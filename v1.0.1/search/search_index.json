{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interation until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])  # Dimensionless.\nsamples = sample(register, block)\n# Interacting qubits as close together.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 35, '10': 35, '01': 30})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket, pulser, visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        protocol: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._protocol = protocol\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code></p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        protocol: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nprotocol=protocol,\nconfiguration=configuration,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.transform(\nself.expectation(values=values, state=state, protocol=protocol, endianness=endianness)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-10-12T17:03:00.615225 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor field in fields(self):\nif not field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {field.name} - Type: {field.type} - Default value: {field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend. Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend. Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        protocol: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, state=None, n_shots=1, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nstate: Tensor | None = None,\nn_shots: int = 1,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>idealized device, least realistic</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>device with realistic specs</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction and loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing. Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates. Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: list[int] | tuple,\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single\n    call to _apply_batch_gate.\"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> 160bb345ce424bdab9f95355d15fe998 0 1be4808b2f16402aa040a6ad9c4c3bd0 X 160bb345ce424bdab9f95355d15fe998--1be4808b2f16402aa040a6ad9c4c3bd0 856e088b6d13466cb460651cefbbfa43 1 d541159b23d64fa8a2dd8b090cd0f303 1be4808b2f16402aa040a6ad9c4c3bd0--d541159b23d64fa8a2dd8b090cd0f303 816c45a7262e499fb014f8b5ea24c9c9 932585cf72474a078daac32fbf5848a4 Y 856e088b6d13466cb460651cefbbfa43--932585cf72474a078daac32fbf5848a4 932585cf72474a078daac32fbf5848a4--816c45a7262e499fb014f8b5ea24c9c9 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> a80f1ae463c24055b83202384d2b22e9 0 fa28e744412d4a33bcb1c99fd274cb30 X a80f1ae463c24055b83202384d2b22e9--fa28e744412d4a33bcb1c99fd274cb30 f215de66656f455eb550f1f9a43ea17c Y fa28e744412d4a33bcb1c99fd274cb30--f215de66656f455eb550f1f9a43ea17c c2d8a5cd90a6484fab6122cee90da4e5 f215de66656f455eb550f1f9a43ea17c--c2d8a5cd90a6484fab6122cee90da4e5 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> 673d50a33e61406cbeaa4a777d76a30c 0 491b8237033b4e08a431cfdb2cc7bbf2 X 673d50a33e61406cbeaa4a777d76a30c--491b8237033b4e08a431cfdb2cc7bbf2 50a04fc9051d4f1eb7a4fd4496b35a15 1 19702cb5a0494dabbc84b4c980015ddd 491b8237033b4e08a431cfdb2cc7bbf2--19702cb5a0494dabbc84b4c980015ddd 214079864f0644ae8d583679d443f4d1 19702cb5a0494dabbc84b4c980015ddd--214079864f0644ae8d583679d443f4d1 cdd55679d51b46ddb73181aaac902ea9 f2790c4a72984a0a9632efe37fd36e57 50a04fc9051d4f1eb7a4fd4496b35a15--f2790c4a72984a0a9632efe37fd36e57 d17443ce38704711a350b237f542f448 Y f2790c4a72984a0a9632efe37fd36e57--d17443ce38704711a350b237f542f448 d17443ce38704711a350b237f542f448--cdd55679d51b46ddb73181aaac902ea9 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> cluster_da81e9f9f95c4550bcc0c1c5d3d06037 081d82fdf2b74476805037a4e0b58e58 0 802a3a7fd63d4ff59cd0a00e9e407663 081d82fdf2b74476805037a4e0b58e58--802a3a7fd63d4ff59cd0a00e9e407663 c9ef660150764722b0e392943e965cfd 1 30d51759d21c4336add43a86ffd60f20 802a3a7fd63d4ff59cd0a00e9e407663--30d51759d21c4336add43a86ffd60f20 654eda8f2da54e60af589ab389979dbf 82ca028808af46cf977639d48df4a55e AddBlock c9ef660150764722b0e392943e965cfd--82ca028808af46cf977639d48df4a55e b55bedca5a634bc4bfed84b8cc492e83 2 82ca028808af46cf977639d48df4a55e--654eda8f2da54e60af589ab389979dbf e24f8c3f513c423b829cfd7094808154 f182138070fb4d8fadb559cde773d029 b55bedca5a634bc4bfed84b8cc492e83--f182138070fb4d8fadb559cde773d029 f182138070fb4d8fadb559cde773d029--e24f8c3f513c423b829cfd7094808154 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> cluster_6fe5b54d9f1f4ee5bb99f7589d26921c cluster_aa331a898b7e46329288a39fdb69cac7 rx 30761c3a0dc5484f9e6189f6053112d8 0 0b71fde233c74a37955d9b5018e9409f X 30761c3a0dc5484f9e6189f6053112d8--0b71fde233c74a37955d9b5018e9409f 2e11eef4e1634ae79f1bd2cb435cc15a 1 b14af9f96d884ebeaf237c9fb7708503 0b71fde233c74a37955d9b5018e9409f--b14af9f96d884ebeaf237c9fb7708503 1cdfee1b797745b7b57d6721349948bc b14af9f96d884ebeaf237c9fb7708503--1cdfee1b797745b7b57d6721349948bc 89e6ba16e87940ec8891f40af6364f8c 1cdfee1b797745b7b57d6721349948bc--89e6ba16e87940ec8891f40af6364f8c 13cdb58a571a4a5c84640ff0941e4443 e32639032a3a4b9db12829986ce6db02 Y 2e11eef4e1634ae79f1bd2cb435cc15a--e32639032a3a4b9db12829986ce6db02 caca0d54ac3f4046a4a1e1f61617f4a2 2 81fc205f07ac4fb7b575a66907dcdcf0 e32639032a3a4b9db12829986ce6db02--81fc205f07ac4fb7b575a66907dcdcf0 d8899d4172fc4879a9be0014a4d16c08 HamEvo 81fc205f07ac4fb7b575a66907dcdcf0--d8899d4172fc4879a9be0014a4d16c08 d8899d4172fc4879a9be0014a4d16c08--13cdb58a571a4a5c84640ff0941e4443 83ff5d7cc62d4721bddfff68593724a7 7d0cc6699eb64150b20eb4014ea5a7ae RX(x) caca0d54ac3f4046a4a1e1f61617f4a2--7d0cc6699eb64150b20eb4014ea5a7ae 8034a66c11da480191e493dab6925b80 3 2bd69cb1195e4ea89a94a663ce5ce773 7d0cc6699eb64150b20eb4014ea5a7ae--2bd69cb1195e4ea89a94a663ce5ce773 29ba730486b940a5b94974e29a005c03 t = 10 2bd69cb1195e4ea89a94a663ce5ce773--29ba730486b940a5b94974e29a005c03 29ba730486b940a5b94974e29a005c03--83ff5d7cc62d4721bddfff68593724a7 f88481c13d9f4569b54a5a2e1daa3854 dd5ddb915c2e4777bce59a998e1a7f2b RX(0.5) 8034a66c11da480191e493dab6925b80--dd5ddb915c2e4777bce59a998e1a7f2b 0412f1311e4b4f0e808652014a203088 X dd5ddb915c2e4777bce59a998e1a7f2b--0412f1311e4b4f0e808652014a203088 0412f1311e4b4f0e808652014a203088--2bd69cb1195e4ea89a94a663ce5ce773 5e821b132e4a475484c11e5fa8458fce 0412f1311e4b4f0e808652014a203088--5e821b132e4a475484c11e5fa8458fce 5e821b132e4a475484c11e5fa8458fce--f88481c13d9f4569b54a5a2e1daa3854 <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, fm_type=\"tower\"), hea(4,2))\n</code></pre> cluster_f3ed530442b34881a2b10a2897a02678 HEA cluster_28a2d98c15d54b02bb85fa3ceb7748d0 FM 39a057926e9d4ec8b3e40388e571c823 0 dcee4c9e30bb48229c728a8c2be11fa8 RX(2*acos(phi)) 39a057926e9d4ec8b3e40388e571c823--dcee4c9e30bb48229c728a8c2be11fa8 8f0b743cded549ca9f6437c28900a572 1 8b647d6a88814abba6532220783313dd RX(theta\u2080) dcee4c9e30bb48229c728a8c2be11fa8--8b647d6a88814abba6532220783313dd 5bed22c711374d0e9b526e84e45383e4 RY(theta\u2084) 8b647d6a88814abba6532220783313dd--5bed22c711374d0e9b526e84e45383e4 f0bf2807ba9641ed8d90f9ba4d6fbdd7 RX(theta\u2088) 5bed22c711374d0e9b526e84e45383e4--f0bf2807ba9641ed8d90f9ba4d6fbdd7 b6a0877343474352b1b086eeeff91067 f0bf2807ba9641ed8d90f9ba4d6fbdd7--b6a0877343474352b1b086eeeff91067 3db1ebe7257c4f89a407131638875678 b6a0877343474352b1b086eeeff91067--3db1ebe7257c4f89a407131638875678 317e97751ac8413a80d0e0f92d3719f8 RX(theta\u2081\u2082) 3db1ebe7257c4f89a407131638875678--317e97751ac8413a80d0e0f92d3719f8 eb139232424a49a58506ace0c314fe29 RY(theta\u2081\u2086) 317e97751ac8413a80d0e0f92d3719f8--eb139232424a49a58506ace0c314fe29 42ee7cff5b644d2aa003c0a229a0f651 RX(theta\u2082\u2080) eb139232424a49a58506ace0c314fe29--42ee7cff5b644d2aa003c0a229a0f651 b2f37c1d086e4b9ba64b7d4b70f3c4d2 42ee7cff5b644d2aa003c0a229a0f651--b2f37c1d086e4b9ba64b7d4b70f3c4d2 f2125fd6cab74dd3879f672665821b57 b2f37c1d086e4b9ba64b7d4b70f3c4d2--f2125fd6cab74dd3879f672665821b57 54a1491f975a4ebd839e0e97029299da f2125fd6cab74dd3879f672665821b57--54a1491f975a4ebd839e0e97029299da 3de43373ffa04fbfa1326fe27e26ed0d 6177d77363204154927ff951dfb06e49 RX(4*acos(phi)) 8f0b743cded549ca9f6437c28900a572--6177d77363204154927ff951dfb06e49 fed559cc35f84e9886f314283fc0787c 2 4f1c307347794a4a99bce489bc1571f6 RX(theta\u2081) 6177d77363204154927ff951dfb06e49--4f1c307347794a4a99bce489bc1571f6 d5a522d4e3784e2b80ad51d9dae0753e RY(theta\u2085) 4f1c307347794a4a99bce489bc1571f6--d5a522d4e3784e2b80ad51d9dae0753e f3b92bf7cd4a4c6aa2724a17f63b58a2 RX(theta\u2089) d5a522d4e3784e2b80ad51d9dae0753e--f3b92bf7cd4a4c6aa2724a17f63b58a2 0e7d0dce1de54b2f887772d9387f9d9b X f3b92bf7cd4a4c6aa2724a17f63b58a2--0e7d0dce1de54b2f887772d9387f9d9b 0e7d0dce1de54b2f887772d9387f9d9b--b6a0877343474352b1b086eeeff91067 fd2bfba19de149ceb6b794a90a322005 0e7d0dce1de54b2f887772d9387f9d9b--fd2bfba19de149ceb6b794a90a322005 bf080398d98244119317170171897f41 RX(theta\u2081\u2083) fd2bfba19de149ceb6b794a90a322005--bf080398d98244119317170171897f41 621473a7bf9e465ca6ef6608fa7aaed1 RY(theta\u2081\u2087) bf080398d98244119317170171897f41--621473a7bf9e465ca6ef6608fa7aaed1 2eda8ce7e8674fcdb82f2b26141d5528 RX(theta\u2082\u2081) 621473a7bf9e465ca6ef6608fa7aaed1--2eda8ce7e8674fcdb82f2b26141d5528 051b0d9d28694ab0b66e7c58703f4fb5 X 2eda8ce7e8674fcdb82f2b26141d5528--051b0d9d28694ab0b66e7c58703f4fb5 051b0d9d28694ab0b66e7c58703f4fb5--b2f37c1d086e4b9ba64b7d4b70f3c4d2 3d96ce5845ec4e668c3af51ea1857ed9 051b0d9d28694ab0b66e7c58703f4fb5--3d96ce5845ec4e668c3af51ea1857ed9 3d96ce5845ec4e668c3af51ea1857ed9--3de43373ffa04fbfa1326fe27e26ed0d 39c1a04839fe4db98758af3e7c8d99bb d3f0eb1856c5407f83bc9908c1a68fa0 RX(6*acos(phi)) fed559cc35f84e9886f314283fc0787c--d3f0eb1856c5407f83bc9908c1a68fa0 6585fae505944fe0b4c0410d292b8f4d 3 f74ae6fe53a04ca9bd1835a118bb31ed RX(theta\u2082) d3f0eb1856c5407f83bc9908c1a68fa0--f74ae6fe53a04ca9bd1835a118bb31ed 0b16f9badfeb4c3da209eb29e493188c RY(theta\u2086) f74ae6fe53a04ca9bd1835a118bb31ed--0b16f9badfeb4c3da209eb29e493188c 79e05cf216f14cb9845166c182d6dcb5 RX(theta\u2081\u2080) 0b16f9badfeb4c3da209eb29e493188c--79e05cf216f14cb9845166c182d6dcb5 d194873b7fd04aeda669c2093fd3bc6e 79e05cf216f14cb9845166c182d6dcb5--d194873b7fd04aeda669c2093fd3bc6e 0ceb7dbaf4024c6faa63edb0d74832dd X d194873b7fd04aeda669c2093fd3bc6e--0ceb7dbaf4024c6faa63edb0d74832dd 0ceb7dbaf4024c6faa63edb0d74832dd--fd2bfba19de149ceb6b794a90a322005 8728a44267634b02b6b38c32925d8b8d RX(theta\u2081\u2084) 0ceb7dbaf4024c6faa63edb0d74832dd--8728a44267634b02b6b38c32925d8b8d b89f07d996594f278d6c88bcba004ea2 RY(theta\u2081\u2088) 8728a44267634b02b6b38c32925d8b8d--b89f07d996594f278d6c88bcba004ea2 6267ded82f0f4458880008825d07eed8 RX(theta\u2082\u2082) b89f07d996594f278d6c88bcba004ea2--6267ded82f0f4458880008825d07eed8 08befb2823e84594bde157bfefac1aa7 6267ded82f0f4458880008825d07eed8--08befb2823e84594bde157bfefac1aa7 034f1ebf8dae4b42b81e9bc761dcedd5 X 08befb2823e84594bde157bfefac1aa7--034f1ebf8dae4b42b81e9bc761dcedd5 034f1ebf8dae4b42b81e9bc761dcedd5--3d96ce5845ec4e668c3af51ea1857ed9 034f1ebf8dae4b42b81e9bc761dcedd5--39c1a04839fe4db98758af3e7c8d99bb 63caf0e7e1454b6fae5ef004d15432c9 645018de14a14659a189095a16dc9d84 RX(8*acos(phi)) 6585fae505944fe0b4c0410d292b8f4d--645018de14a14659a189095a16dc9d84 1b3c685910f3407ebf3474df1bc59ec0 RX(theta\u2083) 645018de14a14659a189095a16dc9d84--1b3c685910f3407ebf3474df1bc59ec0 6c5bddf4573b48afbde36494a6462a2a RY(theta\u2087) 1b3c685910f3407ebf3474df1bc59ec0--6c5bddf4573b48afbde36494a6462a2a f5798bbd201241c1bf60b858b82ad991 RX(theta\u2081\u2081) 6c5bddf4573b48afbde36494a6462a2a--f5798bbd201241c1bf60b858b82ad991 0714fd4a57fc4003b8f47bfa2c5c71bb X f5798bbd201241c1bf60b858b82ad991--0714fd4a57fc4003b8f47bfa2c5c71bb 0714fd4a57fc4003b8f47bfa2c5c71bb--d194873b7fd04aeda669c2093fd3bc6e 28993dae80634b15bacde521dbfaddab 0714fd4a57fc4003b8f47bfa2c5c71bb--28993dae80634b15bacde521dbfaddab 93be301c40bf49abac001950ac294e86 RX(theta\u2081\u2085) 28993dae80634b15bacde521dbfaddab--93be301c40bf49abac001950ac294e86 50b2411640734f4cbe099864cd7d96b0 RY(theta\u2081\u2089) 93be301c40bf49abac001950ac294e86--50b2411640734f4cbe099864cd7d96b0 b0506a1c524e443ab18e5bd9d24f50f3 RX(theta\u2082\u2083) 50b2411640734f4cbe099864cd7d96b0--b0506a1c524e443ab18e5bd9d24f50f3 ab0de9744011435e8c3cfa8c0097af58 X b0506a1c524e443ab18e5bd9d24f50f3--ab0de9744011435e8c3cfa8c0097af58 ab0de9744011435e8c3cfa8c0097af58--08befb2823e84594bde157bfefac1aa7 f60fbb37e38843bfac7d540364d2e1d8 ab0de9744011435e8c3cfa8c0097af58--f60fbb37e38843bfac7d540364d2e1d8 f60fbb37e38843bfac7d540364d2e1d8--63caf0e7e1454b6fae5ef004d15432c9"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/","title":"Digital-Analog Emulation","text":""},{"location":"digital_analog_qc/analog-basics/#from-theory-to-implementation","title":"From theory to implementation","text":"<p>Qadence includes primitives for the construction of Ising-like Hamiltonians to account for custom qubit interaction. This allows to simulate systems close to real quantum computing platforms such as neutral atoms. The general form for time-independent Ising Hamiltonians is</p> \\[ \\mathcal{H} = \\sum_{i} \\frac{\\hbar\\Omega}{2} \\hat\\sigma^x_i - \\sum_{i} \\hbar\\delta \\hat n_i  + \\mathcal{H}_{\\textrm{int}}, \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\hat n = \\frac{1-\\hat\\sigma_z}{2}\\) is the number operator, and \\(\\mathcal{H}_{\\textrm{int}}\\) a pair-wise interaction term. Two central operations implement this Hamiltonian as blocks:</p> <ul> <li><code>WaitBlock</code> by free-evolving \\(\\mathcal{H}_{\\textrm{int}}\\)</li> <li><code>ConstantAnalogRotation</code> by free-evolving \\(\\mathcal{H}\\)</li> </ul> <p>The <code>wait</code> operation can be emulated with an \\(ZZ\\)- (Ising) or an \\(XY\\)-interaction:</p> <pre><code>from qadence import Register, wait, add_interaction, run, Interaction\nblock = wait(duration=3000)\nreg = Register.from_coordinates([(0,0), (0,5)])  # Dimensionless.\nemulated = add_interaction(reg, block, interaction=Interaction.XY)  # or Interaction.ZZ for Ising.\n</code></pre> <pre><code>block = WaitBlock(t=3000.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,)) emulated.generator = AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 29.600] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> <p>The <code>AnalogRot</code> constructor can be used to create a fully customizable <code>ConstantAnalogRotation</code> instances:</p> <pre><code>import torch\nfrom qadence import AnalogRot, AnalogRX\n# Implement a global RX rotation by setting all parameters.\nblock = AnalogRot(\nduration=1000., # [ns]\nomega=torch.pi, # [rad/\u03bcs]\ndelta=0,        # [rad/\u03bcs]\nphase=0,        # [rad]\n)\n# Or use the shortcut.\nblock = AnalogRX(torch.pi)\n</code></pre> <pre><code>AnalogRot = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\nAnalogRX = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\n</code></pre> <p>Automatic emulation in the PyQTorch backend</p> <p>All analog blocks are automatically translated to their emulated version when running them with the PyQTorch backend:</p> <p><pre><code>import torch\nfrom qadence import Register, AnalogRX, sample\nreg = Register.from_coordinates([(0,0), (0,5)])\nsample = sample(reg, AnalogRX(torch.pi))\n</code></pre> <pre><code>sample = [Counter({'00': 40, '10': 32, '01': 28})]\n</code></pre> </p> <p>To compose analog blocks, the regular <code>chain</code> and <code>kron</code> operations can be used under the following restrictions:</p> <ul> <li>The resulting <code>AnalogChain</code> type can only be constructed from <code>AnalogKron</code> blocks   or globally supported primitive analog blocks.</li> <li>The resulting <code>AnalogKron</code> type can only be constructed from non-global   analog blocks with the same duration.</li> </ul> <pre><code>import torch\nfrom qadence import AnalogRot, kron, chain, wait\n# Only analog blocks with a global qubit support can be composed\n# using chain.\nanalog_chain = chain(wait(duration=200), AnalogRot(duration=300, omega=2.0))\n# Only blocks with the same `duration` can be composed using kron.\nanalog_kron = kron(\nwait(duration=1000, qubit_support=(0,1)),\nAnalogRot(duration=1000, omega=2.0, qubit_support=(2,3))\n)\n</code></pre> <pre><code>Analog Chain block = AnalogChain(t=500.000000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u251c\u2500\u2500 WaitBlock(t=200.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=0.600000000000000, t=300, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\nAnalog Kron block = AnalogKron(t=1000, support=(0, 1, 2, 3))\n\u251c\u2500\u2500 WaitBlock(t=1000.0, support=(0, 1))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=2.00000000000000, t=1000, support=(2, 3), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\n</code></pre> <p>Composing digital &amp; analog blocks</p> <p>It is possible to compose digital and analog blocks where the additional restrictions for <code>chain</code> and <code>kron</code> only apply to composite blocks which contain analog blocks only. For further details, see <code>AnalogChain</code> and <code>AnalogKron</code>.</p>"},{"location":"digital_analog_qc/analog-basics/#fitting-a-simple-function","title":"Fitting a simple function","text":"<p>Analog blocks can indeed be parametrized to, for instance, create small ansatze to fit a sine function. When using the <code>pyqtorch</code> backend the <code>add_interaction</code> function is called automatically. As usual, we can choose which differentiation backend we want to use: autodiff or parameter shift rule (PSR).</p> <p>First we define an ansatz block and an observable <pre><code>import torch\nfrom qadence import Register, FeatureParameter, VariationalParameter\nfrom qadence import AnalogRX, AnalogRZ, Z\nfrom qadence import wait, chain, add\npi = torch.pi\n# two qubit register\nreg = Register.from_coordinates([(0, 0), (0, 12)])\n# analog ansatz with input parameter\nt = FeatureParameter(\"t\")\nblock = chain(\nAnalogRX(pi / 2),\nAnalogRZ(t),\nwait(1000 * VariationalParameter(\"theta\", value=0.5)),\nAnalogRX(pi / 2),\n)\n# observable\nobs = add(Z(i) for i in range(reg.n_qubits))\n</code></pre> </p> Plotting functions <code>plot</code> and <code>scatter</code> <p><pre><code>def plot(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.plot(xnp, ynp, **kwargs)\ndef scatter(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.scatter(xnp, ynp, **kwargs)\n</code></pre> </p> <p>Then we define the dataset we want to train on and plot the initial prediction. <pre><code>import matplotlib.pyplot as plt\nfrom qadence import QuantumCircuit, QuantumModel\n# define quantum model; including digital-analog emulation\ncirc = QuantumCircuit(reg, block)\nmodel = QuantumModel(circ, obs, diff_mode=\"gpsr\")\nx_train = torch.linspace(0, 6, steps=30)\ny_train = -0.64 * torch.sin(x_train + 0.33) + 0.1\ny_pred_initial = model.expectation({\"t\": x_train})\nfig, ax = plt.subplots()\nscatter(ax, x_train, y_train, label=\"Training points\", marker=\"o\", color=\"green\")\nplot(ax, x_train, y_pred_initial, label=\"Initial prediction\")\nplt.legend()\n</code></pre> 2023-10-12T17:03:02.266460 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ </p> <p>The rest is the usual PyTorch training routine. <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-2)\ndef loss_fn(x_train, y_train):\nreturn mse_loss(model.expectation({\"t\": x_train}).squeeze(), y_train)\n# train\nn_epochs = 200\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n# if (i + 1) % 10 == 0:\n#     print(f\"Epoch {i+1:0&gt;3} - Loss: {loss.item()}\\n\")\n# visualize\ny_pred = model.expectation({\"t\": x_train})\nfig, ax = plt.subplots()\nscatter(ax, x_train, y_train, label=\"Training points\", marker=\"o\", color=\"green\")\nplot(ax, x_train, y_pred_initial, label=\"Initial prediction\")\nplot(ax, x_train, y_pred, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-10-12T17:03:05.238133 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ </p>"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO oroblem","text":"<p>In this notebook we solve a quadratic unconstrained optimization problem with <code>qadence</code> emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p> Construct QUBO register (defines <code>qubo_register_coords</code> function) <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO is defined by weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Build a register from graph extracted from the QUBO exactly as you would do with Pulser. <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> </p> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian.  Subsequently we add the Ising interaction term to emulate the analog circuit.  This uses a principal quantum number n=70 for the Rydberg level under the hood. <pre><code>from qadence.transpile.emulate import ising_interaction\nLAYERS = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(LAYERS)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\nprint(emulated)\n</code></pre> <pre><code>ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430082484387*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279677658339*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430082484387*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279677658339*s1']]\n</code></pre> </p> <p>Sample the model to get the initial solution. <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> </p> <p>The loss function is defined by averaging over the evaluated bitstrings. <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre>  Here we use a gradient-free optimization loop for reaching the optimal solution. <pre><code>#\nfor i in range(20):\ntry:\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * LAYERS),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\nexcept Exception:\npass\n# sample the optimal solution\nmodel.reset_vparams(res.x)\noptimal_count_dict = model.sample({}, n_shots=1000)[0]\nprint(optimal_count_dict)\n</code></pre> <pre><code>Counter({'00111': 243, '01011': 200, '00100': 103, '01000': 97, '01001': 82, '00110': 72, '00000': 61, '00001': 33, '00010': 25, '10000': 23, '01010': 16, '00101': 14, '10001': 7, '10011': 7, '01111': 5, '10010': 5, '01101': 4, '00011': 2, '01100': 1})\n</code></pre> </p> <pre><code>fig, axs = plt.subplots(1, 2, figsize=(12, 4))\n# known solutions to the QUBO\nsolution_bitstrings=[\"01011\", \"00111\"]\nn_to_show = 20\nxs, ys = zip(*sorted(\ninitial_counts.items(),\nkey=lambda item: item[1],\nreverse=True\n))\ncolors = [\"r\" if x in solution_bitstrings else \"g\" for x in xs]\naxs[0].set_xlabel(\"bitstrings\")\naxs[0].set_ylabel(\"counts\")\naxs[0].bar(xs[:n_to_show], ys[:n_to_show], width=0.5, color=colors)\naxs[0].tick_params(axis=\"x\", labelrotation=90)\naxs[0].set_title(\"Initial solution\")\nxs, ys = zip(*sorted(optimal_count_dict.items(),\nkey=lambda item: item[1],\nreverse=True\n))\ncolors = [\"r\" if x in solution_bitstrings else \"g\" for x in xs]\naxs[1].set_xlabel(\"bitstrings\")\naxs[1].set_ylabel(\"counts\")\naxs[1].bar(xs[:n_to_show], ys[:n_to_show], width=0.5, color=colors)\naxs[1].tick_params(axis=\"x\", labelrotation=90)\naxs[1].set_title(\"Optimal solution\")\nplt.tight_layout()\n</code></pre> 2023-10-12T17:03:06.311174 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-basics/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>The DAQC paradigm is typically implemented on quantum computing hardware based on neutral-atoms where both these computations are realizable.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real neutral-atom devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/daqc-basics/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"DAQC Transform","text":"<p>Digital-analog quantum computing focuses on using simple digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. Such techniques have been shown to be universal for quantum computation <sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>In this tutorial we will exemplify this transformation starting with the representation of a simple digital CNOT using the universality of the Ising Hamiltonian <sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"CNOT with CPHASE","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a CNOT on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the CNOT can be decomposed with two Hadamard and a CPHASE gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nimport qadence as qd\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = qd.chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = qd.product_state(\"10\")\nprint(qd.sample(n_qubits, block = cnot_gate, state = init_state, n_shots = 100))\nprint(qd.sample(n_qubits, block = cnot_decomp, state = init_state, n_shots = 100))\n</code></pre> <pre><code>[Counter({'11': 100})]\n[Counter({'11': 100})]\n</code></pre> <p>The CPHASE gate is fully diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where we used the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)\\), leading to an Ising-like interaction \\(N_iN_j\\) that is common in neutral-atom systems. Let's rebuild the CNOT using this evolution.</p> <pre><code># Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * qd.kron(N(0), N(1))\n# Exponentiating the Hamiltonian\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = qd.block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = qd.block_to_tensor(cphase_evo)\nassert torch.allclose(cphase_matrix, cphase_evo_matrix)\n</code></pre> <p>Now that we have checked the generator of the CPHASE gate, we can use it to apply the CNOT:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = qd.chain(\nH(1),\ncphase_evo,\nH(1)\n)\ninit_state = qd.product_state(\"10\")\nprint(qd.sample(n_qubits, block = cnot_gate, state = init_state, n_shots = 100))\nprint(qd.sample(n_qubits, block = cnot_evo, state = init_state, n_shots = 100))\n</code></pre> <pre><code>[Counter({'11': 100})]\n[Counter({'11': 100})]\n</code></pre> <p>Thus, a CNOT gate can be applied by combining a few single-qubit gates together with a 2-qubit Ising interaction between the control and the target qubit. This is important because it now allows us to exemplify the usage of the Ising transform proposed in the DAQC paper <sup>2</sup>. In the paper, the transform is described for \\(ZZ\\) interactions. In <code>qadence</code> it works both with \\(ZZ\\) and \\(NN\\) interactions.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-3-qubits","title":"CNOT in an interacting system of 3 qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits in a triangular grid. For simplicity let's consider that all qubits interact with each other with an Ising (\\(NN\\)) interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing this interaction over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built:</p> <pre><code>n_qubits = 3\ng_int = 1.0\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * qd.kron(N(i), N(j)))\nh_sys = qd.add(*interaction_list)\nprint(h_sys)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and we cannot isolate the qubits from each other. All we can do is the following:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform single-qubit rotations on individual qubits.</li> </ul> <p>How can we perform a CNOT on two specific qubits of our choice?</p> <p>To perform a fully digital CNOT we would need to isolate the control and target qubit from the third one and have those interact to implement the gate directly. While this may be relatively simple for a 3-qubit system, the experimental burden becomes much greater when we start going into the dozens of qubits.</p> <p>However, with the digital-analog paradigm that is not the case! In fact, we can represent the two qubit Ising interaction required for the CNOT by combining the global system Hamiltonian with a specific set of single-qubit rotations. The full details of this transformation are described in the DAQC paper <sup>2</sup>, and it is available in <code>qadence</code> by calling the <code>daqc_transform</code> function.</p> <p>The <code>daqc_transform</code> function will essentially return a program that represents the evolution of an Hamiltonian \\(H_\\text{target}\\) (target Hamiltonian) for a specified time \\(t_f\\) by using only the evolution of an Hamiltonian \\(H_\\text{build}\\) (build Hamiltonian) for specific intervals of time together with specific single-qubit \\(X\\) rotations. Currently, in <code>qadence</code> it is available for resource and target Hamiltonians composed only of \\(ZZ\\) or \\(NN\\) interactions. The generators are parsed by the <code>daqc_transform</code> function, the appropriate type is automatically determined, and the appropriate single-qubit detunings and global phases are applied.</p> <p>Let's exemplify it for our CNOT problem:</p> <pre><code># The target operation\ni = 0  # Control\nj = 1  # Target\nk = 2  # The extra qubit\n# CNOT on control and target, Identity on the extra qubit\ncnot_target = qd.kron(CNOT(i, j), I(k))\n# The two-qubit Ising (NN) interaction for the CPHASE\nh_int = (-1.0) * qd.kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = qd.daqc_transform(\nn_qubits = 3,        # Total number of qubits in the transformation\ngen_target = h_int,  # The target Ising generator\nt_f = torch.pi,      # The target evolution time\ngen_build = h_sys,   # The building block Ising generator to be used\nstrategy = \"sDAQC\",   # Currently only sDAQC is implemented\nignore_global_phases = False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> cluster_1a7faa2c636344e59a98769b5f113b8b cluster_e39d6392226340f2b1164eee4320f25e cluster_387d18c9a32e48aa8565825d2f259160 cluster_e71bb8f9492f451d9771638cd32cea9b cluster_8b9ed47bd20f45f49894c60e5326432f cluster_dca7b3d248a54be4ab1b5a107e465de6 cluster_165401ef4a524856aa2047d8f57f83b5 a75bbcff75e04f4ab85666a5104af666 0 8a6e188faabb4a33a03151f8b0973a51 HamEvo a75bbcff75e04f4ab85666a5104af666--8a6e188faabb4a33a03151f8b0973a51 ab058d299d164e38b4acd214f599a39b 1 8b6a45d93015409fbedfd0422af7a0ce HamEvo 8a6e188faabb4a33a03151f8b0973a51--8b6a45d93015409fbedfd0422af7a0ce ed04c9f3a7e44d79a421061d1f6c8e08 HamEvo 8b6a45d93015409fbedfd0422af7a0ce--ed04c9f3a7e44d79a421061d1f6c8e08 1af660a739cc4694b082b481dbf38488 X ed04c9f3a7e44d79a421061d1f6c8e08--1af660a739cc4694b082b481dbf38488 6125b36be6e74781acff433cc354da5d HamEvo 1af660a739cc4694b082b481dbf38488--6125b36be6e74781acff433cc354da5d b346cef63f8e43d7b09fe0b2c28e03ba HamEvo 6125b36be6e74781acff433cc354da5d--b346cef63f8e43d7b09fe0b2c28e03ba 1835ad3c0b6e4bcc8a9b593fd5a4ef48 X b346cef63f8e43d7b09fe0b2c28e03ba--1835ad3c0b6e4bcc8a9b593fd5a4ef48 dfdf3086b1ed451da74432427c36942a 1835ad3c0b6e4bcc8a9b593fd5a4ef48--dfdf3086b1ed451da74432427c36942a e9bfa0d90776431ebdf6fbc781e9633a HamEvo dfdf3086b1ed451da74432427c36942a--e9bfa0d90776431ebdf6fbc781e9633a 84a8cbeabef84dae9addc70bc9119434 HamEvo e9bfa0d90776431ebdf6fbc781e9633a--84a8cbeabef84dae9addc70bc9119434 24e9d6468bf34c09959f17fe1972e934 84a8cbeabef84dae9addc70bc9119434--24e9d6468bf34c09959f17fe1972e934 b3f7dad6a78c4e2aa933afec3b9ee107 24e9d6468bf34c09959f17fe1972e934--b3f7dad6a78c4e2aa933afec3b9ee107 d2690e2cedeb4592993a82d1de40c59e be4437fcbb9f43c4874f99a3f03aea6a t = -3.142 ab058d299d164e38b4acd214f599a39b--be4437fcbb9f43c4874f99a3f03aea6a d71cb1f68665435bbc0945c133359157 2 bf10f78fd0b54da8b4b52a7e1244fee9 t = 3.142 be4437fcbb9f43c4874f99a3f03aea6a--bf10f78fd0b54da8b4b52a7e1244fee9 f24d03052dd94e9fa51df2a5f59c7e08 t = -3.142 bf10f78fd0b54da8b4b52a7e1244fee9--f24d03052dd94e9fa51df2a5f59c7e08 069cf6f86b554a0a8751424f6a3ca33f f24d03052dd94e9fa51df2a5f59c7e08--069cf6f86b554a0a8751424f6a3ca33f d3f18c926b114e989bc415396023bead t = 1.571 069cf6f86b554a0a8751424f6a3ca33f--d3f18c926b114e989bc415396023bead 253c860bcd9e442e92445bd66df735b2 t = 1.571 d3f18c926b114e989bc415396023bead--253c860bcd9e442e92445bd66df735b2 018b247f5e3342708bfa45258b21d05d 253c860bcd9e442e92445bd66df735b2--018b247f5e3342708bfa45258b21d05d ac7dde78759344d99b98a77961c0a5e6 X 018b247f5e3342708bfa45258b21d05d--ac7dde78759344d99b98a77961c0a5e6 c4c2f62d05e244459e0d1772fbab1803 t = 1.571 ac7dde78759344d99b98a77961c0a5e6--c4c2f62d05e244459e0d1772fbab1803 d56aafb27e9d491691c17b45c3830327 t = 1.571 c4c2f62d05e244459e0d1772fbab1803--d56aafb27e9d491691c17b45c3830327 9c0751b0ab44481785bbef7955de4014 X d56aafb27e9d491691c17b45c3830327--9c0751b0ab44481785bbef7955de4014 9c0751b0ab44481785bbef7955de4014--d2690e2cedeb4592993a82d1de40c59e 03c9866fdb3042afa12fc81dc9f728c7 f3f5914ad6e84b39b1df7d8d2ba2be46 d71cb1f68665435bbc0945c133359157--f3f5914ad6e84b39b1df7d8d2ba2be46 eb6a23c1788845fa9d3ca21df8b4a306 f3f5914ad6e84b39b1df7d8d2ba2be46--eb6a23c1788845fa9d3ca21df8b4a306 f4f37a5481244aefbe383b79c22e3e31 eb6a23c1788845fa9d3ca21df8b4a306--f4f37a5481244aefbe383b79c22e3e31 389d28077ea7415cbd18c073a71f337b X f4f37a5481244aefbe383b79c22e3e31--389d28077ea7415cbd18c073a71f337b 49d8be2fe97e4f2483de38f8a71535cb 389d28077ea7415cbd18c073a71f337b--49d8be2fe97e4f2483de38f8a71535cb fec458dcbf9f433da61b93e7d4f4ffbb 49d8be2fe97e4f2483de38f8a71535cb--fec458dcbf9f433da61b93e7d4f4ffbb ae9ffd5ed2ca442f816e9d7da1f777b5 X fec458dcbf9f433da61b93e7d4f4ffbb--ae9ffd5ed2ca442f816e9d7da1f777b5 8957f0e18dcf47668a496b3ebac2b9b9 X ae9ffd5ed2ca442f816e9d7da1f777b5--8957f0e18dcf47668a496b3ebac2b9b9 2409a56c428440399e427897b26a2b93 8957f0e18dcf47668a496b3ebac2b9b9--2409a56c428440399e427897b26a2b93 6c7ed7f868e24e34a4cc4f1f77bd1072 2409a56c428440399e427897b26a2b93--6c7ed7f868e24e34a4cc4f1f77bd1072 e6a858f33bf641e9a51f3cd800c5e405 X 6c7ed7f868e24e34a4cc4f1f77bd1072--e6a858f33bf641e9a51f3cd800c5e405 e6a858f33bf641e9a51f3cd800c5e405--03c9866fdb3042afa12fc81dc9f728c7 <p>The circuit above actually only uses two evolutions of the global Hamiltonian. In the displayed circuit also see other instances of <code>HamEvo</code> which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operator. Optionally, the application of the global phases can also be ignored, as shown in the input of <code>daqc_transform</code>. This will not create exactly the same state or operator matrix in tensor form, but in practice they will be equivalent.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case the mapping is exact, since we used the step-wise DAQC technique (sDAQC). In banged DAQC (bDAQC) the mapping is not exact, but is easier to implement on a physical device with always-on interactions such as neutral-atom systems. Currently, only the sDAQC technique is available in <code>qadence</code>.</p> <p>Just as before, we can check that using the transformed Ising circuit we exactly recover the CPHASE gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = qd.block_to_tensor(qd.kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = qd.block_to_tensor(transformed_ising)\n# Will fail if global phases are ignored:\nassert torch.allclose(cphase_matrix, cphase_evo_matrix)\n</code></pre> <p>And we can now build the CNOT gate:</p> <pre><code>cnot_daqc = qd.chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally run the CNOT on a specific 3-qubit initial state:\ninit_state = qd.product_state(\"101\")\n# Check we get an equivalent wavefunction (will still pass if global phases are ignored)\nwf_cnot = qd.run(n_qubits, block = cnot_target, state = init_state)\nwf_daqc = qd.run(n_qubits, block = cnot_daqc, state = init_state)\nassert qd.equivalent_state(wf_cnot, wf_daqc)\n# Visualize the CNOT bit-flip:\nprint(qd.sample(n_qubits, block = cnot_target, state = init_state, n_shots = 100))\nprint(qd.sample(n_qubits, block = cnot_daqc, state = init_state, n_shots = 100))\n</code></pre> <pre><code>[Counter({'111': 100})]\n[Counter({'111': 100})]\n</code></pre> <p>And we are done! We have effectively performed a CNOT operation on our desired target qubits by using only the global interaction of the system as the building block Hamiltonian, together with single-qubit rotations. Going through the trouble of decomposing a single digital gate into its Ising Hamiltonian is certainly not very practical, but it serves as a proof of principle for the potential of this technique to represent universal quantum computation. In the next example, we will see it applied to the digital-analog Quantum Fourier Transform.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a polynomial overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int = 1.0</code>, matching the target Hamiltonian:</p> <pre><code>transformed_ising = qd.daqc_transform(\nn_qubits = 3,\ngen_target = gen_target,\nt_f = 1.0,\ngen_build = gen_build(g_int = 1.0),\n)\n# display(transformed_ising)\n</code></pre> cluster_482805d4b1914878bd37c12dc2f7c522 cluster_654cc49755f744b9afdeb542dd233816 adccfb54b39842c3b000243c0f24fcec 0 d9452e62504a4682ae48cc34ee8cf2ee X adccfb54b39842c3b000243c0f24fcec--d9452e62504a4682ae48cc34ee8cf2ee 9deffbc8efc6479fbd0ec99241dc2ca7 1 8a033dc8b90d4029a3545202c8c8e868 HamEvo d9452e62504a4682ae48cc34ee8cf2ee--8a033dc8b90d4029a3545202c8c8e868 eb0e35fad4904de9b2d06ecc879cb8f4 X 8a033dc8b90d4029a3545202c8c8e868--eb0e35fad4904de9b2d06ecc879cb8f4 b7466f0c38154f689fad5a650d369462 eb0e35fad4904de9b2d06ecc879cb8f4--b7466f0c38154f689fad5a650d369462 862aded97b0d4cebb29d8ddbfc6ecbea HamEvo b7466f0c38154f689fad5a650d369462--862aded97b0d4cebb29d8ddbfc6ecbea 9c677f53f2a248adae76c055182604c1 862aded97b0d4cebb29d8ddbfc6ecbea--9c677f53f2a248adae76c055182604c1 e342917fea044fffa3358488f009081f 9c677f53f2a248adae76c055182604c1--e342917fea044fffa3358488f009081f 7f609730cc824bb9bdaf4c4d659cc1d1 64e10ffa61164a04b46f73388fac0129 9deffbc8efc6479fbd0ec99241dc2ca7--64e10ffa61164a04b46f73388fac0129 c769c18619524a60bcfbc7ace7006ccf 2 a268e004984f489ba456a580c4e6c9de t = -0.500 64e10ffa61164a04b46f73388fac0129--a268e004984f489ba456a580c4e6c9de 25ccb482b4a14be99b5beed0d5668c2b a268e004984f489ba456a580c4e6c9de--25ccb482b4a14be99b5beed0d5668c2b 2f14e0816c1f4a5fb4477d3272928517 X 25ccb482b4a14be99b5beed0d5668c2b--2f14e0816c1f4a5fb4477d3272928517 d219a35edd654dc681d9ea8bd4c1c1ee t = -0.500 2f14e0816c1f4a5fb4477d3272928517--d219a35edd654dc681d9ea8bd4c1c1ee cb100dd9860f41e4a801e67a13973817 X d219a35edd654dc681d9ea8bd4c1c1ee--cb100dd9860f41e4a801e67a13973817 cb100dd9860f41e4a801e67a13973817--7f609730cc824bb9bdaf4c4d659cc1d1 a864a4bf08484679a72e25173c0f6af9 3ee1351419ab49589e6b0abf19671592 X c769c18619524a60bcfbc7ace7006ccf--3ee1351419ab49589e6b0abf19671592 9683201bf916448d83a4de21f4014ecd 3ee1351419ab49589e6b0abf19671592--9683201bf916448d83a4de21f4014ecd b9d5e1115b3648688ed8ccacd1529d0e X 9683201bf916448d83a4de21f4014ecd--b9d5e1115b3648688ed8ccacd1529d0e 57feff90495546d789dec5631c6aec9d X b9d5e1115b3648688ed8ccacd1529d0e--57feff90495546d789dec5631c6aec9d 1d3db0c046dd462c8879a3d4a888ba65 57feff90495546d789dec5631c6aec9d--1d3db0c046dd462c8879a3d4a888ba65 84df33382b3a42928d52b961ac0ea977 X 1d3db0c046dd462c8879a3d4a888ba65--84df33382b3a42928d52b961ac0ea977 84df33382b3a42928d52b961ac0ea977--a864a4bf08484679a72e25173c0f6af9 <p>And we get the transformed circuit. What if our build Hamiltonian has a very weak interaction between qubits 0 and 1?</p> <pre><code>transformed_ising = qd.daqc_transform(\nn_qubits = 3,\ngen_target = gen_target,\nt_f = 1.0,\ngen_build = gen_build(g_int = 0.001),\n)\n# display(transformed_ising)\n</code></pre> cluster_ea2ca90e7e2d4a83a972dbde2faa4d31 cluster_ffcaf515590d449f88051966005baaee ea65d667a62244d785c6f4907c17f529 0 38436185034641e38ede9ce384501e4e X ea65d667a62244d785c6f4907c17f529--38436185034641e38ede9ce384501e4e 9a8936a564b342fb845e0b07e83dcae5 1 644fc69a9ae343a682bde7609e63f3d0 HamEvo 38436185034641e38ede9ce384501e4e--644fc69a9ae343a682bde7609e63f3d0 827a2ca8c5ee4c5aaf1cd71498210203 X 644fc69a9ae343a682bde7609e63f3d0--827a2ca8c5ee4c5aaf1cd71498210203 7af32aa68d18465491b58c9c225ee4db 827a2ca8c5ee4c5aaf1cd71498210203--7af32aa68d18465491b58c9c225ee4db 31381027ecfd4a71897478e2d2efbabe HamEvo 7af32aa68d18465491b58c9c225ee4db--31381027ecfd4a71897478e2d2efbabe fb1b9751e0af46cd86a113b4fcb63752 31381027ecfd4a71897478e2d2efbabe--fb1b9751e0af46cd86a113b4fcb63752 fe59d69e3c8d4f8aa9c383dbca747cf6 fb1b9751e0af46cd86a113b4fcb63752--fe59d69e3c8d4f8aa9c383dbca747cf6 e309f4d90463445fb6f22686f8005def 7c504913d7184be5820804f346d2c254 9a8936a564b342fb845e0b07e83dcae5--7c504913d7184be5820804f346d2c254 291720638d7243db91e69730e9b08aa9 2 da4ed8f9dfda44f08e7b1779c7503a82 t = -500.000000000000 7c504913d7184be5820804f346d2c254--da4ed8f9dfda44f08e7b1779c7503a82 1e13db90b30f471aa2ba8b066591fd18 da4ed8f9dfda44f08e7b1779c7503a82--1e13db90b30f471aa2ba8b066591fd18 a33082dea8c84b85b962c8a999a53ac7 X 1e13db90b30f471aa2ba8b066591fd18--a33082dea8c84b85b962c8a999a53ac7 7c56166b1b8c43958e952efbd3da1641 t = -500.000000000000 a33082dea8c84b85b962c8a999a53ac7--7c56166b1b8c43958e952efbd3da1641 2fb7b4321b654580afdae851ec885dd2 X 7c56166b1b8c43958e952efbd3da1641--2fb7b4321b654580afdae851ec885dd2 2fb7b4321b654580afdae851ec885dd2--e309f4d90463445fb6f22686f8005def 32c10a85d8834894adaaf2c027584fe5 dc1d2d556f784517a78ce6c2cc51627a X 291720638d7243db91e69730e9b08aa9--dc1d2d556f784517a78ce6c2cc51627a bef1e20afdae4b3a85dca66d6dca4431 dc1d2d556f784517a78ce6c2cc51627a--bef1e20afdae4b3a85dca66d6dca4431 a3fa9927208746cda8a99cdcff9a5749 X bef1e20afdae4b3a85dca66d6dca4431--a3fa9927208746cda8a99cdcff9a5749 1530c793a99948c8af962b5801c0615d X a3fa9927208746cda8a99cdcff9a5749--1530c793a99948c8af962b5801c0615d e04c54d05e514ec5a76580f596dcf5a0 1530c793a99948c8af962b5801c0615d--e04c54d05e514ec5a76580f596dcf5a0 8ecd32bfef6a46fc856ddcad26c2e9bb X e04c54d05e514ec5a76580f596dcf5a0--8ecd32bfef6a46fc856ddcad26c2e9bb 8ecd32bfef6a46fc856ddcad26c2e9bb--32c10a85d8834894adaaf2c027584fe5 <p>As we can see, to represent the same interaction between 0 and 1, the slices using the build Hamiltonian need to evolve for much longer, since the target interaction is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present at all, the transform will not work:</p> <pre><code>try:\ntransformed_ising = qd.daqc_transform(\nn_qubits = 3,\ngen_target = gen_target,\nt_f = 1.0,\ngen_build = gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires deep knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future.</p> <p>Let's see it in action.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying Hamiltonian it constructs is equivalent to a digital-analog quantum computing program with the following interaction Hamiltonian (see digital-analog emulation for more details):</p> \\[ \\mathcal{H}_{int} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction coefficient which depends on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are the atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) is the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to evolve for a specific time according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#two-qubits-register-bell-state","title":"Two qubits register: Bell state","text":"<p>Using the <code>chain</code> block makes it easy to create a gate sequence. Here is an example of how to create a Bell state. The <code>entangle</code> operation uses <code>CZ</code> interactions (according to the interaction Hamiltonian introduced in the first paragraph of this section) to entangle states on the <code>X</code> basis. We move the qubits back to the <code>Z</code> basis for the readout using a <code>Y</code> rotation.</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <p>To convert the chain block into a pulse sequence, we define a <code>Register</code> with two qubits and combine it to create a circuit as usual. Then we construct a <code>QuantumModel</code> with a Pulser backend to convert it into a proper parametrized pulse sequence. Supplying the parameter values allows to sample from the pulse sequence result like any other Qadence backend.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# return the final state vector\nfinal_vector = model.run(params)\nprint(final_vector)\n# sample from the result state vector and plot the distribution\nsample = model.sample(params, n_shots=50)[0]\nprint(sample)\nfig, ax = plt.subplots()\nax.bar(sample.keys(), sample.values())\n</code></pre>   tensor([[-0.7080-0.0207j,  0.0395+0.3061j,  0.0039-0.0540j,  0.6220-0.1151j]]) Counter({'00': 27, '11': 18, '01': 5})  2023-10-12T17:03:07.249669 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-10-12T17:03:07.304087 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, the Pulser one provides the concept of <code>Device</code>, inherited from the Pulser. Check this tutorial for more information.</p> <p>A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for the pulses, the maximum distance between two qubits and the maximum duration of the pulse.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not have any limitation in what pulse sequences can run with it.</li> <li><code>REALISTIC</code>: device specification very similar to a real neutral atom quantum processor.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=\"pulser\",\ndiff_mode=\"gpsr\",\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# sample from the result state vector and plot the distribution\nsample = model.sample(params, n_shots=50)[0]\nprint(sample)\n</code></pre>   Counter({'00': 26, '01': 18, '11': 6})"},{"location":"digital_analog_qc/pulser-basic/#create-your-own-gate","title":"Create your own gate","text":"<p>A big advantage of using the block-based interface if  Qadence is that it makes it easy to create complex operations from simple ones as a block composition. In the following, we use the entanglement operation as an example.</p> <p>The operation consists of moving all the qubits to the <code>X</code> basis having the atoms' interaction perform a controlled-Z operation during the free evolution. And we can easily recreate this pattern using the <code>wait</code> (corresponding to free evolution) and <code>AnalogRY</code> blocks with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode='gpsr')\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\nfig, ax = plt.subplots()\nplt.bar(sample.keys(), sample.values())\n</code></pre> 2023-10-12T17:03:07.545164 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-10-12T17:03:07.614570 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system. A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on. Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations such as single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks. Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks. Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time). Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time). Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian</p> <pre><code>H = \u2211\u1d62(h\u03a9/2 sin(\u03c6)*X\u1d62 - cos(\u03c6)*Y\u1d62 - h\u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits. In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interation</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially. On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially. On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically. On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically. On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks. Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially. Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed). Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally. Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.5034+0.1645j, -0.2575-0.4773j, -0.1863-0.2398j, -0.5771+0.0125j],\n[ 0.0301-0.4791j,  0.5561+0.0912j, -0.5891-0.2234j, -0.1547-0.1766j],\n[-0.1238-0.5348j, -0.3862-0.0394j,  0.2656+0.1068j, -0.1997-0.6528j],\n[-0.3733-0.2200j, -0.1777-0.4539j,  0.0268-0.6544j,  0.3337+0.1853j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"chebyshev\")\nreturn tag(fm, tag=\"ChebyshevFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nif support is None:\nsupport = tuple(range(n_qubits))\nxmax = max(feature_range)\nxmin = min(feature_range)\nx = Parameter(param, trainable=False)\n# The feature map works on the range of 0 to 2**n\nx_rescaled = 2 * np.pi * (x - xmin) / (xmax - xmin)\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = kron(RZ(support[i], x_rescaled * (2**i)) for i in range(n_qubits))\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type='fourier')</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Overrides <code>n_qubits</code>. Puts one rotation gate on every qubit in <code>support</code>.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map.</p> <p> TYPE: <code>Type[Rotation]</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Determines the additional expression the final feature parameter (the addtional term in front of <code>param</code>). <code>\"fourier\": param</code> (nothing is done to <code>param</code>) <code>\"chebyshev\": 2*acos(param)</code>, <code>\"tower\": (i+1)*2*acos(param)</code> (where <code>i</code> is the qubit index).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <p>Example: <pre><code>from qadence import feature_map\nfm = feature_map(3, fm_type=\"fourier\")\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=\"chebyshev\")\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=\"tower\")\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['2*acos(phi)']]\nfm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['4*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['6*acos(phi)']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"phi\",\nop: Type[Rotation] = RX,\nfm_type: str = \"fourier\",\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Overrides `n_qubits`. Puts one rotation gate on every qubit in `support`.\n        param: Parameter of the feature map.\n        op: Rotation operation of the feature map.\n        fm_type: Determines the additional expression the final feature parameter (the addtional\n            term in front of `param`). `\"fourier\": param` (nothing is done to `param`)\n            `\"chebyshev\": 2*acos(param)`, `\"tower\": (i+1)*2*acos(param)` (where `i` is the qubit\n            index).\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map\n    fm = feature_map(3, fm_type=\"fourier\")\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=\"chebyshev\")\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=\"tower\")\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\nfparam = FeatureParameter(param)\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif fm_type == \"fourier\":\nfm = kron(*[op(qubit, fparam) for qubit in support])\nelif fm_type == \"chebyshev\":\nfm = kron(*[op(qubit, 2 * sympy.acos(fparam)) for qubit in support])\nelif fm_type == \"tower\":\nfm = kron(*[op(qubit, (i + 1) * 2 * sympy.acos(fparam)) for i, qubit in enumerate(support)])\nelse:\nraise NotImplementedError(f\"Feature map {fm_type} not implemented\")\nfm.tag = \"FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"fourier\")\nreturn tag(fm, tag=\"FourierFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"tower\")\nreturn tag(fm, tag=\"TowerFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers using step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers\n    using step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian with another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian\n    with another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"\n    Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments (see in the examples).</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments\n    (see in the examples).\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function. The default value of each field can be customize with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x28ca97e50&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x28ca97310&gt;, batch_size=1)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>. Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.data_to_model","title":"<code>data_to_model(xs, device='cpu')</code>","text":"<p>Default behavior for single-dispatched function</p> <p>Just return the given data independently on the type</p> PARAMETER  DESCRIPTION <code>xs</code> <p>the input data</p> <p> TYPE: <code>Any</code> </p> <code>device</code> <p>The torch device. Not used in this implementation.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>the <code>xs</code> argument untouched</p> <p> TYPE: <code>Any</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>@singledispatch\ndef data_to_model(xs: Any, device: str = \"cpu\") -&gt; Any:\n\"\"\"Default behavior for single-dispatched function\n    Just return the given data independently on the type\n    Args:\n        xs (Any): the input data\n        device (str, optional): The torch device. Not used in this implementation.\n    Returns:\n        Any: the `xs` argument untouched\n    \"\"\"\nreturn xs\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs, device='cpu')</code>","text":"<p>Default Torch optimize step with closure</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> <code>device</code> <p>The device were computations are executed. Defaults to \"cpu\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\ndevice: str = \"cpu\",\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n        device (str, optional): The device were computations are executed.\n            Defaults to \"cpu\".\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence.constructors import hamiltonian_factory, hea, feature_map\n    from qadence import chain, Parameter, QuantumCircuit, Z\n    from qadence.models import QNN\n    from qadence.ml_tools import train_with_grad, TrainConfig\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n        batch_size=batch_size,\n    )\n    batch_size = 25\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    train_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\nassert loss_fn is not None, \"Provide a valid loss function\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nif isinstance(dataloader, (list, tuple)):\nfrom qadence.ml_tools.data import to_dataloader\nassert len(dataloader) == 2, \"Please provide exactly two torch tensors.\"\nx, y = dataloader\ndataloader = to_dataloader(x=x, y=y, batch_size=config.batch_size)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, dataloader, device=device\n)\nloss = loss.item()\n# single epoch with DictDataloader using a single iteration method\n# DictDataloader returns a single sample of the data\n# with a given batch size decided when the dataloader is defined\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data, device=device)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\n# TODO: make sure to average metrics as well\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, data, device=device\n)\nrunning_loss += loss.item()\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nrunning_loss += loss\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> A block implementing the Hamiltonian evolution operation H where <p>H = exp(-iG, t)</p> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.2719-5.6199e-17j, -0.7859+3.4726e-17j],\n[ 1.1563-3.9082e-17j, -0.5805+1.9620e-17j]])\ntensor([[1.3878-0.3013j, 0.1284-0.0967j],\n[1.7438-0.7405j, 0.2479-0.2353j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation. Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation. Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=np.pi / 2)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names. This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['e83d7a59-0200-4049-a9e8-9c64e8cf394c', 'a87750dd-ad66-40d2-a79f-e52a949f3e26'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code> to include two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters. Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"PARAMETER  DESCRIPTION <code>name</code> <p>When given a string only, the class constructs a trainable Parameter with a a randomly initialized value.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> </p> <code>**assumptions</code> <p>are passed on to the parent class <code>sympy.Symbol</code>. Two new assumption kwargs are supported by this constructor: <code>trainable: bool</code>, and <code>value: TNumber</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>from qadence import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.4794504055083816\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = torch.rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> <code>values</code> <p>values dict which contains values for the Parameters, if empty, Parameter.value will be used.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>as_torch</code> <p>Whether to retrieve a torch-differentiable expression result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.1160196184796376\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn torch.Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: torch.tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[expr], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>A QuantumCircuit instance is completely abstract and it needs to be passed to a quantum backend in order to be executed.</p> PARAMETER  DESCRIPTION <code>support</code> <p><code>Register</code> or number of qubits. If an integer is provided, a register is constructed with <code>Register.all_to_all(x)</code></p> <p> TYPE: <code>int | Register</code> </p> <code>*blocks</code> <p>(Possibly multiple) blocks to construct the circuit from.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag</p> <p>This function recurservily explores all composite blocks to find all the occurrences of a certain tag in the blocks</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag\n    This function recurservily explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates (needed for e.g. analog computing). The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates (needed for e.g. analog\n    computing). The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5f8cb184-8c4c-4dca-a635-29edefce2767', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9256455905063217'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a767436a-b5e2-4427-83e6-77b3b9653c8b', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.2761860032683078'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4c1b3f0a-41d4-48c3-ac73-e1100d04995c', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.3431735922025061'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2be69ced-5038-4e75-85fd-34653165eeb2', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.22890485647276537'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a58c8ac6-215c-40d5-aabb-40bf4984dad9', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.43231338587278156'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c2ed63f4-79d3-4efe-8658-c65a24d76fbb', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.21562456614937775'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0978dba5-3a38-449b-840e-32886ad463bd', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.7804281301994218'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('51d891c7-a11b-4ba3-a65e-367bc2be0c4a', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1183504577113843'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('336cf958-9ffa-4ec9-a30e-d3a9d4be8b3a', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.5368528594854806'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('1fceab67-578a-48e7-8002-cf653b32c5f4', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.9740934558296818'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a76d3e13-7145-4adf-a751-27acfc1e5ab5', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.07339806211741362'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('08d578dd-778b-4fe8-aadf-b2369f3257fa', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.24026971249743434'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>10001111\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.backend import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3215+0.2041j, -0.0156-0.1371j, -0.6557+0.5829j, -0.0965-0.2386j]])\ntensor([[ 0.7423-0.6664j, -0.0467-0.0520j,  0.0000+0.0000j,  0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.backend import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = _run_state(_abstract_random_state(n_qubits, batch_size), backend)  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation. Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation. Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\nkronblocks = block.blocks  # type: ignore[attr-defined]\nn_blocks = len(kronblocks)\nchains = []\nfor qb_idx in range(block.n_qubits):\nprim_gates = []\nfor kron_idx in range(n_blocks):\nprim_gates.append(kronblocks[kron_idx][qb_idx])  # type: ignore[index]\nchains.append(chain(*prim_gates))\ntry:\nreturn kron(*chains)\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.flatten","title":"<code>flatten(block, types=[ChainBlock, KronBlock, AddBlock])</code>","text":"<p>Flattens the given types of <code>CompositeBlock</code>s if possible.</p> <p>Example: <pre><code>from qadence import chain, kron, X\nfrom qadence.transpile import flatten\nfrom qadence.blocks import ChainBlock, KronBlock, AddBlock\nx = chain(chain(chain(X(0))), kron(kron(X(0))))\n# flatten only `ChainBlock`s\nassert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n# flatten `ChainBlock`s and `KronBlock`s\nassert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n# flatten `AddBlock`s (does nothing in this case)\nassert flatten(x, [AddBlock]) == x\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def flatten(block: AbstractBlock, types: list = [ChainBlock, KronBlock, AddBlock]) -&gt; AbstractBlock:\n\"\"\"Flattens the given types of `CompositeBlock`s if possible.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import chain, kron, X\n    from qadence.transpile import flatten\n    from qadence.blocks import ChainBlock, KronBlock, AddBlock\n    x = chain(chain(chain(X(0))), kron(kron(X(0))))\n    # flatten only `ChainBlock`s\n    assert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n    # flatten `ChainBlock`s and `KronBlock`s\n    assert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n    # flatten `AddBlock`s (does nothing in this case)\n    assert flatten(x, [AddBlock]) == x\n    ```\n    \"\"\"\nif isinstance(block, CompositeBlock):\ndef fn(b: AbstractBlock, T: Type) -&gt; AbstractBlock:\nreturn _construct(type(block), tuple(_flat_blocks(b, T)))\nreturn reduce(fn, types, block)  # type: ignore[arg-type]\nelif isinstance(block, ScaleBlock):\nblk = deepcopy(block)\nblk.block = flatten(block.block, types=types)\nreturn blk\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks, move the scale all the way down into the leaves of the block tree.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"When given a scaled CompositeBlock consisting of several PrimitiveBlocks,\n    move the scale all the way down into the leaves of the block tree.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks and reassigning qubit locations approriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks and reassigning\n    qubit locations approriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.emulate.add_interaction","title":"<code>add_interaction(x, *args, interaction=Interaction.NN, spacing=1.0)</code>","text":"<p>Turns blocks or circuits into (a chain of) <code>HamEvo</code> blocks including a chosen interaction term.</p> <p>This is a <code>@singledipatch</code>ed function which can be called in three ways:</p> <ul> <li>With a <code>QuantumCircuit</code> which contains all necessary information: <code>add_interaction(circuit)</code></li> <li>With a <code>Register</code> and an <code>AbstractBlock</code>: <code>add_interaction(reg, block)</code></li> <li>With an <code>AbstractBlock</code> only: <code>add_interaction(block)</code></li> </ul> <p>See the section about analog blocks for detailed information about how which types of blocks are translated.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit or block to be emulated. See the examples on which argument combinations are accepted.</p> <p> TYPE: <code>Register | QuantumCircuit | AbstractBlock</code> </p> <code>interaction</code> <p>Type of interaction that is added. Can also be a function that accepts a register and a list of edges that define which qubits interact (see the examples).</p> <p> TYPE: <code>Interaction | Callable</code> DEFAULT: <code>NN</code> </p> <code>spacing</code> <p>All qubit coordinates are multiplied by <code>spacing</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import QuantumCircuit, AnalogRX, add_interaction\nc = QuantumCircuit(2, AnalogRX(2.0))\ne = add_interaction(c)\n</code></pre> <pre><code>[mul: 0.0] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 AddBlock(0,1)\n\u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u251c\u2500\u2500 [mul: 1.571] \u2502       \u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u2502       \u251c\u2500\u2500 AddBlock(0)\n\u2502       \u2502       \u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502       \u2502   \u2502   \u2514\u2500\u2500 X(0)\n\u2502       \u2502       \u2502   \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502       \u2502       \u2514\u2500\u2500 Y(0)\n\u2502       \u2502       \u2514\u2500\u2500 AddBlock(1)\n\u2502       \u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502           \u2502   \u2514\u2500\u2500 X(1)\n\u2502       \u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502               \u2514\u2500\u2500 Y(1)\n\u2502       \u2514\u2500\u2500 [mul: 0.0] \u2502           \u2514\u2500\u2500 AddBlock(0,1)\n\u2502               \u251c\u2500\u2500 N(0)\n\u2502               \u2514\u2500\u2500 N(1)\n\u2514\u2500\u2500 AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 865723.020] \u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 N(0)\n\u2514\u2500\u2500 N(1)\n</code></pre>  You can also use <code>add_interaction</code> directly on a block, but you have to provide either the <code>Register</code> or define a non-global qubit support. <pre><code>from qadence import AnalogRX, Register, add_interaction\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b)\n# or provide only the block with local qubit support\n# in this case the register is created via `Register(b.n_qubits)`\ne = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\nprint(e.generator)\n</code></pre> <pre><code>[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n</code></pre>  You can specify a custom <code>interaction</code> function which has to accept a <code>Register</code> and a list of <code>edges: list[tuple[int, int]]</code>: <pre><code>from qadence import AnalogRX, Register, add_interaction\nfrom qadence.transpile.emulate import ising_interaction\ndef int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n# do either something completely custom\n# ...\n# or e.g. change the default kwargs to `ising_interaction`\nreturn ising_interaction(r, pairs, rydberg_level=70)\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b, interaction=int_fn)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/emulate.py</code> <pre><code>@singledispatch\ndef add_interaction(\nx: Register | QuantumCircuit | AbstractBlock,\n*args: Any,\ninteraction: Interaction | Callable = Interaction.NN,\nspacing: float = 1.0,\n) -&gt; QuantumCircuit | AbstractBlock:\n\"\"\"Turns blocks or circuits into (a chain of) `HamEvo` blocks including a\n    chosen interaction term.\n    This is a `@singledipatch`ed function which can be called in three ways:\n    * With a `QuantumCircuit` which contains all necessary information: `add_interaction(circuit)`\n    * With a `Register` and an `AbstractBlock`: `add_interaction(reg, block)`\n    * With an `AbstractBlock` only: `add_interaction(block)`\n    See the section about [analog blocks](/digital_analog_qc/analog-basics.md) for\n    detailed information about how which types of blocks are translated.\n    Arguments:\n        x: Circuit or block to be emulated. See the examples on which argument\n            combinations are accepted.\n        interaction: Type of interaction that is added. Can also be a function that accepts a\n            register and a list of edges that define which qubits interact (see the examples).\n        spacing: All qubit coordinates are multiplied by `spacing`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import QuantumCircuit, AnalogRX, add_interaction\n    c = QuantumCircuit(2, AnalogRX(2.0))\n    e = add_interaction(c)\n    print(str(e.block.generator)) # markdown-exec: hide\n    ```\n    You can also use `add_interaction` directly on a block, but you have to provide either\n    the `Register` or define a non-global qubit support.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b)\n    print(e.generator) # markdown-exec: hide\n    # or provide only the block with local qubit support\n    # in this case the register is created via `Register(b.n_qubits)`\n    e = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\n    print(e.generator)\n    ```\n    You can specify a custom `interaction` function which has to accept a `Register` and a list\n    of `edges: list[tuple[int, int]]`:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    from qadence.transpile.emulate import ising_interaction\n    def int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n        # do either something completely custom\n        # ...\n        # or e.g. change the default kwargs to `ising_interaction`\n        return ising_interaction(r, pairs, rydberg_level=70)\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b, interaction=int_fn)\n    ```\n    \"\"\"\nraise ValueError(f\"`add_interaction` is not implemented for {type(x)}\")\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, torch.Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[torch.Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, torch.Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in - <code>add_interaction</code>. - <code>hamiltonian_factory</code>.</p>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML) [^1] in particular are the target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\nfp = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(RX(i, 2 * acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(feature_map, values=inputs)\nprint(samples)\n</code></pre>   [Counter({'0000': 19, '1000': 15, '0100': 9, '0001': 8, '0010': 8, '0101': 6, '1010': 6, '0011': 5, '1001': 4, '1100': 4, '1101': 4, '0111': 3, '1110': 3, '0110': 2, '1011': 2, '1111': 2}), Counter({'0000': 28, '1000': 14, '0001': 11, '0100': 8, '0010': 7, '1010': 7, '1100': 6, '0110': 4, '1101': 4, '0111': 3, '0011': 2, '1001': 2, '0101': 1, '1011': 1, '1110': 1, '1111': 1}), Counter({'1111': 29, '0111': 13, '1011': 11, '1110': 10, '1101': 8, '0011': 4, '0101': 4, '1010': 4, '0010': 3, '0110': 3, '1000': 3, '1001': 3, '0001': 2, '0000': 1, '0100': 1, '1100': 1})]    <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansaztz and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\nprint(f\"Quantum model output: {out}\")\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre>   Quantum model output: tensor([[ 0.3380],         [ 0.3526],         [ 0.0839],         [ 0.4578],         [ 0.4946],         [ 0.3522],         [ 0.0447],         [-0.0138],         [ 0.2831],         [-0.0146]], grad_fn=) First-order derivative w.r.t. the feature parameter: tensor([ -1.1865,   2.6427,   1.5276,  -0.9308,   2.4990, -13.1417,   1.1742,          -0.1297,  -1.2414,  -0.0503], grad_fn=)    <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n</code></pre>   First-order derivative w.r.t. the feature parameter: tensor([ -1.1865,   2.6427,   1.5276,  -0.9308,   2.4990, -13.1417,   1.1742,          -0.1297,  -1.2414,  -0.0503], grad_fn=)    <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-10-12T17:03:09.081843 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> cluster_66ab54376cf449aebbc5916c585f1c67 cost cluster_09f8f46b703e4d31a17c3fd412817976 mixing cluster_4cc85d863e1041bc88ed69b991b44160 mixing cluster_ec7a86899b4b491194ba2914fefb8db2 cost 33e5612a1e0a4290ac9396ffe776fb4a 0 7fa1c06ce4ff40b1bab0ead4633de384 33e5612a1e0a4290ac9396ffe776fb4a--7fa1c06ce4ff40b1bab0ead4633de384 ac9bab06f0034766b65d918600493f11 1 ede7919e31bd45279dc53d6c53f5a8b7 7fa1c06ce4ff40b1bab0ead4633de384--ede7919e31bd45279dc53d6c53f5a8b7 ef4ea064f6fd42b2b807b95e807de6f3 ede7919e31bd45279dc53d6c53f5a8b7--ef4ea064f6fd42b2b807b95e807de6f3 a1a9f61992c045cc9e384c9d2fa26e50 ef4ea064f6fd42b2b807b95e807de6f3--a1a9f61992c045cc9e384c9d2fa26e50 b95b3da564574a43adc8fcd07c8a455a a1a9f61992c045cc9e384c9d2fa26e50--b95b3da564574a43adc8fcd07c8a455a 43c53bfd2677490ca917b8528ebb3ac3 b95b3da564574a43adc8fcd07c8a455a--43c53bfd2677490ca917b8528ebb3ac3 65d0ede2def649fa94c7f878a9464c6d 43c53bfd2677490ca917b8528ebb3ac3--65d0ede2def649fa94c7f878a9464c6d 246bd65ee0ee488fb4910bfe6f477315 65d0ede2def649fa94c7f878a9464c6d--246bd65ee0ee488fb4910bfe6f477315 30621cd5c36f40e1bd500191fbea4762 246bd65ee0ee488fb4910bfe6f477315--30621cd5c36f40e1bd500191fbea4762 05785335ae214ba9af2be561751e09b8 30621cd5c36f40e1bd500191fbea4762--05785335ae214ba9af2be561751e09b8 9dad6474a0a246278d00dfb5acc78f15 05785335ae214ba9af2be561751e09b8--9dad6474a0a246278d00dfb5acc78f15 56bd5ce19b6b4f99aaf7e1e06b474a42 9dad6474a0a246278d00dfb5acc78f15--56bd5ce19b6b4f99aaf7e1e06b474a42 a11c2f6a024f4ee19a01b33b94bcbd19 56bd5ce19b6b4f99aaf7e1e06b474a42--a11c2f6a024f4ee19a01b33b94bcbd19 2989a69d88e04ff88ef6a4fb589b70f3 a11c2f6a024f4ee19a01b33b94bcbd19--2989a69d88e04ff88ef6a4fb589b70f3 fb7f861850204563975c2b306e8c9b2b 2989a69d88e04ff88ef6a4fb589b70f3--fb7f861850204563975c2b306e8c9b2b b30e6b031c064efabb825a0260d04509 fb7f861850204563975c2b306e8c9b2b--b30e6b031c064efabb825a0260d04509 da43618fb96b4b91ad172db38cb8cef7 b30e6b031c064efabb825a0260d04509--da43618fb96b4b91ad172db38cb8cef7 4e49d1aa21c24d1abafad5144e96729f da43618fb96b4b91ad172db38cb8cef7--4e49d1aa21c24d1abafad5144e96729f aed6acc93c5b4193a01a71ffd623e5a7 4e49d1aa21c24d1abafad5144e96729f--aed6acc93c5b4193a01a71ffd623e5a7 1802ac766a8c4cf6bc835d10ba0daf6f aed6acc93c5b4193a01a71ffd623e5a7--1802ac766a8c4cf6bc835d10ba0daf6f 11218eec3eb44084b7b75d90722541a3 1802ac766a8c4cf6bc835d10ba0daf6f--11218eec3eb44084b7b75d90722541a3 594499747029441ca6f17ab31bae9a3d 11218eec3eb44084b7b75d90722541a3--594499747029441ca6f17ab31bae9a3d 1a42bed5db774484a469e4c15226ffd1 594499747029441ca6f17ab31bae9a3d--1a42bed5db774484a469e4c15226ffd1 7f09be2655dc44b1afe11c91f3dfd6ef 1a42bed5db774484a469e4c15226ffd1--7f09be2655dc44b1afe11c91f3dfd6ef a504137d8abd429bb6793e7f772dacac 7f09be2655dc44b1afe11c91f3dfd6ef--a504137d8abd429bb6793e7f772dacac 102f633183f740bebe9274466701fc17 a504137d8abd429bb6793e7f772dacac--102f633183f740bebe9274466701fc17 5445e8e55f124b7daefc1362ba53749a 102f633183f740bebe9274466701fc17--5445e8e55f124b7daefc1362ba53749a 307b93b9cd5b4b09b173307fec120a79 5445e8e55f124b7daefc1362ba53749a--307b93b9cd5b4b09b173307fec120a79 55cbf0ad860949cea8848c6fea2c9a81 307b93b9cd5b4b09b173307fec120a79--55cbf0ad860949cea8848c6fea2c9a81 230f4682bf0f4aa9888557741d82f649 55cbf0ad860949cea8848c6fea2c9a81--230f4682bf0f4aa9888557741d82f649 f124e855859646a6a0ecfd201abba731 230f4682bf0f4aa9888557741d82f649--f124e855859646a6a0ecfd201abba731 4ce9651c31c043f38e3631a8eeb7493a f124e855859646a6a0ecfd201abba731--4ce9651c31c043f38e3631a8eeb7493a e9c6672a65c94bdc82d77a4de71ceb1b 4ce9651c31c043f38e3631a8eeb7493a--e9c6672a65c94bdc82d77a4de71ceb1b 1d8ee3a143614237b99dae57d917145e e9c6672a65c94bdc82d77a4de71ceb1b--1d8ee3a143614237b99dae57d917145e 8acb9741275a4be88494e9af3ac36707 1d8ee3a143614237b99dae57d917145e--8acb9741275a4be88494e9af3ac36707 3ff41adc7c314a0587a5a70dc3f8ab6e 8acb9741275a4be88494e9af3ac36707--3ff41adc7c314a0587a5a70dc3f8ab6e e720a9fc7d6245809a39d9991f79d01b 3ff41adc7c314a0587a5a70dc3f8ab6e--e720a9fc7d6245809a39d9991f79d01b 070821b911504d55a1a2586821376de6 e720a9fc7d6245809a39d9991f79d01b--070821b911504d55a1a2586821376de6 39bb35c438d34c95b37574a9ae0379c6 070821b911504d55a1a2586821376de6--39bb35c438d34c95b37574a9ae0379c6 ee867f95430841c9a27744dd502cda28 39bb35c438d34c95b37574a9ae0379c6--ee867f95430841c9a27744dd502cda28 cd3f42bfb7b141ab8eea36a04054e1ef ee867f95430841c9a27744dd502cda28--cd3f42bfb7b141ab8eea36a04054e1ef ffa2f1cd97da41d98be9314429a8479b cd3f42bfb7b141ab8eea36a04054e1ef--ffa2f1cd97da41d98be9314429a8479b b932a3e619a74c0fb2a457668b1a4969 ffa2f1cd97da41d98be9314429a8479b--b932a3e619a74c0fb2a457668b1a4969 8ad0ef4ba8d6432dacebad4be1616fe9 b932a3e619a74c0fb2a457668b1a4969--8ad0ef4ba8d6432dacebad4be1616fe9 96cdfac0436d4bcf8561f436702b7913 8ad0ef4ba8d6432dacebad4be1616fe9--96cdfac0436d4bcf8561f436702b7913 cc16a2c82247448da006635382358322 96cdfac0436d4bcf8561f436702b7913--cc16a2c82247448da006635382358322 948a06dbb90c46b38b555e0d78f83087 cc16a2c82247448da006635382358322--948a06dbb90c46b38b555e0d78f83087 79822b01710246649a157da4b385be6d 948a06dbb90c46b38b555e0d78f83087--79822b01710246649a157da4b385be6d 6d81ba78942e4c6bb6a6db8c76ecaac7 79822b01710246649a157da4b385be6d--6d81ba78942e4c6bb6a6db8c76ecaac7 7c959d9da9454a4fa6a471dc84cfcb5e 6d81ba78942e4c6bb6a6db8c76ecaac7--7c959d9da9454a4fa6a471dc84cfcb5e abcc0c7bdb3240af874096c29b0323dd 7c959d9da9454a4fa6a471dc84cfcb5e--abcc0c7bdb3240af874096c29b0323dd db74aa6aa02d4ad093980c7e6c3586cb abcc0c7bdb3240af874096c29b0323dd--db74aa6aa02d4ad093980c7e6c3586cb 6a9996d5c2c54f0baf8092e4a09c915e db74aa6aa02d4ad093980c7e6c3586cb--6a9996d5c2c54f0baf8092e4a09c915e 8088dc22980747149457d4893f95274b 6a9996d5c2c54f0baf8092e4a09c915e--8088dc22980747149457d4893f95274b d9cd6d01ef1a4e65baa9c7905b61690c 8088dc22980747149457d4893f95274b--d9cd6d01ef1a4e65baa9c7905b61690c d3f7c8b2aea044d7a93773efc9cdf155 d9cd6d01ef1a4e65baa9c7905b61690c--d3f7c8b2aea044d7a93773efc9cdf155 388868bf19fd47629a612fc3846ea59e d3f7c8b2aea044d7a93773efc9cdf155--388868bf19fd47629a612fc3846ea59e 906b0173d2c64a68b95f1181620bfc27 388868bf19fd47629a612fc3846ea59e--906b0173d2c64a68b95f1181620bfc27 f2ce34ea184d4e5cbea795725bbf370a 906b0173d2c64a68b95f1181620bfc27--f2ce34ea184d4e5cbea795725bbf370a 88b3de57f55f4c10a818db1c32f69e31 f2ce34ea184d4e5cbea795725bbf370a--88b3de57f55f4c10a818db1c32f69e31 59af1ac91f8d4661a71447d5f5fcadbd 88b3de57f55f4c10a818db1c32f69e31--59af1ac91f8d4661a71447d5f5fcadbd eb4dd135d19d4e17ac2fac6500745ef6 59af1ac91f8d4661a71447d5f5fcadbd--eb4dd135d19d4e17ac2fac6500745ef6 a7d67269a62b4dbba1c7823643bb18b2 eb4dd135d19d4e17ac2fac6500745ef6--a7d67269a62b4dbba1c7823643bb18b2 b0caac465cc44e18b0f6796463a9f1a4 a7d67269a62b4dbba1c7823643bb18b2--b0caac465cc44e18b0f6796463a9f1a4 130fafdab9644c788ca6812bc4eea739 b0caac465cc44e18b0f6796463a9f1a4--130fafdab9644c788ca6812bc4eea739 b0ad4783ff01465fbfdefc3d627cf5df RX(b00) 130fafdab9644c788ca6812bc4eea739--b0ad4783ff01465fbfdefc3d627cf5df 7b4150fff1c54211a7e9a3971fb6311d b0ad4783ff01465fbfdefc3d627cf5df--7b4150fff1c54211a7e9a3971fb6311d 23264ca379d0499dbc873212117d9478 7b4150fff1c54211a7e9a3971fb6311d--23264ca379d0499dbc873212117d9478 ab99d3cc113948f9a7649293c6b6f5c9 23264ca379d0499dbc873212117d9478--ab99d3cc113948f9a7649293c6b6f5c9 8f7de7a19a414d14ad6ffec438c2a825 ab99d3cc113948f9a7649293c6b6f5c9--8f7de7a19a414d14ad6ffec438c2a825 ad5fc8ec44ce4c5cb6745c28eda07efa 8f7de7a19a414d14ad6ffec438c2a825--ad5fc8ec44ce4c5cb6745c28eda07efa bdbf46e541094d3391b11499332e6396 ad5fc8ec44ce4c5cb6745c28eda07efa--bdbf46e541094d3391b11499332e6396 f404dab847624a079959b8f0f7a384b2 bdbf46e541094d3391b11499332e6396--f404dab847624a079959b8f0f7a384b2 009350eec1d143eebeda8f798be08f0b f404dab847624a079959b8f0f7a384b2--009350eec1d143eebeda8f798be08f0b 63becb5ca6fc4808942f981889bbd8e4 009350eec1d143eebeda8f798be08f0b--63becb5ca6fc4808942f981889bbd8e4 ab5081eaff224c2eb2ad6e8a5096c047 63becb5ca6fc4808942f981889bbd8e4--ab5081eaff224c2eb2ad6e8a5096c047 77d6931366cf411191361097cc3f7e35 ab5081eaff224c2eb2ad6e8a5096c047--77d6931366cf411191361097cc3f7e35 6c243a24334a41d985fd13e08889e6f9 77d6931366cf411191361097cc3f7e35--6c243a24334a41d985fd13e08889e6f9 a8842106a27b463281974b16cc77cee3 6c243a24334a41d985fd13e08889e6f9--a8842106a27b463281974b16cc77cee3 03bc112456ad469687be528dad63fafe a8842106a27b463281974b16cc77cee3--03bc112456ad469687be528dad63fafe cf182f3592bb42d38850a1883ebc97bd 03bc112456ad469687be528dad63fafe--cf182f3592bb42d38850a1883ebc97bd d51e3e69ee68418490040f31254e38b1 cf182f3592bb42d38850a1883ebc97bd--d51e3e69ee68418490040f31254e38b1 beb962863e3b4b05b8069223ed93b3c6 d51e3e69ee68418490040f31254e38b1--beb962863e3b4b05b8069223ed93b3c6 0b90266fb2034648b7234cc0842f1f2e beb962863e3b4b05b8069223ed93b3c6--0b90266fb2034648b7234cc0842f1f2e a14b5130e38f499897cb80d005c6f60a 0b90266fb2034648b7234cc0842f1f2e--a14b5130e38f499897cb80d005c6f60a ca6d4a68b4534d28a76351439bf8f3c3 a14b5130e38f499897cb80d005c6f60a--ca6d4a68b4534d28a76351439bf8f3c3 b7ee343b6f704e5f96401fafbcf31f77 ca6d4a68b4534d28a76351439bf8f3c3--b7ee343b6f704e5f96401fafbcf31f77 896501e7cd704aa194797c767aaebd40 b7ee343b6f704e5f96401fafbcf31f77--896501e7cd704aa194797c767aaebd40 13b8a877e4974952a918ff8cff5a90dd 896501e7cd704aa194797c767aaebd40--13b8a877e4974952a918ff8cff5a90dd 19b9ead5af19490fbffac573350f76a1 13b8a877e4974952a918ff8cff5a90dd--19b9ead5af19490fbffac573350f76a1 5f27c3c393f04503a63eb8861d5dbdfd 19b9ead5af19490fbffac573350f76a1--5f27c3c393f04503a63eb8861d5dbdfd 05a84d2f1417437faca4fe2bfd560ae7 5f27c3c393f04503a63eb8861d5dbdfd--05a84d2f1417437faca4fe2bfd560ae7 b30993c14e384589a783ef3de83452ad 05a84d2f1417437faca4fe2bfd560ae7--b30993c14e384589a783ef3de83452ad 557e31ec9e93482fb0d9f2184c1f3242 b30993c14e384589a783ef3de83452ad--557e31ec9e93482fb0d9f2184c1f3242 a06d0041e264474a806a872dd781b330 557e31ec9e93482fb0d9f2184c1f3242--a06d0041e264474a806a872dd781b330 63b36adf7efb4a1abe51a6d11a3c214f a06d0041e264474a806a872dd781b330--63b36adf7efb4a1abe51a6d11a3c214f 2bb75130cbb0453191dcd661da6a6c21 63b36adf7efb4a1abe51a6d11a3c214f--2bb75130cbb0453191dcd661da6a6c21 ea4c9822832d405fa94ec1fbaacefb00 2bb75130cbb0453191dcd661da6a6c21--ea4c9822832d405fa94ec1fbaacefb00 500c630f66954053bfb19ba8d6ecf3fc ea4c9822832d405fa94ec1fbaacefb00--500c630f66954053bfb19ba8d6ecf3fc 17403063387146159d3d664c91582b5f 500c630f66954053bfb19ba8d6ecf3fc--17403063387146159d3d664c91582b5f 9e04a4891f4e42babdbce5767669eaf8 17403063387146159d3d664c91582b5f--9e04a4891f4e42babdbce5767669eaf8 fa908d0e5a0a4466864030a16d1cc097 9e04a4891f4e42babdbce5767669eaf8--fa908d0e5a0a4466864030a16d1cc097 6b7bd79f8ef244f1bb752a66958b3b54 fa908d0e5a0a4466864030a16d1cc097--6b7bd79f8ef244f1bb752a66958b3b54 87abb50739c844b789933995d7570b35 6b7bd79f8ef244f1bb752a66958b3b54--87abb50739c844b789933995d7570b35 d36c0d9137af4589b7b38f07c424f5c6 87abb50739c844b789933995d7570b35--d36c0d9137af4589b7b38f07c424f5c6 80eb8c4554e043029c6d1b9efcd36195 d36c0d9137af4589b7b38f07c424f5c6--80eb8c4554e043029c6d1b9efcd36195 999dd8334a5d4b7f943d5f11dd73fac1 80eb8c4554e043029c6d1b9efcd36195--999dd8334a5d4b7f943d5f11dd73fac1 8276785962984e0395de0f24246ff1e8 999dd8334a5d4b7f943d5f11dd73fac1--8276785962984e0395de0f24246ff1e8 1e55a220312142978443e724ff143703 8276785962984e0395de0f24246ff1e8--1e55a220312142978443e724ff143703 47e2fb3ff7d549abbd28c950e95524b7 1e55a220312142978443e724ff143703--47e2fb3ff7d549abbd28c950e95524b7 543f8cde4e2444b39a21608c4dfbd927 47e2fb3ff7d549abbd28c950e95524b7--543f8cde4e2444b39a21608c4dfbd927 fe81bb8b918d48e6879c994d1e787873 543f8cde4e2444b39a21608c4dfbd927--fe81bb8b918d48e6879c994d1e787873 841a58cd4ab04c89b1e7f35de6041d29 fe81bb8b918d48e6879c994d1e787873--841a58cd4ab04c89b1e7f35de6041d29 962ac344db6c4b388c1e66120cc5e76d 841a58cd4ab04c89b1e7f35de6041d29--962ac344db6c4b388c1e66120cc5e76d 1750bcb46b3b43d4a1696011b946ca4d 962ac344db6c4b388c1e66120cc5e76d--1750bcb46b3b43d4a1696011b946ca4d 6a310677e5dc4308acbba56a56d6ecc7 1750bcb46b3b43d4a1696011b946ca4d--6a310677e5dc4308acbba56a56d6ecc7 ba764da6348147ec883c88eea1f5395d 6a310677e5dc4308acbba56a56d6ecc7--ba764da6348147ec883c88eea1f5395d 533f61f5bbe24e2989f3666db393b0fe ba764da6348147ec883c88eea1f5395d--533f61f5bbe24e2989f3666db393b0fe 83acf60e66214b879ca2a2b415d04177 533f61f5bbe24e2989f3666db393b0fe--83acf60e66214b879ca2a2b415d04177 3214e426a0044152b01fafe01aca4096 83acf60e66214b879ca2a2b415d04177--3214e426a0044152b01fafe01aca4096 bebc23e035734eb5a4451be3822a7b63 3214e426a0044152b01fafe01aca4096--bebc23e035734eb5a4451be3822a7b63 25580c869ca844a1a068696419aabe39 bebc23e035734eb5a4451be3822a7b63--25580c869ca844a1a068696419aabe39 eda878ca66d94e2888cfa812e42abac6 25580c869ca844a1a068696419aabe39--eda878ca66d94e2888cfa812e42abac6 d4c09ce061294c2995c3d6e5948e2f76 eda878ca66d94e2888cfa812e42abac6--d4c09ce061294c2995c3d6e5948e2f76 6d42362a15f64885bec595f602088996 d4c09ce061294c2995c3d6e5948e2f76--6d42362a15f64885bec595f602088996 ad719e6e6dd64a1da07c2b2507c9c88d 6d42362a15f64885bec595f602088996--ad719e6e6dd64a1da07c2b2507c9c88d 1d2cb81533e84563b7547a3de73ea70e ad719e6e6dd64a1da07c2b2507c9c88d--1d2cb81533e84563b7547a3de73ea70e 2a40bc5f2a8d4359a80840f05b7f9499 1d2cb81533e84563b7547a3de73ea70e--2a40bc5f2a8d4359a80840f05b7f9499 467416a0c821406ea271327e29a43a30 2a40bc5f2a8d4359a80840f05b7f9499--467416a0c821406ea271327e29a43a30 e25b47fdfba14a45b227794078a7116f 467416a0c821406ea271327e29a43a30--e25b47fdfba14a45b227794078a7116f 076d0c1bc21f4284857167a941ff4e4e e25b47fdfba14a45b227794078a7116f--076d0c1bc21f4284857167a941ff4e4e 285e771cafdc4ddaaaf1d947b6648824 RX(b10) 076d0c1bc21f4284857167a941ff4e4e--285e771cafdc4ddaaaf1d947b6648824 b9bf9f26a77944dc84c92dadeaa4b82f 285e771cafdc4ddaaaf1d947b6648824--b9bf9f26a77944dc84c92dadeaa4b82f 497453d0b81742138ba8861d7cd6642b 7550c1749a9142e79e155d3de511cabe X ac9bab06f0034766b65d918600493f11--7550c1749a9142e79e155d3de511cabe c68dc89839ef457f9ece4db5449a41ab 2 7550c1749a9142e79e155d3de511cabe--7fa1c06ce4ff40b1bab0ead4633de384 75a91a2a52f94ae4a5ab7ccd41b6ae7b 7550c1749a9142e79e155d3de511cabe--75a91a2a52f94ae4a5ab7ccd41b6ae7b 66cd544357804c59a804b0d2a2d249ca 75a91a2a52f94ae4a5ab7ccd41b6ae7b--66cd544357804c59a804b0d2a2d249ca bc6ad366d9264ba7aa376c6a53e9ffa7 66cd544357804c59a804b0d2a2d249ca--bc6ad366d9264ba7aa376c6a53e9ffa7 2ee99bb865a9490083cf8ce9fbd3accc bc6ad366d9264ba7aa376c6a53e9ffa7--2ee99bb865a9490083cf8ce9fbd3accc 78d3678e82124b8c8e07dceb5faa8197 2ee99bb865a9490083cf8ce9fbd3accc--78d3678e82124b8c8e07dceb5faa8197 bd2a2d402def440c8afa63b788c3f7a5 78d3678e82124b8c8e07dceb5faa8197--bd2a2d402def440c8afa63b788c3f7a5 884e2a83b8344b5ab0bbbbadb49cef16 bd2a2d402def440c8afa63b788c3f7a5--884e2a83b8344b5ab0bbbbadb49cef16 5e424a97b8ea4464867bce200ecc55c1 884e2a83b8344b5ab0bbbbadb49cef16--5e424a97b8ea4464867bce200ecc55c1 d228c61b3d404632a1f08050e4f8a2f0 5e424a97b8ea4464867bce200ecc55c1--d228c61b3d404632a1f08050e4f8a2f0 de3a7e5bda7542638d60d468b1db0776 d228c61b3d404632a1f08050e4f8a2f0--de3a7e5bda7542638d60d468b1db0776 b41824ff3c914501acb0dd80ab33ac81 de3a7e5bda7542638d60d468b1db0776--b41824ff3c914501acb0dd80ab33ac81 ca7d864243564cdaaa24747726455f4d b41824ff3c914501acb0dd80ab33ac81--ca7d864243564cdaaa24747726455f4d 1e0f43b2c2394a9aa31bcfddca805074 ca7d864243564cdaaa24747726455f4d--1e0f43b2c2394a9aa31bcfddca805074 3ec0cafa06754592b1b0740661c227a8 X 1e0f43b2c2394a9aa31bcfddca805074--3ec0cafa06754592b1b0740661c227a8 3ec0cafa06754592b1b0740661c227a8--fb7f861850204563975c2b306e8c9b2b 801a10f882474851974b1c57271ba3f2 X 3ec0cafa06754592b1b0740661c227a8--801a10f882474851974b1c57271ba3f2 801a10f882474851974b1c57271ba3f2--b30e6b031c064efabb825a0260d04509 684da1c0658f4b5b890c86983f26a844 801a10f882474851974b1c57271ba3f2--684da1c0658f4b5b890c86983f26a844 be0ebe5273dc494a85c78f37bc4ce5f4 684da1c0658f4b5b890c86983f26a844--be0ebe5273dc494a85c78f37bc4ce5f4 5afa9e4ae4b346f7be7cffd0217e4750 be0ebe5273dc494a85c78f37bc4ce5f4--5afa9e4ae4b346f7be7cffd0217e4750 73ae8641de7f415084fdf9c9e01594f7 X 5afa9e4ae4b346f7be7cffd0217e4750--73ae8641de7f415084fdf9c9e01594f7 73ae8641de7f415084fdf9c9e01594f7--1802ac766a8c4cf6bc835d10ba0daf6f a7d49c0bbba448fab1a9f017cd692575 X 73ae8641de7f415084fdf9c9e01594f7--a7d49c0bbba448fab1a9f017cd692575 a7d49c0bbba448fab1a9f017cd692575--11218eec3eb44084b7b75d90722541a3 837813b8636f4881b04eb6c61ae6206c a7d49c0bbba448fab1a9f017cd692575--837813b8636f4881b04eb6c61ae6206c 1dcfb12746d045f8ba0b31cf7d55f4c6 837813b8636f4881b04eb6c61ae6206c--1dcfb12746d045f8ba0b31cf7d55f4c6 7c250b98ddb9472a9e2d76669e7af622 1dcfb12746d045f8ba0b31cf7d55f4c6--7c250b98ddb9472a9e2d76669e7af622 ae4470f2941047d4b81273e3ab9e114f 7c250b98ddb9472a9e2d76669e7af622--ae4470f2941047d4b81273e3ab9e114f 19fc931eebcb4f6598ec918af2790847 ae4470f2941047d4b81273e3ab9e114f--19fc931eebcb4f6598ec918af2790847 b4879177758149b68e757f5ea28af9fa 19fc931eebcb4f6598ec918af2790847--b4879177758149b68e757f5ea28af9fa 67bf273e153543bca696795939699922 b4879177758149b68e757f5ea28af9fa--67bf273e153543bca696795939699922 da1c009f938541939ec9d13e48512344 67bf273e153543bca696795939699922--da1c009f938541939ec9d13e48512344 b4af929113d54b87bfdc71552c8ef053 da1c009f938541939ec9d13e48512344--b4af929113d54b87bfdc71552c8ef053 d7e92742e64a45aa91c24b3f79d57446 X b4af929113d54b87bfdc71552c8ef053--d7e92742e64a45aa91c24b3f79d57446 d7e92742e64a45aa91c24b3f79d57446--f124e855859646a6a0ecfd201abba731 54f9d342edba4c6ca5f7f70a4fb1c055 d7e92742e64a45aa91c24b3f79d57446--54f9d342edba4c6ca5f7f70a4fb1c055 922815c845f547dd811720b5310c587f 54f9d342edba4c6ca5f7f70a4fb1c055--922815c845f547dd811720b5310c587f b16be261db96444380b67e97883c48cc 922815c845f547dd811720b5310c587f--b16be261db96444380b67e97883c48cc f9bf80d20ab341f7abe2b0ac58d43eed b16be261db96444380b67e97883c48cc--f9bf80d20ab341f7abe2b0ac58d43eed 8cb07402896d4bcd8c44837e8985a6db f9bf80d20ab341f7abe2b0ac58d43eed--8cb07402896d4bcd8c44837e8985a6db fcd369ecceed455183383d235103dd0a 8cb07402896d4bcd8c44837e8985a6db--fcd369ecceed455183383d235103dd0a f4f4930c86014f958eaf7e7605199b33 fcd369ecceed455183383d235103dd0a--f4f4930c86014f958eaf7e7605199b33 e4638c53326147a3b49004f08b2d2039 f4f4930c86014f958eaf7e7605199b33--e4638c53326147a3b49004f08b2d2039 f98e94a127b64344b358f48cc143aa52 e4638c53326147a3b49004f08b2d2039--f98e94a127b64344b358f48cc143aa52 bab94cc1767c4c349e1db660ef51019f f98e94a127b64344b358f48cc143aa52--bab94cc1767c4c349e1db660ef51019f 9473d09616174fd299bf6260b2661323 bab94cc1767c4c349e1db660ef51019f--9473d09616174fd299bf6260b2661323 b79922d332764ff9bfee6ca06448b09b 9473d09616174fd299bf6260b2661323--b79922d332764ff9bfee6ca06448b09b b83a94209d7b4d529f70416ac2eedfda b79922d332764ff9bfee6ca06448b09b--b83a94209d7b4d529f70416ac2eedfda 5b5f1f878c974bd696b02341e537aabb b83a94209d7b4d529f70416ac2eedfda--5b5f1f878c974bd696b02341e537aabb 363b9fff95b7442493c096078c30ea2d 5b5f1f878c974bd696b02341e537aabb--363b9fff95b7442493c096078c30ea2d 5c25bcf197dd46698cb9f7744f857645 363b9fff95b7442493c096078c30ea2d--5c25bcf197dd46698cb9f7744f857645 99ac26b29ada407987ee652f1c972a3d 5c25bcf197dd46698cb9f7744f857645--99ac26b29ada407987ee652f1c972a3d e510cafb1e684b77b0a7f285b770fd68 99ac26b29ada407987ee652f1c972a3d--e510cafb1e684b77b0a7f285b770fd68 5cc4841694ad462984a97838232d26fd e510cafb1e684b77b0a7f285b770fd68--5cc4841694ad462984a97838232d26fd 583137118af4413491acde8d64a81993 5cc4841694ad462984a97838232d26fd--583137118af4413491acde8d64a81993 c7fa90c73b3345dd82348230f1365bc6 583137118af4413491acde8d64a81993--c7fa90c73b3345dd82348230f1365bc6 66bb3b81631e4958a9815cdca6e33810 c7fa90c73b3345dd82348230f1365bc6--66bb3b81631e4958a9815cdca6e33810 4e8218e359f8470b9a44280ebfe49d80 66bb3b81631e4958a9815cdca6e33810--4e8218e359f8470b9a44280ebfe49d80 4e345a18446045feb7fe22d8c0e79472 4e8218e359f8470b9a44280ebfe49d80--4e345a18446045feb7fe22d8c0e79472 65197a0b48704cc9979de60762b9956f 4e345a18446045feb7fe22d8c0e79472--65197a0b48704cc9979de60762b9956f 5170058ee08943a38389c81b33e7f78c 65197a0b48704cc9979de60762b9956f--5170058ee08943a38389c81b33e7f78c 19a5ea04a79a40139f833f4736368360 5170058ee08943a38389c81b33e7f78c--19a5ea04a79a40139f833f4736368360 3f3ff95f39f5424484dda68720bb3c9f 19a5ea04a79a40139f833f4736368360--3f3ff95f39f5424484dda68720bb3c9f a33e7e1bd66044efa8c5ee0096b22152 3f3ff95f39f5424484dda68720bb3c9f--a33e7e1bd66044efa8c5ee0096b22152 d702290e84c44db69c097928d88287f3 a33e7e1bd66044efa8c5ee0096b22152--d702290e84c44db69c097928d88287f3 2d1d004448b54896b567dd722aec5793 d702290e84c44db69c097928d88287f3--2d1d004448b54896b567dd722aec5793 c2ec8a15a55c481baaeb013bbe2632da 2d1d004448b54896b567dd722aec5793--c2ec8a15a55c481baaeb013bbe2632da 3686026c608e4b21b55d480ba4cffc4d c2ec8a15a55c481baaeb013bbe2632da--3686026c608e4b21b55d480ba4cffc4d 6ddf687fdb124971bc17917fa45e780d 3686026c608e4b21b55d480ba4cffc4d--6ddf687fdb124971bc17917fa45e780d 293ed7b3463945d2b890d1476cc1484b RX(b01) 6ddf687fdb124971bc17917fa45e780d--293ed7b3463945d2b890d1476cc1484b 59b6cbb2e7b84c19bab89e8c8668d20b X 293ed7b3463945d2b890d1476cc1484b--59b6cbb2e7b84c19bab89e8c8668d20b 59b6cbb2e7b84c19bab89e8c8668d20b--7b4150fff1c54211a7e9a3971fb6311d 14a048ae328c421aa2a92beeaee87644 59b6cbb2e7b84c19bab89e8c8668d20b--14a048ae328c421aa2a92beeaee87644 6688350baab74143b45dde7753f06e3b 14a048ae328c421aa2a92beeaee87644--6688350baab74143b45dde7753f06e3b 941cf83c954845e1a738e0e4d64df72e 6688350baab74143b45dde7753f06e3b--941cf83c954845e1a738e0e4d64df72e 7c8c0f7eeb03472fa2d2d67ce5769dfb 941cf83c954845e1a738e0e4d64df72e--7c8c0f7eeb03472fa2d2d67ce5769dfb 2698e91ae8ff488ba526abd6d5d37dcb 7c8c0f7eeb03472fa2d2d67ce5769dfb--2698e91ae8ff488ba526abd6d5d37dcb d6d90046a2404660af1b6a5a5096e59a 2698e91ae8ff488ba526abd6d5d37dcb--d6d90046a2404660af1b6a5a5096e59a cc74390d272b4711b55188d227789a82 d6d90046a2404660af1b6a5a5096e59a--cc74390d272b4711b55188d227789a82 8f91fffe1962467b9c8556d2db0ee1ec cc74390d272b4711b55188d227789a82--8f91fffe1962467b9c8556d2db0ee1ec 8c52b6d943e4472aa73b6e9e8c90a04e 8f91fffe1962467b9c8556d2db0ee1ec--8c52b6d943e4472aa73b6e9e8c90a04e fa018da55bd14c5d955ea093f41fa79c 8c52b6d943e4472aa73b6e9e8c90a04e--fa018da55bd14c5d955ea093f41fa79c cba7eb3ca60449be8856b879ecba2e6b fa018da55bd14c5d955ea093f41fa79c--cba7eb3ca60449be8856b879ecba2e6b b4947204764441b0bcaa9b391e42f950 cba7eb3ca60449be8856b879ecba2e6b--b4947204764441b0bcaa9b391e42f950 51648ca549ee4ab696d19b61da0e60cc b4947204764441b0bcaa9b391e42f950--51648ca549ee4ab696d19b61da0e60cc 1d54e2fe1bcd4f5db7d4ea510522abb3 X 51648ca549ee4ab696d19b61da0e60cc--1d54e2fe1bcd4f5db7d4ea510522abb3 1d54e2fe1bcd4f5db7d4ea510522abb3--cf182f3592bb42d38850a1883ebc97bd fe7ad8b26f154e6289197426cdbda24b X 1d54e2fe1bcd4f5db7d4ea510522abb3--fe7ad8b26f154e6289197426cdbda24b fe7ad8b26f154e6289197426cdbda24b--d51e3e69ee68418490040f31254e38b1 2c8c322ea0874ec8ba39947a670b86ef fe7ad8b26f154e6289197426cdbda24b--2c8c322ea0874ec8ba39947a670b86ef 5db93a9e35af4a8eb219cbd2f1c3e173 2c8c322ea0874ec8ba39947a670b86ef--5db93a9e35af4a8eb219cbd2f1c3e173 97332c6757e04f2ebdccd115086ad7ab 5db93a9e35af4a8eb219cbd2f1c3e173--97332c6757e04f2ebdccd115086ad7ab bfbfd4079a984dbdaa2a2186894f7c59 X 97332c6757e04f2ebdccd115086ad7ab--bfbfd4079a984dbdaa2a2186894f7c59 bfbfd4079a984dbdaa2a2186894f7c59--ca6d4a68b4534d28a76351439bf8f3c3 5bb9c8de87e84ee49df68713a7f37130 X bfbfd4079a984dbdaa2a2186894f7c59--5bb9c8de87e84ee49df68713a7f37130 5bb9c8de87e84ee49df68713a7f37130--b7ee343b6f704e5f96401fafbcf31f77 f5d9be4479404894b6dd463133f7013b 5bb9c8de87e84ee49df68713a7f37130--f5d9be4479404894b6dd463133f7013b d8e58d3dabc94509ae232fb327b3b02a f5d9be4479404894b6dd463133f7013b--d8e58d3dabc94509ae232fb327b3b02a 55f3d140aa2f481aa9c5f4b47a6bbc2a d8e58d3dabc94509ae232fb327b3b02a--55f3d140aa2f481aa9c5f4b47a6bbc2a bf9caa6617d64e77bd80d9b118634855 55f3d140aa2f481aa9c5f4b47a6bbc2a--bf9caa6617d64e77bd80d9b118634855 05574aee3ee6416f9b09e54819f7114b bf9caa6617d64e77bd80d9b118634855--05574aee3ee6416f9b09e54819f7114b ef6ae9e7b822438293e3e64ace23db2b 05574aee3ee6416f9b09e54819f7114b--ef6ae9e7b822438293e3e64ace23db2b 363dfbfcceea45dbb76b024b3b87d29f ef6ae9e7b822438293e3e64ace23db2b--363dfbfcceea45dbb76b024b3b87d29f d57083efe8584f688f345d68af94b4dd 363dfbfcceea45dbb76b024b3b87d29f--d57083efe8584f688f345d68af94b4dd d6f76a9cd0ca40359b06627de7304011 d57083efe8584f688f345d68af94b4dd--d6f76a9cd0ca40359b06627de7304011 7923e30e7e79402892f46e38ae6b5db6 X d6f76a9cd0ca40359b06627de7304011--7923e30e7e79402892f46e38ae6b5db6 7923e30e7e79402892f46e38ae6b5db6--2bb75130cbb0453191dcd661da6a6c21 8536b167aced4d90aeade50b61984bfd 7923e30e7e79402892f46e38ae6b5db6--8536b167aced4d90aeade50b61984bfd 1d5fd120696743a6b0f4b14fdd09717b 8536b167aced4d90aeade50b61984bfd--1d5fd120696743a6b0f4b14fdd09717b 2e6a50b735f3490aaba1db37cdfeeace 1d5fd120696743a6b0f4b14fdd09717b--2e6a50b735f3490aaba1db37cdfeeace 4d34f4126f0a426d8bbfb4000e32b6c2 2e6a50b735f3490aaba1db37cdfeeace--4d34f4126f0a426d8bbfb4000e32b6c2 4acb9b80ffe046e79ca8a67f062438c1 4d34f4126f0a426d8bbfb4000e32b6c2--4acb9b80ffe046e79ca8a67f062438c1 086730de8ef74237bc093e1a00e37e27 4acb9b80ffe046e79ca8a67f062438c1--086730de8ef74237bc093e1a00e37e27 3a0e1824d3d44b3091a0c8a14aef4152 086730de8ef74237bc093e1a00e37e27--3a0e1824d3d44b3091a0c8a14aef4152 95f3b55bfa694948bb93ac1ca514b069 3a0e1824d3d44b3091a0c8a14aef4152--95f3b55bfa694948bb93ac1ca514b069 5e17afe98fa943189ed38706346f24a6 95f3b55bfa694948bb93ac1ca514b069--5e17afe98fa943189ed38706346f24a6 08e423ce9ef3438f9ce189d0c084da2f 5e17afe98fa943189ed38706346f24a6--08e423ce9ef3438f9ce189d0c084da2f 6b07838d15124dc980ebec72f2dc24e9 08e423ce9ef3438f9ce189d0c084da2f--6b07838d15124dc980ebec72f2dc24e9 b030d54d12644fbe968b1334e566364d 6b07838d15124dc980ebec72f2dc24e9--b030d54d12644fbe968b1334e566364d ab2a432b842c415685a747122f0f8124 b030d54d12644fbe968b1334e566364d--ab2a432b842c415685a747122f0f8124 0fe1ef5a2d744e9eb6c39fe2810ab340 ab2a432b842c415685a747122f0f8124--0fe1ef5a2d744e9eb6c39fe2810ab340 295479bbc3224135b24a0499c45976de 0fe1ef5a2d744e9eb6c39fe2810ab340--295479bbc3224135b24a0499c45976de ad702a86cbdb44ddb40685bc08586277 295479bbc3224135b24a0499c45976de--ad702a86cbdb44ddb40685bc08586277 0c970a228f214cc98e5c8284730162d5 ad702a86cbdb44ddb40685bc08586277--0c970a228f214cc98e5c8284730162d5 7a3a53fe6eee4f8085a36057802cc32e 0c970a228f214cc98e5c8284730162d5--7a3a53fe6eee4f8085a36057802cc32e 48adaff5c88949049178c78c4b8e03ec 7a3a53fe6eee4f8085a36057802cc32e--48adaff5c88949049178c78c4b8e03ec e9716c5b22154c3dbf64b5a19bfe2adb 48adaff5c88949049178c78c4b8e03ec--e9716c5b22154c3dbf64b5a19bfe2adb 4d7935d7e24e4395be9f6fe66ae8e4b9 e9716c5b22154c3dbf64b5a19bfe2adb--4d7935d7e24e4395be9f6fe66ae8e4b9 2669a8475ea8441095a23a6c599532b5 4d7935d7e24e4395be9f6fe66ae8e4b9--2669a8475ea8441095a23a6c599532b5 5f9798ddc3be41bd96d25b98768ba04a 2669a8475ea8441095a23a6c599532b5--5f9798ddc3be41bd96d25b98768ba04a f5df88f54b724f058d3b1ffebd545e93 5f9798ddc3be41bd96d25b98768ba04a--f5df88f54b724f058d3b1ffebd545e93 6b9bac5a11084d7b9d489b2ab324482b f5df88f54b724f058d3b1ffebd545e93--6b9bac5a11084d7b9d489b2ab324482b ed3230dfda6e4d0193e7258f776fba48 6b9bac5a11084d7b9d489b2ab324482b--ed3230dfda6e4d0193e7258f776fba48 984abf477cf749819532e5d75c6d935f ed3230dfda6e4d0193e7258f776fba48--984abf477cf749819532e5d75c6d935f dcc583a99656480cbe076d6091839266 984abf477cf749819532e5d75c6d935f--dcc583a99656480cbe076d6091839266 fddd514b78574bc7b52b1255eb10fc9d dcc583a99656480cbe076d6091839266--fddd514b78574bc7b52b1255eb10fc9d f4451d52c2874fa4986765d5a93835e8 fddd514b78574bc7b52b1255eb10fc9d--f4451d52c2874fa4986765d5a93835e8 99fe34badb214f758176c3435ca66e44 f4451d52c2874fa4986765d5a93835e8--99fe34badb214f758176c3435ca66e44 e71f01786ba244a594073b5ae60f25cf 99fe34badb214f758176c3435ca66e44--e71f01786ba244a594073b5ae60f25cf 1e4849e695764682a2ec081093bf91f0 e71f01786ba244a594073b5ae60f25cf--1e4849e695764682a2ec081093bf91f0 fbc792a8bb64492c9769a8db1d85cb73 1e4849e695764682a2ec081093bf91f0--fbc792a8bb64492c9769a8db1d85cb73 1dfe3ab0f4344b138fb601d0ce10ec48 RX(b11) fbc792a8bb64492c9769a8db1d85cb73--1dfe3ab0f4344b138fb601d0ce10ec48 1dfe3ab0f4344b138fb601d0ce10ec48--497453d0b81742138ba8861d7cd6642b b9ec45f6806249f58b0ed12938eb2b8a 7b9a1e9102e1465ba54196ec4180316b c68dc89839ef457f9ece4db5449a41ab--7b9a1e9102e1465ba54196ec4180316b 25bf8158473443e98d2ecdd9dd106812 3 3d0534363fe942d190e0edc4ef887576 X 7b9a1e9102e1465ba54196ec4180316b--3d0534363fe942d190e0edc4ef887576 3d0534363fe942d190e0edc4ef887576--75a91a2a52f94ae4a5ab7ccd41b6ae7b bceb72e76a114a7980786cf28342d53a 3d0534363fe942d190e0edc4ef887576--bceb72e76a114a7980786cf28342d53a 6ba6988f0f7249ee8232abed865dc79e bceb72e76a114a7980786cf28342d53a--6ba6988f0f7249ee8232abed865dc79e 6d5b2410f3a144d3bac75568f02e783b 6ba6988f0f7249ee8232abed865dc79e--6d5b2410f3a144d3bac75568f02e783b 03f60c8096ae409c80b23b18cfe9c33b 6d5b2410f3a144d3bac75568f02e783b--03f60c8096ae409c80b23b18cfe9c33b feb8394ccfe44725a0483f850eb5767d 03f60c8096ae409c80b23b18cfe9c33b--feb8394ccfe44725a0483f850eb5767d 4de93fa0ce1c435bbae34ae43c288be7 feb8394ccfe44725a0483f850eb5767d--4de93fa0ce1c435bbae34ae43c288be7 bf870b0fe90a4d1e97a23e0b4721eddc 4de93fa0ce1c435bbae34ae43c288be7--bf870b0fe90a4d1e97a23e0b4721eddc 9825806b5712420c955b8e41dc051411 bf870b0fe90a4d1e97a23e0b4721eddc--9825806b5712420c955b8e41dc051411 fcb5657b2184473db70daac7d30e03ee 9825806b5712420c955b8e41dc051411--fcb5657b2184473db70daac7d30e03ee c0a82a2b754a48a8a5d7d7df06d4cf4f fcb5657b2184473db70daac7d30e03ee--c0a82a2b754a48a8a5d7d7df06d4cf4f ba1ddccac5784d3a996fd4b5bb3a1013 c0a82a2b754a48a8a5d7d7df06d4cf4f--ba1ddccac5784d3a996fd4b5bb3a1013 4f615bd9441b469d94dadac381c26e65 X ba1ddccac5784d3a996fd4b5bb3a1013--4f615bd9441b469d94dadac381c26e65 4f615bd9441b469d94dadac381c26e65--1e0f43b2c2394a9aa31bcfddca805074 85e9a10114494eb4828f9a5e942ee652 4f615bd9441b469d94dadac381c26e65--85e9a10114494eb4828f9a5e942ee652 ccbc1b4679344d129980edff9b6912d6 85e9a10114494eb4828f9a5e942ee652--ccbc1b4679344d129980edff9b6912d6 1d63d588a4e04e66a3a7538e27dcb250 X ccbc1b4679344d129980edff9b6912d6--1d63d588a4e04e66a3a7538e27dcb250 1d63d588a4e04e66a3a7538e27dcb250--684da1c0658f4b5b890c86983f26a844 2eeab2f7e9ed419285303117df227ea2 RZ(-1.0*g0) 1d63d588a4e04e66a3a7538e27dcb250--2eeab2f7e9ed419285303117df227ea2 5eba3799e92442d3851f5f5e66132247 X 2eeab2f7e9ed419285303117df227ea2--5eba3799e92442d3851f5f5e66132247 5eba3799e92442d3851f5f5e66132247--5afa9e4ae4b346f7be7cffd0217e4750 4411f9d875fe4b3d92870c1b34b9fcad 5eba3799e92442d3851f5f5e66132247--4411f9d875fe4b3d92870c1b34b9fcad af022e6cec564ad481414f4c105ea584 4411f9d875fe4b3d92870c1b34b9fcad--af022e6cec564ad481414f4c105ea584 ee23c40c07004c0abed952b35aa3032f X af022e6cec564ad481414f4c105ea584--ee23c40c07004c0abed952b35aa3032f ee23c40c07004c0abed952b35aa3032f--837813b8636f4881b04eb6c61ae6206c febadf09bdc3419b8acf55f153d79823 ee23c40c07004c0abed952b35aa3032f--febadf09bdc3419b8acf55f153d79823 e49aaeb895e749d48d426fd9603b4a7d febadf09bdc3419b8acf55f153d79823--e49aaeb895e749d48d426fd9603b4a7d e6249b113c5e4a13aa7d40775f39ee28 e49aaeb895e749d48d426fd9603b4a7d--e6249b113c5e4a13aa7d40775f39ee28 62023788aa9e445eaec83f6da4c2ce62 e6249b113c5e4a13aa7d40775f39ee28--62023788aa9e445eaec83f6da4c2ce62 4b93cd29951c43129d52916884bd0e0e 62023788aa9e445eaec83f6da4c2ce62--4b93cd29951c43129d52916884bd0e0e 87e60ac7d8544dafb9aa3ad4ccfec12d 4b93cd29951c43129d52916884bd0e0e--87e60ac7d8544dafb9aa3ad4ccfec12d de12cf488ab44e8e8d201849842454b4 87e60ac7d8544dafb9aa3ad4ccfec12d--de12cf488ab44e8e8d201849842454b4 c247b71f9327440190c1116317d67434 X de12cf488ab44e8e8d201849842454b4--c247b71f9327440190c1116317d67434 c247b71f9327440190c1116317d67434--b4af929113d54b87bfdc71552c8ef053 180f3520983b4631a80021adc95858c5 c247b71f9327440190c1116317d67434--180f3520983b4631a80021adc95858c5 53288f19fddd4f9998b63dd6c08b7040 X 180f3520983b4631a80021adc95858c5--53288f19fddd4f9998b63dd6c08b7040 53288f19fddd4f9998b63dd6c08b7040--54f9d342edba4c6ca5f7f70a4fb1c055 d6736e09dd494fe9a919b112c262cce8 RZ(-1.0*g0) 53288f19fddd4f9998b63dd6c08b7040--d6736e09dd494fe9a919b112c262cce8 b78029c4e1474432ba6cd9ca57be28bc X d6736e09dd494fe9a919b112c262cce8--b78029c4e1474432ba6cd9ca57be28bc b78029c4e1474432ba6cd9ca57be28bc--b16be261db96444380b67e97883c48cc 11b6c7049cb24be084488218451e2399 b78029c4e1474432ba6cd9ca57be28bc--11b6c7049cb24be084488218451e2399 16878532ffa64ee1a632eaf2c397edd5 11b6c7049cb24be084488218451e2399--16878532ffa64ee1a632eaf2c397edd5 9a81947810a14a438741fcc8f7db50dc 16878532ffa64ee1a632eaf2c397edd5--9a81947810a14a438741fcc8f7db50dc 7fb99061745d4faf9bd7b93cef77920d 9a81947810a14a438741fcc8f7db50dc--7fb99061745d4faf9bd7b93cef77920d 0f258b8b544849f880d48f277a70306a 7fb99061745d4faf9bd7b93cef77920d--0f258b8b544849f880d48f277a70306a 22ade8832b434995ab67810dcab97546 0f258b8b544849f880d48f277a70306a--22ade8832b434995ab67810dcab97546 d2a4065516c74a2b8a90449c70b00424 22ade8832b434995ab67810dcab97546--d2a4065516c74a2b8a90449c70b00424 b7be74f6df214cce963dfe5452222239 d2a4065516c74a2b8a90449c70b00424--b7be74f6df214cce963dfe5452222239 4f7e5ffa6ff845b383afb8d3adef989b b7be74f6df214cce963dfe5452222239--4f7e5ffa6ff845b383afb8d3adef989b f4b5d2384c554b17a7576bdd55e82d26 4f7e5ffa6ff845b383afb8d3adef989b--f4b5d2384c554b17a7576bdd55e82d26 ac32f3f8642942cf8dc5b24324be67c6 f4b5d2384c554b17a7576bdd55e82d26--ac32f3f8642942cf8dc5b24324be67c6 ba20fcefc5e040188b4518611d9b6b1b ac32f3f8642942cf8dc5b24324be67c6--ba20fcefc5e040188b4518611d9b6b1b 63032b6782ea44b8bd90a17ce3627842 ba20fcefc5e040188b4518611d9b6b1b--63032b6782ea44b8bd90a17ce3627842 f37a0863f9cc432fa93babdf5fd2fc83 63032b6782ea44b8bd90a17ce3627842--f37a0863f9cc432fa93babdf5fd2fc83 d80c4e0a6ce74bb597fe4a7e15ef5895 f37a0863f9cc432fa93babdf5fd2fc83--d80c4e0a6ce74bb597fe4a7e15ef5895 7c937bbc7ee24c358127c8449f7f95e6 d80c4e0a6ce74bb597fe4a7e15ef5895--7c937bbc7ee24c358127c8449f7f95e6 d47bb6db698947ceae5791146e51cb2c 7c937bbc7ee24c358127c8449f7f95e6--d47bb6db698947ceae5791146e51cb2c 0fd16dada85645cb8f11db147f94f91a d47bb6db698947ceae5791146e51cb2c--0fd16dada85645cb8f11db147f94f91a ee3df64385d146fe934c43072d5ef376 0fd16dada85645cb8f11db147f94f91a--ee3df64385d146fe934c43072d5ef376 4c84a07ce924440bba89f27ce5ea6ee9 ee3df64385d146fe934c43072d5ef376--4c84a07ce924440bba89f27ce5ea6ee9 766b87547fb74e069c72322184863e11 4c84a07ce924440bba89f27ce5ea6ee9--766b87547fb74e069c72322184863e11 2194ba2d9fac44a298827e80d5dcb7c1 766b87547fb74e069c72322184863e11--2194ba2d9fac44a298827e80d5dcb7c1 b203e47f3b97499bb6a00ab515b6edf8 2194ba2d9fac44a298827e80d5dcb7c1--b203e47f3b97499bb6a00ab515b6edf8 a8ce223f2c534027ae6cea8a4b503eb7 b203e47f3b97499bb6a00ab515b6edf8--a8ce223f2c534027ae6cea8a4b503eb7 5bf92c90fc5f4e12908949ee8d9ec880 a8ce223f2c534027ae6cea8a4b503eb7--5bf92c90fc5f4e12908949ee8d9ec880 4f8c0593dd2a48a18798d23ba1554999 5bf92c90fc5f4e12908949ee8d9ec880--4f8c0593dd2a48a18798d23ba1554999 b1d84443887c4096b61dc6697c3e0174 4f8c0593dd2a48a18798d23ba1554999--b1d84443887c4096b61dc6697c3e0174 7e49cbe5cfb84cb0a5994f20d1130e4d b1d84443887c4096b61dc6697c3e0174--7e49cbe5cfb84cb0a5994f20d1130e4d d6ec0664c7f749aabd5658ea12ad8e1e 7e49cbe5cfb84cb0a5994f20d1130e4d--d6ec0664c7f749aabd5658ea12ad8e1e 6c55c3e0616549f9a713acc08184f800 d6ec0664c7f749aabd5658ea12ad8e1e--6c55c3e0616549f9a713acc08184f800 0c8c3075fd3949ffaa5b1c02c2294afa 6c55c3e0616549f9a713acc08184f800--0c8c3075fd3949ffaa5b1c02c2294afa 1e51c1b0ffc54293950d65b02b271f2d RX(b02) 0c8c3075fd3949ffaa5b1c02c2294afa--1e51c1b0ffc54293950d65b02b271f2d 2376c4f1b8a947bbb602c3c4be55f087 1e51c1b0ffc54293950d65b02b271f2d--2376c4f1b8a947bbb602c3c4be55f087 e99aa16323934e359a7264c119c44994 X 2376c4f1b8a947bbb602c3c4be55f087--e99aa16323934e359a7264c119c44994 e99aa16323934e359a7264c119c44994--14a048ae328c421aa2a92beeaee87644 d98387c438a94944aa9ab1bdd726bed2 e99aa16323934e359a7264c119c44994--d98387c438a94944aa9ab1bdd726bed2 5d2481be913c4f3b870692c863b91474 d98387c438a94944aa9ab1bdd726bed2--5d2481be913c4f3b870692c863b91474 efe8b426aa32499b8fe157128caf6314 5d2481be913c4f3b870692c863b91474--efe8b426aa32499b8fe157128caf6314 ba72fe55a61149fea7581252b6a73a96 efe8b426aa32499b8fe157128caf6314--ba72fe55a61149fea7581252b6a73a96 7128ee7f7a0d4be38f3eb5e610462382 ba72fe55a61149fea7581252b6a73a96--7128ee7f7a0d4be38f3eb5e610462382 85abf7bb93b24746a00501254314e564 7128ee7f7a0d4be38f3eb5e610462382--85abf7bb93b24746a00501254314e564 214778a7971b4f86ab9ed04fddc19de4 85abf7bb93b24746a00501254314e564--214778a7971b4f86ab9ed04fddc19de4 22a7e44122a3449a8df1c10f8790d66d 214778a7971b4f86ab9ed04fddc19de4--22a7e44122a3449a8df1c10f8790d66d eb9ef751f370476c8e2d5eeb9153a3ed 22a7e44122a3449a8df1c10f8790d66d--eb9ef751f370476c8e2d5eeb9153a3ed fa32e85218ef472dba84cae779f5eeee eb9ef751f370476c8e2d5eeb9153a3ed--fa32e85218ef472dba84cae779f5eeee b14f296c2a5d4759af22dcc6df5998ee fa32e85218ef472dba84cae779f5eeee--b14f296c2a5d4759af22dcc6df5998ee df4e8be00b4842989bbe9418b902a870 X b14f296c2a5d4759af22dcc6df5998ee--df4e8be00b4842989bbe9418b902a870 df4e8be00b4842989bbe9418b902a870--51648ca549ee4ab696d19b61da0e60cc 030e34e414494a39b5f37662db8435b8 df4e8be00b4842989bbe9418b902a870--030e34e414494a39b5f37662db8435b8 ec62ab20e7e94dd8aadeb9a667faa1c0 030e34e414494a39b5f37662db8435b8--ec62ab20e7e94dd8aadeb9a667faa1c0 32c244737bcb47a981444de19c39cbe0 X ec62ab20e7e94dd8aadeb9a667faa1c0--32c244737bcb47a981444de19c39cbe0 32c244737bcb47a981444de19c39cbe0--2c8c322ea0874ec8ba39947a670b86ef 892c130afccf467fb87eb2e729028248 RZ(-1.0*g1) 32c244737bcb47a981444de19c39cbe0--892c130afccf467fb87eb2e729028248 3d7e5012622242d78e2317b88671b682 X 892c130afccf467fb87eb2e729028248--3d7e5012622242d78e2317b88671b682 3d7e5012622242d78e2317b88671b682--97332c6757e04f2ebdccd115086ad7ab 29b177790f614c85bb5eeaceb566698c 3d7e5012622242d78e2317b88671b682--29b177790f614c85bb5eeaceb566698c c81bba833c814aceb710fdaf68e0a7c7 29b177790f614c85bb5eeaceb566698c--c81bba833c814aceb710fdaf68e0a7c7 66a73b1bd2d74a608a7daf7d9b69ab3d X c81bba833c814aceb710fdaf68e0a7c7--66a73b1bd2d74a608a7daf7d9b69ab3d 66a73b1bd2d74a608a7daf7d9b69ab3d--f5d9be4479404894b6dd463133f7013b a297a102502b49c6af4d4c5a4d54cc19 66a73b1bd2d74a608a7daf7d9b69ab3d--a297a102502b49c6af4d4c5a4d54cc19 a8918938bcb9415dbf2144739b4dfad5 a297a102502b49c6af4d4c5a4d54cc19--a8918938bcb9415dbf2144739b4dfad5 300796cad8834e26801b776f470e642d a8918938bcb9415dbf2144739b4dfad5--300796cad8834e26801b776f470e642d e50fc87e655341e0bd33c0c6e67ed36d 300796cad8834e26801b776f470e642d--e50fc87e655341e0bd33c0c6e67ed36d f83e4e319147406290df9cbe5c4ed122 e50fc87e655341e0bd33c0c6e67ed36d--f83e4e319147406290df9cbe5c4ed122 c3cb759b4c8c4a5b95486cfb0efa6dec f83e4e319147406290df9cbe5c4ed122--c3cb759b4c8c4a5b95486cfb0efa6dec f132af63e8054be8bac4ccbf998c2f26 c3cb759b4c8c4a5b95486cfb0efa6dec--f132af63e8054be8bac4ccbf998c2f26 aad8082c3e33404e96d842672babb20e X f132af63e8054be8bac4ccbf998c2f26--aad8082c3e33404e96d842672babb20e aad8082c3e33404e96d842672babb20e--d6f76a9cd0ca40359b06627de7304011 f3e725e9900f4cb3aa8c1c7638d77754 aad8082c3e33404e96d842672babb20e--f3e725e9900f4cb3aa8c1c7638d77754 07bab22a0c7045519914c2ac8c4b922c X f3e725e9900f4cb3aa8c1c7638d77754--07bab22a0c7045519914c2ac8c4b922c 07bab22a0c7045519914c2ac8c4b922c--8536b167aced4d90aeade50b61984bfd 07d6836c0d7f439ab03b18dc393a08fa RZ(-1.0*g1) 07bab22a0c7045519914c2ac8c4b922c--07d6836c0d7f439ab03b18dc393a08fa 8ab8328c659c4caabb0fa74c5dfe7d13 X 07d6836c0d7f439ab03b18dc393a08fa--8ab8328c659c4caabb0fa74c5dfe7d13 8ab8328c659c4caabb0fa74c5dfe7d13--2e6a50b735f3490aaba1db37cdfeeace b01542fdf0f240129aeef686aaac2221 8ab8328c659c4caabb0fa74c5dfe7d13--b01542fdf0f240129aeef686aaac2221 0d9d83c56dbf40cb9b43203933a9c306 b01542fdf0f240129aeef686aaac2221--0d9d83c56dbf40cb9b43203933a9c306 bd558220b9264a0ca7a26fad551b7f36 0d9d83c56dbf40cb9b43203933a9c306--bd558220b9264a0ca7a26fad551b7f36 9b06069ed4e349918ba4afe3f8dd8949 bd558220b9264a0ca7a26fad551b7f36--9b06069ed4e349918ba4afe3f8dd8949 a1f0aebff86646388d910452c8fadc79 9b06069ed4e349918ba4afe3f8dd8949--a1f0aebff86646388d910452c8fadc79 75a8135df24646cd89abc3af6a1a959c a1f0aebff86646388d910452c8fadc79--75a8135df24646cd89abc3af6a1a959c a8472548764a4e3280cf5ec4a2f69b2e 75a8135df24646cd89abc3af6a1a959c--a8472548764a4e3280cf5ec4a2f69b2e a5c36ad024a745ab858e674217b5e86b a8472548764a4e3280cf5ec4a2f69b2e--a5c36ad024a745ab858e674217b5e86b 779defdd2e9c40eaa3075c7bf28ac76a a5c36ad024a745ab858e674217b5e86b--779defdd2e9c40eaa3075c7bf28ac76a fc62253930274cf0911d3ab0ae72420c 779defdd2e9c40eaa3075c7bf28ac76a--fc62253930274cf0911d3ab0ae72420c 8d7ca6fd5d5c40e7a58a83b5ced55715 fc62253930274cf0911d3ab0ae72420c--8d7ca6fd5d5c40e7a58a83b5ced55715 f836e29f487e479797b6ce3228ff5f5c 8d7ca6fd5d5c40e7a58a83b5ced55715--f836e29f487e479797b6ce3228ff5f5c 2cdd456037b8445ea9a802f80d36d2e8 f836e29f487e479797b6ce3228ff5f5c--2cdd456037b8445ea9a802f80d36d2e8 5073120c395f49a7af54c6a7081fb7b9 2cdd456037b8445ea9a802f80d36d2e8--5073120c395f49a7af54c6a7081fb7b9 dc513f0979484225873b7caed7360478 5073120c395f49a7af54c6a7081fb7b9--dc513f0979484225873b7caed7360478 4bf41029c93246d0aae66c3c198feff4 dc513f0979484225873b7caed7360478--4bf41029c93246d0aae66c3c198feff4 9cc568638e114b97b67a219e77093454 4bf41029c93246d0aae66c3c198feff4--9cc568638e114b97b67a219e77093454 ecab17dda13e4547bfa8dc3984d5b678 9cc568638e114b97b67a219e77093454--ecab17dda13e4547bfa8dc3984d5b678 deb2f78bd9db465991454baece31463a ecab17dda13e4547bfa8dc3984d5b678--deb2f78bd9db465991454baece31463a d35477b929a64d3b989afbab083fdf05 deb2f78bd9db465991454baece31463a--d35477b929a64d3b989afbab083fdf05 63bc429a3c8b467288f8e0d1e6c47bc5 d35477b929a64d3b989afbab083fdf05--63bc429a3c8b467288f8e0d1e6c47bc5 e8842b9b4ba94217a5e7122ef4b7a05c 63bc429a3c8b467288f8e0d1e6c47bc5--e8842b9b4ba94217a5e7122ef4b7a05c 140dec2492524df589348aeea8302bd7 e8842b9b4ba94217a5e7122ef4b7a05c--140dec2492524df589348aeea8302bd7 4c8a5c9cf4734082bbc4b875a01715bf 140dec2492524df589348aeea8302bd7--4c8a5c9cf4734082bbc4b875a01715bf 707c409aaef3441ebb1aad894d158515 4c8a5c9cf4734082bbc4b875a01715bf--707c409aaef3441ebb1aad894d158515 62c5f4d010e442afb16356420cde70c6 707c409aaef3441ebb1aad894d158515--62c5f4d010e442afb16356420cde70c6 c5cab159533d48dd990e13f9cbab6f04 62c5f4d010e442afb16356420cde70c6--c5cab159533d48dd990e13f9cbab6f04 de4b33f89ad342fe8dc0c1cd84862de4 c5cab159533d48dd990e13f9cbab6f04--de4b33f89ad342fe8dc0c1cd84862de4 9927337d25e34de99218b6805259c648 de4b33f89ad342fe8dc0c1cd84862de4--9927337d25e34de99218b6805259c648 351ec5c583d341c3b2f141c3604eb557 9927337d25e34de99218b6805259c648--351ec5c583d341c3b2f141c3604eb557 3d7f643d044c43298d9689ad59620dbb 351ec5c583d341c3b2f141c3604eb557--3d7f643d044c43298d9689ad59620dbb 9923dc02349a46de86a1262457d2954e RX(b12) 3d7f643d044c43298d9689ad59620dbb--9923dc02349a46de86a1262457d2954e 9923dc02349a46de86a1262457d2954e--b9ec45f6806249f58b0ed12938eb2b8a b9163fbe66c14632b96ed743e3760409 96177e46722249c38aaa35e211b9da9a 25bf8158473443e98d2ecdd9dd106812--96177e46722249c38aaa35e211b9da9a 42b3f55c73ed452bab9eac9edbe71e53 4 c133c5c0f7274b43b5017bb84ed05830 96177e46722249c38aaa35e211b9da9a--c133c5c0f7274b43b5017bb84ed05830 7f8767884ab04157bf7cf8b4297ae392 X c133c5c0f7274b43b5017bb84ed05830--7f8767884ab04157bf7cf8b4297ae392 7f8767884ab04157bf7cf8b4297ae392--bceb72e76a114a7980786cf28342d53a 0f7be0c515f04043a2fcc41b15bb2255 7f8767884ab04157bf7cf8b4297ae392--0f7be0c515f04043a2fcc41b15bb2255 27c9a5321c1e4a1184f7e18ffcd0f5aa 0f7be0c515f04043a2fcc41b15bb2255--27c9a5321c1e4a1184f7e18ffcd0f5aa c3cf29d8acc94e419fe97037f9b5d268 27c9a5321c1e4a1184f7e18ffcd0f5aa--c3cf29d8acc94e419fe97037f9b5d268 3b8294466f414ed88efc5e10bd72e6dc c3cf29d8acc94e419fe97037f9b5d268--3b8294466f414ed88efc5e10bd72e6dc 2cde816a463b493faa8fa6b90a9e57fc 3b8294466f414ed88efc5e10bd72e6dc--2cde816a463b493faa8fa6b90a9e57fc 5d667306223c4f2d84878fbf7c072d4c 2cde816a463b493faa8fa6b90a9e57fc--5d667306223c4f2d84878fbf7c072d4c 6936ae388ce042bfb1caa7b75fa1ef1b 5d667306223c4f2d84878fbf7c072d4c--6936ae388ce042bfb1caa7b75fa1ef1b a66363ce4d09496ea578ebd51d430d3b 6936ae388ce042bfb1caa7b75fa1ef1b--a66363ce4d09496ea578ebd51d430d3b 484fa5ab71f3436c88c6a54b96e87761 a66363ce4d09496ea578ebd51d430d3b--484fa5ab71f3436c88c6a54b96e87761 1162cd5a7e7048aa8670ebec2801d548 X 484fa5ab71f3436c88c6a54b96e87761--1162cd5a7e7048aa8670ebec2801d548 1162cd5a7e7048aa8670ebec2801d548--ba1ddccac5784d3a996fd4b5bb3a1013 5875e480ce214ebbb6e1dc8bd07e6da2 1162cd5a7e7048aa8670ebec2801d548--5875e480ce214ebbb6e1dc8bd07e6da2 2051f2c897c04634a7d9e9e6db7354c9 5875e480ce214ebbb6e1dc8bd07e6da2--2051f2c897c04634a7d9e9e6db7354c9 0b51babe3d5d4a9d91627f1d7c5dd028 2051f2c897c04634a7d9e9e6db7354c9--0b51babe3d5d4a9d91627f1d7c5dd028 448b3b4b71dc440fb8f5cd37203d3fcc 0b51babe3d5d4a9d91627f1d7c5dd028--448b3b4b71dc440fb8f5cd37203d3fcc 72fa9521a8dc4aef9e97256a7ffd790b 448b3b4b71dc440fb8f5cd37203d3fcc--72fa9521a8dc4aef9e97256a7ffd790b 528a35d1512c4630b7881ab91a09ac12 72fa9521a8dc4aef9e97256a7ffd790b--528a35d1512c4630b7881ab91a09ac12 8e83fa65857740b79c483409ddeecbec 528a35d1512c4630b7881ab91a09ac12--8e83fa65857740b79c483409ddeecbec 918c1d25e1bd4a03b46073854b3f88ca 8e83fa65857740b79c483409ddeecbec--918c1d25e1bd4a03b46073854b3f88ca a6208b20d4384f2c86da74f1b2f55230 918c1d25e1bd4a03b46073854b3f88ca--a6208b20d4384f2c86da74f1b2f55230 6043fe5a3da94427b098d40e45251e29 X a6208b20d4384f2c86da74f1b2f55230--6043fe5a3da94427b098d40e45251e29 6043fe5a3da94427b098d40e45251e29--febadf09bdc3419b8acf55f153d79823 eec547997246478a9f2ea79dcc21a3b1 6043fe5a3da94427b098d40e45251e29--eec547997246478a9f2ea79dcc21a3b1 ff7610b32ec34823bec305c8ded3f6ec eec547997246478a9f2ea79dcc21a3b1--ff7610b32ec34823bec305c8ded3f6ec aef6d6816aa24533be7d6f0c2c04a845 ff7610b32ec34823bec305c8ded3f6ec--aef6d6816aa24533be7d6f0c2c04a845 75e600c1f7dc402baa68d26d204383a9 aef6d6816aa24533be7d6f0c2c04a845--75e600c1f7dc402baa68d26d204383a9 078d130ef2e341d48bc57fd04d22928e 75e600c1f7dc402baa68d26d204383a9--078d130ef2e341d48bc57fd04d22928e 9095cfeaa4e44a518d957723637e5367 X 078d130ef2e341d48bc57fd04d22928e--9095cfeaa4e44a518d957723637e5367 9095cfeaa4e44a518d957723637e5367--de12cf488ab44e8e8d201849842454b4 7834e0b4e1744047aae4cf80f2804c31 9095cfeaa4e44a518d957723637e5367--7834e0b4e1744047aae4cf80f2804c31 edde764cabc64ba5bdf51255b943eebf 7834e0b4e1744047aae4cf80f2804c31--edde764cabc64ba5bdf51255b943eebf d56a4c4095834623bdc84569c277eeac edde764cabc64ba5bdf51255b943eebf--d56a4c4095834623bdc84569c277eeac 4cea1b4abb044f5ebf99e80d543cd6bb d56a4c4095834623bdc84569c277eeac--4cea1b4abb044f5ebf99e80d543cd6bb fb246fae165a4a608568906d4515a46c 4cea1b4abb044f5ebf99e80d543cd6bb--fb246fae165a4a608568906d4515a46c 0917bdd8ea464896aeb3fc2661960b10 X fb246fae165a4a608568906d4515a46c--0917bdd8ea464896aeb3fc2661960b10 0917bdd8ea464896aeb3fc2661960b10--11b6c7049cb24be084488218451e2399 64c399e53da24d10b04b547ee7c3389a RZ(-1.0*g0) 0917bdd8ea464896aeb3fc2661960b10--64c399e53da24d10b04b547ee7c3389a 1020e37db4e24dcba2e9b8a8c8de9ca5 X 64c399e53da24d10b04b547ee7c3389a--1020e37db4e24dcba2e9b8a8c8de9ca5 1020e37db4e24dcba2e9b8a8c8de9ca5--9a81947810a14a438741fcc8f7db50dc 175fb3cbfdc54cf6b20b811fc6c47fdf X 1020e37db4e24dcba2e9b8a8c8de9ca5--175fb3cbfdc54cf6b20b811fc6c47fdf 175fb3cbfdc54cf6b20b811fc6c47fdf--7fb99061745d4faf9bd7b93cef77920d 4300d45d16e24e9fb3f444f8144ea0e3 175fb3cbfdc54cf6b20b811fc6c47fdf--4300d45d16e24e9fb3f444f8144ea0e3 c324d9e912454318bcbfbf02f0857160 4300d45d16e24e9fb3f444f8144ea0e3--c324d9e912454318bcbfbf02f0857160 4ef3ebc5ea804562a48b728ba66fe327 c324d9e912454318bcbfbf02f0857160--4ef3ebc5ea804562a48b728ba66fe327 425cb25afa23440f8834b821052de2b8 X 4ef3ebc5ea804562a48b728ba66fe327--425cb25afa23440f8834b821052de2b8 425cb25afa23440f8834b821052de2b8--b7be74f6df214cce963dfe5452222239 30572b4562ea49b0a79af0e21af77a4c 425cb25afa23440f8834b821052de2b8--30572b4562ea49b0a79af0e21af77a4c 5c7b26b3474849418123ec87de18899b 30572b4562ea49b0a79af0e21af77a4c--5c7b26b3474849418123ec87de18899b ccd69a0786d04eee81f42301cc91e4bb 5c7b26b3474849418123ec87de18899b--ccd69a0786d04eee81f42301cc91e4bb a24dea9ffe6f4247b8a20b60ec9c6830 ccd69a0786d04eee81f42301cc91e4bb--a24dea9ffe6f4247b8a20b60ec9c6830 5a77de55031442448b4f8ff5d1136319 a24dea9ffe6f4247b8a20b60ec9c6830--5a77de55031442448b4f8ff5d1136319 36e6f503231845a89460d5e169eb46bd 5a77de55031442448b4f8ff5d1136319--36e6f503231845a89460d5e169eb46bd 32356f800fb64e91b7744149776daf9e 36e6f503231845a89460d5e169eb46bd--32356f800fb64e91b7744149776daf9e 1af8f2df672548f8b3fb4e26ab2b1b35 32356f800fb64e91b7744149776daf9e--1af8f2df672548f8b3fb4e26ab2b1b35 0b1cc8783ce94466806c924ca7298871 1af8f2df672548f8b3fb4e26ab2b1b35--0b1cc8783ce94466806c924ca7298871 58f8567aa62945dcb986afaaf84e1fe5 0b1cc8783ce94466806c924ca7298871--58f8567aa62945dcb986afaaf84e1fe5 21b47a3216f5445f9dfc8d82f673e162 58f8567aa62945dcb986afaaf84e1fe5--21b47a3216f5445f9dfc8d82f673e162 288a26daaee54b12a1b3776a639fbb27 21b47a3216f5445f9dfc8d82f673e162--288a26daaee54b12a1b3776a639fbb27 78fd5993f4a743ea9155312ba2039e80 288a26daaee54b12a1b3776a639fbb27--78fd5993f4a743ea9155312ba2039e80 a05478b98ee74d23b16203754b912fc2 78fd5993f4a743ea9155312ba2039e80--a05478b98ee74d23b16203754b912fc2 486bb5c334d74940adc4bb880dc7cd88 a05478b98ee74d23b16203754b912fc2--486bb5c334d74940adc4bb880dc7cd88 e671e08a28cc4848a251f2f09399f7a1 486bb5c334d74940adc4bb880dc7cd88--e671e08a28cc4848a251f2f09399f7a1 6021577ae1d0468e8c3ef58741af0242 e671e08a28cc4848a251f2f09399f7a1--6021577ae1d0468e8c3ef58741af0242 e90c2c889992480eba374c4c20f1db50 6021577ae1d0468e8c3ef58741af0242--e90c2c889992480eba374c4c20f1db50 63643e97846c407eb067e6f4ddf1bd96 e90c2c889992480eba374c4c20f1db50--63643e97846c407eb067e6f4ddf1bd96 163e9d4004bd42338369032a7a9130fc 63643e97846c407eb067e6f4ddf1bd96--163e9d4004bd42338369032a7a9130fc d7e0daa826e34ec7b8075f09961813ac 163e9d4004bd42338369032a7a9130fc--d7e0daa826e34ec7b8075f09961813ac f1879d21827144f9911bab1cf17e0fe9 d7e0daa826e34ec7b8075f09961813ac--f1879d21827144f9911bab1cf17e0fe9 4f0b7c984c9945c498b78fdd1c034f33 f1879d21827144f9911bab1cf17e0fe9--4f0b7c984c9945c498b78fdd1c034f33 53521cc775174582b357f9f41e5d3b9d RX(b03) 4f0b7c984c9945c498b78fdd1c034f33--53521cc775174582b357f9f41e5d3b9d 76289819069842d0b654f91c5165fb0d 53521cc775174582b357f9f41e5d3b9d--76289819069842d0b654f91c5165fb0d 412eaa9872b34ee09a03452c5d339578 76289819069842d0b654f91c5165fb0d--412eaa9872b34ee09a03452c5d339578 754705be9aba4a04808460d1850d501b X 412eaa9872b34ee09a03452c5d339578--754705be9aba4a04808460d1850d501b 754705be9aba4a04808460d1850d501b--d98387c438a94944aa9ab1bdd726bed2 c5d29ccf3764434c8222f5ee4c037c7e 754705be9aba4a04808460d1850d501b--c5d29ccf3764434c8222f5ee4c037c7e f0fa46b78f684d5ba2cf763f6d4aa1a9 c5d29ccf3764434c8222f5ee4c037c7e--f0fa46b78f684d5ba2cf763f6d4aa1a9 32061bf7f2d7466f8ab240fb7e14ec0a f0fa46b78f684d5ba2cf763f6d4aa1a9--32061bf7f2d7466f8ab240fb7e14ec0a 3e69385d9d9541e4b31e5b49db0efd68 32061bf7f2d7466f8ab240fb7e14ec0a--3e69385d9d9541e4b31e5b49db0efd68 2e3b8f49bf63461da1ab5be2e4f541b6 3e69385d9d9541e4b31e5b49db0efd68--2e3b8f49bf63461da1ab5be2e4f541b6 62a1804b2306493686149630fcf80ab1 2e3b8f49bf63461da1ab5be2e4f541b6--62a1804b2306493686149630fcf80ab1 18d8040734564f57bffa20165b795ccf 62a1804b2306493686149630fcf80ab1--18d8040734564f57bffa20165b795ccf 389c11c72cf14e719f623f7f4155f59c 18d8040734564f57bffa20165b795ccf--389c11c72cf14e719f623f7f4155f59c 3ec113bf06ab462f9158da1076679779 389c11c72cf14e719f623f7f4155f59c--3ec113bf06ab462f9158da1076679779 6ef8f8dedec348258431cb86a49c9d4d X 3ec113bf06ab462f9158da1076679779--6ef8f8dedec348258431cb86a49c9d4d 6ef8f8dedec348258431cb86a49c9d4d--b14f296c2a5d4759af22dcc6df5998ee 0c741cbee67d4cffa74720007e8c3e7d 6ef8f8dedec348258431cb86a49c9d4d--0c741cbee67d4cffa74720007e8c3e7d 62862b96a1b0418aa6cc6c864c93af7d 0c741cbee67d4cffa74720007e8c3e7d--62862b96a1b0418aa6cc6c864c93af7d 2aaeaa4098874e1690c4aeabca9a44d9 62862b96a1b0418aa6cc6c864c93af7d--2aaeaa4098874e1690c4aeabca9a44d9 5ac5daa483fc4af3a43ce4d7a83ddec7 2aaeaa4098874e1690c4aeabca9a44d9--5ac5daa483fc4af3a43ce4d7a83ddec7 bc79dc1f460240a9b68fe5223a4be11e 5ac5daa483fc4af3a43ce4d7a83ddec7--bc79dc1f460240a9b68fe5223a4be11e 1fd7cec454364d0184715cff0b1eccbd bc79dc1f460240a9b68fe5223a4be11e--1fd7cec454364d0184715cff0b1eccbd 27bb6316827249e990f7c77d90a8c796 1fd7cec454364d0184715cff0b1eccbd--27bb6316827249e990f7c77d90a8c796 ca748616f067483cb3ecda0e63db5971 27bb6316827249e990f7c77d90a8c796--ca748616f067483cb3ecda0e63db5971 913c3f77e62d4137ba7362826a79b57d ca748616f067483cb3ecda0e63db5971--913c3f77e62d4137ba7362826a79b57d a4bf59cdbbe940a1a033579590f4c619 X 913c3f77e62d4137ba7362826a79b57d--a4bf59cdbbe940a1a033579590f4c619 a4bf59cdbbe940a1a033579590f4c619--a297a102502b49c6af4d4c5a4d54cc19 86db8b4924ad4dfc893ceb5b3df8f4c1 a4bf59cdbbe940a1a033579590f4c619--86db8b4924ad4dfc893ceb5b3df8f4c1 ada77cbc03f0490ca8ff0da34c649a5a 86db8b4924ad4dfc893ceb5b3df8f4c1--ada77cbc03f0490ca8ff0da34c649a5a 7caacce544af405bb5081c84d19f2031 ada77cbc03f0490ca8ff0da34c649a5a--7caacce544af405bb5081c84d19f2031 bcda146bf16844b28adf503b08c6fcc9 7caacce544af405bb5081c84d19f2031--bcda146bf16844b28adf503b08c6fcc9 1d8f2ae26376425593d496d27501645d bcda146bf16844b28adf503b08c6fcc9--1d8f2ae26376425593d496d27501645d 489e198717cb47c281f48c50e1175c5e X 1d8f2ae26376425593d496d27501645d--489e198717cb47c281f48c50e1175c5e 489e198717cb47c281f48c50e1175c5e--f132af63e8054be8bac4ccbf998c2f26 7451cf4443674827b21f4f52283d4bc1 489e198717cb47c281f48c50e1175c5e--7451cf4443674827b21f4f52283d4bc1 0e79fb7d835f41c192495de1730dc374 7451cf4443674827b21f4f52283d4bc1--0e79fb7d835f41c192495de1730dc374 e3a52af858304d91a567f5e5eb3a571e 0e79fb7d835f41c192495de1730dc374--e3a52af858304d91a567f5e5eb3a571e e2f6e32fe1114aedb18ddd5e3c981ffb e3a52af858304d91a567f5e5eb3a571e--e2f6e32fe1114aedb18ddd5e3c981ffb fd688bd750494b38982cf9bdc242d72e e2f6e32fe1114aedb18ddd5e3c981ffb--fd688bd750494b38982cf9bdc242d72e 3ceb069aa5ae4abca0a9f8520e26c79b X fd688bd750494b38982cf9bdc242d72e--3ceb069aa5ae4abca0a9f8520e26c79b 3ceb069aa5ae4abca0a9f8520e26c79b--b01542fdf0f240129aeef686aaac2221 172b82a6c54d421ba5f064a715f01648 RZ(-1.0*g1) 3ceb069aa5ae4abca0a9f8520e26c79b--172b82a6c54d421ba5f064a715f01648 d7307423926d40bbb7e648b7110b1c6c X 172b82a6c54d421ba5f064a715f01648--d7307423926d40bbb7e648b7110b1c6c d7307423926d40bbb7e648b7110b1c6c--bd558220b9264a0ca7a26fad551b7f36 21de91a74ba6450681326a05e6cf70a9 X d7307423926d40bbb7e648b7110b1c6c--21de91a74ba6450681326a05e6cf70a9 21de91a74ba6450681326a05e6cf70a9--9b06069ed4e349918ba4afe3f8dd8949 8ca78996eafb42309dee8f57fa419d46 21de91a74ba6450681326a05e6cf70a9--8ca78996eafb42309dee8f57fa419d46 4bc34054538f4115b0fbd49c5b85b38f 8ca78996eafb42309dee8f57fa419d46--4bc34054538f4115b0fbd49c5b85b38f bf05948d5b934e15a59b817a39ed05fb 4bc34054538f4115b0fbd49c5b85b38f--bf05948d5b934e15a59b817a39ed05fb 6886a146d5454167904cef6f2723b545 X bf05948d5b934e15a59b817a39ed05fb--6886a146d5454167904cef6f2723b545 6886a146d5454167904cef6f2723b545--a5c36ad024a745ab858e674217b5e86b e0526f45dbe6498c9801860d0bce873c 6886a146d5454167904cef6f2723b545--e0526f45dbe6498c9801860d0bce873c 6788fe47f2654887967ea150c8955179 e0526f45dbe6498c9801860d0bce873c--6788fe47f2654887967ea150c8955179 8a7864a2c4e54a1ab2e5fda3595fe21c 6788fe47f2654887967ea150c8955179--8a7864a2c4e54a1ab2e5fda3595fe21c 7b43823e842d4d6e8e3ba923840fd068 8a7864a2c4e54a1ab2e5fda3595fe21c--7b43823e842d4d6e8e3ba923840fd068 7b5b246e239a43ec9eb9bbb67c2663af 7b43823e842d4d6e8e3ba923840fd068--7b5b246e239a43ec9eb9bbb67c2663af 1cb466a848d44f6d8326cafa5c3201fb 7b5b246e239a43ec9eb9bbb67c2663af--1cb466a848d44f6d8326cafa5c3201fb c3663f80371b4b43bb56456c5378e653 1cb466a848d44f6d8326cafa5c3201fb--c3663f80371b4b43bb56456c5378e653 f5161e0a448b457a93031b59cf3e94e1 c3663f80371b4b43bb56456c5378e653--f5161e0a448b457a93031b59cf3e94e1 5c65f6d8aad64195a4e642deec6c9d42 f5161e0a448b457a93031b59cf3e94e1--5c65f6d8aad64195a4e642deec6c9d42 ab402e11c8de4bdb9636cf7cc2d62184 5c65f6d8aad64195a4e642deec6c9d42--ab402e11c8de4bdb9636cf7cc2d62184 94efb7c5a40e453690ad599d6089c3ef ab402e11c8de4bdb9636cf7cc2d62184--94efb7c5a40e453690ad599d6089c3ef a18f8e1f690346b19d2bf1dcffecd36f 94efb7c5a40e453690ad599d6089c3ef--a18f8e1f690346b19d2bf1dcffecd36f 9e196b5593714cfdacdc91352cf64d8b a18f8e1f690346b19d2bf1dcffecd36f--9e196b5593714cfdacdc91352cf64d8b 544723b683e6459e81016a6d93b6d967 9e196b5593714cfdacdc91352cf64d8b--544723b683e6459e81016a6d93b6d967 343a5bb79bea4d2c92e5bce08d0b2d6d 544723b683e6459e81016a6d93b6d967--343a5bb79bea4d2c92e5bce08d0b2d6d 3d9bee8f40b04b6d81f325b550154221 343a5bb79bea4d2c92e5bce08d0b2d6d--3d9bee8f40b04b6d81f325b550154221 1e3367c084434759bea3f9d9c3150e1a 3d9bee8f40b04b6d81f325b550154221--1e3367c084434759bea3f9d9c3150e1a a39632c063b64a6e9c1f26da93071680 1e3367c084434759bea3f9d9c3150e1a--a39632c063b64a6e9c1f26da93071680 666bdd458d3c425aa2d084e7332f9f0b a39632c063b64a6e9c1f26da93071680--666bdd458d3c425aa2d084e7332f9f0b 20116760204a49b5b3a48b2863dec93e 666bdd458d3c425aa2d084e7332f9f0b--20116760204a49b5b3a48b2863dec93e 46dee8ffd94e4a14bb28e4c8fef608ff 20116760204a49b5b3a48b2863dec93e--46dee8ffd94e4a14bb28e4c8fef608ff bd86c22e6dd841989ec6f07849f760f8 46dee8ffd94e4a14bb28e4c8fef608ff--bd86c22e6dd841989ec6f07849f760f8 7404adc9f58944858ab6e372b4e235bb bd86c22e6dd841989ec6f07849f760f8--7404adc9f58944858ab6e372b4e235bb 46f124847a404518bf9efd99977a7c7d RX(b13) 7404adc9f58944858ab6e372b4e235bb--46f124847a404518bf9efd99977a7c7d 46f124847a404518bf9efd99977a7c7d--b9163fbe66c14632b96ed743e3760409 1d420794cece485bade1050bd70f7ab4 5a1540b147114cd2a094766227005925 42b3f55c73ed452bab9eac9edbe71e53--5a1540b147114cd2a094766227005925 e31face1281143e1bde6175fa8719b45 5 1ddfdf05900d425384c357d6825d408e 5a1540b147114cd2a094766227005925--1ddfdf05900d425384c357d6825d408e a10417e2856842f182cf4de66c9655db 1ddfdf05900d425384c357d6825d408e--a10417e2856842f182cf4de66c9655db b8fd0ef416b344dea9c197f9bdcd8cb0 X a10417e2856842f182cf4de66c9655db--b8fd0ef416b344dea9c197f9bdcd8cb0 b8fd0ef416b344dea9c197f9bdcd8cb0--0f7be0c515f04043a2fcc41b15bb2255 05445af7be7e4d74becd8d06a6828a39 b8fd0ef416b344dea9c197f9bdcd8cb0--05445af7be7e4d74becd8d06a6828a39 563c8daee1024be38d258972b1d5663e 05445af7be7e4d74becd8d06a6828a39--563c8daee1024be38d258972b1d5663e 9f42a74b9900432c8a1a53194f94083b 563c8daee1024be38d258972b1d5663e--9f42a74b9900432c8a1a53194f94083b 9b26ace70cf9484280d362512aecdc30 9f42a74b9900432c8a1a53194f94083b--9b26ace70cf9484280d362512aecdc30 80762c951c81478bae940b24571f6358 9b26ace70cf9484280d362512aecdc30--80762c951c81478bae940b24571f6358 f32a207557384fa78235ebf738e2c9ab 80762c951c81478bae940b24571f6358--f32a207557384fa78235ebf738e2c9ab 006021a6df3743a9bbb2e7be2ed7504f f32a207557384fa78235ebf738e2c9ab--006021a6df3743a9bbb2e7be2ed7504f 92c1332484c248f39cdbbd33ca9d714e X 006021a6df3743a9bbb2e7be2ed7504f--92c1332484c248f39cdbbd33ca9d714e 92c1332484c248f39cdbbd33ca9d714e--484fa5ab71f3436c88c6a54b96e87761 d3ee3aff61a9494bbcbcdf071b85f7d5 92c1332484c248f39cdbbd33ca9d714e--d3ee3aff61a9494bbcbcdf071b85f7d5 6ac70454cc5f4e078a6941dd540e91c3 d3ee3aff61a9494bbcbcdf071b85f7d5--6ac70454cc5f4e078a6941dd540e91c3 f43c7ab3d15846228a8668dbec7e20e1 6ac70454cc5f4e078a6941dd540e91c3--f43c7ab3d15846228a8668dbec7e20e1 d2c0ec620e0342bd9e380d550dfd7eac f43c7ab3d15846228a8668dbec7e20e1--d2c0ec620e0342bd9e380d550dfd7eac d0177f78bff545b2aa78704a750dab6c d2c0ec620e0342bd9e380d550dfd7eac--d0177f78bff545b2aa78704a750dab6c 7c94be3dcad84cb8bbe2bebd72ec282d d0177f78bff545b2aa78704a750dab6c--7c94be3dcad84cb8bbe2bebd72ec282d eaf4c7689813418fb77f2b05fdc82f9b 7c94be3dcad84cb8bbe2bebd72ec282d--eaf4c7689813418fb77f2b05fdc82f9b ba259949ee154a20ac861b429fa0c0a2 eaf4c7689813418fb77f2b05fdc82f9b--ba259949ee154a20ac861b429fa0c0a2 351d2a389add4d04944083da2a2078d3 ba259949ee154a20ac861b429fa0c0a2--351d2a389add4d04944083da2a2078d3 591f397c841c4412bd7c46752b2bf337 351d2a389add4d04944083da2a2078d3--591f397c841c4412bd7c46752b2bf337 9a354de245254a4b9e059ce789e532d5 591f397c841c4412bd7c46752b2bf337--9a354de245254a4b9e059ce789e532d5 5ff00d140d6946ddbe70fade53a98a0b X 9a354de245254a4b9e059ce789e532d5--5ff00d140d6946ddbe70fade53a98a0b 5ff00d140d6946ddbe70fade53a98a0b--eec547997246478a9f2ea79dcc21a3b1 50a0442258c049669a31e8c2f0e27169 5ff00d140d6946ddbe70fade53a98a0b--50a0442258c049669a31e8c2f0e27169 65fda9c26e474ea1af562ae0d66d6dc1 50a0442258c049669a31e8c2f0e27169--65fda9c26e474ea1af562ae0d66d6dc1 fdef27b219234b3d91617a51ab31ea5c 65fda9c26e474ea1af562ae0d66d6dc1--fdef27b219234b3d91617a51ab31ea5c 66cbcfb239d4473db96b9b0fd1a0fadb X fdef27b219234b3d91617a51ab31ea5c--66cbcfb239d4473db96b9b0fd1a0fadb 66cbcfb239d4473db96b9b0fd1a0fadb--078d130ef2e341d48bc57fd04d22928e 7b416635344b4c42b883a077e3c95ad0 66cbcfb239d4473db96b9b0fd1a0fadb--7b416635344b4c42b883a077e3c95ad0 dfa943a3cda14f86b19799968a0cf137 7b416635344b4c42b883a077e3c95ad0--dfa943a3cda14f86b19799968a0cf137 71c8b928d8234e08aa7a1cfa81a08b41 dfa943a3cda14f86b19799968a0cf137--71c8b928d8234e08aa7a1cfa81a08b41 ce6a79cf3ca247e293e6deef2695839a 71c8b928d8234e08aa7a1cfa81a08b41--ce6a79cf3ca247e293e6deef2695839a 5926185410d14f45a3f70ee0ed83103b ce6a79cf3ca247e293e6deef2695839a--5926185410d14f45a3f70ee0ed83103b bbce4c8c95bc45c59c99d9134d70ac25 5926185410d14f45a3f70ee0ed83103b--bbce4c8c95bc45c59c99d9134d70ac25 969e4cdc510c45379f7acc463797147b bbce4c8c95bc45c59c99d9134d70ac25--969e4cdc510c45379f7acc463797147b 5911919127834cb195abb36b70ef1142 969e4cdc510c45379f7acc463797147b--5911919127834cb195abb36b70ef1142 046e024fc5fb44c38f3f9e14259a41db 5911919127834cb195abb36b70ef1142--046e024fc5fb44c38f3f9e14259a41db ae72759336b34c4fa96fe52b76bbf0d3 046e024fc5fb44c38f3f9e14259a41db--ae72759336b34c4fa96fe52b76bbf0d3 16a73512331142a89352510f492463f0 X ae72759336b34c4fa96fe52b76bbf0d3--16a73512331142a89352510f492463f0 16a73512331142a89352510f492463f0--4300d45d16e24e9fb3f444f8144ea0e3 de59381b2be84f92b5204b9972007fbc RZ(-1.0*g0) 16a73512331142a89352510f492463f0--de59381b2be84f92b5204b9972007fbc 01a675a0ef254ec2a20ed00011374728 X de59381b2be84f92b5204b9972007fbc--01a675a0ef254ec2a20ed00011374728 01a675a0ef254ec2a20ed00011374728--4ef3ebc5ea804562a48b728ba66fe327 21ca03c814474bfe9e13f91f3fbc1266 01a675a0ef254ec2a20ed00011374728--21ca03c814474bfe9e13f91f3fbc1266 770d6fccffd74c9cbf17499ab4be2be9 X 21ca03c814474bfe9e13f91f3fbc1266--770d6fccffd74c9cbf17499ab4be2be9 770d6fccffd74c9cbf17499ab4be2be9--30572b4562ea49b0a79af0e21af77a4c 0ca21cff4d80468195898ef3159a68a6 770d6fccffd74c9cbf17499ab4be2be9--0ca21cff4d80468195898ef3159a68a6 8e8229afa61747f3a0e1837f39bbe64a 0ca21cff4d80468195898ef3159a68a6--8e8229afa61747f3a0e1837f39bbe64a ed22902f17e34e73b799356feac6424e 8e8229afa61747f3a0e1837f39bbe64a--ed22902f17e34e73b799356feac6424e 5bba1aebffaa4be2af470b1dd09380cf ed22902f17e34e73b799356feac6424e--5bba1aebffaa4be2af470b1dd09380cf e9aef61167d44c92b1e2f140dcdb9138 5bba1aebffaa4be2af470b1dd09380cf--e9aef61167d44c92b1e2f140dcdb9138 4d8d66e9b1734eb393a782756bf7356f e9aef61167d44c92b1e2f140dcdb9138--4d8d66e9b1734eb393a782756bf7356f 477b66f50fbe4e1e9279a6fed659a583 4d8d66e9b1734eb393a782756bf7356f--477b66f50fbe4e1e9279a6fed659a583 52635013f052447b99c32e3a85e5af3c X 477b66f50fbe4e1e9279a6fed659a583--52635013f052447b99c32e3a85e5af3c 52635013f052447b99c32e3a85e5af3c--0b1cc8783ce94466806c924ca7298871 cff30e17c19a42bfb1cb00cf8dc24fe2 52635013f052447b99c32e3a85e5af3c--cff30e17c19a42bfb1cb00cf8dc24fe2 6ebb505fd20242a8957326293f709bc4 cff30e17c19a42bfb1cb00cf8dc24fe2--6ebb505fd20242a8957326293f709bc4 81ad5f3750f04be0a5300c08bf9593f6 6ebb505fd20242a8957326293f709bc4--81ad5f3750f04be0a5300c08bf9593f6 4d2712188d0444e1bec8ebd35e01280e 81ad5f3750f04be0a5300c08bf9593f6--4d2712188d0444e1bec8ebd35e01280e 8a4336a38bfd4c5495175990a52d7421 4d2712188d0444e1bec8ebd35e01280e--8a4336a38bfd4c5495175990a52d7421 a72b7582fcb042bbb5743be274a05ca3 8a4336a38bfd4c5495175990a52d7421--a72b7582fcb042bbb5743be274a05ca3 9c5689e154114f568f4a577c301fcad9 a72b7582fcb042bbb5743be274a05ca3--9c5689e154114f568f4a577c301fcad9 008c1584a40547e398822cc3a94552f1 9c5689e154114f568f4a577c301fcad9--008c1584a40547e398822cc3a94552f1 91f23ab218c44f09b463e5521e6d2e98 008c1584a40547e398822cc3a94552f1--91f23ab218c44f09b463e5521e6d2e98 18e1889c0c9142b487348cbc47c2c173 91f23ab218c44f09b463e5521e6d2e98--18e1889c0c9142b487348cbc47c2c173 938e9b77e6d945dbb658c28d4fbb22f5 18e1889c0c9142b487348cbc47c2c173--938e9b77e6d945dbb658c28d4fbb22f5 b22154900c334f19869fd8e86dbf94eb 938e9b77e6d945dbb658c28d4fbb22f5--b22154900c334f19869fd8e86dbf94eb 21b5c92776274243819e98f6d3819b08 b22154900c334f19869fd8e86dbf94eb--21b5c92776274243819e98f6d3819b08 18e2ecce4ae84a519b4b98da2ed8bcb3 21b5c92776274243819e98f6d3819b08--18e2ecce4ae84a519b4b98da2ed8bcb3 5aa905bd51c0498b9c578d484d5e41dd RX(b04) 18e2ecce4ae84a519b4b98da2ed8bcb3--5aa905bd51c0498b9c578d484d5e41dd 9659be887bc04296a0028aa776df06a9 5aa905bd51c0498b9c578d484d5e41dd--9659be887bc04296a0028aa776df06a9 48c7352dcae747889b72ae2a81912e56 9659be887bc04296a0028aa776df06a9--48c7352dcae747889b72ae2a81912e56 c88ece4506694c768e0b0464a45cb958 48c7352dcae747889b72ae2a81912e56--c88ece4506694c768e0b0464a45cb958 8d461fa498b64eb2a9cb15223f425458 X c88ece4506694c768e0b0464a45cb958--8d461fa498b64eb2a9cb15223f425458 8d461fa498b64eb2a9cb15223f425458--c5d29ccf3764434c8222f5ee4c037c7e 1d1377ef7b4c4b4a86f61a84342c513f 8d461fa498b64eb2a9cb15223f425458--1d1377ef7b4c4b4a86f61a84342c513f 2b0afb09de814f01b065f9a1d3aa2eec 1d1377ef7b4c4b4a86f61a84342c513f--2b0afb09de814f01b065f9a1d3aa2eec 23f247be25d749fea579831f8663562a 2b0afb09de814f01b065f9a1d3aa2eec--23f247be25d749fea579831f8663562a b9724df76b0349228f860080a7922655 23f247be25d749fea579831f8663562a--b9724df76b0349228f860080a7922655 414d92f0089d448ead330d96076af19d b9724df76b0349228f860080a7922655--414d92f0089d448ead330d96076af19d b95488fcd0c94555a04790b14f9e9894 414d92f0089d448ead330d96076af19d--b95488fcd0c94555a04790b14f9e9894 cb81c7a67fb54d0383fd145e1fe7ae45 b95488fcd0c94555a04790b14f9e9894--cb81c7a67fb54d0383fd145e1fe7ae45 320da49772bd44d1bbd54a8962c32ff6 X cb81c7a67fb54d0383fd145e1fe7ae45--320da49772bd44d1bbd54a8962c32ff6 320da49772bd44d1bbd54a8962c32ff6--3ec113bf06ab462f9158da1076679779 c225975c24eb4fe0a036158cd84e4f68 320da49772bd44d1bbd54a8962c32ff6--c225975c24eb4fe0a036158cd84e4f68 23e95cf634f7453c83a4b475aa7b72d0 c225975c24eb4fe0a036158cd84e4f68--23e95cf634f7453c83a4b475aa7b72d0 358e530a261a4e9ebb3fc16b56526a96 23e95cf634f7453c83a4b475aa7b72d0--358e530a261a4e9ebb3fc16b56526a96 8ef21c41016b42179b9adbe38b241b74 358e530a261a4e9ebb3fc16b56526a96--8ef21c41016b42179b9adbe38b241b74 3ecde919b1c8482897129549241dbd59 8ef21c41016b42179b9adbe38b241b74--3ecde919b1c8482897129549241dbd59 df5a5d0848e04d5eb5e97b94cf5e99d1 3ecde919b1c8482897129549241dbd59--df5a5d0848e04d5eb5e97b94cf5e99d1 4b995a1903574fdba6fcf29f3557acbb df5a5d0848e04d5eb5e97b94cf5e99d1--4b995a1903574fdba6fcf29f3557acbb 2ef3320a9bdb4961b1222b06be649002 4b995a1903574fdba6fcf29f3557acbb--2ef3320a9bdb4961b1222b06be649002 f356c1a394ca4699a37408a03796fada 2ef3320a9bdb4961b1222b06be649002--f356c1a394ca4699a37408a03796fada a7ec78df2f4f415b822d98d52b9207e5 f356c1a394ca4699a37408a03796fada--a7ec78df2f4f415b822d98d52b9207e5 6c1f068059aa4d1fad2b245b427b46a6 a7ec78df2f4f415b822d98d52b9207e5--6c1f068059aa4d1fad2b245b427b46a6 8ec3e413f11e4b3ab61b1db4769ce37b X 6c1f068059aa4d1fad2b245b427b46a6--8ec3e413f11e4b3ab61b1db4769ce37b 8ec3e413f11e4b3ab61b1db4769ce37b--86db8b4924ad4dfc893ceb5b3df8f4c1 820c1f0351994bb28975937635c55f2f 8ec3e413f11e4b3ab61b1db4769ce37b--820c1f0351994bb28975937635c55f2f c228ccc980f64adda1985dce80226e07 820c1f0351994bb28975937635c55f2f--c228ccc980f64adda1985dce80226e07 e268156b84ca46f5b6d4b60af52b07e8 c228ccc980f64adda1985dce80226e07--e268156b84ca46f5b6d4b60af52b07e8 d7484e4cb088420396037b54403eae40 X e268156b84ca46f5b6d4b60af52b07e8--d7484e4cb088420396037b54403eae40 d7484e4cb088420396037b54403eae40--1d8f2ae26376425593d496d27501645d 8da7785b2cde4bdbbf44b54dab17d8fa d7484e4cb088420396037b54403eae40--8da7785b2cde4bdbbf44b54dab17d8fa 090140a8e7a24841aaa480e64574009e 8da7785b2cde4bdbbf44b54dab17d8fa--090140a8e7a24841aaa480e64574009e 457aeff4aa37413dadbea6c89e1650a3 090140a8e7a24841aaa480e64574009e--457aeff4aa37413dadbea6c89e1650a3 7cbc3661b467422bb9b3903839b0a1e3 457aeff4aa37413dadbea6c89e1650a3--7cbc3661b467422bb9b3903839b0a1e3 c88ed207460547a3898a232d7d1c508d 7cbc3661b467422bb9b3903839b0a1e3--c88ed207460547a3898a232d7d1c508d 82c9c214caa04b8e8511384297f662ed c88ed207460547a3898a232d7d1c508d--82c9c214caa04b8e8511384297f662ed 67ae26629e41489f8b279a74851673e2 82c9c214caa04b8e8511384297f662ed--67ae26629e41489f8b279a74851673e2 084edde644aa46c591c318eb72d0f642 67ae26629e41489f8b279a74851673e2--084edde644aa46c591c318eb72d0f642 d9fad780c64347b8a079de44ec6a695c 084edde644aa46c591c318eb72d0f642--d9fad780c64347b8a079de44ec6a695c 624e90d16b7043c29282cf0d5d21301b d9fad780c64347b8a079de44ec6a695c--624e90d16b7043c29282cf0d5d21301b e46896dad4bf4895afe38a738d0ea026 X 624e90d16b7043c29282cf0d5d21301b--e46896dad4bf4895afe38a738d0ea026 e46896dad4bf4895afe38a738d0ea026--8ca78996eafb42309dee8f57fa419d46 664932c2ef1d4be69dddd62a1d0dd76c RZ(-1.0*g1) e46896dad4bf4895afe38a738d0ea026--664932c2ef1d4be69dddd62a1d0dd76c 9b148cc525e646a8ac4c7f387e4fb340 X 664932c2ef1d4be69dddd62a1d0dd76c--9b148cc525e646a8ac4c7f387e4fb340 9b148cc525e646a8ac4c7f387e4fb340--bf05948d5b934e15a59b817a39ed05fb 8dad9b9c2e9b4181bb15d306d7e17793 9b148cc525e646a8ac4c7f387e4fb340--8dad9b9c2e9b4181bb15d306d7e17793 a310d73a11994cdd887fff2f682ba805 X 8dad9b9c2e9b4181bb15d306d7e17793--a310d73a11994cdd887fff2f682ba805 a310d73a11994cdd887fff2f682ba805--e0526f45dbe6498c9801860d0bce873c a5a3b25197884906a56e776fc7dbcf14 a310d73a11994cdd887fff2f682ba805--a5a3b25197884906a56e776fc7dbcf14 f2137b7cbdd54e49ac653ea416203727 a5a3b25197884906a56e776fc7dbcf14--f2137b7cbdd54e49ac653ea416203727 d28e1d6de4fb4f7ebec5c6ceb073e54a f2137b7cbdd54e49ac653ea416203727--d28e1d6de4fb4f7ebec5c6ceb073e54a a5f74fad4cf6428e897f4dfe9e86b90b d28e1d6de4fb4f7ebec5c6ceb073e54a--a5f74fad4cf6428e897f4dfe9e86b90b b4afb6ed66c544b3be9f4446f17c9f62 a5f74fad4cf6428e897f4dfe9e86b90b--b4afb6ed66c544b3be9f4446f17c9f62 1d7e4ead72ed4776987c2802a23abc42 b4afb6ed66c544b3be9f4446f17c9f62--1d7e4ead72ed4776987c2802a23abc42 15cad472241a4831ab700855627197f6 1d7e4ead72ed4776987c2802a23abc42--15cad472241a4831ab700855627197f6 894d61831378436e8ba955facefdb4e5 X 15cad472241a4831ab700855627197f6--894d61831378436e8ba955facefdb4e5 894d61831378436e8ba955facefdb4e5--5c65f6d8aad64195a4e642deec6c9d42 eb49e4d364fd4776a89bc05af69cb2da 894d61831378436e8ba955facefdb4e5--eb49e4d364fd4776a89bc05af69cb2da 172d924461c54c67a700863f027a0e1d eb49e4d364fd4776a89bc05af69cb2da--172d924461c54c67a700863f027a0e1d c2fa34ba4a2e4909bb909821ab2faeeb 172d924461c54c67a700863f027a0e1d--c2fa34ba4a2e4909bb909821ab2faeeb 58ba46dff3704ea7b887428ef407f983 c2fa34ba4a2e4909bb909821ab2faeeb--58ba46dff3704ea7b887428ef407f983 8ceecdd9ac4146d5bb91790608c6ed5e 58ba46dff3704ea7b887428ef407f983--8ceecdd9ac4146d5bb91790608c6ed5e 6c1d09ad07c444b8b484da80834deab5 8ceecdd9ac4146d5bb91790608c6ed5e--6c1d09ad07c444b8b484da80834deab5 c5f5834d38bb4e7cac4e112488e64696 6c1d09ad07c444b8b484da80834deab5--c5f5834d38bb4e7cac4e112488e64696 871af51b3ddd41afb78234ea8ac1addc c5f5834d38bb4e7cac4e112488e64696--871af51b3ddd41afb78234ea8ac1addc 0dd1d5e582cb4e94905d81ed11cc28a3 871af51b3ddd41afb78234ea8ac1addc--0dd1d5e582cb4e94905d81ed11cc28a3 6ae81fabfeb8479daafc25fadaabdecd 0dd1d5e582cb4e94905d81ed11cc28a3--6ae81fabfeb8479daafc25fadaabdecd 818522d845e44d9ab666bc26d7dfb6da 6ae81fabfeb8479daafc25fadaabdecd--818522d845e44d9ab666bc26d7dfb6da f0f13cea4df843e0940b0a6c132611a5 818522d845e44d9ab666bc26d7dfb6da--f0f13cea4df843e0940b0a6c132611a5 c416ca5906de47f6b7a46f1373324de9 f0f13cea4df843e0940b0a6c132611a5--c416ca5906de47f6b7a46f1373324de9 bd63b2f34ac54379ae668f5f22991e86 c416ca5906de47f6b7a46f1373324de9--bd63b2f34ac54379ae668f5f22991e86 53bfa7c6cff54731994b48c36e9bd36c RX(b14) bd63b2f34ac54379ae668f5f22991e86--53bfa7c6cff54731994b48c36e9bd36c 53bfa7c6cff54731994b48c36e9bd36c--1d420794cece485bade1050bd70f7ab4 a3ef0f377ff34d2681207d337ab584ed 05bac84671e24b10adf0e9f61037c893 e31face1281143e1bde6175fa8719b45--05bac84671e24b10adf0e9f61037c893 8de38f68ded64bb7b00768a99821b455 6 a07eac3a38a743deac09f694345f025c 05bac84671e24b10adf0e9f61037c893--a07eac3a38a743deac09f694345f025c 4b138b834463439485d2efd7bd3bb443 a07eac3a38a743deac09f694345f025c--4b138b834463439485d2efd7bd3bb443 fe0e288059364c6695e04f39951b6f01 4b138b834463439485d2efd7bd3bb443--fe0e288059364c6695e04f39951b6f01 d99d900f1a1a4745b689e1115577a9b1 X fe0e288059364c6695e04f39951b6f01--d99d900f1a1a4745b689e1115577a9b1 d99d900f1a1a4745b689e1115577a9b1--05445af7be7e4d74becd8d06a6828a39 dbe47a15ec634c78b645915bc62a6e3d d99d900f1a1a4745b689e1115577a9b1--dbe47a15ec634c78b645915bc62a6e3d 4327d1a0cf3e4249b06d11b43cedd9e5 dbe47a15ec634c78b645915bc62a6e3d--4327d1a0cf3e4249b06d11b43cedd9e5 fa285508f24a47be847a9ea13f91f0f2 4327d1a0cf3e4249b06d11b43cedd9e5--fa285508f24a47be847a9ea13f91f0f2 ecde8d11975246b7974a88880212df44 fa285508f24a47be847a9ea13f91f0f2--ecde8d11975246b7974a88880212df44 771044fe477a4d708af3a80b8e1364b3 ecde8d11975246b7974a88880212df44--771044fe477a4d708af3a80b8e1364b3 3c21d4c44ecb4a089116e04faaafd4d0 X 771044fe477a4d708af3a80b8e1364b3--3c21d4c44ecb4a089116e04faaafd4d0 3c21d4c44ecb4a089116e04faaafd4d0--006021a6df3743a9bbb2e7be2ed7504f 90ba8b3b809e46a08d29fe172eb97b1f 3c21d4c44ecb4a089116e04faaafd4d0--90ba8b3b809e46a08d29fe172eb97b1f 9b2bf4fe21114964a8f607c2093cd692 90ba8b3b809e46a08d29fe172eb97b1f--9b2bf4fe21114964a8f607c2093cd692 94375d23ae1a47329ab7fd68e7703e2a 9b2bf4fe21114964a8f607c2093cd692--94375d23ae1a47329ab7fd68e7703e2a 560c78c2f94a411c81328f0c3afeb47e 94375d23ae1a47329ab7fd68e7703e2a--560c78c2f94a411c81328f0c3afeb47e 7846b0c98f01454b92e80043d1a94967 560c78c2f94a411c81328f0c3afeb47e--7846b0c98f01454b92e80043d1a94967 528e9ac1a3e24b4289ae8d63bfb6e1a9 7846b0c98f01454b92e80043d1a94967--528e9ac1a3e24b4289ae8d63bfb6e1a9 c0c4c8a685254f0aa9aa20a3c4665732 528e9ac1a3e24b4289ae8d63bfb6e1a9--c0c4c8a685254f0aa9aa20a3c4665732 b5f2e527cd8f49948505ac003b033931 c0c4c8a685254f0aa9aa20a3c4665732--b5f2e527cd8f49948505ac003b033931 dc51d54f821c43a7a5c33b769344a395 b5f2e527cd8f49948505ac003b033931--dc51d54f821c43a7a5c33b769344a395 b25e82c9eaa044f4a016b4651beec940 dc51d54f821c43a7a5c33b769344a395--b25e82c9eaa044f4a016b4651beec940 958b840474174f589d09908c662177b9 b25e82c9eaa044f4a016b4651beec940--958b840474174f589d09908c662177b9 2a68ad6ee2d24bc39c8836be58dd8d8c 958b840474174f589d09908c662177b9--2a68ad6ee2d24bc39c8836be58dd8d8c 2cbf634cc51445b091d56e0a244ac9f6 2a68ad6ee2d24bc39c8836be58dd8d8c--2cbf634cc51445b091d56e0a244ac9f6 bd3159e9bd914445bab73eff3bc231ef X 2cbf634cc51445b091d56e0a244ac9f6--bd3159e9bd914445bab73eff3bc231ef bd3159e9bd914445bab73eff3bc231ef--50a0442258c049669a31e8c2f0e27169 c812899d5f3849c487539b4d8a6988f5 RZ(-1.0*g0) bd3159e9bd914445bab73eff3bc231ef--c812899d5f3849c487539b4d8a6988f5 d863ca8d755b4f3d9e7c8c39a18dedac X c812899d5f3849c487539b4d8a6988f5--d863ca8d755b4f3d9e7c8c39a18dedac d863ca8d755b4f3d9e7c8c39a18dedac--fdef27b219234b3d91617a51ab31ea5c 564453f725b549fda75805a413072ee9 d863ca8d755b4f3d9e7c8c39a18dedac--564453f725b549fda75805a413072ee9 af29ed60cdc74fcab88201f9d6c5349b 564453f725b549fda75805a413072ee9--af29ed60cdc74fcab88201f9d6c5349b 7fdf2ab5e8004bb2aa73737bcc1620e7 af29ed60cdc74fcab88201f9d6c5349b--7fdf2ab5e8004bb2aa73737bcc1620e7 2a0c65094be44d58a774ad0b7c3dc849 7fdf2ab5e8004bb2aa73737bcc1620e7--2a0c65094be44d58a774ad0b7c3dc849 9c8974259b484e438c1654f12dbb9e53 2a0c65094be44d58a774ad0b7c3dc849--9c8974259b484e438c1654f12dbb9e53 9d7818d1d0bf4b27afdd36662acb8615 9c8974259b484e438c1654f12dbb9e53--9d7818d1d0bf4b27afdd36662acb8615 60f6c9212c4c481e93d0d289d514d279 9d7818d1d0bf4b27afdd36662acb8615--60f6c9212c4c481e93d0d289d514d279 618f7074b68243b79dec6c9ad3cf16d2 60f6c9212c4c481e93d0d289d514d279--618f7074b68243b79dec6c9ad3cf16d2 ba0e3d26eba441ec8bb11ebba6862190 618f7074b68243b79dec6c9ad3cf16d2--ba0e3d26eba441ec8bb11ebba6862190 53d6ee1946a0491bb0600aa092580f3a ba0e3d26eba441ec8bb11ebba6862190--53d6ee1946a0491bb0600aa092580f3a a49ab056724e438fbb95e97bcd10f65b 53d6ee1946a0491bb0600aa092580f3a--a49ab056724e438fbb95e97bcd10f65b 6d86382f88fd43569a3766d07c28bc9d a49ab056724e438fbb95e97bcd10f65b--6d86382f88fd43569a3766d07c28bc9d 418c2fb8e4b7471b97213b0557e4a62c 6d86382f88fd43569a3766d07c28bc9d--418c2fb8e4b7471b97213b0557e4a62c 05319f80bf0741da88d224c171ab3ea0 418c2fb8e4b7471b97213b0557e4a62c--05319f80bf0741da88d224c171ab3ea0 3986c069b2d5478e804d6badff5ca643 05319f80bf0741da88d224c171ab3ea0--3986c069b2d5478e804d6badff5ca643 beb81c5494c7485f871912ec2c27bbbb 3986c069b2d5478e804d6badff5ca643--beb81c5494c7485f871912ec2c27bbbb bc1839ec18764a0e99c0ba89c7bf758d X beb81c5494c7485f871912ec2c27bbbb--bc1839ec18764a0e99c0ba89c7bf758d bc1839ec18764a0e99c0ba89c7bf758d--0ca21cff4d80468195898ef3159a68a6 079cee4c4fc6445385d9403444e9107e bc1839ec18764a0e99c0ba89c7bf758d--079cee4c4fc6445385d9403444e9107e 7e08cc59ad7d432b9e3eee8c0bfd1d45 079cee4c4fc6445385d9403444e9107e--7e08cc59ad7d432b9e3eee8c0bfd1d45 98ac289b00724ae799b70fa3057a41a7 7e08cc59ad7d432b9e3eee8c0bfd1d45--98ac289b00724ae799b70fa3057a41a7 53e80e79bad142c3bbc0e2507deddc09 98ac289b00724ae799b70fa3057a41a7--53e80e79bad142c3bbc0e2507deddc09 30787833f5ca4dd0b987b8adbda98d9a 53e80e79bad142c3bbc0e2507deddc09--30787833f5ca4dd0b987b8adbda98d9a d6f267964d4b4ccebf4f2aa3af135997 X 30787833f5ca4dd0b987b8adbda98d9a--d6f267964d4b4ccebf4f2aa3af135997 d6f267964d4b4ccebf4f2aa3af135997--477b66f50fbe4e1e9279a6fed659a583 0a1de5b3cd674aca84a53df6d87b98a8 d6f267964d4b4ccebf4f2aa3af135997--0a1de5b3cd674aca84a53df6d87b98a8 7cb098b9e4a14e38a63105da713869a8 X 0a1de5b3cd674aca84a53df6d87b98a8--7cb098b9e4a14e38a63105da713869a8 7cb098b9e4a14e38a63105da713869a8--cff30e17c19a42bfb1cb00cf8dc24fe2 f75c68fb3cbf4ab5b50e299311fc0991 RZ(-1.0*g0) 7cb098b9e4a14e38a63105da713869a8--f75c68fb3cbf4ab5b50e299311fc0991 85656042e8b74a52a579d8622e7f03f7 X f75c68fb3cbf4ab5b50e299311fc0991--85656042e8b74a52a579d8622e7f03f7 85656042e8b74a52a579d8622e7f03f7--81ad5f3750f04be0a5300c08bf9593f6 22b52de085f54e9b81bbb55b90a3f802 X 85656042e8b74a52a579d8622e7f03f7--22b52de085f54e9b81bbb55b90a3f802 22b52de085f54e9b81bbb55b90a3f802--4d2712188d0444e1bec8ebd35e01280e a8d9a9a30b8b4c8a8a221bde2d9c7974 22b52de085f54e9b81bbb55b90a3f802--a8d9a9a30b8b4c8a8a221bde2d9c7974 9a13664d98c447939303735fda5ff41b a8d9a9a30b8b4c8a8a221bde2d9c7974--9a13664d98c447939303735fda5ff41b fba8f6516f8247d38daf33a26073470a 9a13664d98c447939303735fda5ff41b--fba8f6516f8247d38daf33a26073470a de23735ce7024e40ba734ca7e0d901e2 X fba8f6516f8247d38daf33a26073470a--de23735ce7024e40ba734ca7e0d901e2 de23735ce7024e40ba734ca7e0d901e2--008c1584a40547e398822cc3a94552f1 78d27974b2bb4fe8a4f8177245dc6090 de23735ce7024e40ba734ca7e0d901e2--78d27974b2bb4fe8a4f8177245dc6090 36d7a856d76f42e8a2f9c671b33d1309 78d27974b2bb4fe8a4f8177245dc6090--36d7a856d76f42e8a2f9c671b33d1309 be021c516fce4b7f8e6356898120ebe3 36d7a856d76f42e8a2f9c671b33d1309--be021c516fce4b7f8e6356898120ebe3 72cbf112dbea4e89b5728883c7583932 be021c516fce4b7f8e6356898120ebe3--72cbf112dbea4e89b5728883c7583932 4988dca0875546f380b70d3d66835244 72cbf112dbea4e89b5728883c7583932--4988dca0875546f380b70d3d66835244 78fb07ae189d48d7a8a349a3f7e1baa2 4988dca0875546f380b70d3d66835244--78fb07ae189d48d7a8a349a3f7e1baa2 a7c30294c3254a78b6482e4f50400053 RX(b05) 78fb07ae189d48d7a8a349a3f7e1baa2--a7c30294c3254a78b6482e4f50400053 765d4c14672446a89376a3b11b8bf0e1 a7c30294c3254a78b6482e4f50400053--765d4c14672446a89376a3b11b8bf0e1 b65b61b6d19048daac22d66f8213e264 765d4c14672446a89376a3b11b8bf0e1--b65b61b6d19048daac22d66f8213e264 7b47384255eb41aba4b51fd6c2e502b2 b65b61b6d19048daac22d66f8213e264--7b47384255eb41aba4b51fd6c2e502b2 a4a0d81e9aeb4a6094035c5dc2cd8f49 7b47384255eb41aba4b51fd6c2e502b2--a4a0d81e9aeb4a6094035c5dc2cd8f49 6c672b3364a34ffda446ea7f5898d22c X a4a0d81e9aeb4a6094035c5dc2cd8f49--6c672b3364a34ffda446ea7f5898d22c 6c672b3364a34ffda446ea7f5898d22c--1d1377ef7b4c4b4a86f61a84342c513f 66630b2e4c054889822117eb837767ce 6c672b3364a34ffda446ea7f5898d22c--66630b2e4c054889822117eb837767ce bbd53245cd844f0281392e3df2146b15 66630b2e4c054889822117eb837767ce--bbd53245cd844f0281392e3df2146b15 47fa3dadaf964166b1ba644b85b97ee1 bbd53245cd844f0281392e3df2146b15--47fa3dadaf964166b1ba644b85b97ee1 1d0b1b44779942cc9ceb5523a3df3dda 47fa3dadaf964166b1ba644b85b97ee1--1d0b1b44779942cc9ceb5523a3df3dda ec2952b190834966be029fc0453c7301 1d0b1b44779942cc9ceb5523a3df3dda--ec2952b190834966be029fc0453c7301 feec9dbc1cb24229becdc1d8a6504fb6 X ec2952b190834966be029fc0453c7301--feec9dbc1cb24229becdc1d8a6504fb6 feec9dbc1cb24229becdc1d8a6504fb6--cb81c7a67fb54d0383fd145e1fe7ae45 12395c7111e344d7b5a8e0517164775d feec9dbc1cb24229becdc1d8a6504fb6--12395c7111e344d7b5a8e0517164775d 1b357249062a4850af5597febc4e0808 12395c7111e344d7b5a8e0517164775d--1b357249062a4850af5597febc4e0808 316c7c1c291046a98e7c6d8e255aa81f 1b357249062a4850af5597febc4e0808--316c7c1c291046a98e7c6d8e255aa81f c74ed3fec4714d6695b56bec5cbd61ea 316c7c1c291046a98e7c6d8e255aa81f--c74ed3fec4714d6695b56bec5cbd61ea 859a5a3d4df04930b15c7dd94c9471e7 c74ed3fec4714d6695b56bec5cbd61ea--859a5a3d4df04930b15c7dd94c9471e7 f99538d11a6448c1af886239d5116f2d 859a5a3d4df04930b15c7dd94c9471e7--f99538d11a6448c1af886239d5116f2d 5ee6f1f599a8450f863f92618c67e1f4 f99538d11a6448c1af886239d5116f2d--5ee6f1f599a8450f863f92618c67e1f4 7e1a996ed826489282a1ffc83c86c962 5ee6f1f599a8450f863f92618c67e1f4--7e1a996ed826489282a1ffc83c86c962 51544553ee324b7a9f0b10bebbbb00aa 7e1a996ed826489282a1ffc83c86c962--51544553ee324b7a9f0b10bebbbb00aa 40cfc89af94f4006ac8fa3faf0bbc63f 51544553ee324b7a9f0b10bebbbb00aa--40cfc89af94f4006ac8fa3faf0bbc63f 58ff9e6f34b84a6e926b8c867647992b 40cfc89af94f4006ac8fa3faf0bbc63f--58ff9e6f34b84a6e926b8c867647992b 441dfa3e0ac0422989f7ff832f356d5f 58ff9e6f34b84a6e926b8c867647992b--441dfa3e0ac0422989f7ff832f356d5f 2ef7021c3b524e00bcadbe1383a74e9d 441dfa3e0ac0422989f7ff832f356d5f--2ef7021c3b524e00bcadbe1383a74e9d d31ae7f4a16748c887484d23679f0f76 X 2ef7021c3b524e00bcadbe1383a74e9d--d31ae7f4a16748c887484d23679f0f76 d31ae7f4a16748c887484d23679f0f76--820c1f0351994bb28975937635c55f2f ddfe7855e40747b38739cae9a2c2e546 RZ(-1.0*g1) d31ae7f4a16748c887484d23679f0f76--ddfe7855e40747b38739cae9a2c2e546 7cdc7cfa738e4d64938d595ab3be3d1f X ddfe7855e40747b38739cae9a2c2e546--7cdc7cfa738e4d64938d595ab3be3d1f 7cdc7cfa738e4d64938d595ab3be3d1f--e268156b84ca46f5b6d4b60af52b07e8 4cd9c5f755fc4e9ca62676be996ed781 7cdc7cfa738e4d64938d595ab3be3d1f--4cd9c5f755fc4e9ca62676be996ed781 4b93d959eddb44cf8db912596955b679 4cd9c5f755fc4e9ca62676be996ed781--4b93d959eddb44cf8db912596955b679 26821d9d8c7942fab9274e57df715d60 4b93d959eddb44cf8db912596955b679--26821d9d8c7942fab9274e57df715d60 f95afc7d691a45a4a6306e7eb934d05f 26821d9d8c7942fab9274e57df715d60--f95afc7d691a45a4a6306e7eb934d05f ee43dea5cce2466dab4f60d51b5aa77d f95afc7d691a45a4a6306e7eb934d05f--ee43dea5cce2466dab4f60d51b5aa77d 1ce92810ab384a209da8021aa4f44b66 ee43dea5cce2466dab4f60d51b5aa77d--1ce92810ab384a209da8021aa4f44b66 b7b158aa06644337ac0189b5927c823f 1ce92810ab384a209da8021aa4f44b66--b7b158aa06644337ac0189b5927c823f 376a88dcd6a7452db734a7939446fc45 b7b158aa06644337ac0189b5927c823f--376a88dcd6a7452db734a7939446fc45 6137e563893c473daf61dab2ec357a72 376a88dcd6a7452db734a7939446fc45--6137e563893c473daf61dab2ec357a72 be902f99f5fb4dd8ba2c1fb45142b0e7 6137e563893c473daf61dab2ec357a72--be902f99f5fb4dd8ba2c1fb45142b0e7 7304e165f5e84d14a9fb330cecdb5ac5 be902f99f5fb4dd8ba2c1fb45142b0e7--7304e165f5e84d14a9fb330cecdb5ac5 6d24034da8b941f784da166ac416691f 7304e165f5e84d14a9fb330cecdb5ac5--6d24034da8b941f784da166ac416691f c9139bd75652475caa413522db1cf035 6d24034da8b941f784da166ac416691f--c9139bd75652475caa413522db1cf035 0b93233d4a1947aa95a0a419b66cb07a c9139bd75652475caa413522db1cf035--0b93233d4a1947aa95a0a419b66cb07a 3b348d099cf74b7a9d3d9f3b5963d009 0b93233d4a1947aa95a0a419b66cb07a--3b348d099cf74b7a9d3d9f3b5963d009 302ad1c51d164e0892a29f81dfd55c06 3b348d099cf74b7a9d3d9f3b5963d009--302ad1c51d164e0892a29f81dfd55c06 37c4d15641fb4cd0b0b3533efa900fdd X 302ad1c51d164e0892a29f81dfd55c06--37c4d15641fb4cd0b0b3533efa900fdd 37c4d15641fb4cd0b0b3533efa900fdd--a5a3b25197884906a56e776fc7dbcf14 18f4d089d6984893b353d6a6e5176e7b 37c4d15641fb4cd0b0b3533efa900fdd--18f4d089d6984893b353d6a6e5176e7b 1617a8c8928b4fdaad778e94343414ae 18f4d089d6984893b353d6a6e5176e7b--1617a8c8928b4fdaad778e94343414ae f46cfc5c9afd46e1806fd5217e525801 1617a8c8928b4fdaad778e94343414ae--f46cfc5c9afd46e1806fd5217e525801 15395b68614146d6b8c80da73930aca8 f46cfc5c9afd46e1806fd5217e525801--15395b68614146d6b8c80da73930aca8 a14b184d4ae74a619ffa3e45370d2314 15395b68614146d6b8c80da73930aca8--a14b184d4ae74a619ffa3e45370d2314 1afdc17e1d7240a1976262de7e718ce0 X a14b184d4ae74a619ffa3e45370d2314--1afdc17e1d7240a1976262de7e718ce0 1afdc17e1d7240a1976262de7e718ce0--15cad472241a4831ab700855627197f6 98b4187d49834397ab84219eb0f483a5 1afdc17e1d7240a1976262de7e718ce0--98b4187d49834397ab84219eb0f483a5 e23c930c26464316acdd5ed6f362ad4e X 98b4187d49834397ab84219eb0f483a5--e23c930c26464316acdd5ed6f362ad4e e23c930c26464316acdd5ed6f362ad4e--eb49e4d364fd4776a89bc05af69cb2da de84b36031d3489a98a7fefc440ea09c RZ(-1.0*g1) e23c930c26464316acdd5ed6f362ad4e--de84b36031d3489a98a7fefc440ea09c de8ea3f008be47ac9cc08eb11049a0be X de84b36031d3489a98a7fefc440ea09c--de8ea3f008be47ac9cc08eb11049a0be de8ea3f008be47ac9cc08eb11049a0be--c2fa34ba4a2e4909bb909821ab2faeeb 3b6cb1a90792469c9a7df5b368249475 X de8ea3f008be47ac9cc08eb11049a0be--3b6cb1a90792469c9a7df5b368249475 3b6cb1a90792469c9a7df5b368249475--58ba46dff3704ea7b887428ef407f983 b9020cab33b244e79624e3238478068c 3b6cb1a90792469c9a7df5b368249475--b9020cab33b244e79624e3238478068c 807b7c4400464c3290fe18af58e2198f b9020cab33b244e79624e3238478068c--807b7c4400464c3290fe18af58e2198f 3c4b1ee075f14dacaaa0a49ff376012a 807b7c4400464c3290fe18af58e2198f--3c4b1ee075f14dacaaa0a49ff376012a ffc8a50d95904e9ab6deaf93a2bbdf96 X 3c4b1ee075f14dacaaa0a49ff376012a--ffc8a50d95904e9ab6deaf93a2bbdf96 ffc8a50d95904e9ab6deaf93a2bbdf96--871af51b3ddd41afb78234ea8ac1addc 9a03cdfd922b4c81b26d9a2759524614 ffc8a50d95904e9ab6deaf93a2bbdf96--9a03cdfd922b4c81b26d9a2759524614 8b11eefefb994c4fbe481c588c31f84b 9a03cdfd922b4c81b26d9a2759524614--8b11eefefb994c4fbe481c588c31f84b 90f35d4048ba49d8addeea08a7d15f41 8b11eefefb994c4fbe481c588c31f84b--90f35d4048ba49d8addeea08a7d15f41 14ef1a3330114176bb1a45873395ad22 90f35d4048ba49d8addeea08a7d15f41--14ef1a3330114176bb1a45873395ad22 fcbdc838e6fd4a04ad7fb7b9a974d24e 14ef1a3330114176bb1a45873395ad22--fcbdc838e6fd4a04ad7fb7b9a974d24e 73628a01a5674cfda8b2497e71012d18 fcbdc838e6fd4a04ad7fb7b9a974d24e--73628a01a5674cfda8b2497e71012d18 7cb1f0969cf049a5a4a64638014eef73 RX(b15) 73628a01a5674cfda8b2497e71012d18--7cb1f0969cf049a5a4a64638014eef73 7cb1f0969cf049a5a4a64638014eef73--a3ef0f377ff34d2681207d337ab584ed f77440430dc941629082f76f5d0572f7 8cef36829a6547ecbd0986e290236974 8de38f68ded64bb7b00768a99821b455--8cef36829a6547ecbd0986e290236974 39290b7459794faf89d9abec9e483b8c 7 c9427ab010ac4413b9d63eacfee05bc1 8cef36829a6547ecbd0986e290236974--c9427ab010ac4413b9d63eacfee05bc1 a30db1897bae4db8b0bcc976d90f0a74 c9427ab010ac4413b9d63eacfee05bc1--a30db1897bae4db8b0bcc976d90f0a74 3dc558ff839a46d3a9918c7af956e03f a30db1897bae4db8b0bcc976d90f0a74--3dc558ff839a46d3a9918c7af956e03f 29fa91fe36734b4db7f1b40f70780063 3dc558ff839a46d3a9918c7af956e03f--29fa91fe36734b4db7f1b40f70780063 d4a42facfa9f40cdbc662130a260980d X 29fa91fe36734b4db7f1b40f70780063--d4a42facfa9f40cdbc662130a260980d d4a42facfa9f40cdbc662130a260980d--dbe47a15ec634c78b645915bc62a6e3d 5ea4899a9de442c69b8a14847aa6aebc d4a42facfa9f40cdbc662130a260980d--5ea4899a9de442c69b8a14847aa6aebc b2ff4fc1db1d4412b9598bd5d28b07a5 5ea4899a9de442c69b8a14847aa6aebc--b2ff4fc1db1d4412b9598bd5d28b07a5 df7290f5821c4d769a00bc6eb13042f1 b2ff4fc1db1d4412b9598bd5d28b07a5--df7290f5821c4d769a00bc6eb13042f1 070b5e4649b443a5b5a77f287b6242c1 X df7290f5821c4d769a00bc6eb13042f1--070b5e4649b443a5b5a77f287b6242c1 070b5e4649b443a5b5a77f287b6242c1--771044fe477a4d708af3a80b8e1364b3 ff3eb3afee784883835531d0809d1637 070b5e4649b443a5b5a77f287b6242c1--ff3eb3afee784883835531d0809d1637 f486309b70ca4c32b27cb270b436a737 ff3eb3afee784883835531d0809d1637--f486309b70ca4c32b27cb270b436a737 87858d1f3fc04e65b8bf0c610e87238f f486309b70ca4c32b27cb270b436a737--87858d1f3fc04e65b8bf0c610e87238f 88551ea8a86540b8aebe33fee328459e 87858d1f3fc04e65b8bf0c610e87238f--88551ea8a86540b8aebe33fee328459e 0b62b97314924919b7836af6971aeffe 88551ea8a86540b8aebe33fee328459e--0b62b97314924919b7836af6971aeffe 62846a7d36994d05bf37b2ce77336012 0b62b97314924919b7836af6971aeffe--62846a7d36994d05bf37b2ce77336012 618d27e17e454341a0f8bd284f15d6db 62846a7d36994d05bf37b2ce77336012--618d27e17e454341a0f8bd284f15d6db b0da0ca810a744ee973e69d18ca68899 618d27e17e454341a0f8bd284f15d6db--b0da0ca810a744ee973e69d18ca68899 15189fe263b44eaaa41d757654c1dd58 b0da0ca810a744ee973e69d18ca68899--15189fe263b44eaaa41d757654c1dd58 9da6583384184a2398ad72445ac22e2a 15189fe263b44eaaa41d757654c1dd58--9da6583384184a2398ad72445ac22e2a ee0b73abf55749f58939ca1143e70108 9da6583384184a2398ad72445ac22e2a--ee0b73abf55749f58939ca1143e70108 b0d246569c414d0e8c1e476392f85052 ee0b73abf55749f58939ca1143e70108--b0d246569c414d0e8c1e476392f85052 e2986c3f2a0f441da2bb8c4e1186cfea b0d246569c414d0e8c1e476392f85052--e2986c3f2a0f441da2bb8c4e1186cfea 8b0df09b40ff41e78c44b7e30a855230 e2986c3f2a0f441da2bb8c4e1186cfea--8b0df09b40ff41e78c44b7e30a855230 eb4666dc80c14ae79aaa5df49d434dea 8b0df09b40ff41e78c44b7e30a855230--eb4666dc80c14ae79aaa5df49d434dea 3de6cdf485544687b9f163647c882513 eb4666dc80c14ae79aaa5df49d434dea--3de6cdf485544687b9f163647c882513 19ce8a5b3e2b476a8d9a277e92b8318b 3de6cdf485544687b9f163647c882513--19ce8a5b3e2b476a8d9a277e92b8318b f696951400ba451497809d45f28bfd68 19ce8a5b3e2b476a8d9a277e92b8318b--f696951400ba451497809d45f28bfd68 fb26093df97142a5927cf49eb56de1e2 f696951400ba451497809d45f28bfd68--fb26093df97142a5927cf49eb56de1e2 4a81a0fe7e854a0d8f532cce28e556d8 fb26093df97142a5927cf49eb56de1e2--4a81a0fe7e854a0d8f532cce28e556d8 96643a1caa4743e4bbf48634f40df349 4a81a0fe7e854a0d8f532cce28e556d8--96643a1caa4743e4bbf48634f40df349 be522d32af7e4d03acf45b98e0877492 96643a1caa4743e4bbf48634f40df349--be522d32af7e4d03acf45b98e0877492 ab9db121da774324b9ae24e21e094bf8 be522d32af7e4d03acf45b98e0877492--ab9db121da774324b9ae24e21e094bf8 6729a6a7ec074e30827156575b2e95b0 ab9db121da774324b9ae24e21e094bf8--6729a6a7ec074e30827156575b2e95b0 07994c245bcd4c0cb6a9d0e438db0a93 6729a6a7ec074e30827156575b2e95b0--07994c245bcd4c0cb6a9d0e438db0a93 02c9fc3d43b140d1b3c5ad4141dac9f2 07994c245bcd4c0cb6a9d0e438db0a93--02c9fc3d43b140d1b3c5ad4141dac9f2 7b00f0125d46443e93c4a35760884b92 02c9fc3d43b140d1b3c5ad4141dac9f2--7b00f0125d46443e93c4a35760884b92 40c80778ce254af89e79324eeb589d64 7b00f0125d46443e93c4a35760884b92--40c80778ce254af89e79324eeb589d64 bb675908609c4be681ff0bb37f67f3e7 40c80778ce254af89e79324eeb589d64--bb675908609c4be681ff0bb37f67f3e7 a76ae3a579064acf88286b9eadb63224 bb675908609c4be681ff0bb37f67f3e7--a76ae3a579064acf88286b9eadb63224 ddc40bea6254430cb0e89eaa20881ff1 a76ae3a579064acf88286b9eadb63224--ddc40bea6254430cb0e89eaa20881ff1 8aaab19a6f6f438287b998ea1d4d47af ddc40bea6254430cb0e89eaa20881ff1--8aaab19a6f6f438287b998ea1d4d47af 33b5d41ee5374a17927f5d563010bffa 8aaab19a6f6f438287b998ea1d4d47af--33b5d41ee5374a17927f5d563010bffa 6bc1d054f0bd408ba2a88057f2f4776c 33b5d41ee5374a17927f5d563010bffa--6bc1d054f0bd408ba2a88057f2f4776c fa67fee20c31472699314ec4f24dba92 X 6bc1d054f0bd408ba2a88057f2f4776c--fa67fee20c31472699314ec4f24dba92 fa67fee20c31472699314ec4f24dba92--079cee4c4fc6445385d9403444e9107e f08ff66f24ad4a4c9a3dab28fe811b5e fa67fee20c31472699314ec4f24dba92--f08ff66f24ad4a4c9a3dab28fe811b5e e15216bb2f6b40d799b88a65b718a01b f08ff66f24ad4a4c9a3dab28fe811b5e--e15216bb2f6b40d799b88a65b718a01b 0c410d8b90114253a3510ae84ce048fa e15216bb2f6b40d799b88a65b718a01b--0c410d8b90114253a3510ae84ce048fa 9bf9cb50946a41c69aecff377288c21a X 0c410d8b90114253a3510ae84ce048fa--9bf9cb50946a41c69aecff377288c21a 9bf9cb50946a41c69aecff377288c21a--30787833f5ca4dd0b987b8adbda98d9a 9b288e010724477cb1e895a26dbfee6f 9bf9cb50946a41c69aecff377288c21a--9b288e010724477cb1e895a26dbfee6f ec2efca14eb443afb4abd5adeac699a9 9b288e010724477cb1e895a26dbfee6f--ec2efca14eb443afb4abd5adeac699a9 2fb149b7dbf54ae08c53fcc30d4d0c06 ec2efca14eb443afb4abd5adeac699a9--2fb149b7dbf54ae08c53fcc30d4d0c06 66d148c2d45c4f5890ac09ea8b174a20 2fb149b7dbf54ae08c53fcc30d4d0c06--66d148c2d45c4f5890ac09ea8b174a20 d9058b19479f46a4846d5930e7a2afe8 66d148c2d45c4f5890ac09ea8b174a20--d9058b19479f46a4846d5930e7a2afe8 f3d169148e8b45c1a336c928db123e53 d9058b19479f46a4846d5930e7a2afe8--f3d169148e8b45c1a336c928db123e53 86e3af992cf041cd932d4849aee538b9 X f3d169148e8b45c1a336c928db123e53--86e3af992cf041cd932d4849aee538b9 86e3af992cf041cd932d4849aee538b9--a8d9a9a30b8b4c8a8a221bde2d9c7974 30da094bb4dd496d88e131ce82e67d68 RZ(-1.0*g0) 86e3af992cf041cd932d4849aee538b9--30da094bb4dd496d88e131ce82e67d68 df8b4d048fd24b7eb80ecd91895e6b38 X 30da094bb4dd496d88e131ce82e67d68--df8b4d048fd24b7eb80ecd91895e6b38 df8b4d048fd24b7eb80ecd91895e6b38--fba8f6516f8247d38daf33a26073470a 5fd7eba891ff42289efbc29caa18c981 df8b4d048fd24b7eb80ecd91895e6b38--5fd7eba891ff42289efbc29caa18c981 34f295d3143446dd94c46879cddb4986 X 5fd7eba891ff42289efbc29caa18c981--34f295d3143446dd94c46879cddb4986 34f295d3143446dd94c46879cddb4986--78d27974b2bb4fe8a4f8177245dc6090 365020b4e0104c378ea234f591339cf2 RZ(-1.0*g0) 34f295d3143446dd94c46879cddb4986--365020b4e0104c378ea234f591339cf2 77eea86c830244c0b159ad44ef94f421 X 365020b4e0104c378ea234f591339cf2--77eea86c830244c0b159ad44ef94f421 77eea86c830244c0b159ad44ef94f421--be021c516fce4b7f8e6356898120ebe3 616b4827addd448685a2a7d9be06b52b 77eea86c830244c0b159ad44ef94f421--616b4827addd448685a2a7d9be06b52b 980ce50099e848d9a7fa518952b78743 616b4827addd448685a2a7d9be06b52b--980ce50099e848d9a7fa518952b78743 9202bf41783d4f4fbc93f35c9f29ca4f 980ce50099e848d9a7fa518952b78743--9202bf41783d4f4fbc93f35c9f29ca4f b94db942480b470d94d84ca5f981da36 RX(b06) 9202bf41783d4f4fbc93f35c9f29ca4f--b94db942480b470d94d84ca5f981da36 fb666b4969e3492fa3a1b010bc95210c b94db942480b470d94d84ca5f981da36--fb666b4969e3492fa3a1b010bc95210c f1b3467000384b649bc2c28062a42854 fb666b4969e3492fa3a1b010bc95210c--f1b3467000384b649bc2c28062a42854 594ae0a4949e4f66b3de3ca4940f6db9 f1b3467000384b649bc2c28062a42854--594ae0a4949e4f66b3de3ca4940f6db9 e12488e372ff4a82b1a2ab3f5e1f716f 594ae0a4949e4f66b3de3ca4940f6db9--e12488e372ff4a82b1a2ab3f5e1f716f a82ac38afd7c4077b069ee3202f0907d e12488e372ff4a82b1a2ab3f5e1f716f--a82ac38afd7c4077b069ee3202f0907d 49164e0f8fd34046bb5b0392294e3288 X a82ac38afd7c4077b069ee3202f0907d--49164e0f8fd34046bb5b0392294e3288 49164e0f8fd34046bb5b0392294e3288--66630b2e4c054889822117eb837767ce 26e8f81b2c7c4f1a81561e7bab31cd6a 49164e0f8fd34046bb5b0392294e3288--26e8f81b2c7c4f1a81561e7bab31cd6a 6287c40917d14d719228b841ffd0f4f1 26e8f81b2c7c4f1a81561e7bab31cd6a--6287c40917d14d719228b841ffd0f4f1 f4e66853887c46fea0a62b1d117b84ea 6287c40917d14d719228b841ffd0f4f1--f4e66853887c46fea0a62b1d117b84ea f4507918d78047d990f9962d85aeb37a X f4e66853887c46fea0a62b1d117b84ea--f4507918d78047d990f9962d85aeb37a f4507918d78047d990f9962d85aeb37a--ec2952b190834966be029fc0453c7301 55a4c29e44094d23a29f4f5923ed2810 f4507918d78047d990f9962d85aeb37a--55a4c29e44094d23a29f4f5923ed2810 a485a665f38f436eb97fb5ee5356c02e 55a4c29e44094d23a29f4f5923ed2810--a485a665f38f436eb97fb5ee5356c02e b36f5dd8597e4820b4f7f211eafe70f1 a485a665f38f436eb97fb5ee5356c02e--b36f5dd8597e4820b4f7f211eafe70f1 b5e331f331e14cb6854d58d6c8b4d0eb b36f5dd8597e4820b4f7f211eafe70f1--b5e331f331e14cb6854d58d6c8b4d0eb a42fdad0f107464db33e8a1bf1a0b74a b5e331f331e14cb6854d58d6c8b4d0eb--a42fdad0f107464db33e8a1bf1a0b74a 4783896fd0264327b39e26dd323e4166 a42fdad0f107464db33e8a1bf1a0b74a--4783896fd0264327b39e26dd323e4166 8b02a5695efa44f9af384450ad15d76c 4783896fd0264327b39e26dd323e4166--8b02a5695efa44f9af384450ad15d76c 0dfa79651bf5424c8edcf22c82b5391e 8b02a5695efa44f9af384450ad15d76c--0dfa79651bf5424c8edcf22c82b5391e 3ff43e06f4c241d78bc681ef3c391e01 0dfa79651bf5424c8edcf22c82b5391e--3ff43e06f4c241d78bc681ef3c391e01 68eb3ac0085e4b948ed56ba86d34adc4 3ff43e06f4c241d78bc681ef3c391e01--68eb3ac0085e4b948ed56ba86d34adc4 16373d4efe164a70a0fe161f94f43153 68eb3ac0085e4b948ed56ba86d34adc4--16373d4efe164a70a0fe161f94f43153 61c8fc82b1e4482cac12606e182bb4f9 16373d4efe164a70a0fe161f94f43153--61c8fc82b1e4482cac12606e182bb4f9 4090edb9bc674e5696a6c1f4ade7e4cf 61c8fc82b1e4482cac12606e182bb4f9--4090edb9bc674e5696a6c1f4ade7e4cf 87a9332d25b74a05a3e7cb1e80c67972 4090edb9bc674e5696a6c1f4ade7e4cf--87a9332d25b74a05a3e7cb1e80c67972 2895f2bf24984295ac0e147cf6e4043d 87a9332d25b74a05a3e7cb1e80c67972--2895f2bf24984295ac0e147cf6e4043d 5b6cda95ca5248dda7f6685bdc23d9ac 2895f2bf24984295ac0e147cf6e4043d--5b6cda95ca5248dda7f6685bdc23d9ac ce9f68e6b42d4dd9a60b9cbe3c06edb4 5b6cda95ca5248dda7f6685bdc23d9ac--ce9f68e6b42d4dd9a60b9cbe3c06edb4 168150fce57947469d7062133ad2c3c5 ce9f68e6b42d4dd9a60b9cbe3c06edb4--168150fce57947469d7062133ad2c3c5 476ac32777b5494481e498fd4cb6cb6f 168150fce57947469d7062133ad2c3c5--476ac32777b5494481e498fd4cb6cb6f 38a8f19110264a99b3b2baa7118244da 476ac32777b5494481e498fd4cb6cb6f--38a8f19110264a99b3b2baa7118244da ccd3a0ff98d94d25aa3b8ae71e1e4da0 38a8f19110264a99b3b2baa7118244da--ccd3a0ff98d94d25aa3b8ae71e1e4da0 1179ef8b0cc1487bb1b05a8fd2089e00 ccd3a0ff98d94d25aa3b8ae71e1e4da0--1179ef8b0cc1487bb1b05a8fd2089e00 73ecb4e022e34decb0041561bbd48464 1179ef8b0cc1487bb1b05a8fd2089e00--73ecb4e022e34decb0041561bbd48464 1f39a463daab4bafb6725601872c93e8 73ecb4e022e34decb0041561bbd48464--1f39a463daab4bafb6725601872c93e8 e205ecf2e83a4b4e98799d3ba4f5c51b 1f39a463daab4bafb6725601872c93e8--e205ecf2e83a4b4e98799d3ba4f5c51b d198c90f981d45d09f47882e162eab0a e205ecf2e83a4b4e98799d3ba4f5c51b--d198c90f981d45d09f47882e162eab0a 31bd6ea458ac4b429b055f455ce4284d d198c90f981d45d09f47882e162eab0a--31bd6ea458ac4b429b055f455ce4284d a38766f795b042eda5bd9b1995269ef0 31bd6ea458ac4b429b055f455ce4284d--a38766f795b042eda5bd9b1995269ef0 731c11c1cf364422b8d1315f46e06edd a38766f795b042eda5bd9b1995269ef0--731c11c1cf364422b8d1315f46e06edd 69695fbb54094fb9baa98ab453e1ed28 731c11c1cf364422b8d1315f46e06edd--69695fbb54094fb9baa98ab453e1ed28 18ed526726514ac688f33a9433f812cf 69695fbb54094fb9baa98ab453e1ed28--18ed526726514ac688f33a9433f812cf 6850e6ffe39f4378992137ab7a43cda3 18ed526726514ac688f33a9433f812cf--6850e6ffe39f4378992137ab7a43cda3 2abff8f3f2a34ee4adfe0d0bedf65de7 6850e6ffe39f4378992137ab7a43cda3--2abff8f3f2a34ee4adfe0d0bedf65de7 1be9b28ae07c4dd28f364d78767f4784 2abff8f3f2a34ee4adfe0d0bedf65de7--1be9b28ae07c4dd28f364d78767f4784 44dbbbdc6d104ac3887ab0119d8d5c7f X 1be9b28ae07c4dd28f364d78767f4784--44dbbbdc6d104ac3887ab0119d8d5c7f 44dbbbdc6d104ac3887ab0119d8d5c7f--18f4d089d6984893b353d6a6e5176e7b 6acfa534559d41a4bd9a35cd291e22a6 44dbbbdc6d104ac3887ab0119d8d5c7f--6acfa534559d41a4bd9a35cd291e22a6 050d6684ab7443ea8043616db1264a02 6acfa534559d41a4bd9a35cd291e22a6--050d6684ab7443ea8043616db1264a02 7802d31438cc492d999762c6df7b0b23 050d6684ab7443ea8043616db1264a02--7802d31438cc492d999762c6df7b0b23 ab858a63a11d49e4893ad26db248a034 X 7802d31438cc492d999762c6df7b0b23--ab858a63a11d49e4893ad26db248a034 ab858a63a11d49e4893ad26db248a034--a14b184d4ae74a619ffa3e45370d2314 70692c67ddcd44cfb7b339bdc8b236b0 ab858a63a11d49e4893ad26db248a034--70692c67ddcd44cfb7b339bdc8b236b0 d59d0e0f9a9948038f482d74363008d0 70692c67ddcd44cfb7b339bdc8b236b0--d59d0e0f9a9948038f482d74363008d0 9870e911ecde4da2a5d8b95b240d739d d59d0e0f9a9948038f482d74363008d0--9870e911ecde4da2a5d8b95b240d739d 917b452a97634f82a5ec38955bf4727f 9870e911ecde4da2a5d8b95b240d739d--917b452a97634f82a5ec38955bf4727f aa07d03f43354c859fb378980299d546 917b452a97634f82a5ec38955bf4727f--aa07d03f43354c859fb378980299d546 bf5739ac5bfa47b199b5decef84a13c4 aa07d03f43354c859fb378980299d546--bf5739ac5bfa47b199b5decef84a13c4 0d239534d65942b4b619bd8434258bde X bf5739ac5bfa47b199b5decef84a13c4--0d239534d65942b4b619bd8434258bde 0d239534d65942b4b619bd8434258bde--b9020cab33b244e79624e3238478068c e14759bf57884bbf8175472f68036a67 RZ(-1.0*g1) 0d239534d65942b4b619bd8434258bde--e14759bf57884bbf8175472f68036a67 d2fcdf84fa60406cb8cedc651d221553 X e14759bf57884bbf8175472f68036a67--d2fcdf84fa60406cb8cedc651d221553 d2fcdf84fa60406cb8cedc651d221553--3c4b1ee075f14dacaaa0a49ff376012a 3553f1b5c4c04018a5b1f58654a8894e d2fcdf84fa60406cb8cedc651d221553--3553f1b5c4c04018a5b1f58654a8894e 38ed2b0551494b4e95d4a0b35be2d938 X 3553f1b5c4c04018a5b1f58654a8894e--38ed2b0551494b4e95d4a0b35be2d938 38ed2b0551494b4e95d4a0b35be2d938--9a03cdfd922b4c81b26d9a2759524614 e4192cf8dd9b4bcd9f2d0c49a3b22403 RZ(-1.0*g1) 38ed2b0551494b4e95d4a0b35be2d938--e4192cf8dd9b4bcd9f2d0c49a3b22403 eb9b0ee0fb0a44bbaec2da6516760d97 X e4192cf8dd9b4bcd9f2d0c49a3b22403--eb9b0ee0fb0a44bbaec2da6516760d97 eb9b0ee0fb0a44bbaec2da6516760d97--90f35d4048ba49d8addeea08a7d15f41 79d52e3329794ffd9d9a7f305bcd9ca7 eb9b0ee0fb0a44bbaec2da6516760d97--79d52e3329794ffd9d9a7f305bcd9ca7 458bec696ae94a1f938be03a0a04916e 79d52e3329794ffd9d9a7f305bcd9ca7--458bec696ae94a1f938be03a0a04916e 0ed883417f7d492fac989ce0db59b08d 458bec696ae94a1f938be03a0a04916e--0ed883417f7d492fac989ce0db59b08d 754a4285e1d048efb77f5c2841de730a RX(b16) 0ed883417f7d492fac989ce0db59b08d--754a4285e1d048efb77f5c2841de730a 754a4285e1d048efb77f5c2841de730a--f77440430dc941629082f76f5d0572f7 41d4156ebcf44fc991d813e315ac8be7 293179c6d1a9435fb9536e5d49cfe3d0 39290b7459794faf89d9abec9e483b8c--293179c6d1a9435fb9536e5d49cfe3d0 8b8dace98a974e6794e6f4af013c0aff 293179c6d1a9435fb9536e5d49cfe3d0--8b8dace98a974e6794e6f4af013c0aff 988d1aa383494957a26577fe668889d6 8b8dace98a974e6794e6f4af013c0aff--988d1aa383494957a26577fe668889d6 6bf17bea33064dc7b9e6fb6f75d54054 988d1aa383494957a26577fe668889d6--6bf17bea33064dc7b9e6fb6f75d54054 107cce0c56ea4aad8523ad8593d7adb3 6bf17bea33064dc7b9e6fb6f75d54054--107cce0c56ea4aad8523ad8593d7adb3 6d0ce051f3554095b3182f24d6e8a55c 107cce0c56ea4aad8523ad8593d7adb3--6d0ce051f3554095b3182f24d6e8a55c 3767c11469e340df9602e2ffcb473642 X 6d0ce051f3554095b3182f24d6e8a55c--3767c11469e340df9602e2ffcb473642 3767c11469e340df9602e2ffcb473642--5ea4899a9de442c69b8a14847aa6aebc 781edd367b694b1fa0fc92b8e9bf30b5 RZ(1.0*g0) 3767c11469e340df9602e2ffcb473642--781edd367b694b1fa0fc92b8e9bf30b5 96784d1029a24c2bbf2dd50641e243a2 X 781edd367b694b1fa0fc92b8e9bf30b5--96784d1029a24c2bbf2dd50641e243a2 96784d1029a24c2bbf2dd50641e243a2--df7290f5821c4d769a00bc6eb13042f1 9c05c898de4a4bd1b751eeb73b2b7042 96784d1029a24c2bbf2dd50641e243a2--9c05c898de4a4bd1b751eeb73b2b7042 5af3a5a457434236bb31ff66e8fd9000 9c05c898de4a4bd1b751eeb73b2b7042--5af3a5a457434236bb31ff66e8fd9000 7e147778a1114427b3e3dd8c7f3c9adb 5af3a5a457434236bb31ff66e8fd9000--7e147778a1114427b3e3dd8c7f3c9adb a87f5d278f6b4077abd713bcc5628169 7e147778a1114427b3e3dd8c7f3c9adb--a87f5d278f6b4077abd713bcc5628169 49f67a337d8f448abb263290a1882ef4 a87f5d278f6b4077abd713bcc5628169--49f67a337d8f448abb263290a1882ef4 a795a9b7baf34889b197094e1850b045 49f67a337d8f448abb263290a1882ef4--a795a9b7baf34889b197094e1850b045 1a7fc837d0294488a27203ab3c77a148 a795a9b7baf34889b197094e1850b045--1a7fc837d0294488a27203ab3c77a148 2704261f599d43d1858763dce12c3931 1a7fc837d0294488a27203ab3c77a148--2704261f599d43d1858763dce12c3931 4656681bc916418aa4dabf8281c832da 2704261f599d43d1858763dce12c3931--4656681bc916418aa4dabf8281c832da 1aa3e00d6a4e4879aed955f0cdc1c1ff 4656681bc916418aa4dabf8281c832da--1aa3e00d6a4e4879aed955f0cdc1c1ff 97703c5efde6420bacde540ea76f5f17 1aa3e00d6a4e4879aed955f0cdc1c1ff--97703c5efde6420bacde540ea76f5f17 72421d9f8185406c85be418062cb20ea 97703c5efde6420bacde540ea76f5f17--72421d9f8185406c85be418062cb20ea 428d2bdf55c949f586ba6e9963474a69 72421d9f8185406c85be418062cb20ea--428d2bdf55c949f586ba6e9963474a69 1991fd13672d47de860a9c16f7682738 428d2bdf55c949f586ba6e9963474a69--1991fd13672d47de860a9c16f7682738 0148af9b88654121aa478aab352aa1df 1991fd13672d47de860a9c16f7682738--0148af9b88654121aa478aab352aa1df 07b2ea13f514434785c338ef6e06df15 0148af9b88654121aa478aab352aa1df--07b2ea13f514434785c338ef6e06df15 e57352377f4044ffa022ebdfc3b48039 07b2ea13f514434785c338ef6e06df15--e57352377f4044ffa022ebdfc3b48039 a9ea4cba05c14bf3ae135746aa45fc98 e57352377f4044ffa022ebdfc3b48039--a9ea4cba05c14bf3ae135746aa45fc98 2622517e46e0428ca35bbc987b89c74d a9ea4cba05c14bf3ae135746aa45fc98--2622517e46e0428ca35bbc987b89c74d 630e9f86e49d49c299cb994893b8b211 2622517e46e0428ca35bbc987b89c74d--630e9f86e49d49c299cb994893b8b211 f222507367fc4b53a188893b2465b474 630e9f86e49d49c299cb994893b8b211--f222507367fc4b53a188893b2465b474 88f3b0d237c5474992d681efb71890e2 f222507367fc4b53a188893b2465b474--88f3b0d237c5474992d681efb71890e2 6b922f45a0714be3a38e1e67d0ab3d08 88f3b0d237c5474992d681efb71890e2--6b922f45a0714be3a38e1e67d0ab3d08 d712d0babe194a9684e380ac9eddc954 6b922f45a0714be3a38e1e67d0ab3d08--d712d0babe194a9684e380ac9eddc954 ed9f1057288140a990b603e31cbf8fc1 d712d0babe194a9684e380ac9eddc954--ed9f1057288140a990b603e31cbf8fc1 c1cfdf8bd8e14a02b738eb820b9ebf64 ed9f1057288140a990b603e31cbf8fc1--c1cfdf8bd8e14a02b738eb820b9ebf64 c583f195e0784b70907474e208f82ea5 c1cfdf8bd8e14a02b738eb820b9ebf64--c583f195e0784b70907474e208f82ea5 2f2c88e30fef4e48abc375764ca963aa c583f195e0784b70907474e208f82ea5--2f2c88e30fef4e48abc375764ca963aa 4a8f2eb15f1e4638b39186003d385da8 2f2c88e30fef4e48abc375764ca963aa--4a8f2eb15f1e4638b39186003d385da8 822ba72d4b294f82b702bdd33e1906c2 4a8f2eb15f1e4638b39186003d385da8--822ba72d4b294f82b702bdd33e1906c2 92ef1e08e3d749ab83d51edf16bbc748 822ba72d4b294f82b702bdd33e1906c2--92ef1e08e3d749ab83d51edf16bbc748 426f1dfb82284af9b0b590726039be6b 92ef1e08e3d749ab83d51edf16bbc748--426f1dfb82284af9b0b590726039be6b ad02f00e8d9d479fb01e09ef6c6c64c4 426f1dfb82284af9b0b590726039be6b--ad02f00e8d9d479fb01e09ef6c6c64c4 9953441cafab4f7890faea76a0c235d5 ad02f00e8d9d479fb01e09ef6c6c64c4--9953441cafab4f7890faea76a0c235d5 4c1e0ad9f7b844f9a9d053ce3dd6a7f3 9953441cafab4f7890faea76a0c235d5--4c1e0ad9f7b844f9a9d053ce3dd6a7f3 5210ccb72a1a4a41ba095d20c56f78aa 4c1e0ad9f7b844f9a9d053ce3dd6a7f3--5210ccb72a1a4a41ba095d20c56f78aa adc2cac07b354376b5568a607c3318f2 X 5210ccb72a1a4a41ba095d20c56f78aa--adc2cac07b354376b5568a607c3318f2 adc2cac07b354376b5568a607c3318f2--f08ff66f24ad4a4c9a3dab28fe811b5e d60e2b3c07d248f3b03a9f57b2d4e079 RZ(-1.0*g0) adc2cac07b354376b5568a607c3318f2--d60e2b3c07d248f3b03a9f57b2d4e079 f20b802c60624b3ba7c0ce564be269e1 X d60e2b3c07d248f3b03a9f57b2d4e079--f20b802c60624b3ba7c0ce564be269e1 f20b802c60624b3ba7c0ce564be269e1--0c410d8b90114253a3510ae84ce048fa e0466ecc491648939582cd2fe5b4e237 f20b802c60624b3ba7c0ce564be269e1--e0466ecc491648939582cd2fe5b4e237 bc379b19ee724969bc91c4b44dfc8c57 e0466ecc491648939582cd2fe5b4e237--bc379b19ee724969bc91c4b44dfc8c57 21069eaaedde47359b798eb30c155e99 bc379b19ee724969bc91c4b44dfc8c57--21069eaaedde47359b798eb30c155e99 140b6b10055744fd954450df0e27cfa5 21069eaaedde47359b798eb30c155e99--140b6b10055744fd954450df0e27cfa5 669dbf31ac414807b8d809db98e6d206 140b6b10055744fd954450df0e27cfa5--669dbf31ac414807b8d809db98e6d206 eb62afde4b1f4880857e8a1e96d22333 669dbf31ac414807b8d809db98e6d206--eb62afde4b1f4880857e8a1e96d22333 91eba53fece04d2dbf2d58038336d63e eb62afde4b1f4880857e8a1e96d22333--91eba53fece04d2dbf2d58038336d63e e3d5d6f098674d22814095d99f6d0938 91eba53fece04d2dbf2d58038336d63e--e3d5d6f098674d22814095d99f6d0938 5a000729e1974f7a998ebc3127634a7a e3d5d6f098674d22814095d99f6d0938--5a000729e1974f7a998ebc3127634a7a bcb68e1a25764ffd87729b0266636f58 5a000729e1974f7a998ebc3127634a7a--bcb68e1a25764ffd87729b0266636f58 780f58604f8e4edabba298ac0ed96595 bcb68e1a25764ffd87729b0266636f58--780f58604f8e4edabba298ac0ed96595 3b9cf65933da41f4b34060d3c8bc1b01 780f58604f8e4edabba298ac0ed96595--3b9cf65933da41f4b34060d3c8bc1b01 7bd8c6f666da4a109bd883a0d9473f44 3b9cf65933da41f4b34060d3c8bc1b01--7bd8c6f666da4a109bd883a0d9473f44 4ce6a8b286d8486fba09dd5ccf60e232 7bd8c6f666da4a109bd883a0d9473f44--4ce6a8b286d8486fba09dd5ccf60e232 c5154e49a3c445e2900dfae2e4fecda8 X 4ce6a8b286d8486fba09dd5ccf60e232--c5154e49a3c445e2900dfae2e4fecda8 c5154e49a3c445e2900dfae2e4fecda8--616b4827addd448685a2a7d9be06b52b 148c68e08a7542a78ef40e08523cc178 RZ(-1.0*g0) c5154e49a3c445e2900dfae2e4fecda8--148c68e08a7542a78ef40e08523cc178 6d88a1f28ad540a5a9075c2e7a10a013 X 148c68e08a7542a78ef40e08523cc178--6d88a1f28ad540a5a9075c2e7a10a013 6d88a1f28ad540a5a9075c2e7a10a013--9202bf41783d4f4fbc93f35c9f29ca4f 4fc65459464c4c62a2977f101eb2cf50 RX(b07) 6d88a1f28ad540a5a9075c2e7a10a013--4fc65459464c4c62a2977f101eb2cf50 7bb6054466e249d3be9190a986f6cf87 4fc65459464c4c62a2977f101eb2cf50--7bb6054466e249d3be9190a986f6cf87 895aadd2798041bc9440088b66659371 7bb6054466e249d3be9190a986f6cf87--895aadd2798041bc9440088b66659371 2f3e8d33bbd7487792d54904ddac8d0c 895aadd2798041bc9440088b66659371--2f3e8d33bbd7487792d54904ddac8d0c 5a1f546752f545608194047a87e61176 2f3e8d33bbd7487792d54904ddac8d0c--5a1f546752f545608194047a87e61176 1a5751b0f0964b5aaf5685d12d2e266c 5a1f546752f545608194047a87e61176--1a5751b0f0964b5aaf5685d12d2e266c dbe5c4112a4c480087eed04a95d76ff6 1a5751b0f0964b5aaf5685d12d2e266c--dbe5c4112a4c480087eed04a95d76ff6 938b8c3ba76b424dbc12730969f6a870 X dbe5c4112a4c480087eed04a95d76ff6--938b8c3ba76b424dbc12730969f6a870 938b8c3ba76b424dbc12730969f6a870--26e8f81b2c7c4f1a81561e7bab31cd6a ea1763cddea147329c52333bee353c31 RZ(1.0*g1) 938b8c3ba76b424dbc12730969f6a870--ea1763cddea147329c52333bee353c31 d6727618b8b14b70a294b0fffd1ff272 X ea1763cddea147329c52333bee353c31--d6727618b8b14b70a294b0fffd1ff272 d6727618b8b14b70a294b0fffd1ff272--f4e66853887c46fea0a62b1d117b84ea 6a4ea08ee9b14544a9ae501c38b39956 d6727618b8b14b70a294b0fffd1ff272--6a4ea08ee9b14544a9ae501c38b39956 75c9078253ff45cb8680e9e3861e4984 6a4ea08ee9b14544a9ae501c38b39956--75c9078253ff45cb8680e9e3861e4984 ace6a32980d6447abe228834ec8e7799 75c9078253ff45cb8680e9e3861e4984--ace6a32980d6447abe228834ec8e7799 2b0c1388273147a0aee76d21a9e54dac ace6a32980d6447abe228834ec8e7799--2b0c1388273147a0aee76d21a9e54dac 44db25dfe153470894842b9aa6f7925d 2b0c1388273147a0aee76d21a9e54dac--44db25dfe153470894842b9aa6f7925d 208ee9b500ae4900a3b1bc904c52fc93 44db25dfe153470894842b9aa6f7925d--208ee9b500ae4900a3b1bc904c52fc93 0272247471dc491ba46d897156698377 208ee9b500ae4900a3b1bc904c52fc93--0272247471dc491ba46d897156698377 d5ac6ecfde32426586bd30848b89355d 0272247471dc491ba46d897156698377--d5ac6ecfde32426586bd30848b89355d c556efcd83e248d4826542861e1dc77d d5ac6ecfde32426586bd30848b89355d--c556efcd83e248d4826542861e1dc77d 2c51f07da7644a7cb646b5e5e4de459a c556efcd83e248d4826542861e1dc77d--2c51f07da7644a7cb646b5e5e4de459a 1b2be82034b2479fbc3df24dec6316d5 2c51f07da7644a7cb646b5e5e4de459a--1b2be82034b2479fbc3df24dec6316d5 69bc291cd3884983ac0693ead8ec60b6 1b2be82034b2479fbc3df24dec6316d5--69bc291cd3884983ac0693ead8ec60b6 7ac18b4004154c40bf21aa978c18413b 69bc291cd3884983ac0693ead8ec60b6--7ac18b4004154c40bf21aa978c18413b f4055ad4330d442eb8aba04182282c77 7ac18b4004154c40bf21aa978c18413b--f4055ad4330d442eb8aba04182282c77 c6a3439360d34bf8973c628b76e9c0ff f4055ad4330d442eb8aba04182282c77--c6a3439360d34bf8973c628b76e9c0ff 781c3d310b0e4d9fb3fedf262d3ac96c c6a3439360d34bf8973c628b76e9c0ff--781c3d310b0e4d9fb3fedf262d3ac96c 5e15882dbbb244ec867cd942ca70be1e 781c3d310b0e4d9fb3fedf262d3ac96c--5e15882dbbb244ec867cd942ca70be1e 789c8a0481784ce6b862a1fc44ce0169 5e15882dbbb244ec867cd942ca70be1e--789c8a0481784ce6b862a1fc44ce0169 50451f2da5e9499090573a55b50f1074 789c8a0481784ce6b862a1fc44ce0169--50451f2da5e9499090573a55b50f1074 2b59258a13a44891ad665c95c30e0ce3 50451f2da5e9499090573a55b50f1074--2b59258a13a44891ad665c95c30e0ce3 d2e1d59804504c54ab924fe4720efd56 2b59258a13a44891ad665c95c30e0ce3--d2e1d59804504c54ab924fe4720efd56 9b16670c4cd4449eae9b3820c0230b46 d2e1d59804504c54ab924fe4720efd56--9b16670c4cd4449eae9b3820c0230b46 be51511d176f4c22b6d379cd6e76f418 9b16670c4cd4449eae9b3820c0230b46--be51511d176f4c22b6d379cd6e76f418 ed6fd1890c1b4681882aa6a00e746491 be51511d176f4c22b6d379cd6e76f418--ed6fd1890c1b4681882aa6a00e746491 6fe4941ee52f484fa5d07f1a217a948c ed6fd1890c1b4681882aa6a00e746491--6fe4941ee52f484fa5d07f1a217a948c 0dba308dad3b49c181d9433c46cadcb3 6fe4941ee52f484fa5d07f1a217a948c--0dba308dad3b49c181d9433c46cadcb3 480c34a58d094493b820cf03bafeb62e 0dba308dad3b49c181d9433c46cadcb3--480c34a58d094493b820cf03bafeb62e bad737f5ee4c4ee2beba401bcb2a4606 480c34a58d094493b820cf03bafeb62e--bad737f5ee4c4ee2beba401bcb2a4606 94e7b20b7ed14e81a6d0b18c6845996d bad737f5ee4c4ee2beba401bcb2a4606--94e7b20b7ed14e81a6d0b18c6845996d e4962d4adb064c90b1fc638b16265c91 94e7b20b7ed14e81a6d0b18c6845996d--e4962d4adb064c90b1fc638b16265c91 f0bad921096c44a19cd323baf23321d0 e4962d4adb064c90b1fc638b16265c91--f0bad921096c44a19cd323baf23321d0 b28f8bbff50c43f4bbb7d4b2dad71b76 f0bad921096c44a19cd323baf23321d0--b28f8bbff50c43f4bbb7d4b2dad71b76 b1497698ce5245f4a940d4f9460f2ec0 b28f8bbff50c43f4bbb7d4b2dad71b76--b1497698ce5245f4a940d4f9460f2ec0 b526a25643244c8d920388b0a945581d b1497698ce5245f4a940d4f9460f2ec0--b526a25643244c8d920388b0a945581d c72372caa2ed4c6e8c39592d7bc76587 b526a25643244c8d920388b0a945581d--c72372caa2ed4c6e8c39592d7bc76587 a0b52fa3e1854e90a038b8ad80cc5b1f c72372caa2ed4c6e8c39592d7bc76587--a0b52fa3e1854e90a038b8ad80cc5b1f e1ddf9aa00f74e46a70a9b8ac3847290 X a0b52fa3e1854e90a038b8ad80cc5b1f--e1ddf9aa00f74e46a70a9b8ac3847290 e1ddf9aa00f74e46a70a9b8ac3847290--6acfa534559d41a4bd9a35cd291e22a6 fad8d09d7d7c4bc1b688b2c2542a718d RZ(-1.0*g1) e1ddf9aa00f74e46a70a9b8ac3847290--fad8d09d7d7c4bc1b688b2c2542a718d 32e4d91ec12b48b1862a0d7c959efa27 X fad8d09d7d7c4bc1b688b2c2542a718d--32e4d91ec12b48b1862a0d7c959efa27 32e4d91ec12b48b1862a0d7c959efa27--7802d31438cc492d999762c6df7b0b23 2e15651cf2c64d80b502d058fa454337 32e4d91ec12b48b1862a0d7c959efa27--2e15651cf2c64d80b502d058fa454337 98aed0acf7464fe1bcccb412e9edb208 2e15651cf2c64d80b502d058fa454337--98aed0acf7464fe1bcccb412e9edb208 718f410a12bc471eb384e64164b990ae 98aed0acf7464fe1bcccb412e9edb208--718f410a12bc471eb384e64164b990ae 217e551667a7448c91d46e3a74e4bc46 718f410a12bc471eb384e64164b990ae--217e551667a7448c91d46e3a74e4bc46 853ae9eb229c4a0bbc364cb8f5e732d5 217e551667a7448c91d46e3a74e4bc46--853ae9eb229c4a0bbc364cb8f5e732d5 6a0778e6c6fa4a53878ebaed6e7a2f56 853ae9eb229c4a0bbc364cb8f5e732d5--6a0778e6c6fa4a53878ebaed6e7a2f56 fd57275ab6344fe8815d0f3a78c3cc68 6a0778e6c6fa4a53878ebaed6e7a2f56--fd57275ab6344fe8815d0f3a78c3cc68 67adb06fa9484431a3af2a5d7fb24468 fd57275ab6344fe8815d0f3a78c3cc68--67adb06fa9484431a3af2a5d7fb24468 9623c9cae14b4787b74d740b28bd97a7 67adb06fa9484431a3af2a5d7fb24468--9623c9cae14b4787b74d740b28bd97a7 600bbf8b1d8648f3bcd3f4bcdde9f841 9623c9cae14b4787b74d740b28bd97a7--600bbf8b1d8648f3bcd3f4bcdde9f841 42aad3ddcc11422fa57c8418f43f496a 600bbf8b1d8648f3bcd3f4bcdde9f841--42aad3ddcc11422fa57c8418f43f496a da82f94f1d554332868f13ff3e506a13 42aad3ddcc11422fa57c8418f43f496a--da82f94f1d554332868f13ff3e506a13 d0d0f8b03d2640f3b3f3ab12937f604b da82f94f1d554332868f13ff3e506a13--d0d0f8b03d2640f3b3f3ab12937f604b 3dbdcb60deb8414da3456e8c04a054aa d0d0f8b03d2640f3b3f3ab12937f604b--3dbdcb60deb8414da3456e8c04a054aa b5dbf9f1129440a491710d7b5852836f X 3dbdcb60deb8414da3456e8c04a054aa--b5dbf9f1129440a491710d7b5852836f b5dbf9f1129440a491710d7b5852836f--79d52e3329794ffd9d9a7f305bcd9ca7 4a9c314e48bb4ff09597cdb0b9bdaf00 RZ(-1.0*g1) b5dbf9f1129440a491710d7b5852836f--4a9c314e48bb4ff09597cdb0b9bdaf00 efb753485d2a4cf5a32c8af730733410 X 4a9c314e48bb4ff09597cdb0b9bdaf00--efb753485d2a4cf5a32c8af730733410 efb753485d2a4cf5a32c8af730733410--0ed883417f7d492fac989ce0db59b08d a5263ece616c4e138ccea0d135b2c991 RX(b17) efb753485d2a4cf5a32c8af730733410--a5263ece616c4e138ccea0d135b2c991 a5263ece616c4e138ccea0d135b2c991--41d4156ebcf44fc991d813e315ac8be7"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -2.2398435456962376\nMaxCut cost at iteration 10: 7.695787914761295\nMaxCut cost at iteration 20: 7.796022383095295\nMaxCut cost at iteration 30: 7.983584879024725\nMaxCut cost at iteration 40: 8.001057475558458\nMaxCut cost at iteration 50: 8.006428935038779\nMaxCut cost at iteration 60: 8.088541430635065\nMaxCut cost at iteration 70: 8.670731771660416\nMaxCut cost at iteration 80: 8.959747597413308\nMaxCut cost at iteration 90: 8.999997312038321\nMaxCut cost at iteration 100: 8.999999999787534\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 11011010  2023-10-12T17:03:11.011643 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.006756732932883166\nEpoch 40 - Loss: 0.0013178262682413558\nEpoch 60 - Loss: 0.00024411275385784526\nEpoch 80 - Loss: 1.8109270091472735e-05\nEpoch 100 - Loss: 3.3443547512265775e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-10-12T17:03:13.242767 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_tools/","title":"Tools for quantum machine learning","text":"<p>Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning</li> <li>a set of tools for optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/qml_tools/#quantum-machine-learning-constructors","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_tools/#feature-maps","title":"Feature maps","text":"<p>A few feature maps are directly available for loading classical data into quantum circuits by encoding them into gate rotation angles.</p> <pre><code>from qadence import feature_map\nn_qubits = 3\nfm = feature_map(n_qubits, fm_type=\"fourier\")\nfm = feature_map(n_qubits, fm_type=\"chebyshev\")\nfm = feature_map(n_qubits, fm_type=\"tower\")\n</code></pre> <pre><code>Fourier = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nChebyshev KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['2*acos(phi)']]\nTower KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['4*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['6*acos(phi)']]\n</code></pre>"},{"location":"qml/qml_tools/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> d0d7f98c0a1c490daced88d53d593d2c 0 3780c06376c148fb92b5a1f832adfabf RX(theta\u2080) d0d7f98c0a1c490daced88d53d593d2c--3780c06376c148fb92b5a1f832adfabf 4cd91d48589d49d4adc3646f44ef550b 1 36a87d37b3ee4935a057ef80aee34cd0 RY(theta\u2083) 3780c06376c148fb92b5a1f832adfabf--36a87d37b3ee4935a057ef80aee34cd0 102a774cced24c4db603e1fff72ba842 RX(theta\u2086) 36a87d37b3ee4935a057ef80aee34cd0--102a774cced24c4db603e1fff72ba842 becd618cf07d42daa05bcd32ccdf2f10 102a774cced24c4db603e1fff72ba842--becd618cf07d42daa05bcd32ccdf2f10 bfe6a8700d444f5d822708d1c7deaf1a becd618cf07d42daa05bcd32ccdf2f10--bfe6a8700d444f5d822708d1c7deaf1a bf0ae01fc0914789bd1dc5ef2cca7cf1 RX(theta\u2089) bfe6a8700d444f5d822708d1c7deaf1a--bf0ae01fc0914789bd1dc5ef2cca7cf1 e57cdf4094d146c09f187ed5d3314b86 RY(theta\u2081\u2082) bf0ae01fc0914789bd1dc5ef2cca7cf1--e57cdf4094d146c09f187ed5d3314b86 2a5d22e33ed5438796beabd4e24b1fc3 RX(theta\u2081\u2085) e57cdf4094d146c09f187ed5d3314b86--2a5d22e33ed5438796beabd4e24b1fc3 cb34aca9915a4d14a740bdf2eae6caaa 2a5d22e33ed5438796beabd4e24b1fc3--cb34aca9915a4d14a740bdf2eae6caaa f1db49ed8d1f4182a206c7f4171c379d cb34aca9915a4d14a740bdf2eae6caaa--f1db49ed8d1f4182a206c7f4171c379d 85585d5a88b74086a69dd942d4039afc f1db49ed8d1f4182a206c7f4171c379d--85585d5a88b74086a69dd942d4039afc 5e480a2c01114bcc8dba60aae8773d6c e8d4dace600d425cae7d0defd05504c0 RX(theta\u2081) 4cd91d48589d49d4adc3646f44ef550b--e8d4dace600d425cae7d0defd05504c0 0f0d0ad0cb8445abbac66c39bd5141b1 2 41f7314ec164467a86780c262549e15a RY(theta\u2084) e8d4dace600d425cae7d0defd05504c0--41f7314ec164467a86780c262549e15a d471e43feba84f529e0e1af6df41abe5 RX(theta\u2087) 41f7314ec164467a86780c262549e15a--d471e43feba84f529e0e1af6df41abe5 5b37442b63304e68933daad46f3c5d64 X d471e43feba84f529e0e1af6df41abe5--5b37442b63304e68933daad46f3c5d64 5b37442b63304e68933daad46f3c5d64--becd618cf07d42daa05bcd32ccdf2f10 7a8f12bad0ee450282065a7e104023ba 5b37442b63304e68933daad46f3c5d64--7a8f12bad0ee450282065a7e104023ba 5220a756b767428bb3bccc60ee3d55f0 RX(theta\u2081\u2080) 7a8f12bad0ee450282065a7e104023ba--5220a756b767428bb3bccc60ee3d55f0 4714677d456b486d85c4baa668be4e30 RY(theta\u2081\u2083) 5220a756b767428bb3bccc60ee3d55f0--4714677d456b486d85c4baa668be4e30 7f9b1d11aefe486ca8dcac25db34fcfb RX(theta\u2081\u2086) 4714677d456b486d85c4baa668be4e30--7f9b1d11aefe486ca8dcac25db34fcfb e45533809ddc488fbb79933967b65af6 X 7f9b1d11aefe486ca8dcac25db34fcfb--e45533809ddc488fbb79933967b65af6 e45533809ddc488fbb79933967b65af6--cb34aca9915a4d14a740bdf2eae6caaa 6c2f98ee0a174870aa114979d0e2925e e45533809ddc488fbb79933967b65af6--6c2f98ee0a174870aa114979d0e2925e 6c2f98ee0a174870aa114979d0e2925e--5e480a2c01114bcc8dba60aae8773d6c cd97ee8b128b4db9a1ab96a0fc9e8149 4a8b2bbca88e40ba82de1105fcc9b219 RX(theta\u2082) 0f0d0ad0cb8445abbac66c39bd5141b1--4a8b2bbca88e40ba82de1105fcc9b219 5605760201dc42bdaa28055d6e203efc RY(theta\u2085) 4a8b2bbca88e40ba82de1105fcc9b219--5605760201dc42bdaa28055d6e203efc 44752a747dc94d5cb8b74b156b4a2a3f RX(theta\u2088) 5605760201dc42bdaa28055d6e203efc--44752a747dc94d5cb8b74b156b4a2a3f 152dc8b1ba9f45df9ad7788bc0c55ee0 44752a747dc94d5cb8b74b156b4a2a3f--152dc8b1ba9f45df9ad7788bc0c55ee0 4ece085582ad45cf8d56995410c0b8eb X 152dc8b1ba9f45df9ad7788bc0c55ee0--4ece085582ad45cf8d56995410c0b8eb 4ece085582ad45cf8d56995410c0b8eb--7a8f12bad0ee450282065a7e104023ba 38b83dc5c4db432c93c19606a294a0ef RX(theta\u2081\u2081) 4ece085582ad45cf8d56995410c0b8eb--38b83dc5c4db432c93c19606a294a0ef 90de4bfcd42c4c4ea266afb0c014aea8 RY(theta\u2081\u2084) 38b83dc5c4db432c93c19606a294a0ef--90de4bfcd42c4c4ea266afb0c014aea8 74cf9491dab644deb0ae825c843555e4 RX(theta\u2081\u2087) 90de4bfcd42c4c4ea266afb0c014aea8--74cf9491dab644deb0ae825c843555e4 56c591c81bec4cfb8485c3a7be07096e 74cf9491dab644deb0ae825c843555e4--56c591c81bec4cfb8485c3a7be07096e 343ab99445814ac1ae510a98442a71be X 56c591c81bec4cfb8485c3a7be07096e--343ab99445814ac1ae510a98442a71be 343ab99445814ac1ae510a98442a71be--6c2f98ee0a174870aa114979d0e2925e 343ab99445814ac1ae510a98442a71be--cd97ee8b128b4db9a1ab96a0fc9e8149 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> de79444d4ea54f25a012b262a81f0d0c 0 fc5d3045539c492abba804261250d178 RX(phi\u2080) de79444d4ea54f25a012b262a81f0d0c--fc5d3045539c492abba804261250d178 ab405fbfc3e548b9867f28586e918bfb 1 a806599e2e714631a2d8fff4905b3474 RY(phi\u2083) fc5d3045539c492abba804261250d178--a806599e2e714631a2d8fff4905b3474 195973cfcf03487eba3047c096311f1b RX(phi\u2086) a806599e2e714631a2d8fff4905b3474--195973cfcf03487eba3047c096311f1b b7e9e234e67649e0a9290786d1788fb0 195973cfcf03487eba3047c096311f1b--b7e9e234e67649e0a9290786d1788fb0 82361c8c3a90428185188e90720f7892 b7e9e234e67649e0a9290786d1788fb0--82361c8c3a90428185188e90720f7892 8c7b558a0737446594e773ca71b897b9 RX(phi\u2089) 82361c8c3a90428185188e90720f7892--8c7b558a0737446594e773ca71b897b9 55aad25a21e742cebab492ae54977f37 RY(phi\u2081\u2082) 8c7b558a0737446594e773ca71b897b9--55aad25a21e742cebab492ae54977f37 ad97d3b9c4a44d1aa9b3f82156b8d06e RX(phi\u2081\u2085) 55aad25a21e742cebab492ae54977f37--ad97d3b9c4a44d1aa9b3f82156b8d06e b99bf5a851124fc3b9285ccbd2459ba0 ad97d3b9c4a44d1aa9b3f82156b8d06e--b99bf5a851124fc3b9285ccbd2459ba0 b54121c124e2451187043cdd4927f0b5 b99bf5a851124fc3b9285ccbd2459ba0--b54121c124e2451187043cdd4927f0b5 c5cc45a214fd4bc38eb33bc729308768 b54121c124e2451187043cdd4927f0b5--c5cc45a214fd4bc38eb33bc729308768 6b0075f65173473abc466259948755e8 8ce06adca83e428ebc43c3e19ba10722 RX(phi\u2081) ab405fbfc3e548b9867f28586e918bfb--8ce06adca83e428ebc43c3e19ba10722 cace6cb671334eb69acb0c1364ee912e 2 04a22d669802459e82978a9e5b9071db RY(phi\u2084) 8ce06adca83e428ebc43c3e19ba10722--04a22d669802459e82978a9e5b9071db 84ac73ae02f24ea38436f89f780450ac RX(phi\u2087) 04a22d669802459e82978a9e5b9071db--84ac73ae02f24ea38436f89f780450ac cc5b4ad337e24ec095a284f10a50c27a PHASE(phi_ent\u2080) 84ac73ae02f24ea38436f89f780450ac--cc5b4ad337e24ec095a284f10a50c27a cc5b4ad337e24ec095a284f10a50c27a--b7e9e234e67649e0a9290786d1788fb0 a13755779ebf4d7ba97526b5d47361fc cc5b4ad337e24ec095a284f10a50c27a--a13755779ebf4d7ba97526b5d47361fc 3c8ec9593a7941bf8236b14224100b77 RX(phi\u2081\u2080) a13755779ebf4d7ba97526b5d47361fc--3c8ec9593a7941bf8236b14224100b77 e1c6fb9389d84c029f92d88452846023 RY(phi\u2081\u2083) 3c8ec9593a7941bf8236b14224100b77--e1c6fb9389d84c029f92d88452846023 44ac9f1e31bc4897880e706504421e4f RX(phi\u2081\u2086) e1c6fb9389d84c029f92d88452846023--44ac9f1e31bc4897880e706504421e4f 506b50fd94094e4e84ab3d1c5255c4e4 PHASE(phi_ent\u2082) 44ac9f1e31bc4897880e706504421e4f--506b50fd94094e4e84ab3d1c5255c4e4 506b50fd94094e4e84ab3d1c5255c4e4--b99bf5a851124fc3b9285ccbd2459ba0 d72cc357b84f41808eabdc14fd1ddae4 506b50fd94094e4e84ab3d1c5255c4e4--d72cc357b84f41808eabdc14fd1ddae4 d72cc357b84f41808eabdc14fd1ddae4--6b0075f65173473abc466259948755e8 e0f2f8a85f084e2092df6f1b54f2ac34 ec71011a24564b66ad9f662fcb8d188d RX(phi\u2082) cace6cb671334eb69acb0c1364ee912e--ec71011a24564b66ad9f662fcb8d188d 82cdeddce3124872b6206ddd0cebbfd2 RY(phi\u2085) ec71011a24564b66ad9f662fcb8d188d--82cdeddce3124872b6206ddd0cebbfd2 0b3367319fa14de28d51eb100e7d8c4f RX(phi\u2088) 82cdeddce3124872b6206ddd0cebbfd2--0b3367319fa14de28d51eb100e7d8c4f d468169dafe84f758ea5e1065b881bcb 0b3367319fa14de28d51eb100e7d8c4f--d468169dafe84f758ea5e1065b881bcb 489dfd7a18964fbbae8ce8d71993ffbd PHASE(phi_ent\u2081) d468169dafe84f758ea5e1065b881bcb--489dfd7a18964fbbae8ce8d71993ffbd 489dfd7a18964fbbae8ce8d71993ffbd--a13755779ebf4d7ba97526b5d47361fc f5c460be0a7c4041848c903d2b270ca7 RX(phi\u2081\u2081) 489dfd7a18964fbbae8ce8d71993ffbd--f5c460be0a7c4041848c903d2b270ca7 e09a6d948b1b43c49d2562d4127f6e03 RY(phi\u2081\u2084) f5c460be0a7c4041848c903d2b270ca7--e09a6d948b1b43c49d2562d4127f6e03 4ce19fd909c14d05b6c0199fb08d1253 RX(phi\u2081\u2087) e09a6d948b1b43c49d2562d4127f6e03--4ce19fd909c14d05b6c0199fb08d1253 33c17db5d1d6486ead1f940473fab4c8 4ce19fd909c14d05b6c0199fb08d1253--33c17db5d1d6486ead1f940473fab4c8 836fe573abe94b5bb892e8a6b62de199 PHASE(phi_ent\u2083) 33c17db5d1d6486ead1f940473fab4c8--836fe573abe94b5bb892e8a6b62de199 836fe573abe94b5bb892e8a6b62de199--d72cc357b84f41808eabdc14fd1ddae4 836fe573abe94b5bb892e8a6b62de199--e0f2f8a85f084e2092df6f1b54f2ac34 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like NN interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> cluster_6654e4fc1f194b939b4cc8653b680cd1 cluster_e354996137cf428c8746d8d8be21d9ee 738786c67c1f45b781040b85f06c9a19 0 34fd5af070ba4c0ab03caaa8827c7b30 RX(theta\u2080) 738786c67c1f45b781040b85f06c9a19--34fd5af070ba4c0ab03caaa8827c7b30 31b55e07ba11442e84b6ed6984a886be 1 5e6389655efa4b739101453f9101e5a9 RY(theta\u2083) 34fd5af070ba4c0ab03caaa8827c7b30--5e6389655efa4b739101453f9101e5a9 39f17214e3644bdb89707a327c626455 RX(theta\u2086) 5e6389655efa4b739101453f9101e5a9--39f17214e3644bdb89707a327c626455 b38150a3e5a546dd923c942f6195f9eb HamEvo 39f17214e3644bdb89707a327c626455--b38150a3e5a546dd923c942f6195f9eb a53ee4de30a14aeca20d5cc0b1ad341a RX(theta\u2089) b38150a3e5a546dd923c942f6195f9eb--a53ee4de30a14aeca20d5cc0b1ad341a c2f3df9ff4cd439b95cfddba08080c0f RY(theta\u2081\u2082) a53ee4de30a14aeca20d5cc0b1ad341a--c2f3df9ff4cd439b95cfddba08080c0f 3c31d063183949afbe0d80f8f870ccc5 RX(theta\u2081\u2085) c2f3df9ff4cd439b95cfddba08080c0f--3c31d063183949afbe0d80f8f870ccc5 52beb0620d364f26b4da0267056af2f1 HamEvo 3c31d063183949afbe0d80f8f870ccc5--52beb0620d364f26b4da0267056af2f1 c188c994462e43ae82db2781c02610b0 52beb0620d364f26b4da0267056af2f1--c188c994462e43ae82db2781c02610b0 5ae5d0adbe6743bfbf1313c8f331f93b 3f8bd837a44746d0870c6f47f62b17af RX(theta\u2081) 31b55e07ba11442e84b6ed6984a886be--3f8bd837a44746d0870c6f47f62b17af 4d9e840c5bd64820bf44eb527b9e4f6c 2 342090b6db114a14a4fab1bfc9bcd8cb RY(theta\u2084) 3f8bd837a44746d0870c6f47f62b17af--342090b6db114a14a4fab1bfc9bcd8cb 7f32e2e95b3b43db8f61a39f265b6844 RX(theta\u2087) 342090b6db114a14a4fab1bfc9bcd8cb--7f32e2e95b3b43db8f61a39f265b6844 d26f9b36ec03437bba04a2e85645d5e4 t = theta_t\u2080 7f32e2e95b3b43db8f61a39f265b6844--d26f9b36ec03437bba04a2e85645d5e4 48121c42cffa4cb9b25c66bd570ca887 RX(theta\u2081\u2080) d26f9b36ec03437bba04a2e85645d5e4--48121c42cffa4cb9b25c66bd570ca887 d20e5c6adad94965b07f3210e6a9f1f5 RY(theta\u2081\u2083) 48121c42cffa4cb9b25c66bd570ca887--d20e5c6adad94965b07f3210e6a9f1f5 40f51bd517ce4aa6843f74fdf7d38db1 RX(theta\u2081\u2086) d20e5c6adad94965b07f3210e6a9f1f5--40f51bd517ce4aa6843f74fdf7d38db1 975acf261c044630844641b1691e2b35 t = theta_t\u2081 40f51bd517ce4aa6843f74fdf7d38db1--975acf261c044630844641b1691e2b35 975acf261c044630844641b1691e2b35--5ae5d0adbe6743bfbf1313c8f331f93b 66a038a683164461855550f470c98950 a3fc6f480ead4166990ebe08629cd155 RX(theta\u2082) 4d9e840c5bd64820bf44eb527b9e4f6c--a3fc6f480ead4166990ebe08629cd155 7665a51ea6194d389e2abf4051975291 RY(theta\u2085) a3fc6f480ead4166990ebe08629cd155--7665a51ea6194d389e2abf4051975291 164afb26b691483c8d1c5351b1c5bc94 RX(theta\u2088) 7665a51ea6194d389e2abf4051975291--164afb26b691483c8d1c5351b1c5bc94 de775e6201e5497db2a3c003fd39b8fd 164afb26b691483c8d1c5351b1c5bc94--de775e6201e5497db2a3c003fd39b8fd 5c6d2b5039b04786a483e2f31bdc5aa0 RX(theta\u2081\u2081) de775e6201e5497db2a3c003fd39b8fd--5c6d2b5039b04786a483e2f31bdc5aa0 cbb34fb28b834edc89729f3af39f78a9 RY(theta\u2081\u2084) 5c6d2b5039b04786a483e2f31bdc5aa0--cbb34fb28b834edc89729f3af39f78a9 2cdc48b595514a15977c922f6f87cb38 RX(theta\u2081\u2087) cbb34fb28b834edc89729f3af39f78a9--2cdc48b595514a15977c922f6f87cb38 b99412e9f61f41728b9e1c32cce4fa9c 2cdc48b595514a15977c922f6f87cb38--b99412e9f61f41728b9e1c32cce4fa9c b99412e9f61f41728b9e1c32cce4fa9c--66a038a683164461855550f470c98950 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> cluster_3908618746d740c7bb6867dec54a70e8 cluster_7726cdde65964ce88060fe8e91cfc7c4 d009418f4410463fb144df79bda11617 0 934fb34deaa747aa89ace4f5090ffb82 RX(theta\u2080) d009418f4410463fb144df79bda11617--934fb34deaa747aa89ace4f5090ffb82 edb6eebc73654509b1bc3edd7d5bbd95 1 8e28436cd36e4003941f911d684835d5 RY(theta\u2086) 934fb34deaa747aa89ace4f5090ffb82--8e28436cd36e4003941f911d684835d5 155e15bfde074df29956054895e64f8a RX(theta\u2081\u2082) 8e28436cd36e4003941f911d684835d5--155e15bfde074df29956054895e64f8a d8192adc05074657be5fda2fafc651ed 155e15bfde074df29956054895e64f8a--d8192adc05074657be5fda2fafc651ed 07d9091cf5fd4daa8cd88af5e9e397dd RX(theta\u2081\u2088) d8192adc05074657be5fda2fafc651ed--07d9091cf5fd4daa8cd88af5e9e397dd 976ffc8b02724392992fdcee0cbc6e82 RY(theta\u2082\u2084) 07d9091cf5fd4daa8cd88af5e9e397dd--976ffc8b02724392992fdcee0cbc6e82 8000e5311ed34486a204df35531e0687 RX(theta\u2083\u2080) 976ffc8b02724392992fdcee0cbc6e82--8000e5311ed34486a204df35531e0687 a2116905dc9c43b9bba14672f7906e20 8000e5311ed34486a204df35531e0687--a2116905dc9c43b9bba14672f7906e20 9179db170b0743c4880acbbd2080a36e a2116905dc9c43b9bba14672f7906e20--9179db170b0743c4880acbbd2080a36e f9e9bcbb59af44ffaac5f1eee20be81c b313e9ead95647c6a91baf00e59decb0 RX(theta\u2081) edb6eebc73654509b1bc3edd7d5bbd95--b313e9ead95647c6a91baf00e59decb0 3b51530b90ea47058b7671e040bdbb01 2 a8dc13fc2cf54581aa153688a4f962e9 RY(theta\u2087) b313e9ead95647c6a91baf00e59decb0--a8dc13fc2cf54581aa153688a4f962e9 7638ef93ebab4226ae950b6d22ea895b RX(theta\u2081\u2083) a8dc13fc2cf54581aa153688a4f962e9--7638ef93ebab4226ae950b6d22ea895b 64b57aab4a3f42ce99ccc29a0321fc55 7638ef93ebab4226ae950b6d22ea895b--64b57aab4a3f42ce99ccc29a0321fc55 e2568c45dde34cbab6b643fd887c44d9 RX(theta\u2081\u2089) 64b57aab4a3f42ce99ccc29a0321fc55--e2568c45dde34cbab6b643fd887c44d9 668e0650399e4ae1a78e6a5419f390c4 RY(theta\u2082\u2085) e2568c45dde34cbab6b643fd887c44d9--668e0650399e4ae1a78e6a5419f390c4 5b8d1a4ec58549e6ac6805ff6a223148 RX(theta\u2083\u2081) 668e0650399e4ae1a78e6a5419f390c4--5b8d1a4ec58549e6ac6805ff6a223148 2a0a8e05b5134750be39062616aa0a3c 5b8d1a4ec58549e6ac6805ff6a223148--2a0a8e05b5134750be39062616aa0a3c 2a0a8e05b5134750be39062616aa0a3c--f9e9bcbb59af44ffaac5f1eee20be81c 4d4f5fe26d0e4323a290862c503fcc99 e1616ddc844e400f8a149be7b01e43d4 RX(theta\u2082) 3b51530b90ea47058b7671e040bdbb01--e1616ddc844e400f8a149be7b01e43d4 8f640e32377744a9a8bfc5c5f5a987dc 3 2d9744cd9fd84e13a412cfc24e23c194 RY(theta\u2088) e1616ddc844e400f8a149be7b01e43d4--2d9744cd9fd84e13a412cfc24e23c194 93cb303ef98f4218be23ccaa12a58ddd RX(theta\u2081\u2084) 2d9744cd9fd84e13a412cfc24e23c194--93cb303ef98f4218be23ccaa12a58ddd 6757f862c23342cd9a37e5785e07ef7a HamEvo 93cb303ef98f4218be23ccaa12a58ddd--6757f862c23342cd9a37e5785e07ef7a ebf3004aa1c74863902c613cb6373e75 RX(theta\u2082\u2080) 6757f862c23342cd9a37e5785e07ef7a--ebf3004aa1c74863902c613cb6373e75 c6dba59b950547a8ae82697db3289932 RY(theta\u2082\u2086) ebf3004aa1c74863902c613cb6373e75--c6dba59b950547a8ae82697db3289932 c4e2961b0f754fa8aced200d8b2ee007 RX(theta\u2083\u2082) c6dba59b950547a8ae82697db3289932--c4e2961b0f754fa8aced200d8b2ee007 f0c3376021604a4e9a85ebd6fcaa2655 HamEvo c4e2961b0f754fa8aced200d8b2ee007--f0c3376021604a4e9a85ebd6fcaa2655 f0c3376021604a4e9a85ebd6fcaa2655--4d4f5fe26d0e4323a290862c503fcc99 1a1416ce8e504a16a5a44a1461a584ff f3d53c2ac0ef4e75aa62a65821e267d6 RX(theta\u2083) 8f640e32377744a9a8bfc5c5f5a987dc--f3d53c2ac0ef4e75aa62a65821e267d6 2fac57fac4124358ac64490d97597b22 4 e9fd995808064fb58d1b038765a39851 RY(theta\u2089) f3d53c2ac0ef4e75aa62a65821e267d6--e9fd995808064fb58d1b038765a39851 dcb5b9c84cf1459990b76db507c86102 RX(theta\u2081\u2085) e9fd995808064fb58d1b038765a39851--dcb5b9c84cf1459990b76db507c86102 f4deb67a5f5d42728e826bc525d95a37 t = theta_t\u2080 dcb5b9c84cf1459990b76db507c86102--f4deb67a5f5d42728e826bc525d95a37 2e4575f2d1b64fb597f218a3b849e495 RX(theta\u2082\u2081) f4deb67a5f5d42728e826bc525d95a37--2e4575f2d1b64fb597f218a3b849e495 032f267d4a3d4ee4b92a811f7d8f7a12 RY(theta\u2082\u2087) 2e4575f2d1b64fb597f218a3b849e495--032f267d4a3d4ee4b92a811f7d8f7a12 6cab502ce73943c880658f9d8dfb378b RX(theta\u2083\u2083) 032f267d4a3d4ee4b92a811f7d8f7a12--6cab502ce73943c880658f9d8dfb378b 891281b53f9d44e7b0c2c24b0f5bcf3e t = theta_t\u2081 6cab502ce73943c880658f9d8dfb378b--891281b53f9d44e7b0c2c24b0f5bcf3e 891281b53f9d44e7b0c2c24b0f5bcf3e--1a1416ce8e504a16a5a44a1461a584ff 52f4b9dccfb043af9c22e7597dcc0a4b abc2b42cd7094fcd97db242b8e0aebe1 RX(theta\u2084) 2fac57fac4124358ac64490d97597b22--abc2b42cd7094fcd97db242b8e0aebe1 866b2ace06494ea59e745b06d6736087 5 9abc7ba8a83b49afa113613153376833 RY(theta\u2081\u2080) abc2b42cd7094fcd97db242b8e0aebe1--9abc7ba8a83b49afa113613153376833 7911f9e1dc77483d995c9cdae0547157 RX(theta\u2081\u2086) 9abc7ba8a83b49afa113613153376833--7911f9e1dc77483d995c9cdae0547157 449dd5424df741e790bebcd37cefa5da 7911f9e1dc77483d995c9cdae0547157--449dd5424df741e790bebcd37cefa5da 19d72718676c4bc88bf83d9b50d81730 RX(theta\u2082\u2082) 449dd5424df741e790bebcd37cefa5da--19d72718676c4bc88bf83d9b50d81730 0d31c4d23f014ca7afdbed3be254c593 RY(theta\u2082\u2088) 19d72718676c4bc88bf83d9b50d81730--0d31c4d23f014ca7afdbed3be254c593 76ddb1d8b28040d89751c62a1f0526d3 RX(theta\u2083\u2084) 0d31c4d23f014ca7afdbed3be254c593--76ddb1d8b28040d89751c62a1f0526d3 885dfd8447b44073b621a783c19727ca 76ddb1d8b28040d89751c62a1f0526d3--885dfd8447b44073b621a783c19727ca 885dfd8447b44073b621a783c19727ca--52f4b9dccfb043af9c22e7597dcc0a4b d127749241174ccca2d6dabc9458c345 458c6d35351446e1b6a4e0d8c7dcfe9f RX(theta\u2085) 866b2ace06494ea59e745b06d6736087--458c6d35351446e1b6a4e0d8c7dcfe9f 07cff52588724962b27a50a6f27831d8 RY(theta\u2081\u2081) 458c6d35351446e1b6a4e0d8c7dcfe9f--07cff52588724962b27a50a6f27831d8 2e106bb2fae14226bdb74fb1103462a5 RX(theta\u2081\u2087) 07cff52588724962b27a50a6f27831d8--2e106bb2fae14226bdb74fb1103462a5 18619c5403af4bc48e2c23cccd1fef6d 2e106bb2fae14226bdb74fb1103462a5--18619c5403af4bc48e2c23cccd1fef6d 8b73220879c34d13891ab948459f8a79 RX(theta\u2082\u2083) 18619c5403af4bc48e2c23cccd1fef6d--8b73220879c34d13891ab948459f8a79 8a7459446ae64ac98971f37f5be11ec8 RY(theta\u2082\u2089) 8b73220879c34d13891ab948459f8a79--8a7459446ae64ac98971f37f5be11ec8 0ad0dc4e8c5044aba930d2a1f96ceeb0 RX(theta\u2083\u2085) 8a7459446ae64ac98971f37f5be11ec8--0ad0dc4e8c5044aba930d2a1f96ceeb0 bac26c1d41354ea69853a3f8a398a27a 0ad0dc4e8c5044aba930d2a1f96ceeb0--bac26c1d41354ea69853a3f8a398a27a bac26c1d41354ea69853a3f8a398a27a--d127749241174ccca2d6dabc9458c345"},{"location":"qml/qml_tools/#machine-learning-tools","title":"Machine Learning Tools","text":""},{"location":"qml/qml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using <code>qadence</code>, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader\ndef dataloader() -&gt; DataLoader:\nbatch_size = 5\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\nreturn DataLoader(dataset, batch_size=batch_size)\ndef dictdataloader() -&gt; DictDataLoader:\nbatch_size = 5\nkeys = [\"y1\", \"y2\"]\ndls = {}\nfor k in keys:\nx = torch.rand(batch_size, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\ndataloader = DataLoader(dataset, batch_size=batch_size)\ndls[k] = dataloader\nreturn DictDataLoader(dls)\nn_epochs = 2\n# iterate standard DataLoader\ndl = dataloader()\nfor i in range(n_epochs):\ndata = next(iter(dl))\n# iterate DictDataLoader\nddl = dictdataloader()\nfor i in range(n_epochs):\ndata = next(iter(ddl))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"qml/qml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, <code>qadence</code> also offers a few out-of-the-box routines for optimizing differentiable models like <code>QNN</code>s and <code>QuantumModel</code>s containing either trainable and/or non-trainable parameters (you can refer to this for a refresh about different parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <pre><code>\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <pre><code>\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/qml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nimport matplotlib.pyplot as plt\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\nplt.plot(y.numpy())\nplt.plot(model(input_values).detach().numpy())\n</code></pre> <pre><code>\n</code></pre> <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/qml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1,2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 75645180-4e9e-4f3a-a91e-368aecd8e859, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 09105109-3493-42e3-868d-441a825b5e4b, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 58b3e6fa-78bc-4d38-8102-8540ffdd4376, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 15376d5d-34fd-43e7-ba13-c496c61c2534, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 44e9b569-3821-4469-9488-34524b642af4, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': e96815c6-4f86-4e9d-872f-eb4075468b24, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': bd7409c1-10b3-465b-a210-96dd6736abfa, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 726ed705-41c5-4dbd-b4de-0cc3ec8379df, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 18416e60-ef03-4444-a19a-f21fca8fa9d1, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 4bba31d2-1664-4ce3-8506-4eb6606538b5, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 9cb13120-b1b8-46c3-bfcc-3b215f023134, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_5: tensor([0.3829], requires_grad=True)\ntheta_6: tensor([0.5825], requires_grad=True)\ntheta_7: tensor([0.8215], requires_grad=True)\ntheta_1: tensor([0.9099], requires_grad=True)\ntheta_0: tensor([0.7224], requires_grad=True)\ntheta_8: tensor([0.1922], requires_grad=True)\ntheta_2: tensor([0.8681], requires_grad=True)\ntheta_3: tensor([0.4370], requires_grad=True)\ntheta_4: tensor([0.0779], requires_grad=True)\n}\nembedded = {\n75645180-4e9e-4f3a-a91e-368aecd8e859: tensor([3., 3.])\n09105109-3493-42e3-868d-441a825b5e4b: tensor([2., 2.])\n58b3e6fa-78bc-4d38-8102-8540ffdd4376: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\n15376d5d-34fd-43e7-ba13-c496c61c2534: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\n44e9b569-3821-4469-9488-34524b642af4: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\ne96815c6-4f86-4e9d-872f-eb4075468b24: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\nbd7409c1-10b3-465b-a210-96dd6736abfa: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\n726ed705-41c5-4dbd-b4de-0cc3ec8379df: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\n18416e60-ef03-4444-a19a-f21fca8fa9d1: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\n4bba31d2-1664-4ce3-8506-4eb6606538b5: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\n9cb13120-b1b8-46c3-bfcc-3b215f023134: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_5: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\ntheta_6: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_7: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\ntheta_2: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.])\ntheta_3: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\ntheta_4: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j],\n[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 175, '011': 143, '100': 142, '111': 123, '010': 118, '001': 106, '101': 98, '110': 95})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(75645180-4e9e-4f3a-a91e-368aecd8e859)-C----------------------------------------Rx(58b3e6fa-78bc-4d38-8102-8540ffdd4376)-Ry(e96815c6-4f86-4e9d-872f-eb4075468b24)-Rx(18416e60-ef03-4444-a19a-f21fca8fa9d1)-C---\n|                                                                                                                                                                   |   q1 : -Rz(09105109-3493-42e3-868d-441a825b5e4b)-X----------------------------------------Rx(15376d5d-34fd-43e7-ba13-c496c61c2534)-Ry(bd7409c1-10b3-465b-a210-96dd6736abfa)-Rx(4bba31d2-1664-4ce3-8506-4eb6606538b5)-X-C-\n| q2 : -Rx(44e9b569-3821-4469-9488-34524b642af4)-Ry(726ed705-41c5-4dbd-b4de-0cc3ec8379df)-Rx(9cb13120-b1b8-46c3-bfcc-3b215f023134)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [09105109-3493-42e3-868d-441a825b5e4b, 15376d5d-34fd-43e7-ba13-c496c61c2534, 18416e60-ef03-4444-a19a-f21fca8fa9d1, 44e9b569-3821-4469-9488-34524b642af4, 4bba31d2-1664-4ce3-8506-4eb6606538b5, 58b3e6fa-78bc-4d38-8102-8540ffdd4376, 726ed705-41c5-4dbd-b4de-0cc3ec8379df, 75645180-4e9e-4f3a-a91e-368aecd8e859, 9cb13120-b1b8-46c3-bfcc-3b215f023134, bd7409c1-10b3-465b-a210-96dd6736abfa, e96815c6-4f86-4e9d-872f-eb4075468b24].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(0.73)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.72)-DEPO(0.1)-Ry(0.44)-DEPO(0.1)-Rx(0.58)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.96)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.91)-DEPO(0.1)-Ry(0.08)-DEPO(0.1)-Rx(0.82)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.87)-DEPO(0.1)-Ry(0.38)-DEPO(0.1)-Rx(0.19)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> aba318982b6a4052aa4a6df824ff9c1a 0 9343bbaf28bb49169d96e0f4cbdf57c5 X aba318982b6a4052aa4a6df824ff9c1a--9343bbaf28bb49169d96e0f4cbdf57c5 e5cfe953bb174f6fa6038e7df2c606aa 1 1f8e52ea2f6648e3944218e25e562fff 9343bbaf28bb49169d96e0f4cbdf57c5--1f8e52ea2f6648e3944218e25e562fff 2b66cdcf535e4ad0a0bf8fd623d5e659 52ea9a6dfe7746308f1614c06e0bd65c Y e5cfe953bb174f6fa6038e7df2c606aa--52ea9a6dfe7746308f1614c06e0bd65c 52ea9a6dfe7746308f1614c06e0bd65c--2b66cdcf535e4ad0a0bf8fd623d5e659 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> e23cc20e678f41f29de558fee6c70d0f 0 10c62ef5f2d14f27bd9f52c4b19140cc RX(0.5) e23cc20e678f41f29de558fee6c70d0f--10c62ef5f2d14f27bd9f52c4b19140cc 918500e660c34b9fb4cdb8304863f6ce 10c62ef5f2d14f27bd9f52c4b19140cc--918500e660c34b9fb4cdb8304863f6ce <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> dad1c9dd93f94f6e8d02acf2a7664e3a 0 8da1c27edf1a4722935184291655c543 dad1c9dd93f94f6e8d02acf2a7664e3a--8da1c27edf1a4722935184291655c543 b37698a043324ec9863adfe7bf045e99 1 c4edf649a1bd475bb025e30c6b808065 8da1c27edf1a4722935184291655c543--c4edf649a1bd475bb025e30c6b808065 fcd619dcfa244da89dcba327a6903c13 be38132fcac24e73999f6db15c69a3d5 X b37698a043324ec9863adfe7bf045e99--be38132fcac24e73999f6db15c69a3d5 be38132fcac24e73999f6db15c69a3d5--8da1c27edf1a4722935184291655c543 be38132fcac24e73999f6db15c69a3d5--fcd619dcfa244da89dcba327a6903c13 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> 52207276117f4f719663fd8ad11973b4 0 1ab4ad88eb4e46a0bbd91c44778491b5 X 52207276117f4f719663fd8ad11973b4--1ab4ad88eb4e46a0bbd91c44778491b5 2faa7b7ca8b84162b967fbdadfc0899b X 1ab4ad88eb4e46a0bbd91c44778491b5--2faa7b7ca8b84162b967fbdadfc0899b ff20ae0870ea413683a821cec0c8e153 2faa7b7ca8b84162b967fbdadfc0899b--ff20ae0870ea413683a821cec0c8e153 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> 40a845aef4aa414d897180a83abc41de 0 0eb369da3a51400e91854e3b32a4602e X 40a845aef4aa414d897180a83abc41de--0eb369da3a51400e91854e3b32a4602e 14b6d23faff740e2a21c6867398a3134 1 d507a1119e68498586da5089a66da28e 0eb369da3a51400e91854e3b32a4602e--d507a1119e68498586da5089a66da28e b31ce3d38a3d489285bb34446d200e09 d507a1119e68498586da5089a66da28e--b31ce3d38a3d489285bb34446d200e09 1513f23b5f824fd8a424db3f20d33f9d 661e7bb256aa42aab4b3bbae7f1f33f3 14b6d23faff740e2a21c6867398a3134--661e7bb256aa42aab4b3bbae7f1f33f3 a10d3bd1d75d474ca8c1860f6a862274 X 661e7bb256aa42aab4b3bbae7f1f33f3--a10d3bd1d75d474ca8c1860f6a862274 a10d3bd1d75d474ca8c1860f6a862274--1513f23b5f824fd8a424db3f20d33f9d </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> 261f976091384e3cb26b10198ffe08f6 0 12dd14e1cc3844b99efb43a5bfa8e6d4 X 261f976091384e3cb26b10198ffe08f6--12dd14e1cc3844b99efb43a5bfa8e6d4 a0c71d2bb2624d449e0a47aaff07efb7 1 b6da6a8cefbf4dac85568220f95c8d07 12dd14e1cc3844b99efb43a5bfa8e6d4--b6da6a8cefbf4dac85568220f95c8d07 ba13336d77df4188af9c7fc1f8198ab0 8bf288405dde4c628a200a54aceca258 X a0c71d2bb2624d449e0a47aaff07efb7--8bf288405dde4c628a200a54aceca258 8bf288405dde4c628a200a54aceca258--ba13336d77df4188af9c7fc1f8198ab0 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> cluster_08b4d90283324eb9a8f09854e42cc3ef subblock cluster_d571ab5fd0954d2cb914d809e36941c3 subblock eafc57c8d45240eb8466e7b62d071456 0 bf0e36677814447fb32570b893ad064f X eafc57c8d45240eb8466e7b62d071456--bf0e36677814447fb32570b893ad064f 63e82d14af2545d29b3ce60aff3e8eb8 1 ba4c8c3b75614a9aa6121d3637f69f5a X bf0e36677814447fb32570b893ad064f--ba4c8c3b75614a9aa6121d3637f69f5a 69147dbc1df04280832c8918b439f68e ba4c8c3b75614a9aa6121d3637f69f5a--69147dbc1df04280832c8918b439f68e dad7bf10a57447c8a44dca1b2c707a48 87978ca070bd4c1aa8a2f9da45204518 Y 63e82d14af2545d29b3ce60aff3e8eb8--87978ca070bd4c1aa8a2f9da45204518 48e9756c2570457f927cc6fcb8e4c3c8 2 3934929d647b41bf893fea8a495baf27 Y 87978ca070bd4c1aa8a2f9da45204518--3934929d647b41bf893fea8a495baf27 3934929d647b41bf893fea8a495baf27--dad7bf10a57447c8a44dca1b2c707a48 0290c176952f4f768252062e0c99d32a ce9a819700e84557a239316528689afd 48e9756c2570457f927cc6fcb8e4c3c8--ce9a819700e84557a239316528689afd 7fa1c0eb482f4accb836feb53e184bd2 3 2d76c2ac6a514b08b90671ceca3387cd ce9a819700e84557a239316528689afd--2d76c2ac6a514b08b90671ceca3387cd 2d76c2ac6a514b08b90671ceca3387cd--0290c176952f4f768252062e0c99d32a 9d14d752825548a2b0b3e3940fa7c818 212b21c3eaf5429ba34f7c4cc5aa02d9 7fa1c0eb482f4accb836feb53e184bd2--212b21c3eaf5429ba34f7c4cc5aa02d9 2774a93fed4b47e09f6d3a586000ceb2 4 58918644c0c74c9bba7a38b5e5f69d4d 212b21c3eaf5429ba34f7c4cc5aa02d9--58918644c0c74c9bba7a38b5e5f69d4d 58918644c0c74c9bba7a38b5e5f69d4d--9d14d752825548a2b0b3e3940fa7c818 783a542aeb5c4040ac407e5b4651048a c10beb72d570427c936f7bec7cca1f7e X 2774a93fed4b47e09f6d3a586000ceb2--c10beb72d570427c936f7bec7cca1f7e c10beb72d570427c936f7bec7cca1f7e--212b21c3eaf5429ba34f7c4cc5aa02d9 20727ae861fa46679def97a84e2db2f7 X c10beb72d570427c936f7bec7cca1f7e--20727ae861fa46679def97a84e2db2f7 20727ae861fa46679def97a84e2db2f7--58918644c0c74c9bba7a38b5e5f69d4d 20727ae861fa46679def97a84e2db2f7--783a542aeb5c4040ac407e5b4651048a"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'00': 271, '10': 252, '01': 247, '11': 230})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '000': 27, '010': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be indentical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(list(range(n_qubits)), n_qubits, replace=True)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[ 2.5000e-01, -3.3307e-16],\n[-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2540, -0.0092],\n[-0.0006, -0.0004]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9868+0.0000j, 0.0000-0.1621j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8778+0.0000j, 0.0000-0.4791j],\n[0.9593+0.0000j, 0.0000-0.2825j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5086+0.0000j, 0.6844+0.0000j, 0.0000-0.3116j, 0.0000-0.4194j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> cluster_2fd62507cdc8447bad11185aa5369990 [* 2] cluster_f873443ca79e4dfab5cd495c9e588c78 Rotations d5edfc4f2156498ebf57d1a8124ded69 0 88d0f3e3d12f47dc9ed2d3ee3a157b5f RX(phi/theta) d5edfc4f2156498ebf57d1a8124ded69--88d0f3e3d12f47dc9ed2d3ee3a157b5f da9959a09f2d437295585f03ae396ece 1 d889030630864b10b2021c78d2f5f797 RX(phi) 88d0f3e3d12f47dc9ed2d3ee3a157b5f--d889030630864b10b2021c78d2f5f797 bf3c7881741e4280af85625aec38d042 RX(phi) d889030630864b10b2021c78d2f5f797--bf3c7881741e4280af85625aec38d042 684021c9ec7e4132a7c67e0db2838284 RX(phi + theta) bf3c7881741e4280af85625aec38d042--684021c9ec7e4132a7c67e0db2838284 74f479144c2b49f6abefe4b3efc0f9f3 684021c9ec7e4132a7c67e0db2838284--74f479144c2b49f6abefe4b3efc0f9f3 d64a77dcdf8d42d0a2fb2df79b02ade2 74f479144c2b49f6abefe4b3efc0f9f3--d64a77dcdf8d42d0a2fb2df79b02ade2 1be67c07923543948cb6a74f65b72da1 Z d64a77dcdf8d42d0a2fb2df79b02ade2--1be67c07923543948cb6a74f65b72da1 3cfeefe328694037a080de689ba4f95b 1be67c07923543948cb6a74f65b72da1--3cfeefe328694037a080de689ba4f95b 91981425a4714ce78c7aca7ffd68bb10 597f9071a35d41ffbe957b0780a8799e RY(2*theta) da9959a09f2d437295585f03ae396ece--597f9071a35d41ffbe957b0780a8799e 9b4e54e2fd4b4d45be1d2732fede171f 2 02c15373c96a4ceca92a3bab26a75a16 RY(theta) 597f9071a35d41ffbe957b0780a8799e--02c15373c96a4ceca92a3bab26a75a16 4d645fa163f542bd83a5d7fb12a19859 RY(theta) 02c15373c96a4ceca92a3bab26a75a16--4d645fa163f542bd83a5d7fb12a19859 bf5a7d822f774e4b9a9eacadb30dba37 RY(theta**2) 4d645fa163f542bd83a5d7fb12a19859--bf5a7d822f774e4b9a9eacadb30dba37 e7a4bcc17b5148d3a1846629f8557696 X bf5a7d822f774e4b9a9eacadb30dba37--e7a4bcc17b5148d3a1846629f8557696 e7a4bcc17b5148d3a1846629f8557696--74f479144c2b49f6abefe4b3efc0f9f3 fe77cc8583494ff4a744312b0bf818bf e7a4bcc17b5148d3a1846629f8557696--fe77cc8583494ff4a744312b0bf818bf 0837f174f27f4ecaa329b1c7379c9e15 Z fe77cc8583494ff4a744312b0bf818bf--0837f174f27f4ecaa329b1c7379c9e15 0837f174f27f4ecaa329b1c7379c9e15--91981425a4714ce78c7aca7ffd68bb10 d4f441dbc0fa4146bfe979f8e24e186a 2c8cb4a0238742e58c1ba0ef6bdf93e9 RZ(cos(phi)) 9b4e54e2fd4b4d45be1d2732fede171f--2c8cb4a0238742e58c1ba0ef6bdf93e9 e79f3fe2c65e4f5b997e86f8a4b440ea RZ(phi) 2c8cb4a0238742e58c1ba0ef6bdf93e9--e79f3fe2c65e4f5b997e86f8a4b440ea 57b0ea217eb44f62a49b53a12c93e938 RZ(phi) e79f3fe2c65e4f5b997e86f8a4b440ea--57b0ea217eb44f62a49b53a12c93e938 d12f2a09a794453cba87eb93dc7bb33c RZ(cos(phi)) 57b0ea217eb44f62a49b53a12c93e938--d12f2a09a794453cba87eb93dc7bb33c 8ead22526a36414c8283c9ed5b4d1b8f d12f2a09a794453cba87eb93dc7bb33c--8ead22526a36414c8283c9ed5b4d1b8f 0cae56796d2540bbbb08aa3bd7e85cba X 8ead22526a36414c8283c9ed5b4d1b8f--0cae56796d2540bbbb08aa3bd7e85cba 0cae56796d2540bbbb08aa3bd7e85cba--fe77cc8583494ff4a744312b0bf818bf 4eac4978584e473b9df503b3812049cc Z 0cae56796d2540bbbb08aa3bd7e85cba--4eac4978584e473b9df503b3812049cc 4eac4978584e473b9df503b3812049cc--d4f441dbc0fa4146bfe979f8e24e186a <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6171]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.5703+0.0000j, 0.4950+0.0000j, 0.0000-0.4950j, 0.0000-0.4297j],\n[0.8421+0.0000j, 0.3647+0.0000j, 0.0000-0.3647j, 0.0000-0.1579j],\n[0.8410+0.0000j, 0.3656+0.0000j, 0.0000-0.3656j, 0.0000-0.1590j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> bdebc57d7b84455cb07379c78b18f0f0 0 36a7608fe5cf455aadc0c3ad517f8fad RX(theta\u2080) bdebc57d7b84455cb07379c78b18f0f0--36a7608fe5cf455aadc0c3ad517f8fad 5d574879b6e24b63bc91a4e1f455840e 1 2ff884a8214547f98e5d6adffbe2f2b8 RY(theta\u2084) 36a7608fe5cf455aadc0c3ad517f8fad--2ff884a8214547f98e5d6adffbe2f2b8 271a2b3f58654d81b84c9f99135ead94 RX(theta\u2088) 2ff884a8214547f98e5d6adffbe2f2b8--271a2b3f58654d81b84c9f99135ead94 56f58f610fa74f9aa17069e3dc83ec86 271a2b3f58654d81b84c9f99135ead94--56f58f610fa74f9aa17069e3dc83ec86 408159014e854f5cafd509989a7fb5da 56f58f610fa74f9aa17069e3dc83ec86--408159014e854f5cafd509989a7fb5da f0500f4c95004c639da852402f3e0acc RX(theta\u2081\u2082) 408159014e854f5cafd509989a7fb5da--f0500f4c95004c639da852402f3e0acc 72cb1e26379846f6a6d7819f82e03c87 RY(theta\u2081\u2086) f0500f4c95004c639da852402f3e0acc--72cb1e26379846f6a6d7819f82e03c87 16a85b266cab400ab5c704c9b2c9b96f RX(theta\u2082\u2080) 72cb1e26379846f6a6d7819f82e03c87--16a85b266cab400ab5c704c9b2c9b96f 928b9951193d4c32947cf4204bd39cbe 16a85b266cab400ab5c704c9b2c9b96f--928b9951193d4c32947cf4204bd39cbe e92d155775ed46d9ab9820aba0eb1409 928b9951193d4c32947cf4204bd39cbe--e92d155775ed46d9ab9820aba0eb1409 3577f7733f164013b40039f69abe53bf e92d155775ed46d9ab9820aba0eb1409--3577f7733f164013b40039f69abe53bf 27e27894ccc84c8d8a940ba69615f6ee a608d5ff20d74c719ac60f3c019a730c RX(theta\u2081) 5d574879b6e24b63bc91a4e1f455840e--a608d5ff20d74c719ac60f3c019a730c d26f8900058f4de88a528950eddf8e13 2 08c6235554c549d081e264c079c2626a RY(theta\u2085) a608d5ff20d74c719ac60f3c019a730c--08c6235554c549d081e264c079c2626a 7d4e6d4ad99b4f4badc86e2b72422baf RX(theta\u2089) 08c6235554c549d081e264c079c2626a--7d4e6d4ad99b4f4badc86e2b72422baf 98100ceb03ab4a7e831b9571250fee40 X 7d4e6d4ad99b4f4badc86e2b72422baf--98100ceb03ab4a7e831b9571250fee40 98100ceb03ab4a7e831b9571250fee40--56f58f610fa74f9aa17069e3dc83ec86 ecde723b88b04bd1b4431e7701ebaf9c 98100ceb03ab4a7e831b9571250fee40--ecde723b88b04bd1b4431e7701ebaf9c b03671e4fa8642119009a6c45c050fd9 RX(theta\u2081\u2083) ecde723b88b04bd1b4431e7701ebaf9c--b03671e4fa8642119009a6c45c050fd9 d4d9d27014a7451396101bdff55a764a RY(theta\u2081\u2087) b03671e4fa8642119009a6c45c050fd9--d4d9d27014a7451396101bdff55a764a b106a96626bd42a7927b67db458eb536 RX(theta\u2082\u2081) d4d9d27014a7451396101bdff55a764a--b106a96626bd42a7927b67db458eb536 b09ec5fda5154f3b85bdde1d04214da0 X b106a96626bd42a7927b67db458eb536--b09ec5fda5154f3b85bdde1d04214da0 b09ec5fda5154f3b85bdde1d04214da0--928b9951193d4c32947cf4204bd39cbe fe70a7bdca664a0e81b058a1ce0050cb b09ec5fda5154f3b85bdde1d04214da0--fe70a7bdca664a0e81b058a1ce0050cb fe70a7bdca664a0e81b058a1ce0050cb--27e27894ccc84c8d8a940ba69615f6ee 48201d0a8d7c408e8a2dad1a5d6ae63c fa639a336ab54fadaccf1a8e80d2a57d RX(theta\u2082) d26f8900058f4de88a528950eddf8e13--fa639a336ab54fadaccf1a8e80d2a57d 8a1700f37bc2400881f421a223015206 3 41868aa290ee40fba4611927382810e7 RY(theta\u2086) fa639a336ab54fadaccf1a8e80d2a57d--41868aa290ee40fba4611927382810e7 d5e4b52704de4d4a86e17988a63cc268 RX(theta\u2081\u2080) 41868aa290ee40fba4611927382810e7--d5e4b52704de4d4a86e17988a63cc268 bc729291343b401cb32544d7d4e95f94 d5e4b52704de4d4a86e17988a63cc268--bc729291343b401cb32544d7d4e95f94 b2d519a1bd074fdb9ea9ac741137e1bf X bc729291343b401cb32544d7d4e95f94--b2d519a1bd074fdb9ea9ac741137e1bf b2d519a1bd074fdb9ea9ac741137e1bf--ecde723b88b04bd1b4431e7701ebaf9c 4689299e9b654a46921769c59ae5d915 RX(theta\u2081\u2084) b2d519a1bd074fdb9ea9ac741137e1bf--4689299e9b654a46921769c59ae5d915 7093136111724d4f816f1dbe7445b36e RY(theta\u2081\u2088) 4689299e9b654a46921769c59ae5d915--7093136111724d4f816f1dbe7445b36e 5cfbba4111584e309fd8888b6a150878 RX(theta\u2082\u2082) 7093136111724d4f816f1dbe7445b36e--5cfbba4111584e309fd8888b6a150878 edf2a52f19704aa5af4cea10b92d12b7 5cfbba4111584e309fd8888b6a150878--edf2a52f19704aa5af4cea10b92d12b7 8a92c61e61664a3181a6bca777c3f2bb X edf2a52f19704aa5af4cea10b92d12b7--8a92c61e61664a3181a6bca777c3f2bb 8a92c61e61664a3181a6bca777c3f2bb--fe70a7bdca664a0e81b058a1ce0050cb 8a92c61e61664a3181a6bca777c3f2bb--48201d0a8d7c408e8a2dad1a5d6ae63c b63daf66189c43bcad5de8682eb4503c f49e652fc17d48c7bb2d66725ee60843 RX(theta\u2083) 8a1700f37bc2400881f421a223015206--f49e652fc17d48c7bb2d66725ee60843 04d7512b24414600a481d881aa77005f RY(theta\u2087) f49e652fc17d48c7bb2d66725ee60843--04d7512b24414600a481d881aa77005f 539edc16912244f09e7302be163c5998 RX(theta\u2081\u2081) 04d7512b24414600a481d881aa77005f--539edc16912244f09e7302be163c5998 82af4df7053c47ffb890884e7d5b9fc5 X 539edc16912244f09e7302be163c5998--82af4df7053c47ffb890884e7d5b9fc5 82af4df7053c47ffb890884e7d5b9fc5--bc729291343b401cb32544d7d4e95f94 1b84ddbab8944d93a63a319cf26b10cf 82af4df7053c47ffb890884e7d5b9fc5--1b84ddbab8944d93a63a319cf26b10cf e0d38d95882743b1841335651c9a7a2a RX(theta\u2081\u2085) 1b84ddbab8944d93a63a319cf26b10cf--e0d38d95882743b1841335651c9a7a2a 05e44ebc4cd14e40ae6c71da92f9190b RY(theta\u2081\u2089) e0d38d95882743b1841335651c9a7a2a--05e44ebc4cd14e40ae6c71da92f9190b f3b8cad0d5eb4ba8948b25f7bf8dbad1 RX(theta\u2082\u2083) 05e44ebc4cd14e40ae6c71da92f9190b--f3b8cad0d5eb4ba8948b25f7bf8dbad1 170a05def561456e965f7d52ad210754 X f3b8cad0d5eb4ba8948b25f7bf8dbad1--170a05def561456e965f7d52ad210754 170a05def561456e965f7d52ad210754--edf2a52f19704aa5af4cea10b92d12b7 ee21e4982799418686d426ac1972a15a 170a05def561456e965f7d52ad210754--ee21e4982799418686d426ac1972a15a ee21e4982799418686d426ac1972a15a--b63daf66189c43bcad5de8682eb4503c </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> cluster_df32e4ea69814beaabeaa3345c98df87 HEA cluster_fcd332804a1a4bd59663b03f9f324850 HEA d33b50471cf546ae8b2f38c5f971f4d7 0 0932e5d59f194d18b5fb5038bb5b7cf5 RX(theta\u2080) d33b50471cf546ae8b2f38c5f971f4d7--0932e5d59f194d18b5fb5038bb5b7cf5 5164f99760de4fc18e548fc951083cd2 1 3cd2295817cd495eab416697570c8616 RY(theta\u2084) 0932e5d59f194d18b5fb5038bb5b7cf5--3cd2295817cd495eab416697570c8616 fab292097f3742f9a48343be8c19da73 RX(theta\u2088) 3cd2295817cd495eab416697570c8616--fab292097f3742f9a48343be8c19da73 9016dfb3820a4e5aab06079c68f11eb4 fab292097f3742f9a48343be8c19da73--9016dfb3820a4e5aab06079c68f11eb4 404f9bf772914ef3abcec5596055c3f4 9016dfb3820a4e5aab06079c68f11eb4--404f9bf772914ef3abcec5596055c3f4 b5dbaee8b2844d11997f4ccc31a2f629 RX(theta\u2081\u2082) 404f9bf772914ef3abcec5596055c3f4--b5dbaee8b2844d11997f4ccc31a2f629 fe5e987994294568a83ef6a81bfaf899 RY(theta\u2081\u2086) b5dbaee8b2844d11997f4ccc31a2f629--fe5e987994294568a83ef6a81bfaf899 46c5e2e49d994cae874918fe213a9301 RX(theta\u2082\u2080) fe5e987994294568a83ef6a81bfaf899--46c5e2e49d994cae874918fe213a9301 62e03199c07545b0914fb476d499b1c9 46c5e2e49d994cae874918fe213a9301--62e03199c07545b0914fb476d499b1c9 c9d2eb91c2f146bebac750010a511578 62e03199c07545b0914fb476d499b1c9--c9d2eb91c2f146bebac750010a511578 4e27d20b594d437c982411185df91506 RX(theta\u2080) c9d2eb91c2f146bebac750010a511578--4e27d20b594d437c982411185df91506 e807df2abd7642ab963ab19c85b9dcfd RY(theta\u2084) 4e27d20b594d437c982411185df91506--e807df2abd7642ab963ab19c85b9dcfd d3912f5da0284eeb849afc1a06104ec5 RX(theta\u2088) e807df2abd7642ab963ab19c85b9dcfd--d3912f5da0284eeb849afc1a06104ec5 e9655e0c06af49989ec35e59775bb182 d3912f5da0284eeb849afc1a06104ec5--e9655e0c06af49989ec35e59775bb182 80ad4e66a8264443b691bef86ab1c657 e9655e0c06af49989ec35e59775bb182--80ad4e66a8264443b691bef86ab1c657 28d4c4f8245b468f81748ed2ae6b16ab RX(theta\u2081\u2082) 80ad4e66a8264443b691bef86ab1c657--28d4c4f8245b468f81748ed2ae6b16ab 1953844c59f9487a94f345be1c072782 RY(theta\u2081\u2086) 28d4c4f8245b468f81748ed2ae6b16ab--1953844c59f9487a94f345be1c072782 16165dd8dc614abdb33a6dc4f98635c6 RX(theta\u2082\u2080) 1953844c59f9487a94f345be1c072782--16165dd8dc614abdb33a6dc4f98635c6 c992b60c8d9f448f9bc331067da4d27f 16165dd8dc614abdb33a6dc4f98635c6--c992b60c8d9f448f9bc331067da4d27f 89e5d1997dd54b87aea103d18b3d829e c992b60c8d9f448f9bc331067da4d27f--89e5d1997dd54b87aea103d18b3d829e b4e44fc47878488aa0675580c6f97bba 89e5d1997dd54b87aea103d18b3d829e--b4e44fc47878488aa0675580c6f97bba 165b9d18eacb46c198c4c20aa0305918 db9b843257024a6fb639cd336bb14622 RX(theta\u2081) 5164f99760de4fc18e548fc951083cd2--db9b843257024a6fb639cd336bb14622 aedae7478d224579aab4ef6d6fb58595 2 bbc56ef1fc404703942fbdd1af7e99e8 RY(theta\u2085) db9b843257024a6fb639cd336bb14622--bbc56ef1fc404703942fbdd1af7e99e8 46a8f77a1e9e47a8911a9224d8679339 RX(theta\u2089) bbc56ef1fc404703942fbdd1af7e99e8--46a8f77a1e9e47a8911a9224d8679339 c40a50f7588847699b28b27bf639fda1 X 46a8f77a1e9e47a8911a9224d8679339--c40a50f7588847699b28b27bf639fda1 c40a50f7588847699b28b27bf639fda1--9016dfb3820a4e5aab06079c68f11eb4 e9061eaa6220465d85834322328ae798 c40a50f7588847699b28b27bf639fda1--e9061eaa6220465d85834322328ae798 bfa40a0ba3624bcf9e906552879b0b59 RX(theta\u2081\u2083) e9061eaa6220465d85834322328ae798--bfa40a0ba3624bcf9e906552879b0b59 6dd338b364bf44aca9fb46d81045ae2a RY(theta\u2081\u2087) bfa40a0ba3624bcf9e906552879b0b59--6dd338b364bf44aca9fb46d81045ae2a aa927a6f09684745ac72ca4891c1e3b8 RX(theta\u2082\u2081) 6dd338b364bf44aca9fb46d81045ae2a--aa927a6f09684745ac72ca4891c1e3b8 22ddacd4bc614a49bbe3a7f2d41a5544 X aa927a6f09684745ac72ca4891c1e3b8--22ddacd4bc614a49bbe3a7f2d41a5544 22ddacd4bc614a49bbe3a7f2d41a5544--62e03199c07545b0914fb476d499b1c9 1fd5aec7dd1a45db9411bcb49dc6beb0 22ddacd4bc614a49bbe3a7f2d41a5544--1fd5aec7dd1a45db9411bcb49dc6beb0 a4293bfd8a234fd79b5f8ebd25db075e RX(theta\u2081) 1fd5aec7dd1a45db9411bcb49dc6beb0--a4293bfd8a234fd79b5f8ebd25db075e ce352149de56433281cf93edc5213204 RY(theta\u2085) a4293bfd8a234fd79b5f8ebd25db075e--ce352149de56433281cf93edc5213204 a0e437cb452c42a0bd64809dcfaf83d1 RX(theta\u2089) ce352149de56433281cf93edc5213204--a0e437cb452c42a0bd64809dcfaf83d1 e4a1bd765db34ad5aa864f38ad080c07 X a0e437cb452c42a0bd64809dcfaf83d1--e4a1bd765db34ad5aa864f38ad080c07 e4a1bd765db34ad5aa864f38ad080c07--e9655e0c06af49989ec35e59775bb182 de853ffe90904d208f771da305e935ac e4a1bd765db34ad5aa864f38ad080c07--de853ffe90904d208f771da305e935ac 248c2beb2e11404086a06f6569a2bd56 RX(theta\u2081\u2083) de853ffe90904d208f771da305e935ac--248c2beb2e11404086a06f6569a2bd56 1fd2ba3d8ae14ec8a8a61127ddc1583d RY(theta\u2081\u2087) 248c2beb2e11404086a06f6569a2bd56--1fd2ba3d8ae14ec8a8a61127ddc1583d dea0875c9e6e4985bfb35a50894dcd0b RX(theta\u2082\u2081) 1fd2ba3d8ae14ec8a8a61127ddc1583d--dea0875c9e6e4985bfb35a50894dcd0b 4995bef9c36f4eab9c60acf89005b76d X dea0875c9e6e4985bfb35a50894dcd0b--4995bef9c36f4eab9c60acf89005b76d 4995bef9c36f4eab9c60acf89005b76d--c992b60c8d9f448f9bc331067da4d27f f2d247c0fda34f4e8e4b2ce2f9205b7d 4995bef9c36f4eab9c60acf89005b76d--f2d247c0fda34f4e8e4b2ce2f9205b7d f2d247c0fda34f4e8e4b2ce2f9205b7d--165b9d18eacb46c198c4c20aa0305918 427407965df746c58dfc48c76a765b52 90b2ebf7d08945be8fac2d02b630d48d RX(theta\u2082) aedae7478d224579aab4ef6d6fb58595--90b2ebf7d08945be8fac2d02b630d48d 27bd195cf6db49d282863b221d960613 3 764e4323a432466eaafbdf6720ee1fcc RY(theta\u2086) 90b2ebf7d08945be8fac2d02b630d48d--764e4323a432466eaafbdf6720ee1fcc 46909b407241422099e2eb11942c9a64 RX(theta\u2081\u2080) 764e4323a432466eaafbdf6720ee1fcc--46909b407241422099e2eb11942c9a64 1bb0f962e26546a5be42425e0c5fd197 46909b407241422099e2eb11942c9a64--1bb0f962e26546a5be42425e0c5fd197 e6d82b063ce74dc6925d87ed8b350d2a X 1bb0f962e26546a5be42425e0c5fd197--e6d82b063ce74dc6925d87ed8b350d2a e6d82b063ce74dc6925d87ed8b350d2a--e9061eaa6220465d85834322328ae798 a88ca24910d64a2fa38d4e9448457efb RX(theta\u2081\u2084) e6d82b063ce74dc6925d87ed8b350d2a--a88ca24910d64a2fa38d4e9448457efb 87969655da1340ab8a6045b0fa3e2700 RY(theta\u2081\u2088) a88ca24910d64a2fa38d4e9448457efb--87969655da1340ab8a6045b0fa3e2700 74d3ad38609c4d04965afb001d95f227 RX(theta\u2082\u2082) 87969655da1340ab8a6045b0fa3e2700--74d3ad38609c4d04965afb001d95f227 2eda83530c2944009268dd9ca3c4295b 74d3ad38609c4d04965afb001d95f227--2eda83530c2944009268dd9ca3c4295b 06902881e77140a2b446e7c187b1d856 X 2eda83530c2944009268dd9ca3c4295b--06902881e77140a2b446e7c187b1d856 06902881e77140a2b446e7c187b1d856--1fd5aec7dd1a45db9411bcb49dc6beb0 c2147a40a09840aca6ccf5377e47ded8 RX(theta\u2082) 06902881e77140a2b446e7c187b1d856--c2147a40a09840aca6ccf5377e47ded8 419f2bb77e224423b7dbd46ed7fb8856 RY(theta\u2086) c2147a40a09840aca6ccf5377e47ded8--419f2bb77e224423b7dbd46ed7fb8856 44b91c3ce4ce4583a423808dd31ddd87 RX(theta\u2081\u2080) 419f2bb77e224423b7dbd46ed7fb8856--44b91c3ce4ce4583a423808dd31ddd87 0e182bfaff564e82ad7b8dae16141b79 44b91c3ce4ce4583a423808dd31ddd87--0e182bfaff564e82ad7b8dae16141b79 e3f13bc3bb6b4ead95002b3fb66ad59e X 0e182bfaff564e82ad7b8dae16141b79--e3f13bc3bb6b4ead95002b3fb66ad59e e3f13bc3bb6b4ead95002b3fb66ad59e--de853ffe90904d208f771da305e935ac cdbd9f6c3cfb4a728ca2094c22400430 RX(theta\u2081\u2084) e3f13bc3bb6b4ead95002b3fb66ad59e--cdbd9f6c3cfb4a728ca2094c22400430 43b471a127ec48588b76fd88050a591e RY(theta\u2081\u2088) cdbd9f6c3cfb4a728ca2094c22400430--43b471a127ec48588b76fd88050a591e 0e009c75e3e742458437d035b4760fdf RX(theta\u2082\u2082) 43b471a127ec48588b76fd88050a591e--0e009c75e3e742458437d035b4760fdf 7ed0b37dcb5d42eea42b36f16ef169fc 0e009c75e3e742458437d035b4760fdf--7ed0b37dcb5d42eea42b36f16ef169fc 06e87da3a072423fb73555ec2431a8b3 X 7ed0b37dcb5d42eea42b36f16ef169fc--06e87da3a072423fb73555ec2431a8b3 06e87da3a072423fb73555ec2431a8b3--f2d247c0fda34f4e8e4b2ce2f9205b7d 06e87da3a072423fb73555ec2431a8b3--427407965df746c58dfc48c76a765b52 f3f89ec1f0344392aeadd73667f0b094 288190e84ab04153a693ee17f6d19af4 RX(theta\u2083) 27bd195cf6db49d282863b221d960613--288190e84ab04153a693ee17f6d19af4 e6a77d027faf40248e2e43c8c08ee1bd RY(theta\u2087) 288190e84ab04153a693ee17f6d19af4--e6a77d027faf40248e2e43c8c08ee1bd 58b53eff9df74851a87191d33060c002 RX(theta\u2081\u2081) e6a77d027faf40248e2e43c8c08ee1bd--58b53eff9df74851a87191d33060c002 cbe0e429e7f54b5181ea90652e86406e X 58b53eff9df74851a87191d33060c002--cbe0e429e7f54b5181ea90652e86406e cbe0e429e7f54b5181ea90652e86406e--1bb0f962e26546a5be42425e0c5fd197 922a2285e09c4fb38477bff1bf7e97ec cbe0e429e7f54b5181ea90652e86406e--922a2285e09c4fb38477bff1bf7e97ec 42560615415644ddad004d1b2789aef5 RX(theta\u2081\u2085) 922a2285e09c4fb38477bff1bf7e97ec--42560615415644ddad004d1b2789aef5 3f17372cfe414207bd1ac2a4f642fc6c RY(theta\u2081\u2089) 42560615415644ddad004d1b2789aef5--3f17372cfe414207bd1ac2a4f642fc6c 1999c668ff114380bf1e41a3316ab399 RX(theta\u2082\u2083) 3f17372cfe414207bd1ac2a4f642fc6c--1999c668ff114380bf1e41a3316ab399 b31636558bee4a3e84a09c9f1ac92730 X 1999c668ff114380bf1e41a3316ab399--b31636558bee4a3e84a09c9f1ac92730 b31636558bee4a3e84a09c9f1ac92730--2eda83530c2944009268dd9ca3c4295b 636dd572d0b2427f9edb17dacfbbdc3f b31636558bee4a3e84a09c9f1ac92730--636dd572d0b2427f9edb17dacfbbdc3f e76eafc0cd2a470d9d226bb91b5d3f7a RX(theta\u2083) 636dd572d0b2427f9edb17dacfbbdc3f--e76eafc0cd2a470d9d226bb91b5d3f7a e2a13fec2cf34024bdf30c9c624fbac8 RY(theta\u2087) e76eafc0cd2a470d9d226bb91b5d3f7a--e2a13fec2cf34024bdf30c9c624fbac8 4ba6d6c24b1d49a58c4d8eebfbb261de RX(theta\u2081\u2081) e2a13fec2cf34024bdf30c9c624fbac8--4ba6d6c24b1d49a58c4d8eebfbb261de 4b13a9d427d2448b8aeaa5e8d1253721 X 4ba6d6c24b1d49a58c4d8eebfbb261de--4b13a9d427d2448b8aeaa5e8d1253721 4b13a9d427d2448b8aeaa5e8d1253721--0e182bfaff564e82ad7b8dae16141b79 e850f1dcc1c94700bd1b7eb137fa77be 4b13a9d427d2448b8aeaa5e8d1253721--e850f1dcc1c94700bd1b7eb137fa77be eb2d6f353ab54105864a817728a432a9 RX(theta\u2081\u2085) e850f1dcc1c94700bd1b7eb137fa77be--eb2d6f353ab54105864a817728a432a9 b0e9bf852f064479ab6170cce0060d86 RY(theta\u2081\u2089) eb2d6f353ab54105864a817728a432a9--b0e9bf852f064479ab6170cce0060d86 cf2391a6a8ad495889d9f59aa80f3e62 RX(theta\u2082\u2083) b0e9bf852f064479ab6170cce0060d86--cf2391a6a8ad495889d9f59aa80f3e62 08753339258948608bbafb9e000dd4b0 X cf2391a6a8ad495889d9f59aa80f3e62--08753339258948608bbafb9e000dd4b0 08753339258948608bbafb9e000dd4b0--7ed0b37dcb5d42eea42b36f16ef169fc 991eb44efb1943aeb60d2fde503a8e15 08753339258948608bbafb9e000dd4b0--991eb44efb1943aeb60d2fde503a8e15 991eb44efb1943aeb60d2fde503a8e15--f3f89ec1f0344392aeadd73667f0b094 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> cluster_27d553f54aa44eb4b57e2a0c40d0e943 HEA cluster_82c1aed123d642f2abb350f16f5595ca HEA 34da3a2b74874523be3d719275ae51cf 0 e60a0e52fe6e4096996b0943ae06d4be RX(p1\u2080) 34da3a2b74874523be3d719275ae51cf--e60a0e52fe6e4096996b0943ae06d4be fd9e1a0cff27454f97c9b11d6b658197 1 3a0bddcc95da4d749bc78f06b552131d RY(p1\u2084) e60a0e52fe6e4096996b0943ae06d4be--3a0bddcc95da4d749bc78f06b552131d 667cf2690f2d44fcbd38a250e3fd8501 RX(p1\u2088) 3a0bddcc95da4d749bc78f06b552131d--667cf2690f2d44fcbd38a250e3fd8501 138d767de9c94099b2d9a6f4e75e14d0 667cf2690f2d44fcbd38a250e3fd8501--138d767de9c94099b2d9a6f4e75e14d0 0ff31f5c24884d02819b0cbf82722e85 138d767de9c94099b2d9a6f4e75e14d0--0ff31f5c24884d02819b0cbf82722e85 f6b18c4e89a84a7b8e71cb3b765fbff8 RX(p1\u2081\u2082) 0ff31f5c24884d02819b0cbf82722e85--f6b18c4e89a84a7b8e71cb3b765fbff8 3abb4b66eedd4ebda0fca103d5ff339f RY(p1\u2081\u2086) f6b18c4e89a84a7b8e71cb3b765fbff8--3abb4b66eedd4ebda0fca103d5ff339f 6c5fd4d3629b4bc9a641e5adadc6e525 RX(p1\u2082\u2080) 3abb4b66eedd4ebda0fca103d5ff339f--6c5fd4d3629b4bc9a641e5adadc6e525 91186d406d3648feace5ff5239a66ba5 6c5fd4d3629b4bc9a641e5adadc6e525--91186d406d3648feace5ff5239a66ba5 59e7a7c6e988489ba41d40633091941f 91186d406d3648feace5ff5239a66ba5--59e7a7c6e988489ba41d40633091941f 64e560590f6040d1986006f5165ee8f4 RX(p2\u2080) 59e7a7c6e988489ba41d40633091941f--64e560590f6040d1986006f5165ee8f4 59ce5acf85a84dc193d7222692a5ef82 RY(p2\u2084) 64e560590f6040d1986006f5165ee8f4--59ce5acf85a84dc193d7222692a5ef82 5a953f0264f5485a87120114a58645c5 RX(p2\u2088) 59ce5acf85a84dc193d7222692a5ef82--5a953f0264f5485a87120114a58645c5 ed6a0fecbc384a8ea612941081f0ce17 5a953f0264f5485a87120114a58645c5--ed6a0fecbc384a8ea612941081f0ce17 35576f9186cd4212a774d8c51b06dca9 ed6a0fecbc384a8ea612941081f0ce17--35576f9186cd4212a774d8c51b06dca9 5ea7390f3e2143b1b22a8b58dc657c2f RX(p2\u2081\u2082) 35576f9186cd4212a774d8c51b06dca9--5ea7390f3e2143b1b22a8b58dc657c2f 93221dc4a9d245d8ae6465ce4fe21e80 RY(p2\u2081\u2086) 5ea7390f3e2143b1b22a8b58dc657c2f--93221dc4a9d245d8ae6465ce4fe21e80 cc64797fda3444398dc7899284d5d1db RX(p2\u2082\u2080) 93221dc4a9d245d8ae6465ce4fe21e80--cc64797fda3444398dc7899284d5d1db d3dda4f4acbb4f93b9e7633eb212b173 cc64797fda3444398dc7899284d5d1db--d3dda4f4acbb4f93b9e7633eb212b173 bb330ea1aa5446b788800768edb9546d d3dda4f4acbb4f93b9e7633eb212b173--bb330ea1aa5446b788800768edb9546d e9d379a550674cd983eb44579e76b58c bb330ea1aa5446b788800768edb9546d--e9d379a550674cd983eb44579e76b58c 7d2a6c62e386416c9f3e74768b30963f 049fcb738c3e4ade90f83f85348ca349 RX(p1\u2081) fd9e1a0cff27454f97c9b11d6b658197--049fcb738c3e4ade90f83f85348ca349 38db11b08119432e8cb4ee9d9c78a1b5 2 c0c0085c1d7f44d08b251d6a9ac223e1 RY(p1\u2085) 049fcb738c3e4ade90f83f85348ca349--c0c0085c1d7f44d08b251d6a9ac223e1 b4e76614429c4259b9cad4fabafad9e2 RX(p1\u2089) c0c0085c1d7f44d08b251d6a9ac223e1--b4e76614429c4259b9cad4fabafad9e2 cd0e9975cc9d476a821ff51a8802c00a X b4e76614429c4259b9cad4fabafad9e2--cd0e9975cc9d476a821ff51a8802c00a cd0e9975cc9d476a821ff51a8802c00a--138d767de9c94099b2d9a6f4e75e14d0 cccd0344cd0549dba8172f19cd894f72 cd0e9975cc9d476a821ff51a8802c00a--cccd0344cd0549dba8172f19cd894f72 f0900ef11bef43da86401ca64bff0fe3 RX(p1\u2081\u2083) cccd0344cd0549dba8172f19cd894f72--f0900ef11bef43da86401ca64bff0fe3 3d6a76713cb648579f74a0e02bc14f16 RY(p1\u2081\u2087) f0900ef11bef43da86401ca64bff0fe3--3d6a76713cb648579f74a0e02bc14f16 74ecf85d6c5344808c3c7a84750e9b18 RX(p1\u2082\u2081) 3d6a76713cb648579f74a0e02bc14f16--74ecf85d6c5344808c3c7a84750e9b18 dae1c781cfdc44a099015978fb3ede11 X 74ecf85d6c5344808c3c7a84750e9b18--dae1c781cfdc44a099015978fb3ede11 dae1c781cfdc44a099015978fb3ede11--91186d406d3648feace5ff5239a66ba5 4d62d9e1462e4ba6a5e624a175f08e0a dae1c781cfdc44a099015978fb3ede11--4d62d9e1462e4ba6a5e624a175f08e0a 10dde5aa70c24a0abd9021be3e9c8f42 RX(p2\u2081) 4d62d9e1462e4ba6a5e624a175f08e0a--10dde5aa70c24a0abd9021be3e9c8f42 ca63317b5b244fca940bbef8849ac491 RY(p2\u2085) 10dde5aa70c24a0abd9021be3e9c8f42--ca63317b5b244fca940bbef8849ac491 059f92f9b566427c98cbc5b12342799d RX(p2\u2089) ca63317b5b244fca940bbef8849ac491--059f92f9b566427c98cbc5b12342799d be772d898a1f40ad8cfa2eb9f55c6487 X 059f92f9b566427c98cbc5b12342799d--be772d898a1f40ad8cfa2eb9f55c6487 be772d898a1f40ad8cfa2eb9f55c6487--ed6a0fecbc384a8ea612941081f0ce17 e2cc31f3a2a4404c8d577409690a8959 be772d898a1f40ad8cfa2eb9f55c6487--e2cc31f3a2a4404c8d577409690a8959 f1c81609d3f74ea8b8dd07104507c6c0 RX(p2\u2081\u2083) e2cc31f3a2a4404c8d577409690a8959--f1c81609d3f74ea8b8dd07104507c6c0 1d7baf7c9152474180badca5e63eb0ba RY(p2\u2081\u2087) f1c81609d3f74ea8b8dd07104507c6c0--1d7baf7c9152474180badca5e63eb0ba 444f11ff3fa142b2bb5e86db45d99093 RX(p2\u2082\u2081) 1d7baf7c9152474180badca5e63eb0ba--444f11ff3fa142b2bb5e86db45d99093 1008090ca766464cb73f237fb6570da7 X 444f11ff3fa142b2bb5e86db45d99093--1008090ca766464cb73f237fb6570da7 1008090ca766464cb73f237fb6570da7--d3dda4f4acbb4f93b9e7633eb212b173 295320b34e534ab3b51c1351ca77491e 1008090ca766464cb73f237fb6570da7--295320b34e534ab3b51c1351ca77491e 295320b34e534ab3b51c1351ca77491e--7d2a6c62e386416c9f3e74768b30963f a4c0f75f8d8d4c48a0c82888761e69f6 26acbbcb2e68445992a31bb8ad1cc359 RX(p1\u2082) 38db11b08119432e8cb4ee9d9c78a1b5--26acbbcb2e68445992a31bb8ad1cc359 c48744c2a94d4d26a4d3322206012e3e 3 b0c68b3d28654decb3546139ba247593 RY(p1\u2086) 26acbbcb2e68445992a31bb8ad1cc359--b0c68b3d28654decb3546139ba247593 5fd6504696ae4d0fb4a65efa0dea66a1 RX(p1\u2081\u2080) b0c68b3d28654decb3546139ba247593--5fd6504696ae4d0fb4a65efa0dea66a1 febd6fb3cdcb4dcfbb3f5d0b8971213e 5fd6504696ae4d0fb4a65efa0dea66a1--febd6fb3cdcb4dcfbb3f5d0b8971213e 086bbb3a7df74708875566f006d16e0a X febd6fb3cdcb4dcfbb3f5d0b8971213e--086bbb3a7df74708875566f006d16e0a 086bbb3a7df74708875566f006d16e0a--cccd0344cd0549dba8172f19cd894f72 a673f197262d4e599c1d4725180343c4 RX(p1\u2081\u2084) 086bbb3a7df74708875566f006d16e0a--a673f197262d4e599c1d4725180343c4 f4fc504ba1dc4b529456f659e721f013 RY(p1\u2081\u2088) a673f197262d4e599c1d4725180343c4--f4fc504ba1dc4b529456f659e721f013 df00f21088ca42c398d9b13592a32753 RX(p1\u2082\u2082) f4fc504ba1dc4b529456f659e721f013--df00f21088ca42c398d9b13592a32753 04d142f2eaa74630a1454056738e4d76 df00f21088ca42c398d9b13592a32753--04d142f2eaa74630a1454056738e4d76 031c9db5db474892806b00777a5c9119 X 04d142f2eaa74630a1454056738e4d76--031c9db5db474892806b00777a5c9119 031c9db5db474892806b00777a5c9119--4d62d9e1462e4ba6a5e624a175f08e0a 98735946d800419ea7e92753060f079b RX(p2\u2082) 031c9db5db474892806b00777a5c9119--98735946d800419ea7e92753060f079b 10405f71d6ae4790b91f8d28bbe5b7e6 RY(p2\u2086) 98735946d800419ea7e92753060f079b--10405f71d6ae4790b91f8d28bbe5b7e6 803c59207e544ba79c57ced39ee3371e RX(p2\u2081\u2080) 10405f71d6ae4790b91f8d28bbe5b7e6--803c59207e544ba79c57ced39ee3371e 059d36b2f68748ee97077981eec1785b 803c59207e544ba79c57ced39ee3371e--059d36b2f68748ee97077981eec1785b 323c9031c7714089aa5adefe53a5d17e X 059d36b2f68748ee97077981eec1785b--323c9031c7714089aa5adefe53a5d17e 323c9031c7714089aa5adefe53a5d17e--e2cc31f3a2a4404c8d577409690a8959 2aa8bf99713d4beba406fc1a3ef19f7a RX(p2\u2081\u2084) 323c9031c7714089aa5adefe53a5d17e--2aa8bf99713d4beba406fc1a3ef19f7a 638f964e2f3943ff8b0ffc382fa19b2d RY(p2\u2081\u2088) 2aa8bf99713d4beba406fc1a3ef19f7a--638f964e2f3943ff8b0ffc382fa19b2d 449f461e2dcc435ab537aa45f0ba7048 RX(p2\u2082\u2082) 638f964e2f3943ff8b0ffc382fa19b2d--449f461e2dcc435ab537aa45f0ba7048 238b67701f3b4bee9bd4a8faf104739b 449f461e2dcc435ab537aa45f0ba7048--238b67701f3b4bee9bd4a8faf104739b aea5674a2d3c496989e0e3e868cffb2a X 238b67701f3b4bee9bd4a8faf104739b--aea5674a2d3c496989e0e3e868cffb2a aea5674a2d3c496989e0e3e868cffb2a--295320b34e534ab3b51c1351ca77491e aea5674a2d3c496989e0e3e868cffb2a--a4c0f75f8d8d4c48a0c82888761e69f6 75b427427e6a43bf89048fb0770072ea 219fe50108074f539dffe0d62c8591d4 RX(p1\u2083) c48744c2a94d4d26a4d3322206012e3e--219fe50108074f539dffe0d62c8591d4 b478d25880474bd39c8bd321dc3d7f34 RY(p1\u2087) 219fe50108074f539dffe0d62c8591d4--b478d25880474bd39c8bd321dc3d7f34 6ed0ace60961405d99023e07846b3af6 RX(p1\u2081\u2081) b478d25880474bd39c8bd321dc3d7f34--6ed0ace60961405d99023e07846b3af6 51b06f373e1c408b8ed58aaf9ded2af6 X 6ed0ace60961405d99023e07846b3af6--51b06f373e1c408b8ed58aaf9ded2af6 51b06f373e1c408b8ed58aaf9ded2af6--febd6fb3cdcb4dcfbb3f5d0b8971213e 83a3e27976954b568c30f9be769e61e2 51b06f373e1c408b8ed58aaf9ded2af6--83a3e27976954b568c30f9be769e61e2 030cec35f16b43d698baeb94d2bafaae RX(p1\u2081\u2085) 83a3e27976954b568c30f9be769e61e2--030cec35f16b43d698baeb94d2bafaae c73390f940c940f7aadc78820cd00dbd RY(p1\u2081\u2089) 030cec35f16b43d698baeb94d2bafaae--c73390f940c940f7aadc78820cd00dbd 553269a41a3f428b84ee1d14fb4540a2 RX(p1\u2082\u2083) c73390f940c940f7aadc78820cd00dbd--553269a41a3f428b84ee1d14fb4540a2 6659f5e817c341a4845873bb8275a917 X 553269a41a3f428b84ee1d14fb4540a2--6659f5e817c341a4845873bb8275a917 6659f5e817c341a4845873bb8275a917--04d142f2eaa74630a1454056738e4d76 2785e800a5b145539e387ae1d8769e57 6659f5e817c341a4845873bb8275a917--2785e800a5b145539e387ae1d8769e57 b9cf8e8b25ef485593a1d33fdd8516a4 RX(p2\u2083) 2785e800a5b145539e387ae1d8769e57--b9cf8e8b25ef485593a1d33fdd8516a4 9185777fb83e4736b803f1984e7ae597 RY(p2\u2087) b9cf8e8b25ef485593a1d33fdd8516a4--9185777fb83e4736b803f1984e7ae597 9cbc3b8e46ce44ca8b3ba6fac0379dcd RX(p2\u2081\u2081) 9185777fb83e4736b803f1984e7ae597--9cbc3b8e46ce44ca8b3ba6fac0379dcd 9ecb4bb253a240608c0cb4089988121b X 9cbc3b8e46ce44ca8b3ba6fac0379dcd--9ecb4bb253a240608c0cb4089988121b 9ecb4bb253a240608c0cb4089988121b--059d36b2f68748ee97077981eec1785b 87697e73e1a643adbfe38a7b61fca827 9ecb4bb253a240608c0cb4089988121b--87697e73e1a643adbfe38a7b61fca827 a0dee12e36b048e2ab4f2f2171d5f671 RX(p2\u2081\u2085) 87697e73e1a643adbfe38a7b61fca827--a0dee12e36b048e2ab4f2f2171d5f671 489bf39ab56b40faba25962fb965582f RY(p2\u2081\u2089) a0dee12e36b048e2ab4f2f2171d5f671--489bf39ab56b40faba25962fb965582f 49c37edf950345699d68be76a3ca562c RX(p2\u2082\u2083) 489bf39ab56b40faba25962fb965582f--49c37edf950345699d68be76a3ca562c cb5dd1bdd4f746ac88bf9680cb85a45f X 49c37edf950345699d68be76a3ca562c--cb5dd1bdd4f746ac88bf9680cb85a45f cb5dd1bdd4f746ac88bf9680cb85a45f--238b67701f3b4bee9bd4a8faf104739b b86b1644e3ef495092d644f6f3d961a8 cb5dd1bdd4f746ac88bf9680cb85a45f--b86b1644e3ef495092d644f6f3d961a8 b86b1644e3ef495092d644f6f3d961a8--75b427427e6a43bf89048fb0770072ea </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9406])), ('theta_0', tensor([0.7951])), ('theta_1', tensor([0.3345])), ('theta_10', tensor([0.8927])), ('theta_11', tensor([0.3210])), ('theta_12', tensor([0.3358])), ('theta_13', tensor([0.6445])), ('theta_14', tensor([0.1183])), ('theta_15', tensor([0.8274])), ('theta_16', tensor([0.6881])), ('theta_17', tensor([0.5928])), ('theta_18', tensor([0.2551])), ('theta_19', tensor([0.3500])), ('theta_2', tensor([0.3125])), ('theta_20', tensor([0.5327])), ('theta_21', tensor([0.0981])), ('theta_22', tensor([0.1385])), ('theta_23', tensor([0.6408])), ('theta_3', tensor([0.4979])), ('theta_4', tensor([0.4264])), ('theta_5', tensor([0.5154])), ('theta_6', tensor([0.6589])), ('theta_7', tensor([0.1994])), ('theta_8', tensor([0.9758])), ('theta_9', tensor([0.9689]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9396])), ('theta_0', tensor([0.7941])), ('theta_1', tensor([0.3335])), ('theta_10', tensor([0.8937])), ('theta_11', tensor([0.3200])), ('theta_12', tensor([0.3348])), ('theta_13', tensor([0.6435])), ('theta_14', tensor([0.1193])), ('theta_15', tensor([0.8264])), ('theta_16', tensor([0.6891])), ('theta_17', tensor([0.5918])), ('theta_18', tensor([0.2561])), ('theta_19', tensor([0.3510])), ('theta_2', tensor([0.3135])), ('theta_20', tensor([0.5317])), ('theta_21', tensor([0.0971])), ('theta_22', tensor([0.1395])), ('theta_23', tensor([0.6398])), ('theta_3', tensor([0.4969])), ('theta_4', tensor([0.4254])), ('theta_5', tensor([0.5144])), ('theta_6', tensor([0.6579])), ('theta_7', tensor([0.2004])), ('theta_8', tensor([0.9748])), ('theta_9', tensor([0.9679]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows to compose with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution with non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): ParametricPyQOperation(\n(operation): RX(qubits=(0,), n_qubits=2)\n)\n(1): ParametricPyQOperation(\n(operation): RX(qubits=(1,), n_qubits=2)\n)\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9940+0.0000j,  0.0000-0.0774j,  0.0000-0.0774j, -0.0060+0.0000j],\n[ 0.8271+0.0000j,  0.0000-0.3781j,  0.0000-0.3781j, -0.1729+0.0000j],\n[ 0.9494+0.0000j,  0.0000-0.2191j,  0.0000-0.2191j, -0.0506+0.0000j]])\nxs = [Counter({'00': 98, '01': 1, '10': 1}), Counter({'00': 67, '01': 18, '10': 13, '11': 2}), Counter({'00': 86, '01': 7, '10': 6, '11': 1})]\nex = tensor([[0.9879],\n[0.6543],\n[0.8988]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9879, 0.9879],\n[0.6543, 0.6543],\n[0.8988, 0.8988]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the machine learning tools section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-10-12T17:03:18.154328 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-10-12T17:03:18.304622 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-10-12T17:03:18.344002 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>Qubits coordinates in Qadence are dimensionless but converted to the required unit when executed on a backend. For instance, Pulser uses \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often asssumed in simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interaction must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 58, '00': 42})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 58, '00': 42})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care for automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 87, '01': 13})]\nOn Braket = [Counter({'00': 80, '01': 20})]\nOn Pulser = [Counter({'00': 87, '01': 13})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9223+0.0000j, 0.0000-0.3865j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [ 0.88694888+0.j         -0.16460029+0.j          0.        -0.42429736j\n0.        +0.07874125j]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> cluster_c9080fb247324669aebe8f9fe25cba2d Circuit block cluster_5e7cb31c72d54ea29eac3a6e29f157cb Prep block 4c234326b018468d9318620eb39d891a 0 7dda189c4a834c12b2c0935ec1821c28 4c234326b018468d9318620eb39d891a--7dda189c4a834c12b2c0935ec1821c28 6a1d831d32384f53b430d0f007c753cc 1 5068583f4e124d31b6e39cf3a9726b5a RX(theta\u2080) 7dda189c4a834c12b2c0935ec1821c28--5068583f4e124d31b6e39cf3a9726b5a d9cb3e204cdc4a30a50ee3356185eeb1 RY(theta\u2084) 5068583f4e124d31b6e39cf3a9726b5a--d9cb3e204cdc4a30a50ee3356185eeb1 8cbf33575c7a46a7bae2fe6e250316a8 RX(theta\u2088) d9cb3e204cdc4a30a50ee3356185eeb1--8cbf33575c7a46a7bae2fe6e250316a8 a150e2e2ec514beebd0db1918e334fc8 8cbf33575c7a46a7bae2fe6e250316a8--a150e2e2ec514beebd0db1918e334fc8 7d1980fa412444dda678b4bc45119f8c a150e2e2ec514beebd0db1918e334fc8--7d1980fa412444dda678b4bc45119f8c eb90556ffbc140adaf914f688114ff1c RX(theta\u2081\u2082) 7d1980fa412444dda678b4bc45119f8c--eb90556ffbc140adaf914f688114ff1c b37b742d3b894f0c92ed2e3d11b6e714 RY(theta\u2081\u2086) eb90556ffbc140adaf914f688114ff1c--b37b742d3b894f0c92ed2e3d11b6e714 7486e10b38ab4ba0a2b5b3677adf2837 RX(theta\u2082\u2080) b37b742d3b894f0c92ed2e3d11b6e714--7486e10b38ab4ba0a2b5b3677adf2837 7b62631a38aa41c1aba24a2c6ef8c77b 7486e10b38ab4ba0a2b5b3677adf2837--7b62631a38aa41c1aba24a2c6ef8c77b 9d762eb3efe7461eb7b8164aa981fa6e 7b62631a38aa41c1aba24a2c6ef8c77b--9d762eb3efe7461eb7b8164aa981fa6e 0530e4b7142540b3b097a999907c3847 9d762eb3efe7461eb7b8164aa981fa6e--0530e4b7142540b3b097a999907c3847 d14753e89d624257bc93a97d1f9ade23 e53b561c754e45bc832145995c96ec20 6a1d831d32384f53b430d0f007c753cc--e53b561c754e45bc832145995c96ec20 bde6f2918e7541d8898aabf4a7d438f9 2 eac8c5a328a34db4bcb62d9d17a18729 RX(theta\u2081) e53b561c754e45bc832145995c96ec20--eac8c5a328a34db4bcb62d9d17a18729 8b0ada6b54f74208b90fb71bfa1336c0 RY(theta\u2085) eac8c5a328a34db4bcb62d9d17a18729--8b0ada6b54f74208b90fb71bfa1336c0 8f254da906fd4e0d92122547e7048265 RX(theta\u2089) 8b0ada6b54f74208b90fb71bfa1336c0--8f254da906fd4e0d92122547e7048265 b5c109c1b87e4a1189c7406698a62fe2 X 8f254da906fd4e0d92122547e7048265--b5c109c1b87e4a1189c7406698a62fe2 b5c109c1b87e4a1189c7406698a62fe2--a150e2e2ec514beebd0db1918e334fc8 991d5f0980314d5c962804cb5fc1ee30 b5c109c1b87e4a1189c7406698a62fe2--991d5f0980314d5c962804cb5fc1ee30 88ca7c5521ca4fdab665d6afafc21335 RX(theta\u2081\u2083) 991d5f0980314d5c962804cb5fc1ee30--88ca7c5521ca4fdab665d6afafc21335 e4c908c6b9464626be3cb5fe0043f60a RY(theta\u2081\u2087) 88ca7c5521ca4fdab665d6afafc21335--e4c908c6b9464626be3cb5fe0043f60a efe83b726bec46289ccfbbcb9ecf9566 RX(theta\u2082\u2081) e4c908c6b9464626be3cb5fe0043f60a--efe83b726bec46289ccfbbcb9ecf9566 088eff2fa1a0436dae68a28c8377d53b X efe83b726bec46289ccfbbcb9ecf9566--088eff2fa1a0436dae68a28c8377d53b 088eff2fa1a0436dae68a28c8377d53b--7b62631a38aa41c1aba24a2c6ef8c77b 055ca29e65a94445b719914d8d8c801b 088eff2fa1a0436dae68a28c8377d53b--055ca29e65a94445b719914d8d8c801b 055ca29e65a94445b719914d8d8c801b--d14753e89d624257bc93a97d1f9ade23 75a2749977ea44739bddf6ac84e6f18f 5d7bdaddc5284cc6a21f1f6515358730 bde6f2918e7541d8898aabf4a7d438f9--5d7bdaddc5284cc6a21f1f6515358730 cc131062ee224defb90bbed93438a56d 3 a646196dd81544d686a20b3ac6531845 RX(theta\u2082) 5d7bdaddc5284cc6a21f1f6515358730--a646196dd81544d686a20b3ac6531845 f820fdefc9b640a09e9775b07711d161 RY(theta\u2086) a646196dd81544d686a20b3ac6531845--f820fdefc9b640a09e9775b07711d161 f4fedf8aa6384e6898b58b6a895952c1 RX(theta\u2081\u2080) f820fdefc9b640a09e9775b07711d161--f4fedf8aa6384e6898b58b6a895952c1 05cbb944408049c28c0ec4ef8d30de02 f4fedf8aa6384e6898b58b6a895952c1--05cbb944408049c28c0ec4ef8d30de02 0ea47b261aa34277bcb77995d2675b23 X 05cbb944408049c28c0ec4ef8d30de02--0ea47b261aa34277bcb77995d2675b23 0ea47b261aa34277bcb77995d2675b23--991d5f0980314d5c962804cb5fc1ee30 310ba29f0e1d4a1daaeede92819c78f9 RX(theta\u2081\u2084) 0ea47b261aa34277bcb77995d2675b23--310ba29f0e1d4a1daaeede92819c78f9 45aabd285c3846c3ae250cca875999c9 RY(theta\u2081\u2088) 310ba29f0e1d4a1daaeede92819c78f9--45aabd285c3846c3ae250cca875999c9 5cdeddc0907b4febbd277a8517b7776a RX(theta\u2082\u2082) 45aabd285c3846c3ae250cca875999c9--5cdeddc0907b4febbd277a8517b7776a 5fabea42506d444bacde7be9d7e25baa 5cdeddc0907b4febbd277a8517b7776a--5fabea42506d444bacde7be9d7e25baa 01a68382dc6044d4aea6a375af6f3338 X 5fabea42506d444bacde7be9d7e25baa--01a68382dc6044d4aea6a375af6f3338 01a68382dc6044d4aea6a375af6f3338--055ca29e65a94445b719914d8d8c801b 01a68382dc6044d4aea6a375af6f3338--75a2749977ea44739bddf6ac84e6f18f b7ed7f12c8b240a4bad200a548171ee2 bc4ed5ffbaec471d8085c305d8918f7a X cc131062ee224defb90bbed93438a56d--bc4ed5ffbaec471d8085c305d8918f7a 4f8865ed2a584499abce167bab597147 RX(theta\u2083) bc4ed5ffbaec471d8085c305d8918f7a--4f8865ed2a584499abce167bab597147 bf71349a4c724f0fa91e62a7688a1e02 RY(theta\u2087) 4f8865ed2a584499abce167bab597147--bf71349a4c724f0fa91e62a7688a1e02 17d3024aeeec4fcc89a17bf40c5c5917 RX(theta\u2081\u2081) bf71349a4c724f0fa91e62a7688a1e02--17d3024aeeec4fcc89a17bf40c5c5917 d5a8480e9c3d4607ba9b6c3bd4d3a2b8 X 17d3024aeeec4fcc89a17bf40c5c5917--d5a8480e9c3d4607ba9b6c3bd4d3a2b8 d5a8480e9c3d4607ba9b6c3bd4d3a2b8--05cbb944408049c28c0ec4ef8d30de02 18b9742934ff4d1f904aaebab977442f d5a8480e9c3d4607ba9b6c3bd4d3a2b8--18b9742934ff4d1f904aaebab977442f 78f0abd507b34cc1afee095177f110ee RX(theta\u2081\u2085) 18b9742934ff4d1f904aaebab977442f--78f0abd507b34cc1afee095177f110ee 5a526c11082d4fbcababfa3f74199cc3 RY(theta\u2081\u2089) 78f0abd507b34cc1afee095177f110ee--5a526c11082d4fbcababfa3f74199cc3 7aec9c35dfb64e27899d584be2f895a4 RX(theta\u2082\u2083) 5a526c11082d4fbcababfa3f74199cc3--7aec9c35dfb64e27899d584be2f895a4 90cf9a886c1b44be8dfafa02a11f3598 X 7aec9c35dfb64e27899d584be2f895a4--90cf9a886c1b44be8dfafa02a11f3598 90cf9a886c1b44be8dfafa02a11f3598--5fabea42506d444bacde7be9d7e25baa 4e7fbdbd0e844bb4aa258d9d9475f1a1 90cf9a886c1b44be8dfafa02a11f3598--4e7fbdbd0e844bb4aa258d9d9475f1a1 4e7fbdbd0e844bb4aa258d9d9475f1a1--b7ed7f12c8b240a4bad200a548171ee2  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.4733+0.0588j, -0.3286+0.0288j, -0.0680+0.3754j, -0.3299-0.1679j,\n0.0818+0.2296j, -0.2771-0.2593j, -0.0508+0.0349j,  0.1995-0.3662j],\n[-0.2293+0.0824j, -0.0980-0.0311j, -0.0049-0.1667j,  0.5866+0.3335j,\n0.1787+0.1656j,  0.0792-0.1512j, -0.5753+0.0789j,  0.1434-0.0244j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 CNOT(1,2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}