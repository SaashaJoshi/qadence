{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interation until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])  # Dimensionless.\nsamples = sample(register, block)\n# Interacting qubits as close together.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 38, '01': 35, '10': 27})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket, pulser, visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        protocol: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._protocol = protocol\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code></p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        protocol: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nprotocol=protocol,\nconfiguration=configuration,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.transform(\nself.expectation(values=values, state=state, protocol=protocol, endianness=endianness)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-10-16T14:57:55.901270 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor field in fields(self):\nif not field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {field.name} - Type: {field.type} - Default value: {field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend. Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend. Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        protocol: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, state=None, n_shots=1, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nstate: Tensor | None = None,\nn_shots: int = 1,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>idealized device, least realistic</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>device with realistic specs</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction and loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing. Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates. Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: list[int] | tuple,\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single\n    call to _apply_batch_gate.\"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> c3260dbfc72c4e5b94404981cffd2992 0 ed7927606fb74066a61728232d85aabe X c3260dbfc72c4e5b94404981cffd2992--ed7927606fb74066a61728232d85aabe 2ccbc122b43543f98e15c382fdf20944 1 2a1fecda65784a729d50092c622a7aa5 ed7927606fb74066a61728232d85aabe--2a1fecda65784a729d50092c622a7aa5 92ae586001cb45098e0e016c8655b960 a57053ad835540f4a295244a02ba63a3 Y 2ccbc122b43543f98e15c382fdf20944--a57053ad835540f4a295244a02ba63a3 a57053ad835540f4a295244a02ba63a3--92ae586001cb45098e0e016c8655b960 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> dbf2f40851a74e8b84c858c0ede6e4c5 0 5df61b8b4fe54a1c804ad8fb10b19fc7 X dbf2f40851a74e8b84c858c0ede6e4c5--5df61b8b4fe54a1c804ad8fb10b19fc7 0c6d599ed7d747f98883601897f84108 Y 5df61b8b4fe54a1c804ad8fb10b19fc7--0c6d599ed7d747f98883601897f84108 1217ac0fc312455cbb9a780621fe4c61 0c6d599ed7d747f98883601897f84108--1217ac0fc312455cbb9a780621fe4c61 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> 093827f914564edf9d0f20dfc3c5df46 0 0d598f174aa74409984d29addd4f7b8d X 093827f914564edf9d0f20dfc3c5df46--0d598f174aa74409984d29addd4f7b8d 0198866665094872bd6cb0cc97dbe9c0 1 df101e1ab96644af912508c04515f5e8 0d598f174aa74409984d29addd4f7b8d--df101e1ab96644af912508c04515f5e8 3e0aafa1ed324cd1a99228028e6d68b9 df101e1ab96644af912508c04515f5e8--3e0aafa1ed324cd1a99228028e6d68b9 32eff0881fe14296bf9d35b63315c48f 033942169cf044e8ae110204145456a1 0198866665094872bd6cb0cc97dbe9c0--033942169cf044e8ae110204145456a1 11d5e23561ee4fb982be6004677d9e39 Y 033942169cf044e8ae110204145456a1--11d5e23561ee4fb982be6004677d9e39 11d5e23561ee4fb982be6004677d9e39--32eff0881fe14296bf9d35b63315c48f <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> cluster_7eb1d272a6df4fbfa5e7395c1b6c2f5d 04eb3f68665b4ff298f586feda76b65b 0 4e04f94d4dba4c0297f7760f6bbd27e1 04eb3f68665b4ff298f586feda76b65b--4e04f94d4dba4c0297f7760f6bbd27e1 c06b4cef2aca4d48b83ab9c720755d2f 1 df11c492c021426ca2768567f95934c2 4e04f94d4dba4c0297f7760f6bbd27e1--df11c492c021426ca2768567f95934c2 0724e5d2727b45ca8adc576bf8f22df5 4653a31f423a4153b55456d383939e25 AddBlock c06b4cef2aca4d48b83ab9c720755d2f--4653a31f423a4153b55456d383939e25 532f463f1d274af78a67e6808cc2a886 2 4653a31f423a4153b55456d383939e25--0724e5d2727b45ca8adc576bf8f22df5 7bacfede2efb4ee49e1051d132e84714 83ef579d63d7416ab4ea04c141cebcba 532f463f1d274af78a67e6808cc2a886--83ef579d63d7416ab4ea04c141cebcba 83ef579d63d7416ab4ea04c141cebcba--7bacfede2efb4ee49e1051d132e84714 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> cluster_629bda2cd142414fa76dbce16331c4fd cluster_ff2aa4327a9e4b3fb9a3be3076600976 rx a9ac02ab4c2d414ab2d2c37377aebe50 0 465f76b0a7614ed8a7928a6be11a254f X a9ac02ab4c2d414ab2d2c37377aebe50--465f76b0a7614ed8a7928a6be11a254f 769da6b1766c4e20b176214a929fa3d1 1 035b091682aa4838bfcb981971df2ac2 465f76b0a7614ed8a7928a6be11a254f--035b091682aa4838bfcb981971df2ac2 19c2ae6e602945bba7d61e4519d5ad1b 035b091682aa4838bfcb981971df2ac2--19c2ae6e602945bba7d61e4519d5ad1b 3d7c70fea3aa4186a8f3a7720ba20fba 19c2ae6e602945bba7d61e4519d5ad1b--3d7c70fea3aa4186a8f3a7720ba20fba d9c7f944bf8d433d85c6ca4e4bd279aa f3ca7a5013dc4865addf417b25ad6af5 Y 769da6b1766c4e20b176214a929fa3d1--f3ca7a5013dc4865addf417b25ad6af5 4b205a881acb476f8ce41efb1253f0c2 2 4806a1ebeae24bed8396344738cbfc41 f3ca7a5013dc4865addf417b25ad6af5--4806a1ebeae24bed8396344738cbfc41 4432843c5de0432e8829d812700e3607 HamEvo 4806a1ebeae24bed8396344738cbfc41--4432843c5de0432e8829d812700e3607 4432843c5de0432e8829d812700e3607--d9c7f944bf8d433d85c6ca4e4bd279aa 0d51a2e045864f6c8b1b0d5e1061fec8 a0eda5f4a223487da77c985d81f55312 RX(x) 4b205a881acb476f8ce41efb1253f0c2--a0eda5f4a223487da77c985d81f55312 6ca719774e8d40a1b0719fe5e4844df5 3 9ce67dfe797447d7bb99a1aeeb1e525c a0eda5f4a223487da77c985d81f55312--9ce67dfe797447d7bb99a1aeeb1e525c b8fb9b86aba44d53972a6eedd782c307 t = 10 9ce67dfe797447d7bb99a1aeeb1e525c--b8fb9b86aba44d53972a6eedd782c307 b8fb9b86aba44d53972a6eedd782c307--0d51a2e045864f6c8b1b0d5e1061fec8 d932d34a6744499d9d68a98f0a1713be 0b8adb5bd27444e798b8471e93391ffd RX(0.5) 6ca719774e8d40a1b0719fe5e4844df5--0b8adb5bd27444e798b8471e93391ffd 0c652339764742bc81ae578598ccc00f X 0b8adb5bd27444e798b8471e93391ffd--0c652339764742bc81ae578598ccc00f 0c652339764742bc81ae578598ccc00f--9ce67dfe797447d7bb99a1aeeb1e525c 344b9d83cb344199a9485a4412a675e7 0c652339764742bc81ae578598ccc00f--344b9d83cb344199a9485a4412a675e7 344b9d83cb344199a9485a4412a675e7--d932d34a6744499d9d68a98f0a1713be <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, fm_type=\"tower\"), hea(4,2))\n</code></pre> cluster_d5ce61cd8ca24a10a7fa2b41ddacc2a2 HEA cluster_42ada1d04e324f9a9de18ee2e99d9296 FM f37c7b3b2642467e9c452cb4c757f008 0 3fa53b44b5e3425aa0b7317fb596dcaf RX(2*acos(phi)) f37c7b3b2642467e9c452cb4c757f008--3fa53b44b5e3425aa0b7317fb596dcaf 06da9f80e09b41d3ae02e58b6a6e2b8f 1 0eac58505acc474fafd85116323723ff RX(theta\u2080) 3fa53b44b5e3425aa0b7317fb596dcaf--0eac58505acc474fafd85116323723ff c0b83fd78de14c72abf4745b9ffd7c2a RY(theta\u2084) 0eac58505acc474fafd85116323723ff--c0b83fd78de14c72abf4745b9ffd7c2a 8dacfb63026f412880ea8b02c192de02 RX(theta\u2088) c0b83fd78de14c72abf4745b9ffd7c2a--8dacfb63026f412880ea8b02c192de02 e94b64768ef8429fa73e295f0265e56e 8dacfb63026f412880ea8b02c192de02--e94b64768ef8429fa73e295f0265e56e 8353b80bfbf54e33b9f0cb786cd0242b e94b64768ef8429fa73e295f0265e56e--8353b80bfbf54e33b9f0cb786cd0242b 51f50348a43641bca41fe56f86203223 RX(theta\u2081\u2082) 8353b80bfbf54e33b9f0cb786cd0242b--51f50348a43641bca41fe56f86203223 261305dd9f4b44479cff6ed925dfcf7d RY(theta\u2081\u2086) 51f50348a43641bca41fe56f86203223--261305dd9f4b44479cff6ed925dfcf7d 4680ab84147548cab2930eb83292c9ff RX(theta\u2082\u2080) 261305dd9f4b44479cff6ed925dfcf7d--4680ab84147548cab2930eb83292c9ff 58b0da44514b4cd7828e79f691deb713 4680ab84147548cab2930eb83292c9ff--58b0da44514b4cd7828e79f691deb713 8674cd088a244324828f2c415cab8372 58b0da44514b4cd7828e79f691deb713--8674cd088a244324828f2c415cab8372 dd302c11c3b947ee826a7afa9d17fcf1 8674cd088a244324828f2c415cab8372--dd302c11c3b947ee826a7afa9d17fcf1 8df7ed5fecf34b7e9919da636c7d5a7e f72db530796b4034a3b2118ba278cafd RX(4*acos(phi)) 06da9f80e09b41d3ae02e58b6a6e2b8f--f72db530796b4034a3b2118ba278cafd 19340661048c4bfb8b28d9e88cb25142 2 afef6dd686d84c36a6de8b0b862ad123 RX(theta\u2081) f72db530796b4034a3b2118ba278cafd--afef6dd686d84c36a6de8b0b862ad123 b08df11410a94ab1b833e5f67fbed8d8 RY(theta\u2085) afef6dd686d84c36a6de8b0b862ad123--b08df11410a94ab1b833e5f67fbed8d8 5078846419544b0e95a242e47d856b11 RX(theta\u2089) b08df11410a94ab1b833e5f67fbed8d8--5078846419544b0e95a242e47d856b11 d67b9a5f1e1f4af8aabafb843a54df0e X 5078846419544b0e95a242e47d856b11--d67b9a5f1e1f4af8aabafb843a54df0e d67b9a5f1e1f4af8aabafb843a54df0e--e94b64768ef8429fa73e295f0265e56e d0df94698919480493a582e9158dc179 d67b9a5f1e1f4af8aabafb843a54df0e--d0df94698919480493a582e9158dc179 3f57fb90f0ef4b0286a087e674bfc961 RX(theta\u2081\u2083) d0df94698919480493a582e9158dc179--3f57fb90f0ef4b0286a087e674bfc961 d55c4c8d60ca4478b9337d67e051bcc8 RY(theta\u2081\u2087) 3f57fb90f0ef4b0286a087e674bfc961--d55c4c8d60ca4478b9337d67e051bcc8 3eac91f0abd347c69e7c7f33d24b69f2 RX(theta\u2082\u2081) d55c4c8d60ca4478b9337d67e051bcc8--3eac91f0abd347c69e7c7f33d24b69f2 e8adbab0147f4c168ca1000faf80df82 X 3eac91f0abd347c69e7c7f33d24b69f2--e8adbab0147f4c168ca1000faf80df82 e8adbab0147f4c168ca1000faf80df82--58b0da44514b4cd7828e79f691deb713 61f553eb77be43a386000fe7e62bc107 e8adbab0147f4c168ca1000faf80df82--61f553eb77be43a386000fe7e62bc107 61f553eb77be43a386000fe7e62bc107--8df7ed5fecf34b7e9919da636c7d5a7e 7cb71fcaf6eb4ff6821883abeb553061 e021b162edca40c4be907535f210189d RX(6*acos(phi)) 19340661048c4bfb8b28d9e88cb25142--e021b162edca40c4be907535f210189d 47871ed5bf1f4a3daf5ed174c5f89282 3 38e5ad8af7a544f7bf4ec65fd6c30501 RX(theta\u2082) e021b162edca40c4be907535f210189d--38e5ad8af7a544f7bf4ec65fd6c30501 665e18ca5b234d00986eb53932f5ab62 RY(theta\u2086) 38e5ad8af7a544f7bf4ec65fd6c30501--665e18ca5b234d00986eb53932f5ab62 2f2fac55ed5a4dd09230a380b3297e6d RX(theta\u2081\u2080) 665e18ca5b234d00986eb53932f5ab62--2f2fac55ed5a4dd09230a380b3297e6d f52b7412a00040998db1475a0b6717b1 2f2fac55ed5a4dd09230a380b3297e6d--f52b7412a00040998db1475a0b6717b1 100d2ed9a03d41038eecf0f808fb015e X f52b7412a00040998db1475a0b6717b1--100d2ed9a03d41038eecf0f808fb015e 100d2ed9a03d41038eecf0f808fb015e--d0df94698919480493a582e9158dc179 ace5f9c153d148e58cb91bf8bbda6616 RX(theta\u2081\u2084) 100d2ed9a03d41038eecf0f808fb015e--ace5f9c153d148e58cb91bf8bbda6616 15f6cdb8c08a4a679960895ae7844e68 RY(theta\u2081\u2088) ace5f9c153d148e58cb91bf8bbda6616--15f6cdb8c08a4a679960895ae7844e68 0f4611ebbf704239a289396fcd2f8adc RX(theta\u2082\u2082) 15f6cdb8c08a4a679960895ae7844e68--0f4611ebbf704239a289396fcd2f8adc f26e51d4bfc34d0cbb7e8b3525a6a99e 0f4611ebbf704239a289396fcd2f8adc--f26e51d4bfc34d0cbb7e8b3525a6a99e d979cae91b2842a2b9d67cdc52cda2b9 X f26e51d4bfc34d0cbb7e8b3525a6a99e--d979cae91b2842a2b9d67cdc52cda2b9 d979cae91b2842a2b9d67cdc52cda2b9--61f553eb77be43a386000fe7e62bc107 d979cae91b2842a2b9d67cdc52cda2b9--7cb71fcaf6eb4ff6821883abeb553061 b1cd70234a454b9a8ef6421941aeeca8 b10f92edc43946f29a67c6b5f406f020 RX(8*acos(phi)) 47871ed5bf1f4a3daf5ed174c5f89282--b10f92edc43946f29a67c6b5f406f020 644e52efdd644df2a60b44b49d8e433b RX(theta\u2083) b10f92edc43946f29a67c6b5f406f020--644e52efdd644df2a60b44b49d8e433b 71ea8f052f7643859585a9f413ef1006 RY(theta\u2087) 644e52efdd644df2a60b44b49d8e433b--71ea8f052f7643859585a9f413ef1006 4039ecd36d1d4216bb5ea833fd62ea2d RX(theta\u2081\u2081) 71ea8f052f7643859585a9f413ef1006--4039ecd36d1d4216bb5ea833fd62ea2d 673a67d95dce4363affdc80e80cb441b X 4039ecd36d1d4216bb5ea833fd62ea2d--673a67d95dce4363affdc80e80cb441b 673a67d95dce4363affdc80e80cb441b--f52b7412a00040998db1475a0b6717b1 113ea7096c064878a31217360ab70348 673a67d95dce4363affdc80e80cb441b--113ea7096c064878a31217360ab70348 910555a7260540d58df62c2904d61165 RX(theta\u2081\u2085) 113ea7096c064878a31217360ab70348--910555a7260540d58df62c2904d61165 97fbf1aaec814cc18fb04da0d03627ea RY(theta\u2081\u2089) 910555a7260540d58df62c2904d61165--97fbf1aaec814cc18fb04da0d03627ea f8919cfbd88e4e6da0a368190759acfe RX(theta\u2082\u2083) 97fbf1aaec814cc18fb04da0d03627ea--f8919cfbd88e4e6da0a368190759acfe d50fed72d16c4cdbbad1d8bdaaedc0a1 X f8919cfbd88e4e6da0a368190759acfe--d50fed72d16c4cdbbad1d8bdaaedc0a1 d50fed72d16c4cdbbad1d8bdaaedc0a1--f26e51d4bfc34d0cbb7e8b3525a6a99e 4365cedaf45d483ca6dfb195cf0e8eae d50fed72d16c4cdbbad1d8bdaaedc0a1--4365cedaf45d483ca6dfb195cf0e8eae 4365cedaf45d483ca6dfb195cf0e8eae--b1cd70234a454b9a8ef6421941aeeca8"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/","title":"Digital-Analog Emulation","text":""},{"location":"digital_analog_qc/analog-basics/#from-theory-to-implementation","title":"From theory to implementation","text":"<p>Qadence includes primitives for the construction of Ising-like Hamiltonians to account for custom qubit interaction. This allows to simulate systems close to real quantum computing platforms such as neutral atoms. The general form for time-independent Ising Hamiltonians is</p> \\[ \\mathcal{H} = \\sum_{i} \\frac{\\hbar\\Omega}{2} \\hat\\sigma^x_i - \\sum_{i} \\hbar\\delta \\hat n_i  + \\mathcal{H}_{\\textrm{int}}, \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\hat n = \\frac{1-\\hat\\sigma_z}{2}\\) is the number operator, and \\(\\mathcal{H}_{\\textrm{int}}\\) a pair-wise interaction term. Two central operations implement this Hamiltonian as blocks:</p> <ul> <li><code>WaitBlock</code> by free-evolving \\(\\mathcal{H}_{\\textrm{int}}\\)</li> <li><code>ConstantAnalogRotation</code> by free-evolving \\(\\mathcal{H}\\)</li> </ul> <p>The <code>wait</code> operation can be emulated with an \\(ZZ\\)- (Ising) or an \\(XY\\)-interaction:</p> <pre><code>from qadence import Register, wait, add_interaction, run, Interaction\nblock = wait(duration=3000)\nreg = Register.from_coordinates([(0,0), (0,5)])  # Dimensionless.\nemulated = add_interaction(reg, block, interaction=Interaction.XY)  # or Interaction.ZZ for Ising.\n</code></pre> <pre><code>block = WaitBlock(t=3000.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,)) emulated.generator = AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 29.600] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> <p>The <code>AnalogRot</code> constructor can be used to create a fully customizable <code>ConstantAnalogRotation</code> instances:</p> <pre><code>import torch\nfrom qadence import AnalogRot, AnalogRX\n# Implement a global RX rotation by setting all parameters.\nblock = AnalogRot(\nduration=1000., # [ns]\nomega=torch.pi, # [rad/\u03bcs]\ndelta=0,        # [rad/\u03bcs]\nphase=0,        # [rad]\n)\n# Or use the shortcut.\nblock = AnalogRX(torch.pi)\n</code></pre> <pre><code>AnalogRot = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\nAnalogRX = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\n</code></pre> <p>Automatic emulation in the PyQTorch backend</p> <p>All analog blocks are automatically translated to their emulated version when running them with the PyQTorch backend:</p> <p><pre><code>import torch\nfrom qadence import Register, AnalogRX, sample\nreg = Register.from_coordinates([(0,0), (0,5)])\nsample = sample(reg, AnalogRX(torch.pi))\n</code></pre> <pre><code>sample = [Counter({'00': 40, '10': 32, '01': 28})]\n</code></pre> </p> <p>To compose analog blocks, the regular <code>chain</code> and <code>kron</code> operations can be used under the following restrictions:</p> <ul> <li>The resulting <code>AnalogChain</code> type can only be constructed from <code>AnalogKron</code> blocks   or globally supported primitive analog blocks.</li> <li>The resulting <code>AnalogKron</code> type can only be constructed from non-global   analog blocks with the same duration.</li> </ul> <pre><code>import torch\nfrom qadence import AnalogRot, kron, chain, wait\n# Only analog blocks with a global qubit support can be composed\n# using chain.\nanalog_chain = chain(wait(duration=200), AnalogRot(duration=300, omega=2.0))\n# Only blocks with the same `duration` can be composed using kron.\nanalog_kron = kron(\nwait(duration=1000, qubit_support=(0,1)),\nAnalogRot(duration=1000, omega=2.0, qubit_support=(2,3))\n)\n</code></pre> <pre><code>Analog Chain block = AnalogChain(t=500.000000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u251c\u2500\u2500 WaitBlock(t=200.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=0.600000000000000, t=300, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\nAnalog Kron block = AnalogKron(t=1000, support=(0, 1, 2, 3))\n\u251c\u2500\u2500 WaitBlock(t=1000.0, support=(0, 1))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=2.00000000000000, t=1000, support=(2, 3), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\n</code></pre> <p>Composing digital &amp; analog blocks</p> <p>It is possible to compose digital and analog blocks where the additional restrictions for <code>chain</code> and <code>kron</code> only apply to composite blocks which contain analog blocks only. For further details, see <code>AnalogChain</code> and <code>AnalogKron</code>.</p>"},{"location":"digital_analog_qc/analog-basics/#fitting-a-simple-function","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and paramertized ansatze to fit a sine function. First, define an ansatz block and an observable:</p> <pre><code>import torch\nfrom qadence import Register, FeatureParameter, VariationalParameter\nfrom qadence import AnalogRX, AnalogRZ, Z\nfrom qadence import wait, chain, add\npi = torch.pi\n# A two qubit register.\nreg = Register.from_coordinates([(0, 0), (0, 12)])\n# An analog ansatz with an input time parameter.\nt = FeatureParameter(\"t\")\nblock = chain(\nAnalogRX(pi/2.),\nAnalogRZ(t),\nwait(1000 * VariationalParameter(\"theta\", value=0.5)),\nAnalogRX(pi/2),\n)\n# Total magnetization observable.\nobs = add(Z(i) for i in range(reg.n_qubits))\n</code></pre> Plotting functions <code>plot</code> and <code>scatter</code> <p><pre><code>def plot(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.plot(xnp, ynp, **kwargs)\ndef scatter(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.scatter(xnp, ynp, **kwargs)\n</code></pre> </p> <p>Next, define the dataset to train on and plot the initial prediction. The differentiation mode can be set to either <code>DiffMode.AD</code> or <code>DiffMode.GPSR</code>.</p> <pre><code>import matplotlib.pyplot as plt\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\n# Define a quantum model including digital-analog emulation.\ncirc = QuantumCircuit(reg, block)\nmodel = QuantumModel(circ, obs, diff_mode=DiffMode.GPSR)\n# Time support dataset.\nx_train = torch.linspace(0, 6, steps=30)\n# Function to fit.\ny_train = -0.64 * torch.sin(x_train + 0.33) + 0.1\n# Initial prediction.\ny_pred_initial = model.expectation({\"t\": x_train})\n</code></pre> 2023-10-16T14:57:57.821781 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Finally, the classical optimization part is handled by PyTorch:</p> <pre><code># Use PyTorch built-in functionality.\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-2)\n# Define a loss function.\ndef loss_fn(x_train, y_train):\nreturn mse_loss(model.expectation({\"t\": x_train}).squeeze(), y_train)\n# Number of epochs to train over.\nn_epochs = 200\n# Optimization loop.\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n# Get and visualize the final prediction.\ny_pred = model.expectation({\"t\": x_train})\n</code></pre> 2023-10-16T14:58:00.921006 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.transpile.emulate import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430082484387*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279677658339*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430082484387*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279677658339*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 89, '00100': 86, '10000': 76, '00001': 74, '00010': 72, '00101': 19, '11000': 18, '10010': 13, '01001': 12, '10100': 12, '00011': 11, '00110': 11, '01100': 8, '10001': 8, '01010': 7, '01101': 3, '10110': 3, '00111': 2, '10011': 2, '11010': 2, '01011': 1, '10101': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 243, '01011': 200, '00100': 103, '01000': 97, '01001': 82, '00110': 72, '00000': 61, '00001': 33, '00010': 25, '10000': 23, '01010': 16, '00101': 14, '10001': 7, '10011': 7, '01111': 5, '10010': 5, '01101': 4, '00011': 2, '01100': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-10-16T14:58:01.960719 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-basics/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>The DAQC paradigm is typically implemented on quantum computing hardware based on neutral-atoms where both these computations are realizable.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real neutral-atom devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/daqc-basics/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> cluster_455661ff43c74065b468fe7f536f2576 cluster_c391cb6f2dc04dddb7e7f9acbaf4f981 cluster_9dfdc24d3de14c79920308ec03f445d3 cluster_124009c6cc9542a7a331fa7e11f92ad8 cluster_8d3d044aac4941d393a77f64acd4136e cluster_ee176fb005af404898dd4c3b5dccfaab cluster_6397ca89cc11430dad06951cbf5057e1 b3a81131395344bf9c7c82a5febc8a16 0 0fdf285bf14f4be1a3aaaf92b4759b45 HamEvo b3a81131395344bf9c7c82a5febc8a16--0fdf285bf14f4be1a3aaaf92b4759b45 d6289e5527c1488589fe469df93f78a6 1 1555bd55a345441096eb71ea243b7a8d HamEvo 0fdf285bf14f4be1a3aaaf92b4759b45--1555bd55a345441096eb71ea243b7a8d 8065f385554c4402a722c9be6a6aaefb HamEvo 1555bd55a345441096eb71ea243b7a8d--8065f385554c4402a722c9be6a6aaefb 6dd7720d78ce442283604006c193808e X 8065f385554c4402a722c9be6a6aaefb--6dd7720d78ce442283604006c193808e f10350e663ba40dbb0d9a8e5a38026be HamEvo 6dd7720d78ce442283604006c193808e--f10350e663ba40dbb0d9a8e5a38026be 27324a449df3436480e6858dcc8a1298 HamEvo f10350e663ba40dbb0d9a8e5a38026be--27324a449df3436480e6858dcc8a1298 2579172c4bbd4f15a4172f93c8719d23 X 27324a449df3436480e6858dcc8a1298--2579172c4bbd4f15a4172f93c8719d23 b6f5803d68b642db9915610f9f5b3dc6 2579172c4bbd4f15a4172f93c8719d23--b6f5803d68b642db9915610f9f5b3dc6 869506926c4e4f98a92fb3af035c5ed9 HamEvo b6f5803d68b642db9915610f9f5b3dc6--869506926c4e4f98a92fb3af035c5ed9 0047087464b14828af59c716e50aacbf HamEvo 869506926c4e4f98a92fb3af035c5ed9--0047087464b14828af59c716e50aacbf 2066a74c87324785a30e51c946e2837a 0047087464b14828af59c716e50aacbf--2066a74c87324785a30e51c946e2837a e3ab3f84b37140ae83c00ae170b5da8d 2066a74c87324785a30e51c946e2837a--e3ab3f84b37140ae83c00ae170b5da8d 6e41ff9c174641488449a4812cd8a00f 2974ee5c326d4f6fbaabd0ccb2f6f3da t = -3.142 d6289e5527c1488589fe469df93f78a6--2974ee5c326d4f6fbaabd0ccb2f6f3da 58f584fde52a40bbab7f319eab1a5ca5 2 19bf1b01cc8f41ec9784a5abd7dbc8a0 t = 3.142 2974ee5c326d4f6fbaabd0ccb2f6f3da--19bf1b01cc8f41ec9784a5abd7dbc8a0 22e88e6052894497b8157a431c7230f6 t = -3.142 19bf1b01cc8f41ec9784a5abd7dbc8a0--22e88e6052894497b8157a431c7230f6 e977d92dc7ba40ac987b4bfa9c3fec29 22e88e6052894497b8157a431c7230f6--e977d92dc7ba40ac987b4bfa9c3fec29 9d015ee4dc834de58cf33b1d72d628c2 t = 1.571 e977d92dc7ba40ac987b4bfa9c3fec29--9d015ee4dc834de58cf33b1d72d628c2 8d90a7d6c73f49e285dce15a62d2f832 t = 1.571 9d015ee4dc834de58cf33b1d72d628c2--8d90a7d6c73f49e285dce15a62d2f832 8e6434aceda94c20808cbc3b295844dc 8d90a7d6c73f49e285dce15a62d2f832--8e6434aceda94c20808cbc3b295844dc abcefea7a9524ae7b9860e23bde94d52 X 8e6434aceda94c20808cbc3b295844dc--abcefea7a9524ae7b9860e23bde94d52 c1ebafb977b54fa1a561555fe1c941cd t = 1.571 abcefea7a9524ae7b9860e23bde94d52--c1ebafb977b54fa1a561555fe1c941cd f189bdfd80c1456a89940e78ae9d4e7e t = 1.571 c1ebafb977b54fa1a561555fe1c941cd--f189bdfd80c1456a89940e78ae9d4e7e c557c09134b84dc7b6e3b5741c6e1632 X f189bdfd80c1456a89940e78ae9d4e7e--c557c09134b84dc7b6e3b5741c6e1632 c557c09134b84dc7b6e3b5741c6e1632--6e41ff9c174641488449a4812cd8a00f 30855f4da5444e538a8b60c3e3081a7a 5a1b0cdbfab047bda98fcf521525aa61 58f584fde52a40bbab7f319eab1a5ca5--5a1b0cdbfab047bda98fcf521525aa61 8c468407e634476d8b31b7348295633c 5a1b0cdbfab047bda98fcf521525aa61--8c468407e634476d8b31b7348295633c 4c754db40f584764a2646a09b14cbc81 8c468407e634476d8b31b7348295633c--4c754db40f584764a2646a09b14cbc81 515286d0d3284f07a4dc97d988d557f2 X 4c754db40f584764a2646a09b14cbc81--515286d0d3284f07a4dc97d988d557f2 efa6dc6f7cea4a18bee6394d9d3d5359 515286d0d3284f07a4dc97d988d557f2--efa6dc6f7cea4a18bee6394d9d3d5359 a12fc2fa34e74174bc9f22f5a8c45674 efa6dc6f7cea4a18bee6394d9d3d5359--a12fc2fa34e74174bc9f22f5a8c45674 29223d7f8b4f485d92febff9f0506879 X a12fc2fa34e74174bc9f22f5a8c45674--29223d7f8b4f485d92febff9f0506879 1d3c94dafa2b4a51be1d8b3013de89c0 X 29223d7f8b4f485d92febff9f0506879--1d3c94dafa2b4a51be1d8b3013de89c0 487f651d3d324bdeb4faa2558dd9b2fe 1d3c94dafa2b4a51be1d8b3013de89c0--487f651d3d324bdeb4faa2558dd9b2fe b516c1ff7b764b83bf29845e75bd15e7 487f651d3d324bdeb4faa2558dd9b2fe--b516c1ff7b764b83bf29845e75bd15e7 92c21006f08b450682f51052057dddf6 X b516c1ff7b764b83bf29845e75bd15e7--92c21006f08b450682f51052057dddf6 92c21006f08b450682f51052057dddf6--30855f4da5444e538a8b60c3e3081a7a <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> cluster_6a8a7906141b49a796fd4df6b6c72a76 cluster_304fdc1ea35b4bf7abbabe2187e04879 3db0645a51e947c598d56f7b47b5fc01 0 4059ab7900c942879d69c3585965070f X 3db0645a51e947c598d56f7b47b5fc01--4059ab7900c942879d69c3585965070f a07a45b8f1654c4f8adabc26d156ba06 1 e7ce8eb86bc44f40acb2c5e4272cb499 HamEvo 4059ab7900c942879d69c3585965070f--e7ce8eb86bc44f40acb2c5e4272cb499 7b8450696b0649ed8921d9f85fa528c8 X e7ce8eb86bc44f40acb2c5e4272cb499--7b8450696b0649ed8921d9f85fa528c8 fc286096160246958e1ba16961e2314e 7b8450696b0649ed8921d9f85fa528c8--fc286096160246958e1ba16961e2314e 5e44cdb42e03414082f690955587b3db HamEvo fc286096160246958e1ba16961e2314e--5e44cdb42e03414082f690955587b3db 5e9e1fc985ac4de188a6fc15429721d8 5e44cdb42e03414082f690955587b3db--5e9e1fc985ac4de188a6fc15429721d8 2d6a9d3f027b4276a4db9ea2ca6ce7af 5e9e1fc985ac4de188a6fc15429721d8--2d6a9d3f027b4276a4db9ea2ca6ce7af c9450c5b2bd34677a312ed38623bb505 4085a52ea0694571bc144f3b48cc39da a07a45b8f1654c4f8adabc26d156ba06--4085a52ea0694571bc144f3b48cc39da 4c69ec3a47154eaa909487494672611e 2 d68148568390497695341dbfdb323d77 t = -0.500 4085a52ea0694571bc144f3b48cc39da--d68148568390497695341dbfdb323d77 8963f53a185f42a587c05117bd2a6ac4 d68148568390497695341dbfdb323d77--8963f53a185f42a587c05117bd2a6ac4 511a2b02ffd643709ed6913ff34d64e7 X 8963f53a185f42a587c05117bd2a6ac4--511a2b02ffd643709ed6913ff34d64e7 001bcff694a941728c193d1a74f3c17b t = -0.500 511a2b02ffd643709ed6913ff34d64e7--001bcff694a941728c193d1a74f3c17b dee068b7539d4abf87c1352e85dc2063 X 001bcff694a941728c193d1a74f3c17b--dee068b7539d4abf87c1352e85dc2063 dee068b7539d4abf87c1352e85dc2063--c9450c5b2bd34677a312ed38623bb505 a398b2be8b2943118da17beef2011bb8 e449a9fb1fc140cb939220eca8288419 X 4c69ec3a47154eaa909487494672611e--e449a9fb1fc140cb939220eca8288419 1abb371e3a354c2984dd3623565ddf7a e449a9fb1fc140cb939220eca8288419--1abb371e3a354c2984dd3623565ddf7a 67fa43deddc942729dcde708f783ec33 X 1abb371e3a354c2984dd3623565ddf7a--67fa43deddc942729dcde708f783ec33 20f07395dbaa4564b8cc86e5a1473a27 X 67fa43deddc942729dcde708f783ec33--20f07395dbaa4564b8cc86e5a1473a27 0f22436c4779457c85cc935d3871fd37 20f07395dbaa4564b8cc86e5a1473a27--0f22436c4779457c85cc935d3871fd37 98d78a87fd064f4db61fd8781d6aba92 X 0f22436c4779457c85cc935d3871fd37--98d78a87fd064f4db61fd8781d6aba92 98d78a87fd064f4db61fd8781d6aba92--a398b2be8b2943118da17beef2011bb8 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> cluster_bae765a8a19246c1bcc94280d904edd5 cluster_9d0fa1887725433fa635e45d39cf03aa 9e6e59a8d5804bffa17447b7e061562a 0 f978870533c24f64a74d75374ea0d442 X 9e6e59a8d5804bffa17447b7e061562a--f978870533c24f64a74d75374ea0d442 0597095611bf4d98878ec0cf2e584e0c 1 6d3581be021f48eba95b764a9b1c1b99 HamEvo f978870533c24f64a74d75374ea0d442--6d3581be021f48eba95b764a9b1c1b99 3af77b711b8f49a4b83ca78f2d480b06 X 6d3581be021f48eba95b764a9b1c1b99--3af77b711b8f49a4b83ca78f2d480b06 28beac5c0d154dda985322a8ca36c386 3af77b711b8f49a4b83ca78f2d480b06--28beac5c0d154dda985322a8ca36c386 0debc44fbae24ce99613387a5bc07ee1 HamEvo 28beac5c0d154dda985322a8ca36c386--0debc44fbae24ce99613387a5bc07ee1 93b2b581e92647c695ad17af5eed188b 0debc44fbae24ce99613387a5bc07ee1--93b2b581e92647c695ad17af5eed188b 40d8271367f9476886c7fe28c10a9cf9 93b2b581e92647c695ad17af5eed188b--40d8271367f9476886c7fe28c10a9cf9 11e3140dc3c04e99a086db95cfcfe660 b5fdf204e58743adaba124bb0b09fbc2 0597095611bf4d98878ec0cf2e584e0c--b5fdf204e58743adaba124bb0b09fbc2 2ddfce40dc934c9686dad1e0d473bce9 2 fd6b56f030e4483a9e9324c92a564628 t = -500.000000000000 b5fdf204e58743adaba124bb0b09fbc2--fd6b56f030e4483a9e9324c92a564628 edcfcb40a3534684bdb058f71bf39429 fd6b56f030e4483a9e9324c92a564628--edcfcb40a3534684bdb058f71bf39429 aceb302d7ea04218b717731187355f64 X edcfcb40a3534684bdb058f71bf39429--aceb302d7ea04218b717731187355f64 5b8a19ad39e44fa9828a778a34c2a13e t = -500.000000000000 aceb302d7ea04218b717731187355f64--5b8a19ad39e44fa9828a778a34c2a13e b07cc07c314f46caaac9ba571ba4369f X 5b8a19ad39e44fa9828a778a34c2a13e--b07cc07c314f46caaac9ba571ba4369f b07cc07c314f46caaac9ba571ba4369f--11e3140dc3c04e99a086db95cfcfe660 d2cd9e5faf604a6093c93ceae4a62a9c 5d735426b2b545b881b883f325a34558 X 2ddfce40dc934c9686dad1e0d473bce9--5d735426b2b545b881b883f325a34558 83368752d35c477bae9d1e1279f85e05 5d735426b2b545b881b883f325a34558--83368752d35c477bae9d1e1279f85e05 6e780bcb6b914532badb1a097c68cc22 X 83368752d35c477bae9d1e1279f85e05--6e780bcb6b914532badb1a097c68cc22 c6da4170fca04d0fb7597603d4773101 X 6e780bcb6b914532badb1a097c68cc22--c6da4170fca04d0fb7597603d4773101 2fb2b25aa5c44f5d92a04263597a834d c6da4170fca04d0fb7597603d4773101--2fb2b25aa5c44f5d92a04263597a834d 841bec0602cd48ac93cc0b6251ff14be X 2fb2b25aa5c44f5d92a04263597a834d--841bec0602cd48ac93cc0b6251ff14be 841bec0602cd48ac93cc0b6251ff14be--d2cd9e5faf604a6093c93ceae4a62a9c <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7080-0.0207j,  0.0395+0.3061j,  0.0039-0.0540j,  0.6220-0.1151j]])\nsample = Counter({'00': 27, '11': 18, '01': 5})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-10-16T14:58:02.918164 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-10-16T14:58:02.972589 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 26, '01': 18, '11': 6})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-10-16T14:58:03.226054 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-10-16T14:58:03.296648 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system. A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on. Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations such as single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks. Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks. Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time). Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time). Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian</p> <pre><code>H = \u2211\u1d62(h\u03a9/2 sin(\u03c6)*X\u1d62 - cos(\u03c6)*Y\u1d62 - h\u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits. In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interation</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially. On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially. On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically. On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically. On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks. Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially. Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed). Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally. Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.5034+0.1645j, -0.2575-0.4773j, -0.1863-0.2398j, -0.5771+0.0125j],\n[ 0.0301-0.4791j,  0.5561+0.0912j, -0.5891-0.2234j, -0.1547-0.1766j],\n[-0.1238-0.5348j, -0.3862-0.0394j,  0.2656+0.1068j, -0.1997-0.6528j],\n[-0.3733-0.2200j, -0.1777-0.4539j,  0.0268-0.6544j,  0.3337+0.1853j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"chebyshev\")\nreturn tag(fm, tag=\"ChebyshevFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nif support is None:\nsupport = tuple(range(n_qubits))\nxmax = max(feature_range)\nxmin = min(feature_range)\nx = Parameter(param, trainable=False)\n# The feature map works on the range of 0 to 2**n\nx_rescaled = 2 * np.pi * (x - xmin) / (xmax - xmin)\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = kron(RZ(support[i], x_rescaled * (2**i)) for i in range(n_qubits))\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type='fourier')</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Overrides <code>n_qubits</code>. Puts one rotation gate on every qubit in <code>support</code>.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map.</p> <p> TYPE: <code>Type[Rotation]</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Determines the additional expression the final feature parameter (the addtional term in front of <code>param</code>). <code>\"fourier\": param</code> (nothing is done to <code>param</code>) <code>\"chebyshev\": 2*acos(param)</code>, <code>\"tower\": (i+1)*2*acos(param)</code> (where <code>i</code> is the qubit index).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <p>Example: <pre><code>from qadence import feature_map\nfm = feature_map(3, fm_type=\"fourier\")\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=\"chebyshev\")\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=\"tower\")\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['2*acos(phi)']]\nfm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['4*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['6*acos(phi)']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"phi\",\nop: Type[Rotation] = RX,\nfm_type: str = \"fourier\",\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Overrides `n_qubits`. Puts one rotation gate on every qubit in `support`.\n        param: Parameter of the feature map.\n        op: Rotation operation of the feature map.\n        fm_type: Determines the additional expression the final feature parameter (the addtional\n            term in front of `param`). `\"fourier\": param` (nothing is done to `param`)\n            `\"chebyshev\": 2*acos(param)`, `\"tower\": (i+1)*2*acos(param)` (where `i` is the qubit\n            index).\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map\n    fm = feature_map(3, fm_type=\"fourier\")\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=\"chebyshev\")\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=\"tower\")\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\nfparam = FeatureParameter(param)\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif fm_type == \"fourier\":\nfm = kron(*[op(qubit, fparam) for qubit in support])\nelif fm_type == \"chebyshev\":\nfm = kron(*[op(qubit, 2 * sympy.acos(fparam)) for qubit in support])\nelif fm_type == \"tower\":\nfm = kron(*[op(qubit, (i + 1) * 2 * sympy.acos(fparam)) for i, qubit in enumerate(support)])\nelse:\nraise NotImplementedError(f\"Feature map {fm_type} not implemented\")\nfm.tag = \"FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"fourier\")\nreturn tag(fm, tag=\"FourierFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"tower\")\nreturn tag(fm, tag=\"TowerFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers using step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers\n    using step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian with another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian\n    with another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"\n    Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments (see in the examples).</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments\n    (see in the examples).\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function. The default value of each field can be customize with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x28afb7700&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x28afb7430&gt;, batch_size=1)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>. Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.data_to_model","title":"<code>data_to_model(xs, device='cpu')</code>","text":"<p>Default behavior for single-dispatched function</p> <p>Just return the given data independently on the type</p> PARAMETER  DESCRIPTION <code>xs</code> <p>the input data</p> <p> TYPE: <code>Any</code> </p> <code>device</code> <p>The torch device. Not used in this implementation.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>the <code>xs</code> argument untouched</p> <p> TYPE: <code>Any</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>@singledispatch\ndef data_to_model(xs: Any, device: str = \"cpu\") -&gt; Any:\n\"\"\"Default behavior for single-dispatched function\n    Just return the given data independently on the type\n    Args:\n        xs (Any): the input data\n        device (str, optional): The torch device. Not used in this implementation.\n    Returns:\n        Any: the `xs` argument untouched\n    \"\"\"\nreturn xs\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs, device='cpu')</code>","text":"<p>Default Torch optimize step with closure</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> <code>device</code> <p>The device were computations are executed. Defaults to \"cpu\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\ndevice: str = \"cpu\",\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n        device (str, optional): The device were computations are executed.\n            Defaults to \"cpu\".\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence.constructors import hamiltonian_factory, hea, feature_map\n    from qadence import chain, Parameter, QuantumCircuit, Z\n    from qadence.models import QNN\n    from qadence.ml_tools import train_with_grad, TrainConfig\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n        batch_size=batch_size,\n    )\n    batch_size = 25\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    train_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\nassert loss_fn is not None, \"Provide a valid loss function\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nif isinstance(dataloader, (list, tuple)):\nfrom qadence.ml_tools.data import to_dataloader\nassert len(dataloader) == 2, \"Please provide exactly two torch tensors.\"\nx, y = dataloader\ndataloader = to_dataloader(x=x, y=y, batch_size=config.batch_size)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, dataloader, device=device\n)\nloss = loss.item()\n# single epoch with DictDataloader using a single iteration method\n# DictDataloader returns a single sample of the data\n# with a given batch size decided when the dataloader is defined\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data, device=device)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\n# TODO: make sure to average metrics as well\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, data, device=device\n)\nrunning_loss += loss.item()\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nrunning_loss += loss\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> A block implementing the Hamiltonian evolution operation H where <p>H = exp(-iG, t)</p> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.2374-5.1225e-17j, -0.7288+3.0170e-17j],\n[ 1.1660-4.0583e-17j, -0.5995+2.0868e-17j]])\ntensor([[1.7414-1.2075j, 0.7742-1.1094j],\n[1.3634-0.3266j, 0.4083-0.2874j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation. Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation. Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=np.pi / 2)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names. This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['bde92921-4d5e-4a2c-b8ad-dba36e0327aa', 'b3acc3a8-9ba7-453f-a4eb-a09d9f3ee73c'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code> to include two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters. Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"PARAMETER  DESCRIPTION <code>name</code> <p>When given a string only, the class constructs a trainable Parameter with a a randomly initialized value.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> </p> <code>**assumptions</code> <p>are passed on to the parent class <code>sympy.Symbol</code>. Two new assumption kwargs are supported by this constructor: <code>trainable: bool</code>, and <code>value: TNumber</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>from qadence import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.854665659675864\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = torch.rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> <code>values</code> <p>values dict which contains values for the Parameters, if empty, Parameter.value will be used.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>as_torch</code> <p>Whether to retrieve a torch-differentiable expression result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.013496193764961003\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn torch.Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: torch.tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[expr], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>A QuantumCircuit instance is completely abstract and it needs to be passed to a quantum backend in order to be executed.</p> PARAMETER  DESCRIPTION <code>support</code> <p><code>Register</code> or number of qubits. If an integer is provided, a register is constructed with <code>Register.all_to_all(x)</code></p> <p> TYPE: <code>int | Register</code> </p> <code>*blocks</code> <p>(Possibly multiple) blocks to construct the circuit from.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag</p> <p>This function recurservily explores all composite blocks to find all the occurrences of a certain tag in the blocks</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag\n    This function recurservily explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates (needed for e.g. analog computing). The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates (needed for e.g. analog\n    computing). The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ef7ba18e-545c-46c5-88fb-612d41cb510f', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9649102256983412'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0dbbb7a9-ed4c-498f-97e5-917f8a267977', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.855299175233669'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5376acb0-d469-48e3-b0ff-f57e834965d4', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.4821242625372467'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('97a408b3-658c-4bcc-b025-c1f32223f5eb', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.7216139771883192'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2cb852c7-a8b4-4b93-90ea-2ebb7dedd308', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5520005343296959'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4e2f85a2-89da-424a-9ced-0b2db17bc026', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.5128236248712018'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5958c8e8-ef9b-4238-924b-48cfd4fabdc3', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.7262773469971591'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('93ef8586-3369-4797-85d3-f819fcad26bf', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9592730319839947'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('db630a40-9c16-45fd-954c-3c4886bcd013', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.29853362350562773'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a3627a8f-c92c-4081-a45d-500c789d48f4', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.8358036266838368'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('15bdcafb-2ee7-4a86-89e6-c4f911738752', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5395678859265043'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('edc7edea-ccc2-446d-9335-8e54e9be41f5', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>11100100\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.backend import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[0.3686-0.0605j, 0.2386+0.1186j, 0.0478+0.7804j, 0.0436-0.4199j]])\ntensor([[ 0.8950+0.j, -0.3722+0.j, -0.2270+0.j,  0.0944+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.backend import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = _run_state(_abstract_random_state(n_qubits, batch_size), backend)  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation. Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation. Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\nkronblocks = block.blocks  # type: ignore[attr-defined]\nn_blocks = len(kronblocks)\nchains = []\nfor qb_idx in range(block.n_qubits):\nprim_gates = []\nfor kron_idx in range(n_blocks):\nprim_gates.append(kronblocks[kron_idx][qb_idx])  # type: ignore[index]\nchains.append(chain(*prim_gates))\ntry:\nreturn kron(*chains)\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.flatten","title":"<code>flatten(block, types=[ChainBlock, KronBlock, AddBlock])</code>","text":"<p>Flattens the given types of <code>CompositeBlock</code>s if possible.</p> <p>Example: <pre><code>from qadence import chain, kron, X\nfrom qadence.transpile import flatten\nfrom qadence.blocks import ChainBlock, KronBlock, AddBlock\nx = chain(chain(chain(X(0))), kron(kron(X(0))))\n# flatten only `ChainBlock`s\nassert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n# flatten `ChainBlock`s and `KronBlock`s\nassert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n# flatten `AddBlock`s (does nothing in this case)\nassert flatten(x, [AddBlock]) == x\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def flatten(block: AbstractBlock, types: list = [ChainBlock, KronBlock, AddBlock]) -&gt; AbstractBlock:\n\"\"\"Flattens the given types of `CompositeBlock`s if possible.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import chain, kron, X\n    from qadence.transpile import flatten\n    from qadence.blocks import ChainBlock, KronBlock, AddBlock\n    x = chain(chain(chain(X(0))), kron(kron(X(0))))\n    # flatten only `ChainBlock`s\n    assert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n    # flatten `ChainBlock`s and `KronBlock`s\n    assert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n    # flatten `AddBlock`s (does nothing in this case)\n    assert flatten(x, [AddBlock]) == x\n    ```\n    \"\"\"\nif isinstance(block, CompositeBlock):\ndef fn(b: AbstractBlock, T: Type) -&gt; AbstractBlock:\nreturn _construct(type(block), tuple(_flat_blocks(b, T)))\nreturn reduce(fn, types, block)  # type: ignore[arg-type]\nelif isinstance(block, ScaleBlock):\nblk = deepcopy(block)\nblk.block = flatten(block.block, types=types)\nreturn blk\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks, move the scale all the way down into the leaves of the block tree.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"When given a scaled CompositeBlock consisting of several PrimitiveBlocks,\n    move the scale all the way down into the leaves of the block tree.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks and reassigning qubit locations approriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks and reassigning\n    qubit locations approriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.emulate.add_interaction","title":"<code>add_interaction(x, *args, interaction=Interaction.NN, spacing=1.0)</code>","text":"<p>Turns blocks or circuits into (a chain of) <code>HamEvo</code> blocks including a chosen interaction term.</p> <p>This is a <code>@singledipatch</code>ed function which can be called in three ways:</p> <ul> <li>With a <code>QuantumCircuit</code> which contains all necessary information: <code>add_interaction(circuit)</code></li> <li>With a <code>Register</code> and an <code>AbstractBlock</code>: <code>add_interaction(reg, block)</code></li> <li>With an <code>AbstractBlock</code> only: <code>add_interaction(block)</code></li> </ul> <p>See the section about analog blocks for detailed information about how which types of blocks are translated.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit or block to be emulated. See the examples on which argument combinations are accepted.</p> <p> TYPE: <code>Register | QuantumCircuit | AbstractBlock</code> </p> <code>interaction</code> <p>Type of interaction that is added. Can also be a function that accepts a register and a list of edges that define which qubits interact (see the examples).</p> <p> TYPE: <code>Interaction | Callable</code> DEFAULT: <code>NN</code> </p> <code>spacing</code> <p>All qubit coordinates are multiplied by <code>spacing</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import QuantumCircuit, AnalogRX, add_interaction\nc = QuantumCircuit(2, AnalogRX(2.0))\ne = add_interaction(c)\n</code></pre> <pre><code>[mul: 0.0] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 AddBlock(0,1)\n\u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u251c\u2500\u2500 [mul: 1.571] \u2502       \u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u2502       \u251c\u2500\u2500 AddBlock(0)\n\u2502       \u2502       \u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502       \u2502   \u2502   \u2514\u2500\u2500 X(0)\n\u2502       \u2502       \u2502   \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502       \u2502       \u2514\u2500\u2500 Y(0)\n\u2502       \u2502       \u2514\u2500\u2500 AddBlock(1)\n\u2502       \u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502           \u2502   \u2514\u2500\u2500 X(1)\n\u2502       \u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502               \u2514\u2500\u2500 Y(1)\n\u2502       \u2514\u2500\u2500 [mul: 0.0] \u2502           \u2514\u2500\u2500 AddBlock(0,1)\n\u2502               \u251c\u2500\u2500 N(0)\n\u2502               \u2514\u2500\u2500 N(1)\n\u2514\u2500\u2500 AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 865723.020] \u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 N(0)\n\u2514\u2500\u2500 N(1)\n</code></pre>  You can also use <code>add_interaction</code> directly on a block, but you have to provide either the <code>Register</code> or define a non-global qubit support. <pre><code>from qadence import AnalogRX, Register, add_interaction\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b)\n# or provide only the block with local qubit support\n# in this case the register is created via `Register(b.n_qubits)`\ne = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\nprint(e.generator)\n</code></pre> <pre><code>[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n</code></pre>  You can specify a custom <code>interaction</code> function which has to accept a <code>Register</code> and a list of <code>edges: list[tuple[int, int]]</code>: <pre><code>from qadence import AnalogRX, Register, add_interaction\nfrom qadence.transpile.emulate import ising_interaction\ndef int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n# do either something completely custom\n# ...\n# or e.g. change the default kwargs to `ising_interaction`\nreturn ising_interaction(r, pairs, rydberg_level=70)\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b, interaction=int_fn)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/emulate.py</code> <pre><code>@singledispatch\ndef add_interaction(\nx: Register | QuantumCircuit | AbstractBlock,\n*args: Any,\ninteraction: Interaction | Callable = Interaction.NN,\nspacing: float = 1.0,\n) -&gt; QuantumCircuit | AbstractBlock:\n\"\"\"Turns blocks or circuits into (a chain of) `HamEvo` blocks including a\n    chosen interaction term.\n    This is a `@singledipatch`ed function which can be called in three ways:\n    * With a `QuantumCircuit` which contains all necessary information: `add_interaction(circuit)`\n    * With a `Register` and an `AbstractBlock`: `add_interaction(reg, block)`\n    * With an `AbstractBlock` only: `add_interaction(block)`\n    See the section about [analog blocks](/digital_analog_qc/analog-basics.md) for\n    detailed information about how which types of blocks are translated.\n    Arguments:\n        x: Circuit or block to be emulated. See the examples on which argument\n            combinations are accepted.\n        interaction: Type of interaction that is added. Can also be a function that accepts a\n            register and a list of edges that define which qubits interact (see the examples).\n        spacing: All qubit coordinates are multiplied by `spacing`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import QuantumCircuit, AnalogRX, add_interaction\n    c = QuantumCircuit(2, AnalogRX(2.0))\n    e = add_interaction(c)\n    print(str(e.block.generator)) # markdown-exec: hide\n    ```\n    You can also use `add_interaction` directly on a block, but you have to provide either\n    the `Register` or define a non-global qubit support.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b)\n    print(e.generator) # markdown-exec: hide\n    # or provide only the block with local qubit support\n    # in this case the register is created via `Register(b.n_qubits)`\n    e = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\n    print(e.generator)\n    ```\n    You can specify a custom `interaction` function which has to accept a `Register` and a list\n    of `edges: list[tuple[int, int]]`:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    from qadence.transpile.emulate import ising_interaction\n    def int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n        # do either something completely custom\n        # ...\n        # or e.g. change the default kwargs to `ising_interaction`\n        return ising_interaction(r, pairs, rydberg_level=70)\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b, interaction=int_fn)\n    ```\n    \"\"\"\nraise ValueError(f\"`add_interaction` is not implemented for {type(x)}\")\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, torch.Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[torch.Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, torch.Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in - <code>add_interaction</code>. - <code>hamiltonian_factory</code>.</p>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML) [^1] in particular are the target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\nfp = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(RX(i, 2 * acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(feature_map, values=inputs)\nprint(samples)\n</code></pre>   [Counter({'1111': 75, '1011': 9, '0111': 6, '1101': 4, '1110': 4, '0110': 2}), Counter({'1111': 24, '1110': 16, '1101': 9, '0111': 8, '1001': 7, '0011': 6, '0110': 6, '0100': 5, '1010': 5, '1011': 5, '0101': 3, '0010': 2, '1100': 2, '0000': 1, '0001': 1}), Counter({'0000': 28, '1000': 14, '0001': 12, '0010': 6, '0100': 6, '0101': 6, '1100': 6, '0011': 5, '0110': 4, '1001': 4, '1011': 2, '1101': 2, '1110': 2, '0111': 1, '1010': 1, '1111': 1})]    <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansaztz and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\nprint(f\"Quantum model output: {out}\")\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre>   Quantum model output: tensor([[0.1904],         [0.3953],         [0.2193],         [0.0431],         [0.2558],         [0.3160],         [0.0408],         [0.4406],         [0.4627],         [0.4138]], grad_fn=) First-order derivative w.r.t. the feature parameter: tensor([ 0.5730,  0.6237,  0.6140, -1.0375,  0.6560,  0.6914, -0.9687, -0.5948,         -0.1979, -0.8826], grad_fn=)    <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n</code></pre>   First-order derivative w.r.t. the feature parameter: tensor([ 0.5730,  0.6237,  0.6140, -1.0375,  0.6560,  0.6914, -0.9687, -0.5948,         -0.1979, -0.8826], grad_fn=)    <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-10-16T14:58:04.912532 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> cluster_bef9e40365174f54baccff003149a22e mixing cluster_a92a6a35fe5c42a89bf5d5fe2381a56b cost cluster_3c04161644b4489ba7925558b3307353 cost cluster_3b28b985bb9e4fc180ed0db082fa91ee mixing eb214e55b9664ee8b5c40033079f61da 0 ef2ee73ee7074c81950c4b2051003c65 eb214e55b9664ee8b5c40033079f61da--ef2ee73ee7074c81950c4b2051003c65 3f6ca73e023947b19d643ad7a7e0ec39 1 ef1747998e2b4af38f90ed33463a24bd ef2ee73ee7074c81950c4b2051003c65--ef1747998e2b4af38f90ed33463a24bd bf56fe52cf2141bc98ffe30f4337aaee ef1747998e2b4af38f90ed33463a24bd--bf56fe52cf2141bc98ffe30f4337aaee 5f85244371174472b40ced9ec7d48e79 bf56fe52cf2141bc98ffe30f4337aaee--5f85244371174472b40ced9ec7d48e79 dc1cb5db5f604828bfb504c6ed80d777 5f85244371174472b40ced9ec7d48e79--dc1cb5db5f604828bfb504c6ed80d777 e803defaff234ec3b03421fb64211d88 dc1cb5db5f604828bfb504c6ed80d777--e803defaff234ec3b03421fb64211d88 db844160f5a643c4a8e31d03a7b393de e803defaff234ec3b03421fb64211d88--db844160f5a643c4a8e31d03a7b393de f9847c61014a4a20a60649c2526b9d50 db844160f5a643c4a8e31d03a7b393de--f9847c61014a4a20a60649c2526b9d50 33e50d314d37423788b72843df59ee80 f9847c61014a4a20a60649c2526b9d50--33e50d314d37423788b72843df59ee80 b29dd573fdd04aaaa8d5a7e7e660f12c 33e50d314d37423788b72843df59ee80--b29dd573fdd04aaaa8d5a7e7e660f12c 6311932b28d14b17b091de3c7dfea02e b29dd573fdd04aaaa8d5a7e7e660f12c--6311932b28d14b17b091de3c7dfea02e 3a36714651a445fa910065b9d1c49202 6311932b28d14b17b091de3c7dfea02e--3a36714651a445fa910065b9d1c49202 7afdb81ce9df4e40ac60f216977ccbd0 3a36714651a445fa910065b9d1c49202--7afdb81ce9df4e40ac60f216977ccbd0 fafe2a0d7dd74853af191c8d34353726 7afdb81ce9df4e40ac60f216977ccbd0--fafe2a0d7dd74853af191c8d34353726 dcdb98ddc39740289184e1485068856d fafe2a0d7dd74853af191c8d34353726--dcdb98ddc39740289184e1485068856d 5b7db3f1a3dd49c6b1d82ccd6cf4fd0a dcdb98ddc39740289184e1485068856d--5b7db3f1a3dd49c6b1d82ccd6cf4fd0a 6046e7d987fe46a6b0718f4114cedc78 5b7db3f1a3dd49c6b1d82ccd6cf4fd0a--6046e7d987fe46a6b0718f4114cedc78 9f417eab42fc4cbc85fbead1fd315024 6046e7d987fe46a6b0718f4114cedc78--9f417eab42fc4cbc85fbead1fd315024 e1741ef1d0d64c4cae5a84e06a72877f 9f417eab42fc4cbc85fbead1fd315024--e1741ef1d0d64c4cae5a84e06a72877f a1fdf73f6185439081fa36512d7fc774 e1741ef1d0d64c4cae5a84e06a72877f--a1fdf73f6185439081fa36512d7fc774 e5d87e8632cc4c098f3748499d46c7d8 a1fdf73f6185439081fa36512d7fc774--e5d87e8632cc4c098f3748499d46c7d8 e8d273484b68404ea9f1ac503b9902fa e5d87e8632cc4c098f3748499d46c7d8--e8d273484b68404ea9f1ac503b9902fa 1bd8fb517f6f4085a7dc9699b8521d9d e8d273484b68404ea9f1ac503b9902fa--1bd8fb517f6f4085a7dc9699b8521d9d a7524c2a4cca4018918d5347888a0304 1bd8fb517f6f4085a7dc9699b8521d9d--a7524c2a4cca4018918d5347888a0304 24c5c4fc4aa346b38dd537b8d841748d a7524c2a4cca4018918d5347888a0304--24c5c4fc4aa346b38dd537b8d841748d 1cde416c024b492c9ad34051400c8cd3 24c5c4fc4aa346b38dd537b8d841748d--1cde416c024b492c9ad34051400c8cd3 47a44f4770474e458928f9d9a02f5df6 1cde416c024b492c9ad34051400c8cd3--47a44f4770474e458928f9d9a02f5df6 32b24b2efa4e4da88db2fb093a6e4f29 47a44f4770474e458928f9d9a02f5df6--32b24b2efa4e4da88db2fb093a6e4f29 0b24344f800d41d3890e6bebf092ddc9 32b24b2efa4e4da88db2fb093a6e4f29--0b24344f800d41d3890e6bebf092ddc9 0262f3d4c5ee4f019189b83f90de81e7 0b24344f800d41d3890e6bebf092ddc9--0262f3d4c5ee4f019189b83f90de81e7 a692749e5c8e4e9ca71f60eaa3f1c116 0262f3d4c5ee4f019189b83f90de81e7--a692749e5c8e4e9ca71f60eaa3f1c116 2223f99c26434d02976707cd3c06c4de a692749e5c8e4e9ca71f60eaa3f1c116--2223f99c26434d02976707cd3c06c4de 78bafa0a66644a6cad000797ba15da22 2223f99c26434d02976707cd3c06c4de--78bafa0a66644a6cad000797ba15da22 9f9248bd8e0c433580685f6d946268f0 78bafa0a66644a6cad000797ba15da22--9f9248bd8e0c433580685f6d946268f0 2d7490656045402e8ca755cbd04da8d8 9f9248bd8e0c433580685f6d946268f0--2d7490656045402e8ca755cbd04da8d8 7cb80f4b647242198ff647b5f819e126 2d7490656045402e8ca755cbd04da8d8--7cb80f4b647242198ff647b5f819e126 3d7009b261384791bee8a689f08e4e52 7cb80f4b647242198ff647b5f819e126--3d7009b261384791bee8a689f08e4e52 5700525bd2384215930f0039852b44db 3d7009b261384791bee8a689f08e4e52--5700525bd2384215930f0039852b44db 3d66f248dc3a40879dd936ec9de44535 5700525bd2384215930f0039852b44db--3d66f248dc3a40879dd936ec9de44535 f3a5154c547e43f0a9fa7f29597048e8 3d66f248dc3a40879dd936ec9de44535--f3a5154c547e43f0a9fa7f29597048e8 20f572d593bd4c13be142dcaea3433ea f3a5154c547e43f0a9fa7f29597048e8--20f572d593bd4c13be142dcaea3433ea c058d21222204bd688689a8ec9f41e30 20f572d593bd4c13be142dcaea3433ea--c058d21222204bd688689a8ec9f41e30 bc144b21438d42c6b3c00590239ad617 c058d21222204bd688689a8ec9f41e30--bc144b21438d42c6b3c00590239ad617 09e33d31b57d4b548cf53f87224ccd65 bc144b21438d42c6b3c00590239ad617--09e33d31b57d4b548cf53f87224ccd65 ff2c13ae950d4abcabba245293ee6e2e 09e33d31b57d4b548cf53f87224ccd65--ff2c13ae950d4abcabba245293ee6e2e 4d095e1147964163a6cbad353cd68cc3 ff2c13ae950d4abcabba245293ee6e2e--4d095e1147964163a6cbad353cd68cc3 debf4512a6294ddd962c180d9989e4f0 4d095e1147964163a6cbad353cd68cc3--debf4512a6294ddd962c180d9989e4f0 f8893d14f90b45839c7e4941b82f616c debf4512a6294ddd962c180d9989e4f0--f8893d14f90b45839c7e4941b82f616c a6c88a30228c4f9e839d050d1558c322 f8893d14f90b45839c7e4941b82f616c--a6c88a30228c4f9e839d050d1558c322 cfe660d0017845e392d14b4cb659c8bc a6c88a30228c4f9e839d050d1558c322--cfe660d0017845e392d14b4cb659c8bc 3bb4fe8e9de74d41bef30997b2a7c0ab cfe660d0017845e392d14b4cb659c8bc--3bb4fe8e9de74d41bef30997b2a7c0ab 02bde99bbb774c0ea955125f42442bf5 3bb4fe8e9de74d41bef30997b2a7c0ab--02bde99bbb774c0ea955125f42442bf5 fc9c61146ccc44709dd8f80df304ec92 02bde99bbb774c0ea955125f42442bf5--fc9c61146ccc44709dd8f80df304ec92 2d5143adae6c469eab7a5b8409146015 fc9c61146ccc44709dd8f80df304ec92--2d5143adae6c469eab7a5b8409146015 fb69af8dc7924c328ffc45331760780d 2d5143adae6c469eab7a5b8409146015--fb69af8dc7924c328ffc45331760780d 77d1c359f7f740a7952ce06880043c41 fb69af8dc7924c328ffc45331760780d--77d1c359f7f740a7952ce06880043c41 934040d56ac14b9a8acceb12c438508d 77d1c359f7f740a7952ce06880043c41--934040d56ac14b9a8acceb12c438508d 76141f6136b149b08ec21632617f6b44 934040d56ac14b9a8acceb12c438508d--76141f6136b149b08ec21632617f6b44 2d2ac1663f444e80a7cbeb1863a5ed51 76141f6136b149b08ec21632617f6b44--2d2ac1663f444e80a7cbeb1863a5ed51 bbbf69822542405290f1934f3e4a2243 2d2ac1663f444e80a7cbeb1863a5ed51--bbbf69822542405290f1934f3e4a2243 4c1250440b234b0ebfa51addc6f0dea6 bbbf69822542405290f1934f3e4a2243--4c1250440b234b0ebfa51addc6f0dea6 d8a20418c17e4757a8b860f9af81238d 4c1250440b234b0ebfa51addc6f0dea6--d8a20418c17e4757a8b860f9af81238d d62997d3fca04ef6acde54e6cfd40863 d8a20418c17e4757a8b860f9af81238d--d62997d3fca04ef6acde54e6cfd40863 60b3503cddce401ca744145a1519c9f7 d62997d3fca04ef6acde54e6cfd40863--60b3503cddce401ca744145a1519c9f7 a454b3e4df6246b1b4e3f0ee941eb6be 60b3503cddce401ca744145a1519c9f7--a454b3e4df6246b1b4e3f0ee941eb6be 27aa7d8ce7234a12a2a74dff13541c16 a454b3e4df6246b1b4e3f0ee941eb6be--27aa7d8ce7234a12a2a74dff13541c16 61f8c6fbc702427a97a0333b768b9516 27aa7d8ce7234a12a2a74dff13541c16--61f8c6fbc702427a97a0333b768b9516 4c67c6fb4b6c478ba5812455c187ac81 61f8c6fbc702427a97a0333b768b9516--4c67c6fb4b6c478ba5812455c187ac81 3004aa7438a14156a24f9a4d0d10095f 4c67c6fb4b6c478ba5812455c187ac81--3004aa7438a14156a24f9a4d0d10095f 0ce3234bd2dc49c3aea3bd44910526c8 3004aa7438a14156a24f9a4d0d10095f--0ce3234bd2dc49c3aea3bd44910526c8 aefca9df901949919480f81ab7546f68 0ce3234bd2dc49c3aea3bd44910526c8--aefca9df901949919480f81ab7546f68 e06f6e62999646148790d9fc8bb6d556 aefca9df901949919480f81ab7546f68--e06f6e62999646148790d9fc8bb6d556 ba2e5007fb9e4b37afbc917260ca9556 e06f6e62999646148790d9fc8bb6d556--ba2e5007fb9e4b37afbc917260ca9556 a034676a393d48ba8b1239fcac1b8306 ba2e5007fb9e4b37afbc917260ca9556--a034676a393d48ba8b1239fcac1b8306 1072993ae7cb4a1192fc83ac115f38d7 a034676a393d48ba8b1239fcac1b8306--1072993ae7cb4a1192fc83ac115f38d7 a932fb1aeba9491fa8f53ba3c736339d 1072993ae7cb4a1192fc83ac115f38d7--a932fb1aeba9491fa8f53ba3c736339d bb6345b6735941b3b952c3c8970ed041 a932fb1aeba9491fa8f53ba3c736339d--bb6345b6735941b3b952c3c8970ed041 a13d5740724e4c9c83a9543aaf592098 bb6345b6735941b3b952c3c8970ed041--a13d5740724e4c9c83a9543aaf592098 b8450f3eeeb041a1ba2af8f41d60f40e RX(b00) a13d5740724e4c9c83a9543aaf592098--b8450f3eeeb041a1ba2af8f41d60f40e 319524f011694191aa06aeda3521a2cc b8450f3eeeb041a1ba2af8f41d60f40e--319524f011694191aa06aeda3521a2cc 32cce15d92a043be8538052f293c1956 319524f011694191aa06aeda3521a2cc--32cce15d92a043be8538052f293c1956 fcaf2ff23a034220bc2f9ddc18bfde05 32cce15d92a043be8538052f293c1956--fcaf2ff23a034220bc2f9ddc18bfde05 34bb555fe2b24c96a588cca3afef191f fcaf2ff23a034220bc2f9ddc18bfde05--34bb555fe2b24c96a588cca3afef191f b7e75b007170414899070d580916eb07 34bb555fe2b24c96a588cca3afef191f--b7e75b007170414899070d580916eb07 024cc94a843a43429b516e40ad3e62e4 b7e75b007170414899070d580916eb07--024cc94a843a43429b516e40ad3e62e4 9b622332d27b4058b30905bf21a5d277 024cc94a843a43429b516e40ad3e62e4--9b622332d27b4058b30905bf21a5d277 d199775e89b94dd98aa42ce274c0ebca 9b622332d27b4058b30905bf21a5d277--d199775e89b94dd98aa42ce274c0ebca ee20360985ca4659a8debf1c2bf3542c d199775e89b94dd98aa42ce274c0ebca--ee20360985ca4659a8debf1c2bf3542c 8c3db688c6f34bb980ce8b34268e955c ee20360985ca4659a8debf1c2bf3542c--8c3db688c6f34bb980ce8b34268e955c 70fef34d428a42d88ff8b6175d959df8 8c3db688c6f34bb980ce8b34268e955c--70fef34d428a42d88ff8b6175d959df8 acfff5ee41fd4729a5f45d9f83b11886 70fef34d428a42d88ff8b6175d959df8--acfff5ee41fd4729a5f45d9f83b11886 1f1ffa03892e431b8d75de42c6d5965f acfff5ee41fd4729a5f45d9f83b11886--1f1ffa03892e431b8d75de42c6d5965f 4493d8db6fba4e8e9a98dc4f3508f991 1f1ffa03892e431b8d75de42c6d5965f--4493d8db6fba4e8e9a98dc4f3508f991 21efec06430b497daa58fb5d707423b9 4493d8db6fba4e8e9a98dc4f3508f991--21efec06430b497daa58fb5d707423b9 13e206cdf328429a8835a0dc50596bf9 21efec06430b497daa58fb5d707423b9--13e206cdf328429a8835a0dc50596bf9 1111901364484892a875712761589bed 13e206cdf328429a8835a0dc50596bf9--1111901364484892a875712761589bed f7fabac598924a8bb1d9e82f459d9f0c 1111901364484892a875712761589bed--f7fabac598924a8bb1d9e82f459d9f0c 5db14b0248664d6184156924efbea068 f7fabac598924a8bb1d9e82f459d9f0c--5db14b0248664d6184156924efbea068 de2be3b2beae41e1ba429d15cc7bcc3d 5db14b0248664d6184156924efbea068--de2be3b2beae41e1ba429d15cc7bcc3d 816a09e6b8224c50b16d34e40b55311d de2be3b2beae41e1ba429d15cc7bcc3d--816a09e6b8224c50b16d34e40b55311d 47fd1046dae84e338c93117b864ec0c8 816a09e6b8224c50b16d34e40b55311d--47fd1046dae84e338c93117b864ec0c8 8355a6a2c6cc4573a4cfe2ec9924ea04 47fd1046dae84e338c93117b864ec0c8--8355a6a2c6cc4573a4cfe2ec9924ea04 1c7ea033b60e45969b73f46f881cd55a 8355a6a2c6cc4573a4cfe2ec9924ea04--1c7ea033b60e45969b73f46f881cd55a 75265f5f3a4940298bdf35d0673d6452 1c7ea033b60e45969b73f46f881cd55a--75265f5f3a4940298bdf35d0673d6452 4cae2b89428c48dc8ed75ff1fa1199a9 75265f5f3a4940298bdf35d0673d6452--4cae2b89428c48dc8ed75ff1fa1199a9 ef042ec32b304f128ad8bc3dba494835 4cae2b89428c48dc8ed75ff1fa1199a9--ef042ec32b304f128ad8bc3dba494835 3d371d64c80e424baf1726eb4621395d ef042ec32b304f128ad8bc3dba494835--3d371d64c80e424baf1726eb4621395d 740e47346e324988839d93c40563c36c 3d371d64c80e424baf1726eb4621395d--740e47346e324988839d93c40563c36c dbaf2a07cff7440b940ee28a7bee8237 740e47346e324988839d93c40563c36c--dbaf2a07cff7440b940ee28a7bee8237 34b75aeb8eeb4d3cb2058b4d1d88d75f dbaf2a07cff7440b940ee28a7bee8237--34b75aeb8eeb4d3cb2058b4d1d88d75f 27604eabcdb642329c95c44c9bf9be82 34b75aeb8eeb4d3cb2058b4d1d88d75f--27604eabcdb642329c95c44c9bf9be82 e81b9b46b1a74de79b331d4c21178638 27604eabcdb642329c95c44c9bf9be82--e81b9b46b1a74de79b331d4c21178638 2c40472af9db4296ad4f52eeb31bf331 e81b9b46b1a74de79b331d4c21178638--2c40472af9db4296ad4f52eeb31bf331 8983f13da27247a5b6e3c9c4a0151255 2c40472af9db4296ad4f52eeb31bf331--8983f13da27247a5b6e3c9c4a0151255 c6c48826af4b4aeea094b6e8f44b5318 8983f13da27247a5b6e3c9c4a0151255--c6c48826af4b4aeea094b6e8f44b5318 41d394d0a2de4496a494a62a3f742605 c6c48826af4b4aeea094b6e8f44b5318--41d394d0a2de4496a494a62a3f742605 0cce11a4b68846e78c03463c5b8437a1 41d394d0a2de4496a494a62a3f742605--0cce11a4b68846e78c03463c5b8437a1 8e6469b2057d45429f2317caf0cd401a 0cce11a4b68846e78c03463c5b8437a1--8e6469b2057d45429f2317caf0cd401a 734c61a395f84a8eb9839447a7478d2c 8e6469b2057d45429f2317caf0cd401a--734c61a395f84a8eb9839447a7478d2c 3cb53a956c954053ae32089b33451c93 734c61a395f84a8eb9839447a7478d2c--3cb53a956c954053ae32089b33451c93 cb0d0e0ea72f4f38a72f6a087aa7be6a 3cb53a956c954053ae32089b33451c93--cb0d0e0ea72f4f38a72f6a087aa7be6a 73578e2e1c84447fb9d0297a76662682 cb0d0e0ea72f4f38a72f6a087aa7be6a--73578e2e1c84447fb9d0297a76662682 ffe4c607eb4d4bf4853fd9c9a5416c6a 73578e2e1c84447fb9d0297a76662682--ffe4c607eb4d4bf4853fd9c9a5416c6a 7a5e5038c95c4009b32d677b8a03f94a ffe4c607eb4d4bf4853fd9c9a5416c6a--7a5e5038c95c4009b32d677b8a03f94a 256a1954f2584f2f9b3e2020f148418b 7a5e5038c95c4009b32d677b8a03f94a--256a1954f2584f2f9b3e2020f148418b 9e6e923b5c204a6794a0c30e40740ed8 256a1954f2584f2f9b3e2020f148418b--9e6e923b5c204a6794a0c30e40740ed8 47c92fb62fb44b10951aac7c501306a6 9e6e923b5c204a6794a0c30e40740ed8--47c92fb62fb44b10951aac7c501306a6 513681ba05664c10ad68d924828f61b6 47c92fb62fb44b10951aac7c501306a6--513681ba05664c10ad68d924828f61b6 841caa5bb13048829ddddbfd9b3ef15f 513681ba05664c10ad68d924828f61b6--841caa5bb13048829ddddbfd9b3ef15f 9a0921b2446949fc9b21178be6aaffba 841caa5bb13048829ddddbfd9b3ef15f--9a0921b2446949fc9b21178be6aaffba 5280b830c6c6478c993833212e8e7eea 9a0921b2446949fc9b21178be6aaffba--5280b830c6c6478c993833212e8e7eea fdd17a29c43d4ca9aa6b5653f41c1dfd 5280b830c6c6478c993833212e8e7eea--fdd17a29c43d4ca9aa6b5653f41c1dfd 8aef66615098477784199d0307ba0ce9 fdd17a29c43d4ca9aa6b5653f41c1dfd--8aef66615098477784199d0307ba0ce9 90b30428e77241f2b082eeded0d422f2 8aef66615098477784199d0307ba0ce9--90b30428e77241f2b082eeded0d422f2 d4a3acfe4ea04a429b101553f7af588d 90b30428e77241f2b082eeded0d422f2--d4a3acfe4ea04a429b101553f7af588d f359391f2d504bc4b8e8153d8c00fb5c d4a3acfe4ea04a429b101553f7af588d--f359391f2d504bc4b8e8153d8c00fb5c e06ddf7d927a4378a8d92cde910c901c f359391f2d504bc4b8e8153d8c00fb5c--e06ddf7d927a4378a8d92cde910c901c 4ba54ca0aaab47d98e682dc733d54c2d e06ddf7d927a4378a8d92cde910c901c--4ba54ca0aaab47d98e682dc733d54c2d 79e7547389fe4f969b913b26142e7109 4ba54ca0aaab47d98e682dc733d54c2d--79e7547389fe4f969b913b26142e7109 badb5efaf59044d18db2a15885dc8d67 79e7547389fe4f969b913b26142e7109--badb5efaf59044d18db2a15885dc8d67 d63f3a7d33d2402fa7f19eaa78df3ea6 badb5efaf59044d18db2a15885dc8d67--d63f3a7d33d2402fa7f19eaa78df3ea6 1b67d6ff9e1b4e78baed56b384f4c66f d63f3a7d33d2402fa7f19eaa78df3ea6--1b67d6ff9e1b4e78baed56b384f4c66f ee5575c97abb416f9b964ed3a0d051fa 1b67d6ff9e1b4e78baed56b384f4c66f--ee5575c97abb416f9b964ed3a0d051fa 5f87e8f654834481b1dc5bd936a67b12 ee5575c97abb416f9b964ed3a0d051fa--5f87e8f654834481b1dc5bd936a67b12 7b838df83104405e861f4fcb66a13922 5f87e8f654834481b1dc5bd936a67b12--7b838df83104405e861f4fcb66a13922 495c4406beff4b48bc279f08b227352d 7b838df83104405e861f4fcb66a13922--495c4406beff4b48bc279f08b227352d 6e09d939511e45068813ab1626cd7c9a 495c4406beff4b48bc279f08b227352d--6e09d939511e45068813ab1626cd7c9a c494946f90124505be9f384dfb467f22 6e09d939511e45068813ab1626cd7c9a--c494946f90124505be9f384dfb467f22 7f8dad8e23204ea9abf1867c1a57c04d c494946f90124505be9f384dfb467f22--7f8dad8e23204ea9abf1867c1a57c04d 8938f80494734f3c988ec097406711d0 7f8dad8e23204ea9abf1867c1a57c04d--8938f80494734f3c988ec097406711d0 667c6e80a3c5418d8b40299a43c3acb0 8938f80494734f3c988ec097406711d0--667c6e80a3c5418d8b40299a43c3acb0 bf794d0a641147de8b5ea7efc5b76df2 667c6e80a3c5418d8b40299a43c3acb0--bf794d0a641147de8b5ea7efc5b76df2 9a8b49b4fc324aa4b0f5339e7b1f4898 bf794d0a641147de8b5ea7efc5b76df2--9a8b49b4fc324aa4b0f5339e7b1f4898 1eabc35bb9b3491d98339b4ce4c140d8 9a8b49b4fc324aa4b0f5339e7b1f4898--1eabc35bb9b3491d98339b4ce4c140d8 5e5878ee6b7b4f3f8e88e8f5adb3b8ce 1eabc35bb9b3491d98339b4ce4c140d8--5e5878ee6b7b4f3f8e88e8f5adb3b8ce c409edb8af7d43cca6ef8b164e9f6907 5e5878ee6b7b4f3f8e88e8f5adb3b8ce--c409edb8af7d43cca6ef8b164e9f6907 2d05bcd5aa9b46c3b9f1c806a58c7017 c409edb8af7d43cca6ef8b164e9f6907--2d05bcd5aa9b46c3b9f1c806a58c7017 7e72feced3734afcabe9463cfec7a229 RX(b10) 2d05bcd5aa9b46c3b9f1c806a58c7017--7e72feced3734afcabe9463cfec7a229 82a08bb36b8d4da59399f2895badbc01 7e72feced3734afcabe9463cfec7a229--82a08bb36b8d4da59399f2895badbc01 1b571e47ef2046639f91ced1506856a1 6448592c5eae45509e3574f88e8eca93 X 3f6ca73e023947b19d643ad7a7e0ec39--6448592c5eae45509e3574f88e8eca93 7a4625eb4f6b4da1937b44fcd910ac68 2 6448592c5eae45509e3574f88e8eca93--ef2ee73ee7074c81950c4b2051003c65 2ef78d6446044e918414f3ce65ab2335 6448592c5eae45509e3574f88e8eca93--2ef78d6446044e918414f3ce65ab2335 29fbc21ae91b447288188b28c7299a50 2ef78d6446044e918414f3ce65ab2335--29fbc21ae91b447288188b28c7299a50 91024b655f1f4a9a935fc3fca533d255 29fbc21ae91b447288188b28c7299a50--91024b655f1f4a9a935fc3fca533d255 03b3fc779e0c43938f317b5a066b7f53 91024b655f1f4a9a935fc3fca533d255--03b3fc779e0c43938f317b5a066b7f53 6f597ba65ba64c69ac5c52a42504b7ed 03b3fc779e0c43938f317b5a066b7f53--6f597ba65ba64c69ac5c52a42504b7ed b733cf64214a406c8dc19b7426c8620d 6f597ba65ba64c69ac5c52a42504b7ed--b733cf64214a406c8dc19b7426c8620d a3a6682a0d434967b816605c0154807a b733cf64214a406c8dc19b7426c8620d--a3a6682a0d434967b816605c0154807a 3e74c8454bcb4d4abfb1199898bd02db a3a6682a0d434967b816605c0154807a--3e74c8454bcb4d4abfb1199898bd02db 489c7f93969941629cd275859e9bad0b 3e74c8454bcb4d4abfb1199898bd02db--489c7f93969941629cd275859e9bad0b 7c4e001d26eb421ebb6b47ea7343427b 489c7f93969941629cd275859e9bad0b--7c4e001d26eb421ebb6b47ea7343427b 6f6b45a144c1476fa50344e818bccf42 7c4e001d26eb421ebb6b47ea7343427b--6f6b45a144c1476fa50344e818bccf42 c596cbb95a6c4ace970456cf27336896 6f6b45a144c1476fa50344e818bccf42--c596cbb95a6c4ace970456cf27336896 2c01084b39c749d29f1b3638b8e88699 c596cbb95a6c4ace970456cf27336896--2c01084b39c749d29f1b3638b8e88699 549e161f7a134ef8a44e1e0c6cc45d71 X 2c01084b39c749d29f1b3638b8e88699--549e161f7a134ef8a44e1e0c6cc45d71 549e161f7a134ef8a44e1e0c6cc45d71--dcdb98ddc39740289184e1485068856d 116953cf1bf14ddbb097a60ccc350eb2 X 549e161f7a134ef8a44e1e0c6cc45d71--116953cf1bf14ddbb097a60ccc350eb2 116953cf1bf14ddbb097a60ccc350eb2--5b7db3f1a3dd49c6b1d82ccd6cf4fd0a f3a7b07e4d684f1398d8dbe766d1c834 RZ(-1.0*g0) 116953cf1bf14ddbb097a60ccc350eb2--f3a7b07e4d684f1398d8dbe766d1c834 e769a24a3291440f950e1d1411483599 X f3a7b07e4d684f1398d8dbe766d1c834--e769a24a3291440f950e1d1411483599 e769a24a3291440f950e1d1411483599--9f417eab42fc4cbc85fbead1fd315024 02dec7868e6742569c6dd316bf521022 X e769a24a3291440f950e1d1411483599--02dec7868e6742569c6dd316bf521022 02dec7868e6742569c6dd316bf521022--e1741ef1d0d64c4cae5a84e06a72877f d293f08c32de4ac1b63ccf54edc82264 02dec7868e6742569c6dd316bf521022--d293f08c32de4ac1b63ccf54edc82264 06832e8ad7154e5ba9240db32deebcea d293f08c32de4ac1b63ccf54edc82264--06832e8ad7154e5ba9240db32deebcea b7bee906be39408da5e67991ea178f1e 06832e8ad7154e5ba9240db32deebcea--b7bee906be39408da5e67991ea178f1e e04d2afcf8094a78a0e042c99a94cb72 b7bee906be39408da5e67991ea178f1e--e04d2afcf8094a78a0e042c99a94cb72 f565707009e64ba9b839d579bac0b49d e04d2afcf8094a78a0e042c99a94cb72--f565707009e64ba9b839d579bac0b49d 86ab13313c4149e58c9949cafbbbf52a f565707009e64ba9b839d579bac0b49d--86ab13313c4149e58c9949cafbbbf52a 5f52c76f7ae74cbd94eb8d342ae2a8e4 86ab13313c4149e58c9949cafbbbf52a--5f52c76f7ae74cbd94eb8d342ae2a8e4 207aa91604194ef1b0fe9d88428f1887 5f52c76f7ae74cbd94eb8d342ae2a8e4--207aa91604194ef1b0fe9d88428f1887 84df863ecf0645508c58d2ca029b89cc 207aa91604194ef1b0fe9d88428f1887--84df863ecf0645508c58d2ca029b89cc 5c5bfb2f0c814fc5a1ee62df4f25b2f5 X 84df863ecf0645508c58d2ca029b89cc--5c5bfb2f0c814fc5a1ee62df4f25b2f5 5c5bfb2f0c814fc5a1ee62df4f25b2f5--0b24344f800d41d3890e6bebf092ddc9 66e614d83a374b01b540dcf2561dc3a9 X 5c5bfb2f0c814fc5a1ee62df4f25b2f5--66e614d83a374b01b540dcf2561dc3a9 66e614d83a374b01b540dcf2561dc3a9--0262f3d4c5ee4f019189b83f90de81e7 1c469be7183b41e5b33b97b9c40e7dcb 66e614d83a374b01b540dcf2561dc3a9--1c469be7183b41e5b33b97b9c40e7dcb e8f22750b32c4586bc420cbc123086fd 1c469be7183b41e5b33b97b9c40e7dcb--e8f22750b32c4586bc420cbc123086fd 6e5c75f35f494961b92f11811dac0efc e8f22750b32c4586bc420cbc123086fd--6e5c75f35f494961b92f11811dac0efc 7dad2b0b1eb7405baa5a3ada3872fcb1 6e5c75f35f494961b92f11811dac0efc--7dad2b0b1eb7405baa5a3ada3872fcb1 8fefa24fa19341dbb0b5a051fe215f5e 7dad2b0b1eb7405baa5a3ada3872fcb1--8fefa24fa19341dbb0b5a051fe215f5e 3cd3530acd52426493bf10c81fc016fa 8fefa24fa19341dbb0b5a051fe215f5e--3cd3530acd52426493bf10c81fc016fa 80a55c47fb044912b7f8f97de3ef01d3 3cd3530acd52426493bf10c81fc016fa--80a55c47fb044912b7f8f97de3ef01d3 867a7b5d222f44829c4020c5968c956e 80a55c47fb044912b7f8f97de3ef01d3--867a7b5d222f44829c4020c5968c956e 5e253f72cd2e43c6aed94928b29d9631 867a7b5d222f44829c4020c5968c956e--5e253f72cd2e43c6aed94928b29d9631 c175e38c07e74d12a604093682c2243d 5e253f72cd2e43c6aed94928b29d9631--c175e38c07e74d12a604093682c2243d 59454e8660bf4f85add1110f7d1bf4d7 c175e38c07e74d12a604093682c2243d--59454e8660bf4f85add1110f7d1bf4d7 0b17dbd880a644259aaec6c89d3e72d0 59454e8660bf4f85add1110f7d1bf4d7--0b17dbd880a644259aaec6c89d3e72d0 23bf5b90164a4567b1522a77d3e1cf28 0b17dbd880a644259aaec6c89d3e72d0--23bf5b90164a4567b1522a77d3e1cf28 ce146c3669504ecf81758bbcc6d2429a X 23bf5b90164a4567b1522a77d3e1cf28--ce146c3669504ecf81758bbcc6d2429a ce146c3669504ecf81758bbcc6d2429a--09e33d31b57d4b548cf53f87224ccd65 08bf82a98c624fdbb93e2d5133142481 ce146c3669504ecf81758bbcc6d2429a--08bf82a98c624fdbb93e2d5133142481 592f0123e11549b1878eaff44069a2bd 08bf82a98c624fdbb93e2d5133142481--592f0123e11549b1878eaff44069a2bd 8da514250208402c989e0d7f931d8f9f 592f0123e11549b1878eaff44069a2bd--8da514250208402c989e0d7f931d8f9f 20ab16fe964d4483b626d8fa7d68ed5a 8da514250208402c989e0d7f931d8f9f--20ab16fe964d4483b626d8fa7d68ed5a fcbc4243bc32472291b7a88ade89ea24 20ab16fe964d4483b626d8fa7d68ed5a--fcbc4243bc32472291b7a88ade89ea24 b3c69779c2864072a8b222d532e13879 fcbc4243bc32472291b7a88ade89ea24--b3c69779c2864072a8b222d532e13879 ef5a68cdb520477b8a5983893020dedf b3c69779c2864072a8b222d532e13879--ef5a68cdb520477b8a5983893020dedf c70716e8d8394f109a58791bb220980d ef5a68cdb520477b8a5983893020dedf--c70716e8d8394f109a58791bb220980d 9026d7ea731c45c6b6bf3df96f7dd117 c70716e8d8394f109a58791bb220980d--9026d7ea731c45c6b6bf3df96f7dd117 2d9bf9894fdc42c6b1b403aca81c3205 9026d7ea731c45c6b6bf3df96f7dd117--2d9bf9894fdc42c6b1b403aca81c3205 1332f3a7a2b94cb3ab8ca3bcccb8446a 2d9bf9894fdc42c6b1b403aca81c3205--1332f3a7a2b94cb3ab8ca3bcccb8446a 02befce9d97b407882cfc525885ce57e 1332f3a7a2b94cb3ab8ca3bcccb8446a--02befce9d97b407882cfc525885ce57e b3cf9ce8a4374292bf44f2ac34013ae1 02befce9d97b407882cfc525885ce57e--b3cf9ce8a4374292bf44f2ac34013ae1 f09e776984b84e61a56b528ad76bf904 b3cf9ce8a4374292bf44f2ac34013ae1--f09e776984b84e61a56b528ad76bf904 67b48c066bb44293aad72099b8a850b4 f09e776984b84e61a56b528ad76bf904--67b48c066bb44293aad72099b8a850b4 47ea89d3bee147cab6c645cad06823c3 67b48c066bb44293aad72099b8a850b4--47ea89d3bee147cab6c645cad06823c3 bb114151aa174462b0e308a6cf0ce051 47ea89d3bee147cab6c645cad06823c3--bb114151aa174462b0e308a6cf0ce051 b1cadd0b28b042bfa733b9592e83e71b bb114151aa174462b0e308a6cf0ce051--b1cadd0b28b042bfa733b9592e83e71b 181355b980fe4fd690ac1aa0422d6b7a b1cadd0b28b042bfa733b9592e83e71b--181355b980fe4fd690ac1aa0422d6b7a 75b8c69ce2664a9dabfcacf0ce04d1ed 181355b980fe4fd690ac1aa0422d6b7a--75b8c69ce2664a9dabfcacf0ce04d1ed 29cd7da76714422091e567a96493f414 75b8c69ce2664a9dabfcacf0ce04d1ed--29cd7da76714422091e567a96493f414 32541570af9643ada87e1ed0529da938 29cd7da76714422091e567a96493f414--32541570af9643ada87e1ed0529da938 9ff768d6dab44033be3963ed3aae5f8a 32541570af9643ada87e1ed0529da938--9ff768d6dab44033be3963ed3aae5f8a b0ae2833cd0e4560a2d9e43f1c38b132 9ff768d6dab44033be3963ed3aae5f8a--b0ae2833cd0e4560a2d9e43f1c38b132 936d71313c6a4138a16152267b0e43f8 b0ae2833cd0e4560a2d9e43f1c38b132--936d71313c6a4138a16152267b0e43f8 076fc5723f754722b29ee6e5d3429f19 936d71313c6a4138a16152267b0e43f8--076fc5723f754722b29ee6e5d3429f19 be1b40bb50054bea9c3dcef5fd29df36 076fc5723f754722b29ee6e5d3429f19--be1b40bb50054bea9c3dcef5fd29df36 908667f2f3f7444e9d41189093637f8c be1b40bb50054bea9c3dcef5fd29df36--908667f2f3f7444e9d41189093637f8c f70066d8304f4bd7a4b20e8327aa7576 908667f2f3f7444e9d41189093637f8c--f70066d8304f4bd7a4b20e8327aa7576 3b4ef63153dd49cd9864758933c32607 f70066d8304f4bd7a4b20e8327aa7576--3b4ef63153dd49cd9864758933c32607 642c080d5ad64bde957e35f1e17a07ac 3b4ef63153dd49cd9864758933c32607--642c080d5ad64bde957e35f1e17a07ac bafca0a1d350425d9f99c8b99feefe6e 642c080d5ad64bde957e35f1e17a07ac--bafca0a1d350425d9f99c8b99feefe6e cb9ea7e5f001433296dd22e56734265a bafca0a1d350425d9f99c8b99feefe6e--cb9ea7e5f001433296dd22e56734265a 230c52cfae9541a6b08a1f790773d92d cb9ea7e5f001433296dd22e56734265a--230c52cfae9541a6b08a1f790773d92d cb613d4301984b69ae6705b891c6cc9a RX(b01) 230c52cfae9541a6b08a1f790773d92d--cb613d4301984b69ae6705b891c6cc9a 333760c969be45c4a5fce5b2635d180e X cb613d4301984b69ae6705b891c6cc9a--333760c969be45c4a5fce5b2635d180e 333760c969be45c4a5fce5b2635d180e--319524f011694191aa06aeda3521a2cc b1b63e24a8ba4f20bf45b8bf86a20062 333760c969be45c4a5fce5b2635d180e--b1b63e24a8ba4f20bf45b8bf86a20062 a9c9adb049cb433bb408f54184768113 b1b63e24a8ba4f20bf45b8bf86a20062--a9c9adb049cb433bb408f54184768113 0f4ad047d4e44fbf9c55369e2c0ee649 a9c9adb049cb433bb408f54184768113--0f4ad047d4e44fbf9c55369e2c0ee649 47979327d69d431eb14eaecf80248178 0f4ad047d4e44fbf9c55369e2c0ee649--47979327d69d431eb14eaecf80248178 a03ce2f4456e4860a203e5d19cb8f57f 47979327d69d431eb14eaecf80248178--a03ce2f4456e4860a203e5d19cb8f57f 7b0ed092c4794284b64468db9efec057 a03ce2f4456e4860a203e5d19cb8f57f--7b0ed092c4794284b64468db9efec057 dcb4dda7e5284f278375a979cfbfe097 7b0ed092c4794284b64468db9efec057--dcb4dda7e5284f278375a979cfbfe097 4cd5702a51364297b34aa9686909cbd4 dcb4dda7e5284f278375a979cfbfe097--4cd5702a51364297b34aa9686909cbd4 87a034f1a18b44d480b33c20ab5820e9 4cd5702a51364297b34aa9686909cbd4--87a034f1a18b44d480b33c20ab5820e9 9474303aab4a45efbceafec0b787605d 87a034f1a18b44d480b33c20ab5820e9--9474303aab4a45efbceafec0b787605d 52a0dd529966418ea75ce372a595a233 9474303aab4a45efbceafec0b787605d--52a0dd529966418ea75ce372a595a233 ac95de0abe4e4cd79eb7c6fb97120db5 52a0dd529966418ea75ce372a595a233--ac95de0abe4e4cd79eb7c6fb97120db5 c9ec5e1c264041efa54221d3d03e3fc6 ac95de0abe4e4cd79eb7c6fb97120db5--c9ec5e1c264041efa54221d3d03e3fc6 71e9d1c4093b4617821aeed2e1572689 X c9ec5e1c264041efa54221d3d03e3fc6--71e9d1c4093b4617821aeed2e1572689 71e9d1c4093b4617821aeed2e1572689--21efec06430b497daa58fb5d707423b9 c46685b76d0c4881a35963045caeccc1 X 71e9d1c4093b4617821aeed2e1572689--c46685b76d0c4881a35963045caeccc1 c46685b76d0c4881a35963045caeccc1--13e206cdf328429a8835a0dc50596bf9 e01cfb3ad42f40379bfc0a9a7c1e528a RZ(-1.0*g1) c46685b76d0c4881a35963045caeccc1--e01cfb3ad42f40379bfc0a9a7c1e528a 71e6db8526f04fa199663b2f86159907 X e01cfb3ad42f40379bfc0a9a7c1e528a--71e6db8526f04fa199663b2f86159907 71e6db8526f04fa199663b2f86159907--f7fabac598924a8bb1d9e82f459d9f0c ab22f48f9c64443ca0c40c8486245003 X 71e6db8526f04fa199663b2f86159907--ab22f48f9c64443ca0c40c8486245003 ab22f48f9c64443ca0c40c8486245003--5db14b0248664d6184156924efbea068 384c7102f1d942f19591d478554e1cd7 ab22f48f9c64443ca0c40c8486245003--384c7102f1d942f19591d478554e1cd7 84406ad736da4bbda9ddb4ada04ae182 384c7102f1d942f19591d478554e1cd7--84406ad736da4bbda9ddb4ada04ae182 641c3792c04d47cbadd03db629a6db48 84406ad736da4bbda9ddb4ada04ae182--641c3792c04d47cbadd03db629a6db48 c396a558225a480f9f7f6ce9ed09da45 641c3792c04d47cbadd03db629a6db48--c396a558225a480f9f7f6ce9ed09da45 c77c550aac924022aad5590ccb92ad8f c396a558225a480f9f7f6ce9ed09da45--c77c550aac924022aad5590ccb92ad8f 7c139f40f0bc48f7a480349ac35ab9e3 c77c550aac924022aad5590ccb92ad8f--7c139f40f0bc48f7a480349ac35ab9e3 53aca2ea284e4b25945d5f66b874bf13 7c139f40f0bc48f7a480349ac35ab9e3--53aca2ea284e4b25945d5f66b874bf13 db60cbb66e6648c9b6c7bd6e9002ad3d 53aca2ea284e4b25945d5f66b874bf13--db60cbb66e6648c9b6c7bd6e9002ad3d 81ab8dfff50042ed8c9abac9557c910c db60cbb66e6648c9b6c7bd6e9002ad3d--81ab8dfff50042ed8c9abac9557c910c 14d703dbc3d3462b9dfb19897bbe383e X 81ab8dfff50042ed8c9abac9557c910c--14d703dbc3d3462b9dfb19897bbe383e 14d703dbc3d3462b9dfb19897bbe383e--740e47346e324988839d93c40563c36c 310c55a9e4f742edace6a4ce6b3a4292 X 14d703dbc3d3462b9dfb19897bbe383e--310c55a9e4f742edace6a4ce6b3a4292 310c55a9e4f742edace6a4ce6b3a4292--dbaf2a07cff7440b940ee28a7bee8237 93f5cf16575e450d8ccf4e3b09ecd87c 310c55a9e4f742edace6a4ce6b3a4292--93f5cf16575e450d8ccf4e3b09ecd87c 2335fb0b8ec042baa242c97376bf040b 93f5cf16575e450d8ccf4e3b09ecd87c--2335fb0b8ec042baa242c97376bf040b 8f18bfd0b18b4efdb8e44595d1cf3cfb 2335fb0b8ec042baa242c97376bf040b--8f18bfd0b18b4efdb8e44595d1cf3cfb 78cce89004574f66bc86adf19c660f0e 8f18bfd0b18b4efdb8e44595d1cf3cfb--78cce89004574f66bc86adf19c660f0e 5daa2bd110be462bbddb8d7475373fb7 78cce89004574f66bc86adf19c660f0e--5daa2bd110be462bbddb8d7475373fb7 aeeb7373010740798fd840623506fc30 5daa2bd110be462bbddb8d7475373fb7--aeeb7373010740798fd840623506fc30 90820356549c47409c6ab8e29fe18835 aeeb7373010740798fd840623506fc30--90820356549c47409c6ab8e29fe18835 886213213a86462f92ad460bfab03f0f 90820356549c47409c6ab8e29fe18835--886213213a86462f92ad460bfab03f0f de13a2b26e744641a6051573687d8d7c 886213213a86462f92ad460bfab03f0f--de13a2b26e744641a6051573687d8d7c 6afe1cccc8aa442a85c086ca95b6636e de13a2b26e744641a6051573687d8d7c--6afe1cccc8aa442a85c086ca95b6636e f215b1a574404e25a90fcad1744fc8b7 6afe1cccc8aa442a85c086ca95b6636e--f215b1a574404e25a90fcad1744fc8b7 a575d9d7b05f4932b0af6dd0f85bd31f f215b1a574404e25a90fcad1744fc8b7--a575d9d7b05f4932b0af6dd0f85bd31f 935ce619a14344bea126320d1aa2831b a575d9d7b05f4932b0af6dd0f85bd31f--935ce619a14344bea126320d1aa2831b bdc1f6a883c347e78885941f6c79a1ae X 935ce619a14344bea126320d1aa2831b--bdc1f6a883c347e78885941f6c79a1ae bdc1f6a883c347e78885941f6c79a1ae--ffe4c607eb4d4bf4853fd9c9a5416c6a 1878eb7e4b7747f187a0d1138bb1ffac bdc1f6a883c347e78885941f6c79a1ae--1878eb7e4b7747f187a0d1138bb1ffac e4b79b41759c4951899d88e7042dfa19 1878eb7e4b7747f187a0d1138bb1ffac--e4b79b41759c4951899d88e7042dfa19 ef12e453d7da4bb5b09f5b8fb6f369aa e4b79b41759c4951899d88e7042dfa19--ef12e453d7da4bb5b09f5b8fb6f369aa 0c1b7610d48949e4827b65c012875180 ef12e453d7da4bb5b09f5b8fb6f369aa--0c1b7610d48949e4827b65c012875180 13578d54a5874278bcd03dec5e887ec1 0c1b7610d48949e4827b65c012875180--13578d54a5874278bcd03dec5e887ec1 8a62e60efb2e47c3a9048d62df1c6283 13578d54a5874278bcd03dec5e887ec1--8a62e60efb2e47c3a9048d62df1c6283 8412ae20365947c78aa09ea3901a82e7 8a62e60efb2e47c3a9048d62df1c6283--8412ae20365947c78aa09ea3901a82e7 ab9e8c804f4c4cac937223a9cb40c65b 8412ae20365947c78aa09ea3901a82e7--ab9e8c804f4c4cac937223a9cb40c65b 0b507819cf7c42ab8ce94cc9bf184265 ab9e8c804f4c4cac937223a9cb40c65b--0b507819cf7c42ab8ce94cc9bf184265 0570ed84857a476aa87febe5a7c39b6b 0b507819cf7c42ab8ce94cc9bf184265--0570ed84857a476aa87febe5a7c39b6b 5078928dd4d34d5c9c4f839d0aafa091 0570ed84857a476aa87febe5a7c39b6b--5078928dd4d34d5c9c4f839d0aafa091 256f3167a6ba4257bed04342721d8380 5078928dd4d34d5c9c4f839d0aafa091--256f3167a6ba4257bed04342721d8380 c81701c1e8d547ed98edcded9114de92 256f3167a6ba4257bed04342721d8380--c81701c1e8d547ed98edcded9114de92 f2b18d3e2cac449583408ec33fcfbe42 c81701c1e8d547ed98edcded9114de92--f2b18d3e2cac449583408ec33fcfbe42 35ccd06576d94b419c816a53c1f29a28 f2b18d3e2cac449583408ec33fcfbe42--35ccd06576d94b419c816a53c1f29a28 4798205e2e304da7b922931cd0610395 35ccd06576d94b419c816a53c1f29a28--4798205e2e304da7b922931cd0610395 56cee0a3454d4a3499e2a00c25bdf3d8 4798205e2e304da7b922931cd0610395--56cee0a3454d4a3499e2a00c25bdf3d8 24537077328b42acb536ba4252e91f9f 56cee0a3454d4a3499e2a00c25bdf3d8--24537077328b42acb536ba4252e91f9f 735b4f5a0e22469cbdaf7266d98f0623 24537077328b42acb536ba4252e91f9f--735b4f5a0e22469cbdaf7266d98f0623 f399ae021fc74223b025227eb751a9da 735b4f5a0e22469cbdaf7266d98f0623--f399ae021fc74223b025227eb751a9da 9dbdc31fa0d34847a208de11acb1afc0 f399ae021fc74223b025227eb751a9da--9dbdc31fa0d34847a208de11acb1afc0 0a250ea4b4684b41b7ccb34a606ee542 9dbdc31fa0d34847a208de11acb1afc0--0a250ea4b4684b41b7ccb34a606ee542 700b523a0fbe454aac837b909600672f 0a250ea4b4684b41b7ccb34a606ee542--700b523a0fbe454aac837b909600672f 7bd81801c33d45e9976c55e2f49c91c8 700b523a0fbe454aac837b909600672f--7bd81801c33d45e9976c55e2f49c91c8 c05b1aa1121041e2af87ec5a0aaf352a 7bd81801c33d45e9976c55e2f49c91c8--c05b1aa1121041e2af87ec5a0aaf352a 54c2347731794c54955a94acf9c8b9ff c05b1aa1121041e2af87ec5a0aaf352a--54c2347731794c54955a94acf9c8b9ff 333b0e70b7af4527b11028b578364294 54c2347731794c54955a94acf9c8b9ff--333b0e70b7af4527b11028b578364294 a9640e9e6bf54e3b97a2b5bd8624ea88 333b0e70b7af4527b11028b578364294--a9640e9e6bf54e3b97a2b5bd8624ea88 59dc182831c54f8f99732cdf91832823 a9640e9e6bf54e3b97a2b5bd8624ea88--59dc182831c54f8f99732cdf91832823 74dcbd1f95be4c909ad6665c69fc61f2 59dc182831c54f8f99732cdf91832823--74dcbd1f95be4c909ad6665c69fc61f2 3e3f4a6fee4a461381ec3737406d54f9 74dcbd1f95be4c909ad6665c69fc61f2--3e3f4a6fee4a461381ec3737406d54f9 91b74f730311442f9f1fc0a8399bfcbe 3e3f4a6fee4a461381ec3737406d54f9--91b74f730311442f9f1fc0a8399bfcbe b7e142da625e491688997c459a5c180e 91b74f730311442f9f1fc0a8399bfcbe--b7e142da625e491688997c459a5c180e 12645f3263d24df0a7e08eb01c01314a b7e142da625e491688997c459a5c180e--12645f3263d24df0a7e08eb01c01314a 9aaf51d48d2d4eaa8796fc3fcaaa2a4b RX(b11) 12645f3263d24df0a7e08eb01c01314a--9aaf51d48d2d4eaa8796fc3fcaaa2a4b 9aaf51d48d2d4eaa8796fc3fcaaa2a4b--1b571e47ef2046639f91ced1506856a1 922ef62b422a44c4a9aa7fd8a4ba90ec b2889c3d24674fe7a0214d900ef1d335 7a4625eb4f6b4da1937b44fcd910ac68--b2889c3d24674fe7a0214d900ef1d335 059e25dc430d43aaabdb90a659a52b99 3 ba3b0d49fed947a78b2f46dc7f09fed4 X b2889c3d24674fe7a0214d900ef1d335--ba3b0d49fed947a78b2f46dc7f09fed4 ba3b0d49fed947a78b2f46dc7f09fed4--2ef78d6446044e918414f3ce65ab2335 899d06ca45b34e9db3e5a7f5a7fde8e9 ba3b0d49fed947a78b2f46dc7f09fed4--899d06ca45b34e9db3e5a7f5a7fde8e9 75350f7424164fbbad3072154bedc749 899d06ca45b34e9db3e5a7f5a7fde8e9--75350f7424164fbbad3072154bedc749 efc82c9f5088421994a258b5acc24bb8 75350f7424164fbbad3072154bedc749--efc82c9f5088421994a258b5acc24bb8 3c93c25333c64046acb4118dfda20a71 efc82c9f5088421994a258b5acc24bb8--3c93c25333c64046acb4118dfda20a71 a64e454c2b1c4822971b1fcec4819220 3c93c25333c64046acb4118dfda20a71--a64e454c2b1c4822971b1fcec4819220 9a8797cc333641c895a741b743a95b5f a64e454c2b1c4822971b1fcec4819220--9a8797cc333641c895a741b743a95b5f 5b373927c75a4cd383f75f3ea6a6640c 9a8797cc333641c895a741b743a95b5f--5b373927c75a4cd383f75f3ea6a6640c 316ddf6137bf46c6a831edcbaf42d2e8 5b373927c75a4cd383f75f3ea6a6640c--316ddf6137bf46c6a831edcbaf42d2e8 f977789fed80402c9648cca24a281a36 316ddf6137bf46c6a831edcbaf42d2e8--f977789fed80402c9648cca24a281a36 899e15d0baf540f18dcd3be3db68dc95 f977789fed80402c9648cca24a281a36--899e15d0baf540f18dcd3be3db68dc95 ae2c82a8cf7344ca8125efc1999211c6 899e15d0baf540f18dcd3be3db68dc95--ae2c82a8cf7344ca8125efc1999211c6 58182c2902bb4acfb165d3bab513e78a X ae2c82a8cf7344ca8125efc1999211c6--58182c2902bb4acfb165d3bab513e78a 58182c2902bb4acfb165d3bab513e78a--2c01084b39c749d29f1b3638b8e88699 037ce01b10634b8482484807c6dd3a32 58182c2902bb4acfb165d3bab513e78a--037ce01b10634b8482484807c6dd3a32 ae74846d852f4938b0db8ae911d0c171 037ce01b10634b8482484807c6dd3a32--ae74846d852f4938b0db8ae911d0c171 50d75ed1589f4f99866f071534c54551 ae74846d852f4938b0db8ae911d0c171--50d75ed1589f4f99866f071534c54551 1fdca46065bd4b9aa68054e385355b7a 50d75ed1589f4f99866f071534c54551--1fdca46065bd4b9aa68054e385355b7a 328f735332854e0eb6c6097b724f76c0 1fdca46065bd4b9aa68054e385355b7a--328f735332854e0eb6c6097b724f76c0 8eb29c701f8843f8a0ee1eda2a65a33e X 328f735332854e0eb6c6097b724f76c0--8eb29c701f8843f8a0ee1eda2a65a33e 8eb29c701f8843f8a0ee1eda2a65a33e--d293f08c32de4ac1b63ccf54edc82264 f45ec9defc314a74a8b7146f5f7d8dcf 8eb29c701f8843f8a0ee1eda2a65a33e--f45ec9defc314a74a8b7146f5f7d8dcf f23d2a85ea674ca096bc491a0c6360ef f45ec9defc314a74a8b7146f5f7d8dcf--f23d2a85ea674ca096bc491a0c6360ef 7b8c255aade349d5bdf87135039b2519 f23d2a85ea674ca096bc491a0c6360ef--7b8c255aade349d5bdf87135039b2519 b28ed2b24418409ba8cca73c3bcfc21e 7b8c255aade349d5bdf87135039b2519--b28ed2b24418409ba8cca73c3bcfc21e 849c328316bf46dc9ff11f07d7bf3e65 b28ed2b24418409ba8cca73c3bcfc21e--849c328316bf46dc9ff11f07d7bf3e65 cde09ba1c6184ca6860dab48cdaffe5f 849c328316bf46dc9ff11f07d7bf3e65--cde09ba1c6184ca6860dab48cdaffe5f b0af8220762a40c7abc42d1623034c05 cde09ba1c6184ca6860dab48cdaffe5f--b0af8220762a40c7abc42d1623034c05 8ef834c435bb4f848a1359c4db6ae0f8 X b0af8220762a40c7abc42d1623034c05--8ef834c435bb4f848a1359c4db6ae0f8 8ef834c435bb4f848a1359c4db6ae0f8--84df863ecf0645508c58d2ca029b89cc b4991af800b14a2f97ef819ae4b16bb6 8ef834c435bb4f848a1359c4db6ae0f8--b4991af800b14a2f97ef819ae4b16bb6 773d5c3887b541c193430798df3e7e1e b4991af800b14a2f97ef819ae4b16bb6--773d5c3887b541c193430798df3e7e1e a258db040c114b17a334220a9a82ef84 X 773d5c3887b541c193430798df3e7e1e--a258db040c114b17a334220a9a82ef84 a258db040c114b17a334220a9a82ef84--1c469be7183b41e5b33b97b9c40e7dcb 6614911024284fb49bacf1f281ab6040 a258db040c114b17a334220a9a82ef84--6614911024284fb49bacf1f281ab6040 28178c6ecef046d09675876a8845d66b 6614911024284fb49bacf1f281ab6040--28178c6ecef046d09675876a8845d66b ab9bb0776f6f4d6ebda3c85115aa9578 28178c6ecef046d09675876a8845d66b--ab9bb0776f6f4d6ebda3c85115aa9578 07a7d090e0a049e49860c1458878011c ab9bb0776f6f4d6ebda3c85115aa9578--07a7d090e0a049e49860c1458878011c 9abc1e0dae7f499aa09b03b84498fefa 07a7d090e0a049e49860c1458878011c--9abc1e0dae7f499aa09b03b84498fefa 3e6fdd45966749dcaf02f89cca834bcc 9abc1e0dae7f499aa09b03b84498fefa--3e6fdd45966749dcaf02f89cca834bcc 213a9cd60131448fb97f6c07e20ef62f 3e6fdd45966749dcaf02f89cca834bcc--213a9cd60131448fb97f6c07e20ef62f 80b57758cf40476fa7ee57b6e9cf4446 213a9cd60131448fb97f6c07e20ef62f--80b57758cf40476fa7ee57b6e9cf4446 11c0a79861104830a755fd6adddee80a 80b57758cf40476fa7ee57b6e9cf4446--11c0a79861104830a755fd6adddee80a 030b8ddda57c4509a7b3e506f7ef0456 11c0a79861104830a755fd6adddee80a--030b8ddda57c4509a7b3e506f7ef0456 5630641fe0af4736ac0d1730363f85a8 030b8ddda57c4509a7b3e506f7ef0456--5630641fe0af4736ac0d1730363f85a8 bc4fe844d3a242fd92df67710f083eb2 X 5630641fe0af4736ac0d1730363f85a8--bc4fe844d3a242fd92df67710f083eb2 bc4fe844d3a242fd92df67710f083eb2--23bf5b90164a4567b1522a77d3e1cf28 e13616025af941b293cdf1c14bb5725b bc4fe844d3a242fd92df67710f083eb2--e13616025af941b293cdf1c14bb5725b b0559acfddfd4d8d9dc879fe8ccd6f27 X e13616025af941b293cdf1c14bb5725b--b0559acfddfd4d8d9dc879fe8ccd6f27 b0559acfddfd4d8d9dc879fe8ccd6f27--08bf82a98c624fdbb93e2d5133142481 253b10933fa34222b7d96b1ea6b943ea b0559acfddfd4d8d9dc879fe8ccd6f27--253b10933fa34222b7d96b1ea6b943ea e8856122aa5142c7ab20cf17c2312239 253b10933fa34222b7d96b1ea6b943ea--e8856122aa5142c7ab20cf17c2312239 9b96c73e72704d46ae4afd6d44a6dadf e8856122aa5142c7ab20cf17c2312239--9b96c73e72704d46ae4afd6d44a6dadf e1c3bea9128a4479a179fa00bb7a70e0 9b96c73e72704d46ae4afd6d44a6dadf--e1c3bea9128a4479a179fa00bb7a70e0 3cc10473f38245f29119caf8820fbaf6 e1c3bea9128a4479a179fa00bb7a70e0--3cc10473f38245f29119caf8820fbaf6 e13bad6d6ce948bf9da09d817e74a9b9 X 3cc10473f38245f29119caf8820fbaf6--e13bad6d6ce948bf9da09d817e74a9b9 e13bad6d6ce948bf9da09d817e74a9b9--ef5a68cdb520477b8a5983893020dedf e99c49d48e844dcebff121ee6f3fd043 e13bad6d6ce948bf9da09d817e74a9b9--e99c49d48e844dcebff121ee6f3fd043 b93ff8185ff24cf1a64e9ebc0c27b92b e99c49d48e844dcebff121ee6f3fd043--b93ff8185ff24cf1a64e9ebc0c27b92b d08ead8601c14f39a68ac8fa1d5919dc b93ff8185ff24cf1a64e9ebc0c27b92b--d08ead8601c14f39a68ac8fa1d5919dc 172e0d4d28c444428825ab0c7124fda4 d08ead8601c14f39a68ac8fa1d5919dc--172e0d4d28c444428825ab0c7124fda4 1f0600b8e7b044e18d6d68b76c80eed7 172e0d4d28c444428825ab0c7124fda4--1f0600b8e7b044e18d6d68b76c80eed7 fa3afdea7b84489399d59cad424f6fbe 1f0600b8e7b044e18d6d68b76c80eed7--fa3afdea7b84489399d59cad424f6fbe 39f537a71a7c42648b89fbb18ce74616 fa3afdea7b84489399d59cad424f6fbe--39f537a71a7c42648b89fbb18ce74616 dd4d75bb01ed4316bddfd858f69d06ed 39f537a71a7c42648b89fbb18ce74616--dd4d75bb01ed4316bddfd858f69d06ed 7bd9733299a74a82b802d4133cbbb3cf dd4d75bb01ed4316bddfd858f69d06ed--7bd9733299a74a82b802d4133cbbb3cf 9b9c697c4528463d8cbc640328db62b2 7bd9733299a74a82b802d4133cbbb3cf--9b9c697c4528463d8cbc640328db62b2 4b4b5eaeed9d473faf5b010fccfe157d 9b9c697c4528463d8cbc640328db62b2--4b4b5eaeed9d473faf5b010fccfe157d 275ab600327a4b1b8e2d41693fcc6fcc 4b4b5eaeed9d473faf5b010fccfe157d--275ab600327a4b1b8e2d41693fcc6fcc d897bc3912d146709576256ce5954a28 275ab600327a4b1b8e2d41693fcc6fcc--d897bc3912d146709576256ce5954a28 7c1c442eabbc4244bde285f4190d644b d897bc3912d146709576256ce5954a28--7c1c442eabbc4244bde285f4190d644b ba2df1463f594418a9cee9ce62c81160 7c1c442eabbc4244bde285f4190d644b--ba2df1463f594418a9cee9ce62c81160 7b838e77b6d74b6ba5f006052353aac0 ba2df1463f594418a9cee9ce62c81160--7b838e77b6d74b6ba5f006052353aac0 76354402e7e74855a0a228940d73ba7e 7b838e77b6d74b6ba5f006052353aac0--76354402e7e74855a0a228940d73ba7e 0875e97b231640c09137a8698d5b1e35 76354402e7e74855a0a228940d73ba7e--0875e97b231640c09137a8698d5b1e35 9f8f54e1751d43d8afb5d3923736c627 0875e97b231640c09137a8698d5b1e35--9f8f54e1751d43d8afb5d3923736c627 0558495729634d62bdad2946fd74da2f 9f8f54e1751d43d8afb5d3923736c627--0558495729634d62bdad2946fd74da2f b8943e4e49ba411bb107d4d02ce4524f 0558495729634d62bdad2946fd74da2f--b8943e4e49ba411bb107d4d02ce4524f 0b6b98c58a324d85a43e603f5e33f3a4 b8943e4e49ba411bb107d4d02ce4524f--0b6b98c58a324d85a43e603f5e33f3a4 7de82d845ec341e9ac3a8015a27c00e6 0b6b98c58a324d85a43e603f5e33f3a4--7de82d845ec341e9ac3a8015a27c00e6 a96f7bb2bd8e4035b496b9b658f522f1 7de82d845ec341e9ac3a8015a27c00e6--a96f7bb2bd8e4035b496b9b658f522f1 5bbdfb45552f40988a824484051a3329 a96f7bb2bd8e4035b496b9b658f522f1--5bbdfb45552f40988a824484051a3329 8812ab1c290848f88f8c23ca89ac5990 5bbdfb45552f40988a824484051a3329--8812ab1c290848f88f8c23ca89ac5990 15ec143b7fda4f0090a9ac3b5a1aa0b5 8812ab1c290848f88f8c23ca89ac5990--15ec143b7fda4f0090a9ac3b5a1aa0b5 849cc60de9744b9da9ac1748a6573d1c RX(b02) 15ec143b7fda4f0090a9ac3b5a1aa0b5--849cc60de9744b9da9ac1748a6573d1c 82486f19584a4fb6b1588c094b216249 849cc60de9744b9da9ac1748a6573d1c--82486f19584a4fb6b1588c094b216249 52dfc848b71f42a2954969cc73916917 X 82486f19584a4fb6b1588c094b216249--52dfc848b71f42a2954969cc73916917 52dfc848b71f42a2954969cc73916917--b1b63e24a8ba4f20bf45b8bf86a20062 01f424d133644960bca0cb0d4cd9fcda 52dfc848b71f42a2954969cc73916917--01f424d133644960bca0cb0d4cd9fcda fa2bdde5b50643e2aaa6cb55ab36750e 01f424d133644960bca0cb0d4cd9fcda--fa2bdde5b50643e2aaa6cb55ab36750e b6247a246d264964bf9bcf4314a722c1 fa2bdde5b50643e2aaa6cb55ab36750e--b6247a246d264964bf9bcf4314a722c1 19adcfb025ae4262bc7d84c4e28dbaf1 b6247a246d264964bf9bcf4314a722c1--19adcfb025ae4262bc7d84c4e28dbaf1 29af3642e2034947a908cba941b48643 19adcfb025ae4262bc7d84c4e28dbaf1--29af3642e2034947a908cba941b48643 149e485ca2f64428b90936e3b8002f46 29af3642e2034947a908cba941b48643--149e485ca2f64428b90936e3b8002f46 46237453eb644b9ba5a9e6baed9a5dc1 149e485ca2f64428b90936e3b8002f46--46237453eb644b9ba5a9e6baed9a5dc1 c0093b12bd854389aaded82cebb6c1f4 46237453eb644b9ba5a9e6baed9a5dc1--c0093b12bd854389aaded82cebb6c1f4 2c8b177a1d1e4febbdf45d90a5023d57 c0093b12bd854389aaded82cebb6c1f4--2c8b177a1d1e4febbdf45d90a5023d57 8c965a9f0c564ac48618d53f2727629b 2c8b177a1d1e4febbdf45d90a5023d57--8c965a9f0c564ac48618d53f2727629b 2141914632e943c8adcee951eb7d0c75 8c965a9f0c564ac48618d53f2727629b--2141914632e943c8adcee951eb7d0c75 276a8e62112f40f29cbbe730c85764cd X 2141914632e943c8adcee951eb7d0c75--276a8e62112f40f29cbbe730c85764cd 276a8e62112f40f29cbbe730c85764cd--c9ec5e1c264041efa54221d3d03e3fc6 39cfc948d7be4c0e9984474186fdce99 276a8e62112f40f29cbbe730c85764cd--39cfc948d7be4c0e9984474186fdce99 efc3bd0fedaf4c8b92d4e1efa3f6ac5b 39cfc948d7be4c0e9984474186fdce99--efc3bd0fedaf4c8b92d4e1efa3f6ac5b 7eb711957456410fb08aa8165633beb0 efc3bd0fedaf4c8b92d4e1efa3f6ac5b--7eb711957456410fb08aa8165633beb0 78b99c59236e4513b3cceed1945e8ca9 7eb711957456410fb08aa8165633beb0--78b99c59236e4513b3cceed1945e8ca9 9b4b5d3bb8b449918a2e054185229614 78b99c59236e4513b3cceed1945e8ca9--9b4b5d3bb8b449918a2e054185229614 d52c70788ee34ab395c960cac2579738 X 9b4b5d3bb8b449918a2e054185229614--d52c70788ee34ab395c960cac2579738 d52c70788ee34ab395c960cac2579738--384c7102f1d942f19591d478554e1cd7 d06998c722c4410cb5e59e1fe4f6292c d52c70788ee34ab395c960cac2579738--d06998c722c4410cb5e59e1fe4f6292c ef78076453fa4724b83d06bf9b35cd95 d06998c722c4410cb5e59e1fe4f6292c--ef78076453fa4724b83d06bf9b35cd95 62cf7a5c9d3b4fbebec825c16eb5ca33 ef78076453fa4724b83d06bf9b35cd95--62cf7a5c9d3b4fbebec825c16eb5ca33 97d5b88a77e344d7b41d4007d57a83c1 62cf7a5c9d3b4fbebec825c16eb5ca33--97d5b88a77e344d7b41d4007d57a83c1 e289dcbe2bea412a94d5f2a4d86535a3 97d5b88a77e344d7b41d4007d57a83c1--e289dcbe2bea412a94d5f2a4d86535a3 bb11f18e67ab449088ef0338b3315797 e289dcbe2bea412a94d5f2a4d86535a3--bb11f18e67ab449088ef0338b3315797 bb4ef629a0b048a8b87cafad3834cc6e bb11f18e67ab449088ef0338b3315797--bb4ef629a0b048a8b87cafad3834cc6e 38e3d9d3fa744bf89894ec631d793889 X bb4ef629a0b048a8b87cafad3834cc6e--38e3d9d3fa744bf89894ec631d793889 38e3d9d3fa744bf89894ec631d793889--81ab8dfff50042ed8c9abac9557c910c 17e4dee0e603463ebfcb67f6dfa3ddf2 38e3d9d3fa744bf89894ec631d793889--17e4dee0e603463ebfcb67f6dfa3ddf2 6771ea89028942df9d2709bdd135221b 17e4dee0e603463ebfcb67f6dfa3ddf2--6771ea89028942df9d2709bdd135221b b91644588fd843ce80df4ac7372fa63b X 6771ea89028942df9d2709bdd135221b--b91644588fd843ce80df4ac7372fa63b b91644588fd843ce80df4ac7372fa63b--93f5cf16575e450d8ccf4e3b09ecd87c 3199d965623c4989b59893657bb58a70 b91644588fd843ce80df4ac7372fa63b--3199d965623c4989b59893657bb58a70 bd5811f3ca0342a699ebbdd44106f900 3199d965623c4989b59893657bb58a70--bd5811f3ca0342a699ebbdd44106f900 3d07b4c8b5c547b99eb71cac76e0b3fd bd5811f3ca0342a699ebbdd44106f900--3d07b4c8b5c547b99eb71cac76e0b3fd 3b865087ba9d430d830f2dcf7f0f8492 3d07b4c8b5c547b99eb71cac76e0b3fd--3b865087ba9d430d830f2dcf7f0f8492 074f0a1be2a94747b1bf24273d5582f8 3b865087ba9d430d830f2dcf7f0f8492--074f0a1be2a94747b1bf24273d5582f8 dbf5b3bbd14d4b0a824ec616dc8c4ecf 074f0a1be2a94747b1bf24273d5582f8--dbf5b3bbd14d4b0a824ec616dc8c4ecf 54176e6aff3e4396a95e497d709237d9 dbf5b3bbd14d4b0a824ec616dc8c4ecf--54176e6aff3e4396a95e497d709237d9 5af498be0472495ea83dcaa4883718d4 54176e6aff3e4396a95e497d709237d9--5af498be0472495ea83dcaa4883718d4 aebcb21612994d7081202f5f761e757e 5af498be0472495ea83dcaa4883718d4--aebcb21612994d7081202f5f761e757e a9c95396686b489091e10aa9a67dc4bd aebcb21612994d7081202f5f761e757e--a9c95396686b489091e10aa9a67dc4bd 532ac30d1d9b4c08b6115b600f526227 a9c95396686b489091e10aa9a67dc4bd--532ac30d1d9b4c08b6115b600f526227 143554c8f704461d8ae66d0f503477b9 X 532ac30d1d9b4c08b6115b600f526227--143554c8f704461d8ae66d0f503477b9 143554c8f704461d8ae66d0f503477b9--935ce619a14344bea126320d1aa2831b a709bcd9399d4a3895bbf5828df1406f 143554c8f704461d8ae66d0f503477b9--a709bcd9399d4a3895bbf5828df1406f ca24983af57c4c779bc2a330feb2234b X a709bcd9399d4a3895bbf5828df1406f--ca24983af57c4c779bc2a330feb2234b ca24983af57c4c779bc2a330feb2234b--1878eb7e4b7747f187a0d1138bb1ffac 4d91299e5e32460ca2b147a2336acb33 ca24983af57c4c779bc2a330feb2234b--4d91299e5e32460ca2b147a2336acb33 19fd00d81af444c09007b10d5bf65d2f 4d91299e5e32460ca2b147a2336acb33--19fd00d81af444c09007b10d5bf65d2f 3f1d9b9f848543728da976180f461db8 19fd00d81af444c09007b10d5bf65d2f--3f1d9b9f848543728da976180f461db8 dafe0938342e4e83a8d41074a7def85e 3f1d9b9f848543728da976180f461db8--dafe0938342e4e83a8d41074a7def85e bfb0e55399da45e1b4535736cb203961 dafe0938342e4e83a8d41074a7def85e--bfb0e55399da45e1b4535736cb203961 2fdd206cca294867b00ab8ba0bec02f9 X bfb0e55399da45e1b4535736cb203961--2fdd206cca294867b00ab8ba0bec02f9 2fdd206cca294867b00ab8ba0bec02f9--8412ae20365947c78aa09ea3901a82e7 d90d463698994513aa7bd486d03c7a4c 2fdd206cca294867b00ab8ba0bec02f9--d90d463698994513aa7bd486d03c7a4c 818749c8a77a4300ade01b58f64d9e09 d90d463698994513aa7bd486d03c7a4c--818749c8a77a4300ade01b58f64d9e09 ac8047aa759c4138888ade5caae3f01f 818749c8a77a4300ade01b58f64d9e09--ac8047aa759c4138888ade5caae3f01f 21477385be3e4c7c8509f3dd8d1104fd ac8047aa759c4138888ade5caae3f01f--21477385be3e4c7c8509f3dd8d1104fd 81a9daeec1d745839def952f54edf0b8 21477385be3e4c7c8509f3dd8d1104fd--81a9daeec1d745839def952f54edf0b8 01667403968644f890ad6afe8c80f648 81a9daeec1d745839def952f54edf0b8--01667403968644f890ad6afe8c80f648 45fc44aa8da448dea48c7b57e263c98b 01667403968644f890ad6afe8c80f648--45fc44aa8da448dea48c7b57e263c98b 34cf6872fbcf4e19847e5197335a48a6 45fc44aa8da448dea48c7b57e263c98b--34cf6872fbcf4e19847e5197335a48a6 e1673fd72a064cb688203704dae2288d 34cf6872fbcf4e19847e5197335a48a6--e1673fd72a064cb688203704dae2288d dd649345546542bc87bb38a3cbafcb45 e1673fd72a064cb688203704dae2288d--dd649345546542bc87bb38a3cbafcb45 ec07bd0d8162473ab035fd27323dbf3f dd649345546542bc87bb38a3cbafcb45--ec07bd0d8162473ab035fd27323dbf3f 4c88998e5a674e36ac5adc70020bafc8 ec07bd0d8162473ab035fd27323dbf3f--4c88998e5a674e36ac5adc70020bafc8 4ab2add822534f37a7cc1ba7461f8086 4c88998e5a674e36ac5adc70020bafc8--4ab2add822534f37a7cc1ba7461f8086 f6964cb5e54948f2808b5e675cb44078 4ab2add822534f37a7cc1ba7461f8086--f6964cb5e54948f2808b5e675cb44078 cead28626f8244e5b8b4d0054f0c4152 f6964cb5e54948f2808b5e675cb44078--cead28626f8244e5b8b4d0054f0c4152 94a0a52ec8fa43b392330ee63f992a7f cead28626f8244e5b8b4d0054f0c4152--94a0a52ec8fa43b392330ee63f992a7f 053c14c045554024b89a8e944b1a21a9 94a0a52ec8fa43b392330ee63f992a7f--053c14c045554024b89a8e944b1a21a9 e65a43aa56f145dba37d0d3749f7c02f 053c14c045554024b89a8e944b1a21a9--e65a43aa56f145dba37d0d3749f7c02f e5f6ed25df634c4b817ec6aeb045b10f e65a43aa56f145dba37d0d3749f7c02f--e5f6ed25df634c4b817ec6aeb045b10f babad63a04754ec08ccbbe8ef938645f e5f6ed25df634c4b817ec6aeb045b10f--babad63a04754ec08ccbbe8ef938645f 7a5ca2434ad84bb09f01fde1da9d46b5 babad63a04754ec08ccbbe8ef938645f--7a5ca2434ad84bb09f01fde1da9d46b5 38cc6543c56e474c8bf4f1de469a8074 7a5ca2434ad84bb09f01fde1da9d46b5--38cc6543c56e474c8bf4f1de469a8074 5d8502f407114fecadd366f6235664e5 38cc6543c56e474c8bf4f1de469a8074--5d8502f407114fecadd366f6235664e5 1ae14945e0d9440a9bd8d90175c74756 5d8502f407114fecadd366f6235664e5--1ae14945e0d9440a9bd8d90175c74756 3e3e789219934ab0b17ada3c7839690e 1ae14945e0d9440a9bd8d90175c74756--3e3e789219934ab0b17ada3c7839690e 7adc0c11492347f5b8568ecb05049646 3e3e789219934ab0b17ada3c7839690e--7adc0c11492347f5b8568ecb05049646 1c3e8b59754c458cbc509768eb763fbc 7adc0c11492347f5b8568ecb05049646--1c3e8b59754c458cbc509768eb763fbc 47c046ddb8ff4029bd252af4e3fe7cab RX(b12) 1c3e8b59754c458cbc509768eb763fbc--47c046ddb8ff4029bd252af4e3fe7cab 47c046ddb8ff4029bd252af4e3fe7cab--922ef62b422a44c4a9aa7fd8a4ba90ec 04e90fbf31214999bfa6a31488617e45 29cc861903e1403d83bc8efccc24d869 059e25dc430d43aaabdb90a659a52b99--29cc861903e1403d83bc8efccc24d869 2dd76002b3e94c2db24cdeb36490ab4c 4 4c4df9d21d624690bc147c33874199d3 29cc861903e1403d83bc8efccc24d869--4c4df9d21d624690bc147c33874199d3 d30204d800974fb3a5ba15a246d12531 X 4c4df9d21d624690bc147c33874199d3--d30204d800974fb3a5ba15a246d12531 d30204d800974fb3a5ba15a246d12531--899d06ca45b34e9db3e5a7f5a7fde8e9 33877cefdb04440c98f8ee945106ca7e d30204d800974fb3a5ba15a246d12531--33877cefdb04440c98f8ee945106ca7e 36e44cc83e334334ab7ea1d166a1d7b0 33877cefdb04440c98f8ee945106ca7e--36e44cc83e334334ab7ea1d166a1d7b0 a0d580dfc07744d7a0423f55a3fb40a8 36e44cc83e334334ab7ea1d166a1d7b0--a0d580dfc07744d7a0423f55a3fb40a8 6e19e96996d643d18ec21a6a619bfd60 a0d580dfc07744d7a0423f55a3fb40a8--6e19e96996d643d18ec21a6a619bfd60 61fb4ee66b9042e880abc284c7a7433c 6e19e96996d643d18ec21a6a619bfd60--61fb4ee66b9042e880abc284c7a7433c 6c8bdf91989a408494d3e73bbf152114 61fb4ee66b9042e880abc284c7a7433c--6c8bdf91989a408494d3e73bbf152114 463c3264e81d4d79a17ef54ff404aeb3 6c8bdf91989a408494d3e73bbf152114--463c3264e81d4d79a17ef54ff404aeb3 66abd91201d24a84addb7f2fb6a961a0 463c3264e81d4d79a17ef54ff404aeb3--66abd91201d24a84addb7f2fb6a961a0 ce5afb88b99f43d8a8294cb9c7165b0f 66abd91201d24a84addb7f2fb6a961a0--ce5afb88b99f43d8a8294cb9c7165b0f e37fbab08972442d9d6faccf44624f81 X ce5afb88b99f43d8a8294cb9c7165b0f--e37fbab08972442d9d6faccf44624f81 e37fbab08972442d9d6faccf44624f81--ae2c82a8cf7344ca8125efc1999211c6 2b66bfa34a8247a3b794071ce5fbaf28 e37fbab08972442d9d6faccf44624f81--2b66bfa34a8247a3b794071ce5fbaf28 8137c44796cb44448cee89ea60e516e0 2b66bfa34a8247a3b794071ce5fbaf28--8137c44796cb44448cee89ea60e516e0 0c20dec8f15e40fda2fc228211b6d3a1 8137c44796cb44448cee89ea60e516e0--0c20dec8f15e40fda2fc228211b6d3a1 33c3a1662e7f4042a6bfb60fb2bba4cb 0c20dec8f15e40fda2fc228211b6d3a1--33c3a1662e7f4042a6bfb60fb2bba4cb 2add129f48ac4ec29290f6790a7fbc75 33c3a1662e7f4042a6bfb60fb2bba4cb--2add129f48ac4ec29290f6790a7fbc75 376c3ba984f846238272099aa476a214 2add129f48ac4ec29290f6790a7fbc75--376c3ba984f846238272099aa476a214 f8efc58fdc1445f6baba5fa060721e37 376c3ba984f846238272099aa476a214--f8efc58fdc1445f6baba5fa060721e37 cc18b767dc8448af951f060b875812fd X f8efc58fdc1445f6baba5fa060721e37--cc18b767dc8448af951f060b875812fd cc18b767dc8448af951f060b875812fd--f45ec9defc314a74a8b7146f5f7d8dcf 23ace5fe77ac44d9a086b331312f6a6b cc18b767dc8448af951f060b875812fd--23ace5fe77ac44d9a086b331312f6a6b ec27e20daf904b53a49f351abade6a22 23ace5fe77ac44d9a086b331312f6a6b--ec27e20daf904b53a49f351abade6a22 085c82f8ffd94f6485929610917d3652 ec27e20daf904b53a49f351abade6a22--085c82f8ffd94f6485929610917d3652 99c523995ccb4f1ab98f0a8520122aa2 085c82f8ffd94f6485929610917d3652--99c523995ccb4f1ab98f0a8520122aa2 5aef9fbe3ef94f5f89277e09f7922880 99c523995ccb4f1ab98f0a8520122aa2--5aef9fbe3ef94f5f89277e09f7922880 587ab8dec3f24d75bebcf6f4830cc946 X 5aef9fbe3ef94f5f89277e09f7922880--587ab8dec3f24d75bebcf6f4830cc946 587ab8dec3f24d75bebcf6f4830cc946--b0af8220762a40c7abc42d1623034c05 e5638b3c50404975b20688319f4774cd 587ab8dec3f24d75bebcf6f4830cc946--e5638b3c50404975b20688319f4774cd 437ce87e084e4eb5ac570fdc57c06b74 e5638b3c50404975b20688319f4774cd--437ce87e084e4eb5ac570fdc57c06b74 3bee72bff93546379c1341b2563674b9 437ce87e084e4eb5ac570fdc57c06b74--3bee72bff93546379c1341b2563674b9 50540fb846754955aac416e729d3e3bf 3bee72bff93546379c1341b2563674b9--50540fb846754955aac416e729d3e3bf 1ecad2416354453aaeb5b3f176e92330 X 50540fb846754955aac416e729d3e3bf--1ecad2416354453aaeb5b3f176e92330 1ecad2416354453aaeb5b3f176e92330--6614911024284fb49bacf1f281ab6040 7a3f5372cd1e4bae890ae2d9a68952a8 1ecad2416354453aaeb5b3f176e92330--7a3f5372cd1e4bae890ae2d9a68952a8 45a647f873fa49d493e3c8a372080cf1 7a3f5372cd1e4bae890ae2d9a68952a8--45a647f873fa49d493e3c8a372080cf1 6dacbff43f4f448c9f721f16de6bf26e 45a647f873fa49d493e3c8a372080cf1--6dacbff43f4f448c9f721f16de6bf26e 702f407398e14808b3b0a59044499a6a 6dacbff43f4f448c9f721f16de6bf26e--702f407398e14808b3b0a59044499a6a 3c872f44c31b4d82940908c57f0a5900 702f407398e14808b3b0a59044499a6a--3c872f44c31b4d82940908c57f0a5900 a859fd5087bb42a0904df9037ffbb4c7 3c872f44c31b4d82940908c57f0a5900--a859fd5087bb42a0904df9037ffbb4c7 efb9ed0664d547cb8ab9c79e2038f341 a859fd5087bb42a0904df9037ffbb4c7--efb9ed0664d547cb8ab9c79e2038f341 ba485a4f758349e59327649f86b16b40 efb9ed0664d547cb8ab9c79e2038f341--ba485a4f758349e59327649f86b16b40 fe6ac7fecb0f435da110258c5378930f ba485a4f758349e59327649f86b16b40--fe6ac7fecb0f435da110258c5378930f 0858a7707cbc4e479a5f548239009e5b X fe6ac7fecb0f435da110258c5378930f--0858a7707cbc4e479a5f548239009e5b 0858a7707cbc4e479a5f548239009e5b--5630641fe0af4736ac0d1730363f85a8 e65a01276c2349138120572e238b3e01 0858a7707cbc4e479a5f548239009e5b--e65a01276c2349138120572e238b3e01 7e1fdea8566a440a94cb3644adc3fc21 e65a01276c2349138120572e238b3e01--7e1fdea8566a440a94cb3644adc3fc21 99fae3458441466c99c1a2e54f9a2e53 7e1fdea8566a440a94cb3644adc3fc21--99fae3458441466c99c1a2e54f9a2e53 2262f6486b184c9dbfe70fb4f8ed5796 X 99fae3458441466c99c1a2e54f9a2e53--2262f6486b184c9dbfe70fb4f8ed5796 2262f6486b184c9dbfe70fb4f8ed5796--253b10933fa34222b7d96b1ea6b943ea baf4897290644b35b0e5771a6c2a7a69 2262f6486b184c9dbfe70fb4f8ed5796--baf4897290644b35b0e5771a6c2a7a69 e4248b9838764892822c37db7f4bbc3e baf4897290644b35b0e5771a6c2a7a69--e4248b9838764892822c37db7f4bbc3e 743688277b89494480ab3664515f320b e4248b9838764892822c37db7f4bbc3e--743688277b89494480ab3664515f320b 2acd4825f3804d2caf57eb818490c918 X 743688277b89494480ab3664515f320b--2acd4825f3804d2caf57eb818490c918 2acd4825f3804d2caf57eb818490c918--3cc10473f38245f29119caf8820fbaf6 5b7ab6062b9a4743b9321515a519b74c 2acd4825f3804d2caf57eb818490c918--5b7ab6062b9a4743b9321515a519b74c 7a1cd62bd55a47eba933105c269a3cca 5b7ab6062b9a4743b9321515a519b74c--7a1cd62bd55a47eba933105c269a3cca 55d5e3dd60d94ac1a38933e16141cafa 7a1cd62bd55a47eba933105c269a3cca--55d5e3dd60d94ac1a38933e16141cafa 35c5f2b776414ef9baa1c11c196305a1 55d5e3dd60d94ac1a38933e16141cafa--35c5f2b776414ef9baa1c11c196305a1 7f1ad8f190224896b3be867e89af2d58 35c5f2b776414ef9baa1c11c196305a1--7f1ad8f190224896b3be867e89af2d58 6998fc71fdf642808e4921cc4fc566f7 7f1ad8f190224896b3be867e89af2d58--6998fc71fdf642808e4921cc4fc566f7 2b49c4a655e148708e8aa1c3a7d4c245 6998fc71fdf642808e4921cc4fc566f7--2b49c4a655e148708e8aa1c3a7d4c245 d1f047635aca46c7b89d98e41b448f2b 2b49c4a655e148708e8aa1c3a7d4c245--d1f047635aca46c7b89d98e41b448f2b f40777486aab485682552e83ecbfee60 d1f047635aca46c7b89d98e41b448f2b--f40777486aab485682552e83ecbfee60 c021e41c11aa483aa36ed66909ef7c56 f40777486aab485682552e83ecbfee60--c021e41c11aa483aa36ed66909ef7c56 f52870b565244ee6918bb9c9e0294b78 c021e41c11aa483aa36ed66909ef7c56--f52870b565244ee6918bb9c9e0294b78 ac0fda92830942409c957e54c503cf29 f52870b565244ee6918bb9c9e0294b78--ac0fda92830942409c957e54c503cf29 fea0c8f8750f431699b7852a2ecec209 ac0fda92830942409c957e54c503cf29--fea0c8f8750f431699b7852a2ecec209 1983e01891fb413cabfbb27ca29f6521 fea0c8f8750f431699b7852a2ecec209--1983e01891fb413cabfbb27ca29f6521 d0e8c736fe9f40a982956b0dd5e11b27 1983e01891fb413cabfbb27ca29f6521--d0e8c736fe9f40a982956b0dd5e11b27 c734941330a24e0680f18231f05eb7e6 d0e8c736fe9f40a982956b0dd5e11b27--c734941330a24e0680f18231f05eb7e6 2f639580ac4843c3ad6cea6094a1d635 c734941330a24e0680f18231f05eb7e6--2f639580ac4843c3ad6cea6094a1d635 cd3db39799ae47a380b6f2351dff3ded 2f639580ac4843c3ad6cea6094a1d635--cd3db39799ae47a380b6f2351dff3ded d1367cfb68d8498eb9fb5cf2b2a4b1b1 cd3db39799ae47a380b6f2351dff3ded--d1367cfb68d8498eb9fb5cf2b2a4b1b1 a420336304b64ce8bb55c3773e87273f d1367cfb68d8498eb9fb5cf2b2a4b1b1--a420336304b64ce8bb55c3773e87273f 1b1127052982485192d0f5d1097c9d17 a420336304b64ce8bb55c3773e87273f--1b1127052982485192d0f5d1097c9d17 81210b48102c4dc8b5d36e7cbc2ff798 1b1127052982485192d0f5d1097c9d17--81210b48102c4dc8b5d36e7cbc2ff798 d95f9d5b6489415a99c0f338e4e19f0c 81210b48102c4dc8b5d36e7cbc2ff798--d95f9d5b6489415a99c0f338e4e19f0c 802f2b90033f42e4a81fb1965da2babb d95f9d5b6489415a99c0f338e4e19f0c--802f2b90033f42e4a81fb1965da2babb 83d67288db854f569ed09c9fcf082fb6 802f2b90033f42e4a81fb1965da2babb--83d67288db854f569ed09c9fcf082fb6 e765f79f55d64b89b4e247d95fdaf8af 83d67288db854f569ed09c9fcf082fb6--e765f79f55d64b89b4e247d95fdaf8af fc458e6e4f1c465fb726fdaecd164b96 e765f79f55d64b89b4e247d95fdaf8af--fc458e6e4f1c465fb726fdaecd164b96 916041c064174cb0982106671cec46c3 fc458e6e4f1c465fb726fdaecd164b96--916041c064174cb0982106671cec46c3 c386162cbf66405281d7a0818a0a7bbb RX(b03) 916041c064174cb0982106671cec46c3--c386162cbf66405281d7a0818a0a7bbb 2784566e3cc24670821b1b7b86795f31 c386162cbf66405281d7a0818a0a7bbb--2784566e3cc24670821b1b7b86795f31 ca5cafe940c840fc82d2a469a978a7d0 2784566e3cc24670821b1b7b86795f31--ca5cafe940c840fc82d2a469a978a7d0 5b9dbd1fe1384179b12fdd6a75204d7d X ca5cafe940c840fc82d2a469a978a7d0--5b9dbd1fe1384179b12fdd6a75204d7d 5b9dbd1fe1384179b12fdd6a75204d7d--01f424d133644960bca0cb0d4cd9fcda d1a3f4f56ced4db8af9746ce985cf69d 5b9dbd1fe1384179b12fdd6a75204d7d--d1a3f4f56ced4db8af9746ce985cf69d 8d637ca3addf4bf0a418d53e48484895 d1a3f4f56ced4db8af9746ce985cf69d--8d637ca3addf4bf0a418d53e48484895 83696c6004f04053b64b06fbf91c0834 8d637ca3addf4bf0a418d53e48484895--83696c6004f04053b64b06fbf91c0834 0fd2e1aad03f4afda6a08566470bdbd7 83696c6004f04053b64b06fbf91c0834--0fd2e1aad03f4afda6a08566470bdbd7 ddc054be39ae4b5bb25d87a63158c7c8 0fd2e1aad03f4afda6a08566470bdbd7--ddc054be39ae4b5bb25d87a63158c7c8 83dd68e18dbd4aedae40510f33466022 ddc054be39ae4b5bb25d87a63158c7c8--83dd68e18dbd4aedae40510f33466022 8ffb260b8ea941e9a72dfbaf4e19dccc 83dd68e18dbd4aedae40510f33466022--8ffb260b8ea941e9a72dfbaf4e19dccc 23d628b4634041cf9d02ec44fbff1bfb 8ffb260b8ea941e9a72dfbaf4e19dccc--23d628b4634041cf9d02ec44fbff1bfb b0d23a206caa420dbaef5213bb50e2e8 23d628b4634041cf9d02ec44fbff1bfb--b0d23a206caa420dbaef5213bb50e2e8 0012e31085bf4f0cb676d77154b4078a X b0d23a206caa420dbaef5213bb50e2e8--0012e31085bf4f0cb676d77154b4078a 0012e31085bf4f0cb676d77154b4078a--2141914632e943c8adcee951eb7d0c75 ef89a3fe6ece442399614c042790832e 0012e31085bf4f0cb676d77154b4078a--ef89a3fe6ece442399614c042790832e 8957d0393dd844dd86a6030e04288691 ef89a3fe6ece442399614c042790832e--8957d0393dd844dd86a6030e04288691 fe724dd995a1452f80de9db87b060219 8957d0393dd844dd86a6030e04288691--fe724dd995a1452f80de9db87b060219 b074cb7222764ca180a33fd864213244 fe724dd995a1452f80de9db87b060219--b074cb7222764ca180a33fd864213244 e881feabb875451bb1ee925637d23e28 b074cb7222764ca180a33fd864213244--e881feabb875451bb1ee925637d23e28 8fd934b34d5f44a4888664b5427b20fe e881feabb875451bb1ee925637d23e28--8fd934b34d5f44a4888664b5427b20fe 4443b5856f57479aaf4513e251cd9fc9 8fd934b34d5f44a4888664b5427b20fe--4443b5856f57479aaf4513e251cd9fc9 2875787ecf2743a2a77e405f4cfd0613 X 4443b5856f57479aaf4513e251cd9fc9--2875787ecf2743a2a77e405f4cfd0613 2875787ecf2743a2a77e405f4cfd0613--d06998c722c4410cb5e59e1fe4f6292c caae506995b0461689b84dc6e0f74edb 2875787ecf2743a2a77e405f4cfd0613--caae506995b0461689b84dc6e0f74edb f2d335fed0214d25894d547d389990f8 caae506995b0461689b84dc6e0f74edb--f2d335fed0214d25894d547d389990f8 07f43f5263ef4cd692869954db74cdb5 f2d335fed0214d25894d547d389990f8--07f43f5263ef4cd692869954db74cdb5 6747d1ca01864060b329df0012e7ee1e 07f43f5263ef4cd692869954db74cdb5--6747d1ca01864060b329df0012e7ee1e 72900c8a5d49488daafff303e2229f47 6747d1ca01864060b329df0012e7ee1e--72900c8a5d49488daafff303e2229f47 83c665f250a64926bffb6ed2ee2107c9 X 72900c8a5d49488daafff303e2229f47--83c665f250a64926bffb6ed2ee2107c9 83c665f250a64926bffb6ed2ee2107c9--bb4ef629a0b048a8b87cafad3834cc6e c3b08721c76d44508ef547081d41f83f 83c665f250a64926bffb6ed2ee2107c9--c3b08721c76d44508ef547081d41f83f ffd175decf0b4a0abb49babe016d47cf c3b08721c76d44508ef547081d41f83f--ffd175decf0b4a0abb49babe016d47cf 660e7245ee134feea939cc871ad0a163 ffd175decf0b4a0abb49babe016d47cf--660e7245ee134feea939cc871ad0a163 7dbfada9cf934a0684711c5ec084e6a2 660e7245ee134feea939cc871ad0a163--7dbfada9cf934a0684711c5ec084e6a2 5c136df1a30b4b61987c9fd361be916f X 7dbfada9cf934a0684711c5ec084e6a2--5c136df1a30b4b61987c9fd361be916f 5c136df1a30b4b61987c9fd361be916f--3199d965623c4989b59893657bb58a70 a4f1df8877144083ad65e5b9cb4f3605 5c136df1a30b4b61987c9fd361be916f--a4f1df8877144083ad65e5b9cb4f3605 9e483b43a64e4761a53240f2b08b1e54 a4f1df8877144083ad65e5b9cb4f3605--9e483b43a64e4761a53240f2b08b1e54 a527d049a4d1496ea2b2affd720010a3 9e483b43a64e4761a53240f2b08b1e54--a527d049a4d1496ea2b2affd720010a3 54abe21115104c4888faed91955197b3 a527d049a4d1496ea2b2affd720010a3--54abe21115104c4888faed91955197b3 76f9a36be40a4245adac93055ad3099a 54abe21115104c4888faed91955197b3--76f9a36be40a4245adac93055ad3099a d8d54eed90514df4adaa6fc983f2d84b 76f9a36be40a4245adac93055ad3099a--d8d54eed90514df4adaa6fc983f2d84b dd5d3137a0094522a9bb4e79c9f31605 d8d54eed90514df4adaa6fc983f2d84b--dd5d3137a0094522a9bb4e79c9f31605 8aa8619b604e46f4b393f7b4e82e4664 dd5d3137a0094522a9bb4e79c9f31605--8aa8619b604e46f4b393f7b4e82e4664 5db504f5b8594d2383ddd778f51c42e7 8aa8619b604e46f4b393f7b4e82e4664--5db504f5b8594d2383ddd778f51c42e7 c1d912172992470bbaf3f2ffe52c208a X 5db504f5b8594d2383ddd778f51c42e7--c1d912172992470bbaf3f2ffe52c208a c1d912172992470bbaf3f2ffe52c208a--532ac30d1d9b4c08b6115b600f526227 6340922723264e5bbcb3589cfe24d2e6 c1d912172992470bbaf3f2ffe52c208a--6340922723264e5bbcb3589cfe24d2e6 06578b4439fe4d97af94c946a351bf9e 6340922723264e5bbcb3589cfe24d2e6--06578b4439fe4d97af94c946a351bf9e f8a76ac3040b4e39a0152b0bbc863305 06578b4439fe4d97af94c946a351bf9e--f8a76ac3040b4e39a0152b0bbc863305 6280271eb8b84f51aa1058ad1e725e1a X f8a76ac3040b4e39a0152b0bbc863305--6280271eb8b84f51aa1058ad1e725e1a 6280271eb8b84f51aa1058ad1e725e1a--4d91299e5e32460ca2b147a2336acb33 b82770d890c14ae1ab83722e7c363383 6280271eb8b84f51aa1058ad1e725e1a--b82770d890c14ae1ab83722e7c363383 145557592da244e0a4dd493f71fbb68c b82770d890c14ae1ab83722e7c363383--145557592da244e0a4dd493f71fbb68c b7244caf180b4736a4f0569ab016d333 145557592da244e0a4dd493f71fbb68c--b7244caf180b4736a4f0569ab016d333 a1a1db2a54d34add842baddc9e4746c8 X b7244caf180b4736a4f0569ab016d333--a1a1db2a54d34add842baddc9e4746c8 a1a1db2a54d34add842baddc9e4746c8--bfb0e55399da45e1b4535736cb203961 1623ff3efbf840e2b91114bd3d81f6f5 a1a1db2a54d34add842baddc9e4746c8--1623ff3efbf840e2b91114bd3d81f6f5 471b3b281ad74d72a756cfcf9425812f 1623ff3efbf840e2b91114bd3d81f6f5--471b3b281ad74d72a756cfcf9425812f 0d107ae0ab724b44b7fc6d9f72bdb4b1 471b3b281ad74d72a756cfcf9425812f--0d107ae0ab724b44b7fc6d9f72bdb4b1 c94f4b5773854c8f8fa299a448fabbe8 0d107ae0ab724b44b7fc6d9f72bdb4b1--c94f4b5773854c8f8fa299a448fabbe8 6ee534ec2eaa41aeb5b407d620266796 c94f4b5773854c8f8fa299a448fabbe8--6ee534ec2eaa41aeb5b407d620266796 9a2f712c341a4faba12f74cd8b1fb7f3 6ee534ec2eaa41aeb5b407d620266796--9a2f712c341a4faba12f74cd8b1fb7f3 f3240f141b994408b3af2d2ee631f01a 9a2f712c341a4faba12f74cd8b1fb7f3--f3240f141b994408b3af2d2ee631f01a 82fa127dd07c406080644e2a64df5329 f3240f141b994408b3af2d2ee631f01a--82fa127dd07c406080644e2a64df5329 3a2bda0bc5984ac48583cb0cc0621b5a 82fa127dd07c406080644e2a64df5329--3a2bda0bc5984ac48583cb0cc0621b5a 44887e26fbb440db90f3d397f5a0ae94 3a2bda0bc5984ac48583cb0cc0621b5a--44887e26fbb440db90f3d397f5a0ae94 806a6f94a2734c33b8d2f1dc740f4e5b 44887e26fbb440db90f3d397f5a0ae94--806a6f94a2734c33b8d2f1dc740f4e5b 88188c0a5258463bbd1a6d55d715bf82 806a6f94a2734c33b8d2f1dc740f4e5b--88188c0a5258463bbd1a6d55d715bf82 aa3f5f1f4e5a4f14a3d204211a387979 88188c0a5258463bbd1a6d55d715bf82--aa3f5f1f4e5a4f14a3d204211a387979 05641afc32d34e9da02468fa5ee9a862 aa3f5f1f4e5a4f14a3d204211a387979--05641afc32d34e9da02468fa5ee9a862 61106738017f4e4e9e6eb346056f4e0a 05641afc32d34e9da02468fa5ee9a862--61106738017f4e4e9e6eb346056f4e0a fcc1a05a2df3495ab2fb0142001c46df 61106738017f4e4e9e6eb346056f4e0a--fcc1a05a2df3495ab2fb0142001c46df 0e89bc8540c24aabb41f0a81ddf98e95 fcc1a05a2df3495ab2fb0142001c46df--0e89bc8540c24aabb41f0a81ddf98e95 1f154cf36724433198e41bdab7b1508f 0e89bc8540c24aabb41f0a81ddf98e95--1f154cf36724433198e41bdab7b1508f 8f1f430f59b14142a430d812023128d5 1f154cf36724433198e41bdab7b1508f--8f1f430f59b14142a430d812023128d5 b8673a94286d4e818e52c640de39a0f5 8f1f430f59b14142a430d812023128d5--b8673a94286d4e818e52c640de39a0f5 d9df1977a4274bf8a32b77ef96e48cde b8673a94286d4e818e52c640de39a0f5--d9df1977a4274bf8a32b77ef96e48cde 86e7370698ab45d9b389570df1f50f33 d9df1977a4274bf8a32b77ef96e48cde--86e7370698ab45d9b389570df1f50f33 ac6e57ee55024b5382f720ddf0fefa5e 86e7370698ab45d9b389570df1f50f33--ac6e57ee55024b5382f720ddf0fefa5e 49af206b69024f7d8015dcaeb1539440 ac6e57ee55024b5382f720ddf0fefa5e--49af206b69024f7d8015dcaeb1539440 19079187a0ab4da7ad461ecdad7de47e 49af206b69024f7d8015dcaeb1539440--19079187a0ab4da7ad461ecdad7de47e 521eeef4054a4b92bcd2bea5813e1259 19079187a0ab4da7ad461ecdad7de47e--521eeef4054a4b92bcd2bea5813e1259 ce9364d1c8fd421ab1cd305881f53c00 521eeef4054a4b92bcd2bea5813e1259--ce9364d1c8fd421ab1cd305881f53c00 1a654d0d8abb48bea3fe3e706e97d07b ce9364d1c8fd421ab1cd305881f53c00--1a654d0d8abb48bea3fe3e706e97d07b 6dfbb51a6b144e07b7b18f1bd5a14384 RX(b13) 1a654d0d8abb48bea3fe3e706e97d07b--6dfbb51a6b144e07b7b18f1bd5a14384 6dfbb51a6b144e07b7b18f1bd5a14384--04e90fbf31214999bfa6a31488617e45 1f5b2184ec1040eab1b5a25e482c0dc7 d8cafac480f540f5b444875bcdfe5af7 2dd76002b3e94c2db24cdeb36490ab4c--d8cafac480f540f5b444875bcdfe5af7 d5f6c2c813c94b8c85fa88bad6facaf0 5 1b833c6215d645b7ab3de004551295a9 d8cafac480f540f5b444875bcdfe5af7--1b833c6215d645b7ab3de004551295a9 4c39dabe9abd4740972108eebd929692 1b833c6215d645b7ab3de004551295a9--4c39dabe9abd4740972108eebd929692 330b94a4ff814e32b70f1eaf50381d0e X 4c39dabe9abd4740972108eebd929692--330b94a4ff814e32b70f1eaf50381d0e 330b94a4ff814e32b70f1eaf50381d0e--33877cefdb04440c98f8ee945106ca7e bac37d43321f42eaab17ec6033df14a6 330b94a4ff814e32b70f1eaf50381d0e--bac37d43321f42eaab17ec6033df14a6 33b1a07560084ca7b32c567b6433298b bac37d43321f42eaab17ec6033df14a6--33b1a07560084ca7b32c567b6433298b 7b8f850717a94d0492bce0f869ecb700 33b1a07560084ca7b32c567b6433298b--7b8f850717a94d0492bce0f869ecb700 a540bfed206d4e05b74b1df76e55976c 7b8f850717a94d0492bce0f869ecb700--a540bfed206d4e05b74b1df76e55976c b323e499b011421ba0cbfc05b9caea49 a540bfed206d4e05b74b1df76e55976c--b323e499b011421ba0cbfc05b9caea49 e437feadd6f74350aa437e0d915c7b67 b323e499b011421ba0cbfc05b9caea49--e437feadd6f74350aa437e0d915c7b67 73349906278c40e2ab9837c74ee7beca e437feadd6f74350aa437e0d915c7b67--73349906278c40e2ab9837c74ee7beca 40020ba232d647448e5576616b0da0b5 X 73349906278c40e2ab9837c74ee7beca--40020ba232d647448e5576616b0da0b5 40020ba232d647448e5576616b0da0b5--ce5afb88b99f43d8a8294cb9c7165b0f 005a6918440b44ddbf5fee70ece9a68e 40020ba232d647448e5576616b0da0b5--005a6918440b44ddbf5fee70ece9a68e 933639eda8c9475b80f916e63c287cbb 005a6918440b44ddbf5fee70ece9a68e--933639eda8c9475b80f916e63c287cbb cecccbd495c64480aea6268c8cb65963 933639eda8c9475b80f916e63c287cbb--cecccbd495c64480aea6268c8cb65963 e492914b7c8442c69b5968dfef671bbd cecccbd495c64480aea6268c8cb65963--e492914b7c8442c69b5968dfef671bbd e9e6937773434c42b0f56d93a545bc7f e492914b7c8442c69b5968dfef671bbd--e9e6937773434c42b0f56d93a545bc7f 786877437fa540d590d1c0982a9d49e5 e9e6937773434c42b0f56d93a545bc7f--786877437fa540d590d1c0982a9d49e5 8f2cd6793c6d48f8807ece225f311b8e 786877437fa540d590d1c0982a9d49e5--8f2cd6793c6d48f8807ece225f311b8e 37bc413bfb8e47fcac7fbd2525b25ee4 8f2cd6793c6d48f8807ece225f311b8e--37bc413bfb8e47fcac7fbd2525b25ee4 0d37d9569090450580e34ba57e04c0e9 37bc413bfb8e47fcac7fbd2525b25ee4--0d37d9569090450580e34ba57e04c0e9 629a37f4c53c470da26e27b83d6d4cab X 0d37d9569090450580e34ba57e04c0e9--629a37f4c53c470da26e27b83d6d4cab 629a37f4c53c470da26e27b83d6d4cab--23ace5fe77ac44d9a086b331312f6a6b f1a863529e974b69aae3848988855b37 629a37f4c53c470da26e27b83d6d4cab--f1a863529e974b69aae3848988855b37 252968dacfa241df84103eb9833592aa f1a863529e974b69aae3848988855b37--252968dacfa241df84103eb9833592aa 527a37eb216843acb1e6f6dce60238d5 252968dacfa241df84103eb9833592aa--527a37eb216843acb1e6f6dce60238d5 6da11de89bdb494b9a639ab4efb84be1 X 527a37eb216843acb1e6f6dce60238d5--6da11de89bdb494b9a639ab4efb84be1 6da11de89bdb494b9a639ab4efb84be1--5aef9fbe3ef94f5f89277e09f7922880 a3de7bea8a644ec7bd31e40abf62e98c 6da11de89bdb494b9a639ab4efb84be1--a3de7bea8a644ec7bd31e40abf62e98c 66236f1532e549a9bac2018e37f36408 a3de7bea8a644ec7bd31e40abf62e98c--66236f1532e549a9bac2018e37f36408 d1ed7c8764cc4e65b04ddc022578588d 66236f1532e549a9bac2018e37f36408--d1ed7c8764cc4e65b04ddc022578588d d1ee330829064eec8ce145c5b953f7d3 d1ed7c8764cc4e65b04ddc022578588d--d1ee330829064eec8ce145c5b953f7d3 37176a5f2078422c8991d67bf61ff069 d1ee330829064eec8ce145c5b953f7d3--37176a5f2078422c8991d67bf61ff069 bfeca94cc9704c3a868ef5125232241a 37176a5f2078422c8991d67bf61ff069--bfeca94cc9704c3a868ef5125232241a 40492f44bc7241b89f14b97ebcc5eda7 X bfeca94cc9704c3a868ef5125232241a--40492f44bc7241b89f14b97ebcc5eda7 40492f44bc7241b89f14b97ebcc5eda7--7a3f5372cd1e4bae890ae2d9a68952a8 806bdee53200489c9fd01317569d1360 40492f44bc7241b89f14b97ebcc5eda7--806bdee53200489c9fd01317569d1360 981430f40b9d432383ac782fcab908a6 806bdee53200489c9fd01317569d1360--981430f40b9d432383ac782fcab908a6 bb56467133d648eeafd053d65d77c88e 981430f40b9d432383ac782fcab908a6--bb56467133d648eeafd053d65d77c88e ef0868bd830d4f179ba196626ee8be6a bb56467133d648eeafd053d65d77c88e--ef0868bd830d4f179ba196626ee8be6a f4c735a44e304fa08f38b0446cedd93f ef0868bd830d4f179ba196626ee8be6a--f4c735a44e304fa08f38b0446cedd93f cad175ad844e47edba2a856b6c2c683a f4c735a44e304fa08f38b0446cedd93f--cad175ad844e47edba2a856b6c2c683a 70ab77971fca4d09ac9244daaee27cbe cad175ad844e47edba2a856b6c2c683a--70ab77971fca4d09ac9244daaee27cbe b6f660ba54dc4f679f29b8b6bf14397c X 70ab77971fca4d09ac9244daaee27cbe--b6f660ba54dc4f679f29b8b6bf14397c b6f660ba54dc4f679f29b8b6bf14397c--fe6ac7fecb0f435da110258c5378930f 1a1d7b91b7c64a288cfe7fe59945f068 b6f660ba54dc4f679f29b8b6bf14397c--1a1d7b91b7c64a288cfe7fe59945f068 0f272e585e0f47e29d410f7c9c0f46b5 1a1d7b91b7c64a288cfe7fe59945f068--0f272e585e0f47e29d410f7c9c0f46b5 5166cda177b143219a094fa822ac5829 0f272e585e0f47e29d410f7c9c0f46b5--5166cda177b143219a094fa822ac5829 6ec86407fc604eda8917783c22d3b52f 5166cda177b143219a094fa822ac5829--6ec86407fc604eda8917783c22d3b52f c3e6a855307b438c835aeda9daf0f61a 6ec86407fc604eda8917783c22d3b52f--c3e6a855307b438c835aeda9daf0f61a 818ccb126b7d4b63904914cdd92200ce X c3e6a855307b438c835aeda9daf0f61a--818ccb126b7d4b63904914cdd92200ce 818ccb126b7d4b63904914cdd92200ce--baf4897290644b35b0e5771a6c2a7a69 d6623a293811490d917bbce14c2da74f RZ(-1.0*g0) 818ccb126b7d4b63904914cdd92200ce--d6623a293811490d917bbce14c2da74f cf946c1c8cf94dddac5e5aaf0fd745f8 X d6623a293811490d917bbce14c2da74f--cf946c1c8cf94dddac5e5aaf0fd745f8 cf946c1c8cf94dddac5e5aaf0fd745f8--743688277b89494480ab3664515f320b 7132efb69db5445c91aae40e47ec239f cf946c1c8cf94dddac5e5aaf0fd745f8--7132efb69db5445c91aae40e47ec239f b2b218e6d41448649f2a876c6e1fd961 7132efb69db5445c91aae40e47ec239f--b2b218e6d41448649f2a876c6e1fd961 654f612b27e345b7ae27107a39c007da X b2b218e6d41448649f2a876c6e1fd961--654f612b27e345b7ae27107a39c007da 654f612b27e345b7ae27107a39c007da--7a1cd62bd55a47eba933105c269a3cca a1525144b83343ca84460a5b2a6cd7b0 RZ(-1.0*g0) 654f612b27e345b7ae27107a39c007da--a1525144b83343ca84460a5b2a6cd7b0 aca718a1bc5543e19242bd2033c6cc7c X a1525144b83343ca84460a5b2a6cd7b0--aca718a1bc5543e19242bd2033c6cc7c aca718a1bc5543e19242bd2033c6cc7c--35c5f2b776414ef9baa1c11c196305a1 cbfd56f673434b838f289ebb4fbf342e X aca718a1bc5543e19242bd2033c6cc7c--cbfd56f673434b838f289ebb4fbf342e cbfd56f673434b838f289ebb4fbf342e--7f1ad8f190224896b3be867e89af2d58 9e063581c93b4aff899a2aa1edcae5ef cbfd56f673434b838f289ebb4fbf342e--9e063581c93b4aff899a2aa1edcae5ef fd9cc09895f34cfaad58c979eb33c0c0 9e063581c93b4aff899a2aa1edcae5ef--fd9cc09895f34cfaad58c979eb33c0c0 f6a808d39f684634b78dafb9d3ab90eb fd9cc09895f34cfaad58c979eb33c0c0--f6a808d39f684634b78dafb9d3ab90eb dadb8ab4b8e849e4897bd7a605eeaf07 X f6a808d39f684634b78dafb9d3ab90eb--dadb8ab4b8e849e4897bd7a605eeaf07 dadb8ab4b8e849e4897bd7a605eeaf07--f40777486aab485682552e83ecbfee60 a9c7410e7fae49dd992720dfc7d35108 X dadb8ab4b8e849e4897bd7a605eeaf07--a9c7410e7fae49dd992720dfc7d35108 a9c7410e7fae49dd992720dfc7d35108--c021e41c11aa483aa36ed66909ef7c56 5f81c571d8214db2bad2a6ee17de86f0 a9c7410e7fae49dd992720dfc7d35108--5f81c571d8214db2bad2a6ee17de86f0 cde46e39034a45a3a333bb12c2bcc8b9 5f81c571d8214db2bad2a6ee17de86f0--cde46e39034a45a3a333bb12c2bcc8b9 5a412149833e4ce78c35fff19c56d55d cde46e39034a45a3a333bb12c2bcc8b9--5a412149833e4ce78c35fff19c56d55d 6ac7fa36f18d40e29c351110c06b13bd 5a412149833e4ce78c35fff19c56d55d--6ac7fa36f18d40e29c351110c06b13bd b5962f06440d42ef85b0e19714381abe 6ac7fa36f18d40e29c351110c06b13bd--b5962f06440d42ef85b0e19714381abe 722bb04fb8734aa5b26910f805e9ebe4 X b5962f06440d42ef85b0e19714381abe--722bb04fb8734aa5b26910f805e9ebe4 722bb04fb8734aa5b26910f805e9ebe4--c734941330a24e0680f18231f05eb7e6 d068ba07eeb246799cea3bd08ab0aec3 X 722bb04fb8734aa5b26910f805e9ebe4--d068ba07eeb246799cea3bd08ab0aec3 d068ba07eeb246799cea3bd08ab0aec3--2f639580ac4843c3ad6cea6094a1d635 3ae2099718f540c1918038a5ed774818 d068ba07eeb246799cea3bd08ab0aec3--3ae2099718f540c1918038a5ed774818 80ed5f48c3c145f8b4a46e006790699c 3ae2099718f540c1918038a5ed774818--80ed5f48c3c145f8b4a46e006790699c 0115e48694ec4ce08654501a4dd3f896 80ed5f48c3c145f8b4a46e006790699c--0115e48694ec4ce08654501a4dd3f896 0ea9d84436a840d393534fe7e93c5da4 0115e48694ec4ce08654501a4dd3f896--0ea9d84436a840d393534fe7e93c5da4 165e8c6e068b4b2ebf885c565ef995ea 0ea9d84436a840d393534fe7e93c5da4--165e8c6e068b4b2ebf885c565ef995ea 30e77f3638f740a39abe1f4f729e8d61 165e8c6e068b4b2ebf885c565ef995ea--30e77f3638f740a39abe1f4f729e8d61 f97f48dc053d40c3b4fa6d281c707aa9 30e77f3638f740a39abe1f4f729e8d61--f97f48dc053d40c3b4fa6d281c707aa9 44ee3aa03bd842cf89ccf5346ff5e929 X f97f48dc053d40c3b4fa6d281c707aa9--44ee3aa03bd842cf89ccf5346ff5e929 44ee3aa03bd842cf89ccf5346ff5e929--83d67288db854f569ed09c9fcf082fb6 30e7f3ecddb247f4ab1df21a960bb255 44ee3aa03bd842cf89ccf5346ff5e929--30e7f3ecddb247f4ab1df21a960bb255 0c02563fa4874444bc75b855187512b6 30e7f3ecddb247f4ab1df21a960bb255--0c02563fa4874444bc75b855187512b6 5a9fa9b1f7d74261a1e280158801cb7f 0c02563fa4874444bc75b855187512b6--5a9fa9b1f7d74261a1e280158801cb7f 030836ea8ab24533924b01777eba8ecf RX(b04) 5a9fa9b1f7d74261a1e280158801cb7f--030836ea8ab24533924b01777eba8ecf 1988f9f1cce240f8905dbb993422a580 030836ea8ab24533924b01777eba8ecf--1988f9f1cce240f8905dbb993422a580 34f29547871745fd9e39d329918fa306 1988f9f1cce240f8905dbb993422a580--34f29547871745fd9e39d329918fa306 cdd30955ebc04dc09911486412e9bd13 34f29547871745fd9e39d329918fa306--cdd30955ebc04dc09911486412e9bd13 3ef18608b87044bbbf453f8a5cd6d57a X cdd30955ebc04dc09911486412e9bd13--3ef18608b87044bbbf453f8a5cd6d57a 3ef18608b87044bbbf453f8a5cd6d57a--d1a3f4f56ced4db8af9746ce985cf69d d2d99ae66f5a4031a23f14fbf0a5d9a5 3ef18608b87044bbbf453f8a5cd6d57a--d2d99ae66f5a4031a23f14fbf0a5d9a5 d7e64c154f3945d9a242ed519f5e1f23 d2d99ae66f5a4031a23f14fbf0a5d9a5--d7e64c154f3945d9a242ed519f5e1f23 ae3f7354ee714765aebffd2b87d73f3b d7e64c154f3945d9a242ed519f5e1f23--ae3f7354ee714765aebffd2b87d73f3b d3ed487152524255b8fb92013452b5bd ae3f7354ee714765aebffd2b87d73f3b--d3ed487152524255b8fb92013452b5bd 52aeee04b93f4e578774c47bb1c350da d3ed487152524255b8fb92013452b5bd--52aeee04b93f4e578774c47bb1c350da 50de3f03028e4df2add4f8c7ae6d1e08 52aeee04b93f4e578774c47bb1c350da--50de3f03028e4df2add4f8c7ae6d1e08 45daa88328ce41b6bbdbe2095b9f99a8 50de3f03028e4df2add4f8c7ae6d1e08--45daa88328ce41b6bbdbe2095b9f99a8 bac37bce16fe4810be497c0747ef1e74 X 45daa88328ce41b6bbdbe2095b9f99a8--bac37bce16fe4810be497c0747ef1e74 bac37bce16fe4810be497c0747ef1e74--b0d23a206caa420dbaef5213bb50e2e8 88ec3b91944246f2a1f15c79c5ef4ba5 bac37bce16fe4810be497c0747ef1e74--88ec3b91944246f2a1f15c79c5ef4ba5 535d9475f9d9461c9e3d937d6b5a415a 88ec3b91944246f2a1f15c79c5ef4ba5--535d9475f9d9461c9e3d937d6b5a415a 04c5fdc22f3d47aea5e43d7b2c14482e 535d9475f9d9461c9e3d937d6b5a415a--04c5fdc22f3d47aea5e43d7b2c14482e 262f3248f86a467e84b0323773d007e3 04c5fdc22f3d47aea5e43d7b2c14482e--262f3248f86a467e84b0323773d007e3 f0adf5af9ba849d29dc4df235495cc6b 262f3248f86a467e84b0323773d007e3--f0adf5af9ba849d29dc4df235495cc6b 5883861122674aeea283d3b0bdbda557 f0adf5af9ba849d29dc4df235495cc6b--5883861122674aeea283d3b0bdbda557 d3482b84231e4049a6ea2155fecb3b28 5883861122674aeea283d3b0bdbda557--d3482b84231e4049a6ea2155fecb3b28 f4203304593c4f6e9bde7fc7b01d2c31 d3482b84231e4049a6ea2155fecb3b28--f4203304593c4f6e9bde7fc7b01d2c31 03a2335c05794768b3a9325131416acd f4203304593c4f6e9bde7fc7b01d2c31--03a2335c05794768b3a9325131416acd 138774c7c7754ec4ba83324950c5c299 X 03a2335c05794768b3a9325131416acd--138774c7c7754ec4ba83324950c5c299 138774c7c7754ec4ba83324950c5c299--caae506995b0461689b84dc6e0f74edb 63a7892f1762437fb24ce8cefc85164e 138774c7c7754ec4ba83324950c5c299--63a7892f1762437fb24ce8cefc85164e 5ca76627d7404ca2bbadf55e2e3641dc 63a7892f1762437fb24ce8cefc85164e--5ca76627d7404ca2bbadf55e2e3641dc 1bd60a24c1cd4463b8e11f90f537c0cf 5ca76627d7404ca2bbadf55e2e3641dc--1bd60a24c1cd4463b8e11f90f537c0cf 55b6d413ad55400c8553e3035708e23c X 1bd60a24c1cd4463b8e11f90f537c0cf--55b6d413ad55400c8553e3035708e23c 55b6d413ad55400c8553e3035708e23c--72900c8a5d49488daafff303e2229f47 9cd6927e6b2d4cf3a1599c47138607d5 55b6d413ad55400c8553e3035708e23c--9cd6927e6b2d4cf3a1599c47138607d5 3baf89075b6b47c7a724277727081927 9cd6927e6b2d4cf3a1599c47138607d5--3baf89075b6b47c7a724277727081927 5732c85f3ec5406d841445021399739e 3baf89075b6b47c7a724277727081927--5732c85f3ec5406d841445021399739e 7f4c7627f9d64bd89580ecf4a728b77e 5732c85f3ec5406d841445021399739e--7f4c7627f9d64bd89580ecf4a728b77e e32ae1b79e974eb2ade68d3920b6c9d7 7f4c7627f9d64bd89580ecf4a728b77e--e32ae1b79e974eb2ade68d3920b6c9d7 9eb2ef7112d24f8bbfc62efe2125ff77 e32ae1b79e974eb2ade68d3920b6c9d7--9eb2ef7112d24f8bbfc62efe2125ff77 b68370195d0c44529afe93444b0169ea X 9eb2ef7112d24f8bbfc62efe2125ff77--b68370195d0c44529afe93444b0169ea b68370195d0c44529afe93444b0169ea--a4f1df8877144083ad65e5b9cb4f3605 696bf16b4bc54199ae36d89324e573c9 b68370195d0c44529afe93444b0169ea--696bf16b4bc54199ae36d89324e573c9 0550764d613f4857a7337277c0aa435b 696bf16b4bc54199ae36d89324e573c9--0550764d613f4857a7337277c0aa435b 79c7a671de6c4afa9ca6e6feb7b51514 0550764d613f4857a7337277c0aa435b--79c7a671de6c4afa9ca6e6feb7b51514 946582b21b864caea858ef196851022c 79c7a671de6c4afa9ca6e6feb7b51514--946582b21b864caea858ef196851022c ef376bcc3fb44ff9b563285dd23729ae 946582b21b864caea858ef196851022c--ef376bcc3fb44ff9b563285dd23729ae d51e5944b00442d1927b5ffe6c128a76 ef376bcc3fb44ff9b563285dd23729ae--d51e5944b00442d1927b5ffe6c128a76 1ed0a84ab83148958fd4ffbce2fb628b d51e5944b00442d1927b5ffe6c128a76--1ed0a84ab83148958fd4ffbce2fb628b a7ef92b6f2f64f6fae00f2913d057e24 X 1ed0a84ab83148958fd4ffbce2fb628b--a7ef92b6f2f64f6fae00f2913d057e24 a7ef92b6f2f64f6fae00f2913d057e24--5db504f5b8594d2383ddd778f51c42e7 4183c278a9f949dead916c6881714ac8 a7ef92b6f2f64f6fae00f2913d057e24--4183c278a9f949dead916c6881714ac8 cff77f9fe55645a59e4888e68167b414 4183c278a9f949dead916c6881714ac8--cff77f9fe55645a59e4888e68167b414 5c53d6c32cb94474abe42f19c999e1a4 cff77f9fe55645a59e4888e68167b414--5c53d6c32cb94474abe42f19c999e1a4 f3855f9021e94da5ac3cc141647e8df0 5c53d6c32cb94474abe42f19c999e1a4--f3855f9021e94da5ac3cc141647e8df0 4e73c1364b404afcbaf44302d63a95cf f3855f9021e94da5ac3cc141647e8df0--4e73c1364b404afcbaf44302d63a95cf 1c3f2927a85049f0bad71190413e5db3 X 4e73c1364b404afcbaf44302d63a95cf--1c3f2927a85049f0bad71190413e5db3 1c3f2927a85049f0bad71190413e5db3--b82770d890c14ae1ab83722e7c363383 6d4fba5437eb44e5849dd0f6fb255380 RZ(-1.0*g1) 1c3f2927a85049f0bad71190413e5db3--6d4fba5437eb44e5849dd0f6fb255380 0638831ef8174324a9d29a7bf9e88113 X 6d4fba5437eb44e5849dd0f6fb255380--0638831ef8174324a9d29a7bf9e88113 0638831ef8174324a9d29a7bf9e88113--b7244caf180b4736a4f0569ab016d333 dca692d57c1445cf97ed2bb1458383a6 0638831ef8174324a9d29a7bf9e88113--dca692d57c1445cf97ed2bb1458383a6 c880c647049043719fb4aaa99d93314e dca692d57c1445cf97ed2bb1458383a6--c880c647049043719fb4aaa99d93314e a9fa1355f4b242bdafe4d7602bed3ec3 X c880c647049043719fb4aaa99d93314e--a9fa1355f4b242bdafe4d7602bed3ec3 a9fa1355f4b242bdafe4d7602bed3ec3--471b3b281ad74d72a756cfcf9425812f 963b58b6546f44e7b9f5244c5c1edce2 RZ(-1.0*g1) a9fa1355f4b242bdafe4d7602bed3ec3--963b58b6546f44e7b9f5244c5c1edce2 b37fd1d77af34ad4b150af6125e4ca75 X 963b58b6546f44e7b9f5244c5c1edce2--b37fd1d77af34ad4b150af6125e4ca75 b37fd1d77af34ad4b150af6125e4ca75--c94f4b5773854c8f8fa299a448fabbe8 6960a5932b374acdab23414ec797bcbd X b37fd1d77af34ad4b150af6125e4ca75--6960a5932b374acdab23414ec797bcbd 6960a5932b374acdab23414ec797bcbd--6ee534ec2eaa41aeb5b407d620266796 766bc835589f40ae9c94620afb65042b 6960a5932b374acdab23414ec797bcbd--766bc835589f40ae9c94620afb65042b c9e27a23c7be4631a207042150e7986f 766bc835589f40ae9c94620afb65042b--c9e27a23c7be4631a207042150e7986f 01e4911692e84a298d7c284c5737e205 c9e27a23c7be4631a207042150e7986f--01e4911692e84a298d7c284c5737e205 e3ab0f16aa86421bae38363358f6062c X 01e4911692e84a298d7c284c5737e205--e3ab0f16aa86421bae38363358f6062c e3ab0f16aa86421bae38363358f6062c--3a2bda0bc5984ac48583cb0cc0621b5a 9ae161ad08fa4574a4facd69cd319b1b X e3ab0f16aa86421bae38363358f6062c--9ae161ad08fa4574a4facd69cd319b1b 9ae161ad08fa4574a4facd69cd319b1b--44887e26fbb440db90f3d397f5a0ae94 7103cf29549e4ef7a4ef0ed5b7c8cfc3 9ae161ad08fa4574a4facd69cd319b1b--7103cf29549e4ef7a4ef0ed5b7c8cfc3 5dae7826bf5b4c079127cd7b2efc6475 7103cf29549e4ef7a4ef0ed5b7c8cfc3--5dae7826bf5b4c079127cd7b2efc6475 aaaa61eb652a401f9bbde86cd992fbea 5dae7826bf5b4c079127cd7b2efc6475--aaaa61eb652a401f9bbde86cd992fbea 5fd4d3a6456a423f8d73fa55fa3887a5 aaaa61eb652a401f9bbde86cd992fbea--5fd4d3a6456a423f8d73fa55fa3887a5 9d976f6f6e4f443caeb9571a38da7e97 5fd4d3a6456a423f8d73fa55fa3887a5--9d976f6f6e4f443caeb9571a38da7e97 f7cde36f089a47f8867635cc329bd9de X 9d976f6f6e4f443caeb9571a38da7e97--f7cde36f089a47f8867635cc329bd9de f7cde36f089a47f8867635cc329bd9de--fcc1a05a2df3495ab2fb0142001c46df 0916feaa99734d9eb1ab26d08c8e060e X f7cde36f089a47f8867635cc329bd9de--0916feaa99734d9eb1ab26d08c8e060e 0916feaa99734d9eb1ab26d08c8e060e--0e89bc8540c24aabb41f0a81ddf98e95 b78a362db286448897567f06d78ebc4d 0916feaa99734d9eb1ab26d08c8e060e--b78a362db286448897567f06d78ebc4d 018b68587a2e47c6befb7bd28bd509f2 b78a362db286448897567f06d78ebc4d--018b68587a2e47c6befb7bd28bd509f2 6dee3a322e5540bfb0183b48d3e0f0f5 018b68587a2e47c6befb7bd28bd509f2--6dee3a322e5540bfb0183b48d3e0f0f5 8f5a7661d7f24dbb862b4135627e806b 6dee3a322e5540bfb0183b48d3e0f0f5--8f5a7661d7f24dbb862b4135627e806b 0d7ac71c42604f96a1de5ac6ddac48df 8f5a7661d7f24dbb862b4135627e806b--0d7ac71c42604f96a1de5ac6ddac48df 6f02c4fa2a794c4fb5e4c678b24e4363 0d7ac71c42604f96a1de5ac6ddac48df--6f02c4fa2a794c4fb5e4c678b24e4363 fae7cd101bd94b59a9f3dd3661662bb3 6f02c4fa2a794c4fb5e4c678b24e4363--fae7cd101bd94b59a9f3dd3661662bb3 550599872b034f86af4ee35379db9728 X fae7cd101bd94b59a9f3dd3661662bb3--550599872b034f86af4ee35379db9728 550599872b034f86af4ee35379db9728--19079187a0ab4da7ad461ecdad7de47e 940fdbe68cf94969a210a54d41a55f5e 550599872b034f86af4ee35379db9728--940fdbe68cf94969a210a54d41a55f5e 66fce8aa54e84c42896f5ebab831d036 940fdbe68cf94969a210a54d41a55f5e--66fce8aa54e84c42896f5ebab831d036 ebb80da097c245d5a875f4bc3c45b7c9 66fce8aa54e84c42896f5ebab831d036--ebb80da097c245d5a875f4bc3c45b7c9 d70951360edc43859b7bbecaca4ebc03 RX(b14) ebb80da097c245d5a875f4bc3c45b7c9--d70951360edc43859b7bbecaca4ebc03 d70951360edc43859b7bbecaca4ebc03--1f5b2184ec1040eab1b5a25e482c0dc7 0afb5e480f884e25b3a3be1d58ffa06c bf115c0b9a65466ca98763e726d5e4df d5f6c2c813c94b8c85fa88bad6facaf0--bf115c0b9a65466ca98763e726d5e4df 0b90b9fa81f74b1d9fa259285cdf8bea 6 14f729a5b22a45309f34e788fc7eae09 bf115c0b9a65466ca98763e726d5e4df--14f729a5b22a45309f34e788fc7eae09 f33ae787b47f4ff0a5eb91785be855cf 14f729a5b22a45309f34e788fc7eae09--f33ae787b47f4ff0a5eb91785be855cf 9102d347a82349f0869773aea0215658 f33ae787b47f4ff0a5eb91785be855cf--9102d347a82349f0869773aea0215658 8f87c152455e410ca0f4b98ead86edce X 9102d347a82349f0869773aea0215658--8f87c152455e410ca0f4b98ead86edce 8f87c152455e410ca0f4b98ead86edce--bac37d43321f42eaab17ec6033df14a6 b55ddd23e54b41a2bc2e52a6d7d156e0 8f87c152455e410ca0f4b98ead86edce--b55ddd23e54b41a2bc2e52a6d7d156e0 2ab84363404f4b0986aad80fdc7cb61e b55ddd23e54b41a2bc2e52a6d7d156e0--2ab84363404f4b0986aad80fdc7cb61e a4a77fe56a6b4cf18d2eb15de6624008 2ab84363404f4b0986aad80fdc7cb61e--a4a77fe56a6b4cf18d2eb15de6624008 33473a4ffe0642efbf36d5f98dcdf814 a4a77fe56a6b4cf18d2eb15de6624008--33473a4ffe0642efbf36d5f98dcdf814 f7032855b90a4a94b28ba95939beab52 33473a4ffe0642efbf36d5f98dcdf814--f7032855b90a4a94b28ba95939beab52 18e885fe06f04a0d8276d3a5d59ca9ea X f7032855b90a4a94b28ba95939beab52--18e885fe06f04a0d8276d3a5d59ca9ea 18e885fe06f04a0d8276d3a5d59ca9ea--73349906278c40e2ab9837c74ee7beca 34d882fba00a4bd7b4223cce2a0ee6bf 18e885fe06f04a0d8276d3a5d59ca9ea--34d882fba00a4bd7b4223cce2a0ee6bf d1bf08089cc941b5996a000f63d264b6 34d882fba00a4bd7b4223cce2a0ee6bf--d1bf08089cc941b5996a000f63d264b6 78d215dd4cb24d7fa738c4ec880bf2ac d1bf08089cc941b5996a000f63d264b6--78d215dd4cb24d7fa738c4ec880bf2ac e87551ae5edc4b2e84da7116918799b0 78d215dd4cb24d7fa738c4ec880bf2ac--e87551ae5edc4b2e84da7116918799b0 66b11a32df4b40189a3a854c9b747ec7 e87551ae5edc4b2e84da7116918799b0--66b11a32df4b40189a3a854c9b747ec7 5cd1f9fbebb44fcd92f2717f075437c7 66b11a32df4b40189a3a854c9b747ec7--5cd1f9fbebb44fcd92f2717f075437c7 004a0c3dc9d2443b9ac22f816d44291a 5cd1f9fbebb44fcd92f2717f075437c7--004a0c3dc9d2443b9ac22f816d44291a c56d4e2ffe6e4d4cac918aa212347b81 004a0c3dc9d2443b9ac22f816d44291a--c56d4e2ffe6e4d4cac918aa212347b81 568f9abf5f204ca4841278751b1f2c20 c56d4e2ffe6e4d4cac918aa212347b81--568f9abf5f204ca4841278751b1f2c20 1087ca2f381b405b9937fdb2c364cb70 568f9abf5f204ca4841278751b1f2c20--1087ca2f381b405b9937fdb2c364cb70 6b406eab544a415b8dabe30f791d7048 1087ca2f381b405b9937fdb2c364cb70--6b406eab544a415b8dabe30f791d7048 311d85d1069e413e93d62db656a7044b X 6b406eab544a415b8dabe30f791d7048--311d85d1069e413e93d62db656a7044b 311d85d1069e413e93d62db656a7044b--f1a863529e974b69aae3848988855b37 0688f7e278c44b04812390f54ad406bc RZ(-1.0*g0) 311d85d1069e413e93d62db656a7044b--0688f7e278c44b04812390f54ad406bc beaeee41fb664bdfa9e292edd2272f1f X 0688f7e278c44b04812390f54ad406bc--beaeee41fb664bdfa9e292edd2272f1f beaeee41fb664bdfa9e292edd2272f1f--527a37eb216843acb1e6f6dce60238d5 cd00dceaa02940758ef529c5d09e1e53 beaeee41fb664bdfa9e292edd2272f1f--cd00dceaa02940758ef529c5d09e1e53 0e2ba7a498774eca8e34429386beddda cd00dceaa02940758ef529c5d09e1e53--0e2ba7a498774eca8e34429386beddda cf90d1641ed7459682a1a0966a872293 0e2ba7a498774eca8e34429386beddda--cf90d1641ed7459682a1a0966a872293 ddab37a6ea494c11862dce9867dd997e cf90d1641ed7459682a1a0966a872293--ddab37a6ea494c11862dce9867dd997e b0543aa7dff7452b9dbe4c44f974a141 ddab37a6ea494c11862dce9867dd997e--b0543aa7dff7452b9dbe4c44f974a141 7bc3bfd630f243ba830739d602f89e91 b0543aa7dff7452b9dbe4c44f974a141--7bc3bfd630f243ba830739d602f89e91 1e5d84a01f7d41a2a3f2d2fdc54f41c4 7bc3bfd630f243ba830739d602f89e91--1e5d84a01f7d41a2a3f2d2fdc54f41c4 a5926fce6e1247c595b4fb7f15eda327 1e5d84a01f7d41a2a3f2d2fdc54f41c4--a5926fce6e1247c595b4fb7f15eda327 c8d409c7750c4a40b93807a3d88ab1c5 X a5926fce6e1247c595b4fb7f15eda327--c8d409c7750c4a40b93807a3d88ab1c5 c8d409c7750c4a40b93807a3d88ab1c5--806bdee53200489c9fd01317569d1360 6d3ceb02089040719719189ca8453224 c8d409c7750c4a40b93807a3d88ab1c5--6d3ceb02089040719719189ca8453224 4e887a7745134adea62914f8e0f275b6 6d3ceb02089040719719189ca8453224--4e887a7745134adea62914f8e0f275b6 47c3b59ffb654a67b868a94640f83a6c 4e887a7745134adea62914f8e0f275b6--47c3b59ffb654a67b868a94640f83a6c d0c93e9df0ba475eb887e6ee5ebc30dd 47c3b59ffb654a67b868a94640f83a6c--d0c93e9df0ba475eb887e6ee5ebc30dd 763e9d355fe84a87934809493c96f426 d0c93e9df0ba475eb887e6ee5ebc30dd--763e9d355fe84a87934809493c96f426 f966b40f938245baab8e098193e40ce0 X 763e9d355fe84a87934809493c96f426--f966b40f938245baab8e098193e40ce0 f966b40f938245baab8e098193e40ce0--70ab77971fca4d09ac9244daaee27cbe 075fb56b4bfb436dae929093cfdd5829 f966b40f938245baab8e098193e40ce0--075fb56b4bfb436dae929093cfdd5829 201854f49ac849169e24ba21a3cc0127 075fb56b4bfb436dae929093cfdd5829--201854f49ac849169e24ba21a3cc0127 df34fccb12f74d10aff5c7766cc76f79 201854f49ac849169e24ba21a3cc0127--df34fccb12f74d10aff5c7766cc76f79 dca4da366fb74072a6a376a01799f91d df34fccb12f74d10aff5c7766cc76f79--dca4da366fb74072a6a376a01799f91d 62d3e41f5eba4514acf6f0dd8dc70253 dca4da366fb74072a6a376a01799f91d--62d3e41f5eba4514acf6f0dd8dc70253 922f2429cf4042cb9324f58a43d7b483 62d3e41f5eba4514acf6f0dd8dc70253--922f2429cf4042cb9324f58a43d7b483 969e9e854b9e4ed4915b4a84b365871d 922f2429cf4042cb9324f58a43d7b483--969e9e854b9e4ed4915b4a84b365871d 611895b2b4d74909b6ee588c197bf897 969e9e854b9e4ed4915b4a84b365871d--611895b2b4d74909b6ee588c197bf897 e6206c475f734e43ba95e585168a6048 611895b2b4d74909b6ee588c197bf897--e6206c475f734e43ba95e585168a6048 6983354e79f042e7bd35e6a3da3618ef e6206c475f734e43ba95e585168a6048--6983354e79f042e7bd35e6a3da3618ef 94b2545bbdef4894b36bd18225eec3b1 6983354e79f042e7bd35e6a3da3618ef--94b2545bbdef4894b36bd18225eec3b1 8dfb101840414afe92467b5eb945123f 94b2545bbdef4894b36bd18225eec3b1--8dfb101840414afe92467b5eb945123f e47495b585da4667a6e47c6f20851fcd 8dfb101840414afe92467b5eb945123f--e47495b585da4667a6e47c6f20851fcd 02d1e74d03d04049b0c235d0dbc5a6ad e47495b585da4667a6e47c6f20851fcd--02d1e74d03d04049b0c235d0dbc5a6ad 272f6e3e7ab3453fb64f5ea1021601fe 02d1e74d03d04049b0c235d0dbc5a6ad--272f6e3e7ab3453fb64f5ea1021601fe cd4f3b974d2042cfbdf28fee8600cd0a X 272f6e3e7ab3453fb64f5ea1021601fe--cd4f3b974d2042cfbdf28fee8600cd0a cd4f3b974d2042cfbdf28fee8600cd0a--9e063581c93b4aff899a2aa1edcae5ef e3618198b1c449d28e739f83aca4bd07 RZ(-1.0*g0) cd4f3b974d2042cfbdf28fee8600cd0a--e3618198b1c449d28e739f83aca4bd07 d6878b50a96b42959c3e4bab15ce211f X e3618198b1c449d28e739f83aca4bd07--d6878b50a96b42959c3e4bab15ce211f d6878b50a96b42959c3e4bab15ce211f--f6a808d39f684634b78dafb9d3ab90eb e718877ec434455c97f63f411dd80606 d6878b50a96b42959c3e4bab15ce211f--e718877ec434455c97f63f411dd80606 068964b87cbc4a5089a0ff8330182b15 e718877ec434455c97f63f411dd80606--068964b87cbc4a5089a0ff8330182b15 33eeb9c4ac8a41139df4264cc8cd623e X 068964b87cbc4a5089a0ff8330182b15--33eeb9c4ac8a41139df4264cc8cd623e 33eeb9c4ac8a41139df4264cc8cd623e--5f81c571d8214db2bad2a6ee17de86f0 70c168d2550245ea850a6f998f3a5502 33eeb9c4ac8a41139df4264cc8cd623e--70c168d2550245ea850a6f998f3a5502 5e3e40579ec344ee920b3392c19e43ad 70c168d2550245ea850a6f998f3a5502--5e3e40579ec344ee920b3392c19e43ad f18b3f65a2c64a00a029b25b6d133e61 5e3e40579ec344ee920b3392c19e43ad--f18b3f65a2c64a00a029b25b6d133e61 a8519f8a415b47c9872b8edcf95dac75 X f18b3f65a2c64a00a029b25b6d133e61--a8519f8a415b47c9872b8edcf95dac75 a8519f8a415b47c9872b8edcf95dac75--b5962f06440d42ef85b0e19714381abe ffd06569ec594c29a443836a10867cce a8519f8a415b47c9872b8edcf95dac75--ffd06569ec594c29a443836a10867cce 7e383b1543cc4de780d2a79646fdfb44 ffd06569ec594c29a443836a10867cce--7e383b1543cc4de780d2a79646fdfb44 7bcaff56188741fea44559cfb7f910cc X 7e383b1543cc4de780d2a79646fdfb44--7bcaff56188741fea44559cfb7f910cc 7bcaff56188741fea44559cfb7f910cc--3ae2099718f540c1918038a5ed774818 67ce804d4d634a8b8ca02b0da2015dbb 7bcaff56188741fea44559cfb7f910cc--67ce804d4d634a8b8ca02b0da2015dbb 28d35098ce574c6d87f470e07c1fc804 67ce804d4d634a8b8ca02b0da2015dbb--28d35098ce574c6d87f470e07c1fc804 e66cea73677d4e90a6e3b76b0d449be7 28d35098ce574c6d87f470e07c1fc804--e66cea73677d4e90a6e3b76b0d449be7 7103643f4d5349839270a67f40e4b736 e66cea73677d4e90a6e3b76b0d449be7--7103643f4d5349839270a67f40e4b736 3c4442df0e8d4876a33da3275842b277 7103643f4d5349839270a67f40e4b736--3c4442df0e8d4876a33da3275842b277 83d2bc85192047399185f0b0bd73a8c5 X 3c4442df0e8d4876a33da3275842b277--83d2bc85192047399185f0b0bd73a8c5 83d2bc85192047399185f0b0bd73a8c5--f97f48dc053d40c3b4fa6d281c707aa9 0d57498312e24671b2cec36d6bf70a3b 83d2bc85192047399185f0b0bd73a8c5--0d57498312e24671b2cec36d6bf70a3b 7ebd94e6820340bcbfa03689f4865290 0d57498312e24671b2cec36d6bf70a3b--7ebd94e6820340bcbfa03689f4865290 517cb05d3a424df0aa3502754aa93546 7ebd94e6820340bcbfa03689f4865290--517cb05d3a424df0aa3502754aa93546 b9bfec51f930453c9ef83f497b63436d 517cb05d3a424df0aa3502754aa93546--b9bfec51f930453c9ef83f497b63436d 6d5b89bc9ad942719847d14e3aa2c9d6 RX(b05) b9bfec51f930453c9ef83f497b63436d--6d5b89bc9ad942719847d14e3aa2c9d6 2689ca44d91b4196988bba61c89acf44 6d5b89bc9ad942719847d14e3aa2c9d6--2689ca44d91b4196988bba61c89acf44 a4c447fe54dd4dcc909a5beef942fcba 2689ca44d91b4196988bba61c89acf44--a4c447fe54dd4dcc909a5beef942fcba c5435aaa7d4147f08fea0eec283c28e3 a4c447fe54dd4dcc909a5beef942fcba--c5435aaa7d4147f08fea0eec283c28e3 e6c8bd4e5b7f40f5af870a9db35108ac c5435aaa7d4147f08fea0eec283c28e3--e6c8bd4e5b7f40f5af870a9db35108ac 7dd2aedba33f4e00a592cb5821ca3c80 X e6c8bd4e5b7f40f5af870a9db35108ac--7dd2aedba33f4e00a592cb5821ca3c80 7dd2aedba33f4e00a592cb5821ca3c80--d2d99ae66f5a4031a23f14fbf0a5d9a5 e399a6851ffa4866a87af42ff645076f 7dd2aedba33f4e00a592cb5821ca3c80--e399a6851ffa4866a87af42ff645076f be65998637794507bc2a229b5b0b153c e399a6851ffa4866a87af42ff645076f--be65998637794507bc2a229b5b0b153c 672d2701c683430a93b554407a336378 be65998637794507bc2a229b5b0b153c--672d2701c683430a93b554407a336378 e58002cae9474d4eb9c9ca1055f5565a 672d2701c683430a93b554407a336378--e58002cae9474d4eb9c9ca1055f5565a adad39d697f94edba2b24d13e40a290a e58002cae9474d4eb9c9ca1055f5565a--adad39d697f94edba2b24d13e40a290a 592444868e6b4fa9a83543d16a11b019 X adad39d697f94edba2b24d13e40a290a--592444868e6b4fa9a83543d16a11b019 592444868e6b4fa9a83543d16a11b019--45daa88328ce41b6bbdbe2095b9f99a8 28023512e3e74682b1dd8957e4cb4941 592444868e6b4fa9a83543d16a11b019--28023512e3e74682b1dd8957e4cb4941 e39fd9a3bb684f47a7ac1a5fda98977b 28023512e3e74682b1dd8957e4cb4941--e39fd9a3bb684f47a7ac1a5fda98977b a35b4544fb194c94865a2cac3f4aefa0 e39fd9a3bb684f47a7ac1a5fda98977b--a35b4544fb194c94865a2cac3f4aefa0 251493c2c3a9490697e36be509c2e094 a35b4544fb194c94865a2cac3f4aefa0--251493c2c3a9490697e36be509c2e094 b42f874a0da641308637151485d8f1c0 251493c2c3a9490697e36be509c2e094--b42f874a0da641308637151485d8f1c0 d65459f101c1400c9006b31fcc8da7c9 b42f874a0da641308637151485d8f1c0--d65459f101c1400c9006b31fcc8da7c9 e21ca62997fc4a63ba7dd0135459f324 d65459f101c1400c9006b31fcc8da7c9--e21ca62997fc4a63ba7dd0135459f324 bb4354a180904b828bb6d7282b58b9a1 e21ca62997fc4a63ba7dd0135459f324--bb4354a180904b828bb6d7282b58b9a1 03da83d404b246e08a4a19e09506e225 bb4354a180904b828bb6d7282b58b9a1--03da83d404b246e08a4a19e09506e225 112efd945fbd4da78ef299fdfbafe6f5 03da83d404b246e08a4a19e09506e225--112efd945fbd4da78ef299fdfbafe6f5 25c7b162e144419bbd4abf26672ff550 112efd945fbd4da78ef299fdfbafe6f5--25c7b162e144419bbd4abf26672ff550 0b16a95cd82649a79499b5df3dd0a100 X 25c7b162e144419bbd4abf26672ff550--0b16a95cd82649a79499b5df3dd0a100 0b16a95cd82649a79499b5df3dd0a100--63a7892f1762437fb24ce8cefc85164e 42d7998089294021935485eb5ac28611 RZ(-1.0*g1) 0b16a95cd82649a79499b5df3dd0a100--42d7998089294021935485eb5ac28611 7b6819ec079e41fe9a2ea98eef412fa3 X 42d7998089294021935485eb5ac28611--7b6819ec079e41fe9a2ea98eef412fa3 7b6819ec079e41fe9a2ea98eef412fa3--1bd60a24c1cd4463b8e11f90f537c0cf f7ace9e42d384b1185d2e9c3af388dca 7b6819ec079e41fe9a2ea98eef412fa3--f7ace9e42d384b1185d2e9c3af388dca 24bdf79fe24147fdb882619b5db49ef7 f7ace9e42d384b1185d2e9c3af388dca--24bdf79fe24147fdb882619b5db49ef7 f6c9cb5c75334fbbb543150c8d6b17f2 24bdf79fe24147fdb882619b5db49ef7--f6c9cb5c75334fbbb543150c8d6b17f2 4d817340fb4743f89070e2bdff78c08b f6c9cb5c75334fbbb543150c8d6b17f2--4d817340fb4743f89070e2bdff78c08b dd895e6c79ed440a8feec7145ecb87d4 4d817340fb4743f89070e2bdff78c08b--dd895e6c79ed440a8feec7145ecb87d4 fcc99480da3d4001933f6aa01d3acef9 dd895e6c79ed440a8feec7145ecb87d4--fcc99480da3d4001933f6aa01d3acef9 f574c0d328fd4f09a86a868a19816f4e fcc99480da3d4001933f6aa01d3acef9--f574c0d328fd4f09a86a868a19816f4e 9e075ac0808742758da7ce72c065095a f574c0d328fd4f09a86a868a19816f4e--9e075ac0808742758da7ce72c065095a 9abdc9c57d9b441e8b8a7f5a3a8c2814 X 9e075ac0808742758da7ce72c065095a--9abdc9c57d9b441e8b8a7f5a3a8c2814 9abdc9c57d9b441e8b8a7f5a3a8c2814--696bf16b4bc54199ae36d89324e573c9 4fc7c8fb6c1a4713bf7da6aef1cbdf87 9abdc9c57d9b441e8b8a7f5a3a8c2814--4fc7c8fb6c1a4713bf7da6aef1cbdf87 2665dfef9e2b46208dbb806df8912b2e 4fc7c8fb6c1a4713bf7da6aef1cbdf87--2665dfef9e2b46208dbb806df8912b2e 788bd9c0be6042e4a00d5cdbfaf396aa 2665dfef9e2b46208dbb806df8912b2e--788bd9c0be6042e4a00d5cdbfaf396aa b4a367bafcb24ac7919a0cd7f5a8deeb 788bd9c0be6042e4a00d5cdbfaf396aa--b4a367bafcb24ac7919a0cd7f5a8deeb 812316900f8f4d219d4c1987e43f0e52 b4a367bafcb24ac7919a0cd7f5a8deeb--812316900f8f4d219d4c1987e43f0e52 0cf674188b3645419fc63f59994fe008 X 812316900f8f4d219d4c1987e43f0e52--0cf674188b3645419fc63f59994fe008 0cf674188b3645419fc63f59994fe008--1ed0a84ab83148958fd4ffbce2fb628b 33dc1e871d6846babc9cc5558aa154c0 0cf674188b3645419fc63f59994fe008--33dc1e871d6846babc9cc5558aa154c0 15c952acb0254d7c9f803d3bad637982 33dc1e871d6846babc9cc5558aa154c0--15c952acb0254d7c9f803d3bad637982 26170105ed8548f2bcb3811fe965bdc2 15c952acb0254d7c9f803d3bad637982--26170105ed8548f2bcb3811fe965bdc2 881a21087c994ffba876a7928d4fbebb 26170105ed8548f2bcb3811fe965bdc2--881a21087c994ffba876a7928d4fbebb 11e805cd06ce423f80f037d863ac31bf 881a21087c994ffba876a7928d4fbebb--11e805cd06ce423f80f037d863ac31bf 77f530c2c31748e0b0a0e374105ed561 11e805cd06ce423f80f037d863ac31bf--77f530c2c31748e0b0a0e374105ed561 5b0dfb0823a042e3be1f120435817efe 77f530c2c31748e0b0a0e374105ed561--5b0dfb0823a042e3be1f120435817efe e0aa324c493c424dbddb7e21b1258ac9 5b0dfb0823a042e3be1f120435817efe--e0aa324c493c424dbddb7e21b1258ac9 bd01d9864e1f4f2fb94d487708a57a3a e0aa324c493c424dbddb7e21b1258ac9--bd01d9864e1f4f2fb94d487708a57a3a e4f6db347b1e499bbdc955f53b6c66c2 bd01d9864e1f4f2fb94d487708a57a3a--e4f6db347b1e499bbdc955f53b6c66c2 4c74ef718b0340ac8dbd85763c42b397 e4f6db347b1e499bbdc955f53b6c66c2--4c74ef718b0340ac8dbd85763c42b397 2a5923ff1dbe4a5abac6be4a840176a2 4c74ef718b0340ac8dbd85763c42b397--2a5923ff1dbe4a5abac6be4a840176a2 c02334acc3924e0d81819ad0a1be2302 2a5923ff1dbe4a5abac6be4a840176a2--c02334acc3924e0d81819ad0a1be2302 10965df1bcd74088a2c11f4a5ee21726 c02334acc3924e0d81819ad0a1be2302--10965df1bcd74088a2c11f4a5ee21726 b984bd9bec2642fabcbc819e7bcfa4f6 10965df1bcd74088a2c11f4a5ee21726--b984bd9bec2642fabcbc819e7bcfa4f6 933301e2b09c4e2a816202504d0fdff7 X b984bd9bec2642fabcbc819e7bcfa4f6--933301e2b09c4e2a816202504d0fdff7 933301e2b09c4e2a816202504d0fdff7--766bc835589f40ae9c94620afb65042b fbc3f7ebe806475b9c8777e8a658b696 RZ(-1.0*g1) 933301e2b09c4e2a816202504d0fdff7--fbc3f7ebe806475b9c8777e8a658b696 b0360e05ec2141a2be9dd4b258da2eee X fbc3f7ebe806475b9c8777e8a658b696--b0360e05ec2141a2be9dd4b258da2eee b0360e05ec2141a2be9dd4b258da2eee--01e4911692e84a298d7c284c5737e205 797a9007e9414d2c8a1200f0c0de36f9 b0360e05ec2141a2be9dd4b258da2eee--797a9007e9414d2c8a1200f0c0de36f9 c03a94bc7eab48bcbb992c6f19d8efa2 797a9007e9414d2c8a1200f0c0de36f9--c03a94bc7eab48bcbb992c6f19d8efa2 c819f03a9fe64ca494e5c46cb625dcb1 X c03a94bc7eab48bcbb992c6f19d8efa2--c819f03a9fe64ca494e5c46cb625dcb1 c819f03a9fe64ca494e5c46cb625dcb1--7103cf29549e4ef7a4ef0ed5b7c8cfc3 ce8bdf700f6e4b55a86bd28796a6b315 c819f03a9fe64ca494e5c46cb625dcb1--ce8bdf700f6e4b55a86bd28796a6b315 15bafa9802da4f89afe0b3cb3d96847e ce8bdf700f6e4b55a86bd28796a6b315--15bafa9802da4f89afe0b3cb3d96847e 76be7e4c3a35483b9b6dbc0dbaf4b658 15bafa9802da4f89afe0b3cb3d96847e--76be7e4c3a35483b9b6dbc0dbaf4b658 5aa908ad0bfe4442a09a1522d71394b1 X 76be7e4c3a35483b9b6dbc0dbaf4b658--5aa908ad0bfe4442a09a1522d71394b1 5aa908ad0bfe4442a09a1522d71394b1--9d976f6f6e4f443caeb9571a38da7e97 cd0d30b96ff34c399c88e17437834373 5aa908ad0bfe4442a09a1522d71394b1--cd0d30b96ff34c399c88e17437834373 e0e2aad54eea46bd8625dab89cb78c17 cd0d30b96ff34c399c88e17437834373--e0e2aad54eea46bd8625dab89cb78c17 82df9a099b9b4740b82a5f74dd8e1866 X e0e2aad54eea46bd8625dab89cb78c17--82df9a099b9b4740b82a5f74dd8e1866 82df9a099b9b4740b82a5f74dd8e1866--b78a362db286448897567f06d78ebc4d a24c67084b2e4c8185d46447f57f7974 82df9a099b9b4740b82a5f74dd8e1866--a24c67084b2e4c8185d46447f57f7974 21a1774da625432c84600c6b12e8b756 a24c67084b2e4c8185d46447f57f7974--21a1774da625432c84600c6b12e8b756 148f957ef4a94556a1f34aa54fd78d58 21a1774da625432c84600c6b12e8b756--148f957ef4a94556a1f34aa54fd78d58 cb6175a8fb594a55ae91948b596aad0e 148f957ef4a94556a1f34aa54fd78d58--cb6175a8fb594a55ae91948b596aad0e 0e8e62c2458c4b5b83cda74b4fa6bca0 cb6175a8fb594a55ae91948b596aad0e--0e8e62c2458c4b5b83cda74b4fa6bca0 2509c02dcce64651b5ea52fa1b8817ec X 0e8e62c2458c4b5b83cda74b4fa6bca0--2509c02dcce64651b5ea52fa1b8817ec 2509c02dcce64651b5ea52fa1b8817ec--fae7cd101bd94b59a9f3dd3661662bb3 95b312bc1065431a8768e14cc829f580 2509c02dcce64651b5ea52fa1b8817ec--95b312bc1065431a8768e14cc829f580 511570d12ce1411ab9e1055c119578df 95b312bc1065431a8768e14cc829f580--511570d12ce1411ab9e1055c119578df 65598f8f745c45a0b03aced32c9d29db 511570d12ce1411ab9e1055c119578df--65598f8f745c45a0b03aced32c9d29db 7281c7fafdca4d12bfcf4e3e9618a10a 65598f8f745c45a0b03aced32c9d29db--7281c7fafdca4d12bfcf4e3e9618a10a 9eec731505b54fafb80da7bea9e95157 RX(b15) 7281c7fafdca4d12bfcf4e3e9618a10a--9eec731505b54fafb80da7bea9e95157 9eec731505b54fafb80da7bea9e95157--0afb5e480f884e25b3a3be1d58ffa06c b14afdb2cf154fd69b13af7733aec476 b9b6f14d2cd847178d6bfccf30568491 0b90b9fa81f74b1d9fa259285cdf8bea--b9b6f14d2cd847178d6bfccf30568491 17393c3b0f8645c3aaea005b17501ee8 7 c2ace0d65f064e2cb3f333bad4c283b5 b9b6f14d2cd847178d6bfccf30568491--c2ace0d65f064e2cb3f333bad4c283b5 62c76707b9b74af4a2647b244a86967e c2ace0d65f064e2cb3f333bad4c283b5--62c76707b9b74af4a2647b244a86967e 66ba9a0112b84c13a8b89a9dd96a2313 62c76707b9b74af4a2647b244a86967e--66ba9a0112b84c13a8b89a9dd96a2313 aafb46f6e70b41feb4f9163b71e1befa 66ba9a0112b84c13a8b89a9dd96a2313--aafb46f6e70b41feb4f9163b71e1befa 7fb242c9b92c4b9e81dd48bb50f98d11 X aafb46f6e70b41feb4f9163b71e1befa--7fb242c9b92c4b9e81dd48bb50f98d11 7fb242c9b92c4b9e81dd48bb50f98d11--b55ddd23e54b41a2bc2e52a6d7d156e0 beafe6c8efee4830af782681866d2219 7fb242c9b92c4b9e81dd48bb50f98d11--beafe6c8efee4830af782681866d2219 3b05059e36f84f5e84dfbb660d80c71c beafe6c8efee4830af782681866d2219--3b05059e36f84f5e84dfbb660d80c71c cdeec6a7aca848ef9967828f5c4962c3 3b05059e36f84f5e84dfbb660d80c71c--cdeec6a7aca848ef9967828f5c4962c3 2025e0afcd2145b680f73381a8c344c7 X cdeec6a7aca848ef9967828f5c4962c3--2025e0afcd2145b680f73381a8c344c7 2025e0afcd2145b680f73381a8c344c7--f7032855b90a4a94b28ba95939beab52 854a00319f334ba599817e67d580bba8 2025e0afcd2145b680f73381a8c344c7--854a00319f334ba599817e67d580bba8 06cea676180f4db1ae80e7b59787285b 854a00319f334ba599817e67d580bba8--06cea676180f4db1ae80e7b59787285b 9b3a26fe8b854a769bf79c5bb171efb4 06cea676180f4db1ae80e7b59787285b--9b3a26fe8b854a769bf79c5bb171efb4 4eff751d44164b589a7868a8ad0a4a8e 9b3a26fe8b854a769bf79c5bb171efb4--4eff751d44164b589a7868a8ad0a4a8e 7b1302b3682943d5909c07386c518a8b 4eff751d44164b589a7868a8ad0a4a8e--7b1302b3682943d5909c07386c518a8b 5c7321bb15f74bdda2c12dbd334c21a8 7b1302b3682943d5909c07386c518a8b--5c7321bb15f74bdda2c12dbd334c21a8 189eb7382f2445189e9f27e419853592 5c7321bb15f74bdda2c12dbd334c21a8--189eb7382f2445189e9f27e419853592 c16c5473688a4a7fa21f5f1d01d2fda1 189eb7382f2445189e9f27e419853592--c16c5473688a4a7fa21f5f1d01d2fda1 0813f3e80817495894a86a9d7bc6aaea c16c5473688a4a7fa21f5f1d01d2fda1--0813f3e80817495894a86a9d7bc6aaea 6f3ae688b6da437c8c7aee51c92a1707 0813f3e80817495894a86a9d7bc6aaea--6f3ae688b6da437c8c7aee51c92a1707 de15136c1e7f441e909a7f8be3b6bde3 6f3ae688b6da437c8c7aee51c92a1707--de15136c1e7f441e909a7f8be3b6bde3 874c64a1e9be4a428a7712f93a2e3dc5 de15136c1e7f441e909a7f8be3b6bde3--874c64a1e9be4a428a7712f93a2e3dc5 2b8020af319c4b0798f5b9319edf4abf 874c64a1e9be4a428a7712f93a2e3dc5--2b8020af319c4b0798f5b9319edf4abf 3807d8854df84af783bdc04b5bdf9f47 2b8020af319c4b0798f5b9319edf4abf--3807d8854df84af783bdc04b5bdf9f47 35ca37411bbe4d14b8a9337def1e806d 3807d8854df84af783bdc04b5bdf9f47--35ca37411bbe4d14b8a9337def1e806d c4fafbcc1f8c421b8f96c9c8d63e38be 35ca37411bbe4d14b8a9337def1e806d--c4fafbcc1f8c421b8f96c9c8d63e38be d0d39637bbda4f86bcc1ab4458d329e5 c4fafbcc1f8c421b8f96c9c8d63e38be--d0d39637bbda4f86bcc1ab4458d329e5 69e02d86895c44cba0c7fc4bc36e25be d0d39637bbda4f86bcc1ab4458d329e5--69e02d86895c44cba0c7fc4bc36e25be 19c84d0b050b4bd18b7face8f270b154 69e02d86895c44cba0c7fc4bc36e25be--19c84d0b050b4bd18b7face8f270b154 d66bb747f6504906ac854d901e6b3a2a 19c84d0b050b4bd18b7face8f270b154--d66bb747f6504906ac854d901e6b3a2a b5b449b504a54b1aa419328526d4e580 d66bb747f6504906ac854d901e6b3a2a--b5b449b504a54b1aa419328526d4e580 8df3ca5c52224cf29255f8af7118736a b5b449b504a54b1aa419328526d4e580--8df3ca5c52224cf29255f8af7118736a 3a9cbf8539d443ccbc07583c19df01ba 8df3ca5c52224cf29255f8af7118736a--3a9cbf8539d443ccbc07583c19df01ba 1baccd7e2290469f9f2b9eca875f5b4b 3a9cbf8539d443ccbc07583c19df01ba--1baccd7e2290469f9f2b9eca875f5b4b 1f3072cc4f774f17b952a65fe3a2a82d X 1baccd7e2290469f9f2b9eca875f5b4b--1f3072cc4f774f17b952a65fe3a2a82d 1f3072cc4f774f17b952a65fe3a2a82d--6d3ceb02089040719719189ca8453224 a6b4316a4c87488982cacbd5de21ffde 1f3072cc4f774f17b952a65fe3a2a82d--a6b4316a4c87488982cacbd5de21ffde 424bae7b46e7426c8e1b9b1f62623368 a6b4316a4c87488982cacbd5de21ffde--424bae7b46e7426c8e1b9b1f62623368 17f46a1c4c274a93b7f8ef2423fbbc47 424bae7b46e7426c8e1b9b1f62623368--17f46a1c4c274a93b7f8ef2423fbbc47 b50d3f8f655549e5825d750949e85bf5 X 17f46a1c4c274a93b7f8ef2423fbbc47--b50d3f8f655549e5825d750949e85bf5 b50d3f8f655549e5825d750949e85bf5--763e9d355fe84a87934809493c96f426 2cbd45d3b810443aaf66d32f3973a1a6 b50d3f8f655549e5825d750949e85bf5--2cbd45d3b810443aaf66d32f3973a1a6 8ea1be23d0b046fbaf3e4353c2aa9693 2cbd45d3b810443aaf66d32f3973a1a6--8ea1be23d0b046fbaf3e4353c2aa9693 a5e3318e3f4247fb8936586a3315bcd6 8ea1be23d0b046fbaf3e4353c2aa9693--a5e3318e3f4247fb8936586a3315bcd6 2663dd7b294144c89870d25de772d917 a5e3318e3f4247fb8936586a3315bcd6--2663dd7b294144c89870d25de772d917 a22aad578d2d4e5c999f0ad952f04bcd 2663dd7b294144c89870d25de772d917--a22aad578d2d4e5c999f0ad952f04bcd eda43a093c524349b7ecd64311deae7d a22aad578d2d4e5c999f0ad952f04bcd--eda43a093c524349b7ecd64311deae7d 58b6490842084ae4855784e81f78374a eda43a093c524349b7ecd64311deae7d--58b6490842084ae4855784e81f78374a cc020eae17a04a93bd7753c2ba1d7036 58b6490842084ae4855784e81f78374a--cc020eae17a04a93bd7753c2ba1d7036 91e3e54ca94344e388fa7a6c47047c59 cc020eae17a04a93bd7753c2ba1d7036--91e3e54ca94344e388fa7a6c47047c59 793e97b76fd446228355129ec666843a 91e3e54ca94344e388fa7a6c47047c59--793e97b76fd446228355129ec666843a 1fc9d1f9e3594150836dee724de95a43 793e97b76fd446228355129ec666843a--1fc9d1f9e3594150836dee724de95a43 31c0bdb809c9432c8b79355613591cd8 1fc9d1f9e3594150836dee724de95a43--31c0bdb809c9432c8b79355613591cd8 622641a102e94da49596edb83f1df870 31c0bdb809c9432c8b79355613591cd8--622641a102e94da49596edb83f1df870 122b12b11a384fa4a7ae010024597c6a 622641a102e94da49596edb83f1df870--122b12b11a384fa4a7ae010024597c6a 1a5b986c05074c7ba02026e0d6948dd9 122b12b11a384fa4a7ae010024597c6a--1a5b986c05074c7ba02026e0d6948dd9 a59efca7bb5c4ed1b191d4e2f88445e9 1a5b986c05074c7ba02026e0d6948dd9--a59efca7bb5c4ed1b191d4e2f88445e9 eb019ecdf79d4509871fd8209a32a386 a59efca7bb5c4ed1b191d4e2f88445e9--eb019ecdf79d4509871fd8209a32a386 4f442b0af9974c19a6a581617d9ede01 eb019ecdf79d4509871fd8209a32a386--4f442b0af9974c19a6a581617d9ede01 6c759f2422a043b19ccf97f1072db204 4f442b0af9974c19a6a581617d9ede01--6c759f2422a043b19ccf97f1072db204 b062bcdafec54714acf491e8e0491edc 6c759f2422a043b19ccf97f1072db204--b062bcdafec54714acf491e8e0491edc 10a63771fa5243bcae87b11d24eb1c30 b062bcdafec54714acf491e8e0491edc--10a63771fa5243bcae87b11d24eb1c30 e22e8c830f184af4996e374049b98c9c 10a63771fa5243bcae87b11d24eb1c30--e22e8c830f184af4996e374049b98c9c 24b178f25f654a058b2bcf59cc2bfae6 X e22e8c830f184af4996e374049b98c9c--24b178f25f654a058b2bcf59cc2bfae6 24b178f25f654a058b2bcf59cc2bfae6--70c168d2550245ea850a6f998f3a5502 6d0af51dea194427b80f2faa89986835 RZ(-1.0*g0) 24b178f25f654a058b2bcf59cc2bfae6--6d0af51dea194427b80f2faa89986835 200b31eda0ed475cb75c47901514e503 X 6d0af51dea194427b80f2faa89986835--200b31eda0ed475cb75c47901514e503 200b31eda0ed475cb75c47901514e503--f18b3f65a2c64a00a029b25b6d133e61 589501111cd1482f9c19324a7354a54e 200b31eda0ed475cb75c47901514e503--589501111cd1482f9c19324a7354a54e 30f924f884e64ede80b6835c7e4745d7 589501111cd1482f9c19324a7354a54e--30f924f884e64ede80b6835c7e4745d7 09c257bceff74b5393405d39efe66756 30f924f884e64ede80b6835c7e4745d7--09c257bceff74b5393405d39efe66756 bb60c947226a47d1840d42fbaf1956c7 09c257bceff74b5393405d39efe66756--bb60c947226a47d1840d42fbaf1956c7 060758d2dbf14ae1a3cd4371aa042e5d X bb60c947226a47d1840d42fbaf1956c7--060758d2dbf14ae1a3cd4371aa042e5d 060758d2dbf14ae1a3cd4371aa042e5d--67ce804d4d634a8b8ca02b0da2015dbb f7c8865001ca48d7aef64556dfb3d8ce 060758d2dbf14ae1a3cd4371aa042e5d--f7c8865001ca48d7aef64556dfb3d8ce 17e34381cf2546ce9cc732495b136c68 f7c8865001ca48d7aef64556dfb3d8ce--17e34381cf2546ce9cc732495b136c68 c37ddab3205041d9b9031044e919de3b 17e34381cf2546ce9cc732495b136c68--c37ddab3205041d9b9031044e919de3b be63ab6203ef4984a313ce9a3ca37d5e X c37ddab3205041d9b9031044e919de3b--be63ab6203ef4984a313ce9a3ca37d5e be63ab6203ef4984a313ce9a3ca37d5e--3c4442df0e8d4876a33da3275842b277 993a6cfec6814700aa84ca19c1b5edf6 be63ab6203ef4984a313ce9a3ca37d5e--993a6cfec6814700aa84ca19c1b5edf6 4f8ef6fe176e462990d0be7aeccb4ae9 993a6cfec6814700aa84ca19c1b5edf6--4f8ef6fe176e462990d0be7aeccb4ae9 bdbd1e526add44f18c9158d1c91b7b9f X 4f8ef6fe176e462990d0be7aeccb4ae9--bdbd1e526add44f18c9158d1c91b7b9f bdbd1e526add44f18c9158d1c91b7b9f--7ebd94e6820340bcbfa03689f4865290 55928ed2ff184a399398abf678769e60 RZ(-1.0*g0) bdbd1e526add44f18c9158d1c91b7b9f--55928ed2ff184a399398abf678769e60 c60cb7e5155f48f0baac65a96925c167 X 55928ed2ff184a399398abf678769e60--c60cb7e5155f48f0baac65a96925c167 c60cb7e5155f48f0baac65a96925c167--b9bfec51f930453c9ef83f497b63436d 1f0606e7f22b4941860e13e89df6551c RX(b06) c60cb7e5155f48f0baac65a96925c167--1f0606e7f22b4941860e13e89df6551c 67b44e7830c24ed09507b45a89bb2f59 1f0606e7f22b4941860e13e89df6551c--67b44e7830c24ed09507b45a89bb2f59 b5d8548bc9544e7e8a04d0ab9d9571c8 67b44e7830c24ed09507b45a89bb2f59--b5d8548bc9544e7e8a04d0ab9d9571c8 dfd740fb2d8044548f5f41e58cf1bf97 b5d8548bc9544e7e8a04d0ab9d9571c8--dfd740fb2d8044548f5f41e58cf1bf97 7e7d8a01d3b54d86b50e1570197cbbd5 dfd740fb2d8044548f5f41e58cf1bf97--7e7d8a01d3b54d86b50e1570197cbbd5 2b6593db904148fcadd4c54ec098ad06 7e7d8a01d3b54d86b50e1570197cbbd5--2b6593db904148fcadd4c54ec098ad06 f9e846adf33c43318458ab671dec7c62 X 2b6593db904148fcadd4c54ec098ad06--f9e846adf33c43318458ab671dec7c62 f9e846adf33c43318458ab671dec7c62--e399a6851ffa4866a87af42ff645076f c37e207ff2bb4abfbf3ccb48498c735b f9e846adf33c43318458ab671dec7c62--c37e207ff2bb4abfbf3ccb48498c735b 93c9d6fcd77e4de08eaf222466f7b0c0 c37e207ff2bb4abfbf3ccb48498c735b--93c9d6fcd77e4de08eaf222466f7b0c0 8157ace6c3614b22acf71a2fc5cff78f 93c9d6fcd77e4de08eaf222466f7b0c0--8157ace6c3614b22acf71a2fc5cff78f b7e8a90128244f1c9e0eacdd745a84ec X 8157ace6c3614b22acf71a2fc5cff78f--b7e8a90128244f1c9e0eacdd745a84ec b7e8a90128244f1c9e0eacdd745a84ec--adad39d697f94edba2b24d13e40a290a 6bcfa5d4da894a7c80e33747b5b3d2b8 b7e8a90128244f1c9e0eacdd745a84ec--6bcfa5d4da894a7c80e33747b5b3d2b8 d2107063019946f39ac34fd0e9ae0e2e 6bcfa5d4da894a7c80e33747b5b3d2b8--d2107063019946f39ac34fd0e9ae0e2e 3a35ff4e6283450a90a8ea71b83f26da d2107063019946f39ac34fd0e9ae0e2e--3a35ff4e6283450a90a8ea71b83f26da c89c055846bd46a899cae6a1f0bd1bf8 3a35ff4e6283450a90a8ea71b83f26da--c89c055846bd46a899cae6a1f0bd1bf8 39afd4cd23bf4f0ba4a549ac34c9d79f c89c055846bd46a899cae6a1f0bd1bf8--39afd4cd23bf4f0ba4a549ac34c9d79f 068b3605161043bc9caaf198ec7091fe 39afd4cd23bf4f0ba4a549ac34c9d79f--068b3605161043bc9caaf198ec7091fe c883820cdd034e75a5e243d78d7c5dca 068b3605161043bc9caaf198ec7091fe--c883820cdd034e75a5e243d78d7c5dca 5627b1b9d3c94a4194185b2db0ae3014 c883820cdd034e75a5e243d78d7c5dca--5627b1b9d3c94a4194185b2db0ae3014 d777174152b04b93a09fbffdf66e2df3 5627b1b9d3c94a4194185b2db0ae3014--d777174152b04b93a09fbffdf66e2df3 76ad7ca866bb4185a331b0f08cc42788 d777174152b04b93a09fbffdf66e2df3--76ad7ca866bb4185a331b0f08cc42788 e26d05c9dedf49a9b1e15b7ee4184b09 76ad7ca866bb4185a331b0f08cc42788--e26d05c9dedf49a9b1e15b7ee4184b09 40c266ac07f54635a937edcac3d7bc35 e26d05c9dedf49a9b1e15b7ee4184b09--40c266ac07f54635a937edcac3d7bc35 04754827427e40599a59b46546f742db 40c266ac07f54635a937edcac3d7bc35--04754827427e40599a59b46546f742db 7808bdebbdb243bea4771f5e34e0840a 04754827427e40599a59b46546f742db--7808bdebbdb243bea4771f5e34e0840a 7bde150e61df434f9fecfbd869c47449 7808bdebbdb243bea4771f5e34e0840a--7bde150e61df434f9fecfbd869c47449 302b81cafaa747edac59b211ababa8f3 7bde150e61df434f9fecfbd869c47449--302b81cafaa747edac59b211ababa8f3 7d2d5e9439134727bd5021d700c5f69d 302b81cafaa747edac59b211ababa8f3--7d2d5e9439134727bd5021d700c5f69d 324b5e8e0c1e47cb941caf86cb5c2875 7d2d5e9439134727bd5021d700c5f69d--324b5e8e0c1e47cb941caf86cb5c2875 c009f9fc05cd4bc4bcb9b7ce91c0ec43 324b5e8e0c1e47cb941caf86cb5c2875--c009f9fc05cd4bc4bcb9b7ce91c0ec43 ae71950b691840c89ae3ae6a3bddbe99 c009f9fc05cd4bc4bcb9b7ce91c0ec43--ae71950b691840c89ae3ae6a3bddbe99 3f0ddc0c6e254f4aa81b3ecf06dfc566 ae71950b691840c89ae3ae6a3bddbe99--3f0ddc0c6e254f4aa81b3ecf06dfc566 cb419cf737004579bb5460c7c90d79ed 3f0ddc0c6e254f4aa81b3ecf06dfc566--cb419cf737004579bb5460c7c90d79ed 64aa685a72674e8cb11041e1fbc29f18 cb419cf737004579bb5460c7c90d79ed--64aa685a72674e8cb11041e1fbc29f18 b2591f1b311f4819b94f564fb2ff6e3c 64aa685a72674e8cb11041e1fbc29f18--b2591f1b311f4819b94f564fb2ff6e3c 368b0ca92fa4437d8ba3c8f67a65c249 X b2591f1b311f4819b94f564fb2ff6e3c--368b0ca92fa4437d8ba3c8f67a65c249 368b0ca92fa4437d8ba3c8f67a65c249--4fc7c8fb6c1a4713bf7da6aef1cbdf87 4bdfa20468cc4fd9b1e5227470cdd92e 368b0ca92fa4437d8ba3c8f67a65c249--4bdfa20468cc4fd9b1e5227470cdd92e 92e8ceec7c3e49a5b7f6d65d534eaedb 4bdfa20468cc4fd9b1e5227470cdd92e--92e8ceec7c3e49a5b7f6d65d534eaedb 629094a8636948d99a3417e33dfba1b3 92e8ceec7c3e49a5b7f6d65d534eaedb--629094a8636948d99a3417e33dfba1b3 37257bb79c32420ca1c170952f80abf6 X 629094a8636948d99a3417e33dfba1b3--37257bb79c32420ca1c170952f80abf6 37257bb79c32420ca1c170952f80abf6--812316900f8f4d219d4c1987e43f0e52 6f90f4efb11e447cbecf3b4975ae8f6c 37257bb79c32420ca1c170952f80abf6--6f90f4efb11e447cbecf3b4975ae8f6c 84723f1da7924221acdab9e81cdfaeae 6f90f4efb11e447cbecf3b4975ae8f6c--84723f1da7924221acdab9e81cdfaeae b1fd6f60d5ab4fc89b6ab4b555175d5d 84723f1da7924221acdab9e81cdfaeae--b1fd6f60d5ab4fc89b6ab4b555175d5d 4d081ea86fd14852aa7eafd1b1f77414 b1fd6f60d5ab4fc89b6ab4b555175d5d--4d081ea86fd14852aa7eafd1b1f77414 bb7783e4a10a4a7a9d42fc3718d4f415 4d081ea86fd14852aa7eafd1b1f77414--bb7783e4a10a4a7a9d42fc3718d4f415 5532a54e308c423d9c4364dcafd47693 bb7783e4a10a4a7a9d42fc3718d4f415--5532a54e308c423d9c4364dcafd47693 81ac283e02bf4df79f3355f2564ef1c8 5532a54e308c423d9c4364dcafd47693--81ac283e02bf4df79f3355f2564ef1c8 dc095dee2ccb4457b39b1a569f87d735 81ac283e02bf4df79f3355f2564ef1c8--dc095dee2ccb4457b39b1a569f87d735 88d1918e30774fa7a4322f15dd11ce20 dc095dee2ccb4457b39b1a569f87d735--88d1918e30774fa7a4322f15dd11ce20 150298936a1b4efa9cd268632ad0f6d2 88d1918e30774fa7a4322f15dd11ce20--150298936a1b4efa9cd268632ad0f6d2 2025e65026484c2bb9ffc30ffdc4f28b 150298936a1b4efa9cd268632ad0f6d2--2025e65026484c2bb9ffc30ffdc4f28b c31606e8ef61467a97f40b6ebd07832e 2025e65026484c2bb9ffc30ffdc4f28b--c31606e8ef61467a97f40b6ebd07832e ea9c96b3f36c421daa2f22cb0274d3e7 c31606e8ef61467a97f40b6ebd07832e--ea9c96b3f36c421daa2f22cb0274d3e7 3d8ddfcfd97d469abc4b20f9b852d7de ea9c96b3f36c421daa2f22cb0274d3e7--3d8ddfcfd97d469abc4b20f9b852d7de 1cbc262a48cd4d92afff0f2a8153b7c4 3d8ddfcfd97d469abc4b20f9b852d7de--1cbc262a48cd4d92afff0f2a8153b7c4 4517dc3375a74542ad728e340b38edb3 1cbc262a48cd4d92afff0f2a8153b7c4--4517dc3375a74542ad728e340b38edb3 7721e667e9a64188ad710638ce0ff3a8 4517dc3375a74542ad728e340b38edb3--7721e667e9a64188ad710638ce0ff3a8 e2fb7180af484dada0287a6d5b1484c0 7721e667e9a64188ad710638ce0ff3a8--e2fb7180af484dada0287a6d5b1484c0 7d4915255d974c9282242141a8d2bf0b e2fb7180af484dada0287a6d5b1484c0--7d4915255d974c9282242141a8d2bf0b c23c735329734a6ebffd54188017746f 7d4915255d974c9282242141a8d2bf0b--c23c735329734a6ebffd54188017746f de0911a4b7fb48ceb7a8ac82340d3e51 c23c735329734a6ebffd54188017746f--de0911a4b7fb48ceb7a8ac82340d3e51 4cefa6722c684b06a2952855511e9d2a de0911a4b7fb48ceb7a8ac82340d3e51--4cefa6722c684b06a2952855511e9d2a 9adc2053e4224ad6accadfdbc68c9dfa X 4cefa6722c684b06a2952855511e9d2a--9adc2053e4224ad6accadfdbc68c9dfa 9adc2053e4224ad6accadfdbc68c9dfa--ce8bdf700f6e4b55a86bd28796a6b315 42b22d9c14f440d3a11ea0703394c069 RZ(-1.0*g1) 9adc2053e4224ad6accadfdbc68c9dfa--42b22d9c14f440d3a11ea0703394c069 98871b0d892449b787aa825abbc77ede X 42b22d9c14f440d3a11ea0703394c069--98871b0d892449b787aa825abbc77ede 98871b0d892449b787aa825abbc77ede--76be7e4c3a35483b9b6dbc0dbaf4b658 cdb2c0ebac244f7ebbba57a586aff9c2 98871b0d892449b787aa825abbc77ede--cdb2c0ebac244f7ebbba57a586aff9c2 310afed833f34eb3aaebf56200a49030 cdb2c0ebac244f7ebbba57a586aff9c2--310afed833f34eb3aaebf56200a49030 e3b72820b8a04695abbc441d69bc95cd 310afed833f34eb3aaebf56200a49030--e3b72820b8a04695abbc441d69bc95cd 150c99ad511640f5a5716e3cd9f26258 e3b72820b8a04695abbc441d69bc95cd--150c99ad511640f5a5716e3cd9f26258 3c7f4e9786ce48be8769b058f4343256 X 150c99ad511640f5a5716e3cd9f26258--3c7f4e9786ce48be8769b058f4343256 3c7f4e9786ce48be8769b058f4343256--a24c67084b2e4c8185d46447f57f7974 a74797d36d1645d88a65ac2f9d4be3df 3c7f4e9786ce48be8769b058f4343256--a74797d36d1645d88a65ac2f9d4be3df 779e7201bfd047abb81197fbae160139 a74797d36d1645d88a65ac2f9d4be3df--779e7201bfd047abb81197fbae160139 e0496f2fbdbd4d60aa19609f9db4c686 779e7201bfd047abb81197fbae160139--e0496f2fbdbd4d60aa19609f9db4c686 2acb7a6f5e6543659361cafc1fdee981 X e0496f2fbdbd4d60aa19609f9db4c686--2acb7a6f5e6543659361cafc1fdee981 2acb7a6f5e6543659361cafc1fdee981--0e8e62c2458c4b5b83cda74b4fa6bca0 3232289875b243f2a1fc9ac6f82880ea 2acb7a6f5e6543659361cafc1fdee981--3232289875b243f2a1fc9ac6f82880ea 4d84463686e84e7280ea726a6eab018d 3232289875b243f2a1fc9ac6f82880ea--4d84463686e84e7280ea726a6eab018d 96f052bdde424ed7afffb5403e37048f X 4d84463686e84e7280ea726a6eab018d--96f052bdde424ed7afffb5403e37048f 96f052bdde424ed7afffb5403e37048f--511570d12ce1411ab9e1055c119578df 31c24fe1b98b4c1c8e7806d75129ec8e RZ(-1.0*g1) 96f052bdde424ed7afffb5403e37048f--31c24fe1b98b4c1c8e7806d75129ec8e 8f6370751ef747f49e16a2176d9d2019 X 31c24fe1b98b4c1c8e7806d75129ec8e--8f6370751ef747f49e16a2176d9d2019 8f6370751ef747f49e16a2176d9d2019--7281c7fafdca4d12bfcf4e3e9618a10a cb2e1ecba5f448898802ac2d1d313f1d RX(b16) 8f6370751ef747f49e16a2176d9d2019--cb2e1ecba5f448898802ac2d1d313f1d cb2e1ecba5f448898802ac2d1d313f1d--b14afdb2cf154fd69b13af7733aec476 81aac8656acd489bb1fc03f27dd98486 636ce493126042819efff313cea7564b 17393c3b0f8645c3aaea005b17501ee8--636ce493126042819efff313cea7564b b4dc6f6385644100bd5559daf7f379c9 636ce493126042819efff313cea7564b--b4dc6f6385644100bd5559daf7f379c9 922efe6068ec4a9292a337243b5abdd4 b4dc6f6385644100bd5559daf7f379c9--922efe6068ec4a9292a337243b5abdd4 3ecb6f261ec143238731bf2ccf2849cc 922efe6068ec4a9292a337243b5abdd4--3ecb6f261ec143238731bf2ccf2849cc acd6f3a9b72840079d07a6f0e3b1dd6b 3ecb6f261ec143238731bf2ccf2849cc--acd6f3a9b72840079d07a6f0e3b1dd6b 804b72e0820c4c419a2a9918ef728367 acd6f3a9b72840079d07a6f0e3b1dd6b--804b72e0820c4c419a2a9918ef728367 d44a9edd21d34d7494fcda039fa2b50d X 804b72e0820c4c419a2a9918ef728367--d44a9edd21d34d7494fcda039fa2b50d d44a9edd21d34d7494fcda039fa2b50d--beafe6c8efee4830af782681866d2219 bf516e0b06394c6ca2050fc1b8a2c078 RZ(1.0*g0) d44a9edd21d34d7494fcda039fa2b50d--bf516e0b06394c6ca2050fc1b8a2c078 0feb27f669cb4d919ddd3001b4cae182 X bf516e0b06394c6ca2050fc1b8a2c078--0feb27f669cb4d919ddd3001b4cae182 0feb27f669cb4d919ddd3001b4cae182--cdeec6a7aca848ef9967828f5c4962c3 986108f5c87240a7a61c8e4377a988bf 0feb27f669cb4d919ddd3001b4cae182--986108f5c87240a7a61c8e4377a988bf b70f76ae0e7e40aa9b93d8c7eb0e3230 986108f5c87240a7a61c8e4377a988bf--b70f76ae0e7e40aa9b93d8c7eb0e3230 5eb19496d37b42f38d15a648a143deac b70f76ae0e7e40aa9b93d8c7eb0e3230--5eb19496d37b42f38d15a648a143deac 02bf5563d8e74ac3b06b3c7ba800f66f 5eb19496d37b42f38d15a648a143deac--02bf5563d8e74ac3b06b3c7ba800f66f 25a57bd9d719405c83beb306c06ae2fb 02bf5563d8e74ac3b06b3c7ba800f66f--25a57bd9d719405c83beb306c06ae2fb decef9372c81431385d4c4432a32401b 25a57bd9d719405c83beb306c06ae2fb--decef9372c81431385d4c4432a32401b 7dbbf0fb51e34c98959cdf36f73cf2d1 decef9372c81431385d4c4432a32401b--7dbbf0fb51e34c98959cdf36f73cf2d1 2e1ea66fd3e74ab8b066ec418bcd8666 7dbbf0fb51e34c98959cdf36f73cf2d1--2e1ea66fd3e74ab8b066ec418bcd8666 4e21821a5d8346479ce14a2f285fa03c 2e1ea66fd3e74ab8b066ec418bcd8666--4e21821a5d8346479ce14a2f285fa03c 047384342a3c4616a25cf7ec2817e3c6 4e21821a5d8346479ce14a2f285fa03c--047384342a3c4616a25cf7ec2817e3c6 cebe97f524934b029b93d6812c1fbccb 047384342a3c4616a25cf7ec2817e3c6--cebe97f524934b029b93d6812c1fbccb d4ae151c1d0248e79a63aee91262135e cebe97f524934b029b93d6812c1fbccb--d4ae151c1d0248e79a63aee91262135e 1f00383360c043438c84e9027bca7cbd d4ae151c1d0248e79a63aee91262135e--1f00383360c043438c84e9027bca7cbd c49fb301ca884ab9b74544823be93c57 1f00383360c043438c84e9027bca7cbd--c49fb301ca884ab9b74544823be93c57 9aac14bea4da44c7a633a9390e57b0c4 c49fb301ca884ab9b74544823be93c57--9aac14bea4da44c7a633a9390e57b0c4 149c34dca83a449dbba2c9d42bd131a9 9aac14bea4da44c7a633a9390e57b0c4--149c34dca83a449dbba2c9d42bd131a9 7de139d67e104ac69907b213301bb9ce 149c34dca83a449dbba2c9d42bd131a9--7de139d67e104ac69907b213301bb9ce 4c2bc86158b64b8cb727967ba928a96f 7de139d67e104ac69907b213301bb9ce--4c2bc86158b64b8cb727967ba928a96f ecef8aee67244f9b88e92d6646167c74 4c2bc86158b64b8cb727967ba928a96f--ecef8aee67244f9b88e92d6646167c74 2ac95897da1241ad90bb04cee217c98f ecef8aee67244f9b88e92d6646167c74--2ac95897da1241ad90bb04cee217c98f 4adde126538d4cc9abf0f112475f5fbf 2ac95897da1241ad90bb04cee217c98f--4adde126538d4cc9abf0f112475f5fbf 8f095630b412453882500b6b6097bc46 4adde126538d4cc9abf0f112475f5fbf--8f095630b412453882500b6b6097bc46 324d3f5526bb478888834d9ff855fe49 8f095630b412453882500b6b6097bc46--324d3f5526bb478888834d9ff855fe49 935b51b2dc654a8099c2e8455c30fdbf 324d3f5526bb478888834d9ff855fe49--935b51b2dc654a8099c2e8455c30fdbf ea4ee0ac66044e51b37d2c390b1e9c59 935b51b2dc654a8099c2e8455c30fdbf--ea4ee0ac66044e51b37d2c390b1e9c59 2f09ddb872d547eb81e4c6f8754d22c3 ea4ee0ac66044e51b37d2c390b1e9c59--2f09ddb872d547eb81e4c6f8754d22c3 a7e2d47e46644c9eb08cc4c75c96b996 X 2f09ddb872d547eb81e4c6f8754d22c3--a7e2d47e46644c9eb08cc4c75c96b996 a7e2d47e46644c9eb08cc4c75c96b996--a6b4316a4c87488982cacbd5de21ffde 9107589b386241d6a393354e19732afc RZ(-1.0*g0) a7e2d47e46644c9eb08cc4c75c96b996--9107589b386241d6a393354e19732afc 128c541aeb19467c847165e63e8a38dc X 9107589b386241d6a393354e19732afc--128c541aeb19467c847165e63e8a38dc 128c541aeb19467c847165e63e8a38dc--17f46a1c4c274a93b7f8ef2423fbbc47 04038912456e4100939fff5eb2cd5ac0 128c541aeb19467c847165e63e8a38dc--04038912456e4100939fff5eb2cd5ac0 ed073777426546bf982661e76667c610 04038912456e4100939fff5eb2cd5ac0--ed073777426546bf982661e76667c610 dbc1405229764c3386907084705c4ffc ed073777426546bf982661e76667c610--dbc1405229764c3386907084705c4ffc 941451d6a8764d53af8c818929ef1ee6 dbc1405229764c3386907084705c4ffc--941451d6a8764d53af8c818929ef1ee6 06f7548549ed4f1286d24d9e6c74e325 941451d6a8764d53af8c818929ef1ee6--06f7548549ed4f1286d24d9e6c74e325 73bdaa91dd26496e94095facbd53f080 06f7548549ed4f1286d24d9e6c74e325--73bdaa91dd26496e94095facbd53f080 92832427ef004e209139857edc447004 73bdaa91dd26496e94095facbd53f080--92832427ef004e209139857edc447004 ac584792e26444c4ad581e663e540f38 92832427ef004e209139857edc447004--ac584792e26444c4ad581e663e540f38 51defdcacf9649b5abbb952e81b91513 ac584792e26444c4ad581e663e540f38--51defdcacf9649b5abbb952e81b91513 ce4065dccd3e4ddc96bf2d267d357bdf 51defdcacf9649b5abbb952e81b91513--ce4065dccd3e4ddc96bf2d267d357bdf 6ab29e60649344f89556eea638cd4a58 ce4065dccd3e4ddc96bf2d267d357bdf--6ab29e60649344f89556eea638cd4a58 aa868aeb6244496f959321a2b425b10b 6ab29e60649344f89556eea638cd4a58--aa868aeb6244496f959321a2b425b10b f21897428b0d470faf359b76294473cb aa868aeb6244496f959321a2b425b10b--f21897428b0d470faf359b76294473cb 64ac879dcb7541ce8747cba1d625a333 f21897428b0d470faf359b76294473cb--64ac879dcb7541ce8747cba1d625a333 3e30129b52514fe9a58717e0477cbe86 64ac879dcb7541ce8747cba1d625a333--3e30129b52514fe9a58717e0477cbe86 a46e6ef08282406b85100b53749b4dcb 3e30129b52514fe9a58717e0477cbe86--a46e6ef08282406b85100b53749b4dcb e7c224bcdae841b089d11b9e97a18b6f a46e6ef08282406b85100b53749b4dcb--e7c224bcdae841b089d11b9e97a18b6f 2d31b302d5ae4c1c97685dd737ef733e e7c224bcdae841b089d11b9e97a18b6f--2d31b302d5ae4c1c97685dd737ef733e 0f76e350d80641009289d4143c33940f 2d31b302d5ae4c1c97685dd737ef733e--0f76e350d80641009289d4143c33940f 0a73f017fcae41a2846d5a0d3ceaab3b 0f76e350d80641009289d4143c33940f--0a73f017fcae41a2846d5a0d3ceaab3b 45f6a072aec94fecbc2f370f89fdeb7a 0a73f017fcae41a2846d5a0d3ceaab3b--45f6a072aec94fecbc2f370f89fdeb7a 4bbc21cf64564fbaa83172c043ec54ec 45f6a072aec94fecbc2f370f89fdeb7a--4bbc21cf64564fbaa83172c043ec54ec 5ca1c3d3f9ff43b690083446a7bdff34 4bbc21cf64564fbaa83172c043ec54ec--5ca1c3d3f9ff43b690083446a7bdff34 a82f5e6b377149e58dba1dd993b742c1 5ca1c3d3f9ff43b690083446a7bdff34--a82f5e6b377149e58dba1dd993b742c1 539f21bb539745a7b51359564318703a a82f5e6b377149e58dba1dd993b742c1--539f21bb539745a7b51359564318703a 2318a418b1564e968bbb4692717d0d82 539f21bb539745a7b51359564318703a--2318a418b1564e968bbb4692717d0d82 3539b9a7070849f9b9779fe85ad1fb60 2318a418b1564e968bbb4692717d0d82--3539b9a7070849f9b9779fe85ad1fb60 988f19211ce14fb98f5f1b58ed098c0b 3539b9a7070849f9b9779fe85ad1fb60--988f19211ce14fb98f5f1b58ed098c0b 453ac268645b41aeb0e4121ac20d074f 988f19211ce14fb98f5f1b58ed098c0b--453ac268645b41aeb0e4121ac20d074f db8249b7ad6a4a29a10f984d6c64ff62 453ac268645b41aeb0e4121ac20d074f--db8249b7ad6a4a29a10f984d6c64ff62 8d29b00dd1d34c8dbecc9fbff0212aef db8249b7ad6a4a29a10f984d6c64ff62--8d29b00dd1d34c8dbecc9fbff0212aef 1b8585d1416941bab2df7d9a4ba11ad0 X 8d29b00dd1d34c8dbecc9fbff0212aef--1b8585d1416941bab2df7d9a4ba11ad0 1b8585d1416941bab2df7d9a4ba11ad0--f7c8865001ca48d7aef64556dfb3d8ce f7d950967da64592a1c0f5b7184767ff RZ(-1.0*g0) 1b8585d1416941bab2df7d9a4ba11ad0--f7d950967da64592a1c0f5b7184767ff 30efb928b33a4eb09857c6ced2ab7c00 X f7d950967da64592a1c0f5b7184767ff--30efb928b33a4eb09857c6ced2ab7c00 30efb928b33a4eb09857c6ced2ab7c00--c37ddab3205041d9b9031044e919de3b ea0cc70f5b5b4026bab7843b976ab032 30efb928b33a4eb09857c6ced2ab7c00--ea0cc70f5b5b4026bab7843b976ab032 cc64c06f89cb461fa2d6d51b57098788 ea0cc70f5b5b4026bab7843b976ab032--cc64c06f89cb461fa2d6d51b57098788 8b5a9e5082d74a81ac0f9c56a279167c cc64c06f89cb461fa2d6d51b57098788--8b5a9e5082d74a81ac0f9c56a279167c 0b8d118374ad48e4b7159e56f8bb70ab 8b5a9e5082d74a81ac0f9c56a279167c--0b8d118374ad48e4b7159e56f8bb70ab bd10bb258af14fe6892b6b2fa84511b3 0b8d118374ad48e4b7159e56f8bb70ab--bd10bb258af14fe6892b6b2fa84511b3 d757918434fe45e99358d360c98c5695 bd10bb258af14fe6892b6b2fa84511b3--d757918434fe45e99358d360c98c5695 a9408582fa854a098bab8e72e2a27aef RX(b07) d757918434fe45e99358d360c98c5695--a9408582fa854a098bab8e72e2a27aef 990c92064eaf4d999bc16cd365df230c a9408582fa854a098bab8e72e2a27aef--990c92064eaf4d999bc16cd365df230c ff29c4ced1c74618907fad2eb714e08e 990c92064eaf4d999bc16cd365df230c--ff29c4ced1c74618907fad2eb714e08e 95a04cf58a3d4c46b53e4b60e0b51917 ff29c4ced1c74618907fad2eb714e08e--95a04cf58a3d4c46b53e4b60e0b51917 be8df5c861bb427093269009bc9104be 95a04cf58a3d4c46b53e4b60e0b51917--be8df5c861bb427093269009bc9104be 0ee92d0404fa4bce982c2798d77f3914 be8df5c861bb427093269009bc9104be--0ee92d0404fa4bce982c2798d77f3914 4032fcd2652947eeae5bc213243422db 0ee92d0404fa4bce982c2798d77f3914--4032fcd2652947eeae5bc213243422db 0139f5c9c4b14116bc5fc1dee43cebff X 4032fcd2652947eeae5bc213243422db--0139f5c9c4b14116bc5fc1dee43cebff 0139f5c9c4b14116bc5fc1dee43cebff--c37e207ff2bb4abfbf3ccb48498c735b 94c496ca7dca4a6f88346c1246c7fedd RZ(1.0*g1) 0139f5c9c4b14116bc5fc1dee43cebff--94c496ca7dca4a6f88346c1246c7fedd 46984b2f8cf9494c992a3a24441dd715 X 94c496ca7dca4a6f88346c1246c7fedd--46984b2f8cf9494c992a3a24441dd715 46984b2f8cf9494c992a3a24441dd715--8157ace6c3614b22acf71a2fc5cff78f ee55480b833f49e793b462158a7bc180 46984b2f8cf9494c992a3a24441dd715--ee55480b833f49e793b462158a7bc180 98953c27167e4581b95678f89000eb1e ee55480b833f49e793b462158a7bc180--98953c27167e4581b95678f89000eb1e 9c27137fe051438dadc34b80e5d5b2b4 98953c27167e4581b95678f89000eb1e--9c27137fe051438dadc34b80e5d5b2b4 7846a48cba57462e9cc1cd0f8cda67eb 9c27137fe051438dadc34b80e5d5b2b4--7846a48cba57462e9cc1cd0f8cda67eb fb2254bffc4c4e74a8d0eebe12b84e02 7846a48cba57462e9cc1cd0f8cda67eb--fb2254bffc4c4e74a8d0eebe12b84e02 35337e366d3e41138e9807dd8f6b57c7 fb2254bffc4c4e74a8d0eebe12b84e02--35337e366d3e41138e9807dd8f6b57c7 e4120d5a9eda4ba99909bef4e086eaaf 35337e366d3e41138e9807dd8f6b57c7--e4120d5a9eda4ba99909bef4e086eaaf fcc074ddfc3a46f1a80ddaadd431c6fb e4120d5a9eda4ba99909bef4e086eaaf--fcc074ddfc3a46f1a80ddaadd431c6fb 8b15ee2b03774d34980892fb33dbd669 fcc074ddfc3a46f1a80ddaadd431c6fb--8b15ee2b03774d34980892fb33dbd669 717680dad3284941a4dd33f55b51779b 8b15ee2b03774d34980892fb33dbd669--717680dad3284941a4dd33f55b51779b 0c91bb1ee8e741b2845d4b31b35ac345 717680dad3284941a4dd33f55b51779b--0c91bb1ee8e741b2845d4b31b35ac345 a422b99b7fb1406d92776fffd5372a51 0c91bb1ee8e741b2845d4b31b35ac345--a422b99b7fb1406d92776fffd5372a51 b2e5a527f5484d8895e8a69a717ae871 a422b99b7fb1406d92776fffd5372a51--b2e5a527f5484d8895e8a69a717ae871 57bb8b6d11df4e988a30967b6e86fcfc b2e5a527f5484d8895e8a69a717ae871--57bb8b6d11df4e988a30967b6e86fcfc 63ba31fd335c438ab03c6b67d57186ea 57bb8b6d11df4e988a30967b6e86fcfc--63ba31fd335c438ab03c6b67d57186ea e49e5a3107d643b3a00a10c7d7f1f916 63ba31fd335c438ab03c6b67d57186ea--e49e5a3107d643b3a00a10c7d7f1f916 7f17e96d4f7941a39bca50a499129c2d e49e5a3107d643b3a00a10c7d7f1f916--7f17e96d4f7941a39bca50a499129c2d 14701cb74e5b4051bd39a45b02cc6d3f 7f17e96d4f7941a39bca50a499129c2d--14701cb74e5b4051bd39a45b02cc6d3f ce48b285a40548639a5b9bdcee35758f 14701cb74e5b4051bd39a45b02cc6d3f--ce48b285a40548639a5b9bdcee35758f 4fb57efda2c04f1cbe1e2a064c26c8dd ce48b285a40548639a5b9bdcee35758f--4fb57efda2c04f1cbe1e2a064c26c8dd 11c00774d19241749de9241f0f053f9f 4fb57efda2c04f1cbe1e2a064c26c8dd--11c00774d19241749de9241f0f053f9f f75a1c2f27f14f0199aba0a9f0edd179 11c00774d19241749de9241f0f053f9f--f75a1c2f27f14f0199aba0a9f0edd179 8ef920d878604c21846d0a0ddb8d0284 f75a1c2f27f14f0199aba0a9f0edd179--8ef920d878604c21846d0a0ddb8d0284 d82fdece4b1f48ba9a5889ef5fedd2a8 8ef920d878604c21846d0a0ddb8d0284--d82fdece4b1f48ba9a5889ef5fedd2a8 794141b6fcdb48baa52d1afb4f1da675 d82fdece4b1f48ba9a5889ef5fedd2a8--794141b6fcdb48baa52d1afb4f1da675 a37cddc6c4c94bf092bf45a679ca6680 794141b6fcdb48baa52d1afb4f1da675--a37cddc6c4c94bf092bf45a679ca6680 b7e46e09503a45d79e368756484db8f4 X a37cddc6c4c94bf092bf45a679ca6680--b7e46e09503a45d79e368756484db8f4 b7e46e09503a45d79e368756484db8f4--4bdfa20468cc4fd9b1e5227470cdd92e 0d14cdfd322f49aa88678c6f10ca9f8c RZ(-1.0*g1) b7e46e09503a45d79e368756484db8f4--0d14cdfd322f49aa88678c6f10ca9f8c a458a4ccfff34fd69328198ba7eb9925 X 0d14cdfd322f49aa88678c6f10ca9f8c--a458a4ccfff34fd69328198ba7eb9925 a458a4ccfff34fd69328198ba7eb9925--629094a8636948d99a3417e33dfba1b3 57e11d51b23c4f43879f99a1685a5efc a458a4ccfff34fd69328198ba7eb9925--57e11d51b23c4f43879f99a1685a5efc 20d3cbe4f1964185a5f2dba9baca7178 57e11d51b23c4f43879f99a1685a5efc--20d3cbe4f1964185a5f2dba9baca7178 ff8dae07442f49508bdd01a77b98264d 20d3cbe4f1964185a5f2dba9baca7178--ff8dae07442f49508bdd01a77b98264d 615836096ae74c5792cd11767b156f2d ff8dae07442f49508bdd01a77b98264d--615836096ae74c5792cd11767b156f2d 48a7da680ecd43ab910c47c589ab5532 615836096ae74c5792cd11767b156f2d--48a7da680ecd43ab910c47c589ab5532 f3316dcecc114bb69b62881be628ef01 48a7da680ecd43ab910c47c589ab5532--f3316dcecc114bb69b62881be628ef01 c921c50fad3547e7a37422ce036fd7a2 f3316dcecc114bb69b62881be628ef01--c921c50fad3547e7a37422ce036fd7a2 9444d5251348457db95e91f361a47948 c921c50fad3547e7a37422ce036fd7a2--9444d5251348457db95e91f361a47948 c136715562834a9284dc2a35b6c7c736 9444d5251348457db95e91f361a47948--c136715562834a9284dc2a35b6c7c736 3771dd4e043448bfbdbaf4408704e996 c136715562834a9284dc2a35b6c7c736--3771dd4e043448bfbdbaf4408704e996 4f6c4ccafc9b402da794c6ca7fbbc95e 3771dd4e043448bfbdbaf4408704e996--4f6c4ccafc9b402da794c6ca7fbbc95e fbcd88b4ebd240c48d5e44e20bf6bb10 4f6c4ccafc9b402da794c6ca7fbbc95e--fbcd88b4ebd240c48d5e44e20bf6bb10 99537b9f6df2442b8de7dc36c882b3d4 fbcd88b4ebd240c48d5e44e20bf6bb10--99537b9f6df2442b8de7dc36c882b3d4 bdb13353ad664c0cbe532c8fadb4c1de 99537b9f6df2442b8de7dc36c882b3d4--bdb13353ad664c0cbe532c8fadb4c1de 399a1f0c76544876a7c2294d62c638b7 bdb13353ad664c0cbe532c8fadb4c1de--399a1f0c76544876a7c2294d62c638b7 e4292348543a414b89a701bbc7c1d7a9 399a1f0c76544876a7c2294d62c638b7--e4292348543a414b89a701bbc7c1d7a9 7020a0f30afd43df8339b113dceb2646 e4292348543a414b89a701bbc7c1d7a9--7020a0f30afd43df8339b113dceb2646 d36eb1ee99ab4e93bc90e0ad98c85ba0 7020a0f30afd43df8339b113dceb2646--d36eb1ee99ab4e93bc90e0ad98c85ba0 9810ba08004243b0a489b2575e1ffd99 d36eb1ee99ab4e93bc90e0ad98c85ba0--9810ba08004243b0a489b2575e1ffd99 9e566c24cc0f4eef82491ef60e175fa0 9810ba08004243b0a489b2575e1ffd99--9e566c24cc0f4eef82491ef60e175fa0 4966819024b84cae8ea74571cf180b18 9e566c24cc0f4eef82491ef60e175fa0--4966819024b84cae8ea74571cf180b18 8043ffa11bc04d38a63133b3e9597403 4966819024b84cae8ea74571cf180b18--8043ffa11bc04d38a63133b3e9597403 eb21a635a0a741ccae6d17d035f61af1 8043ffa11bc04d38a63133b3e9597403--eb21a635a0a741ccae6d17d035f61af1 4cae5c37a7cc4633a7bc7bfeb8b0c102 eb21a635a0a741ccae6d17d035f61af1--4cae5c37a7cc4633a7bc7bfeb8b0c102 68627545effc4739b434a1a2b31fba52 4cae5c37a7cc4633a7bc7bfeb8b0c102--68627545effc4739b434a1a2b31fba52 fe02b806b5d340d08d9c9e91b9e63670 68627545effc4739b434a1a2b31fba52--fe02b806b5d340d08d9c9e91b9e63670 a5a3791f2bd344eab29e89d444f4f87e fe02b806b5d340d08d9c9e91b9e63670--a5a3791f2bd344eab29e89d444f4f87e 851dd3262e924ad79901eb945b34d7b6 a5a3791f2bd344eab29e89d444f4f87e--851dd3262e924ad79901eb945b34d7b6 1a48e4c60b5c464782d655d90d495a13 851dd3262e924ad79901eb945b34d7b6--1a48e4c60b5c464782d655d90d495a13 592cc122a7634e858973707a30dc8fad 1a48e4c60b5c464782d655d90d495a13--592cc122a7634e858973707a30dc8fad 29a6c11f92fb4deab372a5ff5401b769 592cc122a7634e858973707a30dc8fad--29a6c11f92fb4deab372a5ff5401b769 cdc2381ac7c24dd39302f62d92a8cc0d X 29a6c11f92fb4deab372a5ff5401b769--cdc2381ac7c24dd39302f62d92a8cc0d cdc2381ac7c24dd39302f62d92a8cc0d--a74797d36d1645d88a65ac2f9d4be3df ebce2cc2dc2e45b5a5baf41b00884691 RZ(-1.0*g1) cdc2381ac7c24dd39302f62d92a8cc0d--ebce2cc2dc2e45b5a5baf41b00884691 e971713ae7f2473a9de4222c42ad0af5 X ebce2cc2dc2e45b5a5baf41b00884691--e971713ae7f2473a9de4222c42ad0af5 e971713ae7f2473a9de4222c42ad0af5--e0496f2fbdbd4d60aa19609f9db4c686 b37a4bc12ea1459691275b759e50a765 e971713ae7f2473a9de4222c42ad0af5--b37a4bc12ea1459691275b759e50a765 befafff084fc41cebe7806725c2a5a51 b37a4bc12ea1459691275b759e50a765--befafff084fc41cebe7806725c2a5a51 177c8670a3be414fba28584f80482078 befafff084fc41cebe7806725c2a5a51--177c8670a3be414fba28584f80482078 ba174e3ab4b3416e876da40e507d4402 177c8670a3be414fba28584f80482078--ba174e3ab4b3416e876da40e507d4402 b849efb33be44f6eb4ac132a4840147e ba174e3ab4b3416e876da40e507d4402--b849efb33be44f6eb4ac132a4840147e 7f50012a8d57449483bbfe9de498d098 b849efb33be44f6eb4ac132a4840147e--7f50012a8d57449483bbfe9de498d098 6d63fab2d95f42d99dbf0f545263281e RX(b17) 7f50012a8d57449483bbfe9de498d098--6d63fab2d95f42d99dbf0f545263281e 6d63fab2d95f42d99dbf0f545263281e--81aac8656acd489bb1fc03f27dd98486"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -2.256850795060263\nMaxCut cost at iteration 10: 6.196977171124766\nMaxCut cost at iteration 20: 6.893527974612319\nMaxCut cost at iteration 30: 6.960701635311692\nMaxCut cost at iteration 40: 6.970448111737511\nMaxCut cost at iteration 50: 6.999980833357501\nMaxCut cost at iteration 60: 6.999999993208131\nMaxCut cost at iteration 70: 6.9999999999975495\nMaxCut cost at iteration 80: 6.999999999999996\nMaxCut cost at iteration 90: 7.000000000000002\nMaxCut cost at iteration 100: 7.000000000000004\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 10110010  2023-10-16T14:58:06.823332 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.006756732932883166\nEpoch 40 - Loss: 0.0013178262682413558\nEpoch 60 - Loss: 0.00024411275385784526\nEpoch 80 - Loss: 1.8109270091472735e-05\nEpoch 100 - Loss: 3.3443547512265775e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-10-16T14:58:09.023237 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_tools/","title":"Tools for quantum machine learning","text":"<p>Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning</li> <li>a set of tools for optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/qml_tools/#quantum-machine-learning-constructors","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_tools/#feature-maps","title":"Feature maps","text":"<p>A few feature maps are directly available for loading classical data into quantum circuits by encoding them into gate rotation angles.</p> <pre><code>from qadence import feature_map\nn_qubits = 3\nfm = feature_map(n_qubits, fm_type=\"fourier\")\nfm = feature_map(n_qubits, fm_type=\"chebyshev\")\nfm = feature_map(n_qubits, fm_type=\"tower\")\n</code></pre> <pre><code>Fourier = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nChebyshev KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['2*acos(phi)']]\nTower KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['4*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['6*acos(phi)']]\n</code></pre>"},{"location":"qml/qml_tools/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> 8b3598b12a694350b13f119dba80017a 0 6adfaa2787e444efbf0a440530c3305b RX(theta\u2080) 8b3598b12a694350b13f119dba80017a--6adfaa2787e444efbf0a440530c3305b 76e4ec2ea6014d76a22e705cbc86a7ac 1 a4081bdf670048e3a6705fbddb81c335 RY(theta\u2083) 6adfaa2787e444efbf0a440530c3305b--a4081bdf670048e3a6705fbddb81c335 ac05f951798c4cdeb1db4f76b044807b RX(theta\u2086) a4081bdf670048e3a6705fbddb81c335--ac05f951798c4cdeb1db4f76b044807b d6c562e68b134a72b828733774558e00 ac05f951798c4cdeb1db4f76b044807b--d6c562e68b134a72b828733774558e00 342ae26459a84fe68624279cfd44ff2f d6c562e68b134a72b828733774558e00--342ae26459a84fe68624279cfd44ff2f c1c8202e90b94f4fb3f7e5f4dd76c903 RX(theta\u2089) 342ae26459a84fe68624279cfd44ff2f--c1c8202e90b94f4fb3f7e5f4dd76c903 8e2501274d6b4609a0e80c14f5151062 RY(theta\u2081\u2082) c1c8202e90b94f4fb3f7e5f4dd76c903--8e2501274d6b4609a0e80c14f5151062 c3477e78d0834621b00d4a2e07a3fa79 RX(theta\u2081\u2085) 8e2501274d6b4609a0e80c14f5151062--c3477e78d0834621b00d4a2e07a3fa79 7efca9e422624118be8db0c472c87e06 c3477e78d0834621b00d4a2e07a3fa79--7efca9e422624118be8db0c472c87e06 1e69c32ef1864c05823319c076e63cd6 7efca9e422624118be8db0c472c87e06--1e69c32ef1864c05823319c076e63cd6 524b1380152b4941af3bf27eb01ccbe0 1e69c32ef1864c05823319c076e63cd6--524b1380152b4941af3bf27eb01ccbe0 14640ffb77744b088c8956830da7bb6b c392814bc5c643b8a4440aee4295d788 RX(theta\u2081) 76e4ec2ea6014d76a22e705cbc86a7ac--c392814bc5c643b8a4440aee4295d788 fa38c2011e9140eeb985a34211660501 2 aa82c694f1404d65bec23b328cd3437a RY(theta\u2084) c392814bc5c643b8a4440aee4295d788--aa82c694f1404d65bec23b328cd3437a bc3315c9e74a448dbf787ecab41f5755 RX(theta\u2087) aa82c694f1404d65bec23b328cd3437a--bc3315c9e74a448dbf787ecab41f5755 b7429f7e019b457d9959cea7bdce73cd X bc3315c9e74a448dbf787ecab41f5755--b7429f7e019b457d9959cea7bdce73cd b7429f7e019b457d9959cea7bdce73cd--d6c562e68b134a72b828733774558e00 3e943c2a09b047989001c13c5507d05a b7429f7e019b457d9959cea7bdce73cd--3e943c2a09b047989001c13c5507d05a 42a38ccc066e4c75b958f68828dfa6c5 RX(theta\u2081\u2080) 3e943c2a09b047989001c13c5507d05a--42a38ccc066e4c75b958f68828dfa6c5 37c4bf2316fa4127965af60e75e754eb RY(theta\u2081\u2083) 42a38ccc066e4c75b958f68828dfa6c5--37c4bf2316fa4127965af60e75e754eb 45fa0f96bdb54ee9b2df5d99e17a8459 RX(theta\u2081\u2086) 37c4bf2316fa4127965af60e75e754eb--45fa0f96bdb54ee9b2df5d99e17a8459 14a2d78386cc442b83d04c8d09cba021 X 45fa0f96bdb54ee9b2df5d99e17a8459--14a2d78386cc442b83d04c8d09cba021 14a2d78386cc442b83d04c8d09cba021--7efca9e422624118be8db0c472c87e06 40fab3c782eb4e82bce032b3512d18e9 14a2d78386cc442b83d04c8d09cba021--40fab3c782eb4e82bce032b3512d18e9 40fab3c782eb4e82bce032b3512d18e9--14640ffb77744b088c8956830da7bb6b b9fc093ee1e14269b8ce4d1523ca4844 45e95fbc173f419087a2c7c96ccafdf8 RX(theta\u2082) fa38c2011e9140eeb985a34211660501--45e95fbc173f419087a2c7c96ccafdf8 6c7b360343d645c9be571fdc2695d582 RY(theta\u2085) 45e95fbc173f419087a2c7c96ccafdf8--6c7b360343d645c9be571fdc2695d582 a340f62b7d5a4f499c3819c9a43eece3 RX(theta\u2088) 6c7b360343d645c9be571fdc2695d582--a340f62b7d5a4f499c3819c9a43eece3 e5daaf0a2d034518a7a7eedb1ebf6218 a340f62b7d5a4f499c3819c9a43eece3--e5daaf0a2d034518a7a7eedb1ebf6218 99985b9031924aceac4321783e12f4f7 X e5daaf0a2d034518a7a7eedb1ebf6218--99985b9031924aceac4321783e12f4f7 99985b9031924aceac4321783e12f4f7--3e943c2a09b047989001c13c5507d05a 0f1c604ce7444cfba2f73e237ea50ed3 RX(theta\u2081\u2081) 99985b9031924aceac4321783e12f4f7--0f1c604ce7444cfba2f73e237ea50ed3 58951e612b0943849b11e5dcb864ecbc RY(theta\u2081\u2084) 0f1c604ce7444cfba2f73e237ea50ed3--58951e612b0943849b11e5dcb864ecbc 77868101f8d244a8b6e097b2abef06df RX(theta\u2081\u2087) 58951e612b0943849b11e5dcb864ecbc--77868101f8d244a8b6e097b2abef06df 8a00cd2ee07e4210b2741c00088d44f6 77868101f8d244a8b6e097b2abef06df--8a00cd2ee07e4210b2741c00088d44f6 47b7b63dae7c4a73b6d78e9f22e19ca8 X 8a00cd2ee07e4210b2741c00088d44f6--47b7b63dae7c4a73b6d78e9f22e19ca8 47b7b63dae7c4a73b6d78e9f22e19ca8--40fab3c782eb4e82bce032b3512d18e9 47b7b63dae7c4a73b6d78e9f22e19ca8--b9fc093ee1e14269b8ce4d1523ca4844 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> 375e2f5bb11a43e2be1e4f5ce408b458 0 13a023eec59042abb6c3179881b0fb24 RX(phi\u2080) 375e2f5bb11a43e2be1e4f5ce408b458--13a023eec59042abb6c3179881b0fb24 3d01051b39f045aaab1a67cfba51c20f 1 68a5b43c088e4c2ebc024fb33efdb235 RY(phi\u2083) 13a023eec59042abb6c3179881b0fb24--68a5b43c088e4c2ebc024fb33efdb235 4f6df5947ad741c5ad6714028079d7b9 RX(phi\u2086) 68a5b43c088e4c2ebc024fb33efdb235--4f6df5947ad741c5ad6714028079d7b9 bb19429f7ef54987be53a7d81cb36a21 4f6df5947ad741c5ad6714028079d7b9--bb19429f7ef54987be53a7d81cb36a21 cfd56d8f2ac148ef9040d0b63486b496 bb19429f7ef54987be53a7d81cb36a21--cfd56d8f2ac148ef9040d0b63486b496 eb26107617e642e1835dfbedf880b947 RX(phi\u2089) cfd56d8f2ac148ef9040d0b63486b496--eb26107617e642e1835dfbedf880b947 eca92183be5f4e5382938ce2338d27d4 RY(phi\u2081\u2082) eb26107617e642e1835dfbedf880b947--eca92183be5f4e5382938ce2338d27d4 7f7c37456fc94fff883dc9114df737be RX(phi\u2081\u2085) eca92183be5f4e5382938ce2338d27d4--7f7c37456fc94fff883dc9114df737be 898402580e2242ccbd56c1c7cc347a56 7f7c37456fc94fff883dc9114df737be--898402580e2242ccbd56c1c7cc347a56 7e6cca96a8234675970f18ef5f0bb4c0 898402580e2242ccbd56c1c7cc347a56--7e6cca96a8234675970f18ef5f0bb4c0 6e0fbb5b9e9b40d6b6214776ce58dc72 7e6cca96a8234675970f18ef5f0bb4c0--6e0fbb5b9e9b40d6b6214776ce58dc72 d1c309adf37b4e6db0f80bfebf5cf855 3b91df2389154041b9a626d9e2aa54bf RX(phi\u2081) 3d01051b39f045aaab1a67cfba51c20f--3b91df2389154041b9a626d9e2aa54bf b15cdbbcd40e4a1e89bff1b90def586e 2 3a14f84e87c840d0b109cd44e293d2b8 RY(phi\u2084) 3b91df2389154041b9a626d9e2aa54bf--3a14f84e87c840d0b109cd44e293d2b8 8b5b77f4e42e4b33b0048e217a2536bc RX(phi\u2087) 3a14f84e87c840d0b109cd44e293d2b8--8b5b77f4e42e4b33b0048e217a2536bc fc9169404d1a416face9726a68d93a4d PHASE(phi_ent\u2080) 8b5b77f4e42e4b33b0048e217a2536bc--fc9169404d1a416face9726a68d93a4d fc9169404d1a416face9726a68d93a4d--bb19429f7ef54987be53a7d81cb36a21 a8a98c1028f744a392e393e8ad7251e0 fc9169404d1a416face9726a68d93a4d--a8a98c1028f744a392e393e8ad7251e0 c4c6bdb124214cc79d2e1ee8154095b3 RX(phi\u2081\u2080) a8a98c1028f744a392e393e8ad7251e0--c4c6bdb124214cc79d2e1ee8154095b3 0fe7dabaa6374a8dafb3e0fdfdb5c6fc RY(phi\u2081\u2083) c4c6bdb124214cc79d2e1ee8154095b3--0fe7dabaa6374a8dafb3e0fdfdb5c6fc e3ae918aff384d94b2094272f34d6e86 RX(phi\u2081\u2086) 0fe7dabaa6374a8dafb3e0fdfdb5c6fc--e3ae918aff384d94b2094272f34d6e86 9b9eca81a1604e35bce602f74ef11690 PHASE(phi_ent\u2082) e3ae918aff384d94b2094272f34d6e86--9b9eca81a1604e35bce602f74ef11690 9b9eca81a1604e35bce602f74ef11690--898402580e2242ccbd56c1c7cc347a56 cd13d5aff36847878320b6179b2ae689 9b9eca81a1604e35bce602f74ef11690--cd13d5aff36847878320b6179b2ae689 cd13d5aff36847878320b6179b2ae689--d1c309adf37b4e6db0f80bfebf5cf855 252ec8e1c90642718a9379552bcc7799 09086c2e1a274d1f9d1559fe3c49d89f RX(phi\u2082) b15cdbbcd40e4a1e89bff1b90def586e--09086c2e1a274d1f9d1559fe3c49d89f 29d9644193a449359dcfe486c2bb3868 RY(phi\u2085) 09086c2e1a274d1f9d1559fe3c49d89f--29d9644193a449359dcfe486c2bb3868 42a363d3c336400f93891411b58b419d RX(phi\u2088) 29d9644193a449359dcfe486c2bb3868--42a363d3c336400f93891411b58b419d e0bc82749f184331b89ce0fc50d58bea 42a363d3c336400f93891411b58b419d--e0bc82749f184331b89ce0fc50d58bea c3ca37e2f053429aa6723f8e90f04997 PHASE(phi_ent\u2081) e0bc82749f184331b89ce0fc50d58bea--c3ca37e2f053429aa6723f8e90f04997 c3ca37e2f053429aa6723f8e90f04997--a8a98c1028f744a392e393e8ad7251e0 5a7312f635214694be38d8a889aa1fab RX(phi\u2081\u2081) c3ca37e2f053429aa6723f8e90f04997--5a7312f635214694be38d8a889aa1fab d64d1847e25843d488e455a268a3e979 RY(phi\u2081\u2084) 5a7312f635214694be38d8a889aa1fab--d64d1847e25843d488e455a268a3e979 e4f95a656b7747af9d6f0a5daed90047 RX(phi\u2081\u2087) d64d1847e25843d488e455a268a3e979--e4f95a656b7747af9d6f0a5daed90047 c27f2b937b874b72a6d5f0be8ee2949e e4f95a656b7747af9d6f0a5daed90047--c27f2b937b874b72a6d5f0be8ee2949e fd10641d57c64d1dbae612cc8c228af4 PHASE(phi_ent\u2083) c27f2b937b874b72a6d5f0be8ee2949e--fd10641d57c64d1dbae612cc8c228af4 fd10641d57c64d1dbae612cc8c228af4--cd13d5aff36847878320b6179b2ae689 fd10641d57c64d1dbae612cc8c228af4--252ec8e1c90642718a9379552bcc7799 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like NN interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> cluster_66a265c88ed146de8867282dd9a7bc03 cluster_ea8ec54191a64bc5bff5cbc635ea4863 ab5bf090df20475ab85bd727c48fc53c 0 f070f7ec28824e6bb60021b1ada807eb RX(theta\u2080) ab5bf090df20475ab85bd727c48fc53c--f070f7ec28824e6bb60021b1ada807eb 0667e2ee1b474beb84916fb8d0d0adbf 1 f29d0a0545f443108a00bac940812878 RY(theta\u2083) f070f7ec28824e6bb60021b1ada807eb--f29d0a0545f443108a00bac940812878 94f2b4f371d74ee39017fcd2ef73128e RX(theta\u2086) f29d0a0545f443108a00bac940812878--94f2b4f371d74ee39017fcd2ef73128e a89da0ceb3c840c5b674e0a4b795d2f1 HamEvo 94f2b4f371d74ee39017fcd2ef73128e--a89da0ceb3c840c5b674e0a4b795d2f1 445510b7872d4e068267f77f7179bd61 RX(theta\u2089) a89da0ceb3c840c5b674e0a4b795d2f1--445510b7872d4e068267f77f7179bd61 512fd4f3e4254f9285c8364fd4d1a3ad RY(theta\u2081\u2082) 445510b7872d4e068267f77f7179bd61--512fd4f3e4254f9285c8364fd4d1a3ad c514792c722344bd9bf127148e0533f7 RX(theta\u2081\u2085) 512fd4f3e4254f9285c8364fd4d1a3ad--c514792c722344bd9bf127148e0533f7 bccc383862bd473db4b0402033ccb50d HamEvo c514792c722344bd9bf127148e0533f7--bccc383862bd473db4b0402033ccb50d 530677a6ea754c75acb4c18d8a3ecc35 bccc383862bd473db4b0402033ccb50d--530677a6ea754c75acb4c18d8a3ecc35 91b73ee7ff2c40858f411832c3013240 7448ee6908d241c381bdb4e1db7ad2ca RX(theta\u2081) 0667e2ee1b474beb84916fb8d0d0adbf--7448ee6908d241c381bdb4e1db7ad2ca 598fb3b91bc5452c80cad5752df887ae 2 5f6f4bd060ce4fb0ad3adbebd20ebbf1 RY(theta\u2084) 7448ee6908d241c381bdb4e1db7ad2ca--5f6f4bd060ce4fb0ad3adbebd20ebbf1 866166c93c8f43ae8b945f6d19d970c0 RX(theta\u2087) 5f6f4bd060ce4fb0ad3adbebd20ebbf1--866166c93c8f43ae8b945f6d19d970c0 c3afd1a582934a958cc7d2fc16e8c891 t = theta_t\u2080 866166c93c8f43ae8b945f6d19d970c0--c3afd1a582934a958cc7d2fc16e8c891 abc444a48545435dbc57e366a6dd000b RX(theta\u2081\u2080) c3afd1a582934a958cc7d2fc16e8c891--abc444a48545435dbc57e366a6dd000b 4b6ba5b2ba9c4ef3a8e1828d3502cf50 RY(theta\u2081\u2083) abc444a48545435dbc57e366a6dd000b--4b6ba5b2ba9c4ef3a8e1828d3502cf50 e19726347e434a50ad302322d9a30e1c RX(theta\u2081\u2086) 4b6ba5b2ba9c4ef3a8e1828d3502cf50--e19726347e434a50ad302322d9a30e1c c20256d0114f45628ca5cb8849848b75 t = theta_t\u2081 e19726347e434a50ad302322d9a30e1c--c20256d0114f45628ca5cb8849848b75 c20256d0114f45628ca5cb8849848b75--91b73ee7ff2c40858f411832c3013240 40006e5b0c444aa8a638a152650c96fd 510d70b0f41748469a065bdcc9bbe1ed RX(theta\u2082) 598fb3b91bc5452c80cad5752df887ae--510d70b0f41748469a065bdcc9bbe1ed 2c2158e4c89a4e57893e592883df9828 RY(theta\u2085) 510d70b0f41748469a065bdcc9bbe1ed--2c2158e4c89a4e57893e592883df9828 09e032503720436d82bb7d12b9419b94 RX(theta\u2088) 2c2158e4c89a4e57893e592883df9828--09e032503720436d82bb7d12b9419b94 e87624b620e744d2885b0b2020df77af 09e032503720436d82bb7d12b9419b94--e87624b620e744d2885b0b2020df77af a8ab4a6902d14161b647d9d88c090765 RX(theta\u2081\u2081) e87624b620e744d2885b0b2020df77af--a8ab4a6902d14161b647d9d88c090765 2f123c18d4c34f85bfe2dbaf1c453bf1 RY(theta\u2081\u2084) a8ab4a6902d14161b647d9d88c090765--2f123c18d4c34f85bfe2dbaf1c453bf1 99fd44d783294d6a87981873e46191ca RX(theta\u2081\u2087) 2f123c18d4c34f85bfe2dbaf1c453bf1--99fd44d783294d6a87981873e46191ca 88ef9cf8b75d4e8eb39127d5ee941d09 99fd44d783294d6a87981873e46191ca--88ef9cf8b75d4e8eb39127d5ee941d09 88ef9cf8b75d4e8eb39127d5ee941d09--40006e5b0c444aa8a638a152650c96fd <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> cluster_2772b3f399814a7995d211f3e7baa5e2 cluster_ff8cf9afeef54f4a84aa85c766958151 62d660c42a174cc28f4a7bd38d62b5cc 0 73689367c80c4f7098da15c0e3cc41fb RX(theta\u2080) 62d660c42a174cc28f4a7bd38d62b5cc--73689367c80c4f7098da15c0e3cc41fb f5eaec2e61054733afad1718f8712d2b 1 1fc20b617d9b42afb9b89fde56892ce7 RY(theta\u2086) 73689367c80c4f7098da15c0e3cc41fb--1fc20b617d9b42afb9b89fde56892ce7 40b3d757c0f74ceca19c6a74e2d3f1d2 RX(theta\u2081\u2082) 1fc20b617d9b42afb9b89fde56892ce7--40b3d757c0f74ceca19c6a74e2d3f1d2 c643e41d75e84859b8acd33d064525d1 40b3d757c0f74ceca19c6a74e2d3f1d2--c643e41d75e84859b8acd33d064525d1 f8e88fca48474122aa6e2c33a03f5d16 RX(theta\u2081\u2088) c643e41d75e84859b8acd33d064525d1--f8e88fca48474122aa6e2c33a03f5d16 1c7d420d9e114efe9ff00603cfae3092 RY(theta\u2082\u2084) f8e88fca48474122aa6e2c33a03f5d16--1c7d420d9e114efe9ff00603cfae3092 6f0fe753a5a942369f1fb2157d1ff918 RX(theta\u2083\u2080) 1c7d420d9e114efe9ff00603cfae3092--6f0fe753a5a942369f1fb2157d1ff918 95a6d499adc04d8a9512b51386dd4460 6f0fe753a5a942369f1fb2157d1ff918--95a6d499adc04d8a9512b51386dd4460 b9ce345f5ee5448c8ac1367570b31277 95a6d499adc04d8a9512b51386dd4460--b9ce345f5ee5448c8ac1367570b31277 4c62a55185614956a67ae275b8349983 05ad9a927f6d4ac8ab36b14ca01bec0b RX(theta\u2081) f5eaec2e61054733afad1718f8712d2b--05ad9a927f6d4ac8ab36b14ca01bec0b 478a29df74a541fabaa866c82748d7e2 2 52cb5f24400b4a0c886b4c8ec113c74d RY(theta\u2087) 05ad9a927f6d4ac8ab36b14ca01bec0b--52cb5f24400b4a0c886b4c8ec113c74d 634c9561c2514a77b164d09945547ed8 RX(theta\u2081\u2083) 52cb5f24400b4a0c886b4c8ec113c74d--634c9561c2514a77b164d09945547ed8 5172c445bb6549c1b48e95bcce17b2d3 634c9561c2514a77b164d09945547ed8--5172c445bb6549c1b48e95bcce17b2d3 23eb7247d84f4ac5b323132f71459e8a RX(theta\u2081\u2089) 5172c445bb6549c1b48e95bcce17b2d3--23eb7247d84f4ac5b323132f71459e8a 3bffdb89dd474f1fae5deba5db8d5b34 RY(theta\u2082\u2085) 23eb7247d84f4ac5b323132f71459e8a--3bffdb89dd474f1fae5deba5db8d5b34 c206cc6b5e4c458983b2b50155662c25 RX(theta\u2083\u2081) 3bffdb89dd474f1fae5deba5db8d5b34--c206cc6b5e4c458983b2b50155662c25 c2ad435c443d40529f5950cc90613119 c206cc6b5e4c458983b2b50155662c25--c2ad435c443d40529f5950cc90613119 c2ad435c443d40529f5950cc90613119--4c62a55185614956a67ae275b8349983 38fb483ec19944ca86b5f4c1c8b00ac3 c3cc05fe9b6f45daa4585b807e0108b8 RX(theta\u2082) 478a29df74a541fabaa866c82748d7e2--c3cc05fe9b6f45daa4585b807e0108b8 813e66547d0948fd879343f068d4fa6f 3 bd5b6fbb4ebf4b3e86995b819bcb94c9 RY(theta\u2088) c3cc05fe9b6f45daa4585b807e0108b8--bd5b6fbb4ebf4b3e86995b819bcb94c9 6a3c31f9ff864a34b42df92b982706ae RX(theta\u2081\u2084) bd5b6fbb4ebf4b3e86995b819bcb94c9--6a3c31f9ff864a34b42df92b982706ae fabdd7a7d24842bb95de3b35f7dd4f5b HamEvo 6a3c31f9ff864a34b42df92b982706ae--fabdd7a7d24842bb95de3b35f7dd4f5b 6ad6af69acb048a19e87ab48ccd681d2 RX(theta\u2082\u2080) fabdd7a7d24842bb95de3b35f7dd4f5b--6ad6af69acb048a19e87ab48ccd681d2 faae49e287e24fcdb3026562f4fa94de RY(theta\u2082\u2086) 6ad6af69acb048a19e87ab48ccd681d2--faae49e287e24fcdb3026562f4fa94de ec05f17bca2d4d1495c0e94010e563e3 RX(theta\u2083\u2082) faae49e287e24fcdb3026562f4fa94de--ec05f17bca2d4d1495c0e94010e563e3 fd4cfa04a19c41e0abb34e6af8d2b139 HamEvo ec05f17bca2d4d1495c0e94010e563e3--fd4cfa04a19c41e0abb34e6af8d2b139 fd4cfa04a19c41e0abb34e6af8d2b139--38fb483ec19944ca86b5f4c1c8b00ac3 a3fdf60019ae4a37987cc1a980711962 a64cadf7848a42a49760b4add57f008e RX(theta\u2083) 813e66547d0948fd879343f068d4fa6f--a64cadf7848a42a49760b4add57f008e 6c2e3290d0e34c8b9145958047df079a 4 1d5dafd3af544f6a8e48c536784bdc7c RY(theta\u2089) a64cadf7848a42a49760b4add57f008e--1d5dafd3af544f6a8e48c536784bdc7c 21fac1a114ef47ee9960215fcc767b7c RX(theta\u2081\u2085) 1d5dafd3af544f6a8e48c536784bdc7c--21fac1a114ef47ee9960215fcc767b7c e19ba2bb30634fdf8c2eb923e18aff37 t = theta_t\u2080 21fac1a114ef47ee9960215fcc767b7c--e19ba2bb30634fdf8c2eb923e18aff37 44c98a70d7b944c2910d7441bebe027c RX(theta\u2082\u2081) e19ba2bb30634fdf8c2eb923e18aff37--44c98a70d7b944c2910d7441bebe027c f95f85b9fa074f17be8cc03bf6971667 RY(theta\u2082\u2087) 44c98a70d7b944c2910d7441bebe027c--f95f85b9fa074f17be8cc03bf6971667 e742bb26364c4397921d5d467e120352 RX(theta\u2083\u2083) f95f85b9fa074f17be8cc03bf6971667--e742bb26364c4397921d5d467e120352 9c09caa199df48e385508c7db562480b t = theta_t\u2081 e742bb26364c4397921d5d467e120352--9c09caa199df48e385508c7db562480b 9c09caa199df48e385508c7db562480b--a3fdf60019ae4a37987cc1a980711962 8ed6c432689c4d1ea98f4971a5d4e482 2ac6ddfd0f47496ea8ebdf7bcb6b3578 RX(theta\u2084) 6c2e3290d0e34c8b9145958047df079a--2ac6ddfd0f47496ea8ebdf7bcb6b3578 335f493d9f9d455783ba0f6db791135b 5 5ff075af9833449ea911465fd5ccc9e1 RY(theta\u2081\u2080) 2ac6ddfd0f47496ea8ebdf7bcb6b3578--5ff075af9833449ea911465fd5ccc9e1 335dc482110449d4a189fc0f7e41ade1 RX(theta\u2081\u2086) 5ff075af9833449ea911465fd5ccc9e1--335dc482110449d4a189fc0f7e41ade1 f1c6aea5ac2f4922ac2965fb8175c0f1 335dc482110449d4a189fc0f7e41ade1--f1c6aea5ac2f4922ac2965fb8175c0f1 42a76de7dde44e7ebbeb09b680ea0a5e RX(theta\u2082\u2082) f1c6aea5ac2f4922ac2965fb8175c0f1--42a76de7dde44e7ebbeb09b680ea0a5e 54bbd1a0d7f74586ba26374a3174b489 RY(theta\u2082\u2088) 42a76de7dde44e7ebbeb09b680ea0a5e--54bbd1a0d7f74586ba26374a3174b489 3f8c8734cccb4922865b0fc37e0a517b RX(theta\u2083\u2084) 54bbd1a0d7f74586ba26374a3174b489--3f8c8734cccb4922865b0fc37e0a517b ca773bdf04c24a8ab838357f836bbe29 3f8c8734cccb4922865b0fc37e0a517b--ca773bdf04c24a8ab838357f836bbe29 ca773bdf04c24a8ab838357f836bbe29--8ed6c432689c4d1ea98f4971a5d4e482 1033f53960b14b9d8f0717a4b6e4cc2d 396ebd6eee124c1797671cafcaf71ec8 RX(theta\u2085) 335f493d9f9d455783ba0f6db791135b--396ebd6eee124c1797671cafcaf71ec8 46817a1b71ef4bdea42b43df64dead25 RY(theta\u2081\u2081) 396ebd6eee124c1797671cafcaf71ec8--46817a1b71ef4bdea42b43df64dead25 b0d66647672343fb88457a80504cf415 RX(theta\u2081\u2087) 46817a1b71ef4bdea42b43df64dead25--b0d66647672343fb88457a80504cf415 9a9cd22da10c43d9abc0502d06c9f96d b0d66647672343fb88457a80504cf415--9a9cd22da10c43d9abc0502d06c9f96d 151df55a92a142a6b0c142c6f88a463a RX(theta\u2082\u2083) 9a9cd22da10c43d9abc0502d06c9f96d--151df55a92a142a6b0c142c6f88a463a 88873e5c95894c13b3ed05668c89888a RY(theta\u2082\u2089) 151df55a92a142a6b0c142c6f88a463a--88873e5c95894c13b3ed05668c89888a a9eb55df018443879dc65a2291231c85 RX(theta\u2083\u2085) 88873e5c95894c13b3ed05668c89888a--a9eb55df018443879dc65a2291231c85 35f151fa32a04b1f99671eafd9e49a03 a9eb55df018443879dc65a2291231c85--35f151fa32a04b1f99671eafd9e49a03 35f151fa32a04b1f99671eafd9e49a03--1033f53960b14b9d8f0717a4b6e4cc2d"},{"location":"qml/qml_tools/#machine-learning-tools","title":"Machine Learning Tools","text":""},{"location":"qml/qml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using <code>qadence</code>, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader\ndef dataloader() -&gt; DataLoader:\nbatch_size = 5\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\nreturn DataLoader(dataset, batch_size=batch_size)\ndef dictdataloader() -&gt; DictDataLoader:\nbatch_size = 5\nkeys = [\"y1\", \"y2\"]\ndls = {}\nfor k in keys:\nx = torch.rand(batch_size, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\ndataloader = DataLoader(dataset, batch_size=batch_size)\ndls[k] = dataloader\nreturn DictDataLoader(dls)\nn_epochs = 2\n# iterate standard DataLoader\ndl = dataloader()\nfor i in range(n_epochs):\ndata = next(iter(dl))\n# iterate DictDataLoader\nddl = dictdataloader()\nfor i in range(n_epochs):\ndata = next(iter(ddl))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"qml/qml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, <code>qadence</code> also offers a few out-of-the-box routines for optimizing differentiable models like <code>QNN</code>s and <code>QuantumModel</code>s containing either trainable and/or non-trainable parameters (you can refer to this for a refresh about different parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <pre><code>\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <pre><code>\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/qml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nimport matplotlib.pyplot as plt\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\nplt.plot(y.numpy())\nplt.plot(model(input_values).detach().numpy())\n</code></pre> <pre><code>\n</code></pre> <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/qml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1,2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 307ac4ab-c752-4ba5-b12a-543d16e111b8, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': aebc4a65-72be-4546-8f8e-727da0245d1c, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': aad4323d-f680-4d99-a8c1-fac36699e670, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 066e4205-81fb-4eb7-84f6-ac3a28b8dfd1, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': d1c8e841-bf08-4e71-a007-0de951b416ff, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': c899aa8d-1baa-4099-94b2-efdc06370bf5, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 1deaba2a-dddc-417e-b9e4-d707e0924fed, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 65aa5474-c5b1-4d65-a61e-2640c68a6f2e, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 3dc702b6-4765-404d-85aa-6ed57dafdc4a, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 01daf613-58f2-4056-8e0e-5600d95fc34f, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': dc48c13e-777c-41bd-be30-d23a29c212fb, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_4: tensor([0.0779], requires_grad=True)\ntheta_1: tensor([0.9099], requires_grad=True)\ntheta_3: tensor([0.4370], requires_grad=True)\ntheta_5: tensor([0.3829], requires_grad=True)\ntheta_0: tensor([0.7224], requires_grad=True)\ntheta_2: tensor([0.8681], requires_grad=True)\ntheta_6: tensor([0.5825], requires_grad=True)\ntheta_8: tensor([0.1922], requires_grad=True)\ntheta_7: tensor([0.8215], requires_grad=True)\n}\nembedded = {\n307ac4ab-c752-4ba5-b12a-543d16e111b8: tensor([3., 3.])\naebc4a65-72be-4546-8f8e-727da0245d1c: tensor([2., 2.])\naad4323d-f680-4d99-a8c1-fac36699e670: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\n066e4205-81fb-4eb7-84f6-ac3a28b8dfd1: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\nd1c8e841-bf08-4e71-a007-0de951b416ff: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\nc899aa8d-1baa-4099-94b2-efdc06370bf5: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\n1deaba2a-dddc-417e-b9e4-d707e0924fed: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\n65aa5474-c5b1-4d65-a61e-2640c68a6f2e: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\n3dc702b6-4765-404d-85aa-6ed57dafdc4a: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\n01daf613-58f2-4056-8e0e-5600d95fc34f: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\ndc48c13e-777c-41bd-be30-d23a29c212fb: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_4: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\ntheta_5: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_2: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\ntheta_6: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.])\ntheta_7: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j],\n[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 175, '011': 143, '100': 142, '111': 123, '010': 118, '001': 106, '101': 98, '110': 95})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(307ac4ab-c752-4ba5-b12a-543d16e111b8)-C----------------------------------------Rx(aad4323d-f680-4d99-a8c1-fac36699e670)-Ry(c899aa8d-1baa-4099-94b2-efdc06370bf5)-Rx(3dc702b6-4765-404d-85aa-6ed57dafdc4a)-C---\n|                                                                                                                                                                   |   q1 : -Rz(aebc4a65-72be-4546-8f8e-727da0245d1c)-X----------------------------------------Rx(066e4205-81fb-4eb7-84f6-ac3a28b8dfd1)-Ry(1deaba2a-dddc-417e-b9e4-d707e0924fed)-Rx(01daf613-58f2-4056-8e0e-5600d95fc34f)-X-C-\n| q2 : -Rx(d1c8e841-bf08-4e71-a007-0de951b416ff)-Ry(65aa5474-c5b1-4d65-a61e-2640c68a6f2e)-Rx(dc48c13e-777c-41bd-be30-d23a29c212fb)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [01daf613-58f2-4056-8e0e-5600d95fc34f, 066e4205-81fb-4eb7-84f6-ac3a28b8dfd1, 1deaba2a-dddc-417e-b9e4-d707e0924fed, 307ac4ab-c752-4ba5-b12a-543d16e111b8, 3dc702b6-4765-404d-85aa-6ed57dafdc4a, 65aa5474-c5b1-4d65-a61e-2640c68a6f2e, aad4323d-f680-4d99-a8c1-fac36699e670, aebc4a65-72be-4546-8f8e-727da0245d1c, c899aa8d-1baa-4099-94b2-efdc06370bf5, d1c8e841-bf08-4e71-a007-0de951b416ff, dc48c13e-777c-41bd-be30-d23a29c212fb].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(0.73)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.72)-DEPO(0.1)-Ry(0.44)-DEPO(0.1)-Rx(0.58)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.96)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.91)-DEPO(0.1)-Ry(0.08)-DEPO(0.1)-Rx(0.82)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.87)-DEPO(0.1)-Ry(0.38)-DEPO(0.1)-Rx(0.19)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> 539fad213a4f43bf8731b6aa1abd2a21 0 1eee343067f94fc59a990180f970814a X 539fad213a4f43bf8731b6aa1abd2a21--1eee343067f94fc59a990180f970814a 29c2ca8a4ed24c77b032f51acc8945ba 1 93283764ad62400cbc3a0293be2fe62f 1eee343067f94fc59a990180f970814a--93283764ad62400cbc3a0293be2fe62f 03b545e740804434a94f2ab08c4f3aad 4b2519917dc546bcab08b190166b602d Y 29c2ca8a4ed24c77b032f51acc8945ba--4b2519917dc546bcab08b190166b602d 4b2519917dc546bcab08b190166b602d--03b545e740804434a94f2ab08c4f3aad </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> 53d465e8a5cd4772a5c9bcb51506b71f 0 880bf770aa1f4477998d98c3d3a4b5b9 RX(0.5) 53d465e8a5cd4772a5c9bcb51506b71f--880bf770aa1f4477998d98c3d3a4b5b9 0a1438a2f6dc40388c39f0ff40baeae0 880bf770aa1f4477998d98c3d3a4b5b9--0a1438a2f6dc40388c39f0ff40baeae0 <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> 5510d41783494812a2f6b9311783e535 0 41da1b1789fd40019fb68b13b50f6bbd 5510d41783494812a2f6b9311783e535--41da1b1789fd40019fb68b13b50f6bbd 05512033918f443fb2f679d13c8adf49 1 96c0e3a11ed14762a041d5c87c49d561 41da1b1789fd40019fb68b13b50f6bbd--96c0e3a11ed14762a041d5c87c49d561 2c4bd40509b04a078fe0dc26ffe48ee5 3857b35515854158a925640878439341 X 05512033918f443fb2f679d13c8adf49--3857b35515854158a925640878439341 3857b35515854158a925640878439341--41da1b1789fd40019fb68b13b50f6bbd 3857b35515854158a925640878439341--2c4bd40509b04a078fe0dc26ffe48ee5 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> 6e0b890edbf948309cafea5bc4086b28 0 ecd0dfd0c8604237a9224517ca84183e X 6e0b890edbf948309cafea5bc4086b28--ecd0dfd0c8604237a9224517ca84183e 7e391968366b4353ba4674c2b9596e6a X ecd0dfd0c8604237a9224517ca84183e--7e391968366b4353ba4674c2b9596e6a a04328015ac84085ad9a96a0ec6e0c63 7e391968366b4353ba4674c2b9596e6a--a04328015ac84085ad9a96a0ec6e0c63 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> e2c82c3d8f074500991d8b3300c20b50 0 7e7dd5502b4d4cb0b9279bfb1afc715c X e2c82c3d8f074500991d8b3300c20b50--7e7dd5502b4d4cb0b9279bfb1afc715c 82c360b5f26c42d7a67a5757bde183b4 1 22e7bdb70f5f422b8598a8ab2a9efdd1 7e7dd5502b4d4cb0b9279bfb1afc715c--22e7bdb70f5f422b8598a8ab2a9efdd1 5c8eca6a970245eb9f8e95c367794ccc 22e7bdb70f5f422b8598a8ab2a9efdd1--5c8eca6a970245eb9f8e95c367794ccc 1217edd401c34695833a651a4a60c1cb a05d5fd8e0d74bdca4df58343be181cf 82c360b5f26c42d7a67a5757bde183b4--a05d5fd8e0d74bdca4df58343be181cf e4503248e05c486d99c48b0a95e03b03 X a05d5fd8e0d74bdca4df58343be181cf--e4503248e05c486d99c48b0a95e03b03 e4503248e05c486d99c48b0a95e03b03--1217edd401c34695833a651a4a60c1cb </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> c05dc3ac8f6c4b3d8140c33b9e06237a 0 157d1d0f0a924e1090bd3cd97df15335 X c05dc3ac8f6c4b3d8140c33b9e06237a--157d1d0f0a924e1090bd3cd97df15335 518ea1cead8242e2a918f5e44393df4d 1 66658844f2ff4d0ea26618aebbf6ec04 157d1d0f0a924e1090bd3cd97df15335--66658844f2ff4d0ea26618aebbf6ec04 a88906e3fd1f4729adae7b52318531b1 72da42ecc4e5417a8a724f1a5aae6478 X 518ea1cead8242e2a918f5e44393df4d--72da42ecc4e5417a8a724f1a5aae6478 72da42ecc4e5417a8a724f1a5aae6478--a88906e3fd1f4729adae7b52318531b1 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> cluster_3eb7b4af3ad14d93bbbcb4b0d9af83ee subblock cluster_1a10cbca0ed74af08238e7061b1e529d subblock ad4dd81d9c864fb69f92d687cc419639 0 23ad9025b6154d0baa4d1802ba60fc08 X ad4dd81d9c864fb69f92d687cc419639--23ad9025b6154d0baa4d1802ba60fc08 f1342f593a1f46e787c19031436a6789 1 8f7ec60a5dc14d748ce81a1e7947b88e X 23ad9025b6154d0baa4d1802ba60fc08--8f7ec60a5dc14d748ce81a1e7947b88e 07b4f2a3e7e047558603a7d4d334ec4a 8f7ec60a5dc14d748ce81a1e7947b88e--07b4f2a3e7e047558603a7d4d334ec4a f66202a45fd6429594ed0b2bee4f8849 9be476c5cfb3461aa5042e14a62bd165 Y f1342f593a1f46e787c19031436a6789--9be476c5cfb3461aa5042e14a62bd165 1ce42d1b09c64dcd8094b02c0b928b9f 2 0f451b0dad0543fe931058416d723e1b Y 9be476c5cfb3461aa5042e14a62bd165--0f451b0dad0543fe931058416d723e1b 0f451b0dad0543fe931058416d723e1b--f66202a45fd6429594ed0b2bee4f8849 ede919219e7e419ab648f3ef8e027a24 bda67cc318864917859487c374bf7806 1ce42d1b09c64dcd8094b02c0b928b9f--bda67cc318864917859487c374bf7806 2d85e367df924ab48e8bd324afd52c18 3 c9cc096909c24ec3991c597c24fe8062 bda67cc318864917859487c374bf7806--c9cc096909c24ec3991c597c24fe8062 c9cc096909c24ec3991c597c24fe8062--ede919219e7e419ab648f3ef8e027a24 6896869881784559a5800680dd180511 0ff3b8e5cb374e4eaa4ead413770ccb9 2d85e367df924ab48e8bd324afd52c18--0ff3b8e5cb374e4eaa4ead413770ccb9 7db7381e42d0471b83914ff3e89f33a4 4 cba5039351ad4f069b18f1dcc8db9a64 0ff3b8e5cb374e4eaa4ead413770ccb9--cba5039351ad4f069b18f1dcc8db9a64 cba5039351ad4f069b18f1dcc8db9a64--6896869881784559a5800680dd180511 9cbbb3903d754341b629992322f7b732 47bdf0cc8bbf43c58f1cde1a3682f674 X 7db7381e42d0471b83914ff3e89f33a4--47bdf0cc8bbf43c58f1cde1a3682f674 47bdf0cc8bbf43c58f1cde1a3682f674--0ff3b8e5cb374e4eaa4ead413770ccb9 9073cd2ea04f4a46ba79cf5d6595abbd X 47bdf0cc8bbf43c58f1cde1a3682f674--9073cd2ea04f4a46ba79cf5d6595abbd 9073cd2ea04f4a46ba79cf5d6595abbd--cba5039351ad4f069b18f1dcc8db9a64 9073cd2ea04f4a46ba79cf5d6595abbd--9cbbb3903d754341b629992322f7b732"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'00': 271, '10': 252, '01': 247, '11': 230})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '000': 27, '010': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be indentical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(list(range(n_qubits)), n_qubits, replace=True)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[ 2.5000e-01, -3.3307e-16],\n[-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2540, -0.0092],\n[-0.0006, -0.0004]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9868+0.0000j, 0.0000-0.1621j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8778+0.0000j, 0.0000-0.4791j],\n[0.9593+0.0000j, 0.0000-0.2825j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5086+0.0000j, 0.6844+0.0000j, 0.0000-0.3116j, 0.0000-0.4194j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> cluster_a0fd417cba544b04b902d91320d4c863 [* 2] cluster_77393da18f144dec9c22b0edeecbcff1 Rotations 122788c6e55445ae8dd135ff16eda32b 0 d80c7404d9a44357952725c735a07a38 RX(phi/theta) 122788c6e55445ae8dd135ff16eda32b--d80c7404d9a44357952725c735a07a38 b3a525258c714c908c27473320ba6d07 1 3bc45c5fd0594b6d8587236c6071ba5b RX(phi) d80c7404d9a44357952725c735a07a38--3bc45c5fd0594b6d8587236c6071ba5b 06256ce6171a4c88a7fff2125fb7ba0b RX(phi) 3bc45c5fd0594b6d8587236c6071ba5b--06256ce6171a4c88a7fff2125fb7ba0b f09eed1f089b4c17b46ae173aa283a52 RX(phi + theta) 06256ce6171a4c88a7fff2125fb7ba0b--f09eed1f089b4c17b46ae173aa283a52 bfa094838e844d929b7fc17944b52529 f09eed1f089b4c17b46ae173aa283a52--bfa094838e844d929b7fc17944b52529 af07b0c681ab4f3c928e7e128233098e bfa094838e844d929b7fc17944b52529--af07b0c681ab4f3c928e7e128233098e 7ca79da0944a46cd8792d8116e4dd9b3 Z af07b0c681ab4f3c928e7e128233098e--7ca79da0944a46cd8792d8116e4dd9b3 b6ed6ecfbf9a44ca85933f290a9b581c 7ca79da0944a46cd8792d8116e4dd9b3--b6ed6ecfbf9a44ca85933f290a9b581c b5ec03ca821e443f8afea57303a2accc 0f2a9d24aaa749cbbcd9da452fafb277 RY(2*theta) b3a525258c714c908c27473320ba6d07--0f2a9d24aaa749cbbcd9da452fafb277 79de5c1e599d45818bd8d1d483d9ffe8 2 2cf4dfddc5ad4556ae96c00f8a4e08e4 RY(theta) 0f2a9d24aaa749cbbcd9da452fafb277--2cf4dfddc5ad4556ae96c00f8a4e08e4 3627fa4d7ad64c8196a0ca9000218d8b RY(theta) 2cf4dfddc5ad4556ae96c00f8a4e08e4--3627fa4d7ad64c8196a0ca9000218d8b 7006e0874ce94b9388ebc8fbba34e018 RY(theta**2) 3627fa4d7ad64c8196a0ca9000218d8b--7006e0874ce94b9388ebc8fbba34e018 01fa4d4637fb4de9981566ee8ca2f704 X 7006e0874ce94b9388ebc8fbba34e018--01fa4d4637fb4de9981566ee8ca2f704 01fa4d4637fb4de9981566ee8ca2f704--bfa094838e844d929b7fc17944b52529 e6c65b894dbe4393b3dd39a17e2db513 01fa4d4637fb4de9981566ee8ca2f704--e6c65b894dbe4393b3dd39a17e2db513 3d1ff771ff034564bab376e7e3ad8f64 Z e6c65b894dbe4393b3dd39a17e2db513--3d1ff771ff034564bab376e7e3ad8f64 3d1ff771ff034564bab376e7e3ad8f64--b5ec03ca821e443f8afea57303a2accc 1b9e3d0c07bf44f4a6446099b08befc5 e8210ba3b34a430e95814baf4de91229 RZ(cos(phi)) 79de5c1e599d45818bd8d1d483d9ffe8--e8210ba3b34a430e95814baf4de91229 dd3d97c4da96471eb965ac1511a53db3 RZ(phi) e8210ba3b34a430e95814baf4de91229--dd3d97c4da96471eb965ac1511a53db3 cd52fe6e3dba471ea726b67fba651a00 RZ(phi) dd3d97c4da96471eb965ac1511a53db3--cd52fe6e3dba471ea726b67fba651a00 f97ecb93616c4ee49996dfd9c5b7f572 RZ(cos(phi)) cd52fe6e3dba471ea726b67fba651a00--f97ecb93616c4ee49996dfd9c5b7f572 5aa7f4217ad44b06954117de2bee1306 f97ecb93616c4ee49996dfd9c5b7f572--5aa7f4217ad44b06954117de2bee1306 33683ab3bb7841beabe1dfe037c0c3c2 X 5aa7f4217ad44b06954117de2bee1306--33683ab3bb7841beabe1dfe037c0c3c2 33683ab3bb7841beabe1dfe037c0c3c2--e6c65b894dbe4393b3dd39a17e2db513 050e6ac578164d7580100cbd000e0253 Z 33683ab3bb7841beabe1dfe037c0c3c2--050e6ac578164d7580100cbd000e0253 050e6ac578164d7580100cbd000e0253--1b9e3d0c07bf44f4a6446099b08befc5 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6171]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.5703+0.0000j, 0.4950+0.0000j, 0.0000-0.4950j, 0.0000-0.4297j],\n[0.8421+0.0000j, 0.3647+0.0000j, 0.0000-0.3647j, 0.0000-0.1579j],\n[0.8410+0.0000j, 0.3656+0.0000j, 0.0000-0.3656j, 0.0000-0.1590j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> 40064fe83c614848ba879b67014ef65d 0 de8cf19455bf40ac968dea7676ebbf61 RX(theta\u2080) 40064fe83c614848ba879b67014ef65d--de8cf19455bf40ac968dea7676ebbf61 ef7383dd20b245b0ae3faff5ce766ae5 1 04f986bad5fd46959f4fdb744141f839 RY(theta\u2084) de8cf19455bf40ac968dea7676ebbf61--04f986bad5fd46959f4fdb744141f839 a38695307f604dc9ad80a0c0e2fd170e RX(theta\u2088) 04f986bad5fd46959f4fdb744141f839--a38695307f604dc9ad80a0c0e2fd170e 2dd7d78d790b48ac8b80cec718becbae a38695307f604dc9ad80a0c0e2fd170e--2dd7d78d790b48ac8b80cec718becbae 2f9c9817f160477cbd80f852a2a2ec4c 2dd7d78d790b48ac8b80cec718becbae--2f9c9817f160477cbd80f852a2a2ec4c ae791bc92e134edfb96bcd9449bdee2f RX(theta\u2081\u2082) 2f9c9817f160477cbd80f852a2a2ec4c--ae791bc92e134edfb96bcd9449bdee2f 40e4baa9eef54f7187035d36f7556d49 RY(theta\u2081\u2086) ae791bc92e134edfb96bcd9449bdee2f--40e4baa9eef54f7187035d36f7556d49 6108757be20c48d89cb96d4046344043 RX(theta\u2082\u2080) 40e4baa9eef54f7187035d36f7556d49--6108757be20c48d89cb96d4046344043 dd4a5c8a287f4d97840675292c68dbcf 6108757be20c48d89cb96d4046344043--dd4a5c8a287f4d97840675292c68dbcf fc5e8f78f78f4b679816a7b49c194fcf dd4a5c8a287f4d97840675292c68dbcf--fc5e8f78f78f4b679816a7b49c194fcf 180a9273d083488d92b5404ad20a0a80 fc5e8f78f78f4b679816a7b49c194fcf--180a9273d083488d92b5404ad20a0a80 37cbc912d33341f4aa61ee2838e7ada6 a322c9cb1b7149029a7d1d2adb039aa3 RX(theta\u2081) ef7383dd20b245b0ae3faff5ce766ae5--a322c9cb1b7149029a7d1d2adb039aa3 5f0db1d6ac294bfba61d35e4668ebedb 2 8588c84eb9894503a2b132a5c0a40e83 RY(theta\u2085) a322c9cb1b7149029a7d1d2adb039aa3--8588c84eb9894503a2b132a5c0a40e83 cc5790d03b134030a723f8de5872a47d RX(theta\u2089) 8588c84eb9894503a2b132a5c0a40e83--cc5790d03b134030a723f8de5872a47d f462c4b84665475490523cc339bdd4d8 X cc5790d03b134030a723f8de5872a47d--f462c4b84665475490523cc339bdd4d8 f462c4b84665475490523cc339bdd4d8--2dd7d78d790b48ac8b80cec718becbae e85afaf65adf4d8e827a207903ae487d f462c4b84665475490523cc339bdd4d8--e85afaf65adf4d8e827a207903ae487d eaf08ebc6a1d4242943bcc5e79962d7f RX(theta\u2081\u2083) e85afaf65adf4d8e827a207903ae487d--eaf08ebc6a1d4242943bcc5e79962d7f e0ee544ca668470e92503d027599c510 RY(theta\u2081\u2087) eaf08ebc6a1d4242943bcc5e79962d7f--e0ee544ca668470e92503d027599c510 4900efdc64324dfcbdd2adc4c8510863 RX(theta\u2082\u2081) e0ee544ca668470e92503d027599c510--4900efdc64324dfcbdd2adc4c8510863 335774dd13624a998027b90297220be6 X 4900efdc64324dfcbdd2adc4c8510863--335774dd13624a998027b90297220be6 335774dd13624a998027b90297220be6--dd4a5c8a287f4d97840675292c68dbcf 5ba4e5de261849e9aec2f3cbdb74b7dc 335774dd13624a998027b90297220be6--5ba4e5de261849e9aec2f3cbdb74b7dc 5ba4e5de261849e9aec2f3cbdb74b7dc--37cbc912d33341f4aa61ee2838e7ada6 c330d4b706fd48a3ac0fb70f3de9309b 5800eaf8cca94079b097e06ab4d08710 RX(theta\u2082) 5f0db1d6ac294bfba61d35e4668ebedb--5800eaf8cca94079b097e06ab4d08710 dd39536b4dfa4c14a8f916a585e87347 3 e16ebd402e1a4e1daa382e35fb4bf490 RY(theta\u2086) 5800eaf8cca94079b097e06ab4d08710--e16ebd402e1a4e1daa382e35fb4bf490 7f0fec33dbc74a3e90214525450a1a13 RX(theta\u2081\u2080) e16ebd402e1a4e1daa382e35fb4bf490--7f0fec33dbc74a3e90214525450a1a13 2383f370bd4c460e805a0f15d3e40ddf 7f0fec33dbc74a3e90214525450a1a13--2383f370bd4c460e805a0f15d3e40ddf 2ca3da113e754b999e6a5757152fc0e1 X 2383f370bd4c460e805a0f15d3e40ddf--2ca3da113e754b999e6a5757152fc0e1 2ca3da113e754b999e6a5757152fc0e1--e85afaf65adf4d8e827a207903ae487d 8e9a3a772d01439980eca4a3e3d50c9e RX(theta\u2081\u2084) 2ca3da113e754b999e6a5757152fc0e1--8e9a3a772d01439980eca4a3e3d50c9e f0f01d107b3243e18511339f00d52f77 RY(theta\u2081\u2088) 8e9a3a772d01439980eca4a3e3d50c9e--f0f01d107b3243e18511339f00d52f77 15e119da84844057b0c585fc4008f44a RX(theta\u2082\u2082) f0f01d107b3243e18511339f00d52f77--15e119da84844057b0c585fc4008f44a 36e622588075437da361c18e4e4049be 15e119da84844057b0c585fc4008f44a--36e622588075437da361c18e4e4049be dbbe301c642f444aa3d7887968c14619 X 36e622588075437da361c18e4e4049be--dbbe301c642f444aa3d7887968c14619 dbbe301c642f444aa3d7887968c14619--5ba4e5de261849e9aec2f3cbdb74b7dc dbbe301c642f444aa3d7887968c14619--c330d4b706fd48a3ac0fb70f3de9309b 36016e5c60c241b8bd88c2c719eefd94 038d58ec013d47208e97c1447760d77a RX(theta\u2083) dd39536b4dfa4c14a8f916a585e87347--038d58ec013d47208e97c1447760d77a f9e98a8b4b0d40258ee1fba2e972ac81 RY(theta\u2087) 038d58ec013d47208e97c1447760d77a--f9e98a8b4b0d40258ee1fba2e972ac81 27ec8aa42ef14a1693fa42f854f8f9d8 RX(theta\u2081\u2081) f9e98a8b4b0d40258ee1fba2e972ac81--27ec8aa42ef14a1693fa42f854f8f9d8 e02e7218674841c0bc94cdda646cbede X 27ec8aa42ef14a1693fa42f854f8f9d8--e02e7218674841c0bc94cdda646cbede e02e7218674841c0bc94cdda646cbede--2383f370bd4c460e805a0f15d3e40ddf 1ca887d7d0b845bfb2b3b6a5c06f96a6 e02e7218674841c0bc94cdda646cbede--1ca887d7d0b845bfb2b3b6a5c06f96a6 1998449c53624ca7b57d01d0e9e677ad RX(theta\u2081\u2085) 1ca887d7d0b845bfb2b3b6a5c06f96a6--1998449c53624ca7b57d01d0e9e677ad 1ea1f4f6f8a24c2cb6f3fcc3723ae1c3 RY(theta\u2081\u2089) 1998449c53624ca7b57d01d0e9e677ad--1ea1f4f6f8a24c2cb6f3fcc3723ae1c3 9d526491d6794267b197ed60d8de97c8 RX(theta\u2082\u2083) 1ea1f4f6f8a24c2cb6f3fcc3723ae1c3--9d526491d6794267b197ed60d8de97c8 87259ebe915f4828ab37ea23749dbcde X 9d526491d6794267b197ed60d8de97c8--87259ebe915f4828ab37ea23749dbcde 87259ebe915f4828ab37ea23749dbcde--36e622588075437da361c18e4e4049be e4baeb05a30d4375b7cd855fc5723c19 87259ebe915f4828ab37ea23749dbcde--e4baeb05a30d4375b7cd855fc5723c19 e4baeb05a30d4375b7cd855fc5723c19--36016e5c60c241b8bd88c2c719eefd94 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> cluster_95153c2b861b46bda5be5cb55f930eef HEA cluster_49fb79a993b04b7484224bd6ead2d48c HEA 3bc17c99ad864cf89e9d787df8689d61 0 5c645eec5ce34e0b8a3ced3985d6f36c RX(theta\u2080) 3bc17c99ad864cf89e9d787df8689d61--5c645eec5ce34e0b8a3ced3985d6f36c e6f91d17d3c541108b36b06a04e541b9 1 564d7ae9514d43df95d70678a6647d5f RY(theta\u2084) 5c645eec5ce34e0b8a3ced3985d6f36c--564d7ae9514d43df95d70678a6647d5f f68e955e0dab4944ba0ecea3ccdddde8 RX(theta\u2088) 564d7ae9514d43df95d70678a6647d5f--f68e955e0dab4944ba0ecea3ccdddde8 fcc03071e28f4326b45c0c1a13744028 f68e955e0dab4944ba0ecea3ccdddde8--fcc03071e28f4326b45c0c1a13744028 bf70afcb82b147dc8d14caad534fe94d fcc03071e28f4326b45c0c1a13744028--bf70afcb82b147dc8d14caad534fe94d 93bbffb183714e388afa39b895728d4a RX(theta\u2081\u2082) bf70afcb82b147dc8d14caad534fe94d--93bbffb183714e388afa39b895728d4a 9f13e10da63648f098380ef7ee7eca36 RY(theta\u2081\u2086) 93bbffb183714e388afa39b895728d4a--9f13e10da63648f098380ef7ee7eca36 82d7254ea7894fad9537bc625215fcc8 RX(theta\u2082\u2080) 9f13e10da63648f098380ef7ee7eca36--82d7254ea7894fad9537bc625215fcc8 b3688aaf0ae145a4b756965894f3c3a3 82d7254ea7894fad9537bc625215fcc8--b3688aaf0ae145a4b756965894f3c3a3 386a1830cbec4a68a9afca3489736988 b3688aaf0ae145a4b756965894f3c3a3--386a1830cbec4a68a9afca3489736988 f1900cc85324406584fd54f8d68fd614 RX(theta\u2080) 386a1830cbec4a68a9afca3489736988--f1900cc85324406584fd54f8d68fd614 ba03607a1b76445bb948aec2e2667429 RY(theta\u2084) f1900cc85324406584fd54f8d68fd614--ba03607a1b76445bb948aec2e2667429 317902a2d4dc40af8972ac0963256317 RX(theta\u2088) ba03607a1b76445bb948aec2e2667429--317902a2d4dc40af8972ac0963256317 2dd7087cb3a1445ba505c419354e527e 317902a2d4dc40af8972ac0963256317--2dd7087cb3a1445ba505c419354e527e 9d2f573aee0643e0a3cd9d6282854121 2dd7087cb3a1445ba505c419354e527e--9d2f573aee0643e0a3cd9d6282854121 d4504706f8b249eca697acae6522fb51 RX(theta\u2081\u2082) 9d2f573aee0643e0a3cd9d6282854121--d4504706f8b249eca697acae6522fb51 e801b320eb9a41bc97549ab51a29059d RY(theta\u2081\u2086) d4504706f8b249eca697acae6522fb51--e801b320eb9a41bc97549ab51a29059d b5ab997aba214bc6a0c4a5b25c2d0112 RX(theta\u2082\u2080) e801b320eb9a41bc97549ab51a29059d--b5ab997aba214bc6a0c4a5b25c2d0112 a03f3873e7f34ae3816a24c7e0d9334c b5ab997aba214bc6a0c4a5b25c2d0112--a03f3873e7f34ae3816a24c7e0d9334c c3ed02400aec4c0cac7220bc94b0ea74 a03f3873e7f34ae3816a24c7e0d9334c--c3ed02400aec4c0cac7220bc94b0ea74 72a09ab10be845dd8c1ce72ae583f4f1 c3ed02400aec4c0cac7220bc94b0ea74--72a09ab10be845dd8c1ce72ae583f4f1 fb59098fe1d24bbfafa6cf86b96e16b2 596390c7c13b4f1aa144d9170f800bf2 RX(theta\u2081) e6f91d17d3c541108b36b06a04e541b9--596390c7c13b4f1aa144d9170f800bf2 9a3299ec0b7b47eebf99c16c36d2185a 2 0ef87d98beef4b9eb7a2bd72333f99ba RY(theta\u2085) 596390c7c13b4f1aa144d9170f800bf2--0ef87d98beef4b9eb7a2bd72333f99ba 63bb7a8c6f384d94a072ed07a2a9059b RX(theta\u2089) 0ef87d98beef4b9eb7a2bd72333f99ba--63bb7a8c6f384d94a072ed07a2a9059b 6fd54082c6364c21927af3ef0716ded2 X 63bb7a8c6f384d94a072ed07a2a9059b--6fd54082c6364c21927af3ef0716ded2 6fd54082c6364c21927af3ef0716ded2--fcc03071e28f4326b45c0c1a13744028 3f50092da8544a9d95562505b27d27a5 6fd54082c6364c21927af3ef0716ded2--3f50092da8544a9d95562505b27d27a5 1cc93ff363914470b2da7dd6bb0ac28f RX(theta\u2081\u2083) 3f50092da8544a9d95562505b27d27a5--1cc93ff363914470b2da7dd6bb0ac28f c9b37f3b123248388b8339bca1bd9b3a RY(theta\u2081\u2087) 1cc93ff363914470b2da7dd6bb0ac28f--c9b37f3b123248388b8339bca1bd9b3a f2279dbd8aa74da4b19b5cab972dce20 RX(theta\u2082\u2081) c9b37f3b123248388b8339bca1bd9b3a--f2279dbd8aa74da4b19b5cab972dce20 d6a1e2fc9dde4c0583dc2a1e6e14e293 X f2279dbd8aa74da4b19b5cab972dce20--d6a1e2fc9dde4c0583dc2a1e6e14e293 d6a1e2fc9dde4c0583dc2a1e6e14e293--b3688aaf0ae145a4b756965894f3c3a3 6d460aacb57e409bbb6141280b28a829 d6a1e2fc9dde4c0583dc2a1e6e14e293--6d460aacb57e409bbb6141280b28a829 b1c7ec608102417b913bdc687a47a899 RX(theta\u2081) 6d460aacb57e409bbb6141280b28a829--b1c7ec608102417b913bdc687a47a899 fccd4d7041e44ad7aa80a5be1966ab4d RY(theta\u2085) b1c7ec608102417b913bdc687a47a899--fccd4d7041e44ad7aa80a5be1966ab4d ac83ef20847549f68b20532af37d7019 RX(theta\u2089) fccd4d7041e44ad7aa80a5be1966ab4d--ac83ef20847549f68b20532af37d7019 a5e4ce8f0648493695c993c7f4c1d332 X ac83ef20847549f68b20532af37d7019--a5e4ce8f0648493695c993c7f4c1d332 a5e4ce8f0648493695c993c7f4c1d332--2dd7087cb3a1445ba505c419354e527e f6cdab083b2b4748b7311e7ab680789c a5e4ce8f0648493695c993c7f4c1d332--f6cdab083b2b4748b7311e7ab680789c d99d40ccf1f5430aad7fdda5183cfae0 RX(theta\u2081\u2083) f6cdab083b2b4748b7311e7ab680789c--d99d40ccf1f5430aad7fdda5183cfae0 991b3e5ae0524f60adcab2d251b2b36c RY(theta\u2081\u2087) d99d40ccf1f5430aad7fdda5183cfae0--991b3e5ae0524f60adcab2d251b2b36c 30f97845a1d24c9b84f42e38fb8d1097 RX(theta\u2082\u2081) 991b3e5ae0524f60adcab2d251b2b36c--30f97845a1d24c9b84f42e38fb8d1097 5a7cdd8695b14397be480669a2364e6b X 30f97845a1d24c9b84f42e38fb8d1097--5a7cdd8695b14397be480669a2364e6b 5a7cdd8695b14397be480669a2364e6b--a03f3873e7f34ae3816a24c7e0d9334c 40311c199a0b4f1da834fe418759a589 5a7cdd8695b14397be480669a2364e6b--40311c199a0b4f1da834fe418759a589 40311c199a0b4f1da834fe418759a589--fb59098fe1d24bbfafa6cf86b96e16b2 9b31ed0d61f34b0e9b15f3aed3d4d085 f3f7563593ba412db77a1749f6111672 RX(theta\u2082) 9a3299ec0b7b47eebf99c16c36d2185a--f3f7563593ba412db77a1749f6111672 8ed889e811094e59a2d06844c8337514 3 d9acafbda4d94c3c89c817e011702e1a RY(theta\u2086) f3f7563593ba412db77a1749f6111672--d9acafbda4d94c3c89c817e011702e1a 7b5b9c2517d94072994bb95b81bf8a3d RX(theta\u2081\u2080) d9acafbda4d94c3c89c817e011702e1a--7b5b9c2517d94072994bb95b81bf8a3d 1c25bfc4b27b4c4ea6dd16df1d6146b8 7b5b9c2517d94072994bb95b81bf8a3d--1c25bfc4b27b4c4ea6dd16df1d6146b8 87f4f42c481246e2a00726878f2796d7 X 1c25bfc4b27b4c4ea6dd16df1d6146b8--87f4f42c481246e2a00726878f2796d7 87f4f42c481246e2a00726878f2796d7--3f50092da8544a9d95562505b27d27a5 3e1ab9773ddf4290bc50fed2f810a838 RX(theta\u2081\u2084) 87f4f42c481246e2a00726878f2796d7--3e1ab9773ddf4290bc50fed2f810a838 8cbcf0e0ba22447289df142726fef018 RY(theta\u2081\u2088) 3e1ab9773ddf4290bc50fed2f810a838--8cbcf0e0ba22447289df142726fef018 204838d99276461ba6816989cc1782dd RX(theta\u2082\u2082) 8cbcf0e0ba22447289df142726fef018--204838d99276461ba6816989cc1782dd 2e65187255c34a9892ef3b86994eca7b 204838d99276461ba6816989cc1782dd--2e65187255c34a9892ef3b86994eca7b 2d9d19c8365948c89e0ce15870eba5a2 X 2e65187255c34a9892ef3b86994eca7b--2d9d19c8365948c89e0ce15870eba5a2 2d9d19c8365948c89e0ce15870eba5a2--6d460aacb57e409bbb6141280b28a829 ae1bb22ff61c4227b2b5b4d994617cce RX(theta\u2082) 2d9d19c8365948c89e0ce15870eba5a2--ae1bb22ff61c4227b2b5b4d994617cce 86463c75c622457eb6e2043529530b7c RY(theta\u2086) ae1bb22ff61c4227b2b5b4d994617cce--86463c75c622457eb6e2043529530b7c 2e2d3a3e6aae40348553b9a9e9a93e45 RX(theta\u2081\u2080) 86463c75c622457eb6e2043529530b7c--2e2d3a3e6aae40348553b9a9e9a93e45 ce6e68b270094d9abded47b5dfbbd723 2e2d3a3e6aae40348553b9a9e9a93e45--ce6e68b270094d9abded47b5dfbbd723 b1e20e998c904d0893ad256291bc6ea0 X ce6e68b270094d9abded47b5dfbbd723--b1e20e998c904d0893ad256291bc6ea0 b1e20e998c904d0893ad256291bc6ea0--f6cdab083b2b4748b7311e7ab680789c 97859ecce0ab47caa9c3a34f19de3154 RX(theta\u2081\u2084) b1e20e998c904d0893ad256291bc6ea0--97859ecce0ab47caa9c3a34f19de3154 9651057832774f3f8f688fc099f63fde RY(theta\u2081\u2088) 97859ecce0ab47caa9c3a34f19de3154--9651057832774f3f8f688fc099f63fde 66ab41a69a294bf8b2b7a1959c0eecd5 RX(theta\u2082\u2082) 9651057832774f3f8f688fc099f63fde--66ab41a69a294bf8b2b7a1959c0eecd5 b5d47d1ebf124e6d805300d51f65199a 66ab41a69a294bf8b2b7a1959c0eecd5--b5d47d1ebf124e6d805300d51f65199a 0f537a0751bc4f14b58e0c383670ac49 X b5d47d1ebf124e6d805300d51f65199a--0f537a0751bc4f14b58e0c383670ac49 0f537a0751bc4f14b58e0c383670ac49--40311c199a0b4f1da834fe418759a589 0f537a0751bc4f14b58e0c383670ac49--9b31ed0d61f34b0e9b15f3aed3d4d085 1064786be802491891b68a851a14bd56 c9008882d717406a9b29e899ab621627 RX(theta\u2083) 8ed889e811094e59a2d06844c8337514--c9008882d717406a9b29e899ab621627 9ab2773eba2945488e6a35404bd692e0 RY(theta\u2087) c9008882d717406a9b29e899ab621627--9ab2773eba2945488e6a35404bd692e0 d1be630f37714eec8ed4db123ae1b862 RX(theta\u2081\u2081) 9ab2773eba2945488e6a35404bd692e0--d1be630f37714eec8ed4db123ae1b862 75f7857c9a054429b7595ea19869ad0f X d1be630f37714eec8ed4db123ae1b862--75f7857c9a054429b7595ea19869ad0f 75f7857c9a054429b7595ea19869ad0f--1c25bfc4b27b4c4ea6dd16df1d6146b8 6b6ec2a0ac6e4cf4a7765df2780853e7 75f7857c9a054429b7595ea19869ad0f--6b6ec2a0ac6e4cf4a7765df2780853e7 2e41d5ed20a24e95ae16c41dafc4f01c RX(theta\u2081\u2085) 6b6ec2a0ac6e4cf4a7765df2780853e7--2e41d5ed20a24e95ae16c41dafc4f01c 2e2d042ff9784ceba87766e25c298d31 RY(theta\u2081\u2089) 2e41d5ed20a24e95ae16c41dafc4f01c--2e2d042ff9784ceba87766e25c298d31 81f8f34353cc4428a419aed7a06f91ea RX(theta\u2082\u2083) 2e2d042ff9784ceba87766e25c298d31--81f8f34353cc4428a419aed7a06f91ea 57e9a0269acd4f3ca091a15a416eb769 X 81f8f34353cc4428a419aed7a06f91ea--57e9a0269acd4f3ca091a15a416eb769 57e9a0269acd4f3ca091a15a416eb769--2e65187255c34a9892ef3b86994eca7b 23465dc3c9af4a6bbafbcb0afcc8f8f4 57e9a0269acd4f3ca091a15a416eb769--23465dc3c9af4a6bbafbcb0afcc8f8f4 d65ac21e13b34506af791f17f103d58f RX(theta\u2083) 23465dc3c9af4a6bbafbcb0afcc8f8f4--d65ac21e13b34506af791f17f103d58f 7adf2a76f6ee49f89bfc38e04fc518f1 RY(theta\u2087) d65ac21e13b34506af791f17f103d58f--7adf2a76f6ee49f89bfc38e04fc518f1 264d1e7500914710ad959ba664f8f011 RX(theta\u2081\u2081) 7adf2a76f6ee49f89bfc38e04fc518f1--264d1e7500914710ad959ba664f8f011 e660de90f0334cfab8346d35e0913b31 X 264d1e7500914710ad959ba664f8f011--e660de90f0334cfab8346d35e0913b31 e660de90f0334cfab8346d35e0913b31--ce6e68b270094d9abded47b5dfbbd723 00eaa7b2d7da4129b10570cd5220dff9 e660de90f0334cfab8346d35e0913b31--00eaa7b2d7da4129b10570cd5220dff9 6910a0660dc846939d501a80347eb498 RX(theta\u2081\u2085) 00eaa7b2d7da4129b10570cd5220dff9--6910a0660dc846939d501a80347eb498 7f6a8f218750482195da8c3cbf7e5a4e RY(theta\u2081\u2089) 6910a0660dc846939d501a80347eb498--7f6a8f218750482195da8c3cbf7e5a4e 3a4676269b52459db0b64500e8e53442 RX(theta\u2082\u2083) 7f6a8f218750482195da8c3cbf7e5a4e--3a4676269b52459db0b64500e8e53442 db98c4087c4b465ba32c3f1228be35ea X 3a4676269b52459db0b64500e8e53442--db98c4087c4b465ba32c3f1228be35ea db98c4087c4b465ba32c3f1228be35ea--b5d47d1ebf124e6d805300d51f65199a dec0fd548840490e9d399f39f14f1495 db98c4087c4b465ba32c3f1228be35ea--dec0fd548840490e9d399f39f14f1495 dec0fd548840490e9d399f39f14f1495--1064786be802491891b68a851a14bd56 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> cluster_b31f9a59ad434d55bac7dc5a968e1f50 HEA cluster_21f8553b18524861b83e7094526ff38e HEA 7432f23cc8b14b3d82e91ed1e100a584 0 aab85de29a6d4d80b1c32299d06366c6 RX(p1\u2080) 7432f23cc8b14b3d82e91ed1e100a584--aab85de29a6d4d80b1c32299d06366c6 ec21582d30484cd39cacd91af72b43fb 1 697a14e1c3854aaf9e62629d3b42d1b2 RY(p1\u2084) aab85de29a6d4d80b1c32299d06366c6--697a14e1c3854aaf9e62629d3b42d1b2 837c76e9c62e4ee7a8a36441d7b89f8d RX(p1\u2088) 697a14e1c3854aaf9e62629d3b42d1b2--837c76e9c62e4ee7a8a36441d7b89f8d f09aefc5452c4ec19eec503c58ba4aff 837c76e9c62e4ee7a8a36441d7b89f8d--f09aefc5452c4ec19eec503c58ba4aff 0b01f29aa5a2433c9ed8cebe6df6505d f09aefc5452c4ec19eec503c58ba4aff--0b01f29aa5a2433c9ed8cebe6df6505d d831465cbafa4eb0aca5093ab0ebff50 RX(p1\u2081\u2082) 0b01f29aa5a2433c9ed8cebe6df6505d--d831465cbafa4eb0aca5093ab0ebff50 b8d6bd9a25a0438986fdd3afb4d9de5d RY(p1\u2081\u2086) d831465cbafa4eb0aca5093ab0ebff50--b8d6bd9a25a0438986fdd3afb4d9de5d 0d1d81fe2486434ca97e633ae42962c0 RX(p1\u2082\u2080) b8d6bd9a25a0438986fdd3afb4d9de5d--0d1d81fe2486434ca97e633ae42962c0 97f76af6281244eabd618b39935c4d67 0d1d81fe2486434ca97e633ae42962c0--97f76af6281244eabd618b39935c4d67 03c078d6b07f4bff8670e8a797ecd981 97f76af6281244eabd618b39935c4d67--03c078d6b07f4bff8670e8a797ecd981 bcdc82b5393549c7bd0c1fd341976cf1 RX(p2\u2080) 03c078d6b07f4bff8670e8a797ecd981--bcdc82b5393549c7bd0c1fd341976cf1 1c229291387641c297ca883f4fe24086 RY(p2\u2084) bcdc82b5393549c7bd0c1fd341976cf1--1c229291387641c297ca883f4fe24086 e6775f59f8b44c87ad47bae43417563a RX(p2\u2088) 1c229291387641c297ca883f4fe24086--e6775f59f8b44c87ad47bae43417563a 9ce8cd3335c24b24a3cfe873ab195f8e e6775f59f8b44c87ad47bae43417563a--9ce8cd3335c24b24a3cfe873ab195f8e f62ea63a604e49fa8aba1f23266707ab 9ce8cd3335c24b24a3cfe873ab195f8e--f62ea63a604e49fa8aba1f23266707ab 9e7ae1fd64784590955e4e435e266fdc RX(p2\u2081\u2082) f62ea63a604e49fa8aba1f23266707ab--9e7ae1fd64784590955e4e435e266fdc 93c1d3461c2b4693aeaa85862fb29523 RY(p2\u2081\u2086) 9e7ae1fd64784590955e4e435e266fdc--93c1d3461c2b4693aeaa85862fb29523 87a6125ae692409084059025e82ee6f4 RX(p2\u2082\u2080) 93c1d3461c2b4693aeaa85862fb29523--87a6125ae692409084059025e82ee6f4 e35308919ce14ce6bdb6743e31915355 87a6125ae692409084059025e82ee6f4--e35308919ce14ce6bdb6743e31915355 d9640938ff9d4b8b825c5cc05fb4f920 e35308919ce14ce6bdb6743e31915355--d9640938ff9d4b8b825c5cc05fb4f920 3a193ccd047d49f6b68cc8e7e8d15e75 d9640938ff9d4b8b825c5cc05fb4f920--3a193ccd047d49f6b68cc8e7e8d15e75 925d551066304ca8be178268b1a20b1b b6c4a0336eac430ab6150d786ed22415 RX(p1\u2081) ec21582d30484cd39cacd91af72b43fb--b6c4a0336eac430ab6150d786ed22415 2b134d50948e49fa8e64cf077bec859a 2 5c8c42364a344ced879e588d3f677c26 RY(p1\u2085) b6c4a0336eac430ab6150d786ed22415--5c8c42364a344ced879e588d3f677c26 7942bf64725a46e09ef6bb2d4829114f RX(p1\u2089) 5c8c42364a344ced879e588d3f677c26--7942bf64725a46e09ef6bb2d4829114f 2c2863af1a7a416896e4a6ed47c79eb1 X 7942bf64725a46e09ef6bb2d4829114f--2c2863af1a7a416896e4a6ed47c79eb1 2c2863af1a7a416896e4a6ed47c79eb1--f09aefc5452c4ec19eec503c58ba4aff b8343ea6237e4f268f2eebb01af7dbe4 2c2863af1a7a416896e4a6ed47c79eb1--b8343ea6237e4f268f2eebb01af7dbe4 5bcaa0f604f845dda27d83a9f0a5198b RX(p1\u2081\u2083) b8343ea6237e4f268f2eebb01af7dbe4--5bcaa0f604f845dda27d83a9f0a5198b 980a68c7726b47958ff937e59269c5c1 RY(p1\u2081\u2087) 5bcaa0f604f845dda27d83a9f0a5198b--980a68c7726b47958ff937e59269c5c1 4ddde7fb11494023a56da6eedcb413e9 RX(p1\u2082\u2081) 980a68c7726b47958ff937e59269c5c1--4ddde7fb11494023a56da6eedcb413e9 72a585aeddb2471b80f01b11f44ab1d9 X 4ddde7fb11494023a56da6eedcb413e9--72a585aeddb2471b80f01b11f44ab1d9 72a585aeddb2471b80f01b11f44ab1d9--97f76af6281244eabd618b39935c4d67 57e446dcf3ac4b709f0fe72e699fe38b 72a585aeddb2471b80f01b11f44ab1d9--57e446dcf3ac4b709f0fe72e699fe38b 935d4a5e315643c386c3259e0a1e1eef RX(p2\u2081) 57e446dcf3ac4b709f0fe72e699fe38b--935d4a5e315643c386c3259e0a1e1eef b018a283964c40c2bc9e24f35740f79d RY(p2\u2085) 935d4a5e315643c386c3259e0a1e1eef--b018a283964c40c2bc9e24f35740f79d e36cd17f83c64a6a89589ba4aaf9eecc RX(p2\u2089) b018a283964c40c2bc9e24f35740f79d--e36cd17f83c64a6a89589ba4aaf9eecc bfbc2373801642adada240bc95f43c2e X e36cd17f83c64a6a89589ba4aaf9eecc--bfbc2373801642adada240bc95f43c2e bfbc2373801642adada240bc95f43c2e--9ce8cd3335c24b24a3cfe873ab195f8e 17bec047795b4cf2905f189718648992 bfbc2373801642adada240bc95f43c2e--17bec047795b4cf2905f189718648992 24cc5831405b47e190ed194eaf16537a RX(p2\u2081\u2083) 17bec047795b4cf2905f189718648992--24cc5831405b47e190ed194eaf16537a 031b0dba59184cf994751a4680655648 RY(p2\u2081\u2087) 24cc5831405b47e190ed194eaf16537a--031b0dba59184cf994751a4680655648 0918ab9e6fb84a50ba3ef7412384ed5b RX(p2\u2082\u2081) 031b0dba59184cf994751a4680655648--0918ab9e6fb84a50ba3ef7412384ed5b 61278b5f09564f86a28237eaa71ee335 X 0918ab9e6fb84a50ba3ef7412384ed5b--61278b5f09564f86a28237eaa71ee335 61278b5f09564f86a28237eaa71ee335--e35308919ce14ce6bdb6743e31915355 69aa1f0ac86d4710a2f91f661f01dd4d 61278b5f09564f86a28237eaa71ee335--69aa1f0ac86d4710a2f91f661f01dd4d 69aa1f0ac86d4710a2f91f661f01dd4d--925d551066304ca8be178268b1a20b1b 4f73e79e917c44cd8ff0150b63f2e2e9 7c5aaa214a7f4de198d00350501f01cb RX(p1\u2082) 2b134d50948e49fa8e64cf077bec859a--7c5aaa214a7f4de198d00350501f01cb e8aeb321f394414da1242e8d1b4c8da4 3 6c07a188eb704cc99f3dd85e6b479447 RY(p1\u2086) 7c5aaa214a7f4de198d00350501f01cb--6c07a188eb704cc99f3dd85e6b479447 27e98d9f9bed4a4ca5727d8e735ea34b RX(p1\u2081\u2080) 6c07a188eb704cc99f3dd85e6b479447--27e98d9f9bed4a4ca5727d8e735ea34b 608671f067004c2396efc6f86a045a9f 27e98d9f9bed4a4ca5727d8e735ea34b--608671f067004c2396efc6f86a045a9f 3b3a25cd6c9f4744b92d814213d5d5f8 X 608671f067004c2396efc6f86a045a9f--3b3a25cd6c9f4744b92d814213d5d5f8 3b3a25cd6c9f4744b92d814213d5d5f8--b8343ea6237e4f268f2eebb01af7dbe4 bd2a5cd54d5e48a1967d6094f5a30daa RX(p1\u2081\u2084) 3b3a25cd6c9f4744b92d814213d5d5f8--bd2a5cd54d5e48a1967d6094f5a30daa ec2e6cba937447c8a887f309e35ff4ab RY(p1\u2081\u2088) bd2a5cd54d5e48a1967d6094f5a30daa--ec2e6cba937447c8a887f309e35ff4ab 1139f72872814986ae0790355de9564c RX(p1\u2082\u2082) ec2e6cba937447c8a887f309e35ff4ab--1139f72872814986ae0790355de9564c e1f990a703884ddebf563b9e36bb2d5c 1139f72872814986ae0790355de9564c--e1f990a703884ddebf563b9e36bb2d5c 69a1725dbe054855a2a339fe74b27102 X e1f990a703884ddebf563b9e36bb2d5c--69a1725dbe054855a2a339fe74b27102 69a1725dbe054855a2a339fe74b27102--57e446dcf3ac4b709f0fe72e699fe38b 96ebe9a2a0554e339c76232d15b4af7e RX(p2\u2082) 69a1725dbe054855a2a339fe74b27102--96ebe9a2a0554e339c76232d15b4af7e 8cd96a4868954cd6b0de8e2b065ea651 RY(p2\u2086) 96ebe9a2a0554e339c76232d15b4af7e--8cd96a4868954cd6b0de8e2b065ea651 fa9484571c08472cb200cd4ec3103644 RX(p2\u2081\u2080) 8cd96a4868954cd6b0de8e2b065ea651--fa9484571c08472cb200cd4ec3103644 12f829010a9048dc839012f99a09e3af fa9484571c08472cb200cd4ec3103644--12f829010a9048dc839012f99a09e3af 1435cebe2c4c444cb20be840c33168ea X 12f829010a9048dc839012f99a09e3af--1435cebe2c4c444cb20be840c33168ea 1435cebe2c4c444cb20be840c33168ea--17bec047795b4cf2905f189718648992 33e390b0e49844a7808c4ddb9be377c5 RX(p2\u2081\u2084) 1435cebe2c4c444cb20be840c33168ea--33e390b0e49844a7808c4ddb9be377c5 44487d2bf3654470ae73113fae57e39b RY(p2\u2081\u2088) 33e390b0e49844a7808c4ddb9be377c5--44487d2bf3654470ae73113fae57e39b 2d96c3a8905340659c8d0b0160647264 RX(p2\u2082\u2082) 44487d2bf3654470ae73113fae57e39b--2d96c3a8905340659c8d0b0160647264 3fe56973a6cf41f1807595c9053184d9 2d96c3a8905340659c8d0b0160647264--3fe56973a6cf41f1807595c9053184d9 2345c2c1ae6d46c6ab5a5b05694b705b X 3fe56973a6cf41f1807595c9053184d9--2345c2c1ae6d46c6ab5a5b05694b705b 2345c2c1ae6d46c6ab5a5b05694b705b--69aa1f0ac86d4710a2f91f661f01dd4d 2345c2c1ae6d46c6ab5a5b05694b705b--4f73e79e917c44cd8ff0150b63f2e2e9 61e062c5cd5f4b18ae21566c021884f4 faf7bf392fe247048f38b750a0d8413d RX(p1\u2083) e8aeb321f394414da1242e8d1b4c8da4--faf7bf392fe247048f38b750a0d8413d a8fea432e6a84988a117de027d0a451a RY(p1\u2087) faf7bf392fe247048f38b750a0d8413d--a8fea432e6a84988a117de027d0a451a c75fbb7e58b64625aecb7d27ad6e04eb RX(p1\u2081\u2081) a8fea432e6a84988a117de027d0a451a--c75fbb7e58b64625aecb7d27ad6e04eb cf895d2008ff42dbb42fcda96fe7fc3c X c75fbb7e58b64625aecb7d27ad6e04eb--cf895d2008ff42dbb42fcda96fe7fc3c cf895d2008ff42dbb42fcda96fe7fc3c--608671f067004c2396efc6f86a045a9f fbff1b06974142b484457281a14b6b2a cf895d2008ff42dbb42fcda96fe7fc3c--fbff1b06974142b484457281a14b6b2a eb0493ffdaea46ae9712aa6f98b46ffb RX(p1\u2081\u2085) fbff1b06974142b484457281a14b6b2a--eb0493ffdaea46ae9712aa6f98b46ffb b93184331ebd42e6a6720df7e2d98595 RY(p1\u2081\u2089) eb0493ffdaea46ae9712aa6f98b46ffb--b93184331ebd42e6a6720df7e2d98595 5ecad5a2a80b49b5bd409ec5ae502d22 RX(p1\u2082\u2083) b93184331ebd42e6a6720df7e2d98595--5ecad5a2a80b49b5bd409ec5ae502d22 8672618615a749ebaa8961d7b16a06f5 X 5ecad5a2a80b49b5bd409ec5ae502d22--8672618615a749ebaa8961d7b16a06f5 8672618615a749ebaa8961d7b16a06f5--e1f990a703884ddebf563b9e36bb2d5c 69704e23e4a04fad96771b07c714ff03 8672618615a749ebaa8961d7b16a06f5--69704e23e4a04fad96771b07c714ff03 24a5aa4cc6ae4192b281ccf1e1e3a701 RX(p2\u2083) 69704e23e4a04fad96771b07c714ff03--24a5aa4cc6ae4192b281ccf1e1e3a701 9db7bcaa42ea48d29c70350ae8567806 RY(p2\u2087) 24a5aa4cc6ae4192b281ccf1e1e3a701--9db7bcaa42ea48d29c70350ae8567806 4ba2a781cf7749c3ae26626ba77bf313 RX(p2\u2081\u2081) 9db7bcaa42ea48d29c70350ae8567806--4ba2a781cf7749c3ae26626ba77bf313 51a402fada64427f8a66c7c31b7fa91a X 4ba2a781cf7749c3ae26626ba77bf313--51a402fada64427f8a66c7c31b7fa91a 51a402fada64427f8a66c7c31b7fa91a--12f829010a9048dc839012f99a09e3af 8a626c40021c4755997fcfc9716368b7 51a402fada64427f8a66c7c31b7fa91a--8a626c40021c4755997fcfc9716368b7 e6877d65efa145beb98166362f4b01c8 RX(p2\u2081\u2085) 8a626c40021c4755997fcfc9716368b7--e6877d65efa145beb98166362f4b01c8 f30ee2f0fea44227a5326855127818df RY(p2\u2081\u2089) e6877d65efa145beb98166362f4b01c8--f30ee2f0fea44227a5326855127818df d15a4f393f8f4c28b49951eaf789a0d1 RX(p2\u2082\u2083) f30ee2f0fea44227a5326855127818df--d15a4f393f8f4c28b49951eaf789a0d1 fec250c2575147d3aa53b2d852dee462 X d15a4f393f8f4c28b49951eaf789a0d1--fec250c2575147d3aa53b2d852dee462 fec250c2575147d3aa53b2d852dee462--3fe56973a6cf41f1807595c9053184d9 868eeb59133d4cfca0e7389049fbf1e8 fec250c2575147d3aa53b2d852dee462--868eeb59133d4cfca0e7389049fbf1e8 868eeb59133d4cfca0e7389049fbf1e8--61e062c5cd5f4b18ae21566c021884f4 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9406])), ('theta_0', tensor([0.7951])), ('theta_1', tensor([0.3345])), ('theta_10', tensor([0.8927])), ('theta_11', tensor([0.3210])), ('theta_12', tensor([0.3358])), ('theta_13', tensor([0.6445])), ('theta_14', tensor([0.1183])), ('theta_15', tensor([0.8274])), ('theta_16', tensor([0.6881])), ('theta_17', tensor([0.5928])), ('theta_18', tensor([0.2551])), ('theta_19', tensor([0.3500])), ('theta_2', tensor([0.3125])), ('theta_20', tensor([0.5327])), ('theta_21', tensor([0.0981])), ('theta_22', tensor([0.1385])), ('theta_23', tensor([0.6408])), ('theta_3', tensor([0.4979])), ('theta_4', tensor([0.4264])), ('theta_5', tensor([0.5154])), ('theta_6', tensor([0.6589])), ('theta_7', tensor([0.1994])), ('theta_8', tensor([0.9758])), ('theta_9', tensor([0.9689]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9396])), ('theta_0', tensor([0.7941])), ('theta_1', tensor([0.3335])), ('theta_10', tensor([0.8937])), ('theta_11', tensor([0.3200])), ('theta_12', tensor([0.3348])), ('theta_13', tensor([0.6435])), ('theta_14', tensor([0.1193])), ('theta_15', tensor([0.8264])), ('theta_16', tensor([0.6891])), ('theta_17', tensor([0.5918])), ('theta_18', tensor([0.2561])), ('theta_19', tensor([0.3510])), ('theta_2', tensor([0.3135])), ('theta_20', tensor([0.5317])), ('theta_21', tensor([0.0971])), ('theta_22', tensor([0.1395])), ('theta_23', tensor([0.6398])), ('theta_3', tensor([0.4969])), ('theta_4', tensor([0.4254])), ('theta_5', tensor([0.5144])), ('theta_6', tensor([0.6579])), ('theta_7', tensor([0.2004])), ('theta_8', tensor([0.9748])), ('theta_9', tensor([0.9679]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows to compose with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution with non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): ParametricPyQOperation(\n(operation): RX(qubits=(0,), n_qubits=2)\n)\n(1): ParametricPyQOperation(\n(operation): RX(qubits=(1,), n_qubits=2)\n)\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9940+0.0000j,  0.0000-0.0774j,  0.0000-0.0774j, -0.0060+0.0000j],\n[ 0.8271+0.0000j,  0.0000-0.3781j,  0.0000-0.3781j, -0.1729+0.0000j],\n[ 0.9494+0.0000j,  0.0000-0.2191j,  0.0000-0.2191j, -0.0506+0.0000j]])\nxs = [Counter({'00': 98, '01': 1, '10': 1}), Counter({'00': 67, '01': 18, '10': 13, '11': 2}), Counter({'00': 86, '01': 7, '10': 6, '11': 1})]\nex = tensor([[0.9879],\n[0.6543],\n[0.8988]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9879, 0.9879],\n[0.6543, 0.6543],\n[0.8988, 0.8988]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the machine learning tools section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-10-16T14:58:14.346418 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-10-16T14:58:14.496314 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-10-16T14:58:14.535823 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>Qubits coordinates in Qadence are dimensionless but converted to the required unit when executed on a backend. For instance, Pulser uses \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often asssumed in simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interaction must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 58, '00': 42})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 58, '00': 42})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care for automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 87, '01': 13})]\nOn Braket = [Counter({'00': 80, '01': 20})]\nOn Pulser = [Counter({'00': 87, '01': 13})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9223+0.0000j, 0.0000-0.3865j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [ 0.56230754+0.j -0.06783009+0.j  0.81821011+0.j -0.09869913+0.j]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> cluster_e879252ef2c8498eaeddcec621b7ed57 Circuit block cluster_f27612b5626d473f8d8a34d3cb0d5589 Prep block 0f6ca2a940a647809008a9dc3fcdcfa1 0 fce42e0c13074984832123bf65f5f4eb 0f6ca2a940a647809008a9dc3fcdcfa1--fce42e0c13074984832123bf65f5f4eb 1724ebecbc7742629d08bd15bc93de46 1 5d980613b9094b8fba978a54adcbf425 RX(theta\u2080) fce42e0c13074984832123bf65f5f4eb--5d980613b9094b8fba978a54adcbf425 b35ad5f435ef439eb8135caa8edc10a3 RY(theta\u2084) 5d980613b9094b8fba978a54adcbf425--b35ad5f435ef439eb8135caa8edc10a3 38c08e53cb2c4cc3bc9ab883baf098dc RX(theta\u2088) b35ad5f435ef439eb8135caa8edc10a3--38c08e53cb2c4cc3bc9ab883baf098dc 19a2964ca754456eb625a0edf622a7c8 38c08e53cb2c4cc3bc9ab883baf098dc--19a2964ca754456eb625a0edf622a7c8 acd958717ffb44d89e31f4cce68f1cc1 19a2964ca754456eb625a0edf622a7c8--acd958717ffb44d89e31f4cce68f1cc1 b4052cff16b54e0b8a3332902203abb9 RX(theta\u2081\u2082) acd958717ffb44d89e31f4cce68f1cc1--b4052cff16b54e0b8a3332902203abb9 f4f9f4a8d68f474cb4fe0288a3b5be0c RY(theta\u2081\u2086) b4052cff16b54e0b8a3332902203abb9--f4f9f4a8d68f474cb4fe0288a3b5be0c f2827e67a5564b39ad83a567619e6c64 RX(theta\u2082\u2080) f4f9f4a8d68f474cb4fe0288a3b5be0c--f2827e67a5564b39ad83a567619e6c64 586ae13cce8947b0904f210c34c0e9a9 f2827e67a5564b39ad83a567619e6c64--586ae13cce8947b0904f210c34c0e9a9 c0990c02054c48c9b668b5c9f54f2076 586ae13cce8947b0904f210c34c0e9a9--c0990c02054c48c9b668b5c9f54f2076 069bc5d3ddc84b4fab6bddda90dcb114 c0990c02054c48c9b668b5c9f54f2076--069bc5d3ddc84b4fab6bddda90dcb114 465c7505c09a49c9891de8848fd77453 1d8f4009c38c443dab1a2a1ffa8fc34e 1724ebecbc7742629d08bd15bc93de46--1d8f4009c38c443dab1a2a1ffa8fc34e 45b4c5f2f60a4f3aa9c6b6cb76638357 2 2e26fa41513f47cd9ea9c189932baea8 RX(theta\u2081) 1d8f4009c38c443dab1a2a1ffa8fc34e--2e26fa41513f47cd9ea9c189932baea8 abe3353262c04bc38ba37e592864191d RY(theta\u2085) 2e26fa41513f47cd9ea9c189932baea8--abe3353262c04bc38ba37e592864191d 165c0c7416424bb69e5f7eb654f2e4d1 RX(theta\u2089) abe3353262c04bc38ba37e592864191d--165c0c7416424bb69e5f7eb654f2e4d1 8f90d4cd99d0439ab5566e089247844d X 165c0c7416424bb69e5f7eb654f2e4d1--8f90d4cd99d0439ab5566e089247844d 8f90d4cd99d0439ab5566e089247844d--19a2964ca754456eb625a0edf622a7c8 b26a031824b24ff5bf7595a8c58b656c 8f90d4cd99d0439ab5566e089247844d--b26a031824b24ff5bf7595a8c58b656c 7c149a1b4de94ae79d69515fd214fba3 RX(theta\u2081\u2083) b26a031824b24ff5bf7595a8c58b656c--7c149a1b4de94ae79d69515fd214fba3 2258549b1a684fd78d252ee6984ebb0f RY(theta\u2081\u2087) 7c149a1b4de94ae79d69515fd214fba3--2258549b1a684fd78d252ee6984ebb0f 0d0f2777bb5541f48a776cbf81be9c70 RX(theta\u2082\u2081) 2258549b1a684fd78d252ee6984ebb0f--0d0f2777bb5541f48a776cbf81be9c70 58a1dea87c2b45c6bbad71dc3bc0924e X 0d0f2777bb5541f48a776cbf81be9c70--58a1dea87c2b45c6bbad71dc3bc0924e 58a1dea87c2b45c6bbad71dc3bc0924e--586ae13cce8947b0904f210c34c0e9a9 30e84fef62104603b95b59f7db423e5f 58a1dea87c2b45c6bbad71dc3bc0924e--30e84fef62104603b95b59f7db423e5f 30e84fef62104603b95b59f7db423e5f--465c7505c09a49c9891de8848fd77453 42f2b62e7e704d0292d1f20114c8713b e302b9db5e7e4ea8a7135cedcd38e3d1 45b4c5f2f60a4f3aa9c6b6cb76638357--e302b9db5e7e4ea8a7135cedcd38e3d1 e3094f04a71c466dbdf22e9c41ea076f 3 5b8abb3091354e32be348d00fd44336b RX(theta\u2082) e302b9db5e7e4ea8a7135cedcd38e3d1--5b8abb3091354e32be348d00fd44336b d21e1f6ae13f41fd87d2a1162e574edb RY(theta\u2086) 5b8abb3091354e32be348d00fd44336b--d21e1f6ae13f41fd87d2a1162e574edb 769db2c48e83418b97d703fadfb3df68 RX(theta\u2081\u2080) d21e1f6ae13f41fd87d2a1162e574edb--769db2c48e83418b97d703fadfb3df68 84a1b9ca835943f785a039bfa71ae5ae 769db2c48e83418b97d703fadfb3df68--84a1b9ca835943f785a039bfa71ae5ae 895535506ba143be8b8b39bd1f7532d4 X 84a1b9ca835943f785a039bfa71ae5ae--895535506ba143be8b8b39bd1f7532d4 895535506ba143be8b8b39bd1f7532d4--b26a031824b24ff5bf7595a8c58b656c 3414e208d7b94bcba27734a294259bb2 RX(theta\u2081\u2084) 895535506ba143be8b8b39bd1f7532d4--3414e208d7b94bcba27734a294259bb2 33ebe6dc4093493cbfdd06dcaff65f82 RY(theta\u2081\u2088) 3414e208d7b94bcba27734a294259bb2--33ebe6dc4093493cbfdd06dcaff65f82 981a2e5fe2394d19b71e6c7342dcd712 RX(theta\u2082\u2082) 33ebe6dc4093493cbfdd06dcaff65f82--981a2e5fe2394d19b71e6c7342dcd712 8e49b9af9159401bbb8e7a251b6ced00 981a2e5fe2394d19b71e6c7342dcd712--8e49b9af9159401bbb8e7a251b6ced00 e4ab9425859b4207a115a30161b544b6 X 8e49b9af9159401bbb8e7a251b6ced00--e4ab9425859b4207a115a30161b544b6 e4ab9425859b4207a115a30161b544b6--30e84fef62104603b95b59f7db423e5f e4ab9425859b4207a115a30161b544b6--42f2b62e7e704d0292d1f20114c8713b 9edb0ee9b91645d29b55c0203b42a9d1 6e6be4729f8548fe986bfa9338d94597 X e3094f04a71c466dbdf22e9c41ea076f--6e6be4729f8548fe986bfa9338d94597 77afa7ae4b1b4f37b79eff779791275a RX(theta\u2083) 6e6be4729f8548fe986bfa9338d94597--77afa7ae4b1b4f37b79eff779791275a f11a6fe2ecae4692ab9a1c22665874a8 RY(theta\u2087) 77afa7ae4b1b4f37b79eff779791275a--f11a6fe2ecae4692ab9a1c22665874a8 f08f7a5c7570435288b165857e362051 RX(theta\u2081\u2081) f11a6fe2ecae4692ab9a1c22665874a8--f08f7a5c7570435288b165857e362051 171d38941b544b9a9a79de51de2d7ac0 X f08f7a5c7570435288b165857e362051--171d38941b544b9a9a79de51de2d7ac0 171d38941b544b9a9a79de51de2d7ac0--84a1b9ca835943f785a039bfa71ae5ae 5ef96144384b4323910b742910c2c629 171d38941b544b9a9a79de51de2d7ac0--5ef96144384b4323910b742910c2c629 b0d68868e17842309fcc9608d17e7631 RX(theta\u2081\u2085) 5ef96144384b4323910b742910c2c629--b0d68868e17842309fcc9608d17e7631 e717191dd8c241859aeb76d74f585114 RY(theta\u2081\u2089) b0d68868e17842309fcc9608d17e7631--e717191dd8c241859aeb76d74f585114 b11bb0fe6e6b4522ba29b96dd3e7c8d4 RX(theta\u2082\u2083) e717191dd8c241859aeb76d74f585114--b11bb0fe6e6b4522ba29b96dd3e7c8d4 e33670f5657c4e5db8a7a0571003962f X b11bb0fe6e6b4522ba29b96dd3e7c8d4--e33670f5657c4e5db8a7a0571003962f e33670f5657c4e5db8a7a0571003962f--8e49b9af9159401bbb8e7a251b6ced00 79ce0a8b4e6b4e659b37d6053e5539a0 e33670f5657c4e5db8a7a0571003962f--79ce0a8b4e6b4e659b37d6053e5539a0 79ce0a8b4e6b4e659b37d6053e5539a0--9edb0ee9b91645d29b55c0203b42a9d1  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.4733+0.0588j, -0.3286+0.0288j, -0.0680+0.3754j, -0.3299-0.1679j,\n0.0818+0.2296j, -0.2771-0.2593j, -0.0508+0.0349j,  0.1995-0.3662j],\n[-0.2293+0.0824j, -0.0980-0.0311j, -0.0049-0.1667j,  0.5866+0.3335j,\n0.1787+0.1656j,  0.0792-0.1512j, -0.5753+0.0789j,  0.1434-0.0244j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 CNOT(1,2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}