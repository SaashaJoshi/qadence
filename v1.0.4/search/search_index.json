{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])  # Dimensionless.\nsamples = sample(register, block)\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 41, '10': 33, '01': 26})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        protocol: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._protocol = protocol\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code></p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        protocol: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nprotocol=protocol,\nconfiguration=configuration,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.transform(\nself.expectation(values=values, state=state, protocol=protocol, endianness=endianness)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-11-05T22:47:02.536213 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor _field in fields(self):\nif not _field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend. Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend. Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        protocol: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, state=None, n_shots=1, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nstate: Tensor | None = None,\nn_shots: int = 1,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>idealized device, least realistic</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>device with realistic specs</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction and loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing. Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates. Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: Tuple[int, ...],\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single\n    call to _apply_batch_gate.\"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> %3 c5e77dac72a84cb3a63aed4f573f6ed5 0 a86142f7e69f41ef99b1a88e8b4a7c21 X c5e77dac72a84cb3a63aed4f573f6ed5--a86142f7e69f41ef99b1a88e8b4a7c21 847c480d6c4442659a7e60933f6342dd 1 a1e7792b9ba0473687e228378e641856 a86142f7e69f41ef99b1a88e8b4a7c21--a1e7792b9ba0473687e228378e641856 1e66068e7f4c495cbea36d29c11d83e7 e70a2377103348d98e426a922f7f8500 Y 847c480d6c4442659a7e60933f6342dd--e70a2377103348d98e426a922f7f8500 e70a2377103348d98e426a922f7f8500--1e66068e7f4c495cbea36d29c11d83e7 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> %3 8fb9f3645dce4cdba3d57d8ce7bd42ce 0 6fc3d042ff8f4d62836b0a6d1812b36f X 8fb9f3645dce4cdba3d57d8ce7bd42ce--6fc3d042ff8f4d62836b0a6d1812b36f 9dcad2d645234e9a802e9f278a9c297f Y 6fc3d042ff8f4d62836b0a6d1812b36f--9dcad2d645234e9a802e9f278a9c297f 433f903fb1cd4abdab765b3638afdd23 9dcad2d645234e9a802e9f278a9c297f--433f903fb1cd4abdab765b3638afdd23 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> %3 66e452f7443645f6874d5bb147822098 0 057ccf3698ed4a44894028440d8760bc X 66e452f7443645f6874d5bb147822098--057ccf3698ed4a44894028440d8760bc 4f1382e97f0245feac73e7cff86405c6 1 89efc1f5e62b48c4b4357d2a513486dc 057ccf3698ed4a44894028440d8760bc--89efc1f5e62b48c4b4357d2a513486dc c0ecedcebf294d8791bfd51dea0d090f 89efc1f5e62b48c4b4357d2a513486dc--c0ecedcebf294d8791bfd51dea0d090f 2dae713c06f04670b8816c5e5e0d8e28 0145042602c346829ebd38c11050adf5 4f1382e97f0245feac73e7cff86405c6--0145042602c346829ebd38c11050adf5 df217cb96b064f239a06aba775297a60 Y 0145042602c346829ebd38c11050adf5--df217cb96b064f239a06aba775297a60 df217cb96b064f239a06aba775297a60--2dae713c06f04670b8816c5e5e0d8e28 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_8b6b9328d3044e728c7537720f7585c6 3d6b91a76f7e4df0b07d58ebb594de83 0 182ceb6c13414eebbee634d99cca91d2 3d6b91a76f7e4df0b07d58ebb594de83--182ceb6c13414eebbee634d99cca91d2 1ca3535f4bf549769592f7d8b59bff2f 1 07f4c94bf90449e5a3b9db1ef3209d36 182ceb6c13414eebbee634d99cca91d2--07f4c94bf90449e5a3b9db1ef3209d36 c90e4c8f56c041e2a60b3eec57890a8e 6ad416042d0e4b1ab2d60c75f598e925 AddBlock 1ca3535f4bf549769592f7d8b59bff2f--6ad416042d0e4b1ab2d60c75f598e925 98ca93562de14fdd99bae8c5738f6bb7 2 6ad416042d0e4b1ab2d60c75f598e925--c90e4c8f56c041e2a60b3eec57890a8e eeac8fd2a89d4c26a1413bb301c4763d 449fab9cc13e4d7b87e1a19342e4a7c0 98ca93562de14fdd99bae8c5738f6bb7--449fab9cc13e4d7b87e1a19342e4a7c0 449fab9cc13e4d7b87e1a19342e4a7c0--eeac8fd2a89d4c26a1413bb301c4763d <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> %3 cluster_1bc812e3868d4b658a069a520d498274 cluster_6467f7c8b06c4e29a11ce9995eb88134 rx 6129ad3985fa4bf39dcb9dcb3a12dc8f 0 571cd80692fa463180aa5ad61dc65ed6 X 6129ad3985fa4bf39dcb9dcb3a12dc8f--571cd80692fa463180aa5ad61dc65ed6 628f8ad6c1ec45e2af85dbd49b69c703 1 8759a31e41384fb282765d94ba222e70 571cd80692fa463180aa5ad61dc65ed6--8759a31e41384fb282765d94ba222e70 1614b04f45ba4b929a153a704bf89f16 8759a31e41384fb282765d94ba222e70--1614b04f45ba4b929a153a704bf89f16 694a145ee1ed4e98a5ecc9d649917061 1614b04f45ba4b929a153a704bf89f16--694a145ee1ed4e98a5ecc9d649917061 e6300e7ae748455e8acebf0a7faf2a07 00143a376fd243c9b8bc0cdda5b2e9c8 Y 628f8ad6c1ec45e2af85dbd49b69c703--00143a376fd243c9b8bc0cdda5b2e9c8 1b4ae184d3e745b283a4fcc1ca940a7b 2 f0dc167e1c534135aecaa4abd25b3b24 00143a376fd243c9b8bc0cdda5b2e9c8--f0dc167e1c534135aecaa4abd25b3b24 cdc3482ead09407ca67cf0fd2bdaf02a HamEvo f0dc167e1c534135aecaa4abd25b3b24--cdc3482ead09407ca67cf0fd2bdaf02a cdc3482ead09407ca67cf0fd2bdaf02a--e6300e7ae748455e8acebf0a7faf2a07 4b4a520667e24d6fbda6365f24a2985f b573a980831a481389bb62feee9960a5 RX(x) 1b4ae184d3e745b283a4fcc1ca940a7b--b573a980831a481389bb62feee9960a5 8aecec32b0274f7391a85a26f926f50f 3 bd1213bcf2694a43bc0970c21e609aac b573a980831a481389bb62feee9960a5--bd1213bcf2694a43bc0970c21e609aac bd34967c94f34f66aec0c1f4e20cefd6 t = 10 bd1213bcf2694a43bc0970c21e609aac--bd34967c94f34f66aec0c1f4e20cefd6 bd34967c94f34f66aec0c1f4e20cefd6--4b4a520667e24d6fbda6365f24a2985f c3de2638bc0b48fb9f3524c85872b7d0 b477413aa8404dd0a3ff23b71196979c RX(0.5) 8aecec32b0274f7391a85a26f926f50f--b477413aa8404dd0a3ff23b71196979c d3a6652800a24fcb8eb727a9dc4ad34a X b477413aa8404dd0a3ff23b71196979c--d3a6652800a24fcb8eb727a9dc4ad34a d3a6652800a24fcb8eb727a9dc4ad34a--bd1213bcf2694a43bc0970c21e609aac 02b5e630fbad45f79613fcad74b8f062 d3a6652800a24fcb8eb727a9dc4ad34a--02b5e630fbad45f79613fcad74b8f062 02b5e630fbad45f79613fcad74b8f062--c3de2638bc0b48fb9f3524c85872b7d0 <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_82c60f41fe8545dc9d823359a4408bbf HEA cluster_2d9d6d8958e048ac8f723d200aaa4804 Tower Fourier FM 351a97180a214bbaacee7b739696f746 0 7d4dbda40eda4a3d9d02a5152cdec5c4 RX(1.0*phi) 351a97180a214bbaacee7b739696f746--7d4dbda40eda4a3d9d02a5152cdec5c4 61d1eac7a75e4d6da0e48171e3443eab 1 048fbdfd92f641c988bbb4fab6695208 RX(theta\u2080) 7d4dbda40eda4a3d9d02a5152cdec5c4--048fbdfd92f641c988bbb4fab6695208 bf97bebaf674437fbd1f5009a7b1c04b RY(theta\u2084) 048fbdfd92f641c988bbb4fab6695208--bf97bebaf674437fbd1f5009a7b1c04b 4380219ac3b24603b30c6c7da1b8aa83 RX(theta\u2088) bf97bebaf674437fbd1f5009a7b1c04b--4380219ac3b24603b30c6c7da1b8aa83 279f1d3e7b784d709d21ffd25c75faec 4380219ac3b24603b30c6c7da1b8aa83--279f1d3e7b784d709d21ffd25c75faec cc89a46e883641e7ad477e1f644766f2 279f1d3e7b784d709d21ffd25c75faec--cc89a46e883641e7ad477e1f644766f2 9994414243ba46279170f7f266d256ba RX(theta\u2081\u2082) cc89a46e883641e7ad477e1f644766f2--9994414243ba46279170f7f266d256ba 7e795a9291924cc7a235614d093b4070 RY(theta\u2081\u2086) 9994414243ba46279170f7f266d256ba--7e795a9291924cc7a235614d093b4070 a389153940d64c88bd019670c694d175 RX(theta\u2082\u2080) 7e795a9291924cc7a235614d093b4070--a389153940d64c88bd019670c694d175 b3b28434b0a34c22a7a7a9fa0e91c553 a389153940d64c88bd019670c694d175--b3b28434b0a34c22a7a7a9fa0e91c553 941e0a7778154b6fb14295e1891a6a0b b3b28434b0a34c22a7a7a9fa0e91c553--941e0a7778154b6fb14295e1891a6a0b 2d8fd84f39494969ad960c4b680135f9 941e0a7778154b6fb14295e1891a6a0b--2d8fd84f39494969ad960c4b680135f9 ffe6412c52764eac96cda3317e056fd9 46c5c04dd6234007a840f757f1071bfb RX(2.0*phi) 61d1eac7a75e4d6da0e48171e3443eab--46c5c04dd6234007a840f757f1071bfb e75e3bcea6174302bde811ed18e4483f 2 1f666e0c29a94aca9e9714f495d1fdc7 RX(theta\u2081) 46c5c04dd6234007a840f757f1071bfb--1f666e0c29a94aca9e9714f495d1fdc7 81743a32d75d427b8868be002154fdb4 RY(theta\u2085) 1f666e0c29a94aca9e9714f495d1fdc7--81743a32d75d427b8868be002154fdb4 e00005a0a08b4e078f1a5d58a2e2aced RX(theta\u2089) 81743a32d75d427b8868be002154fdb4--e00005a0a08b4e078f1a5d58a2e2aced 745a99a0239e4aa38184df310e9ce9cf X e00005a0a08b4e078f1a5d58a2e2aced--745a99a0239e4aa38184df310e9ce9cf 745a99a0239e4aa38184df310e9ce9cf--279f1d3e7b784d709d21ffd25c75faec ce3eb9faebc042eea059a0d09a0d2419 745a99a0239e4aa38184df310e9ce9cf--ce3eb9faebc042eea059a0d09a0d2419 6b8579ae8d9d4311a62eb9ae339af136 RX(theta\u2081\u2083) ce3eb9faebc042eea059a0d09a0d2419--6b8579ae8d9d4311a62eb9ae339af136 aa6ad49f8df84680be32500c2bb9f7f4 RY(theta\u2081\u2087) 6b8579ae8d9d4311a62eb9ae339af136--aa6ad49f8df84680be32500c2bb9f7f4 0df683b9bc0146ffa97e535a52fee4a9 RX(theta\u2082\u2081) aa6ad49f8df84680be32500c2bb9f7f4--0df683b9bc0146ffa97e535a52fee4a9 12583ccab03d4de6bb64a5192d84d828 X 0df683b9bc0146ffa97e535a52fee4a9--12583ccab03d4de6bb64a5192d84d828 12583ccab03d4de6bb64a5192d84d828--b3b28434b0a34c22a7a7a9fa0e91c553 2d8a07cdd89843b4bcd5ad1a1ba4ecd6 12583ccab03d4de6bb64a5192d84d828--2d8a07cdd89843b4bcd5ad1a1ba4ecd6 2d8a07cdd89843b4bcd5ad1a1ba4ecd6--ffe6412c52764eac96cda3317e056fd9 1f163426e064480aa4cedd5a739ad496 6bedc82b19da415fa414d2602589c0a1 RX(3.0*phi) e75e3bcea6174302bde811ed18e4483f--6bedc82b19da415fa414d2602589c0a1 d01bbb4350a541899a7a293787150895 3 52c4e07bc70743acbf091f622c39f2cc RX(theta\u2082) 6bedc82b19da415fa414d2602589c0a1--52c4e07bc70743acbf091f622c39f2cc 147ce274ee2d44249740bfc60011f61e RY(theta\u2086) 52c4e07bc70743acbf091f622c39f2cc--147ce274ee2d44249740bfc60011f61e 6c622f3ae818406cbb2e7c2de424be77 RX(theta\u2081\u2080) 147ce274ee2d44249740bfc60011f61e--6c622f3ae818406cbb2e7c2de424be77 742a1cde3093410d8a0ec0fca361e5e8 6c622f3ae818406cbb2e7c2de424be77--742a1cde3093410d8a0ec0fca361e5e8 79d11fb076f24e60b006b1c2b5631466 X 742a1cde3093410d8a0ec0fca361e5e8--79d11fb076f24e60b006b1c2b5631466 79d11fb076f24e60b006b1c2b5631466--ce3eb9faebc042eea059a0d09a0d2419 cc2c5c9ade6442f981d203d480d51085 RX(theta\u2081\u2084) 79d11fb076f24e60b006b1c2b5631466--cc2c5c9ade6442f981d203d480d51085 7211e2328a0a45d39a9f7d3ec2ea1f5d RY(theta\u2081\u2088) cc2c5c9ade6442f981d203d480d51085--7211e2328a0a45d39a9f7d3ec2ea1f5d 5c8fd54edbde40d995cc29f1916ab59f RX(theta\u2082\u2082) 7211e2328a0a45d39a9f7d3ec2ea1f5d--5c8fd54edbde40d995cc29f1916ab59f 4173e5ff7f6e407d8e97285ac543a2b7 5c8fd54edbde40d995cc29f1916ab59f--4173e5ff7f6e407d8e97285ac543a2b7 84d0c2de8d314cad8acbcc4f5c08c5d9 X 4173e5ff7f6e407d8e97285ac543a2b7--84d0c2de8d314cad8acbcc4f5c08c5d9 84d0c2de8d314cad8acbcc4f5c08c5d9--2d8a07cdd89843b4bcd5ad1a1ba4ecd6 84d0c2de8d314cad8acbcc4f5c08c5d9--1f163426e064480aa4cedd5a739ad496 80721a0068d64505a636c00422345ec3 de0779b71fe14a3d84ead8895276a4ab RX(4.0*phi) d01bbb4350a541899a7a293787150895--de0779b71fe14a3d84ead8895276a4ab 14d462c7893a4c57bf7ed310376f78ec RX(theta\u2083) de0779b71fe14a3d84ead8895276a4ab--14d462c7893a4c57bf7ed310376f78ec a4ede345433747fa81680982d1e5678a RY(theta\u2087) 14d462c7893a4c57bf7ed310376f78ec--a4ede345433747fa81680982d1e5678a a88dda23c60c4f6fb7b750ef38faa62f RX(theta\u2081\u2081) a4ede345433747fa81680982d1e5678a--a88dda23c60c4f6fb7b750ef38faa62f d372684c6e0b453c8e58cf0cc38e8bf8 X a88dda23c60c4f6fb7b750ef38faa62f--d372684c6e0b453c8e58cf0cc38e8bf8 d372684c6e0b453c8e58cf0cc38e8bf8--742a1cde3093410d8a0ec0fca361e5e8 8c053cc60cd8465cace4f38e187ce02d d372684c6e0b453c8e58cf0cc38e8bf8--8c053cc60cd8465cace4f38e187ce02d 7c0996d2637e4a808423a3abeff37433 RX(theta\u2081\u2085) 8c053cc60cd8465cace4f38e187ce02d--7c0996d2637e4a808423a3abeff37433 c82268d9f287434b82580de1466672cc RY(theta\u2081\u2089) 7c0996d2637e4a808423a3abeff37433--c82268d9f287434b82580de1466672cc df23f8251f014d719909d4843e0da9b9 RX(theta\u2082\u2083) c82268d9f287434b82580de1466672cc--df23f8251f014d719909d4843e0da9b9 b133b386087344da9a31bb7d9c303621 X df23f8251f014d719909d4843e0da9b9--b133b386087344da9a31bb7d9c303621 b133b386087344da9a31bb7d9c303621--4173e5ff7f6e407d8e97285ac543a2b7 939e8f738b4540eca1c4d30aea479898 b133b386087344da9a31bb7d9c303621--939e8f738b4540eca1c4d30aea479898 939e8f738b4540eca1c4d30aea479898--80721a0068d64505a636c00422345ec3"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/","title":"Digital-Analog Emulation","text":""},{"location":"digital_analog_qc/analog-basics/#from-theory-to-implementation","title":"From theory to implementation","text":"<p>Qadence includes primitives for the construction of Ising-like Hamiltonians to account for custom qubit interaction. This allows to simulate systems close to real quantum computing platforms such as neutral atoms. The general form for time-independent Ising Hamiltonians is</p> \\[ \\mathcal{H} = \\sum_{i} \\frac{\\hbar\\Omega}{2} \\hat\\sigma^x_i - \\sum_{i} \\hbar\\delta \\hat n_i  + \\mathcal{H}_{\\textrm{int}}, \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\hat n = \\frac{1-\\hat\\sigma_z}{2}\\) is the number operator, and \\(\\mathcal{H}_{\\textrm{int}}\\) a pair-wise interaction term. Two central operations implement this Hamiltonian as blocks:</p> <ul> <li><code>WaitBlock</code> by free-evolving \\(\\mathcal{H}_{\\textrm{int}}\\)</li> <li><code>ConstantAnalogRotation</code> by free-evolving \\(\\mathcal{H}\\)</li> </ul> <p>The <code>wait</code> operation can be emulated with an \\(ZZ\\)- (Ising) or an \\(XY\\)-interaction:</p> <pre><code>from qadence import Register, wait, add_interaction, run, Interaction\nblock = wait(duration=3000)\nreg = Register.from_coordinates([(0,0), (0,5)])  # Dimensionless.\nemulated = add_interaction(reg, block, interaction=Interaction.XY)  # or Interaction.ZZ for Ising.\n</code></pre> <pre><code>block = WaitBlock(t=3000.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,)) emulated.generator = AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 29.600] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> <p>The <code>AnalogRot</code> constructor can be used to create a fully customizable <code>ConstantAnalogRotation</code> instances:</p> <pre><code>import torch\nfrom qadence import AnalogRot, AnalogRX\n# Implement a global RX rotation by setting all parameters.\nblock = AnalogRot(\nduration=1000., # [ns]\nomega=torch.pi, # [rad/\u03bcs]\ndelta=0,        # [rad/\u03bcs]\nphase=0,        # [rad]\n)\n# Or use the shortcut.\nblock = AnalogRX(torch.pi)\n</code></pre> <pre><code>AnalogRot = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\nAnalogRX = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\n</code></pre> <p>Automatic emulation in the PyQTorch backend</p> <p>All analog blocks are automatically translated to their emulated version when running them with the PyQTorch backend:</p> <p><pre><code>import torch\nfrom qadence import Register, AnalogRX, sample\nreg = Register.from_coordinates([(0,0), (0,5)])\nsample = sample(reg, AnalogRX(torch.pi))\n</code></pre> <pre><code>sample = [Counter({'00': 40, '10': 32, '01': 28})]\n</code></pre> </p> <p>To compose analog blocks, the regular <code>chain</code> and <code>kron</code> operations can be used under the following restrictions:</p> <ul> <li>The resulting <code>AnalogChain</code> type can only be constructed from <code>AnalogKron</code> blocks   or globally supported primitive analog blocks.</li> <li>The resulting <code>AnalogKron</code> type can only be constructed from non-global   analog blocks with the same duration.</li> </ul> <pre><code>import torch\nfrom qadence import AnalogRot, kron, chain, wait\n# Only analog blocks with a global qubit support can be composed\n# using chain.\nanalog_chain = chain(wait(duration=200), AnalogRot(duration=300, omega=2.0))\n# Only blocks with the same `duration` can be composed using kron.\nanalog_kron = kron(\nwait(duration=1000, qubit_support=(0,1)),\nAnalogRot(duration=1000, omega=2.0, qubit_support=(2,3))\n)\n</code></pre> <pre><code>Analog Chain block = AnalogChain(t=500.000000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u251c\u2500\u2500 WaitBlock(t=200.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=0.600000000000000, t=300, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\nAnalog Kron block = AnalogKron(t=1000, support=(0, 1, 2, 3))\n\u251c\u2500\u2500 WaitBlock(t=1000.0, support=(0, 1))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=2.00000000000000, t=1000, support=(2, 3), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\n</code></pre> <p>Composing digital &amp; analog blocks</p> <p>It is possible to compose digital and analog blocks where the additional restrictions for <code>chain</code> and <code>kron</code> only apply to composite blocks which contain analog blocks only. For further details, see <code>AnalogChain</code> and <code>AnalogKron</code>.</p>"},{"location":"digital_analog_qc/analog-basics/#fitting-a-simple-function","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and paramertized ansatze to fit a sine function. First, define an ansatz block and an observable:</p> <pre><code>import torch\nfrom qadence import Register, FeatureParameter, VariationalParameter\nfrom qadence import AnalogRX, AnalogRZ, Z\nfrom qadence import wait, chain, add\npi = torch.pi\n# A two qubit register.\nreg = Register.from_coordinates([(0, 0), (0, 12)])\n# An analog ansatz with an input time parameter.\nt = FeatureParameter(\"t\")\nblock = chain(\nAnalogRX(pi/2.),\nAnalogRZ(t),\nwait(1000 * VariationalParameter(\"theta\", value=0.5)),\nAnalogRX(pi/2),\n)\n# Total magnetization observable.\nobs = add(Z(i) for i in range(reg.n_qubits))\n</code></pre> Plotting functions <code>plot</code> and <code>scatter</code> <p><pre><code>def plot(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.plot(xnp, ynp, **kwargs)\ndef scatter(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.scatter(xnp, ynp, **kwargs)\n</code></pre> </p> <p>Next, define the dataset to train on and plot the initial prediction. The differentiation mode can be set to either <code>DiffMode.AD</code> or <code>DiffMode.GPSR</code>.</p> <pre><code>import matplotlib.pyplot as plt\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\n# Define a quantum model including digital-analog emulation.\ncirc = QuantumCircuit(reg, block)\nmodel = QuantumModel(circ, obs, diff_mode=DiffMode.GPSR)\n# Time support dataset.\nx_train = torch.linspace(0, 6, steps=30)\n# Function to fit.\ny_train = -0.64 * torch.sin(x_train + 0.33) + 0.1\n# Initial prediction.\ny_pred_initial = model.expectation({\"t\": x_train})\n</code></pre> 2023-11-05T22:47:03.286464 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Finally, the classical optimization part is handled by PyTorch:</p> <pre><code># Use PyTorch built-in functionality.\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-2)\n# Define a loss function.\ndef loss_fn(x_train, y_train):\nreturn mse_loss(model.expectation({\"t\": x_train}).squeeze(), y_train)\n# Number of epochs to train over.\nn_epochs = 200\n# Optimization loop.\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n# Get and visualize the final prediction.\ny_pred = model.expectation({\"t\": x_train})\n</code></pre> 2023-11-05T22:47:06.807820 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.transpile.emulate import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430074584827*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279670303258*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430074584827*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279670303258*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 89, '00100': 86, '10000': 76, '00001': 74, '00010': 72, '00101': 19, '11000': 18, '10010': 13, '01001': 12, '10100': 12, '00011': 11, '00110': 11, '01100': 8, '10001': 8, '01010': 7, '01101': 3, '10110': 3, '00111': 2, '10011': 2, '11010': 2, '01011': 1, '10101': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 243, '01011': 200, '00100': 103, '01000': 97, '01001': 82, '00110': 72, '00000': 61, '00001': 33, '00010': 25, '10000': 23, '01010': 16, '00101': 14, '10001': 7, '10011': 7, '01111': 5, '10010': 5, '01101': 4, '00011': 2, '01100': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-11-05T22:47:08.745452 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-basics/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>The DAQC paradigm is typically implemented on quantum computing hardware based on neutral-atoms where both these computations are realizable.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real neutral-atom devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/daqc-basics/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_729eb6832bdd40d18c4f3b5b7eca9caa cluster_45efc602aa1340ee8cffc0f6bdc92714 cluster_a7214c38c1fc4e2ebcf57bbdfcaed4a7 cluster_06547320a48c49379b970ef1d44f0f38 cluster_e6f38ecf58af4e6a958a9eb9dc5e1e42 cluster_1ce85f12fa6e4cb09c59e4fe90e68ec7 cluster_80089d996b0f461d881f6d728105d63f 83e2d621c42e435e93fb5f815aa8a530 0 dec9807f282c4dff8119bdd291d52b4e HamEvo 83e2d621c42e435e93fb5f815aa8a530--dec9807f282c4dff8119bdd291d52b4e 61fc0cdfc0794cbda0f49d128d380a69 1 45f78f9bfe534d529a213ae743db9ca0 HamEvo dec9807f282c4dff8119bdd291d52b4e--45f78f9bfe534d529a213ae743db9ca0 39fd2eceb54b48b3ba54fb7edf095204 HamEvo 45f78f9bfe534d529a213ae743db9ca0--39fd2eceb54b48b3ba54fb7edf095204 a46e7ee5ad3a4b72a37f602b7a1d1667 X 39fd2eceb54b48b3ba54fb7edf095204--a46e7ee5ad3a4b72a37f602b7a1d1667 8feda2a115d94a7491de0f955afae62d HamEvo a46e7ee5ad3a4b72a37f602b7a1d1667--8feda2a115d94a7491de0f955afae62d efdafba34bb74aefad06c316a60b8750 HamEvo 8feda2a115d94a7491de0f955afae62d--efdafba34bb74aefad06c316a60b8750 280398766e19420494d06d27c1b1aa29 X efdafba34bb74aefad06c316a60b8750--280398766e19420494d06d27c1b1aa29 48d43a10f4c14bd2a92eba9ba3e7b134 280398766e19420494d06d27c1b1aa29--48d43a10f4c14bd2a92eba9ba3e7b134 02071391f73a4771bd945c8312191052 HamEvo 48d43a10f4c14bd2a92eba9ba3e7b134--02071391f73a4771bd945c8312191052 8af4d2e163f94a91b53fbc1b2152963c HamEvo 02071391f73a4771bd945c8312191052--8af4d2e163f94a91b53fbc1b2152963c 2004e39985734f62a72e0602c7839a91 8af4d2e163f94a91b53fbc1b2152963c--2004e39985734f62a72e0602c7839a91 0e1e4cbd6615478d9efd61f4dfe496c9 2004e39985734f62a72e0602c7839a91--0e1e4cbd6615478d9efd61f4dfe496c9 3d0b7a696b85477296ba9500f7607cc3 775a3dae42194f7bb803b75c007ee697 t = -3.142 61fc0cdfc0794cbda0f49d128d380a69--775a3dae42194f7bb803b75c007ee697 8ebf38d21b8441a69361f0f7f35f39a6 2 c6c5ba4cdb3d43bab20cdf0c56c53eac t = 3.142 775a3dae42194f7bb803b75c007ee697--c6c5ba4cdb3d43bab20cdf0c56c53eac 751942b87eca490982de777ef7d0ed38 t = -3.142 c6c5ba4cdb3d43bab20cdf0c56c53eac--751942b87eca490982de777ef7d0ed38 de4ef68c90174333a6095abacf0322d6 751942b87eca490982de777ef7d0ed38--de4ef68c90174333a6095abacf0322d6 2951346b15ad4518a42a094f410c0c0e t = 1.571 de4ef68c90174333a6095abacf0322d6--2951346b15ad4518a42a094f410c0c0e 187969bf57c044b8b634b5cdfd8f39ba t = 1.571 2951346b15ad4518a42a094f410c0c0e--187969bf57c044b8b634b5cdfd8f39ba 03f146d028664fdbb1796d43572bfa60 187969bf57c044b8b634b5cdfd8f39ba--03f146d028664fdbb1796d43572bfa60 cd094d9caf13443f965238e15bda70fd X 03f146d028664fdbb1796d43572bfa60--cd094d9caf13443f965238e15bda70fd d5f869d5eb4f4179ae7a11cf5303d82b t = 1.571 cd094d9caf13443f965238e15bda70fd--d5f869d5eb4f4179ae7a11cf5303d82b 7023a485552b4f2b808152876afdbcc0 t = 1.571 d5f869d5eb4f4179ae7a11cf5303d82b--7023a485552b4f2b808152876afdbcc0 d0b3a32ac035423d8bad5286564f5a27 X 7023a485552b4f2b808152876afdbcc0--d0b3a32ac035423d8bad5286564f5a27 d0b3a32ac035423d8bad5286564f5a27--3d0b7a696b85477296ba9500f7607cc3 172a7ea0513f4477a8dfcb3f64835b98 ff5674b5330749f28d69003633a8b7b7 8ebf38d21b8441a69361f0f7f35f39a6--ff5674b5330749f28d69003633a8b7b7 8927fc3913a54e1babab327ec6dc32d0 ff5674b5330749f28d69003633a8b7b7--8927fc3913a54e1babab327ec6dc32d0 ef3d6fb2fb2345379b62dc1a08ea02c9 8927fc3913a54e1babab327ec6dc32d0--ef3d6fb2fb2345379b62dc1a08ea02c9 5da971e3e7e94a5fb713411be367d0e0 X ef3d6fb2fb2345379b62dc1a08ea02c9--5da971e3e7e94a5fb713411be367d0e0 8c51cb5ec63947afbe55dcd9cbbdb6ea 5da971e3e7e94a5fb713411be367d0e0--8c51cb5ec63947afbe55dcd9cbbdb6ea 5b646b44f0694fb3b9c4f8b08ee97a63 8c51cb5ec63947afbe55dcd9cbbdb6ea--5b646b44f0694fb3b9c4f8b08ee97a63 89f7781665914c9ab2d7c7f0119dd8d7 X 5b646b44f0694fb3b9c4f8b08ee97a63--89f7781665914c9ab2d7c7f0119dd8d7 02a762705860445999901cd67a83a778 X 89f7781665914c9ab2d7c7f0119dd8d7--02a762705860445999901cd67a83a778 5083a44f98b94417ba2a751ca7b2c8c9 02a762705860445999901cd67a83a778--5083a44f98b94417ba2a751ca7b2c8c9 1553b8c4f7ba4f6cbb1325aabacb2bc7 5083a44f98b94417ba2a751ca7b2c8c9--1553b8c4f7ba4f6cbb1325aabacb2bc7 96472e81cb1645f6af8f85d35d85c7c6 X 1553b8c4f7ba4f6cbb1325aabacb2bc7--96472e81cb1645f6af8f85d35d85c7c6 96472e81cb1645f6af8f85d35d85c7c6--172a7ea0513f4477a8dfcb3f64835b98 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_4dda9e352446456fa22f94c6a5d5844e cluster_d47ca694cfb04ad4b8e41c99266e38aa ec6cd3aad24743898fd1db0af8ca875a 0 a004b43a3e914c3d84c9d06560892110 X ec6cd3aad24743898fd1db0af8ca875a--a004b43a3e914c3d84c9d06560892110 685db354a03548b88d7ac3f63ce5797c 1 d289caa4b8d6418f81576a09c20ffda3 HamEvo a004b43a3e914c3d84c9d06560892110--d289caa4b8d6418f81576a09c20ffda3 47a8140a0d204d769707ee0582d2e62c X d289caa4b8d6418f81576a09c20ffda3--47a8140a0d204d769707ee0582d2e62c 72cf998cf98c4b50b4f4363cfbc74294 47a8140a0d204d769707ee0582d2e62c--72cf998cf98c4b50b4f4363cfbc74294 0ab7143e27eb492283494f3d54c11ff3 HamEvo 72cf998cf98c4b50b4f4363cfbc74294--0ab7143e27eb492283494f3d54c11ff3 ce1e116423934839aaf68fbe8d51712b 0ab7143e27eb492283494f3d54c11ff3--ce1e116423934839aaf68fbe8d51712b e0be72533b6d454a8b4d4a358e7800da ce1e116423934839aaf68fbe8d51712b--e0be72533b6d454a8b4d4a358e7800da d3fe679419bc4b70937e9b76e61c08c0 98009114064b4f00891a58f989d93ff6 685db354a03548b88d7ac3f63ce5797c--98009114064b4f00891a58f989d93ff6 d9a479ba4d6e43b9bc1190a77b2a62e0 2 60af7dd07f4e417592c7ea3d2594ba88 t = -0.500 98009114064b4f00891a58f989d93ff6--60af7dd07f4e417592c7ea3d2594ba88 d15ceb24da0842a59e7cd5e43805b390 60af7dd07f4e417592c7ea3d2594ba88--d15ceb24da0842a59e7cd5e43805b390 c3a23c669c0d4ff497f93ef3b50091b5 X d15ceb24da0842a59e7cd5e43805b390--c3a23c669c0d4ff497f93ef3b50091b5 6091fd45465e448d834ff55addcce5d2 t = -0.500 c3a23c669c0d4ff497f93ef3b50091b5--6091fd45465e448d834ff55addcce5d2 7e165a0410ff47b6a03746371b75b05f X 6091fd45465e448d834ff55addcce5d2--7e165a0410ff47b6a03746371b75b05f 7e165a0410ff47b6a03746371b75b05f--d3fe679419bc4b70937e9b76e61c08c0 59ac8ba6ebb44cc292bf28e7894126be 05029f4b4dde4567abcaa6f64056453f X d9a479ba4d6e43b9bc1190a77b2a62e0--05029f4b4dde4567abcaa6f64056453f 0e6a7a5bf9e7411b97a12cfc30d05ecd 05029f4b4dde4567abcaa6f64056453f--0e6a7a5bf9e7411b97a12cfc30d05ecd 446820c8b308400ba0695180c0fd41ec X 0e6a7a5bf9e7411b97a12cfc30d05ecd--446820c8b308400ba0695180c0fd41ec d872eea3e4334eacaf308f198302d13f X 446820c8b308400ba0695180c0fd41ec--d872eea3e4334eacaf308f198302d13f d57e41ae86354eceab1d51f36d818c0a d872eea3e4334eacaf308f198302d13f--d57e41ae86354eceab1d51f36d818c0a 5a37fa83628340a585a4c4d28a89b0eb X d57e41ae86354eceab1d51f36d818c0a--5a37fa83628340a585a4c4d28a89b0eb 5a37fa83628340a585a4c4d28a89b0eb--59ac8ba6ebb44cc292bf28e7894126be <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_c460bbd9e1ff4053a584bd2892a86cb6 cluster_2942730b4c224ec4aa7f1855d4e0cbc4 f4acee8591b64f25b6562201df8bd838 0 0742c60bfab14fbaaeda6ff71e3fda6c X f4acee8591b64f25b6562201df8bd838--0742c60bfab14fbaaeda6ff71e3fda6c 3e2701b870294107a586c878546461f7 1 db8d54760d154a07abf935f17812668d HamEvo 0742c60bfab14fbaaeda6ff71e3fda6c--db8d54760d154a07abf935f17812668d 3c80c586c8094d5383ddf1388791221c X db8d54760d154a07abf935f17812668d--3c80c586c8094d5383ddf1388791221c dcbb255f863848d9b3689466daaa689d 3c80c586c8094d5383ddf1388791221c--dcbb255f863848d9b3689466daaa689d 54af439a25534349b68506f23046578d HamEvo dcbb255f863848d9b3689466daaa689d--54af439a25534349b68506f23046578d c1a9955f9dc94759896548e3503faa44 54af439a25534349b68506f23046578d--c1a9955f9dc94759896548e3503faa44 a193b97c39c840da9c755149b10ef984 c1a9955f9dc94759896548e3503faa44--a193b97c39c840da9c755149b10ef984 ca06166f1d304c6a803e56a045603696 c88d017fdbe54a528bb55ee661aee058 3e2701b870294107a586c878546461f7--c88d017fdbe54a528bb55ee661aee058 7ae572e5aec8446a8e5edaba0a811fc3 2 13e88d7f973d49b29f1187ad869acc0b t = -500.000000000000 c88d017fdbe54a528bb55ee661aee058--13e88d7f973d49b29f1187ad869acc0b d433da021bfc46b6ac27e5cf9bfdaca0 13e88d7f973d49b29f1187ad869acc0b--d433da021bfc46b6ac27e5cf9bfdaca0 c6ee2174ea734366b13d9fd436ba71aa X d433da021bfc46b6ac27e5cf9bfdaca0--c6ee2174ea734366b13d9fd436ba71aa 2e1d250fb38b40b8b07f01e94a4cdc5c t = -500.000000000000 c6ee2174ea734366b13d9fd436ba71aa--2e1d250fb38b40b8b07f01e94a4cdc5c 7b6177ff4e214921bce2c04be577f8c0 X 2e1d250fb38b40b8b07f01e94a4cdc5c--7b6177ff4e214921bce2c04be577f8c0 7b6177ff4e214921bce2c04be577f8c0--ca06166f1d304c6a803e56a045603696 45ffce73c0dc47a886ddec5ac53904d4 79be4163bace48d1bdc9c27c3f7c9df6 X 7ae572e5aec8446a8e5edaba0a811fc3--79be4163bace48d1bdc9c27c3f7c9df6 b29716b3348c4759abde12dae33b2b5c 79be4163bace48d1bdc9c27c3f7c9df6--b29716b3348c4759abde12dae33b2b5c 2020b61207a24a10b0677fcd182692b4 X b29716b3348c4759abde12dae33b2b5c--2020b61207a24a10b0677fcd182692b4 a34282e596764faf83714d9fdaab493a X 2020b61207a24a10b0677fcd182692b4--a34282e596764faf83714d9fdaab493a 75ede891858242dca44de73cece9984d a34282e596764faf83714d9fdaab493a--75ede891858242dca44de73cece9984d 1a65accbaf0c4c71b1fd2910d52411b1 X 75ede891858242dca44de73cece9984d--1a65accbaf0c4c71b1fd2910d52411b1 1a65accbaf0c4c71b1fd2910d52411b1--45ffce73c0dc47a886ddec5ac53904d4 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <p><code>python exec=\"off\" source=\"material-block\" html=\"1\" session=\"pulser-basic\" config = {     \"cloud_configuration\": {         \"username\": \"&lt;changeme&gt;\",         \"password\": \"&lt;changeme&gt;\",         \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators         \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`     } }</code></p> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7080-0.0207j,  0.0395+0.3061j,  0.0039-0.0540j,  0.6220-0.1151j]])\nsample = Counter({'00': 27, '11': 18, '01': 5})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-11-05T22:47:09.178882 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-11-05T22:47:09.296911 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 26, '01': 18, '11': 6})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-11-05T22:47:09.713080 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-11-05T22:47:09.872146 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system. A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on. Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations such as single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks. Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks. Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time). Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time). Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian</p> <pre><code>H = \u2211\u1d62(h\u03a9/2 sin(\u03c6)*X\u1d62 - cos(\u03c6)*Y\u1d62 - h\u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits. In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially. On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially. On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically. On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically. On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks. Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially. Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed). Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally. Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.5034+0.1645j, -0.2575-0.4773j, -0.1863-0.2398j, -0.5771+0.0125j],\n[ 0.0301-0.4791j,  0.5561+0.0912j, -0.5891-0.2234j, -0.1547-0.1766j],\n[-0.1238-0.5348j, -0.3862-0.0394j,  0.2656+0.1068j, -0.1997-0.6528j],\n[-0.3733-0.2200j, -0.1777-0.4539j,  0.0268-0.6544j,  0.3337+0.1853j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nsupport = tuple(range(n_qubits)) if support is None else support\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=RZ,\nfm_type=BasisSet.FOURIER,\nreupload_scaling=ReuploadScaling.EXP,\nfeature_range=feature_range,\ntarget_range=(0.0, 2 * pi),\n)\nrlayer.tag = None\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] | None = None,\nparam: Parameter | str = \"phi\",\nop: RotationTypes = RX,\nfm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\nreupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\nfeature_range: tuple[float, float] | None = None,\ntarget_range: tuple[float, float] | None = None,\nmultiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n# Process input\nif support is None:\nsupport = tuple(range(n_qubits))\nelif len(support) != n_qubits:\nraise ValueError(\"Wrong qubit support supplied\")\nif op not in ROTATIONS:\nraise ValueError(\nf\"Operation {op} not supported. \"\nf\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n)\n# Backwards compatibility\nif fm_type in (\"fourier\", \"chebyshev\", \"tower\"):\nlogger.warning(\n\"Selecting `fm_type` as 'fourier', 'chebyshev' or 'tower' is deprecated. \"\n\"Please use the respective enumerations: 'fm_type = BasisSet.FOURIER', \"\n\"'fm_type = BasisSet.CHEBYSHEV' or 'reupload_scaling = ReuploadScaling.TOWER'.\"\n)\nif fm_type == \"fourier\":\nfm_type = BasisSet.FOURIER\nelif fm_type == \"chebyshev\":\nfm_type = BasisSet.CHEBYSHEV\nelif fm_type == \"tower\":\nfm_type = BasisSet.CHEBYSHEV\nreupload_scaling = ReuploadScaling.TOWER\nif isinstance(param, Parameter):\nfparam = param\nfparam.trainable = False\nelse:\nfparam = FeatureParameter(param)\n# Set feature and target range\nfeature_range = _set_range(fm_type) if feature_range is None else feature_range\ntarget_range = _set_range(fm_type) if target_range is None else target_range\n# Rescale the feature parameter\nscaling = (max(target_range) - min(target_range)) / (max(feature_range) - min(feature_range))\nshift = min(target_range) - min(feature_range) * scaling\nif isclose(scaling, 1.0):\n# So we don't get 1.0 factor in visualization\nscaled_fparam = fparam + shift\nelse:\nscaled_fparam = scaling * fparam + shift\n# Transform feature parameter\nif fm_type == BasisSet.FOURIER:\ntransformed_feature = scaled_fparam\nelif fm_type == BasisSet.CHEBYSHEV:\ntransformed_feature = acos(scaled_fparam)\nelif inspect.isclass(fm_type) and issubclass(fm_type, Function):\ntransformed_feature = fm_type(scaled_fparam)\nelse:\nraise NotImplementedError(\nf\"Feature map type {fm_type} not implemented. Choose an item from the BasisSet \"\nf\"enum: {[bs.name for bs in BasisSet]}, or your own sympy.Function to wrap \"\n\"the given feature parameter with.\"\n)\nbasis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n# Set reupload scaling function\nif callable(reupload_scaling):\nrs_func = reupload_scaling\nrs_tag = \"Custom\"\nelse:\nrs_func = RS_FUNC_DICT.get(reupload_scaling, None)  # type: ignore [call-overload]\nif rs_func is None:\nraise NotImplementedError(\nf\"Reupload scaling {reupload_scaling} not implemented; choose an item from \"\nf\"the ReuploadScaling enum: {[rs.name for rs in ReuploadScaling]}, or your own \"\n\"python function with a single int arg as input and int or float output.\"\n)\nif isinstance(reupload_scaling, ReuploadScaling):\nrs_tag = reupload_scaling.value\nelse:\nrs_tag = reupload_scaling\n# Set overall multiplier\nmultiplier = 1 if multiplier is None else multiplier\n# Build feature map\nop_list = []\nfor i, qubit in enumerate(support):\nop_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\nfm = kron(*op_list)\nfm.tag = rs_tag + \" \" + basis_tag + \" FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\nFutureWarning,\n)\nfm = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=op,\nfm_type=BasisSet.CHEBYSHEV,\nreupload_scaling=ReuploadScaling.TOWER,\n)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers using step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers\n    using step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian with another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian\n    with another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"\n    Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments (see in the examples).</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments\n    (see in the examples).\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function. The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fea4c72a680&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fea4c728f70&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>. Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.data_to_model","title":"<code>data_to_model(xs, device='cpu')</code>","text":"<p>Default behavior for single-dispatched function</p> <p>Just return the given data independently on the type</p> PARAMETER  DESCRIPTION <code>xs</code> <p>the input data</p> <p> TYPE: <code>Any</code> </p> <code>device</code> <p>The torch device. Not used in this implementation.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>the <code>xs</code> argument untouched</p> <p> TYPE: <code>Any</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>@singledispatch\ndef data_to_model(xs: Any, device: str = \"cpu\") -&gt; Any:\n\"\"\"Default behavior for single-dispatched function\n    Just return the given data independently on the type\n    Args:\n        xs (Any): the input data\n        device (str, optional): The torch device. Not used in this implementation.\n    Returns:\n        Any: the `xs` argument untouched\n    \"\"\"\nreturn xs\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs, device='cpu')</code>","text":"<p>Default Torch optimize step with closure</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> <code>device</code> <p>The device were computations are executed. Defaults to \"cpu\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\ndevice: str = \"cpu\",\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n        device (str, optional): The device were computations are executed.\n            Defaults to \"cpu\".\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence.constructors import hamiltonian_factory, hea, feature_map\n    from qadence import chain, Parameter, QuantumCircuit, Z\n    from qadence.models import QNN\n    from qadence.ml_tools import train_with_grad, TrainConfig\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n        batch_size=batch_size,\n    )\n    batch_size = 25\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    train_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\nassert loss_fn is not None, \"Provide a valid loss function\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nif isinstance(dataloader, (list, tuple)):\nfrom qadence.ml_tools.data import to_dataloader\nassert len(dataloader) == 2, \"Please provide exactly two torch tensors.\"\nx, y = dataloader\ndataloader = to_dataloader(x=x, y=y, batch_size=config.batch_size)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, dataloader, device=device\n)\nloss = loss.item()\n# single epoch with DictDataloader using a single iteration method\n# DictDataloader returns a single sample of the data\n# with a given batch size decided when the dataloader is defined\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data, device=device)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\n# TODO: make sure to average metrics as well\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, data, device=device\n)\nrunning_loss += loss.item()\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nrunning_loss += loss\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> A block implementing the Hamiltonian evolution operation H where <p>H = exp(-iG, t)</p> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.2374-5.1225e-17j, -0.7288+3.0170e-17j],\n[ 1.1660-4.0583e-17j, -0.5995+2.0868e-17j]])\ntensor([[1.7414-1.2075j, 0.7742-1.1094j],\n[1.3634-0.3266j, 0.4083-0.2874j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation. Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation. Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=np.pi / 2)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names. This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['ff42cdcf-0980-4b1c-af57-de366ba575b2', 'ba431136-b929-4955-b641-713838314cdc'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code> to include two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters. Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"PARAMETER  DESCRIPTION <code>name</code> <p>When given a string only, the class constructs a trainable Parameter with a a randomly initialized value.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> </p> <code>**assumptions</code> <p>are passed on to the parent class <code>sympy.Symbol</code>. Two new assumption kwargs are supported by this constructor: <code>trainable: bool</code>, and <code>value: TNumber</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>from qadence import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.854665659675864\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = torch.rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> <code>values</code> <p>values dict which contains values for the Parameters, if empty, Parameter.value will be used.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>as_torch</code> <p>Whether to retrieve a torch-differentiable expression result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.013496193764961003\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn torch.Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: torch.tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[sympy.N(expr)], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>A QuantumCircuit instance is completely abstract and it needs to be passed to a quantum backend in order to be executed.</p> PARAMETER  DESCRIPTION <code>support</code> <p><code>Register</code> or number of qubits. If an integer is provided, a register is constructed with <code>Register.all_to_all(x)</code></p> <p> TYPE: <code>int | Register</code> </p> <code>*blocks</code> <p>(Possibly multiple) blocks to construct the circuit from.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n\"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\nreturn QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates (needed for e.g. analog computing). The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates (needed for e.g. analog\n    computing). The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('9583f94b-e3f7-4913-9cfe-d20a0911f86d', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9649102256983412'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('af97d45a-a501-4b99-af62-78450408f32d', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.855299175233669'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('98660c20-a41b-49ae-88d5-92c6b886d65d', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.4821242625372467'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8e054bcf-1f80-4ed5-8888-64900d6c7fef', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.7216139771883192'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a01b0c90-9b15-465e-85d7-c79a54c05ead', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5520005343296959'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7b4ce5d3-c870-4749-a1e4-5ab1e9d816b4', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.5128236248712018'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('cdeb342c-0eb3-46a2-9216-8a9d6a6963d9', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.7262773469971591'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('865a0fca-b2a4-467d-a18c-c2b996a1cb37', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9592730319839947'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('45a7ce0e-ee07-4d1e-bb87-785c94f597ee', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.29853362350562773'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0ad37e49-e3dc-41d1-a657-94b1ddd78228', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.8358036266838368'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('22ce082e-24d1-4372-b0c6-a3c5e4dfa105', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5395678859265043'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('89b4ae1a-5d99-43b4-b2fd-50b3df365cab', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>11011001\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.backend import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[0.3686-0.0605j, 0.2386+0.1186j, 0.0478+0.7804j, 0.0436-0.4199j]])\ntensor([[ 0.6429-0.6737j,  0.0000+0.0000j, -0.2516+0.2637j,  0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.backend import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = _run_state(_abstract_random_state(n_qubits, batch_size), backend)  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation. Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation. Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\ntry:\nreturn kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks, move the scale all the way down into the leaves of the block tree.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"When given a scaled CompositeBlock consisting of several PrimitiveBlocks,\n    move the scale all the way down into the leaves of the block tree.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks and reassigning qubit locations approriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks and reassigning\n    qubit locations approriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.emulate.add_interaction","title":"<code>add_interaction(x, *args, interaction=Interaction.NN, spacing=1.0)</code>","text":"<p>Turns blocks or circuits into (a chain of) <code>HamEvo</code> blocks including a chosen interaction term.</p> <p>This is a <code>@singledipatch</code>ed function which can be called in three ways:</p> <ul> <li>With a <code>QuantumCircuit</code> which contains all necessary information: <code>add_interaction(circuit)</code></li> <li>With a <code>Register</code> and an <code>AbstractBlock</code>: <code>add_interaction(reg, block)</code></li> <li>With an <code>AbstractBlock</code> only: <code>add_interaction(block)</code></li> </ul> <p>See the section about analog blocks for detailed information about how which types of blocks are translated.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit or block to be emulated. See the examples on which argument combinations are accepted.</p> <p> TYPE: <code>Register | QuantumCircuit | AbstractBlock</code> </p> <code>interaction</code> <p>Type of interaction that is added. Can also be a function that accepts a register and a list of edges that define which qubits interact (see the examples).</p> <p> TYPE: <code>Interaction | Callable</code> DEFAULT: <code>NN</code> </p> <code>spacing</code> <p>All qubit coordinates are multiplied by <code>spacing</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import QuantumCircuit, AnalogRX, add_interaction\nc = QuantumCircuit(2, AnalogRX(2.0))\ne = add_interaction(c)\n</code></pre> <pre><code>[mul: 0.0] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 AddBlock(0,1)\n\u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u251c\u2500\u2500 [mul: 1.571] \u2502       \u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u2502       \u251c\u2500\u2500 AddBlock(0)\n\u2502       \u2502       \u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502       \u2502   \u2502   \u2514\u2500\u2500 X(0)\n\u2502       \u2502       \u2502   \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502       \u2502       \u2514\u2500\u2500 Y(0)\n\u2502       \u2502       \u2514\u2500\u2500 AddBlock(1)\n\u2502       \u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502           \u2502   \u2514\u2500\u2500 X(1)\n\u2502       \u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502               \u2514\u2500\u2500 Y(1)\n\u2502       \u2514\u2500\u2500 [mul: 0.0] \u2502           \u2514\u2500\u2500 AddBlock(0,1)\n\u2502               \u251c\u2500\u2500 N(0)\n\u2502               \u2514\u2500\u2500 N(1)\n\u2514\u2500\u2500 AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 865723.020] \u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 N(0)\n\u2514\u2500\u2500 N(1)\n</code></pre>  You can also use <code>add_interaction</code> directly on a block, but you have to provide either the <code>Register</code> or define a non-global qubit support. <pre><code>from qadence import AnalogRX, Register, add_interaction\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b)\n# or provide only the block with local qubit support\n# in this case the register is created via `Register(b.n_qubits)`\ne = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\nprint(e.generator)\n</code></pre> <pre><code>[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n</code></pre>  You can specify a custom <code>interaction</code> function which has to accept a <code>Register</code> and a list of <code>edges: list[tuple[int, int]]</code>: <pre><code>from qadence import AnalogRX, Register, add_interaction\nfrom qadence.transpile.emulate import ising_interaction\ndef int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n# do either something completely custom\n# ...\n# or e.g. change the default kwargs to `ising_interaction`\nreturn ising_interaction(r, pairs, rydberg_level=70)\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b, interaction=int_fn)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/emulate.py</code> <pre><code>@singledispatch\ndef add_interaction(\nx: Register | QuantumCircuit | AbstractBlock,\n*args: Any,\ninteraction: Interaction | Callable = Interaction.NN,\nspacing: float = 1.0,\n) -&gt; QuantumCircuit | AbstractBlock:\n\"\"\"Turns blocks or circuits into (a chain of) `HamEvo` blocks including a\n    chosen interaction term.\n    This is a `@singledipatch`ed function which can be called in three ways:\n    * With a `QuantumCircuit` which contains all necessary information: `add_interaction(circuit)`\n    * With a `Register` and an `AbstractBlock`: `add_interaction(reg, block)`\n    * With an `AbstractBlock` only: `add_interaction(block)`\n    See the section about [analog blocks](/digital_analog_qc/analog-basics.md) for\n    detailed information about how which types of blocks are translated.\n    Arguments:\n        x: Circuit or block to be emulated. See the examples on which argument\n            combinations are accepted.\n        interaction: Type of interaction that is added. Can also be a function that accepts a\n            register and a list of edges that define which qubits interact (see the examples).\n        spacing: All qubit coordinates are multiplied by `spacing`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import QuantumCircuit, AnalogRX, add_interaction\n    c = QuantumCircuit(2, AnalogRX(2.0))\n    e = add_interaction(c)\n    print(str(e.block.generator)) # markdown-exec: hide\n    ```\n    You can also use `add_interaction` directly on a block, but you have to provide either\n    the `Register` or define a non-global qubit support.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b)\n    print(e.generator) # markdown-exec: hide\n    # or provide only the block with local qubit support\n    # in this case the register is created via `Register(b.n_qubits)`\n    e = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\n    print(e.generator)\n    ```\n    You can specify a custom `interaction` function which has to accept a `Register` and a list\n    of `edges: list[tuple[int, int]]`:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    from qadence.transpile.emulate import ising_interaction\n    def int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n        # do either something completely custom\n        # ...\n        # or e.g. change the default kwargs to `ising_interaction`\n        return ising_interaction(r, pairs, rydberg_level=70)\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b, interaction=int_fn)\n    ```\n    \"\"\"\nraise ValueError(f\"`add_interaction` is not implemented for {type(x)}\")\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, torch.Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[torch.Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, torch.Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in - <code>add_interaction</code>. - <code>hamiltonian_factory</code>.</p>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 17, '1000': 14, '0100': 11, '0010': 9, '0011': 6, '0110': 6, '1010': 5, '1011': 5, '1100': 5, '1110': 5, '0001': 4, '1101': 4, '1001': 3, '0101': 2, '0111': 2, '1111': 2})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: tensor([[0.3667],\n[0.2050],\n[0.3449],\n[0.0755],\n[0.3173],\n[0.2709],\n[0.0777],\n[0.0627],\n[0.0870],\n[0.0496]], grad_fn=&lt;CatBackward0&gt;)\nFirst-order derivative w.r.t. the feature parameter: tensor([-0.4283, -0.5675, -0.4635,  0.9309, -0.4996, -0.5424,  0.9636, -0.3908,\n-0.4656, -0.3263], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: tensor([-0.4283, -0.5675, -0.4635,  0.9309, -0.4996, -0.5424,  0.9636, -0.3908,\n-0.4656, -0.3263], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader\ndef dataloader() -&gt; DataLoader:\nbatch_size = 5\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\nreturn DataLoader(dataset, batch_size=batch_size)\ndef dictdataloader() -&gt; DictDataLoader:\nbatch_size = 5\nkeys = [\"y1\", \"y2\"]\ndls = {}\nfor k in keys:\nx = torch.rand(batch_size, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\ndataloader = DataLoader(dataset, batch_size=batch_size)\ndls[k] = dataloader\nreturn DictDataLoader(dls)\nn_epochs = 2\n# iterate standard DataLoader\ndl = dataloader()\nfor i in range(n_epochs):\ndata = next(iter(dl))\n# iterate DictDataLoader\nddl = dictdataloader()\nfor i in range(n_epochs):\ndata = next(iter(ddl))\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nimport matplotlib.pyplot as plt\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 50\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\nplt.plot(x.numpy(), y.numpy())\nplt.plot(x.numpy(), model(x).detach().numpy())\n</code></pre> 2023-11-05T22:47:23.075891 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-11-05T22:47:23.616742 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_097cc9343b6842d39a3d714064766f65 mixing cluster_58a617ff93d0405299662e6fc097ef6b mixing cluster_c7bf96f62ada45b9a4b4c4dc33883faa cost cluster_b9544e09ed1d47ab955ca748238cbc0f cost 8581631a41e1474d887c717af031fca7 0 dd2cbaa0528d407fb4ea52b19d595006 8581631a41e1474d887c717af031fca7--dd2cbaa0528d407fb4ea52b19d595006 89c5ede720d548148462d6ea96609b6d 1 20fb60be46bb40738a32c59ddf784fc2 dd2cbaa0528d407fb4ea52b19d595006--20fb60be46bb40738a32c59ddf784fc2 ffa70de2cab1441bbf81e524a433dfb5 20fb60be46bb40738a32c59ddf784fc2--ffa70de2cab1441bbf81e524a433dfb5 d0494cea58ae41ad8c17091afd0ef8bb ffa70de2cab1441bbf81e524a433dfb5--d0494cea58ae41ad8c17091afd0ef8bb 844872799e5c40308a1da19c635acb65 d0494cea58ae41ad8c17091afd0ef8bb--844872799e5c40308a1da19c635acb65 072d9732472c40ea8d88b541dc257337 844872799e5c40308a1da19c635acb65--072d9732472c40ea8d88b541dc257337 ce0d8f6a6b1d47e7abac01ca04bcbb02 072d9732472c40ea8d88b541dc257337--ce0d8f6a6b1d47e7abac01ca04bcbb02 41885a807b14468c9bfb236f1816b64e ce0d8f6a6b1d47e7abac01ca04bcbb02--41885a807b14468c9bfb236f1816b64e b80edeb66ae445bda129aaf19b15bd4e 41885a807b14468c9bfb236f1816b64e--b80edeb66ae445bda129aaf19b15bd4e 82a480ceec45494c9fc9edaf008be785 b80edeb66ae445bda129aaf19b15bd4e--82a480ceec45494c9fc9edaf008be785 c05e3dbf1c214adfa090b4b5b231d77c 82a480ceec45494c9fc9edaf008be785--c05e3dbf1c214adfa090b4b5b231d77c ab22e25199b44376a0d7b10e305a6886 c05e3dbf1c214adfa090b4b5b231d77c--ab22e25199b44376a0d7b10e305a6886 72b978b0a5474f558ae6a063be4db312 ab22e25199b44376a0d7b10e305a6886--72b978b0a5474f558ae6a063be4db312 30b79954b4c24c22bb0a666c09e52519 72b978b0a5474f558ae6a063be4db312--30b79954b4c24c22bb0a666c09e52519 369d2bdfb30a4970a7ddde4ca765b04b 30b79954b4c24c22bb0a666c09e52519--369d2bdfb30a4970a7ddde4ca765b04b d238e5de8da640009f69da11bd777df0 369d2bdfb30a4970a7ddde4ca765b04b--d238e5de8da640009f69da11bd777df0 871c25561a3c467e80ba97704a0945f3 d238e5de8da640009f69da11bd777df0--871c25561a3c467e80ba97704a0945f3 4cd64a0a2bd74d9e9c0ac34e99c942fe 871c25561a3c467e80ba97704a0945f3--4cd64a0a2bd74d9e9c0ac34e99c942fe c6110c637e394c6ba08be7183abc7908 4cd64a0a2bd74d9e9c0ac34e99c942fe--c6110c637e394c6ba08be7183abc7908 e09198f45efb44999a02d6f924b9ba09 c6110c637e394c6ba08be7183abc7908--e09198f45efb44999a02d6f924b9ba09 9d93ccd039da4fae83c6cae3b3ba112c e09198f45efb44999a02d6f924b9ba09--9d93ccd039da4fae83c6cae3b3ba112c ca1981cf239243098ff4df487f463514 9d93ccd039da4fae83c6cae3b3ba112c--ca1981cf239243098ff4df487f463514 af4f1c7d8f63419d94f45b290c2c3491 ca1981cf239243098ff4df487f463514--af4f1c7d8f63419d94f45b290c2c3491 22ebeb01186f48f1845f316b54621fff af4f1c7d8f63419d94f45b290c2c3491--22ebeb01186f48f1845f316b54621fff 92996792a6604ca7b73a0c86dc21dea4 22ebeb01186f48f1845f316b54621fff--92996792a6604ca7b73a0c86dc21dea4 86941ed3b6404c7fafa3aaa6522acf95 92996792a6604ca7b73a0c86dc21dea4--86941ed3b6404c7fafa3aaa6522acf95 bdd916f27768499c8d0f011171e9d5b7 86941ed3b6404c7fafa3aaa6522acf95--bdd916f27768499c8d0f011171e9d5b7 5a1e1502ec634e64a3359f50e9226cce bdd916f27768499c8d0f011171e9d5b7--5a1e1502ec634e64a3359f50e9226cce 89a71b437a21464597d6cc4b2064bbb7 5a1e1502ec634e64a3359f50e9226cce--89a71b437a21464597d6cc4b2064bbb7 2639e25d5c3a41588a267adaa588d4a6 89a71b437a21464597d6cc4b2064bbb7--2639e25d5c3a41588a267adaa588d4a6 ce32aa9fd53c484b838a98c76365e7fb 2639e25d5c3a41588a267adaa588d4a6--ce32aa9fd53c484b838a98c76365e7fb 8d2657b5c3b643679dff9a2ec58f8e56 ce32aa9fd53c484b838a98c76365e7fb--8d2657b5c3b643679dff9a2ec58f8e56 bc10e059cfc94ce38f872b609e5863b7 8d2657b5c3b643679dff9a2ec58f8e56--bc10e059cfc94ce38f872b609e5863b7 b45eb1d93c66462085111e1373582d9a bc10e059cfc94ce38f872b609e5863b7--b45eb1d93c66462085111e1373582d9a 6c4ee155f70f4ff59af736660e2e0599 b45eb1d93c66462085111e1373582d9a--6c4ee155f70f4ff59af736660e2e0599 32fc60a32d9944ae886d1f2b7327ab06 6c4ee155f70f4ff59af736660e2e0599--32fc60a32d9944ae886d1f2b7327ab06 6f5ba9ac0feb420ba631e7eb52817647 32fc60a32d9944ae886d1f2b7327ab06--6f5ba9ac0feb420ba631e7eb52817647 e5e96cd897414459818f184271c30660 6f5ba9ac0feb420ba631e7eb52817647--e5e96cd897414459818f184271c30660 7f3717e4184a4a9290aa7b98be02f9cf e5e96cd897414459818f184271c30660--7f3717e4184a4a9290aa7b98be02f9cf a7a266ff25624f91a48e87259edbdb2c 7f3717e4184a4a9290aa7b98be02f9cf--a7a266ff25624f91a48e87259edbdb2c e704f0e314984364845336a2ca022a5c a7a266ff25624f91a48e87259edbdb2c--e704f0e314984364845336a2ca022a5c dc53d73d063c4ae0956921c6ecfdd626 e704f0e314984364845336a2ca022a5c--dc53d73d063c4ae0956921c6ecfdd626 83ccbaf991df421e99b25c85cd0ed1d6 dc53d73d063c4ae0956921c6ecfdd626--83ccbaf991df421e99b25c85cd0ed1d6 12fda5b955924e16b212a670b4dcb0d1 83ccbaf991df421e99b25c85cd0ed1d6--12fda5b955924e16b212a670b4dcb0d1 8c68b1aaf6ee458e8a69803081fbba72 12fda5b955924e16b212a670b4dcb0d1--8c68b1aaf6ee458e8a69803081fbba72 ae6ed8f2e59d40f19b79b58da83b0676 8c68b1aaf6ee458e8a69803081fbba72--ae6ed8f2e59d40f19b79b58da83b0676 188068f3a9e6499faeb9798518880bce ae6ed8f2e59d40f19b79b58da83b0676--188068f3a9e6499faeb9798518880bce fea0ae38fb8c4a03b60af37a0efb5b67 188068f3a9e6499faeb9798518880bce--fea0ae38fb8c4a03b60af37a0efb5b67 d370167369424c928c1e8c2a25894f70 fea0ae38fb8c4a03b60af37a0efb5b67--d370167369424c928c1e8c2a25894f70 d2abd53545204ecfbb0bb111bfdaa262 d370167369424c928c1e8c2a25894f70--d2abd53545204ecfbb0bb111bfdaa262 c92a1287bbe34b9faec166b0e008f21b d2abd53545204ecfbb0bb111bfdaa262--c92a1287bbe34b9faec166b0e008f21b c4cea85650564a19bdd79b4b6b3bbe9b c92a1287bbe34b9faec166b0e008f21b--c4cea85650564a19bdd79b4b6b3bbe9b 51be2881c9894494908c357bfb8d1965 c4cea85650564a19bdd79b4b6b3bbe9b--51be2881c9894494908c357bfb8d1965 2b791f2388f544e48ca380eef4858588 51be2881c9894494908c357bfb8d1965--2b791f2388f544e48ca380eef4858588 6fb5fff8034c4d4eb243c15a33d3a742 2b791f2388f544e48ca380eef4858588--6fb5fff8034c4d4eb243c15a33d3a742 e3afc453d6ab458ca895667b491fe8cd 6fb5fff8034c4d4eb243c15a33d3a742--e3afc453d6ab458ca895667b491fe8cd f3ea370b57bd4cb499a7a8232f448d2b e3afc453d6ab458ca895667b491fe8cd--f3ea370b57bd4cb499a7a8232f448d2b 94fe5bb1c06a49838f244c68af9fe197 f3ea370b57bd4cb499a7a8232f448d2b--94fe5bb1c06a49838f244c68af9fe197 58302e2eacc041d8ab0fb2de2d0e8b03 94fe5bb1c06a49838f244c68af9fe197--58302e2eacc041d8ab0fb2de2d0e8b03 7ad058a029a8486c9b46bd2efff79ce4 58302e2eacc041d8ab0fb2de2d0e8b03--7ad058a029a8486c9b46bd2efff79ce4 122bb2c410244c4f9be2a7dc8efe36c9 7ad058a029a8486c9b46bd2efff79ce4--122bb2c410244c4f9be2a7dc8efe36c9 5068e9dd59364d1baed731592e5b45d5 122bb2c410244c4f9be2a7dc8efe36c9--5068e9dd59364d1baed731592e5b45d5 7fdfdea8e3d24952a456a7f0321535bb 5068e9dd59364d1baed731592e5b45d5--7fdfdea8e3d24952a456a7f0321535bb be96981a25b2415ca7497e53c850454d 7fdfdea8e3d24952a456a7f0321535bb--be96981a25b2415ca7497e53c850454d 9b99071ab51041549fc38750a2496aa0 be96981a25b2415ca7497e53c850454d--9b99071ab51041549fc38750a2496aa0 2cbce0198ce244bca5deba8103ccf3cf 9b99071ab51041549fc38750a2496aa0--2cbce0198ce244bca5deba8103ccf3cf 75e968725baa45f28a6fb64370b4bd4b 2cbce0198ce244bca5deba8103ccf3cf--75e968725baa45f28a6fb64370b4bd4b 1236f6b38c7e4b5fa12b78e0b68f0c6f 75e968725baa45f28a6fb64370b4bd4b--1236f6b38c7e4b5fa12b78e0b68f0c6f 8910fb59ece94225840a3c6dc4706a4e 1236f6b38c7e4b5fa12b78e0b68f0c6f--8910fb59ece94225840a3c6dc4706a4e 7a56e8b7700441fdbbe264044272fe60 8910fb59ece94225840a3c6dc4706a4e--7a56e8b7700441fdbbe264044272fe60 0fd1da04bce544c58cd3d5e178b8bd29 7a56e8b7700441fdbbe264044272fe60--0fd1da04bce544c58cd3d5e178b8bd29 8f776317c2114c88af74513557231394 0fd1da04bce544c58cd3d5e178b8bd29--8f776317c2114c88af74513557231394 70fa30af10a244879c1f87faa26c2891 8f776317c2114c88af74513557231394--70fa30af10a244879c1f87faa26c2891 281c417f77f14b78827a07d305ae487a 70fa30af10a244879c1f87faa26c2891--281c417f77f14b78827a07d305ae487a e45d448f2d0f4db19e2faf2968a1c40e 281c417f77f14b78827a07d305ae487a--e45d448f2d0f4db19e2faf2968a1c40e ec9cf6531a05407d89551f0c0c4dfae8 e45d448f2d0f4db19e2faf2968a1c40e--ec9cf6531a05407d89551f0c0c4dfae8 afab8e8dbb334060890cb29875ae113d ec9cf6531a05407d89551f0c0c4dfae8--afab8e8dbb334060890cb29875ae113d 9d3981ee8fc14a66b14d11f508a7fcb6 afab8e8dbb334060890cb29875ae113d--9d3981ee8fc14a66b14d11f508a7fcb6 cfeb166bc259437cb27df528aa24385c 9d3981ee8fc14a66b14d11f508a7fcb6--cfeb166bc259437cb27df528aa24385c 4e1acf79cbb44e258a738dd5834ce069 cfeb166bc259437cb27df528aa24385c--4e1acf79cbb44e258a738dd5834ce069 bf8201baa7404e7fb9d4d9efa12241f0 4e1acf79cbb44e258a738dd5834ce069--bf8201baa7404e7fb9d4d9efa12241f0 7888fce0126a45c5b7d36a4a1b52ae68 bf8201baa7404e7fb9d4d9efa12241f0--7888fce0126a45c5b7d36a4a1b52ae68 0bb2e5b387484a048a08d3b547938c77 7888fce0126a45c5b7d36a4a1b52ae68--0bb2e5b387484a048a08d3b547938c77 e91bf2b1b9cd4fee9d11d8fa245e40a6 0bb2e5b387484a048a08d3b547938c77--e91bf2b1b9cd4fee9d11d8fa245e40a6 c2e1883f9f4547fab508b61964cc8b33 e91bf2b1b9cd4fee9d11d8fa245e40a6--c2e1883f9f4547fab508b61964cc8b33 5c3a52e599844d038c0397ff910ff25d c2e1883f9f4547fab508b61964cc8b33--5c3a52e599844d038c0397ff910ff25d 6f40784a8cd0426ab72f67c996878733 5c3a52e599844d038c0397ff910ff25d--6f40784a8cd0426ab72f67c996878733 74c27ab3c30c4e44bf932280a777e57a 6f40784a8cd0426ab72f67c996878733--74c27ab3c30c4e44bf932280a777e57a 9676866d068644669bd11c995a718933 74c27ab3c30c4e44bf932280a777e57a--9676866d068644669bd11c995a718933 8f62f4b103a647908ac0d6baca5687dd 9676866d068644669bd11c995a718933--8f62f4b103a647908ac0d6baca5687dd 9f1dc79a689d492d8708b3b8a4df0bf4 8f62f4b103a647908ac0d6baca5687dd--9f1dc79a689d492d8708b3b8a4df0bf4 7af6341a4fbf4c69bc0f128b228df539 9f1dc79a689d492d8708b3b8a4df0bf4--7af6341a4fbf4c69bc0f128b228df539 edf95fb8247b4f33ac3fb66caf4b5733 7af6341a4fbf4c69bc0f128b228df539--edf95fb8247b4f33ac3fb66caf4b5733 304a302292184bed92091566cc8c4097 edf95fb8247b4f33ac3fb66caf4b5733--304a302292184bed92091566cc8c4097 b398571093b64b259854da3354ee79ad 304a302292184bed92091566cc8c4097--b398571093b64b259854da3354ee79ad 15a046d98714422fb690aff1b271daa2 b398571093b64b259854da3354ee79ad--15a046d98714422fb690aff1b271daa2 dce4019af3eb4f96a713a4665ba5eeaa 15a046d98714422fb690aff1b271daa2--dce4019af3eb4f96a713a4665ba5eeaa 09c397934099469ebe27c9d149627dea dce4019af3eb4f96a713a4665ba5eeaa--09c397934099469ebe27c9d149627dea ffe01d8f483c47619b1f3bb651d1cc01 09c397934099469ebe27c9d149627dea--ffe01d8f483c47619b1f3bb651d1cc01 bc8f64a56f624420a11bb7ed5a93ec94 ffe01d8f483c47619b1f3bb651d1cc01--bc8f64a56f624420a11bb7ed5a93ec94 3496511c55fb4beb9af639f528786d40 bc8f64a56f624420a11bb7ed5a93ec94--3496511c55fb4beb9af639f528786d40 54249a60cdfb41da83d638e3c790c064 3496511c55fb4beb9af639f528786d40--54249a60cdfb41da83d638e3c790c064 7b8121b2f55d49969e866b3d03f2860a 54249a60cdfb41da83d638e3c790c064--7b8121b2f55d49969e866b3d03f2860a 74ab139666d44130b3c8f7a5484361f0 7b8121b2f55d49969e866b3d03f2860a--74ab139666d44130b3c8f7a5484361f0 3052e68c9d654a99914bfc420ea5560d 74ab139666d44130b3c8f7a5484361f0--3052e68c9d654a99914bfc420ea5560d 5b00994c257d49ebaae849c6d41b339b 3052e68c9d654a99914bfc420ea5560d--5b00994c257d49ebaae849c6d41b339b bfa412c217c943f99e00683333ace739 5b00994c257d49ebaae849c6d41b339b--bfa412c217c943f99e00683333ace739 756c280a13754432bfef83685772ec97 bfa412c217c943f99e00683333ace739--756c280a13754432bfef83685772ec97 e74b1872db6943aba7ad319cc6947cf2 756c280a13754432bfef83685772ec97--e74b1872db6943aba7ad319cc6947cf2 aeea944696544ed19f173344f25fd940 e74b1872db6943aba7ad319cc6947cf2--aeea944696544ed19f173344f25fd940 bb53c83d8e944e1a9f1143871a0612cd aeea944696544ed19f173344f25fd940--bb53c83d8e944e1a9f1143871a0612cd b1e2887ec91e47cab0c4df3a9dd3f33d bb53c83d8e944e1a9f1143871a0612cd--b1e2887ec91e47cab0c4df3a9dd3f33d 5a7bde2299004fea8a4d7a3a17697d56 RX(b00) b1e2887ec91e47cab0c4df3a9dd3f33d--5a7bde2299004fea8a4d7a3a17697d56 b8766ddf1a5944d48209b549dc0d2dfe 5a7bde2299004fea8a4d7a3a17697d56--b8766ddf1a5944d48209b549dc0d2dfe 6161357b1ca64510adbeff0a81bddbf9 b8766ddf1a5944d48209b549dc0d2dfe--6161357b1ca64510adbeff0a81bddbf9 39aca8657f80477e94d71bfc6f42fb32 6161357b1ca64510adbeff0a81bddbf9--39aca8657f80477e94d71bfc6f42fb32 cc9a97c001794833af1b56463165bb43 39aca8657f80477e94d71bfc6f42fb32--cc9a97c001794833af1b56463165bb43 684ac84d676e47de8bbcf08868133e7b cc9a97c001794833af1b56463165bb43--684ac84d676e47de8bbcf08868133e7b fe09263effdc4fc4a194875251d4adc0 684ac84d676e47de8bbcf08868133e7b--fe09263effdc4fc4a194875251d4adc0 1aeeca70d6b440f793db7b42edcec839 fe09263effdc4fc4a194875251d4adc0--1aeeca70d6b440f793db7b42edcec839 b74c2878adf744d19538bac4e38523e0 1aeeca70d6b440f793db7b42edcec839--b74c2878adf744d19538bac4e38523e0 98c74195cdad40d79018c91e6cffe898 b74c2878adf744d19538bac4e38523e0--98c74195cdad40d79018c91e6cffe898 bf57061ca84441759659d8979e7a7b4a 98c74195cdad40d79018c91e6cffe898--bf57061ca84441759659d8979e7a7b4a 6e4a8f12d19b43ad8c7bc9f911926a4f bf57061ca84441759659d8979e7a7b4a--6e4a8f12d19b43ad8c7bc9f911926a4f a62d798227ed47689ac2ee7dac556c53 6e4a8f12d19b43ad8c7bc9f911926a4f--a62d798227ed47689ac2ee7dac556c53 93144e037fa347cfbd22db9fd2676898 a62d798227ed47689ac2ee7dac556c53--93144e037fa347cfbd22db9fd2676898 b9ef22f40b214af598ba22e74cd382bc 93144e037fa347cfbd22db9fd2676898--b9ef22f40b214af598ba22e74cd382bc dd087180054a4ce8bd418e4f521a4373 b9ef22f40b214af598ba22e74cd382bc--dd087180054a4ce8bd418e4f521a4373 122e7a6920504741b440a8f398210c0e dd087180054a4ce8bd418e4f521a4373--122e7a6920504741b440a8f398210c0e 03de355447f74237a096131ee27dcbf5 122e7a6920504741b440a8f398210c0e--03de355447f74237a096131ee27dcbf5 36779e9608fb4178b392c4e0b24b499a 03de355447f74237a096131ee27dcbf5--36779e9608fb4178b392c4e0b24b499a 09ce63f95bb44a07ad53efe960a9ce15 36779e9608fb4178b392c4e0b24b499a--09ce63f95bb44a07ad53efe960a9ce15 e9f9ee298c1c4f1dab54b9d38e48625a 09ce63f95bb44a07ad53efe960a9ce15--e9f9ee298c1c4f1dab54b9d38e48625a faafa6dbd3d140f99b01068248b03ef2 e9f9ee298c1c4f1dab54b9d38e48625a--faafa6dbd3d140f99b01068248b03ef2 a1ce5ee7e3cb47339c3d4269e08fa379 faafa6dbd3d140f99b01068248b03ef2--a1ce5ee7e3cb47339c3d4269e08fa379 1cff78b106224222984f66fa6ddee983 a1ce5ee7e3cb47339c3d4269e08fa379--1cff78b106224222984f66fa6ddee983 ab967aab973e419cac7b6b98613905e5 1cff78b106224222984f66fa6ddee983--ab967aab973e419cac7b6b98613905e5 3a0aeed6c2994764bcaa7ef226cb6206 ab967aab973e419cac7b6b98613905e5--3a0aeed6c2994764bcaa7ef226cb6206 7231348fc3f64ccda93fa9593cce4ff0 3a0aeed6c2994764bcaa7ef226cb6206--7231348fc3f64ccda93fa9593cce4ff0 2a309935bd3040d6869a91b2fa033ca6 7231348fc3f64ccda93fa9593cce4ff0--2a309935bd3040d6869a91b2fa033ca6 b6a06a4e086f4eddbdff0509d5b1d642 2a309935bd3040d6869a91b2fa033ca6--b6a06a4e086f4eddbdff0509d5b1d642 813a18381be54906b9d1712e8c46853e b6a06a4e086f4eddbdff0509d5b1d642--813a18381be54906b9d1712e8c46853e 8bd8e429722d43b9a16a6bc5172b8946 813a18381be54906b9d1712e8c46853e--8bd8e429722d43b9a16a6bc5172b8946 ca6b936364074946854a1128be47be79 8bd8e429722d43b9a16a6bc5172b8946--ca6b936364074946854a1128be47be79 bc72f826c232496099e3a5504ee39b90 ca6b936364074946854a1128be47be79--bc72f826c232496099e3a5504ee39b90 1b231be5a9504167872fd2d3e71384a0 bc72f826c232496099e3a5504ee39b90--1b231be5a9504167872fd2d3e71384a0 7f8ed56d2c4147db903fe82ca59d3bb7 1b231be5a9504167872fd2d3e71384a0--7f8ed56d2c4147db903fe82ca59d3bb7 fe14264c05f641e0a5dd02bfa42eb0f0 7f8ed56d2c4147db903fe82ca59d3bb7--fe14264c05f641e0a5dd02bfa42eb0f0 157b9a1f326c4a43bca0d9594e3861bc fe14264c05f641e0a5dd02bfa42eb0f0--157b9a1f326c4a43bca0d9594e3861bc 4873544384ca44ab93f42ab9aa855a0e 157b9a1f326c4a43bca0d9594e3861bc--4873544384ca44ab93f42ab9aa855a0e 969bc084cd464711a479e0828a57bd85 4873544384ca44ab93f42ab9aa855a0e--969bc084cd464711a479e0828a57bd85 c2bcf87a2e9549c89e52c9085f2e76dd 969bc084cd464711a479e0828a57bd85--c2bcf87a2e9549c89e52c9085f2e76dd 6a87b35709b84c03aa9ef6926c033c07 c2bcf87a2e9549c89e52c9085f2e76dd--6a87b35709b84c03aa9ef6926c033c07 a55acea3afa744e1b6eeef4aa23e51e4 6a87b35709b84c03aa9ef6926c033c07--a55acea3afa744e1b6eeef4aa23e51e4 1f6fcaf4ab5d49dd9b321d9b25c3f075 a55acea3afa744e1b6eeef4aa23e51e4--1f6fcaf4ab5d49dd9b321d9b25c3f075 7a14a5168e974940bad641c6ef91cfdf 1f6fcaf4ab5d49dd9b321d9b25c3f075--7a14a5168e974940bad641c6ef91cfdf bbf6dba9d7224e27940adfca4b23edfc 7a14a5168e974940bad641c6ef91cfdf--bbf6dba9d7224e27940adfca4b23edfc 0c18e150828d4cf383648da00bac175a bbf6dba9d7224e27940adfca4b23edfc--0c18e150828d4cf383648da00bac175a 736167a9d2e14f109048cf75841b7f13 0c18e150828d4cf383648da00bac175a--736167a9d2e14f109048cf75841b7f13 521b6454f1c9486fbd303c38f128c04f 736167a9d2e14f109048cf75841b7f13--521b6454f1c9486fbd303c38f128c04f a201906dbb61441780a08a14822c20b6 521b6454f1c9486fbd303c38f128c04f--a201906dbb61441780a08a14822c20b6 c165b7b9c5724d78b3771e24a033d622 a201906dbb61441780a08a14822c20b6--c165b7b9c5724d78b3771e24a033d622 b4577f43302c41b4970c0bc744f3e032 c165b7b9c5724d78b3771e24a033d622--b4577f43302c41b4970c0bc744f3e032 436bc2f912154ba79772b066477fe750 b4577f43302c41b4970c0bc744f3e032--436bc2f912154ba79772b066477fe750 0626d607f0794ff9a9237c13ae7237e4 436bc2f912154ba79772b066477fe750--0626d607f0794ff9a9237c13ae7237e4 61501d93614c4281ae799bf7d107d45d 0626d607f0794ff9a9237c13ae7237e4--61501d93614c4281ae799bf7d107d45d 2e92369f3f284e2ca5a69e13bf5646e7 61501d93614c4281ae799bf7d107d45d--2e92369f3f284e2ca5a69e13bf5646e7 a8266144d1354f9087affc491414acf8 2e92369f3f284e2ca5a69e13bf5646e7--a8266144d1354f9087affc491414acf8 67383c4aadd248d7a09993a3471ecd0e a8266144d1354f9087affc491414acf8--67383c4aadd248d7a09993a3471ecd0e bb1846e121214327b094cc4f948befa0 67383c4aadd248d7a09993a3471ecd0e--bb1846e121214327b094cc4f948befa0 0bbec5223e264200bab8f4dbf804531a bb1846e121214327b094cc4f948befa0--0bbec5223e264200bab8f4dbf804531a 5de4c64056e34c9f8e977bffa811e1c8 0bbec5223e264200bab8f4dbf804531a--5de4c64056e34c9f8e977bffa811e1c8 989ffc20b09848e1921c5c26eb361450 5de4c64056e34c9f8e977bffa811e1c8--989ffc20b09848e1921c5c26eb361450 9e3d06c9ca914b9ead9132fc1de67f79 989ffc20b09848e1921c5c26eb361450--9e3d06c9ca914b9ead9132fc1de67f79 250cebd60081428c868998b94529c587 9e3d06c9ca914b9ead9132fc1de67f79--250cebd60081428c868998b94529c587 292f278fa9ee42a9848a6c60c3567764 250cebd60081428c868998b94529c587--292f278fa9ee42a9848a6c60c3567764 ed622cec363146b69cb80850f176951b 292f278fa9ee42a9848a6c60c3567764--ed622cec363146b69cb80850f176951b f829721589f44b44b847e71aab499a71 ed622cec363146b69cb80850f176951b--f829721589f44b44b847e71aab499a71 2c9b038eceaa45c3bcb2e3db8c62827a f829721589f44b44b847e71aab499a71--2c9b038eceaa45c3bcb2e3db8c62827a 46cfc181654d4a1bbe8be24665b15670 2c9b038eceaa45c3bcb2e3db8c62827a--46cfc181654d4a1bbe8be24665b15670 640f1426578541c09a77d9fc12bdda30 46cfc181654d4a1bbe8be24665b15670--640f1426578541c09a77d9fc12bdda30 f395f8207bf64cb3b0215c50c8638acf 640f1426578541c09a77d9fc12bdda30--f395f8207bf64cb3b0215c50c8638acf bb1e49660395476e99ec193c61bc7e07 f395f8207bf64cb3b0215c50c8638acf--bb1e49660395476e99ec193c61bc7e07 3fe68801729a47bc9c5783d730f94ba7 bb1e49660395476e99ec193c61bc7e07--3fe68801729a47bc9c5783d730f94ba7 6d24c5f644f74fd5be232ee7d96c1023 3fe68801729a47bc9c5783d730f94ba7--6d24c5f644f74fd5be232ee7d96c1023 f92f2c406bef4dbf8ec0564eb3a6c886 6d24c5f644f74fd5be232ee7d96c1023--f92f2c406bef4dbf8ec0564eb3a6c886 896b89f157394b84bdff55b8578e1f2c f92f2c406bef4dbf8ec0564eb3a6c886--896b89f157394b84bdff55b8578e1f2c c441939d5f0a4c7a8ac869e3c828a121 896b89f157394b84bdff55b8578e1f2c--c441939d5f0a4c7a8ac869e3c828a121 94c7f59edcc347b6bdf2b0993b5f0b74 c441939d5f0a4c7a8ac869e3c828a121--94c7f59edcc347b6bdf2b0993b5f0b74 a5a1200a59ec4879989fa9621b6f30a6 94c7f59edcc347b6bdf2b0993b5f0b74--a5a1200a59ec4879989fa9621b6f30a6 878da98235a04c7cbe8138e0a2a02863 a5a1200a59ec4879989fa9621b6f30a6--878da98235a04c7cbe8138e0a2a02863 6a7338c6d93e4a5696c27d466be197e9 878da98235a04c7cbe8138e0a2a02863--6a7338c6d93e4a5696c27d466be197e9 1ed6db681853452b8de64d73d3559540 6a7338c6d93e4a5696c27d466be197e9--1ed6db681853452b8de64d73d3559540 6f5113bd6b57462ea5b57f398671516f 1ed6db681853452b8de64d73d3559540--6f5113bd6b57462ea5b57f398671516f 45040f3818de4f49b5e251835e5b83cf 6f5113bd6b57462ea5b57f398671516f--45040f3818de4f49b5e251835e5b83cf b7bd775e7c4a4482a96202b3890c9113 45040f3818de4f49b5e251835e5b83cf--b7bd775e7c4a4482a96202b3890c9113 bf382697855c4657bdfe08c134a81356 b7bd775e7c4a4482a96202b3890c9113--bf382697855c4657bdfe08c134a81356 79b1a0bfd25a48b5b8a9d2803d3cd733 bf382697855c4657bdfe08c134a81356--79b1a0bfd25a48b5b8a9d2803d3cd733 89ebb764e41246f19beee80d13375e92 79b1a0bfd25a48b5b8a9d2803d3cd733--89ebb764e41246f19beee80d13375e92 7577bddb0b4b421182ea6480fcf72dd6 89ebb764e41246f19beee80d13375e92--7577bddb0b4b421182ea6480fcf72dd6 1277d470255446fb8cc6a9629d209355 7577bddb0b4b421182ea6480fcf72dd6--1277d470255446fb8cc6a9629d209355 1fd2bcfd270541699df808239748864b 1277d470255446fb8cc6a9629d209355--1fd2bcfd270541699df808239748864b dc8b667dca6645f88627bb566fcc18ab 1fd2bcfd270541699df808239748864b--dc8b667dca6645f88627bb566fcc18ab d64018162ac04b24877b948d7dc1678f dc8b667dca6645f88627bb566fcc18ab--d64018162ac04b24877b948d7dc1678f ac870e2f9be44e339db301d70ac53983 d64018162ac04b24877b948d7dc1678f--ac870e2f9be44e339db301d70ac53983 efc317feb8234fdcbb7bcd16511095d0 ac870e2f9be44e339db301d70ac53983--efc317feb8234fdcbb7bcd16511095d0 0fcf25e6bf15421aba561cb94168e85f efc317feb8234fdcbb7bcd16511095d0--0fcf25e6bf15421aba561cb94168e85f b801fb6121b646b5b5a97c9c9e1d3f3f 0fcf25e6bf15421aba561cb94168e85f--b801fb6121b646b5b5a97c9c9e1d3f3f 9a782afa248e473f907878928a3dcfb9 b801fb6121b646b5b5a97c9c9e1d3f3f--9a782afa248e473f907878928a3dcfb9 6f55656ace6f45579a833fc2022e1987 9a782afa248e473f907878928a3dcfb9--6f55656ace6f45579a833fc2022e1987 6d247869f57d450ca1190168f8d91666 6f55656ace6f45579a833fc2022e1987--6d247869f57d450ca1190168f8d91666 7b06a5c8873f44c3bbe80e2bd013d4da 6d247869f57d450ca1190168f8d91666--7b06a5c8873f44c3bbe80e2bd013d4da ddc656bbdd4a4e1ea4427033eb66ad97 7b06a5c8873f44c3bbe80e2bd013d4da--ddc656bbdd4a4e1ea4427033eb66ad97 c625ff66cf3a48529e615e03040ec62b ddc656bbdd4a4e1ea4427033eb66ad97--c625ff66cf3a48529e615e03040ec62b e99bbc86a77e4910aedd33ff779f62f4 c625ff66cf3a48529e615e03040ec62b--e99bbc86a77e4910aedd33ff779f62f4 ca520119e4aa4546b96c8991c2f2a691 e99bbc86a77e4910aedd33ff779f62f4--ca520119e4aa4546b96c8991c2f2a691 96a192ae9bc3483c8249c19860f72a01 ca520119e4aa4546b96c8991c2f2a691--96a192ae9bc3483c8249c19860f72a01 5f2d5dc1239f4c50aa1cb80992065345 96a192ae9bc3483c8249c19860f72a01--5f2d5dc1239f4c50aa1cb80992065345 17947081f8c443069d32c5e80d7f7c7e 5f2d5dc1239f4c50aa1cb80992065345--17947081f8c443069d32c5e80d7f7c7e 97b73d21129642a08d7083338aefec1a 17947081f8c443069d32c5e80d7f7c7e--97b73d21129642a08d7083338aefec1a e199e448af4b4e948b47e95fe7072a6b 97b73d21129642a08d7083338aefec1a--e199e448af4b4e948b47e95fe7072a6b 8a5b437470d24f6ebea444dd4db8b23a e199e448af4b4e948b47e95fe7072a6b--8a5b437470d24f6ebea444dd4db8b23a 78bed5af9b5040e9a84dffeee7fc2810 8a5b437470d24f6ebea444dd4db8b23a--78bed5af9b5040e9a84dffeee7fc2810 6d917020766f4db888a8d835c0e39dc6 78bed5af9b5040e9a84dffeee7fc2810--6d917020766f4db888a8d835c0e39dc6 1509cf7a67624ae8880224758a14ba59 6d917020766f4db888a8d835c0e39dc6--1509cf7a67624ae8880224758a14ba59 50ec7948acae463ca4f1b2171543526d RX(b10) 1509cf7a67624ae8880224758a14ba59--50ec7948acae463ca4f1b2171543526d 6b3c92729c9544edaa4615abece655b0 50ec7948acae463ca4f1b2171543526d--6b3c92729c9544edaa4615abece655b0 399c28bcf17242a4b6c1db08bd692c2c 062959c1da1f4bbcac0e33dc7ac4e766 X 89c5ede720d548148462d6ea96609b6d--062959c1da1f4bbcac0e33dc7ac4e766 b89ab0699b0f442b9b5e7759733cdedc 2 062959c1da1f4bbcac0e33dc7ac4e766--dd2cbaa0528d407fb4ea52b19d595006 f9e5ddcea9e745e987489713046afcb6 062959c1da1f4bbcac0e33dc7ac4e766--f9e5ddcea9e745e987489713046afcb6 42a2e2d9d5eb446eb47808b7236fe28f f9e5ddcea9e745e987489713046afcb6--42a2e2d9d5eb446eb47808b7236fe28f 67abfe1505b74e56a4166c48dd0379d9 42a2e2d9d5eb446eb47808b7236fe28f--67abfe1505b74e56a4166c48dd0379d9 4ab89bf834534ee6b987a1af52999b40 67abfe1505b74e56a4166c48dd0379d9--4ab89bf834534ee6b987a1af52999b40 264ac6a6374e42beafe9dc451539befd 4ab89bf834534ee6b987a1af52999b40--264ac6a6374e42beafe9dc451539befd ccd4daa401e248668373c7bd685b9169 264ac6a6374e42beafe9dc451539befd--ccd4daa401e248668373c7bd685b9169 cc8d74c07cba42f1913b8cd30f92cf45 ccd4daa401e248668373c7bd685b9169--cc8d74c07cba42f1913b8cd30f92cf45 5e6fa03cff124cbabfa5617f402e4e77 cc8d74c07cba42f1913b8cd30f92cf45--5e6fa03cff124cbabfa5617f402e4e77 41813ef9b4344db4adbc22717dafbc41 5e6fa03cff124cbabfa5617f402e4e77--41813ef9b4344db4adbc22717dafbc41 8e21e48a55d04bbb8b3ea23889921c70 41813ef9b4344db4adbc22717dafbc41--8e21e48a55d04bbb8b3ea23889921c70 e8b1f015db894bb99157ae44ee8a416a 8e21e48a55d04bbb8b3ea23889921c70--e8b1f015db894bb99157ae44ee8a416a 82b671368a324a318bda74490d49de7e e8b1f015db894bb99157ae44ee8a416a--82b671368a324a318bda74490d49de7e e3671b72a53747999484ad7a5d755fe7 82b671368a324a318bda74490d49de7e--e3671b72a53747999484ad7a5d755fe7 3e3fe67fdabf490696d1ca9e2bedbf97 X e3671b72a53747999484ad7a5d755fe7--3e3fe67fdabf490696d1ca9e2bedbf97 3e3fe67fdabf490696d1ca9e2bedbf97--369d2bdfb30a4970a7ddde4ca765b04b 816fe776fb81460cab499c115bac0199 X 3e3fe67fdabf490696d1ca9e2bedbf97--816fe776fb81460cab499c115bac0199 816fe776fb81460cab499c115bac0199--d238e5de8da640009f69da11bd777df0 54f56b6deec64e99a9891fc05efef61b RZ(-1.0*g0) 816fe776fb81460cab499c115bac0199--54f56b6deec64e99a9891fc05efef61b 33fd510582e546d9a12a90241f1df033 X 54f56b6deec64e99a9891fc05efef61b--33fd510582e546d9a12a90241f1df033 33fd510582e546d9a12a90241f1df033--4cd64a0a2bd74d9e9c0ac34e99c942fe 362f29b10ac64f36a4a5585ea79bdf31 X 33fd510582e546d9a12a90241f1df033--362f29b10ac64f36a4a5585ea79bdf31 362f29b10ac64f36a4a5585ea79bdf31--c6110c637e394c6ba08be7183abc7908 0c0b9e7250224767b287250f9273c1e7 362f29b10ac64f36a4a5585ea79bdf31--0c0b9e7250224767b287250f9273c1e7 aabc125da239456a8e6cbad55cffcf27 0c0b9e7250224767b287250f9273c1e7--aabc125da239456a8e6cbad55cffcf27 4599adda36394a49a5eaebd9b3328170 aabc125da239456a8e6cbad55cffcf27--4599adda36394a49a5eaebd9b3328170 9a3cf410a47f45f2a23f3ac7fcd0b324 4599adda36394a49a5eaebd9b3328170--9a3cf410a47f45f2a23f3ac7fcd0b324 dc97ce1b26f040639bdce453cb624115 9a3cf410a47f45f2a23f3ac7fcd0b324--dc97ce1b26f040639bdce453cb624115 529cc43185704e6a941c7e62c02bfc67 X dc97ce1b26f040639bdce453cb624115--529cc43185704e6a941c7e62c02bfc67 529cc43185704e6a941c7e62c02bfc67--92996792a6604ca7b73a0c86dc21dea4 172d8bd92a484e4fb01f25cc559df952 X 529cc43185704e6a941c7e62c02bfc67--172d8bd92a484e4fb01f25cc559df952 172d8bd92a484e4fb01f25cc559df952--86941ed3b6404c7fafa3aaa6522acf95 03dd059f488e4a6a8793469bbdf3459a 172d8bd92a484e4fb01f25cc559df952--03dd059f488e4a6a8793469bbdf3459a 42ddb74c10ff4a60a1c343e24e7b99c5 03dd059f488e4a6a8793469bbdf3459a--42ddb74c10ff4a60a1c343e24e7b99c5 7f0a16459ff44c4e95e7ae0232085861 42ddb74c10ff4a60a1c343e24e7b99c5--7f0a16459ff44c4e95e7ae0232085861 7fdafdf77f5d4822aa062ef668e8ffc0 7f0a16459ff44c4e95e7ae0232085861--7fdafdf77f5d4822aa062ef668e8ffc0 4fd7faef73dd483187d89d1abeec37b1 7fdafdf77f5d4822aa062ef668e8ffc0--4fd7faef73dd483187d89d1abeec37b1 62f01c65ef6b49e3ac5c765193d3451f 4fd7faef73dd483187d89d1abeec37b1--62f01c65ef6b49e3ac5c765193d3451f a87afaf2ec424d9fae65e434fff98ed8 62f01c65ef6b49e3ac5c765193d3451f--a87afaf2ec424d9fae65e434fff98ed8 8af7a287bd044a788deb74af09bca68a X a87afaf2ec424d9fae65e434fff98ed8--8af7a287bd044a788deb74af09bca68a 8af7a287bd044a788deb74af09bca68a--b45eb1d93c66462085111e1373582d9a 7879f20e012f44a5a740877b608b52ff X 8af7a287bd044a788deb74af09bca68a--7879f20e012f44a5a740877b608b52ff 7879f20e012f44a5a740877b608b52ff--6c4ee155f70f4ff59af736660e2e0599 e31126e1979c4d089d5d2800417f1601 7879f20e012f44a5a740877b608b52ff--e31126e1979c4d089d5d2800417f1601 1832114fca494490b4baaf9289c38045 e31126e1979c4d089d5d2800417f1601--1832114fca494490b4baaf9289c38045 b46f75a9a71242cfa090fb5a683fa12e 1832114fca494490b4baaf9289c38045--b46f75a9a71242cfa090fb5a683fa12e b8eb33b7b537481f8ca2da69230a173e b46f75a9a71242cfa090fb5a683fa12e--b8eb33b7b537481f8ca2da69230a173e 57bb63c112544088b09c62e5dad5bcaa b8eb33b7b537481f8ca2da69230a173e--57bb63c112544088b09c62e5dad5bcaa d9dd06d1722a4fd0addeb29a4201cde3 57bb63c112544088b09c62e5dad5bcaa--d9dd06d1722a4fd0addeb29a4201cde3 1d23b447c91646d88ba187d3663b05dc d9dd06d1722a4fd0addeb29a4201cde3--1d23b447c91646d88ba187d3663b05dc d40ae0f142294bd5928afec6070880cc 1d23b447c91646d88ba187d3663b05dc--d40ae0f142294bd5928afec6070880cc 40c8aede56784e38b8101eba0ed03d48 d40ae0f142294bd5928afec6070880cc--40c8aede56784e38b8101eba0ed03d48 754ccf4ad5884840aff8e6a826411ed8 X 40c8aede56784e38b8101eba0ed03d48--754ccf4ad5884840aff8e6a826411ed8 754ccf4ad5884840aff8e6a826411ed8--8c68b1aaf6ee458e8a69803081fbba72 f14bc0b13254419ca3ae98cdf6647533 X 754ccf4ad5884840aff8e6a826411ed8--f14bc0b13254419ca3ae98cdf6647533 f14bc0b13254419ca3ae98cdf6647533--ae6ed8f2e59d40f19b79b58da83b0676 8c6d82fc43bf4fab840b770178a5d7c4 f14bc0b13254419ca3ae98cdf6647533--8c6d82fc43bf4fab840b770178a5d7c4 43aac2b91b464e8a9d0b58952a079fdc 8c6d82fc43bf4fab840b770178a5d7c4--43aac2b91b464e8a9d0b58952a079fdc fe9d7add86614052a6f0986729371305 43aac2b91b464e8a9d0b58952a079fdc--fe9d7add86614052a6f0986729371305 df043c76562e42aeb650e67c89b23afc fe9d7add86614052a6f0986729371305--df043c76562e42aeb650e67c89b23afc 3d283336c8ca40afb9f15ab817342447 df043c76562e42aeb650e67c89b23afc--3d283336c8ca40afb9f15ab817342447 a7755ba8217d48729d1d4aaec1ed9ddb 3d283336c8ca40afb9f15ab817342447--a7755ba8217d48729d1d4aaec1ed9ddb 7ec5f7543e404ef788b217c97748fed4 a7755ba8217d48729d1d4aaec1ed9ddb--7ec5f7543e404ef788b217c97748fed4 31b2ccdf049946a2a06740a8e95086cb 7ec5f7543e404ef788b217c97748fed4--31b2ccdf049946a2a06740a8e95086cb 0f1b5c4f75e04d3bbb8a0575ee08ee62 31b2ccdf049946a2a06740a8e95086cb--0f1b5c4f75e04d3bbb8a0575ee08ee62 cbb370e91d474f8ebfd36014c9257e97 0f1b5c4f75e04d3bbb8a0575ee08ee62--cbb370e91d474f8ebfd36014c9257e97 319afca97501445eae427090517e8ff4 cbb370e91d474f8ebfd36014c9257e97--319afca97501445eae427090517e8ff4 de5dfe9b14a64ca3b22c8082ce08cd36 X 319afca97501445eae427090517e8ff4--de5dfe9b14a64ca3b22c8082ce08cd36 de5dfe9b14a64ca3b22c8082ce08cd36--94fe5bb1c06a49838f244c68af9fe197 cd73710780bd4faca694d89b880fadd7 de5dfe9b14a64ca3b22c8082ce08cd36--cd73710780bd4faca694d89b880fadd7 e883638f31044d20b56d6162a5eb6b2c cd73710780bd4faca694d89b880fadd7--e883638f31044d20b56d6162a5eb6b2c 7a34b1be39754c96b4838866d58fc597 e883638f31044d20b56d6162a5eb6b2c--7a34b1be39754c96b4838866d58fc597 4cafea61cc794dd98193e320bd3a159a 7a34b1be39754c96b4838866d58fc597--4cafea61cc794dd98193e320bd3a159a b3bf4eca8bb743fb833fe3358797a0db 4cafea61cc794dd98193e320bd3a159a--b3bf4eca8bb743fb833fe3358797a0db 83d73e21687a4dcfbea1eef61db23531 b3bf4eca8bb743fb833fe3358797a0db--83d73e21687a4dcfbea1eef61db23531 5aee8a5638b049e786f9dc4f8a345af7 83d73e21687a4dcfbea1eef61db23531--5aee8a5638b049e786f9dc4f8a345af7 36c0875777b44ff99dad488536820708 5aee8a5638b049e786f9dc4f8a345af7--36c0875777b44ff99dad488536820708 018e65f9f640463fb1acf34c1307590a 36c0875777b44ff99dad488536820708--018e65f9f640463fb1acf34c1307590a 0b82104732e3435e991aa55fe221651a 018e65f9f640463fb1acf34c1307590a--0b82104732e3435e991aa55fe221651a e1339238380e4d28bac6c3b49acbb61c 0b82104732e3435e991aa55fe221651a--e1339238380e4d28bac6c3b49acbb61c decf801187ab46e98c445609a7e3223a e1339238380e4d28bac6c3b49acbb61c--decf801187ab46e98c445609a7e3223a ef8a2669c9e64261bcd4bda705fedb70 decf801187ab46e98c445609a7e3223a--ef8a2669c9e64261bcd4bda705fedb70 0b14058cd25841c493e8ca3c580e14a6 ef8a2669c9e64261bcd4bda705fedb70--0b14058cd25841c493e8ca3c580e14a6 61f2b38458e04ec29b6965461e34204a 0b14058cd25841c493e8ca3c580e14a6--61f2b38458e04ec29b6965461e34204a 1d15d0db12d74c02b5dd799b87413784 61f2b38458e04ec29b6965461e34204a--1d15d0db12d74c02b5dd799b87413784 8313f7160ded4f1bad15f67272a3ccee 1d15d0db12d74c02b5dd799b87413784--8313f7160ded4f1bad15f67272a3ccee 460b02fa38724b7dbc1ba2ab73451ab5 8313f7160ded4f1bad15f67272a3ccee--460b02fa38724b7dbc1ba2ab73451ab5 67d0c37f84da4da8998431e372e545c5 460b02fa38724b7dbc1ba2ab73451ab5--67d0c37f84da4da8998431e372e545c5 7cc2770b3abc40018715fd5bff0011b3 67d0c37f84da4da8998431e372e545c5--7cc2770b3abc40018715fd5bff0011b3 667541d7f8014f8cb80ae21e48865146 7cc2770b3abc40018715fd5bff0011b3--667541d7f8014f8cb80ae21e48865146 f0748703dead4876b2a96759f67af4e9 667541d7f8014f8cb80ae21e48865146--f0748703dead4876b2a96759f67af4e9 7c3edcf14dab4b09a7bc1377eb7eaf8c f0748703dead4876b2a96759f67af4e9--7c3edcf14dab4b09a7bc1377eb7eaf8c 2b727f8bbab14536a8975cc3332bd934 7c3edcf14dab4b09a7bc1377eb7eaf8c--2b727f8bbab14536a8975cc3332bd934 8e419f6c14e84a4ab90441c19213a5cf 2b727f8bbab14536a8975cc3332bd934--8e419f6c14e84a4ab90441c19213a5cf 8b4008b479834c15a14af400fc17b758 8e419f6c14e84a4ab90441c19213a5cf--8b4008b479834c15a14af400fc17b758 248439073bb0487f88362d90199a4e05 8b4008b479834c15a14af400fc17b758--248439073bb0487f88362d90199a4e05 ab17878ddde94e22922372e347f66cb2 248439073bb0487f88362d90199a4e05--ab17878ddde94e22922372e347f66cb2 60f7e0f37c6343ae84bfa191f6abaa9f ab17878ddde94e22922372e347f66cb2--60f7e0f37c6343ae84bfa191f6abaa9f ba648925693e4d089c7f7f7c75ac9e64 60f7e0f37c6343ae84bfa191f6abaa9f--ba648925693e4d089c7f7f7c75ac9e64 c7cd14a9d9334a1eb2f2cdd963e26838 ba648925693e4d089c7f7f7c75ac9e64--c7cd14a9d9334a1eb2f2cdd963e26838 7fd4e0fe55e248c49a6f976d4af23970 c7cd14a9d9334a1eb2f2cdd963e26838--7fd4e0fe55e248c49a6f976d4af23970 d7996c24ab2442eb83956a3754365b98 7fd4e0fe55e248c49a6f976d4af23970--d7996c24ab2442eb83956a3754365b98 37ecfe97f6b245dd8ec24278ea91d846 d7996c24ab2442eb83956a3754365b98--37ecfe97f6b245dd8ec24278ea91d846 6abdba8ecc1f421a9fbc8cd2c927bf02 37ecfe97f6b245dd8ec24278ea91d846--6abdba8ecc1f421a9fbc8cd2c927bf02 c34334476567418495c7cf2a6e0def3b 6abdba8ecc1f421a9fbc8cd2c927bf02--c34334476567418495c7cf2a6e0def3b f1e813b771e8414c865bc1f91f36b3b5 c34334476567418495c7cf2a6e0def3b--f1e813b771e8414c865bc1f91f36b3b5 4964359430b94d8caff9411ab441619d f1e813b771e8414c865bc1f91f36b3b5--4964359430b94d8caff9411ab441619d ec69df3de583449dbe15f5c1443704ef 4964359430b94d8caff9411ab441619d--ec69df3de583449dbe15f5c1443704ef d625e598d1c041cda8320b6db58806ce ec69df3de583449dbe15f5c1443704ef--d625e598d1c041cda8320b6db58806ce 3cc60c13807f41b193d2255f78054978 d625e598d1c041cda8320b6db58806ce--3cc60c13807f41b193d2255f78054978 7600030b89e6409c9c861c36628d7f12 3cc60c13807f41b193d2255f78054978--7600030b89e6409c9c861c36628d7f12 38e263d388974182a03c818c7e4af94e 7600030b89e6409c9c861c36628d7f12--38e263d388974182a03c818c7e4af94e 441eb66623154360afc8a4bffd148c97 38e263d388974182a03c818c7e4af94e--441eb66623154360afc8a4bffd148c97 1e58f791db8d43b187939710593bedc6 441eb66623154360afc8a4bffd148c97--1e58f791db8d43b187939710593bedc6 1a1c5a7dd2d04563a727181d40fcf9a5 1e58f791db8d43b187939710593bedc6--1a1c5a7dd2d04563a727181d40fcf9a5 616485bf33314cb48ba39e0e48c64244 1a1c5a7dd2d04563a727181d40fcf9a5--616485bf33314cb48ba39e0e48c64244 59eb1f1479e4448289fcec27d8b0af0e 616485bf33314cb48ba39e0e48c64244--59eb1f1479e4448289fcec27d8b0af0e f950845ced2640b8ac40460bb666308e 59eb1f1479e4448289fcec27d8b0af0e--f950845ced2640b8ac40460bb666308e 9dd279d093c842faa433b43fde026cd2 f950845ced2640b8ac40460bb666308e--9dd279d093c842faa433b43fde026cd2 5256ec5686fb48188708d6da35301487 9dd279d093c842faa433b43fde026cd2--5256ec5686fb48188708d6da35301487 78339aed68ce4bdc92d70f860817a82a 5256ec5686fb48188708d6da35301487--78339aed68ce4bdc92d70f860817a82a 5e9e251c89a645549282d034a6a5aed2 78339aed68ce4bdc92d70f860817a82a--5e9e251c89a645549282d034a6a5aed2 09a8f2ae08954fc1a308e8ec0311ca24 5e9e251c89a645549282d034a6a5aed2--09a8f2ae08954fc1a308e8ec0311ca24 cbfaeca68b834586adea0ecd1cd592ca RX(b01) 09a8f2ae08954fc1a308e8ec0311ca24--cbfaeca68b834586adea0ecd1cd592ca df71e078552643c7a1620447d213aa16 X cbfaeca68b834586adea0ecd1cd592ca--df71e078552643c7a1620447d213aa16 df71e078552643c7a1620447d213aa16--b8766ddf1a5944d48209b549dc0d2dfe 7e0b3f907be7472ca5ca0a345258ad43 df71e078552643c7a1620447d213aa16--7e0b3f907be7472ca5ca0a345258ad43 b66510a0bb4f4569a112a6ae8eaa053b 7e0b3f907be7472ca5ca0a345258ad43--b66510a0bb4f4569a112a6ae8eaa053b cf5f5b7df9d24cc28f5e623c35976ee0 b66510a0bb4f4569a112a6ae8eaa053b--cf5f5b7df9d24cc28f5e623c35976ee0 01b0b47486b44e5a8178d113d680c386 cf5f5b7df9d24cc28f5e623c35976ee0--01b0b47486b44e5a8178d113d680c386 088bcd2bd7aa4246bf3736abb2b3e54c 01b0b47486b44e5a8178d113d680c386--088bcd2bd7aa4246bf3736abb2b3e54c 307068420f3c46ddac177daf13798b1e 088bcd2bd7aa4246bf3736abb2b3e54c--307068420f3c46ddac177daf13798b1e 2bb2d311b44046bdae125f4c6a826c64 307068420f3c46ddac177daf13798b1e--2bb2d311b44046bdae125f4c6a826c64 74ebb56480ca42cf9e21b22992d61b59 2bb2d311b44046bdae125f4c6a826c64--74ebb56480ca42cf9e21b22992d61b59 958dbc7b1bc44be6be0561f9632894a0 74ebb56480ca42cf9e21b22992d61b59--958dbc7b1bc44be6be0561f9632894a0 8b41b2911922420aa7f12cf234e7aa82 958dbc7b1bc44be6be0561f9632894a0--8b41b2911922420aa7f12cf234e7aa82 9fe9e3189e584366a8f1b7a6552aed2b 8b41b2911922420aa7f12cf234e7aa82--9fe9e3189e584366a8f1b7a6552aed2b 08745adb2c4c4cd0a01fbc3eddeb27a0 9fe9e3189e584366a8f1b7a6552aed2b--08745adb2c4c4cd0a01fbc3eddeb27a0 bac3d239ce014d88b449065fa405e6a3 08745adb2c4c4cd0a01fbc3eddeb27a0--bac3d239ce014d88b449065fa405e6a3 2614ac4013114c9987b79a6051849b3b X bac3d239ce014d88b449065fa405e6a3--2614ac4013114c9987b79a6051849b3b 2614ac4013114c9987b79a6051849b3b--dd087180054a4ce8bd418e4f521a4373 0052509dceea4c5fa11790c9fd3a9392 X 2614ac4013114c9987b79a6051849b3b--0052509dceea4c5fa11790c9fd3a9392 0052509dceea4c5fa11790c9fd3a9392--122e7a6920504741b440a8f398210c0e a416f143f2114ca59963a4ede95f78b5 RZ(-1.0*g1) 0052509dceea4c5fa11790c9fd3a9392--a416f143f2114ca59963a4ede95f78b5 901b6f77bdc74f41a38c9a57cfb7aaf6 X a416f143f2114ca59963a4ede95f78b5--901b6f77bdc74f41a38c9a57cfb7aaf6 901b6f77bdc74f41a38c9a57cfb7aaf6--36779e9608fb4178b392c4e0b24b499a 819a87a1a726499ba4040f89c06aa165 X 901b6f77bdc74f41a38c9a57cfb7aaf6--819a87a1a726499ba4040f89c06aa165 819a87a1a726499ba4040f89c06aa165--09ce63f95bb44a07ad53efe960a9ce15 59c6608bdde345ada196e5251d6af8e3 819a87a1a726499ba4040f89c06aa165--59c6608bdde345ada196e5251d6af8e3 c5d10d91441b42d4b9d8165c8a89d125 59c6608bdde345ada196e5251d6af8e3--c5d10d91441b42d4b9d8165c8a89d125 a364e1b904544f559f083b71804d54a1 c5d10d91441b42d4b9d8165c8a89d125--a364e1b904544f559f083b71804d54a1 d715ced9b9854726bcb9c3825884124d a364e1b904544f559f083b71804d54a1--d715ced9b9854726bcb9c3825884124d 8dcddc733aa74d2eb36d56ba17e55e63 d715ced9b9854726bcb9c3825884124d--8dcddc733aa74d2eb36d56ba17e55e63 0a24b50596c3405285ef55e01fa62e59 X 8dcddc733aa74d2eb36d56ba17e55e63--0a24b50596c3405285ef55e01fa62e59 0a24b50596c3405285ef55e01fa62e59--3a0aeed6c2994764bcaa7ef226cb6206 8fecdf1ae40348909f67136a19f99e5b X 0a24b50596c3405285ef55e01fa62e59--8fecdf1ae40348909f67136a19f99e5b 8fecdf1ae40348909f67136a19f99e5b--7231348fc3f64ccda93fa9593cce4ff0 d9ce4537e711451886f36688c7a9a775 8fecdf1ae40348909f67136a19f99e5b--d9ce4537e711451886f36688c7a9a775 6825bf9c180c44e7950bb65adee1f97c d9ce4537e711451886f36688c7a9a775--6825bf9c180c44e7950bb65adee1f97c 0a3947e23f0b450d8e8f9d7e47b10302 6825bf9c180c44e7950bb65adee1f97c--0a3947e23f0b450d8e8f9d7e47b10302 95811a22609f42e89b71b6c02fb1fc1f 0a3947e23f0b450d8e8f9d7e47b10302--95811a22609f42e89b71b6c02fb1fc1f 6b00678b627f498293ad9500686aabbb 95811a22609f42e89b71b6c02fb1fc1f--6b00678b627f498293ad9500686aabbb 9f20dd0b271a45228185b42d93317074 6b00678b627f498293ad9500686aabbb--9f20dd0b271a45228185b42d93317074 a256b270759e46058ed583eefcd3a240 9f20dd0b271a45228185b42d93317074--a256b270759e46058ed583eefcd3a240 5450c32884e842ee855db6b309e6a061 X a256b270759e46058ed583eefcd3a240--5450c32884e842ee855db6b309e6a061 5450c32884e842ee855db6b309e6a061--7f8ed56d2c4147db903fe82ca59d3bb7 672a38b7c09046dd8a90b0eae97a125a X 5450c32884e842ee855db6b309e6a061--672a38b7c09046dd8a90b0eae97a125a 672a38b7c09046dd8a90b0eae97a125a--fe14264c05f641e0a5dd02bfa42eb0f0 ac8f9db63b554851a52bf8a6f98c26d4 672a38b7c09046dd8a90b0eae97a125a--ac8f9db63b554851a52bf8a6f98c26d4 c2f288773e784f69a249b6412aa58be3 ac8f9db63b554851a52bf8a6f98c26d4--c2f288773e784f69a249b6412aa58be3 8748472c61d9468ab9cfd7e19d18d5b3 c2f288773e784f69a249b6412aa58be3--8748472c61d9468ab9cfd7e19d18d5b3 206d5088a3084d0f899ace29fac2bffb 8748472c61d9468ab9cfd7e19d18d5b3--206d5088a3084d0f899ace29fac2bffb c06cb3052b7b423082cf637642262e36 206d5088a3084d0f899ace29fac2bffb--c06cb3052b7b423082cf637642262e36 efe4761c46e5475eacf522709ee0b42c c06cb3052b7b423082cf637642262e36--efe4761c46e5475eacf522709ee0b42c 97e065bf28124121bffba988fba0a15f efe4761c46e5475eacf522709ee0b42c--97e065bf28124121bffba988fba0a15f a981c5e829874a7d91c89fea977d734b 97e065bf28124121bffba988fba0a15f--a981c5e829874a7d91c89fea977d734b 881d0e0bf2ce451688797525e843d588 a981c5e829874a7d91c89fea977d734b--881d0e0bf2ce451688797525e843d588 951188c4e61f4662b4642cf6c843a292 X 881d0e0bf2ce451688797525e843d588--951188c4e61f4662b4642cf6c843a292 951188c4e61f4662b4642cf6c843a292--0c18e150828d4cf383648da00bac175a ad398ab41f284ced903cedb689436af2 X 951188c4e61f4662b4642cf6c843a292--ad398ab41f284ced903cedb689436af2 ad398ab41f284ced903cedb689436af2--736167a9d2e14f109048cf75841b7f13 855c6a3b34614acfa53673f927f7a38e ad398ab41f284ced903cedb689436af2--855c6a3b34614acfa53673f927f7a38e 7da2b284f1544747994eec2451b09f72 855c6a3b34614acfa53673f927f7a38e--7da2b284f1544747994eec2451b09f72 d8f8550b634f4c6f8f29e103df18076e 7da2b284f1544747994eec2451b09f72--d8f8550b634f4c6f8f29e103df18076e 2557bf77e12740e1b299195f49971a4f d8f8550b634f4c6f8f29e103df18076e--2557bf77e12740e1b299195f49971a4f d3122e23f8b04978bfd1f1e76edf29fb 2557bf77e12740e1b299195f49971a4f--d3122e23f8b04978bfd1f1e76edf29fb f6c68b72adc040309d0773206e08da66 d3122e23f8b04978bfd1f1e76edf29fb--f6c68b72adc040309d0773206e08da66 66096a926faf4b3a9f18d997b349a9d9 f6c68b72adc040309d0773206e08da66--66096a926faf4b3a9f18d997b349a9d9 38290cdb832d4d9eab3344d104dc02b3 66096a926faf4b3a9f18d997b349a9d9--38290cdb832d4d9eab3344d104dc02b3 a40e6ef09f5f43f7b91e032cfa57df5e 38290cdb832d4d9eab3344d104dc02b3--a40e6ef09f5f43f7b91e032cfa57df5e 056114604ede49dbae1389a9383a2471 a40e6ef09f5f43f7b91e032cfa57df5e--056114604ede49dbae1389a9383a2471 a4ed082b971344a8ade70ae95b67b0fd 056114604ede49dbae1389a9383a2471--a4ed082b971344a8ade70ae95b67b0fd 4e5d2278e265442da83d100f16f2c222 X a4ed082b971344a8ade70ae95b67b0fd--4e5d2278e265442da83d100f16f2c222 4e5d2278e265442da83d100f16f2c222--0bbec5223e264200bab8f4dbf804531a a931d32643134c13b0e41167cea70744 4e5d2278e265442da83d100f16f2c222--a931d32643134c13b0e41167cea70744 05f4f2daae4542f19b391243a096ebf9 a931d32643134c13b0e41167cea70744--05f4f2daae4542f19b391243a096ebf9 f2f106faa3a44a55b1ef4eb13e4b4d19 05f4f2daae4542f19b391243a096ebf9--f2f106faa3a44a55b1ef4eb13e4b4d19 67713f6536064ace899e134d1259c23e f2f106faa3a44a55b1ef4eb13e4b4d19--67713f6536064ace899e134d1259c23e d94c38e239684eb9887c8f144c6d9834 67713f6536064ace899e134d1259c23e--d94c38e239684eb9887c8f144c6d9834 af73c425704a4461b667992de95ae8ae d94c38e239684eb9887c8f144c6d9834--af73c425704a4461b667992de95ae8ae 5fab2ec1dffa4009854aeb2d9a7d1056 af73c425704a4461b667992de95ae8ae--5fab2ec1dffa4009854aeb2d9a7d1056 7cd47a017b12414890519cf87373b54b 5fab2ec1dffa4009854aeb2d9a7d1056--7cd47a017b12414890519cf87373b54b 0fe9c244584f4761be332c3f27b903d5 7cd47a017b12414890519cf87373b54b--0fe9c244584f4761be332c3f27b903d5 3a3866529a624881a9f5c1d803f58ff5 0fe9c244584f4761be332c3f27b903d5--3a3866529a624881a9f5c1d803f58ff5 15e73360733b420abe6dc2e1b5d5592f 3a3866529a624881a9f5c1d803f58ff5--15e73360733b420abe6dc2e1b5d5592f 419a1ad79ce74bcfb5edd245f715f45a 15e73360733b420abe6dc2e1b5d5592f--419a1ad79ce74bcfb5edd245f715f45a 30e359b2b0684b978dbeebe640bb14e9 419a1ad79ce74bcfb5edd245f715f45a--30e359b2b0684b978dbeebe640bb14e9 20a52405a98a48f185b5f84a81e7f7b1 30e359b2b0684b978dbeebe640bb14e9--20a52405a98a48f185b5f84a81e7f7b1 7be3f7d99d4547cd9743e8e1e87b28e2 20a52405a98a48f185b5f84a81e7f7b1--7be3f7d99d4547cd9743e8e1e87b28e2 ed4a6aa03edd4fff969609a4472cdcc6 7be3f7d99d4547cd9743e8e1e87b28e2--ed4a6aa03edd4fff969609a4472cdcc6 e0cd4f4e8d8248b7a6e3b12798aa22c4 ed4a6aa03edd4fff969609a4472cdcc6--e0cd4f4e8d8248b7a6e3b12798aa22c4 7ae6465c4bfd4ee990d2a8c9ba583dc9 e0cd4f4e8d8248b7a6e3b12798aa22c4--7ae6465c4bfd4ee990d2a8c9ba583dc9 ebedc5bf8e18443fbffe2388373d3641 7ae6465c4bfd4ee990d2a8c9ba583dc9--ebedc5bf8e18443fbffe2388373d3641 0e6dc94e562f43d68e4d47da487cf911 ebedc5bf8e18443fbffe2388373d3641--0e6dc94e562f43d68e4d47da487cf911 88449d15eb9941a78122c0dc9864740a 0e6dc94e562f43d68e4d47da487cf911--88449d15eb9941a78122c0dc9864740a 7f614ce861f14f318ebdcf1168e202cb 88449d15eb9941a78122c0dc9864740a--7f614ce861f14f318ebdcf1168e202cb 6de688db4760470587f1701171ca0fc0 7f614ce861f14f318ebdcf1168e202cb--6de688db4760470587f1701171ca0fc0 df2ee0e30b0c410ca047c7bdd5215f1f 6de688db4760470587f1701171ca0fc0--df2ee0e30b0c410ca047c7bdd5215f1f 648b0d5b34444f0f8bc95c0b00a126cd df2ee0e30b0c410ca047c7bdd5215f1f--648b0d5b34444f0f8bc95c0b00a126cd d210f8b9feb74ca0a04e22a69f2064eb 648b0d5b34444f0f8bc95c0b00a126cd--d210f8b9feb74ca0a04e22a69f2064eb 986d3f6f5fb148b4bf4aa06b6ee3e4f0 d210f8b9feb74ca0a04e22a69f2064eb--986d3f6f5fb148b4bf4aa06b6ee3e4f0 c2719f38158042c2a30841b5cb91f1bd 986d3f6f5fb148b4bf4aa06b6ee3e4f0--c2719f38158042c2a30841b5cb91f1bd cc15c67f12e94dd5bafd237bb7a3d9e3 c2719f38158042c2a30841b5cb91f1bd--cc15c67f12e94dd5bafd237bb7a3d9e3 b78afcf1f4004fa5ac738401f88cfa4d cc15c67f12e94dd5bafd237bb7a3d9e3--b78afcf1f4004fa5ac738401f88cfa4d b28fa56e735245ddba708dcaa7fbff70 b78afcf1f4004fa5ac738401f88cfa4d--b28fa56e735245ddba708dcaa7fbff70 30de30899be6482db3efa46e187b311c b28fa56e735245ddba708dcaa7fbff70--30de30899be6482db3efa46e187b311c e8f8bc6db734492d8a057e534e5f76de 30de30899be6482db3efa46e187b311c--e8f8bc6db734492d8a057e534e5f76de 015469b697514092b6d794493004127d e8f8bc6db734492d8a057e534e5f76de--015469b697514092b6d794493004127d 87b902229fc04811b6b4a20514be0ca8 015469b697514092b6d794493004127d--87b902229fc04811b6b4a20514be0ca8 39082c93d664459d9cbc64fdd13b82ca 87b902229fc04811b6b4a20514be0ca8--39082c93d664459d9cbc64fdd13b82ca 1b1d91f2784f4569819eec67a31269e2 39082c93d664459d9cbc64fdd13b82ca--1b1d91f2784f4569819eec67a31269e2 ed70d03b0f954eb994846f4fcbe68a1d 1b1d91f2784f4569819eec67a31269e2--ed70d03b0f954eb994846f4fcbe68a1d 4b932444d207486d8c8c30d2e211221b ed70d03b0f954eb994846f4fcbe68a1d--4b932444d207486d8c8c30d2e211221b f63c5e1383ca4a6d84f430fc5eba18df 4b932444d207486d8c8c30d2e211221b--f63c5e1383ca4a6d84f430fc5eba18df 102110408e6c4119a6a0e4165e6a4539 f63c5e1383ca4a6d84f430fc5eba18df--102110408e6c4119a6a0e4165e6a4539 bc910ebd8c874872ba0d09a406d2edd2 102110408e6c4119a6a0e4165e6a4539--bc910ebd8c874872ba0d09a406d2edd2 ee0c6a770f0749228bb909546c131ad7 bc910ebd8c874872ba0d09a406d2edd2--ee0c6a770f0749228bb909546c131ad7 82f0657991454b9990d742aaf388581a ee0c6a770f0749228bb909546c131ad7--82f0657991454b9990d742aaf388581a 68b6ab7f51454f6bb1ba9e7fce2449d3 82f0657991454b9990d742aaf388581a--68b6ab7f51454f6bb1ba9e7fce2449d3 a7378fdb05b9409e88526fdbc5935743 68b6ab7f51454f6bb1ba9e7fce2449d3--a7378fdb05b9409e88526fdbc5935743 d83c7e59ce4c44c395f011b29863c682 a7378fdb05b9409e88526fdbc5935743--d83c7e59ce4c44c395f011b29863c682 6f7bb9f35c2b4b21b952fa8d61536110 d83c7e59ce4c44c395f011b29863c682--6f7bb9f35c2b4b21b952fa8d61536110 d7c057265f50420f8de7db4b8a70eb1f 6f7bb9f35c2b4b21b952fa8d61536110--d7c057265f50420f8de7db4b8a70eb1f 49de5817725a4367828290c248804e60 d7c057265f50420f8de7db4b8a70eb1f--49de5817725a4367828290c248804e60 2ad5d8d1947340959d373dd9306ad1b8 49de5817725a4367828290c248804e60--2ad5d8d1947340959d373dd9306ad1b8 21e26aa8312644e2bcfbc9c967e454bf 2ad5d8d1947340959d373dd9306ad1b8--21e26aa8312644e2bcfbc9c967e454bf 2cfe1c6a9ec14c6c9729480e59b38ad4 21e26aa8312644e2bcfbc9c967e454bf--2cfe1c6a9ec14c6c9729480e59b38ad4 0151790c68a34f95a8574da7201d9cdc 2cfe1c6a9ec14c6c9729480e59b38ad4--0151790c68a34f95a8574da7201d9cdc 59f0313ca2434be9bc21b7f91398ab32 RX(b11) 0151790c68a34f95a8574da7201d9cdc--59f0313ca2434be9bc21b7f91398ab32 59f0313ca2434be9bc21b7f91398ab32--399c28bcf17242a4b6c1db08bd692c2c 59bf168a68ed4e218c586162d865ecb1 ab50b6e077a8451aaf61ceaca66d704c b89ab0699b0f442b9b5e7759733cdedc--ab50b6e077a8451aaf61ceaca66d704c ba34424c519a41bb856d7b1bfdaeecca 3 13ae73b17ca54001a57934b2f420583e X ab50b6e077a8451aaf61ceaca66d704c--13ae73b17ca54001a57934b2f420583e 13ae73b17ca54001a57934b2f420583e--f9e5ddcea9e745e987489713046afcb6 b9b944944bca4a1a905f2ca90bb39347 13ae73b17ca54001a57934b2f420583e--b9b944944bca4a1a905f2ca90bb39347 9f3884ed6b3b49f88f9d6062506a590d b9b944944bca4a1a905f2ca90bb39347--9f3884ed6b3b49f88f9d6062506a590d 104dbb1b78f1480db374b1a9fba117f3 9f3884ed6b3b49f88f9d6062506a590d--104dbb1b78f1480db374b1a9fba117f3 c1c19172b45740f8b56445e2bdfc9b07 104dbb1b78f1480db374b1a9fba117f3--c1c19172b45740f8b56445e2bdfc9b07 a238375190ba498ca259a7093fce932e c1c19172b45740f8b56445e2bdfc9b07--a238375190ba498ca259a7093fce932e cabcef7f9adf4682a13f123be2fee030 a238375190ba498ca259a7093fce932e--cabcef7f9adf4682a13f123be2fee030 0db253bfc54f4ac2b2baa8f9e6b7dce0 cabcef7f9adf4682a13f123be2fee030--0db253bfc54f4ac2b2baa8f9e6b7dce0 f0a7c66db2df49f68a965978262b4d30 0db253bfc54f4ac2b2baa8f9e6b7dce0--f0a7c66db2df49f68a965978262b4d30 b171c9d25c7a4eba90bf486a5aa978b9 f0a7c66db2df49f68a965978262b4d30--b171c9d25c7a4eba90bf486a5aa978b9 1021300f39d14d15a64dbcff0f80505d b171c9d25c7a4eba90bf486a5aa978b9--1021300f39d14d15a64dbcff0f80505d 8ede29659fb34dc297f5ccd8d1cc76ec 1021300f39d14d15a64dbcff0f80505d--8ede29659fb34dc297f5ccd8d1cc76ec 59b142a7aa00483ebda89ada0f29a5bf X 8ede29659fb34dc297f5ccd8d1cc76ec--59b142a7aa00483ebda89ada0f29a5bf 59b142a7aa00483ebda89ada0f29a5bf--e3671b72a53747999484ad7a5d755fe7 39a51e7bad70448f91a7d0a8d697f604 59b142a7aa00483ebda89ada0f29a5bf--39a51e7bad70448f91a7d0a8d697f604 7b271a0a8f57407cbd29a9ac0d4d8876 39a51e7bad70448f91a7d0a8d697f604--7b271a0a8f57407cbd29a9ac0d4d8876 9401a70db9ca4ea6baf5b848381eec5b 7b271a0a8f57407cbd29a9ac0d4d8876--9401a70db9ca4ea6baf5b848381eec5b 2cfff09f661f4ef5b7a909b3ced33f69 9401a70db9ca4ea6baf5b848381eec5b--2cfff09f661f4ef5b7a909b3ced33f69 e194ca4d34474bff950b79a2df2c9d4e 2cfff09f661f4ef5b7a909b3ced33f69--e194ca4d34474bff950b79a2df2c9d4e b8e34e84de4b47f2b918e74b3d557ae2 X e194ca4d34474bff950b79a2df2c9d4e--b8e34e84de4b47f2b918e74b3d557ae2 b8e34e84de4b47f2b918e74b3d557ae2--0c0b9e7250224767b287250f9273c1e7 1c5e316a99004456b82c8710f297681d b8e34e84de4b47f2b918e74b3d557ae2--1c5e316a99004456b82c8710f297681d 163b8565ff3e42cb811a82e6efe54277 1c5e316a99004456b82c8710f297681d--163b8565ff3e42cb811a82e6efe54277 95b78aec5d7549f98c16d0fd52ceabab 163b8565ff3e42cb811a82e6efe54277--95b78aec5d7549f98c16d0fd52ceabab 77defab40f284219952a258f77811a69 X 95b78aec5d7549f98c16d0fd52ceabab--77defab40f284219952a258f77811a69 77defab40f284219952a258f77811a69--dc97ce1b26f040639bdce453cb624115 0f06d0dabef84c51bcabfa2c830ad67c 77defab40f284219952a258f77811a69--0f06d0dabef84c51bcabfa2c830ad67c a7f2ac2e7a9e4d56890c9500504e55b1 0f06d0dabef84c51bcabfa2c830ad67c--a7f2ac2e7a9e4d56890c9500504e55b1 bc6b62551caf463c911b81e20116589c X a7f2ac2e7a9e4d56890c9500504e55b1--bc6b62551caf463c911b81e20116589c bc6b62551caf463c911b81e20116589c--03dd059f488e4a6a8793469bbdf3459a 5eafa58c0b944455bd337162cc434f2a bc6b62551caf463c911b81e20116589c--5eafa58c0b944455bd337162cc434f2a 01234e044d2a481ba448e50cf87d23e0 5eafa58c0b944455bd337162cc434f2a--01234e044d2a481ba448e50cf87d23e0 a05df6ea6e8d41cd85def56f9781812f 01234e044d2a481ba448e50cf87d23e0--a05df6ea6e8d41cd85def56f9781812f 78dca8f8b33947a88201b95b9651603e a05df6ea6e8d41cd85def56f9781812f--78dca8f8b33947a88201b95b9651603e 34f7744a36964948b9bb27dff6b421af 78dca8f8b33947a88201b95b9651603e--34f7744a36964948b9bb27dff6b421af c8b1e199a556472e88b3b8da9d2acebd X 34f7744a36964948b9bb27dff6b421af--c8b1e199a556472e88b3b8da9d2acebd c8b1e199a556472e88b3b8da9d2acebd--a87afaf2ec424d9fae65e434fff98ed8 dd2f73cb2f5d44a6976c488a5eed6ce4 c8b1e199a556472e88b3b8da9d2acebd--dd2f73cb2f5d44a6976c488a5eed6ce4 0ffdce688acd437b93d06fddad5cfdfe dd2f73cb2f5d44a6976c488a5eed6ce4--0ffdce688acd437b93d06fddad5cfdfe 875c7ec575b84a328ba49220c23e7d1f X 0ffdce688acd437b93d06fddad5cfdfe--875c7ec575b84a328ba49220c23e7d1f 875c7ec575b84a328ba49220c23e7d1f--e31126e1979c4d089d5d2800417f1601 1e088aaeb04145a7b5884241c33f2dc5 875c7ec575b84a328ba49220c23e7d1f--1e088aaeb04145a7b5884241c33f2dc5 ebe1714af3f3446ba791ead2cd1ea0c8 1e088aaeb04145a7b5884241c33f2dc5--ebe1714af3f3446ba791ead2cd1ea0c8 a85f871cd83046d5ac794cf0978684fe ebe1714af3f3446ba791ead2cd1ea0c8--a85f871cd83046d5ac794cf0978684fe aad1e77e6b87477583ba724874a5b7f4 a85f871cd83046d5ac794cf0978684fe--aad1e77e6b87477583ba724874a5b7f4 a6bc06983ab14c6f8999636612ea88a2 aad1e77e6b87477583ba724874a5b7f4--a6bc06983ab14c6f8999636612ea88a2 93e5bdb8e54e4e5fb0834e2e9a366f0a a6bc06983ab14c6f8999636612ea88a2--93e5bdb8e54e4e5fb0834e2e9a366f0a 2da2de5701da43d2b9a4650581555f4e 93e5bdb8e54e4e5fb0834e2e9a366f0a--2da2de5701da43d2b9a4650581555f4e cf4c86c7a60644f59c0a36b18ceac1a3 X 2da2de5701da43d2b9a4650581555f4e--cf4c86c7a60644f59c0a36b18ceac1a3 cf4c86c7a60644f59c0a36b18ceac1a3--40c8aede56784e38b8101eba0ed03d48 e4e000a7b0334bac8ff3f7a65d0d406e cf4c86c7a60644f59c0a36b18ceac1a3--e4e000a7b0334bac8ff3f7a65d0d406e ed230db2f4314eaa903e993685f00e7d e4e000a7b0334bac8ff3f7a65d0d406e--ed230db2f4314eaa903e993685f00e7d 244c5c788a694b6797567382e869408c X ed230db2f4314eaa903e993685f00e7d--244c5c788a694b6797567382e869408c 244c5c788a694b6797567382e869408c--8c6d82fc43bf4fab840b770178a5d7c4 3792037d5ad84d0c8f61351d434563ec 244c5c788a694b6797567382e869408c--3792037d5ad84d0c8f61351d434563ec 69becf7b2a2949e0ace054c923c433a7 3792037d5ad84d0c8f61351d434563ec--69becf7b2a2949e0ace054c923c433a7 35fe33eb79e343769d04119c7ac5a6fb 69becf7b2a2949e0ace054c923c433a7--35fe33eb79e343769d04119c7ac5a6fb ccd257b2de1548bfab273ad45a13638c 35fe33eb79e343769d04119c7ac5a6fb--ccd257b2de1548bfab273ad45a13638c c6d22c054243441fa869d2393a2f1d56 ccd257b2de1548bfab273ad45a13638c--c6d22c054243441fa869d2393a2f1d56 828919a421df48bf8c4829caf8a2bc54 c6d22c054243441fa869d2393a2f1d56--828919a421df48bf8c4829caf8a2bc54 353a30e8e5104fa292751e1fcf4ec78e 828919a421df48bf8c4829caf8a2bc54--353a30e8e5104fa292751e1fcf4ec78e 57a6bc170aa44a2cbb1f1437335605ea 353a30e8e5104fa292751e1fcf4ec78e--57a6bc170aa44a2cbb1f1437335605ea 1c43df9f6b9c4ea2886d59e46c701672 57a6bc170aa44a2cbb1f1437335605ea--1c43df9f6b9c4ea2886d59e46c701672 cdb038eddb794d6498aa77859872b0df X 1c43df9f6b9c4ea2886d59e46c701672--cdb038eddb794d6498aa77859872b0df cdb038eddb794d6498aa77859872b0df--319afca97501445eae427090517e8ff4 11c65a136f9b4750bff2ec666f5231b4 cdb038eddb794d6498aa77859872b0df--11c65a136f9b4750bff2ec666f5231b4 23a55738bf8047c2b6505269a1f25090 X 11c65a136f9b4750bff2ec666f5231b4--23a55738bf8047c2b6505269a1f25090 23a55738bf8047c2b6505269a1f25090--cd73710780bd4faca694d89b880fadd7 931cf21275714cacbeefe734ba90cfa5 23a55738bf8047c2b6505269a1f25090--931cf21275714cacbeefe734ba90cfa5 0675fb88eb5d4e7fb38c977cc86659fe 931cf21275714cacbeefe734ba90cfa5--0675fb88eb5d4e7fb38c977cc86659fe dddb4374fd444ab587511440e886e94b 0675fb88eb5d4e7fb38c977cc86659fe--dddb4374fd444ab587511440e886e94b 299605c839584a88bf340225108ad0ca dddb4374fd444ab587511440e886e94b--299605c839584a88bf340225108ad0ca 7157b4131e7c40ac84d7229f50c5080a 299605c839584a88bf340225108ad0ca--7157b4131e7c40ac84d7229f50c5080a 0a3675f00c884d3592621fe2fad24cea 7157b4131e7c40ac84d7229f50c5080a--0a3675f00c884d3592621fe2fad24cea 1fed826e5f064adc9bf7205bfc51534a 0a3675f00c884d3592621fe2fad24cea--1fed826e5f064adc9bf7205bfc51534a 441219b0fa624b51b348a4499e8a0e0a 1fed826e5f064adc9bf7205bfc51534a--441219b0fa624b51b348a4499e8a0e0a ff81c464a5964845b2536363248fe84c 441219b0fa624b51b348a4499e8a0e0a--ff81c464a5964845b2536363248fe84c 6898676a6a7847f6a4adf2a036df95bd X ff81c464a5964845b2536363248fe84c--6898676a6a7847f6a4adf2a036df95bd 6898676a6a7847f6a4adf2a036df95bd--e1339238380e4d28bac6c3b49acbb61c 8945f9babb134bcda09cb653803853d1 6898676a6a7847f6a4adf2a036df95bd--8945f9babb134bcda09cb653803853d1 1d92c3a6dc154a62900d54d9b6373867 8945f9babb134bcda09cb653803853d1--1d92c3a6dc154a62900d54d9b6373867 c65623437e7c4c89965a02aaf59877c5 1d92c3a6dc154a62900d54d9b6373867--c65623437e7c4c89965a02aaf59877c5 e6dc1fedf9ba4212ba50ece4a1d81f8d c65623437e7c4c89965a02aaf59877c5--e6dc1fedf9ba4212ba50ece4a1d81f8d 7ab7074b1af242f9970487e89715ad84 e6dc1fedf9ba4212ba50ece4a1d81f8d--7ab7074b1af242f9970487e89715ad84 547ae0ca342b4535a72a3a88a914d24f 7ab7074b1af242f9970487e89715ad84--547ae0ca342b4535a72a3a88a914d24f 2a1b7e8b0aba4108be367477c848a83f 547ae0ca342b4535a72a3a88a914d24f--2a1b7e8b0aba4108be367477c848a83f 587414cfc7d8463885e1e9d02e9b15d7 2a1b7e8b0aba4108be367477c848a83f--587414cfc7d8463885e1e9d02e9b15d7 96f60d1524604a4cb347721f591555f2 587414cfc7d8463885e1e9d02e9b15d7--96f60d1524604a4cb347721f591555f2 21bda2aa33944cfa9317f8d08696c827 96f60d1524604a4cb347721f591555f2--21bda2aa33944cfa9317f8d08696c827 80da46fbccb0460cb789f37c4a2b8bff 21bda2aa33944cfa9317f8d08696c827--80da46fbccb0460cb789f37c4a2b8bff f604014738594c2680b3395e3a632e9e 80da46fbccb0460cb789f37c4a2b8bff--f604014738594c2680b3395e3a632e9e 4ec91754e9554f7b8771b66cfafcc40c f604014738594c2680b3395e3a632e9e--4ec91754e9554f7b8771b66cfafcc40c a218ad4de692400fa94b19f8cbd08aa6 4ec91754e9554f7b8771b66cfafcc40c--a218ad4de692400fa94b19f8cbd08aa6 688427fc9b47498aa95a8a4b87bc7a97 a218ad4de692400fa94b19f8cbd08aa6--688427fc9b47498aa95a8a4b87bc7a97 e293acbb594647e0b41ed2b460ab558f 688427fc9b47498aa95a8a4b87bc7a97--e293acbb594647e0b41ed2b460ab558f 1e61736102b149d880bfd906d38c3910 e293acbb594647e0b41ed2b460ab558f--1e61736102b149d880bfd906d38c3910 e721459e1b184bdea7155e597b9fc2c1 1e61736102b149d880bfd906d38c3910--e721459e1b184bdea7155e597b9fc2c1 d6b93faae15f4f14ac71f60d85546783 e721459e1b184bdea7155e597b9fc2c1--d6b93faae15f4f14ac71f60d85546783 09faa199ec0a439fa95bb0a649350115 d6b93faae15f4f14ac71f60d85546783--09faa199ec0a439fa95bb0a649350115 8e5b0e76955549ef811df26ae08282ac 09faa199ec0a439fa95bb0a649350115--8e5b0e76955549ef811df26ae08282ac 1ba7477762b64a8381b8de92a5d63242 8e5b0e76955549ef811df26ae08282ac--1ba7477762b64a8381b8de92a5d63242 02b10842160b4d7c807f639bfc11d051 1ba7477762b64a8381b8de92a5d63242--02b10842160b4d7c807f639bfc11d051 0107cb47c1ee46bdb34b6b55fcf01e35 02b10842160b4d7c807f639bfc11d051--0107cb47c1ee46bdb34b6b55fcf01e35 11ca6e57c0724c7ca5b3d8858ae2bde7 0107cb47c1ee46bdb34b6b55fcf01e35--11ca6e57c0724c7ca5b3d8858ae2bde7 9a47d14ce9db4ee2995fb0b7239eeca1 11ca6e57c0724c7ca5b3d8858ae2bde7--9a47d14ce9db4ee2995fb0b7239eeca1 874447a81bf4490b9e5d156e3a33bb7d 9a47d14ce9db4ee2995fb0b7239eeca1--874447a81bf4490b9e5d156e3a33bb7d b3b2d07e326e4d0fa8e19cef7feb6f0c 874447a81bf4490b9e5d156e3a33bb7d--b3b2d07e326e4d0fa8e19cef7feb6f0c 851524f8968240c9aecee61f34d291e3 b3b2d07e326e4d0fa8e19cef7feb6f0c--851524f8968240c9aecee61f34d291e3 6a68deed9c74479ba74c1e3dae959647 851524f8968240c9aecee61f34d291e3--6a68deed9c74479ba74c1e3dae959647 a334ab1b6f7c4159855644ebf7a73b7e 6a68deed9c74479ba74c1e3dae959647--a334ab1b6f7c4159855644ebf7a73b7e c3af14c46f644998852005f9fedf196c a334ab1b6f7c4159855644ebf7a73b7e--c3af14c46f644998852005f9fedf196c c82ade9cf47d4cc8abf031cd78023952 c3af14c46f644998852005f9fedf196c--c82ade9cf47d4cc8abf031cd78023952 568c69f5ce9e4bbc87c4cb6157f73eba c82ade9cf47d4cc8abf031cd78023952--568c69f5ce9e4bbc87c4cb6157f73eba eed17c8253a1470b88ec63d986e9d733 568c69f5ce9e4bbc87c4cb6157f73eba--eed17c8253a1470b88ec63d986e9d733 452e633f5f7b409eb08ecd702ef89514 eed17c8253a1470b88ec63d986e9d733--452e633f5f7b409eb08ecd702ef89514 f68f140aba7844ac93243f054a27aacf 452e633f5f7b409eb08ecd702ef89514--f68f140aba7844ac93243f054a27aacf 925bab783ab845f2a25de148ce297736 f68f140aba7844ac93243f054a27aacf--925bab783ab845f2a25de148ce297736 156629b0a97b4fd88f48ad13f9178014 925bab783ab845f2a25de148ce297736--156629b0a97b4fd88f48ad13f9178014 16eb497bc39d430bb107e3a0a977534c 156629b0a97b4fd88f48ad13f9178014--16eb497bc39d430bb107e3a0a977534c c01508d61fd84ff29be9b67e632f9ed4 16eb497bc39d430bb107e3a0a977534c--c01508d61fd84ff29be9b67e632f9ed4 55ebe701c5bc49c5bfa9763416d1595b c01508d61fd84ff29be9b67e632f9ed4--55ebe701c5bc49c5bfa9763416d1595b bd754ce6b5aa440f8d0db2ec2ca1de2e 55ebe701c5bc49c5bfa9763416d1595b--bd754ce6b5aa440f8d0db2ec2ca1de2e c9698d9bb9fe45d8adfbc1c3959675c3 RX(b02) bd754ce6b5aa440f8d0db2ec2ca1de2e--c9698d9bb9fe45d8adfbc1c3959675c3 44f69bf8063b444fa1b6ab4e4ed5c5ef c9698d9bb9fe45d8adfbc1c3959675c3--44f69bf8063b444fa1b6ab4e4ed5c5ef 552dc50e91224327bbb911551315b6c8 X 44f69bf8063b444fa1b6ab4e4ed5c5ef--552dc50e91224327bbb911551315b6c8 552dc50e91224327bbb911551315b6c8--7e0b3f907be7472ca5ca0a345258ad43 2726494cca344d5ab082c6a53b517798 552dc50e91224327bbb911551315b6c8--2726494cca344d5ab082c6a53b517798 b0c873a760704b8e9e7069e6589a006e 2726494cca344d5ab082c6a53b517798--b0c873a760704b8e9e7069e6589a006e db5d29136b4a4b9c99bb43160953a167 b0c873a760704b8e9e7069e6589a006e--db5d29136b4a4b9c99bb43160953a167 570efdd1f5544d5ba359f225faa7bf10 db5d29136b4a4b9c99bb43160953a167--570efdd1f5544d5ba359f225faa7bf10 6092f29443324457a9d5dcfdd7661f45 570efdd1f5544d5ba359f225faa7bf10--6092f29443324457a9d5dcfdd7661f45 bbfbf56852d64d1a93598953b24db163 6092f29443324457a9d5dcfdd7661f45--bbfbf56852d64d1a93598953b24db163 752b27dd0fe2435197e36b39a084a408 bbfbf56852d64d1a93598953b24db163--752b27dd0fe2435197e36b39a084a408 e71c4fe3212b4101891731e0ccc2e79d 752b27dd0fe2435197e36b39a084a408--e71c4fe3212b4101891731e0ccc2e79d 79b512ebc3ac451b89d397e37d7a4473 e71c4fe3212b4101891731e0ccc2e79d--79b512ebc3ac451b89d397e37d7a4473 47537f6cee55405cbfe1ffa30b058e2d 79b512ebc3ac451b89d397e37d7a4473--47537f6cee55405cbfe1ffa30b058e2d b45c67195b064e2980b43d46b42d57dc 47537f6cee55405cbfe1ffa30b058e2d--b45c67195b064e2980b43d46b42d57dc a88040c4e20c4e71ac55c32a8b1955f2 X b45c67195b064e2980b43d46b42d57dc--a88040c4e20c4e71ac55c32a8b1955f2 a88040c4e20c4e71ac55c32a8b1955f2--bac3d239ce014d88b449065fa405e6a3 0fbb46f6350c46b098862eb9642c85b9 a88040c4e20c4e71ac55c32a8b1955f2--0fbb46f6350c46b098862eb9642c85b9 ba45a78f5a794b77bd60cf76d937ee6a 0fbb46f6350c46b098862eb9642c85b9--ba45a78f5a794b77bd60cf76d937ee6a ed9b6aca463047d48151799d83aa09b3 ba45a78f5a794b77bd60cf76d937ee6a--ed9b6aca463047d48151799d83aa09b3 25ede3788b65413b9a7746bcf5ff846c ed9b6aca463047d48151799d83aa09b3--25ede3788b65413b9a7746bcf5ff846c 21a12d7dc3c8496085427b526b8aaf7c 25ede3788b65413b9a7746bcf5ff846c--21a12d7dc3c8496085427b526b8aaf7c 98c2f3e57ffd40efbbef230bab18e30d X 21a12d7dc3c8496085427b526b8aaf7c--98c2f3e57ffd40efbbef230bab18e30d 98c2f3e57ffd40efbbef230bab18e30d--59c6608bdde345ada196e5251d6af8e3 2232b5ca7d91494abed15b18083dcab2 98c2f3e57ffd40efbbef230bab18e30d--2232b5ca7d91494abed15b18083dcab2 d6ffb240c3954c52b75896a0ea5ef132 2232b5ca7d91494abed15b18083dcab2--d6ffb240c3954c52b75896a0ea5ef132 b8cf1a9a436b4750bfe87a30691ab6d9 d6ffb240c3954c52b75896a0ea5ef132--b8cf1a9a436b4750bfe87a30691ab6d9 ec7aedef37ab41f79d8293a30f5dca64 X b8cf1a9a436b4750bfe87a30691ab6d9--ec7aedef37ab41f79d8293a30f5dca64 ec7aedef37ab41f79d8293a30f5dca64--8dcddc733aa74d2eb36d56ba17e55e63 2fb7b936990549b4b5de1bea9be3f399 ec7aedef37ab41f79d8293a30f5dca64--2fb7b936990549b4b5de1bea9be3f399 f0397ad219ab4a4587590ada1afb2d04 2fb7b936990549b4b5de1bea9be3f399--f0397ad219ab4a4587590ada1afb2d04 8d3991b55bf84789865e77908c6f9c2e X f0397ad219ab4a4587590ada1afb2d04--8d3991b55bf84789865e77908c6f9c2e 8d3991b55bf84789865e77908c6f9c2e--d9ce4537e711451886f36688c7a9a775 8c02a34d2c26488292e33bfc573840e5 8d3991b55bf84789865e77908c6f9c2e--8c02a34d2c26488292e33bfc573840e5 8c59e4744d6b469fa4ba789e7a432c56 8c02a34d2c26488292e33bfc573840e5--8c59e4744d6b469fa4ba789e7a432c56 d87fd1fac3f944d1b5ab1fddf214f6ea 8c59e4744d6b469fa4ba789e7a432c56--d87fd1fac3f944d1b5ab1fddf214f6ea 410b592c95fa4f7eb2a93ef2443b674a d87fd1fac3f944d1b5ab1fddf214f6ea--410b592c95fa4f7eb2a93ef2443b674a 44ee589f228c4962a7191df0041327e5 410b592c95fa4f7eb2a93ef2443b674a--44ee589f228c4962a7191df0041327e5 8e8d634a82424fafbef3b10a44d80f54 X 44ee589f228c4962a7191df0041327e5--8e8d634a82424fafbef3b10a44d80f54 8e8d634a82424fafbef3b10a44d80f54--a256b270759e46058ed583eefcd3a240 f0d08a8e21834d6bb5896ecdee1a5194 8e8d634a82424fafbef3b10a44d80f54--f0d08a8e21834d6bb5896ecdee1a5194 ad24b0d1c4c14388a72e934c3a375131 f0d08a8e21834d6bb5896ecdee1a5194--ad24b0d1c4c14388a72e934c3a375131 f281c53523c54d98acbf05db852a1c67 X ad24b0d1c4c14388a72e934c3a375131--f281c53523c54d98acbf05db852a1c67 f281c53523c54d98acbf05db852a1c67--ac8f9db63b554851a52bf8a6f98c26d4 36d6e32c048b46baa4448f1560bcdee0 f281c53523c54d98acbf05db852a1c67--36d6e32c048b46baa4448f1560bcdee0 777dcf146128453a8f12afc5c8335921 36d6e32c048b46baa4448f1560bcdee0--777dcf146128453a8f12afc5c8335921 1fb6ae17f0ef4d56896e9b2148b2ba7c 777dcf146128453a8f12afc5c8335921--1fb6ae17f0ef4d56896e9b2148b2ba7c 404f856cfaeb454284fafc8c52d96833 1fb6ae17f0ef4d56896e9b2148b2ba7c--404f856cfaeb454284fafc8c52d96833 d77a8e43fa754f19b2195fc66d6b5200 404f856cfaeb454284fafc8c52d96833--d77a8e43fa754f19b2195fc66d6b5200 86674608e31a4ea8ba54552fba912899 d77a8e43fa754f19b2195fc66d6b5200--86674608e31a4ea8ba54552fba912899 63f46106e8bf44e795c7c03e3f335931 86674608e31a4ea8ba54552fba912899--63f46106e8bf44e795c7c03e3f335931 df12a54f4f2c4957b5a0e253f9d9ebc9 X 63f46106e8bf44e795c7c03e3f335931--df12a54f4f2c4957b5a0e253f9d9ebc9 df12a54f4f2c4957b5a0e253f9d9ebc9--881d0e0bf2ce451688797525e843d588 a440a819afb6408ea5e9b690a0997b94 df12a54f4f2c4957b5a0e253f9d9ebc9--a440a819afb6408ea5e9b690a0997b94 b76193e00e8d48e182086ac000e70d5e a440a819afb6408ea5e9b690a0997b94--b76193e00e8d48e182086ac000e70d5e 5b04706a1d7249e0a38e7726e4b42a9f X b76193e00e8d48e182086ac000e70d5e--5b04706a1d7249e0a38e7726e4b42a9f 5b04706a1d7249e0a38e7726e4b42a9f--855c6a3b34614acfa53673f927f7a38e 665a7869b5e34a5ba36816749cf22af9 5b04706a1d7249e0a38e7726e4b42a9f--665a7869b5e34a5ba36816749cf22af9 be949de9130d4ace8a9bb00a8b078444 665a7869b5e34a5ba36816749cf22af9--be949de9130d4ace8a9bb00a8b078444 37a64f760e93453185b32f884bc200f1 be949de9130d4ace8a9bb00a8b078444--37a64f760e93453185b32f884bc200f1 812a08f39c684909bfdd3319c472ea1a 37a64f760e93453185b32f884bc200f1--812a08f39c684909bfdd3319c472ea1a 964dfe9ebd154072a22cca9dc53ba0bc 812a08f39c684909bfdd3319c472ea1a--964dfe9ebd154072a22cca9dc53ba0bc db2449a936114d5db4a6d8aac4860e3f 964dfe9ebd154072a22cca9dc53ba0bc--db2449a936114d5db4a6d8aac4860e3f f139cc8b79b642fcac1d2e78592fc982 db2449a936114d5db4a6d8aac4860e3f--f139cc8b79b642fcac1d2e78592fc982 6bb8ce75278940419d248946ad58f6bc f139cc8b79b642fcac1d2e78592fc982--6bb8ce75278940419d248946ad58f6bc 65cc60c48abb468b8dadbe2011df172e 6bb8ce75278940419d248946ad58f6bc--65cc60c48abb468b8dadbe2011df172e c403dcd7ef164c35859f308d804d734a X 65cc60c48abb468b8dadbe2011df172e--c403dcd7ef164c35859f308d804d734a c403dcd7ef164c35859f308d804d734a--a4ed082b971344a8ade70ae95b67b0fd 520082bb3a5742968dfbc3711d784673 c403dcd7ef164c35859f308d804d734a--520082bb3a5742968dfbc3711d784673 472112ffdf2b4ee7bf8c3945e7e88e9e X 520082bb3a5742968dfbc3711d784673--472112ffdf2b4ee7bf8c3945e7e88e9e 472112ffdf2b4ee7bf8c3945e7e88e9e--a931d32643134c13b0e41167cea70744 2f7bf6f587a24aa3ac5ddba7d1c55696 472112ffdf2b4ee7bf8c3945e7e88e9e--2f7bf6f587a24aa3ac5ddba7d1c55696 28e9cb3b0cbc44d5899cdcf5b53c2505 2f7bf6f587a24aa3ac5ddba7d1c55696--28e9cb3b0cbc44d5899cdcf5b53c2505 409ff2b3b98344349357fe41dc07e06b 28e9cb3b0cbc44d5899cdcf5b53c2505--409ff2b3b98344349357fe41dc07e06b 8c80b39f447a46ab9ec0f468c31876ee 409ff2b3b98344349357fe41dc07e06b--8c80b39f447a46ab9ec0f468c31876ee d7752c6e84e242b18ae7fca61b8d9b49 8c80b39f447a46ab9ec0f468c31876ee--d7752c6e84e242b18ae7fca61b8d9b49 de70ca94f6614594a5b234c33d576130 d7752c6e84e242b18ae7fca61b8d9b49--de70ca94f6614594a5b234c33d576130 528c545b28dd4f3fb9d9a620f886e6a0 de70ca94f6614594a5b234c33d576130--528c545b28dd4f3fb9d9a620f886e6a0 847dae63475546849343ea9e277d1bc2 528c545b28dd4f3fb9d9a620f886e6a0--847dae63475546849343ea9e277d1bc2 0bf705e694994fe8b837cea38f68e974 847dae63475546849343ea9e277d1bc2--0bf705e694994fe8b837cea38f68e974 d899d4335bd94186b4ecbf65f17d9345 X 0bf705e694994fe8b837cea38f68e974--d899d4335bd94186b4ecbf65f17d9345 d899d4335bd94186b4ecbf65f17d9345--15e73360733b420abe6dc2e1b5d5592f 4eff0b0c557747d69308b834770ea3ec d899d4335bd94186b4ecbf65f17d9345--4eff0b0c557747d69308b834770ea3ec 356784c76547451b973edfbc51320c54 4eff0b0c557747d69308b834770ea3ec--356784c76547451b973edfbc51320c54 c1e9a21e41ac4d69ba9a017ee987bf8c 356784c76547451b973edfbc51320c54--c1e9a21e41ac4d69ba9a017ee987bf8c 8432f03d0f694976983970505b60ee10 c1e9a21e41ac4d69ba9a017ee987bf8c--8432f03d0f694976983970505b60ee10 50d7727a9c284e2cb811cfa9f82914aa 8432f03d0f694976983970505b60ee10--50d7727a9c284e2cb811cfa9f82914aa 6ef12a67fa3b4826ba5411fcbdee42d0 50d7727a9c284e2cb811cfa9f82914aa--6ef12a67fa3b4826ba5411fcbdee42d0 ae2d88fc3ca94646aca8e9d9b1bfd19d 6ef12a67fa3b4826ba5411fcbdee42d0--ae2d88fc3ca94646aca8e9d9b1bfd19d 3f1d1cc874324204af4df87d3cb1b599 ae2d88fc3ca94646aca8e9d9b1bfd19d--3f1d1cc874324204af4df87d3cb1b599 bdbca175670e4a71b14f203e4819d1bd 3f1d1cc874324204af4df87d3cb1b599--bdbca175670e4a71b14f203e4819d1bd c071751694754e52bc5bc50e7592c684 bdbca175670e4a71b14f203e4819d1bd--c071751694754e52bc5bc50e7592c684 e7312c7ddfa1422a88bb4d86033c0bad c071751694754e52bc5bc50e7592c684--e7312c7ddfa1422a88bb4d86033c0bad 68ac47759de94aac9755a0e301e8c7b2 e7312c7ddfa1422a88bb4d86033c0bad--68ac47759de94aac9755a0e301e8c7b2 d25cad002d1e4443a1dbeaa95528bfbd 68ac47759de94aac9755a0e301e8c7b2--d25cad002d1e4443a1dbeaa95528bfbd c7a9f7202ea543e7b716eef8a9863b9a d25cad002d1e4443a1dbeaa95528bfbd--c7a9f7202ea543e7b716eef8a9863b9a c8ae0546ae854c7fa3deee454b80301e c7a9f7202ea543e7b716eef8a9863b9a--c8ae0546ae854c7fa3deee454b80301e 6b9594b0f0c74f769d509b5b20359a07 c8ae0546ae854c7fa3deee454b80301e--6b9594b0f0c74f769d509b5b20359a07 063692853f314889bcc99c8cd39a7ef0 6b9594b0f0c74f769d509b5b20359a07--063692853f314889bcc99c8cd39a7ef0 8b74338ebae74064934ef931b1d763c3 063692853f314889bcc99c8cd39a7ef0--8b74338ebae74064934ef931b1d763c3 07fc424c9e7c48039878cdd091e33c44 8b74338ebae74064934ef931b1d763c3--07fc424c9e7c48039878cdd091e33c44 a75bed5f10204702b01c33b8e0143339 07fc424c9e7c48039878cdd091e33c44--a75bed5f10204702b01c33b8e0143339 535dbe1a4cd14cf0962fa8d01d305bb9 a75bed5f10204702b01c33b8e0143339--535dbe1a4cd14cf0962fa8d01d305bb9 7990553974f046f9be66e3e5abf7b83a 535dbe1a4cd14cf0962fa8d01d305bb9--7990553974f046f9be66e3e5abf7b83a d7516f5f56fe4311a2f3c9bafe153767 7990553974f046f9be66e3e5abf7b83a--d7516f5f56fe4311a2f3c9bafe153767 24cb66cc813640b29eafc196064373db d7516f5f56fe4311a2f3c9bafe153767--24cb66cc813640b29eafc196064373db e63781d81ed8438e88eda6d2490f443e 24cb66cc813640b29eafc196064373db--e63781d81ed8438e88eda6d2490f443e 2aa651396a08412e842c7f0f14ec43f5 e63781d81ed8438e88eda6d2490f443e--2aa651396a08412e842c7f0f14ec43f5 7df75977b78f4c9899dec9837e58da4b 2aa651396a08412e842c7f0f14ec43f5--7df75977b78f4c9899dec9837e58da4b 73f563a1750b4087819f0348a60a4e36 7df75977b78f4c9899dec9837e58da4b--73f563a1750b4087819f0348a60a4e36 c9dc1ab516c440f895a811fd724bc63e 73f563a1750b4087819f0348a60a4e36--c9dc1ab516c440f895a811fd724bc63e 7fb839790b9347d99e1985019803daec c9dc1ab516c440f895a811fd724bc63e--7fb839790b9347d99e1985019803daec 999b5dea73ce47b2a5a9e0c411394ec6 7fb839790b9347d99e1985019803daec--999b5dea73ce47b2a5a9e0c411394ec6 b870b29493984235ade31ae35d692bf3 999b5dea73ce47b2a5a9e0c411394ec6--b870b29493984235ade31ae35d692bf3 217a1a7a431145c285ff7864e2cdc4f0 b870b29493984235ade31ae35d692bf3--217a1a7a431145c285ff7864e2cdc4f0 ae6d9ec5a1e34034aa76bf1d8f9f9c4f 217a1a7a431145c285ff7864e2cdc4f0--ae6d9ec5a1e34034aa76bf1d8f9f9c4f 13d81ef8c00f4a86b15bff88bebe0299 ae6d9ec5a1e34034aa76bf1d8f9f9c4f--13d81ef8c00f4a86b15bff88bebe0299 77173c59cbed4b22b62ef682f5d2d346 13d81ef8c00f4a86b15bff88bebe0299--77173c59cbed4b22b62ef682f5d2d346 07626b5e2ae2429d9c4135dda7b6e9b3 77173c59cbed4b22b62ef682f5d2d346--07626b5e2ae2429d9c4135dda7b6e9b3 c80a89b65e5547ba8b720a0d0f222a52 07626b5e2ae2429d9c4135dda7b6e9b3--c80a89b65e5547ba8b720a0d0f222a52 31e2013e5cbb495cbf77d0f40cfd907a c80a89b65e5547ba8b720a0d0f222a52--31e2013e5cbb495cbf77d0f40cfd907a f2ef2c97c7d040758f0675a41ec5cc0e 31e2013e5cbb495cbf77d0f40cfd907a--f2ef2c97c7d040758f0675a41ec5cc0e 013c138e84f44b00b31ce156eb842b06 f2ef2c97c7d040758f0675a41ec5cc0e--013c138e84f44b00b31ce156eb842b06 c96d84d4f23f40b9a14d287e34ddadd1 013c138e84f44b00b31ce156eb842b06--c96d84d4f23f40b9a14d287e34ddadd1 2bda561a07af476592c7b860ad970924 c96d84d4f23f40b9a14d287e34ddadd1--2bda561a07af476592c7b860ad970924 4ff30e8a012c40ac99f59375a016341a RX(b12) 2bda561a07af476592c7b860ad970924--4ff30e8a012c40ac99f59375a016341a 4ff30e8a012c40ac99f59375a016341a--59bf168a68ed4e218c586162d865ecb1 03ca210c12514cd285f920c55fa90bbc 171d869a1ed8425086f0e03a3bb3350d ba34424c519a41bb856d7b1bfdaeecca--171d869a1ed8425086f0e03a3bb3350d bdb66801f4d34dbabeeea227ae547f22 4 e4c56ace6f2b4ec5a1db00a08019ed1c 171d869a1ed8425086f0e03a3bb3350d--e4c56ace6f2b4ec5a1db00a08019ed1c a9894463d20447efae10fe692a6a69a4 X e4c56ace6f2b4ec5a1db00a08019ed1c--a9894463d20447efae10fe692a6a69a4 a9894463d20447efae10fe692a6a69a4--b9b944944bca4a1a905f2ca90bb39347 a2391078b9e149dc97423708976588ea a9894463d20447efae10fe692a6a69a4--a2391078b9e149dc97423708976588ea b8402bd0c0f8448abd7a17abd7c95de4 a2391078b9e149dc97423708976588ea--b8402bd0c0f8448abd7a17abd7c95de4 88d9fafeecfc4c16b1eea9eca6be3848 b8402bd0c0f8448abd7a17abd7c95de4--88d9fafeecfc4c16b1eea9eca6be3848 ea7697d4714b4c2e897f39049f326720 88d9fafeecfc4c16b1eea9eca6be3848--ea7697d4714b4c2e897f39049f326720 63a9b914ceec407d8af5156f383df808 ea7697d4714b4c2e897f39049f326720--63a9b914ceec407d8af5156f383df808 93fa8d294f9c477380a29799698ddac4 63a9b914ceec407d8af5156f383df808--93fa8d294f9c477380a29799698ddac4 3cdb9ad605e043e983da9dd65c86cc98 93fa8d294f9c477380a29799698ddac4--3cdb9ad605e043e983da9dd65c86cc98 db21d90613fa49dcb6f77b6842d10749 3cdb9ad605e043e983da9dd65c86cc98--db21d90613fa49dcb6f77b6842d10749 f3d00acb2b344de6833caede981bf961 db21d90613fa49dcb6f77b6842d10749--f3d00acb2b344de6833caede981bf961 5d12910ac1e34490812857e97c0f8054 X f3d00acb2b344de6833caede981bf961--5d12910ac1e34490812857e97c0f8054 5d12910ac1e34490812857e97c0f8054--8ede29659fb34dc297f5ccd8d1cc76ec 3a14c378241c4aa48d2da1cdc68db745 5d12910ac1e34490812857e97c0f8054--3a14c378241c4aa48d2da1cdc68db745 9f32dc192af4444bbea5217b1d6cf57e 3a14c378241c4aa48d2da1cdc68db745--9f32dc192af4444bbea5217b1d6cf57e f075eb93df57493abc043a52313d4ee1 9f32dc192af4444bbea5217b1d6cf57e--f075eb93df57493abc043a52313d4ee1 3b42e9b7c7f1484d86bfcc11e17b73e9 f075eb93df57493abc043a52313d4ee1--3b42e9b7c7f1484d86bfcc11e17b73e9 174aa3a163b244d18a7d1a1ee819887b 3b42e9b7c7f1484d86bfcc11e17b73e9--174aa3a163b244d18a7d1a1ee819887b 71db6962079041069b670043feb941d2 174aa3a163b244d18a7d1a1ee819887b--71db6962079041069b670043feb941d2 9721b1d2c383453e9d912bb14b7fc562 71db6962079041069b670043feb941d2--9721b1d2c383453e9d912bb14b7fc562 129a29ed8e334990b191cd9791a32f4e X 9721b1d2c383453e9d912bb14b7fc562--129a29ed8e334990b191cd9791a32f4e 129a29ed8e334990b191cd9791a32f4e--1c5e316a99004456b82c8710f297681d fe6044e30f274e659610ee17a8f33d0a RZ(-1.0*g0) 129a29ed8e334990b191cd9791a32f4e--fe6044e30f274e659610ee17a8f33d0a bcac28e30f5042b185538f66085fff95 X fe6044e30f274e659610ee17a8f33d0a--bcac28e30f5042b185538f66085fff95 bcac28e30f5042b185538f66085fff95--95b78aec5d7549f98c16d0fd52ceabab 8bfc6a707c1740f0ba359d587362c17f bcac28e30f5042b185538f66085fff95--8bfc6a707c1740f0ba359d587362c17f ec5c5aa1000a4bf29142a7e2ee9ca512 8bfc6a707c1740f0ba359d587362c17f--ec5c5aa1000a4bf29142a7e2ee9ca512 41347ffe9e7b4cb9b0263931a1bf13fd ec5c5aa1000a4bf29142a7e2ee9ca512--41347ffe9e7b4cb9b0263931a1bf13fd 3962d4850cb44076bd7816b3758ddad0 41347ffe9e7b4cb9b0263931a1bf13fd--3962d4850cb44076bd7816b3758ddad0 17acdae275d846e08b2acf92d84ec65c X 3962d4850cb44076bd7816b3758ddad0--17acdae275d846e08b2acf92d84ec65c 17acdae275d846e08b2acf92d84ec65c--5eafa58c0b944455bd337162cc434f2a 102891217d5147afa63eaf1b77d0619a 17acdae275d846e08b2acf92d84ec65c--102891217d5147afa63eaf1b77d0619a 96a7b186a9a24781bfc7c2c57af4352c 102891217d5147afa63eaf1b77d0619a--96a7b186a9a24781bfc7c2c57af4352c 7893f209f98e469882501b2118a729c0 96a7b186a9a24781bfc7c2c57af4352c--7893f209f98e469882501b2118a729c0 d7fd4f28534b4a0fa3dccb9f19ab8aea X 7893f209f98e469882501b2118a729c0--d7fd4f28534b4a0fa3dccb9f19ab8aea d7fd4f28534b4a0fa3dccb9f19ab8aea--34f7744a36964948b9bb27dff6b421af 2248c924225c4ccd890bee2d4b6214e9 d7fd4f28534b4a0fa3dccb9f19ab8aea--2248c924225c4ccd890bee2d4b6214e9 ff71a248fb9b4bb9af25e96bd16712c6 2248c924225c4ccd890bee2d4b6214e9--ff71a248fb9b4bb9af25e96bd16712c6 f7330c972a004e02853dbe800d89ac7b ff71a248fb9b4bb9af25e96bd16712c6--f7330c972a004e02853dbe800d89ac7b 5708eea6463b4d5e8ebf9d12c0fcd255 f7330c972a004e02853dbe800d89ac7b--5708eea6463b4d5e8ebf9d12c0fcd255 dc2ffbee17514f96a60fe27e29e64a55 X 5708eea6463b4d5e8ebf9d12c0fcd255--dc2ffbee17514f96a60fe27e29e64a55 dc2ffbee17514f96a60fe27e29e64a55--1e088aaeb04145a7b5884241c33f2dc5 f4ce4d271d3f4f5eb96720a937104d17 dc2ffbee17514f96a60fe27e29e64a55--f4ce4d271d3f4f5eb96720a937104d17 f2e46bc509a54f2ea235ba0326b99e6d f4ce4d271d3f4f5eb96720a937104d17--f2e46bc509a54f2ea235ba0326b99e6d b952adefa7ec4a7b960370ee18f58bd9 f2e46bc509a54f2ea235ba0326b99e6d--b952adefa7ec4a7b960370ee18f58bd9 5cd771ea52fb444c84eac9f344c2a435 b952adefa7ec4a7b960370ee18f58bd9--5cd771ea52fb444c84eac9f344c2a435 6ab11866669446dbb3da39cabcbecb6b 5cd771ea52fb444c84eac9f344c2a435--6ab11866669446dbb3da39cabcbecb6b 7986b2b161d14450b892de2f5c5578aa X 6ab11866669446dbb3da39cabcbecb6b--7986b2b161d14450b892de2f5c5578aa 7986b2b161d14450b892de2f5c5578aa--2da2de5701da43d2b9a4650581555f4e cbccfc16179249b5b5945219ab41cdea 7986b2b161d14450b892de2f5c5578aa--cbccfc16179249b5b5945219ab41cdea 2fba30cb5d2e42c989181cf086747f4c cbccfc16179249b5b5945219ab41cdea--2fba30cb5d2e42c989181cf086747f4c f3e40fa189ee4b949ae92b1b9a83fc3a 2fba30cb5d2e42c989181cf086747f4c--f3e40fa189ee4b949ae92b1b9a83fc3a ef5599663b3642c3b16eff2a2edff507 f3e40fa189ee4b949ae92b1b9a83fc3a--ef5599663b3642c3b16eff2a2edff507 aa844eb3873c4e5f9e845e6c07d98789 X ef5599663b3642c3b16eff2a2edff507--aa844eb3873c4e5f9e845e6c07d98789 aa844eb3873c4e5f9e845e6c07d98789--3792037d5ad84d0c8f61351d434563ec 2ff5e5e428d444959f6bb7da2b0b7ede aa844eb3873c4e5f9e845e6c07d98789--2ff5e5e428d444959f6bb7da2b0b7ede d6d217a4fbe74e0a9c43d58498c5a2c5 2ff5e5e428d444959f6bb7da2b0b7ede--d6d217a4fbe74e0a9c43d58498c5a2c5 4fd994b348414f75b219740d8a322cb6 d6d217a4fbe74e0a9c43d58498c5a2c5--4fd994b348414f75b219740d8a322cb6 66a58b77519e4b23a5b184f358dd5b22 4fd994b348414f75b219740d8a322cb6--66a58b77519e4b23a5b184f358dd5b22 4d635b3e94de480fb6ad6d17fb50decf 66a58b77519e4b23a5b184f358dd5b22--4d635b3e94de480fb6ad6d17fb50decf d05a88a6eb814050bb498abfc5444f88 4d635b3e94de480fb6ad6d17fb50decf--d05a88a6eb814050bb498abfc5444f88 12629bb58d124683a336d96a9364b0f7 d05a88a6eb814050bb498abfc5444f88--12629bb58d124683a336d96a9364b0f7 aeca3dc3d8ad4514b6ad2db1a36bea2d X 12629bb58d124683a336d96a9364b0f7--aeca3dc3d8ad4514b6ad2db1a36bea2d aeca3dc3d8ad4514b6ad2db1a36bea2d--1c43df9f6b9c4ea2886d59e46c701672 4415a3e88f3c42d9b789ad904c1a3e3f aeca3dc3d8ad4514b6ad2db1a36bea2d--4415a3e88f3c42d9b789ad904c1a3e3f f655cc96912a4577a4de55c25f29465d 4415a3e88f3c42d9b789ad904c1a3e3f--f655cc96912a4577a4de55c25f29465d 603c8f73287043d5acb5420027463543 f655cc96912a4577a4de55c25f29465d--603c8f73287043d5acb5420027463543 edc3eea93952458fbe58fb4c302a6778 X 603c8f73287043d5acb5420027463543--edc3eea93952458fbe58fb4c302a6778 edc3eea93952458fbe58fb4c302a6778--931cf21275714cacbeefe734ba90cfa5 ae2e79503bbc4749aa7f11df5fc18d21 edc3eea93952458fbe58fb4c302a6778--ae2e79503bbc4749aa7f11df5fc18d21 23f2f407befc4ed9bac6e436a8e25171 ae2e79503bbc4749aa7f11df5fc18d21--23f2f407befc4ed9bac6e436a8e25171 98a909df141340009f53dbbac97cb47f 23f2f407befc4ed9bac6e436a8e25171--98a909df141340009f53dbbac97cb47f 28bb6891571743d9bab2a712e31306b2 98a909df141340009f53dbbac97cb47f--28bb6891571743d9bab2a712e31306b2 707ad182e4cc4222b4bf63560b005d17 28bb6891571743d9bab2a712e31306b2--707ad182e4cc4222b4bf63560b005d17 f1a5258070d44736827d597fa3893541 707ad182e4cc4222b4bf63560b005d17--f1a5258070d44736827d597fa3893541 2e119b83ece74e1ba19c9b8333e5b41c f1a5258070d44736827d597fa3893541--2e119b83ece74e1ba19c9b8333e5b41c 9c4409b3c14f4d74a325b33b6b9cdb81 X 2e119b83ece74e1ba19c9b8333e5b41c--9c4409b3c14f4d74a325b33b6b9cdb81 9c4409b3c14f4d74a325b33b6b9cdb81--ff81c464a5964845b2536363248fe84c 35addd504a7c438fa7ae8b0a8f1947cf 9c4409b3c14f4d74a325b33b6b9cdb81--35addd504a7c438fa7ae8b0a8f1947cf e9e83bc1a8a44b699e626e94e6c36c86 X 35addd504a7c438fa7ae8b0a8f1947cf--e9e83bc1a8a44b699e626e94e6c36c86 e9e83bc1a8a44b699e626e94e6c36c86--8945f9babb134bcda09cb653803853d1 956464f39fb14cdc91847705ea8b14c9 RZ(-1.0*g0) e9e83bc1a8a44b699e626e94e6c36c86--956464f39fb14cdc91847705ea8b14c9 affa1a5a53a24a38a5dac25ca32c1fcd X 956464f39fb14cdc91847705ea8b14c9--affa1a5a53a24a38a5dac25ca32c1fcd affa1a5a53a24a38a5dac25ca32c1fcd--c65623437e7c4c89965a02aaf59877c5 5e9f33e036d84089a7df6224a9b6819c X affa1a5a53a24a38a5dac25ca32c1fcd--5e9f33e036d84089a7df6224a9b6819c 5e9f33e036d84089a7df6224a9b6819c--e6dc1fedf9ba4212ba50ece4a1d81f8d 0a4ca4c446aa408487b0072faeb1e9ac 5e9f33e036d84089a7df6224a9b6819c--0a4ca4c446aa408487b0072faeb1e9ac 776954bdea32475b97c580c6d04a46ad 0a4ca4c446aa408487b0072faeb1e9ac--776954bdea32475b97c580c6d04a46ad 9af245cc85314f55886940f18b77ba23 776954bdea32475b97c580c6d04a46ad--9af245cc85314f55886940f18b77ba23 6b25dc9b00674def9299751abcaae472 X 9af245cc85314f55886940f18b77ba23--6b25dc9b00674def9299751abcaae472 6b25dc9b00674def9299751abcaae472--587414cfc7d8463885e1e9d02e9b15d7 ad5434de6b884291af24c473f2ca3c8f X 6b25dc9b00674def9299751abcaae472--ad5434de6b884291af24c473f2ca3c8f ad5434de6b884291af24c473f2ca3c8f--96f60d1524604a4cb347721f591555f2 8168afa7fbe9449ba52f5c53ac620f42 ad5434de6b884291af24c473f2ca3c8f--8168afa7fbe9449ba52f5c53ac620f42 193dacf49767459898e0376935694c44 8168afa7fbe9449ba52f5c53ac620f42--193dacf49767459898e0376935694c44 a4db78f8f2c145cd9148cd63ca0352cd 193dacf49767459898e0376935694c44--a4db78f8f2c145cd9148cd63ca0352cd c54c617de3d44077aa14b4afe521b45d a4db78f8f2c145cd9148cd63ca0352cd--c54c617de3d44077aa14b4afe521b45d 565892ea60b94c29929ebb3a927f4e3a c54c617de3d44077aa14b4afe521b45d--565892ea60b94c29929ebb3a927f4e3a e3b772eecc3d48bbba22fbc70bfcdc2b 565892ea60b94c29929ebb3a927f4e3a--e3b772eecc3d48bbba22fbc70bfcdc2b 5da0460361334862902361f546ff37c1 e3b772eecc3d48bbba22fbc70bfcdc2b--5da0460361334862902361f546ff37c1 07682b9227ef43c884dfb1d49fd9ec4a X 5da0460361334862902361f546ff37c1--07682b9227ef43c884dfb1d49fd9ec4a 07682b9227ef43c884dfb1d49fd9ec4a--1e61736102b149d880bfd906d38c3910 41eb777c63b944349aa7c6b66cec26cc X 07682b9227ef43c884dfb1d49fd9ec4a--41eb777c63b944349aa7c6b66cec26cc 41eb777c63b944349aa7c6b66cec26cc--e721459e1b184bdea7155e597b9fc2c1 2cd2ab83b27c44bb82fa0919cc5bbe42 41eb777c63b944349aa7c6b66cec26cc--2cd2ab83b27c44bb82fa0919cc5bbe42 4626ea5e423c4ebf9c7589b1c9b5d793 2cd2ab83b27c44bb82fa0919cc5bbe42--4626ea5e423c4ebf9c7589b1c9b5d793 6e5726ea1b6b4b7e8598f5b6a95240df 4626ea5e423c4ebf9c7589b1c9b5d793--6e5726ea1b6b4b7e8598f5b6a95240df d896ba933ab94ad29fb24ea9e61000ea 6e5726ea1b6b4b7e8598f5b6a95240df--d896ba933ab94ad29fb24ea9e61000ea a59815b4c1a34297b18cbd5d26baae2d d896ba933ab94ad29fb24ea9e61000ea--a59815b4c1a34297b18cbd5d26baae2d 707e07ff6ed14322889b14ef6182d3cb a59815b4c1a34297b18cbd5d26baae2d--707e07ff6ed14322889b14ef6182d3cb 9e1cacc3d4cb418092c95512a12165b7 707e07ff6ed14322889b14ef6182d3cb--9e1cacc3d4cb418092c95512a12165b7 b8a70354a02343e9aa0b52fd0ea8f813 9e1cacc3d4cb418092c95512a12165b7--b8a70354a02343e9aa0b52fd0ea8f813 2b321deeb06d4238b43604a33d3a8e6f b8a70354a02343e9aa0b52fd0ea8f813--2b321deeb06d4238b43604a33d3a8e6f 4ec8dd6fdf7847e5b2dc755087c368a5 X 2b321deeb06d4238b43604a33d3a8e6f--4ec8dd6fdf7847e5b2dc755087c368a5 4ec8dd6fdf7847e5b2dc755087c368a5--b3b2d07e326e4d0fa8e19cef7feb6f0c aca61b5381dc4b23b5577bb99f14ce9e 4ec8dd6fdf7847e5b2dc755087c368a5--aca61b5381dc4b23b5577bb99f14ce9e 333098425d56483d9fa326f8f7e92b37 aca61b5381dc4b23b5577bb99f14ce9e--333098425d56483d9fa326f8f7e92b37 56405058113542a9ba8fed9c5f9401d1 333098425d56483d9fa326f8f7e92b37--56405058113542a9ba8fed9c5f9401d1 c035d17c9c994451bb4090b4c0652e83 56405058113542a9ba8fed9c5f9401d1--c035d17c9c994451bb4090b4c0652e83 007b84f1e8e641e5af2d533ac2c2a962 c035d17c9c994451bb4090b4c0652e83--007b84f1e8e641e5af2d533ac2c2a962 be8822aa099e4f6c92f74c76e15671d3 007b84f1e8e641e5af2d533ac2c2a962--be8822aa099e4f6c92f74c76e15671d3 26f03f47bff1482cbc70080397acdf92 be8822aa099e4f6c92f74c76e15671d3--26f03f47bff1482cbc70080397acdf92 a350b6f0ef37472690b67b392ff8c513 26f03f47bff1482cbc70080397acdf92--a350b6f0ef37472690b67b392ff8c513 b1e416b269dd47ed876ff2b8d5def75d a350b6f0ef37472690b67b392ff8c513--b1e416b269dd47ed876ff2b8d5def75d 7030e9014d6d49799c24cc97d46bd95a b1e416b269dd47ed876ff2b8d5def75d--7030e9014d6d49799c24cc97d46bd95a 302a7f15edcd4254833b9523668620a4 7030e9014d6d49799c24cc97d46bd95a--302a7f15edcd4254833b9523668620a4 a7b4f644852b4a4288109b6944384fe8 302a7f15edcd4254833b9523668620a4--a7b4f644852b4a4288109b6944384fe8 c280fce612234f41b38218d5c8476e61 a7b4f644852b4a4288109b6944384fe8--c280fce612234f41b38218d5c8476e61 883749f89dac498a9a2e0495b0a4cde5 c280fce612234f41b38218d5c8476e61--883749f89dac498a9a2e0495b0a4cde5 e6ab206b3f424d89ab1b22791ba533a5 883749f89dac498a9a2e0495b0a4cde5--e6ab206b3f424d89ab1b22791ba533a5 caae869558a4401d94904c39d1cb2924 RX(b03) e6ab206b3f424d89ab1b22791ba533a5--caae869558a4401d94904c39d1cb2924 63e21eee307342dab0785f47debf512b caae869558a4401d94904c39d1cb2924--63e21eee307342dab0785f47debf512b 60db52b25f1b4ba0b2811433b114d483 63e21eee307342dab0785f47debf512b--60db52b25f1b4ba0b2811433b114d483 1f979e4eccd8449ba888acc1e40c8b65 X 60db52b25f1b4ba0b2811433b114d483--1f979e4eccd8449ba888acc1e40c8b65 1f979e4eccd8449ba888acc1e40c8b65--2726494cca344d5ab082c6a53b517798 6e0907c9fbc947ddb026d067c82f57f8 1f979e4eccd8449ba888acc1e40c8b65--6e0907c9fbc947ddb026d067c82f57f8 f51ef06e943e4f0995802fef42f30c33 6e0907c9fbc947ddb026d067c82f57f8--f51ef06e943e4f0995802fef42f30c33 d57d15fc086a413388eee7691d7e0d9c f51ef06e943e4f0995802fef42f30c33--d57d15fc086a413388eee7691d7e0d9c 93e05245a85e4c568a4356469519c403 d57d15fc086a413388eee7691d7e0d9c--93e05245a85e4c568a4356469519c403 58ede2b29a594cc895f90f9c39a40577 93e05245a85e4c568a4356469519c403--58ede2b29a594cc895f90f9c39a40577 22a02e1346474907ba797d80108b473c 58ede2b29a594cc895f90f9c39a40577--22a02e1346474907ba797d80108b473c 716cd23f2c524f1b81d37bf87f75146d 22a02e1346474907ba797d80108b473c--716cd23f2c524f1b81d37bf87f75146d 2b9e45b807a241d1a97579d825c0146d 716cd23f2c524f1b81d37bf87f75146d--2b9e45b807a241d1a97579d825c0146d dcbfb27063214c29acf3a36d4d090810 2b9e45b807a241d1a97579d825c0146d--dcbfb27063214c29acf3a36d4d090810 9ef043bb012946988981f72c9d399e36 X dcbfb27063214c29acf3a36d4d090810--9ef043bb012946988981f72c9d399e36 9ef043bb012946988981f72c9d399e36--b45c67195b064e2980b43d46b42d57dc ce226dd8a00849d18f84385bd11994f9 9ef043bb012946988981f72c9d399e36--ce226dd8a00849d18f84385bd11994f9 a926c395d7d44fdca3e75bc02e83ee38 ce226dd8a00849d18f84385bd11994f9--a926c395d7d44fdca3e75bc02e83ee38 35b05290824444fbaaa7a716bfb5d578 a926c395d7d44fdca3e75bc02e83ee38--35b05290824444fbaaa7a716bfb5d578 f7a14a59ecd14f4ab533e63ccae47256 35b05290824444fbaaa7a716bfb5d578--f7a14a59ecd14f4ab533e63ccae47256 0dd610de942649d68b0248eabe24d5b4 f7a14a59ecd14f4ab533e63ccae47256--0dd610de942649d68b0248eabe24d5b4 af25a0f8ff994b4ca1e97c6bb50b38ff 0dd610de942649d68b0248eabe24d5b4--af25a0f8ff994b4ca1e97c6bb50b38ff 21baeee84dd64542a309554c5d31b234 af25a0f8ff994b4ca1e97c6bb50b38ff--21baeee84dd64542a309554c5d31b234 e2f3708184234d7d9ba6827c3441bfe2 X 21baeee84dd64542a309554c5d31b234--e2f3708184234d7d9ba6827c3441bfe2 e2f3708184234d7d9ba6827c3441bfe2--2232b5ca7d91494abed15b18083dcab2 16729604307f4ee996270860b3d07633 RZ(-1.0*g1) e2f3708184234d7d9ba6827c3441bfe2--16729604307f4ee996270860b3d07633 17afb1ab78664616aa19f36bf13e5ba3 X 16729604307f4ee996270860b3d07633--17afb1ab78664616aa19f36bf13e5ba3 17afb1ab78664616aa19f36bf13e5ba3--b8cf1a9a436b4750bfe87a30691ab6d9 84c9bf324281406db1b0392ac5b23dc4 17afb1ab78664616aa19f36bf13e5ba3--84c9bf324281406db1b0392ac5b23dc4 9a688521d56f4bbd8475f64685803b9d 84c9bf324281406db1b0392ac5b23dc4--9a688521d56f4bbd8475f64685803b9d 85fcadc7310c4baa81c4dccc869a5ceb 9a688521d56f4bbd8475f64685803b9d--85fcadc7310c4baa81c4dccc869a5ceb b553f168b3394427a03aca69d4b36471 85fcadc7310c4baa81c4dccc869a5ceb--b553f168b3394427a03aca69d4b36471 5aa8266314e54c24a36eec53e3c6ae47 X b553f168b3394427a03aca69d4b36471--5aa8266314e54c24a36eec53e3c6ae47 5aa8266314e54c24a36eec53e3c6ae47--8c02a34d2c26488292e33bfc573840e5 43bb3636b94e4facb451f6db2e17472d 5aa8266314e54c24a36eec53e3c6ae47--43bb3636b94e4facb451f6db2e17472d 44437569bf494fadb367f6b7c81820ab 43bb3636b94e4facb451f6db2e17472d--44437569bf494fadb367f6b7c81820ab ae45dab430924a44ab28634267bee678 44437569bf494fadb367f6b7c81820ab--ae45dab430924a44ab28634267bee678 e7f5bcbc8228465a865131f0623e72c3 X ae45dab430924a44ab28634267bee678--e7f5bcbc8228465a865131f0623e72c3 e7f5bcbc8228465a865131f0623e72c3--44ee589f228c4962a7191df0041327e5 c8697113a6dd4cbb90f1dc1e9151ad9c e7f5bcbc8228465a865131f0623e72c3--c8697113a6dd4cbb90f1dc1e9151ad9c 11f824ecdc0f4cdbb0441813a42e1f3f c8697113a6dd4cbb90f1dc1e9151ad9c--11f824ecdc0f4cdbb0441813a42e1f3f affe97e6d0584a87a30edf7695da92d4 11f824ecdc0f4cdbb0441813a42e1f3f--affe97e6d0584a87a30edf7695da92d4 f9a21918d20b42e4a85bf8835559761c affe97e6d0584a87a30edf7695da92d4--f9a21918d20b42e4a85bf8835559761c 323d89dd83814a3ca9a21f5b25f8f4a1 X f9a21918d20b42e4a85bf8835559761c--323d89dd83814a3ca9a21f5b25f8f4a1 323d89dd83814a3ca9a21f5b25f8f4a1--36d6e32c048b46baa4448f1560bcdee0 85ee6e7c43d64b3bbee0dc62a5acb496 323d89dd83814a3ca9a21f5b25f8f4a1--85ee6e7c43d64b3bbee0dc62a5acb496 17cd997c513849aea0230515d351abd1 85ee6e7c43d64b3bbee0dc62a5acb496--17cd997c513849aea0230515d351abd1 0aeb08434eb34b478e7f03776aa04c4e 17cd997c513849aea0230515d351abd1--0aeb08434eb34b478e7f03776aa04c4e f658ceb4a9af46b08e5a35db9b180631 0aeb08434eb34b478e7f03776aa04c4e--f658ceb4a9af46b08e5a35db9b180631 48f238fce9564d0585a954476cf3de3b f658ceb4a9af46b08e5a35db9b180631--48f238fce9564d0585a954476cf3de3b e7c9e37dadcd496b8857ceb9294c7d0e X 48f238fce9564d0585a954476cf3de3b--e7c9e37dadcd496b8857ceb9294c7d0e e7c9e37dadcd496b8857ceb9294c7d0e--63f46106e8bf44e795c7c03e3f335931 97daa03796e44ef2b2ae27c0f9e4be4e e7c9e37dadcd496b8857ceb9294c7d0e--97daa03796e44ef2b2ae27c0f9e4be4e 698d6a65626f4c94861434ee19c4ff54 97daa03796e44ef2b2ae27c0f9e4be4e--698d6a65626f4c94861434ee19c4ff54 aa599e9351ff4c4ea34de021ae33b8a3 698d6a65626f4c94861434ee19c4ff54--aa599e9351ff4c4ea34de021ae33b8a3 f967d52452934f98a26bdb7ecad3620b aa599e9351ff4c4ea34de021ae33b8a3--f967d52452934f98a26bdb7ecad3620b ab4b8af93cdc4ceaac25644310477b9b X f967d52452934f98a26bdb7ecad3620b--ab4b8af93cdc4ceaac25644310477b9b ab4b8af93cdc4ceaac25644310477b9b--665a7869b5e34a5ba36816749cf22af9 c6746da5204f4b72b5c28385f66ce480 ab4b8af93cdc4ceaac25644310477b9b--c6746da5204f4b72b5c28385f66ce480 8cd3159f0d0748a295861a347aa5e833 c6746da5204f4b72b5c28385f66ce480--8cd3159f0d0748a295861a347aa5e833 88797b241ba749a79200efd7f1b46d90 8cd3159f0d0748a295861a347aa5e833--88797b241ba749a79200efd7f1b46d90 1dae53260dba4fd3b72e8671ed2d5b56 88797b241ba749a79200efd7f1b46d90--1dae53260dba4fd3b72e8671ed2d5b56 e969432628e441b6be2fbc09f3c3dd05 1dae53260dba4fd3b72e8671ed2d5b56--e969432628e441b6be2fbc09f3c3dd05 954bd5443d5241e1b317f4905283bfd0 e969432628e441b6be2fbc09f3c3dd05--954bd5443d5241e1b317f4905283bfd0 1bbea4143f1d439c9fade09a616ab062 954bd5443d5241e1b317f4905283bfd0--1bbea4143f1d439c9fade09a616ab062 c96769710818470a99014cd9567abb8f X 1bbea4143f1d439c9fade09a616ab062--c96769710818470a99014cd9567abb8f c96769710818470a99014cd9567abb8f--65cc60c48abb468b8dadbe2011df172e a86f894aab8c41e486c3057e5b80a4bb c96769710818470a99014cd9567abb8f--a86f894aab8c41e486c3057e5b80a4bb 72585328b8e045fca276353fc67c5450 a86f894aab8c41e486c3057e5b80a4bb--72585328b8e045fca276353fc67c5450 3ed56894d7b344c88fe45f8a7d4234a3 72585328b8e045fca276353fc67c5450--3ed56894d7b344c88fe45f8a7d4234a3 7cc58296a81148be99f36e9148c2618a X 3ed56894d7b344c88fe45f8a7d4234a3--7cc58296a81148be99f36e9148c2618a 7cc58296a81148be99f36e9148c2618a--2f7bf6f587a24aa3ac5ddba7d1c55696 326b9d4b95614fd58a04d01273d564da 7cc58296a81148be99f36e9148c2618a--326b9d4b95614fd58a04d01273d564da f2ea2c02cfa94e6fb3079990d6723f76 326b9d4b95614fd58a04d01273d564da--f2ea2c02cfa94e6fb3079990d6723f76 9a65665f93ba4391802a79931db4a970 f2ea2c02cfa94e6fb3079990d6723f76--9a65665f93ba4391802a79931db4a970 2e243d581d7d4d0f8eaa64729195116a 9a65665f93ba4391802a79931db4a970--2e243d581d7d4d0f8eaa64729195116a 8896b07ffe594531b409804bd2cfac31 2e243d581d7d4d0f8eaa64729195116a--8896b07ffe594531b409804bd2cfac31 0b883c36730442c6a3c0f5d3978ad57e 8896b07ffe594531b409804bd2cfac31--0b883c36730442c6a3c0f5d3978ad57e b913a820488144f7952176b242bba933 0b883c36730442c6a3c0f5d3978ad57e--b913a820488144f7952176b242bba933 dfacaff8cbc446ec8b218069df9f8a4a X b913a820488144f7952176b242bba933--dfacaff8cbc446ec8b218069df9f8a4a dfacaff8cbc446ec8b218069df9f8a4a--0bf705e694994fe8b837cea38f68e974 851183dc33e34cf89ec1acf463ccdba2 dfacaff8cbc446ec8b218069df9f8a4a--851183dc33e34cf89ec1acf463ccdba2 a0e741c4adf9419f9cfbd7b580996069 X 851183dc33e34cf89ec1acf463ccdba2--a0e741c4adf9419f9cfbd7b580996069 a0e741c4adf9419f9cfbd7b580996069--4eff0b0c557747d69308b834770ea3ec 32cc093fe949471aba8d450b069ce158 RZ(-1.0*g1) a0e741c4adf9419f9cfbd7b580996069--32cc093fe949471aba8d450b069ce158 2e56d6879b0044a6be7e961233746241 X 32cc093fe949471aba8d450b069ce158--2e56d6879b0044a6be7e961233746241 2e56d6879b0044a6be7e961233746241--c1e9a21e41ac4d69ba9a017ee987bf8c aaf2c668745f4d2f91dc8e91cc5d7387 X 2e56d6879b0044a6be7e961233746241--aaf2c668745f4d2f91dc8e91cc5d7387 aaf2c668745f4d2f91dc8e91cc5d7387--8432f03d0f694976983970505b60ee10 e3cf111fa9d047b7af4e3ce245c10b1b aaf2c668745f4d2f91dc8e91cc5d7387--e3cf111fa9d047b7af4e3ce245c10b1b de889005a5c745baa929a900d41f96f6 e3cf111fa9d047b7af4e3ce245c10b1b--de889005a5c745baa929a900d41f96f6 908d0ccb15af4ed48238349e238d277b de889005a5c745baa929a900d41f96f6--908d0ccb15af4ed48238349e238d277b bbcef5b64b514196ab9f35a116c5d516 X 908d0ccb15af4ed48238349e238d277b--bbcef5b64b514196ab9f35a116c5d516 bbcef5b64b514196ab9f35a116c5d516--3f1d1cc874324204af4df87d3cb1b599 1fd1c59b81a24c3ba0a376f55beb579e X bbcef5b64b514196ab9f35a116c5d516--1fd1c59b81a24c3ba0a376f55beb579e 1fd1c59b81a24c3ba0a376f55beb579e--bdbca175670e4a71b14f203e4819d1bd d0aa3ba308524d21bb831a8c0c48f715 1fd1c59b81a24c3ba0a376f55beb579e--d0aa3ba308524d21bb831a8c0c48f715 5043439bbc9c4738bfd705d21531f835 d0aa3ba308524d21bb831a8c0c48f715--5043439bbc9c4738bfd705d21531f835 97f66be7403549bcac34357f81cd826a 5043439bbc9c4738bfd705d21531f835--97f66be7403549bcac34357f81cd826a ce4eb5e6cc4f482983f31165a2706ecd 97f66be7403549bcac34357f81cd826a--ce4eb5e6cc4f482983f31165a2706ecd 9699313ab0784c278b02d4b2d366fe98 ce4eb5e6cc4f482983f31165a2706ecd--9699313ab0784c278b02d4b2d366fe98 c3c51f7d2b474487ae7bae4d78dcc075 9699313ab0784c278b02d4b2d366fe98--c3c51f7d2b474487ae7bae4d78dcc075 758ffb6724e44359bddbf9ca27d0cb0b c3c51f7d2b474487ae7bae4d78dcc075--758ffb6724e44359bddbf9ca27d0cb0b 1d79ce23cf874e4998cadb18267780f0 X 758ffb6724e44359bddbf9ca27d0cb0b--1d79ce23cf874e4998cadb18267780f0 1d79ce23cf874e4998cadb18267780f0--063692853f314889bcc99c8cd39a7ef0 7c8e474b1713499c951f7d07120edbe3 X 1d79ce23cf874e4998cadb18267780f0--7c8e474b1713499c951f7d07120edbe3 7c8e474b1713499c951f7d07120edbe3--8b74338ebae74064934ef931b1d763c3 3ca5a61bd8754625b7c94fe441a786b4 7c8e474b1713499c951f7d07120edbe3--3ca5a61bd8754625b7c94fe441a786b4 06d9b503778a48c3ba039529fed52dc4 3ca5a61bd8754625b7c94fe441a786b4--06d9b503778a48c3ba039529fed52dc4 70735314c88349f79e6dbed822578ab5 06d9b503778a48c3ba039529fed52dc4--70735314c88349f79e6dbed822578ab5 306cb371df3446ffa565343837635a6f 70735314c88349f79e6dbed822578ab5--306cb371df3446ffa565343837635a6f 354cba2430e3473e86a43476d4e1b95c 306cb371df3446ffa565343837635a6f--354cba2430e3473e86a43476d4e1b95c 67418748bd5147c08ccfee99c0a65290 354cba2430e3473e86a43476d4e1b95c--67418748bd5147c08ccfee99c0a65290 17abe4a2d25744a6989a846748a35402 67418748bd5147c08ccfee99c0a65290--17abe4a2d25744a6989a846748a35402 038d88f55d8142efa9f2724067504154 17abe4a2d25744a6989a846748a35402--038d88f55d8142efa9f2724067504154 d277830d04354f4cbecb53a65a564bbc 038d88f55d8142efa9f2724067504154--d277830d04354f4cbecb53a65a564bbc 60680fc0c3494e4b9f7ee056adfc40f8 X d277830d04354f4cbecb53a65a564bbc--60680fc0c3494e4b9f7ee056adfc40f8 60680fc0c3494e4b9f7ee056adfc40f8--73f563a1750b4087819f0348a60a4e36 adf4596de18a4c2f879632892f5cbeb1 60680fc0c3494e4b9f7ee056adfc40f8--adf4596de18a4c2f879632892f5cbeb1 6d2b049db551453dbee6b66915f8ec01 adf4596de18a4c2f879632892f5cbeb1--6d2b049db551453dbee6b66915f8ec01 00e446c7810d4898b73a78a9d0d5e238 6d2b049db551453dbee6b66915f8ec01--00e446c7810d4898b73a78a9d0d5e238 e84673e890ef4d52b9c42b29e9f68e62 00e446c7810d4898b73a78a9d0d5e238--e84673e890ef4d52b9c42b29e9f68e62 8795625276ae47daa4e878382fe1be36 e84673e890ef4d52b9c42b29e9f68e62--8795625276ae47daa4e878382fe1be36 90f43d0ba84645fc99f5df40929eed0d 8795625276ae47daa4e878382fe1be36--90f43d0ba84645fc99f5df40929eed0d 2997d0fa2ca04dee943b4b975e917715 90f43d0ba84645fc99f5df40929eed0d--2997d0fa2ca04dee943b4b975e917715 f6070e674fc7470b924579d278168860 2997d0fa2ca04dee943b4b975e917715--f6070e674fc7470b924579d278168860 4f75379b47484b23a4945d947dd54ad4 f6070e674fc7470b924579d278168860--4f75379b47484b23a4945d947dd54ad4 c8a8f6f5f529484abb3efd9753a38fa3 4f75379b47484b23a4945d947dd54ad4--c8a8f6f5f529484abb3efd9753a38fa3 ad0fe10251e2461ca463790e7de8fe3d c8a8f6f5f529484abb3efd9753a38fa3--ad0fe10251e2461ca463790e7de8fe3d 63a594bea2b9438c9685b3a52ad62664 ad0fe10251e2461ca463790e7de8fe3d--63a594bea2b9438c9685b3a52ad62664 fa2f36f01889456d9c210d958e03fac8 63a594bea2b9438c9685b3a52ad62664--fa2f36f01889456d9c210d958e03fac8 04922c500bd04ce199f11a74de3b18dd fa2f36f01889456d9c210d958e03fac8--04922c500bd04ce199f11a74de3b18dd b82c2e37d2da4330891c1e964582d09b 04922c500bd04ce199f11a74de3b18dd--b82c2e37d2da4330891c1e964582d09b d85b03f2a7234d968b2f17a4fa7bad4f RX(b13) b82c2e37d2da4330891c1e964582d09b--d85b03f2a7234d968b2f17a4fa7bad4f d85b03f2a7234d968b2f17a4fa7bad4f--03ca210c12514cd285f920c55fa90bbc 61ae118a0390486188d8525d12cfecb6 e314e68eda584b64b2d2e6a5ba537b5d bdb66801f4d34dbabeeea227ae547f22--e314e68eda584b64b2d2e6a5ba537b5d 2a4f2844e622411ca33158c27115c091 5 4c6f7617f5424d6ca17cd4cf276459d1 e314e68eda584b64b2d2e6a5ba537b5d--4c6f7617f5424d6ca17cd4cf276459d1 acce20aa335e4135935966acd3a379e7 4c6f7617f5424d6ca17cd4cf276459d1--acce20aa335e4135935966acd3a379e7 1a0fd725dd424feba5c62a2c35a74384 X acce20aa335e4135935966acd3a379e7--1a0fd725dd424feba5c62a2c35a74384 1a0fd725dd424feba5c62a2c35a74384--a2391078b9e149dc97423708976588ea dae6cb2de6af4c25977fc3b44aca224b 1a0fd725dd424feba5c62a2c35a74384--dae6cb2de6af4c25977fc3b44aca224b 3569bf250fd54c7a8b7adc17b9e3bef8 dae6cb2de6af4c25977fc3b44aca224b--3569bf250fd54c7a8b7adc17b9e3bef8 d820dd4affc1498fb5874a68837e5b50 3569bf250fd54c7a8b7adc17b9e3bef8--d820dd4affc1498fb5874a68837e5b50 3114edcc7af34b368fb68feb515eb472 d820dd4affc1498fb5874a68837e5b50--3114edcc7af34b368fb68feb515eb472 0fdf609b5062424e832f8f144db39a81 3114edcc7af34b368fb68feb515eb472--0fdf609b5062424e832f8f144db39a81 bc58d6b719cb4c15956c4007b878b4b4 0fdf609b5062424e832f8f144db39a81--bc58d6b719cb4c15956c4007b878b4b4 4796be65a95f4ce1b085b45c426d6586 bc58d6b719cb4c15956c4007b878b4b4--4796be65a95f4ce1b085b45c426d6586 254983c2c5904696aa46eacaf8ef0c06 X 4796be65a95f4ce1b085b45c426d6586--254983c2c5904696aa46eacaf8ef0c06 254983c2c5904696aa46eacaf8ef0c06--f3d00acb2b344de6833caede981bf961 e30ea1014ddb4c7fb51aba765aafd086 254983c2c5904696aa46eacaf8ef0c06--e30ea1014ddb4c7fb51aba765aafd086 2ba2ac47693046b4b6bdc084fcf6f600 e30ea1014ddb4c7fb51aba765aafd086--2ba2ac47693046b4b6bdc084fcf6f600 2cb14db464354cdd898d3978d4c5e9de 2ba2ac47693046b4b6bdc084fcf6f600--2cb14db464354cdd898d3978d4c5e9de 3fd30a6ab69749c692b72e8b5e7b71bd 2cb14db464354cdd898d3978d4c5e9de--3fd30a6ab69749c692b72e8b5e7b71bd fa3ee7ea83aa4f5a91b98123a3a6b7a7 3fd30a6ab69749c692b72e8b5e7b71bd--fa3ee7ea83aa4f5a91b98123a3a6b7a7 7a1185b215214501a70580da69a5c8ff fa3ee7ea83aa4f5a91b98123a3a6b7a7--7a1185b215214501a70580da69a5c8ff 63d87e1a0b7b425792156567d1daf478 7a1185b215214501a70580da69a5c8ff--63d87e1a0b7b425792156567d1daf478 8f798ede88ed4426a6768eb59a413ee3 63d87e1a0b7b425792156567d1daf478--8f798ede88ed4426a6768eb59a413ee3 e7f999dbfc5e49ed9d6c21e086ebbc71 8f798ede88ed4426a6768eb59a413ee3--e7f999dbfc5e49ed9d6c21e086ebbc71 d3a8853ea93142d19b5e0c3ac5f6c5f1 e7f999dbfc5e49ed9d6c21e086ebbc71--d3a8853ea93142d19b5e0c3ac5f6c5f1 4fabbff6246b460981e2997f8eb7c83c d3a8853ea93142d19b5e0c3ac5f6c5f1--4fabbff6246b460981e2997f8eb7c83c 7d8b6bcf2d7c4253ba3e605a60b1d99f 4fabbff6246b460981e2997f8eb7c83c--7d8b6bcf2d7c4253ba3e605a60b1d99f ff2e8fa8103f48d2bbd88f7cddab7ac0 7d8b6bcf2d7c4253ba3e605a60b1d99f--ff2e8fa8103f48d2bbd88f7cddab7ac0 18ea53c648c549b1a5281662d0c34979 ff2e8fa8103f48d2bbd88f7cddab7ac0--18ea53c648c549b1a5281662d0c34979 3620feaea9a74f77890a904322c4a427 18ea53c648c549b1a5281662d0c34979--3620feaea9a74f77890a904322c4a427 17a8b3f8512640ab98876a2efd8a014e 3620feaea9a74f77890a904322c4a427--17a8b3f8512640ab98876a2efd8a014e d4a820821d2b42c7a40cc6ea1ccd393b X 17a8b3f8512640ab98876a2efd8a014e--d4a820821d2b42c7a40cc6ea1ccd393b d4a820821d2b42c7a40cc6ea1ccd393b--102891217d5147afa63eaf1b77d0619a 012445571cba4fe19b1b50a53083a463 RZ(-1.0*g0) d4a820821d2b42c7a40cc6ea1ccd393b--012445571cba4fe19b1b50a53083a463 5802a32635e84473adc9085333e0171a X 012445571cba4fe19b1b50a53083a463--5802a32635e84473adc9085333e0171a 5802a32635e84473adc9085333e0171a--7893f209f98e469882501b2118a729c0 541d83bdc3c64605bb60299ca321584d 5802a32635e84473adc9085333e0171a--541d83bdc3c64605bb60299ca321584d 85a6996cc0a54703bcd5496f5175a791 541d83bdc3c64605bb60299ca321584d--85a6996cc0a54703bcd5496f5175a791 6d8ca4b634794d6680e389387d9c93c7 85a6996cc0a54703bcd5496f5175a791--6d8ca4b634794d6680e389387d9c93c7 62e3292e09df4ceb8f348248c6242ebb 6d8ca4b634794d6680e389387d9c93c7--62e3292e09df4ceb8f348248c6242ebb ecdedee866a74288910dbb2447bb1aab 62e3292e09df4ceb8f348248c6242ebb--ecdedee866a74288910dbb2447bb1aab c47e7abd2c8c489da5d2ec60fa439f54 ecdedee866a74288910dbb2447bb1aab--c47e7abd2c8c489da5d2ec60fa439f54 da5df41e6a194797a5222ebe6638be6e X c47e7abd2c8c489da5d2ec60fa439f54--da5df41e6a194797a5222ebe6638be6e da5df41e6a194797a5222ebe6638be6e--f4ce4d271d3f4f5eb96720a937104d17 0667693352a540c1ba511ecbb9ea9429 da5df41e6a194797a5222ebe6638be6e--0667693352a540c1ba511ecbb9ea9429 c361ea8efff14f2ca1434ee43e45d2e9 0667693352a540c1ba511ecbb9ea9429--c361ea8efff14f2ca1434ee43e45d2e9 4a1b3d25c935403787af147ba05cecf4 c361ea8efff14f2ca1434ee43e45d2e9--4a1b3d25c935403787af147ba05cecf4 44e5615c848c47d6924671ea06c1305f X 4a1b3d25c935403787af147ba05cecf4--44e5615c848c47d6924671ea06c1305f 44e5615c848c47d6924671ea06c1305f--6ab11866669446dbb3da39cabcbecb6b b3dcfa8d67564078900aa5f086982fd0 44e5615c848c47d6924671ea06c1305f--b3dcfa8d67564078900aa5f086982fd0 51343b21fb9e493092dd5b5bf2a3ef9b b3dcfa8d67564078900aa5f086982fd0--51343b21fb9e493092dd5b5bf2a3ef9b ae6df423bccd48bb9e6a645d47890ad0 51343b21fb9e493092dd5b5bf2a3ef9b--ae6df423bccd48bb9e6a645d47890ad0 c3403e8e30df43d08aa2f8f11dbe662e ae6df423bccd48bb9e6a645d47890ad0--c3403e8e30df43d08aa2f8f11dbe662e 2952a21c934a4ae48fca847ce61dfc38 c3403e8e30df43d08aa2f8f11dbe662e--2952a21c934a4ae48fca847ce61dfc38 87b8ca6feb774427a97349ab1ec1cbfb 2952a21c934a4ae48fca847ce61dfc38--87b8ca6feb774427a97349ab1ec1cbfb e6cc45a5a2f542a79fc8a3a066d2ecbc X 87b8ca6feb774427a97349ab1ec1cbfb--e6cc45a5a2f542a79fc8a3a066d2ecbc e6cc45a5a2f542a79fc8a3a066d2ecbc--2ff5e5e428d444959f6bb7da2b0b7ede f2de1529f8144596be8894199091ec3d e6cc45a5a2f542a79fc8a3a066d2ecbc--f2de1529f8144596be8894199091ec3d f71abe8b61d04949b0428fa2f148ba2e f2de1529f8144596be8894199091ec3d--f71abe8b61d04949b0428fa2f148ba2e 047e3e6f3fdc4f9e8c9ab839298a2677 f71abe8b61d04949b0428fa2f148ba2e--047e3e6f3fdc4f9e8c9ab839298a2677 202ba7e1873247d28c6f216301dc3fd3 047e3e6f3fdc4f9e8c9ab839298a2677--202ba7e1873247d28c6f216301dc3fd3 fa1bc4f5399848de8eeb5f5ea5ea8734 202ba7e1873247d28c6f216301dc3fd3--fa1bc4f5399848de8eeb5f5ea5ea8734 3ff4e765e0554ebfa0aadc2629fb35a7 X fa1bc4f5399848de8eeb5f5ea5ea8734--3ff4e765e0554ebfa0aadc2629fb35a7 3ff4e765e0554ebfa0aadc2629fb35a7--12629bb58d124683a336d96a9364b0f7 f20bb73e943e45419dddaf7894fa7b3e 3ff4e765e0554ebfa0aadc2629fb35a7--f20bb73e943e45419dddaf7894fa7b3e 8223a3313353413f9efe468f16c639a6 f20bb73e943e45419dddaf7894fa7b3e--8223a3313353413f9efe468f16c639a6 97109b037b8d42d68d5d0ab8a3017d60 8223a3313353413f9efe468f16c639a6--97109b037b8d42d68d5d0ab8a3017d60 6a757b48d35249b4b98c920ec5dcda13 97109b037b8d42d68d5d0ab8a3017d60--6a757b48d35249b4b98c920ec5dcda13 97eebf5d32ce4547919e0351b5cc0894 6a757b48d35249b4b98c920ec5dcda13--97eebf5d32ce4547919e0351b5cc0894 e5f252c9850c48ab89f713389f66ac7b X 97eebf5d32ce4547919e0351b5cc0894--e5f252c9850c48ab89f713389f66ac7b e5f252c9850c48ab89f713389f66ac7b--ae2e79503bbc4749aa7f11df5fc18d21 d5cbbe86b07e49189d590bccd2e5add2 e5f252c9850c48ab89f713389f66ac7b--d5cbbe86b07e49189d590bccd2e5add2 13a99486bbac423eae4ed2f1bf569861 d5cbbe86b07e49189d590bccd2e5add2--13a99486bbac423eae4ed2f1bf569861 de6b94add8064450a38ea261ebd74124 13a99486bbac423eae4ed2f1bf569861--de6b94add8064450a38ea261ebd74124 d9dfb8a225de46f19cebf66aac1d1831 de6b94add8064450a38ea261ebd74124--d9dfb8a225de46f19cebf66aac1d1831 c687f57ca5874cf7a91f82115ff88006 d9dfb8a225de46f19cebf66aac1d1831--c687f57ca5874cf7a91f82115ff88006 2227aa9fbda44444889b0fab842bcd7f X c687f57ca5874cf7a91f82115ff88006--2227aa9fbda44444889b0fab842bcd7f 2227aa9fbda44444889b0fab842bcd7f--2e119b83ece74e1ba19c9b8333e5b41c 2080424770bd4172b92aa3102d72dcd2 2227aa9fbda44444889b0fab842bcd7f--2080424770bd4172b92aa3102d72dcd2 9c9d792e44714050bfe3c2eb9d47054b 2080424770bd4172b92aa3102d72dcd2--9c9d792e44714050bfe3c2eb9d47054b b38f20a41b2a4de8862ca2c66137e120 9c9d792e44714050bfe3c2eb9d47054b--b38f20a41b2a4de8862ca2c66137e120 cf6252167709473baa03eec9724ebfe0 b38f20a41b2a4de8862ca2c66137e120--cf6252167709473baa03eec9724ebfe0 dd15685041a94d24833c2f7dbeb48402 cf6252167709473baa03eec9724ebfe0--dd15685041a94d24833c2f7dbeb48402 cc132576c44045869a667f6fd39790fc dd15685041a94d24833c2f7dbeb48402--cc132576c44045869a667f6fd39790fc f4891f1c84564682a97c0c7ac496f8c6 X cc132576c44045869a667f6fd39790fc--f4891f1c84564682a97c0c7ac496f8c6 f4891f1c84564682a97c0c7ac496f8c6--0a4ca4c446aa408487b0072faeb1e9ac 4e4d585ccda14a20bcff6769ccfd3f26 RZ(-1.0*g0) f4891f1c84564682a97c0c7ac496f8c6--4e4d585ccda14a20bcff6769ccfd3f26 8e402a1029004170849556dcb593eec5 X 4e4d585ccda14a20bcff6769ccfd3f26--8e402a1029004170849556dcb593eec5 8e402a1029004170849556dcb593eec5--9af245cc85314f55886940f18b77ba23 39a392c0ba43486aaefe9eb6dc8539a8 8e402a1029004170849556dcb593eec5--39a392c0ba43486aaefe9eb6dc8539a8 1b347df376ff4a4ea5d0fba1b8328f55 39a392c0ba43486aaefe9eb6dc8539a8--1b347df376ff4a4ea5d0fba1b8328f55 d5f8ddc52e5c418d8ab075d0f6aca087 X 1b347df376ff4a4ea5d0fba1b8328f55--d5f8ddc52e5c418d8ab075d0f6aca087 d5f8ddc52e5c418d8ab075d0f6aca087--8168afa7fbe9449ba52f5c53ac620f42 457eb8cb9bd74469a38eb8a33a8a2f94 d5f8ddc52e5c418d8ab075d0f6aca087--457eb8cb9bd74469a38eb8a33a8a2f94 63ebb0a4e06b4ab69ae698987fe68b19 457eb8cb9bd74469a38eb8a33a8a2f94--63ebb0a4e06b4ab69ae698987fe68b19 b158b07b3d964748bd0a3e7a15598c80 63ebb0a4e06b4ab69ae698987fe68b19--b158b07b3d964748bd0a3e7a15598c80 378c26372b59491c9008d244de55b5fb b158b07b3d964748bd0a3e7a15598c80--378c26372b59491c9008d244de55b5fb 769fc298fe5242ee8a5bdbc96e3551a3 378c26372b59491c9008d244de55b5fb--769fc298fe5242ee8a5bdbc96e3551a3 dfc8bcf12ff844bbb27f6feebd4aee30 X 769fc298fe5242ee8a5bdbc96e3551a3--dfc8bcf12ff844bbb27f6feebd4aee30 dfc8bcf12ff844bbb27f6feebd4aee30--5da0460361334862902361f546ff37c1 75a7da7af34542319171a0ff5c8c8327 dfc8bcf12ff844bbb27f6feebd4aee30--75a7da7af34542319171a0ff5c8c8327 e255445b068b484da5438c8f93d62c0d 75a7da7af34542319171a0ff5c8c8327--e255445b068b484da5438c8f93d62c0d e0976a3fa26b445682e79095836af45f X e255445b068b484da5438c8f93d62c0d--e0976a3fa26b445682e79095836af45f e0976a3fa26b445682e79095836af45f--2cd2ab83b27c44bb82fa0919cc5bbe42 c6fb5a92899b41098d4f310226a6d02f e0976a3fa26b445682e79095836af45f--c6fb5a92899b41098d4f310226a6d02f 12824a146c7e4ea6b870e62cc165a0e4 c6fb5a92899b41098d4f310226a6d02f--12824a146c7e4ea6b870e62cc165a0e4 e366536c39d24ae0a4a9a6130c16796e 12824a146c7e4ea6b870e62cc165a0e4--e366536c39d24ae0a4a9a6130c16796e 54a4317db2d441bc9703bd12653f98c9 e366536c39d24ae0a4a9a6130c16796e--54a4317db2d441bc9703bd12653f98c9 f3d9ae75405b4590bfb8f1fd29e42338 54a4317db2d441bc9703bd12653f98c9--f3d9ae75405b4590bfb8f1fd29e42338 87b74d77937941ba92a6064e97b418d2 f3d9ae75405b4590bfb8f1fd29e42338--87b74d77937941ba92a6064e97b418d2 4a930843d2174b9492d60c223fbf7be2 87b74d77937941ba92a6064e97b418d2--4a930843d2174b9492d60c223fbf7be2 3b2ecb3cf01b4f98893a37a18ffd76fc X 4a930843d2174b9492d60c223fbf7be2--3b2ecb3cf01b4f98893a37a18ffd76fc 3b2ecb3cf01b4f98893a37a18ffd76fc--2b321deeb06d4238b43604a33d3a8e6f 2a0b26b5afd349969d37b00b8198d3c6 3b2ecb3cf01b4f98893a37a18ffd76fc--2a0b26b5afd349969d37b00b8198d3c6 4c02380824de4bb78ca6a8ac867787a2 X 2a0b26b5afd349969d37b00b8198d3c6--4c02380824de4bb78ca6a8ac867787a2 4c02380824de4bb78ca6a8ac867787a2--aca61b5381dc4b23b5577bb99f14ce9e 6a786a8c3d7543d48a611e95bddc87b7 RZ(-1.0*g0) 4c02380824de4bb78ca6a8ac867787a2--6a786a8c3d7543d48a611e95bddc87b7 dbc15ca1ff7643cb8b506642039911e9 X 6a786a8c3d7543d48a611e95bddc87b7--dbc15ca1ff7643cb8b506642039911e9 dbc15ca1ff7643cb8b506642039911e9--56405058113542a9ba8fed9c5f9401d1 2bcec6791ab74b1e9e9f7283819f2614 dbc15ca1ff7643cb8b506642039911e9--2bcec6791ab74b1e9e9f7283819f2614 f6cfc34ac4cc47128edb14cdcdd7ac8f 2bcec6791ab74b1e9e9f7283819f2614--f6cfc34ac4cc47128edb14cdcdd7ac8f 8dcb739983ec4ba8a4b4f3281ea17e9e f6cfc34ac4cc47128edb14cdcdd7ac8f--8dcb739983ec4ba8a4b4f3281ea17e9e 03c8a56c57094f36861aad0aec324b2e 8dcb739983ec4ba8a4b4f3281ea17e9e--03c8a56c57094f36861aad0aec324b2e 002aa4628cfa4172b47467eee8757568 03c8a56c57094f36861aad0aec324b2e--002aa4628cfa4172b47467eee8757568 a0d245417706429a847e89e182334fc8 002aa4628cfa4172b47467eee8757568--a0d245417706429a847e89e182334fc8 22b0a16aced04ddc95fff7db1c5eee12 a0d245417706429a847e89e182334fc8--22b0a16aced04ddc95fff7db1c5eee12 2b3bb2a8a1ca45ecbba0e93828919ccc 22b0a16aced04ddc95fff7db1c5eee12--2b3bb2a8a1ca45ecbba0e93828919ccc 665d2f63156b4af9a0fb2f9a11ecbbd9 2b3bb2a8a1ca45ecbba0e93828919ccc--665d2f63156b4af9a0fb2f9a11ecbbd9 55c0ac9f8a584a09a9a0ebf7de47cf35 665d2f63156b4af9a0fb2f9a11ecbbd9--55c0ac9f8a584a09a9a0ebf7de47cf35 ad76c46e58cb4f8999965bfb43839a34 55c0ac9f8a584a09a9a0ebf7de47cf35--ad76c46e58cb4f8999965bfb43839a34 8b99db6ed3424a46b74f4353ef832f9b ad76c46e58cb4f8999965bfb43839a34--8b99db6ed3424a46b74f4353ef832f9b fb4bc781e25e4c478397515a01ac9523 RX(b04) 8b99db6ed3424a46b74f4353ef832f9b--fb4bc781e25e4c478397515a01ac9523 ae077a8f660b48b79ba524950f4b6d1f fb4bc781e25e4c478397515a01ac9523--ae077a8f660b48b79ba524950f4b6d1f b1ee61d65ba942d18255e4552ff7fca1 ae077a8f660b48b79ba524950f4b6d1f--b1ee61d65ba942d18255e4552ff7fca1 4c34021408b040d4930b8dcd9fcf1acf b1ee61d65ba942d18255e4552ff7fca1--4c34021408b040d4930b8dcd9fcf1acf 520d3363fa4340deb73372000da41615 X 4c34021408b040d4930b8dcd9fcf1acf--520d3363fa4340deb73372000da41615 520d3363fa4340deb73372000da41615--6e0907c9fbc947ddb026d067c82f57f8 bec3bd8b0692486aa5e426ad2104abb4 520d3363fa4340deb73372000da41615--bec3bd8b0692486aa5e426ad2104abb4 7a46a315d0394fbfa3916415398d8119 bec3bd8b0692486aa5e426ad2104abb4--7a46a315d0394fbfa3916415398d8119 bf990b98d2ee42c28176a68b9b4ef46c 7a46a315d0394fbfa3916415398d8119--bf990b98d2ee42c28176a68b9b4ef46c 0532906c3e0f4db89e0140963f77db95 bf990b98d2ee42c28176a68b9b4ef46c--0532906c3e0f4db89e0140963f77db95 eef8213a113a4db589e0397820b2fa45 0532906c3e0f4db89e0140963f77db95--eef8213a113a4db589e0397820b2fa45 2f4ac6bc6e2948a7a06432042d816ab3 eef8213a113a4db589e0397820b2fa45--2f4ac6bc6e2948a7a06432042d816ab3 8f071f86a4e14aa8b1ce752853c6722e 2f4ac6bc6e2948a7a06432042d816ab3--8f071f86a4e14aa8b1ce752853c6722e cc9350b174a8435c99362caebe1f73a6 X 8f071f86a4e14aa8b1ce752853c6722e--cc9350b174a8435c99362caebe1f73a6 cc9350b174a8435c99362caebe1f73a6--dcbfb27063214c29acf3a36d4d090810 4bd5442745b14afa8d220eaa55d9ac12 cc9350b174a8435c99362caebe1f73a6--4bd5442745b14afa8d220eaa55d9ac12 32657ed5746945c692cbf016cd7df255 4bd5442745b14afa8d220eaa55d9ac12--32657ed5746945c692cbf016cd7df255 b0de3168101c45d4a36e03c7e4271413 32657ed5746945c692cbf016cd7df255--b0de3168101c45d4a36e03c7e4271413 9839f43af4c948e38652e458853073ee b0de3168101c45d4a36e03c7e4271413--9839f43af4c948e38652e458853073ee 30e0e23b53084d5c84e1e839adffb434 9839f43af4c948e38652e458853073ee--30e0e23b53084d5c84e1e839adffb434 3ac3853f7a7b4d41a3167996f6239a82 30e0e23b53084d5c84e1e839adffb434--3ac3853f7a7b4d41a3167996f6239a82 d2c1361140374225ab6481b77ad1882d 3ac3853f7a7b4d41a3167996f6239a82--d2c1361140374225ab6481b77ad1882d c255a24d02054529a3e92d7ecad80a56 d2c1361140374225ab6481b77ad1882d--c255a24d02054529a3e92d7ecad80a56 dad68f1e643d42cf86489c8a3e1ca1a8 c255a24d02054529a3e92d7ecad80a56--dad68f1e643d42cf86489c8a3e1ca1a8 57f20ff76dce41dfabfb88f93ceb8cff dad68f1e643d42cf86489c8a3e1ca1a8--57f20ff76dce41dfabfb88f93ceb8cff b2d6c9392a9c4fbfad0735d7f1ab7538 57f20ff76dce41dfabfb88f93ceb8cff--b2d6c9392a9c4fbfad0735d7f1ab7538 94243ff200424412a7c60657005dcc58 b2d6c9392a9c4fbfad0735d7f1ab7538--94243ff200424412a7c60657005dcc58 faf2c6c6b68f4eeebac030ffaea82685 94243ff200424412a7c60657005dcc58--faf2c6c6b68f4eeebac030ffaea82685 a791d87a545941c2bac74989d0022cb6 faf2c6c6b68f4eeebac030ffaea82685--a791d87a545941c2bac74989d0022cb6 a4774a5941a74a88b124a5307df756ee a791d87a545941c2bac74989d0022cb6--a4774a5941a74a88b124a5307df756ee b46a55733911457d9f93bcac80478838 a4774a5941a74a88b124a5307df756ee--b46a55733911457d9f93bcac80478838 9cbf6511feb64755b786349b2c12fea6 X b46a55733911457d9f93bcac80478838--9cbf6511feb64755b786349b2c12fea6 9cbf6511feb64755b786349b2c12fea6--43bb3636b94e4facb451f6db2e17472d 8f59a32efc794384b90dc137e95c0db2 RZ(-1.0*g1) 9cbf6511feb64755b786349b2c12fea6--8f59a32efc794384b90dc137e95c0db2 f4dab6b03e6b4a0480869002583aa3ec X 8f59a32efc794384b90dc137e95c0db2--f4dab6b03e6b4a0480869002583aa3ec f4dab6b03e6b4a0480869002583aa3ec--ae45dab430924a44ab28634267bee678 bda45d6896b742c2a5a316647129af03 f4dab6b03e6b4a0480869002583aa3ec--bda45d6896b742c2a5a316647129af03 900c1410eed44fc19e7394fde4e91002 bda45d6896b742c2a5a316647129af03--900c1410eed44fc19e7394fde4e91002 5bb560fec05142549b98c5adba2a8502 900c1410eed44fc19e7394fde4e91002--5bb560fec05142549b98c5adba2a8502 e065f21e5aea4e2b84cc61ab868e842d 5bb560fec05142549b98c5adba2a8502--e065f21e5aea4e2b84cc61ab868e842d 2265d3e8e04445bca3aaa06414b00248 e065f21e5aea4e2b84cc61ab868e842d--2265d3e8e04445bca3aaa06414b00248 9e3b8652a682412fbea669ddb58a279d 2265d3e8e04445bca3aaa06414b00248--9e3b8652a682412fbea669ddb58a279d e4f854bc2e3d46fe87b6030a7da376da X 9e3b8652a682412fbea669ddb58a279d--e4f854bc2e3d46fe87b6030a7da376da e4f854bc2e3d46fe87b6030a7da376da--85ee6e7c43d64b3bbee0dc62a5acb496 5f1f98e8358e43fbb366bd0cc50e26f9 e4f854bc2e3d46fe87b6030a7da376da--5f1f98e8358e43fbb366bd0cc50e26f9 8b4a3e86448a49bcb98d8d5114d98628 5f1f98e8358e43fbb366bd0cc50e26f9--8b4a3e86448a49bcb98d8d5114d98628 07428e6a191447ce814edbe9bde2940d 8b4a3e86448a49bcb98d8d5114d98628--07428e6a191447ce814edbe9bde2940d 8b4398ac51c140e7b7af83822408b4e4 X 07428e6a191447ce814edbe9bde2940d--8b4398ac51c140e7b7af83822408b4e4 8b4398ac51c140e7b7af83822408b4e4--48f238fce9564d0585a954476cf3de3b 1598de8ee49c4452a1ccfb384518933b 8b4398ac51c140e7b7af83822408b4e4--1598de8ee49c4452a1ccfb384518933b 25277a1c397b4d25a38b2c65c7a2e08a 1598de8ee49c4452a1ccfb384518933b--25277a1c397b4d25a38b2c65c7a2e08a e2cf04a15ddb4d2fb114ea7b7fc8d8e2 25277a1c397b4d25a38b2c65c7a2e08a--e2cf04a15ddb4d2fb114ea7b7fc8d8e2 9a0e312aa2ff4a55b3d36d5ac3e80a46 e2cf04a15ddb4d2fb114ea7b7fc8d8e2--9a0e312aa2ff4a55b3d36d5ac3e80a46 82213be2dbc7477486401c7ca17fe185 9a0e312aa2ff4a55b3d36d5ac3e80a46--82213be2dbc7477486401c7ca17fe185 8c074527584f4ec4848f9d257f96d3f7 82213be2dbc7477486401c7ca17fe185--8c074527584f4ec4848f9d257f96d3f7 0420601d032c4d94abf24f3394abd445 X 8c074527584f4ec4848f9d257f96d3f7--0420601d032c4d94abf24f3394abd445 0420601d032c4d94abf24f3394abd445--c6746da5204f4b72b5c28385f66ce480 fd1a2408792f4e4399b12be7fb5dd6ee 0420601d032c4d94abf24f3394abd445--fd1a2408792f4e4399b12be7fb5dd6ee cbadf794d1204ed19e2c6b2b12ff6077 fd1a2408792f4e4399b12be7fb5dd6ee--cbadf794d1204ed19e2c6b2b12ff6077 61c2f0b98ce24b04938b734e19df2a24 cbadf794d1204ed19e2c6b2b12ff6077--61c2f0b98ce24b04938b734e19df2a24 7396cc055b9c4fcbb21d0c2ec7814230 61c2f0b98ce24b04938b734e19df2a24--7396cc055b9c4fcbb21d0c2ec7814230 14d08d6701d34c319bdd71093e42da9d 7396cc055b9c4fcbb21d0c2ec7814230--14d08d6701d34c319bdd71093e42da9d 0281d23a03be405dabd661d8ac45f56f X 14d08d6701d34c319bdd71093e42da9d--0281d23a03be405dabd661d8ac45f56f 0281d23a03be405dabd661d8ac45f56f--1bbea4143f1d439c9fade09a616ab062 3c3733a384994341a6f57ea178c5252e 0281d23a03be405dabd661d8ac45f56f--3c3733a384994341a6f57ea178c5252e bc3e697580764e04a76533f2f00f3e1c 3c3733a384994341a6f57ea178c5252e--bc3e697580764e04a76533f2f00f3e1c a5dd424c2a6f44119e9a2930a30b3498 bc3e697580764e04a76533f2f00f3e1c--a5dd424c2a6f44119e9a2930a30b3498 e41debae07ac44978848c87e836bb8c8 a5dd424c2a6f44119e9a2930a30b3498--e41debae07ac44978848c87e836bb8c8 8bd26b223ebe428f8a3d353fd0626734 e41debae07ac44978848c87e836bb8c8--8bd26b223ebe428f8a3d353fd0626734 d18fd8827845440db9913baf5b462346 X 8bd26b223ebe428f8a3d353fd0626734--d18fd8827845440db9913baf5b462346 d18fd8827845440db9913baf5b462346--326b9d4b95614fd58a04d01273d564da 6224594ed4474b9b9eb83cbe36f9adb7 d18fd8827845440db9913baf5b462346--6224594ed4474b9b9eb83cbe36f9adb7 e2e6c5d5df3c446dab97696dc57ea599 6224594ed4474b9b9eb83cbe36f9adb7--e2e6c5d5df3c446dab97696dc57ea599 c4a4c2a8d99d4bc08680daec514652e6 e2e6c5d5df3c446dab97696dc57ea599--c4a4c2a8d99d4bc08680daec514652e6 2ad26e1915c94e008620bc5b29ccc729 c4a4c2a8d99d4bc08680daec514652e6--2ad26e1915c94e008620bc5b29ccc729 2a377251653f4d129a6d4a7c348f2943 2ad26e1915c94e008620bc5b29ccc729--2a377251653f4d129a6d4a7c348f2943 63bd85d59498494199372f92c9c2f0ef X 2a377251653f4d129a6d4a7c348f2943--63bd85d59498494199372f92c9c2f0ef 63bd85d59498494199372f92c9c2f0ef--b913a820488144f7952176b242bba933 d7fd108b4c85473f845b4bfea07fffae 63bd85d59498494199372f92c9c2f0ef--d7fd108b4c85473f845b4bfea07fffae 9bdb63e7aa16444e9b887092e9d0d061 d7fd108b4c85473f845b4bfea07fffae--9bdb63e7aa16444e9b887092e9d0d061 4e39f0f32db24d74946897e1e885be53 9bdb63e7aa16444e9b887092e9d0d061--4e39f0f32db24d74946897e1e885be53 27e6f056af3b42afbd0d5b5130e7fc59 4e39f0f32db24d74946897e1e885be53--27e6f056af3b42afbd0d5b5130e7fc59 6c79ca7e78bb4545a2fe6618ef24485a 27e6f056af3b42afbd0d5b5130e7fc59--6c79ca7e78bb4545a2fe6618ef24485a 64df7717738b410ebd85c22f6a058cf9 6c79ca7e78bb4545a2fe6618ef24485a--64df7717738b410ebd85c22f6a058cf9 3717697937ff48e597b57edf6b0bab03 X 64df7717738b410ebd85c22f6a058cf9--3717697937ff48e597b57edf6b0bab03 3717697937ff48e597b57edf6b0bab03--e3cf111fa9d047b7af4e3ce245c10b1b 526a5917132a485f89483a91dafc591d RZ(-1.0*g1) 3717697937ff48e597b57edf6b0bab03--526a5917132a485f89483a91dafc591d 4c3ef86e0ae04909be88bda2a3a26f81 X 526a5917132a485f89483a91dafc591d--4c3ef86e0ae04909be88bda2a3a26f81 4c3ef86e0ae04909be88bda2a3a26f81--908d0ccb15af4ed48238349e238d277b 7184bcf55a254d3d92a27ed8ca8d9b15 4c3ef86e0ae04909be88bda2a3a26f81--7184bcf55a254d3d92a27ed8ca8d9b15 01c6574ebc614b49aea4c55e6122cb30 7184bcf55a254d3d92a27ed8ca8d9b15--01c6574ebc614b49aea4c55e6122cb30 d7dc31f7787f46d28b0fd0ef5c2728fd X 01c6574ebc614b49aea4c55e6122cb30--d7dc31f7787f46d28b0fd0ef5c2728fd d7dc31f7787f46d28b0fd0ef5c2728fd--d0aa3ba308524d21bb831a8c0c48f715 e130087fd56643fc887533ba0b8bf6b7 d7dc31f7787f46d28b0fd0ef5c2728fd--e130087fd56643fc887533ba0b8bf6b7 1450fbf3ba8f403ca8905776043470a7 e130087fd56643fc887533ba0b8bf6b7--1450fbf3ba8f403ca8905776043470a7 a95b8fec2b4d4ca1adbde247134e5c02 1450fbf3ba8f403ca8905776043470a7--a95b8fec2b4d4ca1adbde247134e5c02 cb1911b9d6d84da18630b05342b400fc a95b8fec2b4d4ca1adbde247134e5c02--cb1911b9d6d84da18630b05342b400fc 9ab3a4ef01a741c1a4340a596d9cdae8 cb1911b9d6d84da18630b05342b400fc--9ab3a4ef01a741c1a4340a596d9cdae8 63c566380eb1401392e007575890812b X 9ab3a4ef01a741c1a4340a596d9cdae8--63c566380eb1401392e007575890812b 63c566380eb1401392e007575890812b--758ffb6724e44359bddbf9ca27d0cb0b 2725456033374b36a3bfa49a93c798fc 63c566380eb1401392e007575890812b--2725456033374b36a3bfa49a93c798fc ecf4b9493476448ead3d1c66b85f4d49 2725456033374b36a3bfa49a93c798fc--ecf4b9493476448ead3d1c66b85f4d49 c65e5760aa7140efaca824cd7460ef28 X ecf4b9493476448ead3d1c66b85f4d49--c65e5760aa7140efaca824cd7460ef28 c65e5760aa7140efaca824cd7460ef28--3ca5a61bd8754625b7c94fe441a786b4 e3ec8a4527694ca59afc75affba62266 c65e5760aa7140efaca824cd7460ef28--e3ec8a4527694ca59afc75affba62266 98df912e890b4e0589fe2db756f26642 e3ec8a4527694ca59afc75affba62266--98df912e890b4e0589fe2db756f26642 31dd549e5fb04302bde626c68f4c3202 98df912e890b4e0589fe2db756f26642--31dd549e5fb04302bde626c68f4c3202 201d89aad3da43b8a2d24c64140ef25d 31dd549e5fb04302bde626c68f4c3202--201d89aad3da43b8a2d24c64140ef25d 194c8e362bf641a6ad160e1477155b1c 201d89aad3da43b8a2d24c64140ef25d--194c8e362bf641a6ad160e1477155b1c b80358cd6b914fa0a23e00ec53cc3208 194c8e362bf641a6ad160e1477155b1c--b80358cd6b914fa0a23e00ec53cc3208 a978464f939141aca6a4b29f64e915a9 b80358cd6b914fa0a23e00ec53cc3208--a978464f939141aca6a4b29f64e915a9 7cdaf37418aa419ba1440422e1133a5f X a978464f939141aca6a4b29f64e915a9--7cdaf37418aa419ba1440422e1133a5f 7cdaf37418aa419ba1440422e1133a5f--d277830d04354f4cbecb53a65a564bbc 770e56a3a024475ea0be271be4c31b57 7cdaf37418aa419ba1440422e1133a5f--770e56a3a024475ea0be271be4c31b57 be4ae3f370184c388262806cbad6de9c X 770e56a3a024475ea0be271be4c31b57--be4ae3f370184c388262806cbad6de9c be4ae3f370184c388262806cbad6de9c--adf4596de18a4c2f879632892f5cbeb1 367ea86c5e584b1b9c55127be8dc150e RZ(-1.0*g1) be4ae3f370184c388262806cbad6de9c--367ea86c5e584b1b9c55127be8dc150e f6466ab69e814896a128cf42f18036f8 X 367ea86c5e584b1b9c55127be8dc150e--f6466ab69e814896a128cf42f18036f8 f6466ab69e814896a128cf42f18036f8--00e446c7810d4898b73a78a9d0d5e238 85b1e65b2f01480b8564c85b2074cc96 f6466ab69e814896a128cf42f18036f8--85b1e65b2f01480b8564c85b2074cc96 928b7c1552d542aab7ce4bdb7fa2b473 85b1e65b2f01480b8564c85b2074cc96--928b7c1552d542aab7ce4bdb7fa2b473 1c9d3c1f845648439b0bd7ad87a7669e 928b7c1552d542aab7ce4bdb7fa2b473--1c9d3c1f845648439b0bd7ad87a7669e 8de352a2d3c94c8ea6c173d4c75b0bf1 1c9d3c1f845648439b0bd7ad87a7669e--8de352a2d3c94c8ea6c173d4c75b0bf1 2a1af7f75dc844798a67e1732441d50c 8de352a2d3c94c8ea6c173d4c75b0bf1--2a1af7f75dc844798a67e1732441d50c a20bc6676b5e462fa8c3da0fbcac50a6 2a1af7f75dc844798a67e1732441d50c--a20bc6676b5e462fa8c3da0fbcac50a6 18d6c84cb61040b2af26cd6c561e37cf a20bc6676b5e462fa8c3da0fbcac50a6--18d6c84cb61040b2af26cd6c561e37cf a6507636aed04f4f8830a273c7eb43fc 18d6c84cb61040b2af26cd6c561e37cf--a6507636aed04f4f8830a273c7eb43fc 868d4e8740a2473caa658806bfecd1f8 a6507636aed04f4f8830a273c7eb43fc--868d4e8740a2473caa658806bfecd1f8 cabbc3e0dae54e99b50c76930d25ebc1 868d4e8740a2473caa658806bfecd1f8--cabbc3e0dae54e99b50c76930d25ebc1 29698559e7724f40a88d0c2337562540 cabbc3e0dae54e99b50c76930d25ebc1--29698559e7724f40a88d0c2337562540 3306263881444da5a2b9451958d36007 29698559e7724f40a88d0c2337562540--3306263881444da5a2b9451958d36007 3074941e039544b1990e12d388e0bb48 RX(b14) 3306263881444da5a2b9451958d36007--3074941e039544b1990e12d388e0bb48 3074941e039544b1990e12d388e0bb48--61ae118a0390486188d8525d12cfecb6 3a4719c9916e4f6a99072658fa1ec60c d1924e6010f84c8989c9d041f132bfa8 2a4f2844e622411ca33158c27115c091--d1924e6010f84c8989c9d041f132bfa8 0827ceb13e8d429cb95ff717f77d041f 6 b29735d8281248a5a37fc803da3cff5a d1924e6010f84c8989c9d041f132bfa8--b29735d8281248a5a37fc803da3cff5a 79244cdf3d4c498f8be23118d53f270d b29735d8281248a5a37fc803da3cff5a--79244cdf3d4c498f8be23118d53f270d b77441c712114fe78ff8194b2a656038 79244cdf3d4c498f8be23118d53f270d--b77441c712114fe78ff8194b2a656038 8b85becbac5444ac9be3c4e704bc6436 X b77441c712114fe78ff8194b2a656038--8b85becbac5444ac9be3c4e704bc6436 8b85becbac5444ac9be3c4e704bc6436--dae6cb2de6af4c25977fc3b44aca224b b908d365bc214027b3e4f585599d8d0d 8b85becbac5444ac9be3c4e704bc6436--b908d365bc214027b3e4f585599d8d0d 5518be59a39b45b8af54167885888b61 b908d365bc214027b3e4f585599d8d0d--5518be59a39b45b8af54167885888b61 e7e2cb2e3fe44134871a6b34f39dc07f 5518be59a39b45b8af54167885888b61--e7e2cb2e3fe44134871a6b34f39dc07f 645d335177c4484f842c73d45c09904e e7e2cb2e3fe44134871a6b34f39dc07f--645d335177c4484f842c73d45c09904e f8ec9caccecc4f6a874b3e1c65147ca7 645d335177c4484f842c73d45c09904e--f8ec9caccecc4f6a874b3e1c65147ca7 403562d3265b406181d0fec91cda28a9 X f8ec9caccecc4f6a874b3e1c65147ca7--403562d3265b406181d0fec91cda28a9 403562d3265b406181d0fec91cda28a9--4796be65a95f4ce1b085b45c426d6586 be1bc0cf888646369f7ae03fea4d5ad1 403562d3265b406181d0fec91cda28a9--be1bc0cf888646369f7ae03fea4d5ad1 576896464ecf462aa78804dbace06d77 be1bc0cf888646369f7ae03fea4d5ad1--576896464ecf462aa78804dbace06d77 b388e2952f3f4f208473e5c9f482d302 576896464ecf462aa78804dbace06d77--b388e2952f3f4f208473e5c9f482d302 6b3bbe44954648e08e7f952d957ae104 b388e2952f3f4f208473e5c9f482d302--6b3bbe44954648e08e7f952d957ae104 dd51a47e1fc74b1391428f22f139c1e3 6b3bbe44954648e08e7f952d957ae104--dd51a47e1fc74b1391428f22f139c1e3 86b6a72749a94463a446eec687bba8a1 dd51a47e1fc74b1391428f22f139c1e3--86b6a72749a94463a446eec687bba8a1 92bc8e9546484aec97a864be84c68dd2 86b6a72749a94463a446eec687bba8a1--92bc8e9546484aec97a864be84c68dd2 9700b87ee91b4639abd7119e66072340 92bc8e9546484aec97a864be84c68dd2--9700b87ee91b4639abd7119e66072340 1ec4ad6b2c37455390e9c9db132268eb 9700b87ee91b4639abd7119e66072340--1ec4ad6b2c37455390e9c9db132268eb eb41fdd78b2d4ec780afc6711ddec2ba 1ec4ad6b2c37455390e9c9db132268eb--eb41fdd78b2d4ec780afc6711ddec2ba ee493004b2774c3a9023a5cdea76400f eb41fdd78b2d4ec780afc6711ddec2ba--ee493004b2774c3a9023a5cdea76400f b6eb940ede0e4400b010889022ee967f ee493004b2774c3a9023a5cdea76400f--b6eb940ede0e4400b010889022ee967f e98f1ed29f2f46a0859954e2441ce456 b6eb940ede0e4400b010889022ee967f--e98f1ed29f2f46a0859954e2441ce456 685ef889c9d74b5382032abf1e49e872 e98f1ed29f2f46a0859954e2441ce456--685ef889c9d74b5382032abf1e49e872 6467bcd6952b4e329e72a467baa3fbd1 685ef889c9d74b5382032abf1e49e872--6467bcd6952b4e329e72a467baa3fbd1 40ed8ab8f09a4b3ba57f335a839c31b0 6467bcd6952b4e329e72a467baa3fbd1--40ed8ab8f09a4b3ba57f335a839c31b0 484cad2cd0464a36826e40dcb605a91d 40ed8ab8f09a4b3ba57f335a839c31b0--484cad2cd0464a36826e40dcb605a91d 552343895c0147d6945463a738fb6ec3 484cad2cd0464a36826e40dcb605a91d--552343895c0147d6945463a738fb6ec3 ae832e9c71844d97993afdf60d402f18 552343895c0147d6945463a738fb6ec3--ae832e9c71844d97993afdf60d402f18 b7da1bbbe10a4469bb1409805dd6afeb ae832e9c71844d97993afdf60d402f18--b7da1bbbe10a4469bb1409805dd6afeb f47acda180df45a583e944fb8fdfafd7 b7da1bbbe10a4469bb1409805dd6afeb--f47acda180df45a583e944fb8fdfafd7 8d6717e69ec7417e8744afcd656fc06a f47acda180df45a583e944fb8fdfafd7--8d6717e69ec7417e8744afcd656fc06a 3e68f8e9b0bf45518df4ba38cbf1b09d 8d6717e69ec7417e8744afcd656fc06a--3e68f8e9b0bf45518df4ba38cbf1b09d 4b5f59ec304d491da3cc71d53064c01b 3e68f8e9b0bf45518df4ba38cbf1b09d--4b5f59ec304d491da3cc71d53064c01b cf7d12fa54a94dc2ad02c1631f358aff 4b5f59ec304d491da3cc71d53064c01b--cf7d12fa54a94dc2ad02c1631f358aff 65d1a8fc6a1b496290e3ce5f127d4662 cf7d12fa54a94dc2ad02c1631f358aff--65d1a8fc6a1b496290e3ce5f127d4662 028b314e4ceb49fcaff1f8e6c3af1fd2 65d1a8fc6a1b496290e3ce5f127d4662--028b314e4ceb49fcaff1f8e6c3af1fd2 4b15d28587594f0f90eb4b78120997d1 X 028b314e4ceb49fcaff1f8e6c3af1fd2--4b15d28587594f0f90eb4b78120997d1 4b15d28587594f0f90eb4b78120997d1--0667693352a540c1ba511ecbb9ea9429 b2645aac520e434fbb18532f67ae17e9 RZ(-1.0*g0) 4b15d28587594f0f90eb4b78120997d1--b2645aac520e434fbb18532f67ae17e9 89a9e7cf67ac4986adeef8522793f8db X b2645aac520e434fbb18532f67ae17e9--89a9e7cf67ac4986adeef8522793f8db 89a9e7cf67ac4986adeef8522793f8db--4a1b3d25c935403787af147ba05cecf4 ea235465cb5b4b078fd86df7f12ba730 89a9e7cf67ac4986adeef8522793f8db--ea235465cb5b4b078fd86df7f12ba730 cefb69a27e9340f0b1e6f82934ed4ba1 ea235465cb5b4b078fd86df7f12ba730--cefb69a27e9340f0b1e6f82934ed4ba1 ff5c566d9c9a4dfaa649d6ea7f3bf6f4 cefb69a27e9340f0b1e6f82934ed4ba1--ff5c566d9c9a4dfaa649d6ea7f3bf6f4 fc53bced394c4e98828d2bfebc278d6c ff5c566d9c9a4dfaa649d6ea7f3bf6f4--fc53bced394c4e98828d2bfebc278d6c 48df0f11562e4d15a1455431585dde50 fc53bced394c4e98828d2bfebc278d6c--48df0f11562e4d15a1455431585dde50 d6ba559f09eb46fd88940a42f9e3dded 48df0f11562e4d15a1455431585dde50--d6ba559f09eb46fd88940a42f9e3dded e76e2c2863514a9ebb0249fa2d39537f d6ba559f09eb46fd88940a42f9e3dded--e76e2c2863514a9ebb0249fa2d39537f b92c3382b76a441a95b3c91a27f1b2eb e76e2c2863514a9ebb0249fa2d39537f--b92c3382b76a441a95b3c91a27f1b2eb c93d6e23b9794df29b05a6471be07f66 X b92c3382b76a441a95b3c91a27f1b2eb--c93d6e23b9794df29b05a6471be07f66 c93d6e23b9794df29b05a6471be07f66--f2de1529f8144596be8894199091ec3d 998195750d92405fa75e76ce9b17202e c93d6e23b9794df29b05a6471be07f66--998195750d92405fa75e76ce9b17202e eeb1f190c13e446f9c8ce4e6a7ec1025 998195750d92405fa75e76ce9b17202e--eeb1f190c13e446f9c8ce4e6a7ec1025 f3bd4ccc4d1e4334ae4b7b186e82a26b eeb1f190c13e446f9c8ce4e6a7ec1025--f3bd4ccc4d1e4334ae4b7b186e82a26b 32bd5063e65b4c71856b5b5d72943eb9 X f3bd4ccc4d1e4334ae4b7b186e82a26b--32bd5063e65b4c71856b5b5d72943eb9 32bd5063e65b4c71856b5b5d72943eb9--fa1bc4f5399848de8eeb5f5ea5ea8734 b6ba7fd64a6f4da58e6118ec8602b370 32bd5063e65b4c71856b5b5d72943eb9--b6ba7fd64a6f4da58e6118ec8602b370 2feac2900a224fffbd66716b5d54f805 b6ba7fd64a6f4da58e6118ec8602b370--2feac2900a224fffbd66716b5d54f805 c0ffaf350b164541b3d00f6f62120740 2feac2900a224fffbd66716b5d54f805--c0ffaf350b164541b3d00f6f62120740 b917d44c9e3f42a28479be4e407ae98c c0ffaf350b164541b3d00f6f62120740--b917d44c9e3f42a28479be4e407ae98c eca38aa6895f4c1f942356ef72ae1d05 b917d44c9e3f42a28479be4e407ae98c--eca38aa6895f4c1f942356ef72ae1d05 13c54fc090a64a72a3b5672b0d07c69f eca38aa6895f4c1f942356ef72ae1d05--13c54fc090a64a72a3b5672b0d07c69f 4a0b67bf19164a8d8a93d2d30347485d 13c54fc090a64a72a3b5672b0d07c69f--4a0b67bf19164a8d8a93d2d30347485d 59a8af15e35c4647b3f679c986284567 X 4a0b67bf19164a8d8a93d2d30347485d--59a8af15e35c4647b3f679c986284567 59a8af15e35c4647b3f679c986284567--d5cbbe86b07e49189d590bccd2e5add2 a84c39740505492182702e1103d3d7eb 59a8af15e35c4647b3f679c986284567--a84c39740505492182702e1103d3d7eb 877960e2bf3f488192da12ab9e23a6c6 a84c39740505492182702e1103d3d7eb--877960e2bf3f488192da12ab9e23a6c6 e9772b45bf32477295a77b66205a0321 877960e2bf3f488192da12ab9e23a6c6--e9772b45bf32477295a77b66205a0321 6b9d59a0bc214d99bc0c16e6145a268c X e9772b45bf32477295a77b66205a0321--6b9d59a0bc214d99bc0c16e6145a268c 6b9d59a0bc214d99bc0c16e6145a268c--c687f57ca5874cf7a91f82115ff88006 bb32d932098e4b99b6c50ec63bbebd57 6b9d59a0bc214d99bc0c16e6145a268c--bb32d932098e4b99b6c50ec63bbebd57 70850b05b1214f23b8dc9ac82ff0251e bb32d932098e4b99b6c50ec63bbebd57--70850b05b1214f23b8dc9ac82ff0251e 13cbb9e3df9246b1b131d98405f9c522 70850b05b1214f23b8dc9ac82ff0251e--13cbb9e3df9246b1b131d98405f9c522 350be99fff684b0c968f1d077a11752b 13cbb9e3df9246b1b131d98405f9c522--350be99fff684b0c968f1d077a11752b dbbe3e8b168947e2b94be563012a6cf7 350be99fff684b0c968f1d077a11752b--dbbe3e8b168947e2b94be563012a6cf7 a8eb1e45633c45798b1f7cb119dec14a dbbe3e8b168947e2b94be563012a6cf7--a8eb1e45633c45798b1f7cb119dec14a b295c9e1c4144e1c9b1fb2d858913094 a8eb1e45633c45798b1f7cb119dec14a--b295c9e1c4144e1c9b1fb2d858913094 818300f23c7247fe8dd43bbbfa0f389d b295c9e1c4144e1c9b1fb2d858913094--818300f23c7247fe8dd43bbbfa0f389d cbe7629a43974f32b3bbe2446c55e6f7 818300f23c7247fe8dd43bbbfa0f389d--cbe7629a43974f32b3bbe2446c55e6f7 b9ad21b9cdb54e6598bf2b7ba15be30c cbe7629a43974f32b3bbe2446c55e6f7--b9ad21b9cdb54e6598bf2b7ba15be30c a414e965bf2d4b5aabc845e32b2eb17d b9ad21b9cdb54e6598bf2b7ba15be30c--a414e965bf2d4b5aabc845e32b2eb17d c88d351ae0db45ee894f8cc0428be72c a414e965bf2d4b5aabc845e32b2eb17d--c88d351ae0db45ee894f8cc0428be72c 18b71f335b9c42969e75c2af74cde1a3 c88d351ae0db45ee894f8cc0428be72c--18b71f335b9c42969e75c2af74cde1a3 afb290b5153249598e6ef6fa08562c08 X 18b71f335b9c42969e75c2af74cde1a3--afb290b5153249598e6ef6fa08562c08 afb290b5153249598e6ef6fa08562c08--457eb8cb9bd74469a38eb8a33a8a2f94 7f744b9880f84da69283fb925f62d672 afb290b5153249598e6ef6fa08562c08--7f744b9880f84da69283fb925f62d672 eb982f1927c048eda8649d466375e055 7f744b9880f84da69283fb925f62d672--eb982f1927c048eda8649d466375e055 cb47884ff7184ab4b61c3246587f9a99 eb982f1927c048eda8649d466375e055--cb47884ff7184ab4b61c3246587f9a99 00dcabb8405a43b7931bfd1d4d5714ed X cb47884ff7184ab4b61c3246587f9a99--00dcabb8405a43b7931bfd1d4d5714ed 00dcabb8405a43b7931bfd1d4d5714ed--769fc298fe5242ee8a5bdbc96e3551a3 e112db520c184dbe83e703063f1d825f 00dcabb8405a43b7931bfd1d4d5714ed--e112db520c184dbe83e703063f1d825f 74fb75c6e3ca4dcdbe5bb68eafd74e87 e112db520c184dbe83e703063f1d825f--74fb75c6e3ca4dcdbe5bb68eafd74e87 aeb4b495067a4ef5a58280c70d793785 74fb75c6e3ca4dcdbe5bb68eafd74e87--aeb4b495067a4ef5a58280c70d793785 980291059b3a4e358af477b1b30d1931 aeb4b495067a4ef5a58280c70d793785--980291059b3a4e358af477b1b30d1931 ea7f52d1776646eaac61e6af0b8c84f4 X 980291059b3a4e358af477b1b30d1931--ea7f52d1776646eaac61e6af0b8c84f4 ea7f52d1776646eaac61e6af0b8c84f4--c6fb5a92899b41098d4f310226a6d02f fbb2a9276a2a405a874afb1c00d03c31 ea7f52d1776646eaac61e6af0b8c84f4--fbb2a9276a2a405a874afb1c00d03c31 4278597c1d4f47c4a26e6db478c354a8 fbb2a9276a2a405a874afb1c00d03c31--4278597c1d4f47c4a26e6db478c354a8 00f050a73f1d454cadd1600b27f71fc2 4278597c1d4f47c4a26e6db478c354a8--00f050a73f1d454cadd1600b27f71fc2 6053495ee50e407facdce1bd9517b104 00f050a73f1d454cadd1600b27f71fc2--6053495ee50e407facdce1bd9517b104 c877a068415148b39cf3fa4a36be3ab4 6053495ee50e407facdce1bd9517b104--c877a068415148b39cf3fa4a36be3ab4 8c5e5be226d84ad39079c3b8220eca25 X c877a068415148b39cf3fa4a36be3ab4--8c5e5be226d84ad39079c3b8220eca25 8c5e5be226d84ad39079c3b8220eca25--4a930843d2174b9492d60c223fbf7be2 70bbe37b7f0746df99c767720b32b505 8c5e5be226d84ad39079c3b8220eca25--70bbe37b7f0746df99c767720b32b505 387715e484014d7abb7f0e5476fa9213 70bbe37b7f0746df99c767720b32b505--387715e484014d7abb7f0e5476fa9213 f3c4f538b81a426fbb5ce5059e454842 387715e484014d7abb7f0e5476fa9213--f3c4f538b81a426fbb5ce5059e454842 7788d090c17d4ad19ab8625ac614183a f3c4f538b81a426fbb5ce5059e454842--7788d090c17d4ad19ab8625ac614183a 4525e6d4c8f6494a981125883d5b40c8 7788d090c17d4ad19ab8625ac614183a--4525e6d4c8f6494a981125883d5b40c8 15b60a802f8c4e9e8acd6e5dbf18fe02 X 4525e6d4c8f6494a981125883d5b40c8--15b60a802f8c4e9e8acd6e5dbf18fe02 15b60a802f8c4e9e8acd6e5dbf18fe02--2bcec6791ab74b1e9e9f7283819f2614 52385158c98743ecb1833ad7df1701ea 15b60a802f8c4e9e8acd6e5dbf18fe02--52385158c98743ecb1833ad7df1701ea bf88dcda4a7c448d9ba3ad5a8174bc37 52385158c98743ecb1833ad7df1701ea--bf88dcda4a7c448d9ba3ad5a8174bc37 af99b8528aac4d9680180816ef34c58c bf88dcda4a7c448d9ba3ad5a8174bc37--af99b8528aac4d9680180816ef34c58c 431abe3e29d84ff49760f858dcf8238f X af99b8528aac4d9680180816ef34c58c--431abe3e29d84ff49760f858dcf8238f 431abe3e29d84ff49760f858dcf8238f--002aa4628cfa4172b47467eee8757568 25a4b12985db480ba6012f67aa9e6120 X 431abe3e29d84ff49760f858dcf8238f--25a4b12985db480ba6012f67aa9e6120 25a4b12985db480ba6012f67aa9e6120--a0d245417706429a847e89e182334fc8 a81f42b03b4f49088c0c67327d077ad1 25a4b12985db480ba6012f67aa9e6120--a81f42b03b4f49088c0c67327d077ad1 6cec00247a3c404586baabe0183a88f1 a81f42b03b4f49088c0c67327d077ad1--6cec00247a3c404586baabe0183a88f1 9ac7205ad0744204bb06e13bbb06e4e8 6cec00247a3c404586baabe0183a88f1--9ac7205ad0744204bb06e13bbb06e4e8 7b7650ac828542d8adc7491c4fccc7e9 9ac7205ad0744204bb06e13bbb06e4e8--7b7650ac828542d8adc7491c4fccc7e9 dae4f0ab194c4aba9b5ae0d09dca2144 7b7650ac828542d8adc7491c4fccc7e9--dae4f0ab194c4aba9b5ae0d09dca2144 4caf017732d6446595ef73dd6c34c2ce X dae4f0ab194c4aba9b5ae0d09dca2144--4caf017732d6446595ef73dd6c34c2ce 4caf017732d6446595ef73dd6c34c2ce--8b99db6ed3424a46b74f4353ef832f9b 040ea56593604b66b18b961c7137137f RX(b05) 4caf017732d6446595ef73dd6c34c2ce--040ea56593604b66b18b961c7137137f f1a52dac52ef4b75b872dc98caf9994b 040ea56593604b66b18b961c7137137f--f1a52dac52ef4b75b872dc98caf9994b 092cfc98882f46d382287634b1355a50 f1a52dac52ef4b75b872dc98caf9994b--092cfc98882f46d382287634b1355a50 243f1fae13be4bedab9d0473a805f479 092cfc98882f46d382287634b1355a50--243f1fae13be4bedab9d0473a805f479 acc6ba3c403f4436aeb29179edb9940a 243f1fae13be4bedab9d0473a805f479--acc6ba3c403f4436aeb29179edb9940a cf4793e8610345bf81c505ea98041444 X acc6ba3c403f4436aeb29179edb9940a--cf4793e8610345bf81c505ea98041444 cf4793e8610345bf81c505ea98041444--bec3bd8b0692486aa5e426ad2104abb4 afa4ac2cdfd94f2b89a1ee39a5ec836c cf4793e8610345bf81c505ea98041444--afa4ac2cdfd94f2b89a1ee39a5ec836c 3747bad55bc94ac9ad252cdf63e25032 afa4ac2cdfd94f2b89a1ee39a5ec836c--3747bad55bc94ac9ad252cdf63e25032 8ee413878f824e9aa7f13618d0aeb64f 3747bad55bc94ac9ad252cdf63e25032--8ee413878f824e9aa7f13618d0aeb64f f8655e32e6434fd19d89391ba195256e 8ee413878f824e9aa7f13618d0aeb64f--f8655e32e6434fd19d89391ba195256e 41c5660658d34957a62d42545306515f f8655e32e6434fd19d89391ba195256e--41c5660658d34957a62d42545306515f a1830536bbce416b86bba1b11347d5d3 X 41c5660658d34957a62d42545306515f--a1830536bbce416b86bba1b11347d5d3 a1830536bbce416b86bba1b11347d5d3--8f071f86a4e14aa8b1ce752853c6722e 79866c5a6fb949969c66619663333cd7 a1830536bbce416b86bba1b11347d5d3--79866c5a6fb949969c66619663333cd7 da99377faf2c4c728b9ba29101d531dd 79866c5a6fb949969c66619663333cd7--da99377faf2c4c728b9ba29101d531dd ec99e830698743c2ac3106112c2f0ac9 da99377faf2c4c728b9ba29101d531dd--ec99e830698743c2ac3106112c2f0ac9 8f768616cd044f978e53cf4fefc52c26 ec99e830698743c2ac3106112c2f0ac9--8f768616cd044f978e53cf4fefc52c26 024997949f8e457298fc2887dbe8d3d9 8f768616cd044f978e53cf4fefc52c26--024997949f8e457298fc2887dbe8d3d9 250e0dcbfa0048ceb7dc57ad0376002a 024997949f8e457298fc2887dbe8d3d9--250e0dcbfa0048ceb7dc57ad0376002a 80b6e982f5274ee4b4001d364a5394a4 250e0dcbfa0048ceb7dc57ad0376002a--80b6e982f5274ee4b4001d364a5394a4 797af42ff0364eb6ac2205b9458ddcc5 80b6e982f5274ee4b4001d364a5394a4--797af42ff0364eb6ac2205b9458ddcc5 a806122427444f4f8fd3d8cedf15bc30 797af42ff0364eb6ac2205b9458ddcc5--a806122427444f4f8fd3d8cedf15bc30 6e5758a4573d4bae965f4419e920715a a806122427444f4f8fd3d8cedf15bc30--6e5758a4573d4bae965f4419e920715a 8f383f2c18a44dd0a0a0213118a99b60 6e5758a4573d4bae965f4419e920715a--8f383f2c18a44dd0a0a0213118a99b60 7a4400c3757f40638cdd98be1a28067a 8f383f2c18a44dd0a0a0213118a99b60--7a4400c3757f40638cdd98be1a28067a 6e457ad6546f428ab686f6bac726ec36 7a4400c3757f40638cdd98be1a28067a--6e457ad6546f428ab686f6bac726ec36 269bdea558ad489c854bd391bd51ad60 6e457ad6546f428ab686f6bac726ec36--269bdea558ad489c854bd391bd51ad60 9c7c3c88dcec4beba631d2a4c9615aa1 269bdea558ad489c854bd391bd51ad60--9c7c3c88dcec4beba631d2a4c9615aa1 59ab1268be034031876ed6298c6425f0 9c7c3c88dcec4beba631d2a4c9615aa1--59ab1268be034031876ed6298c6425f0 c18f478c99314048a60a4a318b2f2eb2 59ab1268be034031876ed6298c6425f0--c18f478c99314048a60a4a318b2f2eb2 3793ac5ebc50440f9b0cd82e43a8954e c18f478c99314048a60a4a318b2f2eb2--3793ac5ebc50440f9b0cd82e43a8954e 92acc672c92d4ba283ad7a41238ad2a6 3793ac5ebc50440f9b0cd82e43a8954e--92acc672c92d4ba283ad7a41238ad2a6 d262e9a19cd840e3809bc606a37b8a0a 92acc672c92d4ba283ad7a41238ad2a6--d262e9a19cd840e3809bc606a37b8a0a 38493a3017514f679a7373aca0d82f18 d262e9a19cd840e3809bc606a37b8a0a--38493a3017514f679a7373aca0d82f18 0f588aae84084436b10ebb102f8f8ec1 38493a3017514f679a7373aca0d82f18--0f588aae84084436b10ebb102f8f8ec1 9e6076101ebe4f059f2aedc140b13ce0 0f588aae84084436b10ebb102f8f8ec1--9e6076101ebe4f059f2aedc140b13ce0 cf89a1c04e144a76aacaea558f1d202a 9e6076101ebe4f059f2aedc140b13ce0--cf89a1c04e144a76aacaea558f1d202a e0e1a40b712740ac8a2cd331ebedc47f cf89a1c04e144a76aacaea558f1d202a--e0e1a40b712740ac8a2cd331ebedc47f cb79c25ffab1472696d147595be30542 e0e1a40b712740ac8a2cd331ebedc47f--cb79c25ffab1472696d147595be30542 d28b05cd4841404791a28654381c3093 cb79c25ffab1472696d147595be30542--d28b05cd4841404791a28654381c3093 908c25f4c81f45259e21f528c12837d1 X d28b05cd4841404791a28654381c3093--908c25f4c81f45259e21f528c12837d1 908c25f4c81f45259e21f528c12837d1--5f1f98e8358e43fbb366bd0cc50e26f9 1fb6da38c4524d67b900c8e7ba33958f RZ(-1.0*g1) 908c25f4c81f45259e21f528c12837d1--1fb6da38c4524d67b900c8e7ba33958f 81712afa72a5412f8a99db24981ec655 X 1fb6da38c4524d67b900c8e7ba33958f--81712afa72a5412f8a99db24981ec655 81712afa72a5412f8a99db24981ec655--07428e6a191447ce814edbe9bde2940d 74bc27553ace484ea367e340eceabd82 81712afa72a5412f8a99db24981ec655--74bc27553ace484ea367e340eceabd82 78aeb80bf38043a290e1bf1d5180a003 74bc27553ace484ea367e340eceabd82--78aeb80bf38043a290e1bf1d5180a003 e1e4805130d4446a8145b5795f7b7662 78aeb80bf38043a290e1bf1d5180a003--e1e4805130d4446a8145b5795f7b7662 0c8d8b9212584e76bc627d158ab11068 e1e4805130d4446a8145b5795f7b7662--0c8d8b9212584e76bc627d158ab11068 a18f969e34cd4a4586cb39dc07fc8583 0c8d8b9212584e76bc627d158ab11068--a18f969e34cd4a4586cb39dc07fc8583 5907995b407b4b318866ed02e95bdf45 a18f969e34cd4a4586cb39dc07fc8583--5907995b407b4b318866ed02e95bdf45 5990745f52234206ba10e07ab58e41ee 5907995b407b4b318866ed02e95bdf45--5990745f52234206ba10e07ab58e41ee e27fb459511744b0986cb461c552a61a 5990745f52234206ba10e07ab58e41ee--e27fb459511744b0986cb461c552a61a 54c5b89fb76d451aa34f92a0346abe83 X e27fb459511744b0986cb461c552a61a--54c5b89fb76d451aa34f92a0346abe83 54c5b89fb76d451aa34f92a0346abe83--fd1a2408792f4e4399b12be7fb5dd6ee 5ae494b3cd534c068b9e9a23f9933627 54c5b89fb76d451aa34f92a0346abe83--5ae494b3cd534c068b9e9a23f9933627 2c13effcefeb445d873433149e78112e 5ae494b3cd534c068b9e9a23f9933627--2c13effcefeb445d873433149e78112e 2b75ba86dec14e4fb397821f1e1043c0 2c13effcefeb445d873433149e78112e--2b75ba86dec14e4fb397821f1e1043c0 3e028d63d2e240bc988a25724c9f987e X 2b75ba86dec14e4fb397821f1e1043c0--3e028d63d2e240bc988a25724c9f987e 3e028d63d2e240bc988a25724c9f987e--14d08d6701d34c319bdd71093e42da9d 21e1e177c90940859cad6b8dfc59d2b1 3e028d63d2e240bc988a25724c9f987e--21e1e177c90940859cad6b8dfc59d2b1 2b96294ba13b4ed9aea8c0a3c8e7fde7 21e1e177c90940859cad6b8dfc59d2b1--2b96294ba13b4ed9aea8c0a3c8e7fde7 f01b5c76938848f4ac0f0efd1f9f8032 2b96294ba13b4ed9aea8c0a3c8e7fde7--f01b5c76938848f4ac0f0efd1f9f8032 16c0c2ef7d93490c8f411c39303345e5 f01b5c76938848f4ac0f0efd1f9f8032--16c0c2ef7d93490c8f411c39303345e5 a796994d61144a169d0b7a4c77a87a56 16c0c2ef7d93490c8f411c39303345e5--a796994d61144a169d0b7a4c77a87a56 bc3871caa5e9400e8e9b14d27f10cc76 a796994d61144a169d0b7a4c77a87a56--bc3871caa5e9400e8e9b14d27f10cc76 d0f504b36a974fb2a31ff28c14254ab6 bc3871caa5e9400e8e9b14d27f10cc76--d0f504b36a974fb2a31ff28c14254ab6 834910acc8c3453fad3726381c28b0b9 X d0f504b36a974fb2a31ff28c14254ab6--834910acc8c3453fad3726381c28b0b9 834910acc8c3453fad3726381c28b0b9--6224594ed4474b9b9eb83cbe36f9adb7 26f31e482edc4f5194a02d61d82fa4fc 834910acc8c3453fad3726381c28b0b9--26f31e482edc4f5194a02d61d82fa4fc 6056fda7022a44f0ad4d579b6743071c 26f31e482edc4f5194a02d61d82fa4fc--6056fda7022a44f0ad4d579b6743071c 40119f201adf452db90c5dfb0e04d5bb 6056fda7022a44f0ad4d579b6743071c--40119f201adf452db90c5dfb0e04d5bb 298deba2c1a8433ca24b7fffc40a8d39 X 40119f201adf452db90c5dfb0e04d5bb--298deba2c1a8433ca24b7fffc40a8d39 298deba2c1a8433ca24b7fffc40a8d39--2a377251653f4d129a6d4a7c348f2943 72e2cf8e52e244eeb02a7533daf03f85 298deba2c1a8433ca24b7fffc40a8d39--72e2cf8e52e244eeb02a7533daf03f85 87f2b09337d4460b94c7c315e5b9d2b0 72e2cf8e52e244eeb02a7533daf03f85--87f2b09337d4460b94c7c315e5b9d2b0 431fb283ac6e4b299f14124a737c4da9 87f2b09337d4460b94c7c315e5b9d2b0--431fb283ac6e4b299f14124a737c4da9 d6497aefe8f444139b6ed73214cf9358 431fb283ac6e4b299f14124a737c4da9--d6497aefe8f444139b6ed73214cf9358 e317b495eaa1485f98d714c65ebd03b6 d6497aefe8f444139b6ed73214cf9358--e317b495eaa1485f98d714c65ebd03b6 9fc9df43378f4ae9b8e5b325a8f06ef0 e317b495eaa1485f98d714c65ebd03b6--9fc9df43378f4ae9b8e5b325a8f06ef0 1eedffc7855a4ee6a983d4e7f88e651b 9fc9df43378f4ae9b8e5b325a8f06ef0--1eedffc7855a4ee6a983d4e7f88e651b f95321a0fddf420eb9e52b8fcccab6c5 1eedffc7855a4ee6a983d4e7f88e651b--f95321a0fddf420eb9e52b8fcccab6c5 4bca8fd70d3c4917b9c4a2ec1157e45f f95321a0fddf420eb9e52b8fcccab6c5--4bca8fd70d3c4917b9c4a2ec1157e45f ee34e0193f0448c6bd30b93dbbb5db76 4bca8fd70d3c4917b9c4a2ec1157e45f--ee34e0193f0448c6bd30b93dbbb5db76 aaf4ec2769264133bfc96fce76179126 ee34e0193f0448c6bd30b93dbbb5db76--aaf4ec2769264133bfc96fce76179126 0fbe93df07bc4338a3531e8cdcdcf8a2 aaf4ec2769264133bfc96fce76179126--0fbe93df07bc4338a3531e8cdcdcf8a2 95e3adcbda864e45b2a642e0d6307987 0fbe93df07bc4338a3531e8cdcdcf8a2--95e3adcbda864e45b2a642e0d6307987 216bff3f2e194194981f5859c57f02b9 X 95e3adcbda864e45b2a642e0d6307987--216bff3f2e194194981f5859c57f02b9 216bff3f2e194194981f5859c57f02b9--e130087fd56643fc887533ba0b8bf6b7 57c82d071722499dbfe71f96c2d3409c 216bff3f2e194194981f5859c57f02b9--57c82d071722499dbfe71f96c2d3409c 2ba63dc79fce4eafa5df0d2722afc2a3 57c82d071722499dbfe71f96c2d3409c--2ba63dc79fce4eafa5df0d2722afc2a3 b7a7a3b4722347799b7e3ee55bef4c6a 2ba63dc79fce4eafa5df0d2722afc2a3--b7a7a3b4722347799b7e3ee55bef4c6a 0ff0211d2935429ab56b378a8998156b X b7a7a3b4722347799b7e3ee55bef4c6a--0ff0211d2935429ab56b378a8998156b 0ff0211d2935429ab56b378a8998156b--9ab3a4ef01a741c1a4340a596d9cdae8 a651e476f1ec4460a793215c6af93c21 0ff0211d2935429ab56b378a8998156b--a651e476f1ec4460a793215c6af93c21 9ada1071acae4738abe28f6739744da5 a651e476f1ec4460a793215c6af93c21--9ada1071acae4738abe28f6739744da5 ff62a186a3ed45b3a1b6045261876482 9ada1071acae4738abe28f6739744da5--ff62a186a3ed45b3a1b6045261876482 d55f7dde1b7044bfadf7938d14ee8a03 ff62a186a3ed45b3a1b6045261876482--d55f7dde1b7044bfadf7938d14ee8a03 42c32fb28fc0478b83cf1b42291c5efa X d55f7dde1b7044bfadf7938d14ee8a03--42c32fb28fc0478b83cf1b42291c5efa 42c32fb28fc0478b83cf1b42291c5efa--e3ec8a4527694ca59afc75affba62266 7f153e2b3a9a441984ab7e8500000b7c 42c32fb28fc0478b83cf1b42291c5efa--7f153e2b3a9a441984ab7e8500000b7c 70b75bf81ecd40be8aba0ce89914da32 7f153e2b3a9a441984ab7e8500000b7c--70b75bf81ecd40be8aba0ce89914da32 6eae7f9a2fe64a8391af20efa585753d 70b75bf81ecd40be8aba0ce89914da32--6eae7f9a2fe64a8391af20efa585753d 0fe8da778cff42bfb73e77299cf7fc1b 6eae7f9a2fe64a8391af20efa585753d--0fe8da778cff42bfb73e77299cf7fc1b 8f752a7f019b4859a28c9c7b3cdc03cd 0fe8da778cff42bfb73e77299cf7fc1b--8f752a7f019b4859a28c9c7b3cdc03cd 939523704faf40519bd65aa90bced2c4 X 8f752a7f019b4859a28c9c7b3cdc03cd--939523704faf40519bd65aa90bced2c4 939523704faf40519bd65aa90bced2c4--a978464f939141aca6a4b29f64e915a9 8d07cb3d2c964c0593162d68b15f0dc8 939523704faf40519bd65aa90bced2c4--8d07cb3d2c964c0593162d68b15f0dc8 3cdb472118a34f98beb18030190169f6 8d07cb3d2c964c0593162d68b15f0dc8--3cdb472118a34f98beb18030190169f6 146642627a6f4c83a201d5c77fb8447a 3cdb472118a34f98beb18030190169f6--146642627a6f4c83a201d5c77fb8447a 2dc484a22e2a459c8802dc37cb5567c3 146642627a6f4c83a201d5c77fb8447a--2dc484a22e2a459c8802dc37cb5567c3 1ad78cd1195a4d36a0c678710ceffa6c 2dc484a22e2a459c8802dc37cb5567c3--1ad78cd1195a4d36a0c678710ceffa6c 08ee61821f2a48ff8eb2380dd30b2c64 X 1ad78cd1195a4d36a0c678710ceffa6c--08ee61821f2a48ff8eb2380dd30b2c64 08ee61821f2a48ff8eb2380dd30b2c64--85b1e65b2f01480b8564c85b2074cc96 1712ec44d23b4d32ae85f8fecad436a8 08ee61821f2a48ff8eb2380dd30b2c64--1712ec44d23b4d32ae85f8fecad436a8 7e1655ff3fd14e2bacb0116fc69d9479 1712ec44d23b4d32ae85f8fecad436a8--7e1655ff3fd14e2bacb0116fc69d9479 c821f9d5a7dc420da0468ed4a30981d3 7e1655ff3fd14e2bacb0116fc69d9479--c821f9d5a7dc420da0468ed4a30981d3 549d6818b4a54365b4d7ed92e696f61c X c821f9d5a7dc420da0468ed4a30981d3--549d6818b4a54365b4d7ed92e696f61c 549d6818b4a54365b4d7ed92e696f61c--2a1af7f75dc844798a67e1732441d50c 92623190e90e4bfda49c3e46e51ddff0 X 549d6818b4a54365b4d7ed92e696f61c--92623190e90e4bfda49c3e46e51ddff0 92623190e90e4bfda49c3e46e51ddff0--a20bc6676b5e462fa8c3da0fbcac50a6 db009c9bd4574f49bddb0f2fc63e4177 92623190e90e4bfda49c3e46e51ddff0--db009c9bd4574f49bddb0f2fc63e4177 68d2016f0d594810b4c90041eb76e05f db009c9bd4574f49bddb0f2fc63e4177--68d2016f0d594810b4c90041eb76e05f bade1dd97b1b464695fff3e7ad93f61d 68d2016f0d594810b4c90041eb76e05f--bade1dd97b1b464695fff3e7ad93f61d 915e059a04254800b5aa6ed070904fef bade1dd97b1b464695fff3e7ad93f61d--915e059a04254800b5aa6ed070904fef 5984524c241c49adb4527955f4b5ebe6 915e059a04254800b5aa6ed070904fef--5984524c241c49adb4527955f4b5ebe6 6d83d3314faa476ab611a898df57e023 X 5984524c241c49adb4527955f4b5ebe6--6d83d3314faa476ab611a898df57e023 6d83d3314faa476ab611a898df57e023--3306263881444da5a2b9451958d36007 a5024d88145547599844e40dcc7a7737 RX(b15) 6d83d3314faa476ab611a898df57e023--a5024d88145547599844e40dcc7a7737 a5024d88145547599844e40dcc7a7737--3a4719c9916e4f6a99072658fa1ec60c 58fe48b198364de98687f57d283bd37b 76942851695f4942b0a0af22c7b5b69e 0827ceb13e8d429cb95ff717f77d041f--76942851695f4942b0a0af22c7b5b69e 8ce05e1eff12478b96fa045920405289 7 4e48475097e14cb08da4ee6dbfd9297a 76942851695f4942b0a0af22c7b5b69e--4e48475097e14cb08da4ee6dbfd9297a a6d42feb868342d49ebdfab424ca32c9 4e48475097e14cb08da4ee6dbfd9297a--a6d42feb868342d49ebdfab424ca32c9 a3e4b4647b4e437fb111b9947ab6f6f8 a6d42feb868342d49ebdfab424ca32c9--a3e4b4647b4e437fb111b9947ab6f6f8 5a590a938a6846d08d8f0390acfebf20 a3e4b4647b4e437fb111b9947ab6f6f8--5a590a938a6846d08d8f0390acfebf20 4d3fc25c5a9640ebb3dc64fec9bdd37a X 5a590a938a6846d08d8f0390acfebf20--4d3fc25c5a9640ebb3dc64fec9bdd37a 4d3fc25c5a9640ebb3dc64fec9bdd37a--b908d365bc214027b3e4f585599d8d0d 75b4d53032b04170b10a0ac2870d0b58 4d3fc25c5a9640ebb3dc64fec9bdd37a--75b4d53032b04170b10a0ac2870d0b58 d14c877ac6dc481789c61d3aa5c0d4a0 75b4d53032b04170b10a0ac2870d0b58--d14c877ac6dc481789c61d3aa5c0d4a0 f1239f4c89dd44d0887101c57d251a15 d14c877ac6dc481789c61d3aa5c0d4a0--f1239f4c89dd44d0887101c57d251a15 a18b690198ea467caae2757bf60ba5fb X f1239f4c89dd44d0887101c57d251a15--a18b690198ea467caae2757bf60ba5fb a18b690198ea467caae2757bf60ba5fb--f8ec9caccecc4f6a874b3e1c65147ca7 962444f317d74667b7008edd1335eb39 a18b690198ea467caae2757bf60ba5fb--962444f317d74667b7008edd1335eb39 549ff8cfabcb4213b7e07f6a577e72f7 962444f317d74667b7008edd1335eb39--549ff8cfabcb4213b7e07f6a577e72f7 9679ffc5d70348e3bc1d3a5dd3fb0e21 549ff8cfabcb4213b7e07f6a577e72f7--9679ffc5d70348e3bc1d3a5dd3fb0e21 03dfbdb7691d4780bf07ff528b6873ab 9679ffc5d70348e3bc1d3a5dd3fb0e21--03dfbdb7691d4780bf07ff528b6873ab ff0c6a10803e4f298fb6dcb627575916 03dfbdb7691d4780bf07ff528b6873ab--ff0c6a10803e4f298fb6dcb627575916 f6bd80bd943d4d4388e548ce5e91669e ff0c6a10803e4f298fb6dcb627575916--f6bd80bd943d4d4388e548ce5e91669e 126a63913d9540bbbf1b0ee9c57c213b f6bd80bd943d4d4388e548ce5e91669e--126a63913d9540bbbf1b0ee9c57c213b f42260a3e9ac4ca6aadc7ab361d1a0a0 126a63913d9540bbbf1b0ee9c57c213b--f42260a3e9ac4ca6aadc7ab361d1a0a0 c2fd9f06b5f94a7f8c62ffa1f3d2e48f f42260a3e9ac4ca6aadc7ab361d1a0a0--c2fd9f06b5f94a7f8c62ffa1f3d2e48f 3f2ffd0813b347cb92fa0d1ca20694a8 c2fd9f06b5f94a7f8c62ffa1f3d2e48f--3f2ffd0813b347cb92fa0d1ca20694a8 0958ae5655ec4ee088b84a6ebe11acd6 3f2ffd0813b347cb92fa0d1ca20694a8--0958ae5655ec4ee088b84a6ebe11acd6 105a8a98eb1d4ab79838d14532d87fae 0958ae5655ec4ee088b84a6ebe11acd6--105a8a98eb1d4ab79838d14532d87fae 128924f700a0416daad7a2861648f26b 105a8a98eb1d4ab79838d14532d87fae--128924f700a0416daad7a2861648f26b 1e436bea99a8441b982f4d470bb5815b 128924f700a0416daad7a2861648f26b--1e436bea99a8441b982f4d470bb5815b 4772e71438d74de785b33363c3507dc8 1e436bea99a8441b982f4d470bb5815b--4772e71438d74de785b33363c3507dc8 3b1e6d9a46c84f529cd1277041cc0289 4772e71438d74de785b33363c3507dc8--3b1e6d9a46c84f529cd1277041cc0289 500777e3eef4498ea8f5f7bec3b8ddff 3b1e6d9a46c84f529cd1277041cc0289--500777e3eef4498ea8f5f7bec3b8ddff fe731c555f3641c99bf34ead0b8f289c 500777e3eef4498ea8f5f7bec3b8ddff--fe731c555f3641c99bf34ead0b8f289c d2edc8818c434d5d881b1062836d840e fe731c555f3641c99bf34ead0b8f289c--d2edc8818c434d5d881b1062836d840e 144bcff676cc4e8582e2a5f3db1ef921 d2edc8818c434d5d881b1062836d840e--144bcff676cc4e8582e2a5f3db1ef921 1bf1f29e7d2f48c6ba191d93ccec2f21 144bcff676cc4e8582e2a5f3db1ef921--1bf1f29e7d2f48c6ba191d93ccec2f21 740e486c494c48b48b039af1b5a6e6fa 1bf1f29e7d2f48c6ba191d93ccec2f21--740e486c494c48b48b039af1b5a6e6fa 5fcaf8f1b91d434fa0bc2a17a4eb46bb 740e486c494c48b48b039af1b5a6e6fa--5fcaf8f1b91d434fa0bc2a17a4eb46bb f96eb3313fa642ec80abd8b013d16a2b 5fcaf8f1b91d434fa0bc2a17a4eb46bb--f96eb3313fa642ec80abd8b013d16a2b baa42c173e9c44acb923f8abf9f905f2 f96eb3313fa642ec80abd8b013d16a2b--baa42c173e9c44acb923f8abf9f905f2 fac484f817f74cfd8305adf1ae3fc5b9 baa42c173e9c44acb923f8abf9f905f2--fac484f817f74cfd8305adf1ae3fc5b9 d40a80a145dd40eebb9d70c323adf193 fac484f817f74cfd8305adf1ae3fc5b9--d40a80a145dd40eebb9d70c323adf193 d865afde956c49e4a6cb3308280a3084 d40a80a145dd40eebb9d70c323adf193--d865afde956c49e4a6cb3308280a3084 055443d10d9445af89f49d808a3b016e d865afde956c49e4a6cb3308280a3084--055443d10d9445af89f49d808a3b016e de76c1ea063f4c0abb391a0eaa7d6c99 055443d10d9445af89f49d808a3b016e--de76c1ea063f4c0abb391a0eaa7d6c99 bba363c1e8e4471390ef77294b70bec9 de76c1ea063f4c0abb391a0eaa7d6c99--bba363c1e8e4471390ef77294b70bec9 a2cf967b77fe43b6b89d53067b5593fd bba363c1e8e4471390ef77294b70bec9--a2cf967b77fe43b6b89d53067b5593fd c90293e54b5340c4937da77a5cdd82d5 a2cf967b77fe43b6b89d53067b5593fd--c90293e54b5340c4937da77a5cdd82d5 048a52b5f63d45a69c1c66d31a666c09 c90293e54b5340c4937da77a5cdd82d5--048a52b5f63d45a69c1c66d31a666c09 89fe6e337c9c41fdab2597230aa90fd8 048a52b5f63d45a69c1c66d31a666c09--89fe6e337c9c41fdab2597230aa90fd8 3cdf2689be584928b9c3c56eca07c274 89fe6e337c9c41fdab2597230aa90fd8--3cdf2689be584928b9c3c56eca07c274 9cbf2f120777412f9d5c96de5cb7eb48 3cdf2689be584928b9c3c56eca07c274--9cbf2f120777412f9d5c96de5cb7eb48 a3409106ea9c460f9e3e91f38d8467a9 9cbf2f120777412f9d5c96de5cb7eb48--a3409106ea9c460f9e3e91f38d8467a9 6e1b93f20bc34337b3c9398faa41aef7 a3409106ea9c460f9e3e91f38d8467a9--6e1b93f20bc34337b3c9398faa41aef7 3f6152dd8e84453c9c1a98f09d59cb85 6e1b93f20bc34337b3c9398faa41aef7--3f6152dd8e84453c9c1a98f09d59cb85 768739f0634a4279b827f0e6fc0f2a42 X 3f6152dd8e84453c9c1a98f09d59cb85--768739f0634a4279b827f0e6fc0f2a42 768739f0634a4279b827f0e6fc0f2a42--998195750d92405fa75e76ce9b17202e 9d4a39370d0a47d095231abcb9824400 RZ(-1.0*g0) 768739f0634a4279b827f0e6fc0f2a42--9d4a39370d0a47d095231abcb9824400 aa3c2d420b7d46d99ef52851cbc1aaff X 9d4a39370d0a47d095231abcb9824400--aa3c2d420b7d46d99ef52851cbc1aaff aa3c2d420b7d46d99ef52851cbc1aaff--f3bd4ccc4d1e4334ae4b7b186e82a26b 63dbe3296f8d446fb9e3c5d183dbe847 aa3c2d420b7d46d99ef52851cbc1aaff--63dbe3296f8d446fb9e3c5d183dbe847 de0b5098c31640dd84a6e26c6ef4857c 63dbe3296f8d446fb9e3c5d183dbe847--de0b5098c31640dd84a6e26c6ef4857c 64d46a21836a4414bd157f1c62b26751 de0b5098c31640dd84a6e26c6ef4857c--64d46a21836a4414bd157f1c62b26751 a2823a82fba44141a43c002a3d5c2fb5 64d46a21836a4414bd157f1c62b26751--a2823a82fba44141a43c002a3d5c2fb5 de5fc47c40bb45f4b69c623de0bae7df a2823a82fba44141a43c002a3d5c2fb5--de5fc47c40bb45f4b69c623de0bae7df 0faee821f9844ac1a04eb8891d4e958c de5fc47c40bb45f4b69c623de0bae7df--0faee821f9844ac1a04eb8891d4e958c e92dbd72608c483a8fd02855bc8f7f8d 0faee821f9844ac1a04eb8891d4e958c--e92dbd72608c483a8fd02855bc8f7f8d 0348966459564eeb8ceaaa29bd8b9e39 e92dbd72608c483a8fd02855bc8f7f8d--0348966459564eeb8ceaaa29bd8b9e39 4f2031f5582e456884525c94ce5a8fb8 0348966459564eeb8ceaaa29bd8b9e39--4f2031f5582e456884525c94ce5a8fb8 23fd6d17a3aa48068fc38729282028d0 X 4f2031f5582e456884525c94ce5a8fb8--23fd6d17a3aa48068fc38729282028d0 23fd6d17a3aa48068fc38729282028d0--a84c39740505492182702e1103d3d7eb ea163c76f9b243f0ab634e487ef9bb98 RZ(-1.0*g0) 23fd6d17a3aa48068fc38729282028d0--ea163c76f9b243f0ab634e487ef9bb98 de818286ff034131856cad4add20f480 X ea163c76f9b243f0ab634e487ef9bb98--de818286ff034131856cad4add20f480 de818286ff034131856cad4add20f480--e9772b45bf32477295a77b66205a0321 eb7ebc874c304aaaac2b2b66407eea4c de818286ff034131856cad4add20f480--eb7ebc874c304aaaac2b2b66407eea4c 003ab8ac573f4efaa594a70d0f62b809 eb7ebc874c304aaaac2b2b66407eea4c--003ab8ac573f4efaa594a70d0f62b809 61ba6c00467a4068ba27190cca9c31fd 003ab8ac573f4efaa594a70d0f62b809--61ba6c00467a4068ba27190cca9c31fd 70ed2b43b93a4c2382ed91d2859e96e9 61ba6c00467a4068ba27190cca9c31fd--70ed2b43b93a4c2382ed91d2859e96e9 12c60f7c82544d718afcfde17440757c 70ed2b43b93a4c2382ed91d2859e96e9--12c60f7c82544d718afcfde17440757c 48a034df55a24986a4bd1f1bda25411a 12c60f7c82544d718afcfde17440757c--48a034df55a24986a4bd1f1bda25411a 5c6091aa4f7a4a6aa71bdbe302e38b92 48a034df55a24986a4bd1f1bda25411a--5c6091aa4f7a4a6aa71bdbe302e38b92 d8c892a100df49a6bcec07f761f0ca68 5c6091aa4f7a4a6aa71bdbe302e38b92--d8c892a100df49a6bcec07f761f0ca68 316d2b512125452eba41295e7b509664 d8c892a100df49a6bcec07f761f0ca68--316d2b512125452eba41295e7b509664 e091f9d3fca4406899eff618d7003026 316d2b512125452eba41295e7b509664--e091f9d3fca4406899eff618d7003026 6ee66b7058134b109333b4430e8b5075 e091f9d3fca4406899eff618d7003026--6ee66b7058134b109333b4430e8b5075 0902e71e1681459dae37be828c562664 6ee66b7058134b109333b4430e8b5075--0902e71e1681459dae37be828c562664 1c9fc08fb4884f7ebd85310f0b6a6703 0902e71e1681459dae37be828c562664--1c9fc08fb4884f7ebd85310f0b6a6703 b36694ebe3bc4e3b87be450eff7e989d 1c9fc08fb4884f7ebd85310f0b6a6703--b36694ebe3bc4e3b87be450eff7e989d a3772efe0d2147de8fdc12ac5a2d7505 b36694ebe3bc4e3b87be450eff7e989d--a3772efe0d2147de8fdc12ac5a2d7505 1f22ce2ecc814e6998b3be7eb05171c9 X a3772efe0d2147de8fdc12ac5a2d7505--1f22ce2ecc814e6998b3be7eb05171c9 1f22ce2ecc814e6998b3be7eb05171c9--7f744b9880f84da69283fb925f62d672 3fa212183af241e18601c63e7cea006c RZ(-1.0*g0) 1f22ce2ecc814e6998b3be7eb05171c9--3fa212183af241e18601c63e7cea006c 74d22d2172504817a25c9b1481f2229c X 3fa212183af241e18601c63e7cea006c--74d22d2172504817a25c9b1481f2229c 74d22d2172504817a25c9b1481f2229c--cb47884ff7184ab4b61c3246587f9a99 f463a3a2d24c4778b4f9ae3ed8fd121b 74d22d2172504817a25c9b1481f2229c--f463a3a2d24c4778b4f9ae3ed8fd121b d6152675a09949f4ae21498bbe61544d f463a3a2d24c4778b4f9ae3ed8fd121b--d6152675a09949f4ae21498bbe61544d e80feb440c3744e881fc7809da41f751 d6152675a09949f4ae21498bbe61544d--e80feb440c3744e881fc7809da41f751 0c9e544cd6ac4e38a057abe56b0ab4b8 e80feb440c3744e881fc7809da41f751--0c9e544cd6ac4e38a057abe56b0ab4b8 42d0e8152a3a4f8dbdb7bb1130ff1f22 0c9e544cd6ac4e38a057abe56b0ab4b8--42d0e8152a3a4f8dbdb7bb1130ff1f22 e6ba834e73fd4967bf36ff86de00b5b7 42d0e8152a3a4f8dbdb7bb1130ff1f22--e6ba834e73fd4967bf36ff86de00b5b7 3974ab9deebf4a3cb01682ba6cc12ab5 X e6ba834e73fd4967bf36ff86de00b5b7--3974ab9deebf4a3cb01682ba6cc12ab5 3974ab9deebf4a3cb01682ba6cc12ab5--fbb2a9276a2a405a874afb1c00d03c31 c9a41628a24f43fd8ab813cd0c8f18ab 3974ab9deebf4a3cb01682ba6cc12ab5--c9a41628a24f43fd8ab813cd0c8f18ab 175632b6ad1c40fa89a19ece3a7ca9f8 c9a41628a24f43fd8ab813cd0c8f18ab--175632b6ad1c40fa89a19ece3a7ca9f8 794a81d9d4a744879f99ec4a2c45e44e 175632b6ad1c40fa89a19ece3a7ca9f8--794a81d9d4a744879f99ec4a2c45e44e 355caecf48ed451ab7f1762d9a34ca2b X 794a81d9d4a744879f99ec4a2c45e44e--355caecf48ed451ab7f1762d9a34ca2b 355caecf48ed451ab7f1762d9a34ca2b--c877a068415148b39cf3fa4a36be3ab4 46c64a3f447540d286925b3b39baef65 355caecf48ed451ab7f1762d9a34ca2b--46c64a3f447540d286925b3b39baef65 57acaf70564d4639a09055a05f49b7a5 46c64a3f447540d286925b3b39baef65--57acaf70564d4639a09055a05f49b7a5 1f5102a17ef042a1840e145414536a6e 57acaf70564d4639a09055a05f49b7a5--1f5102a17ef042a1840e145414536a6e c97fcd2d43be4dbd9ee5ff9b7d1e0f02 1f5102a17ef042a1840e145414536a6e--c97fcd2d43be4dbd9ee5ff9b7d1e0f02 8cf2cda158944873b6e6285ebc1cf727 c97fcd2d43be4dbd9ee5ff9b7d1e0f02--8cf2cda158944873b6e6285ebc1cf727 20e9ee47ff3c49639c2f759445bc03b0 8cf2cda158944873b6e6285ebc1cf727--20e9ee47ff3c49639c2f759445bc03b0 89ee1159ad8a4f0ea1515314641e90b5 20e9ee47ff3c49639c2f759445bc03b0--89ee1159ad8a4f0ea1515314641e90b5 df51d964c4144de0b9b65ccfe100673d X 89ee1159ad8a4f0ea1515314641e90b5--df51d964c4144de0b9b65ccfe100673d df51d964c4144de0b9b65ccfe100673d--52385158c98743ecb1833ad7df1701ea ecc8633e707742da900c6a1f5d36436c RZ(-1.0*g0) df51d964c4144de0b9b65ccfe100673d--ecc8633e707742da900c6a1f5d36436c 96cd1bb25f2c453a8c9b3928198bb610 X ecc8633e707742da900c6a1f5d36436c--96cd1bb25f2c453a8c9b3928198bb610 96cd1bb25f2c453a8c9b3928198bb610--af99b8528aac4d9680180816ef34c58c 0694caa0fa284e0e9b66206e019bf859 96cd1bb25f2c453a8c9b3928198bb610--0694caa0fa284e0e9b66206e019bf859 8793e6d6fd424fd5add9bfa30a330391 0694caa0fa284e0e9b66206e019bf859--8793e6d6fd424fd5add9bfa30a330391 e9ddfd7588ed403c81b05014285c037c X 8793e6d6fd424fd5add9bfa30a330391--e9ddfd7588ed403c81b05014285c037c e9ddfd7588ed403c81b05014285c037c--a81f42b03b4f49088c0c67327d077ad1 9ad84a8fbd4a4b4cadb7c1e905901988 e9ddfd7588ed403c81b05014285c037c--9ad84a8fbd4a4b4cadb7c1e905901988 785dd3a7dd054060ad9a192041088ec7 9ad84a8fbd4a4b4cadb7c1e905901988--785dd3a7dd054060ad9a192041088ec7 ec5c9e89656e43659c4e8434e5f1ceb8 785dd3a7dd054060ad9a192041088ec7--ec5c9e89656e43659c4e8434e5f1ceb8 0b5e4092625441debcf6d4c222b7e8f7 X ec5c9e89656e43659c4e8434e5f1ceb8--0b5e4092625441debcf6d4c222b7e8f7 0b5e4092625441debcf6d4c222b7e8f7--dae4f0ab194c4aba9b5ae0d09dca2144 11a4e25d145540b78da60f0fc2bb3154 0b5e4092625441debcf6d4c222b7e8f7--11a4e25d145540b78da60f0fc2bb3154 22bc06a017fc43dd99ad4dfad26d07e8 RX(b06) 11a4e25d145540b78da60f0fc2bb3154--22bc06a017fc43dd99ad4dfad26d07e8 01f765e61ae640b8b4d50d7b65354fbe 22bc06a017fc43dd99ad4dfad26d07e8--01f765e61ae640b8b4d50d7b65354fbe b54bf796de4645a8a6cd2865e39c6589 01f765e61ae640b8b4d50d7b65354fbe--b54bf796de4645a8a6cd2865e39c6589 2fc22b3deda442b6b232539e0af5f1a2 b54bf796de4645a8a6cd2865e39c6589--2fc22b3deda442b6b232539e0af5f1a2 a2113b4c45904e888cf67983c57d72f9 2fc22b3deda442b6b232539e0af5f1a2--a2113b4c45904e888cf67983c57d72f9 6d00adb064894446ba8e7af1124f1f0e a2113b4c45904e888cf67983c57d72f9--6d00adb064894446ba8e7af1124f1f0e bef897b4af964832947606b5279d16a7 X 6d00adb064894446ba8e7af1124f1f0e--bef897b4af964832947606b5279d16a7 bef897b4af964832947606b5279d16a7--afa4ac2cdfd94f2b89a1ee39a5ec836c 86fc6d9b71f042c1972dff23e679a387 bef897b4af964832947606b5279d16a7--86fc6d9b71f042c1972dff23e679a387 8115eb1de58b417c9b98fbf1d8be6d16 86fc6d9b71f042c1972dff23e679a387--8115eb1de58b417c9b98fbf1d8be6d16 a073b65850b9484b8e4ebc87538f1f94 8115eb1de58b417c9b98fbf1d8be6d16--a073b65850b9484b8e4ebc87538f1f94 483ed9272c6e4115aae7fb640a131590 X a073b65850b9484b8e4ebc87538f1f94--483ed9272c6e4115aae7fb640a131590 483ed9272c6e4115aae7fb640a131590--41c5660658d34957a62d42545306515f 597d911d81d64d268e2b41a2c15ee189 483ed9272c6e4115aae7fb640a131590--597d911d81d64d268e2b41a2c15ee189 2c19da78457a4b2882d1815949ee4964 597d911d81d64d268e2b41a2c15ee189--2c19da78457a4b2882d1815949ee4964 f5e2f434ffef4af383c0885550cf40d5 2c19da78457a4b2882d1815949ee4964--f5e2f434ffef4af383c0885550cf40d5 69b156396ec54bc2a914f02c936c1657 f5e2f434ffef4af383c0885550cf40d5--69b156396ec54bc2a914f02c936c1657 64fb6e49b8664b298d5e27e4ee85eda9 69b156396ec54bc2a914f02c936c1657--64fb6e49b8664b298d5e27e4ee85eda9 4cece3751faf47fbbd89fe33522396b5 64fb6e49b8664b298d5e27e4ee85eda9--4cece3751faf47fbbd89fe33522396b5 59b61b89984142218ceacf5d8922903c 4cece3751faf47fbbd89fe33522396b5--59b61b89984142218ceacf5d8922903c 9ff9b406a9f046559e73f91d8b31a41f 59b61b89984142218ceacf5d8922903c--9ff9b406a9f046559e73f91d8b31a41f 8b3390a2b9bb44ecbc2117a1bbf9a9ef 9ff9b406a9f046559e73f91d8b31a41f--8b3390a2b9bb44ecbc2117a1bbf9a9ef 71727f0eea574ab7b06fa5257af261d5 8b3390a2b9bb44ecbc2117a1bbf9a9ef--71727f0eea574ab7b06fa5257af261d5 92967a2bafbc48f884a00a9cbb61104d 71727f0eea574ab7b06fa5257af261d5--92967a2bafbc48f884a00a9cbb61104d e6f26ea5524248a381e528818e18175e 92967a2bafbc48f884a00a9cbb61104d--e6f26ea5524248a381e528818e18175e e51f6e90e7134518a674028c94d69aee e6f26ea5524248a381e528818e18175e--e51f6e90e7134518a674028c94d69aee 19cd55bf67ea425290496e9c89bd266b e51f6e90e7134518a674028c94d69aee--19cd55bf67ea425290496e9c89bd266b da6f1903464249dc97468e5541ea9542 19cd55bf67ea425290496e9c89bd266b--da6f1903464249dc97468e5541ea9542 bbdb5143f74148deb3b01496f82cb8c9 da6f1903464249dc97468e5541ea9542--bbdb5143f74148deb3b01496f82cb8c9 0fcd03f9524c4b4595a5e42bf88ae24b bbdb5143f74148deb3b01496f82cb8c9--0fcd03f9524c4b4595a5e42bf88ae24b 53b3eb712a8842d0a94ba095d1e4eb5a 0fcd03f9524c4b4595a5e42bf88ae24b--53b3eb712a8842d0a94ba095d1e4eb5a 8bacb5fb1ef54193b9b9bd45d95bfa92 53b3eb712a8842d0a94ba095d1e4eb5a--8bacb5fb1ef54193b9b9bd45d95bfa92 3d23f713f4ea45d1995d9d162f85a64d 8bacb5fb1ef54193b9b9bd45d95bfa92--3d23f713f4ea45d1995d9d162f85a64d e4df4c12a1dc4c58a77a259f1af63391 3d23f713f4ea45d1995d9d162f85a64d--e4df4c12a1dc4c58a77a259f1af63391 05e7f3edbd804b3bbf152fd14ee48312 e4df4c12a1dc4c58a77a259f1af63391--05e7f3edbd804b3bbf152fd14ee48312 82712ffde1494e3a9ce43297ae0d8f02 05e7f3edbd804b3bbf152fd14ee48312--82712ffde1494e3a9ce43297ae0d8f02 fc6f9f0b86494f5780bf85b4fc841d4c 82712ffde1494e3a9ce43297ae0d8f02--fc6f9f0b86494f5780bf85b4fc841d4c 72dd88808aae4b9d91ffd8d571d84a28 fc6f9f0b86494f5780bf85b4fc841d4c--72dd88808aae4b9d91ffd8d571d84a28 1b2f9294e2384db0a17f4afe244e6e01 72dd88808aae4b9d91ffd8d571d84a28--1b2f9294e2384db0a17f4afe244e6e01 3f5fb3ec566a4f90be1064ef7a261634 1b2f9294e2384db0a17f4afe244e6e01--3f5fb3ec566a4f90be1064ef7a261634 53f7769cc2f04146b932450a2c4a9d64 3f5fb3ec566a4f90be1064ef7a261634--53f7769cc2f04146b932450a2c4a9d64 1051cf837f754f168225e7e80a4997fc 53f7769cc2f04146b932450a2c4a9d64--1051cf837f754f168225e7e80a4997fc c9245dbea9484226b46617a1a7a1fc31 1051cf837f754f168225e7e80a4997fc--c9245dbea9484226b46617a1a7a1fc31 c8ffa5068f624bc59b2c6724404c0cbf c9245dbea9484226b46617a1a7a1fc31--c8ffa5068f624bc59b2c6724404c0cbf 9f6fc70e7b4947c2b3a06a6a59015d0f c8ffa5068f624bc59b2c6724404c0cbf--9f6fc70e7b4947c2b3a06a6a59015d0f d46045ddef934370ac271e387192e19f 9f6fc70e7b4947c2b3a06a6a59015d0f--d46045ddef934370ac271e387192e19f 72cacab82c8a4d15b78cdd82f50d48f4 d46045ddef934370ac271e387192e19f--72cacab82c8a4d15b78cdd82f50d48f4 97e899d710f94e92a84bdaae574fc4a3 72cacab82c8a4d15b78cdd82f50d48f4--97e899d710f94e92a84bdaae574fc4a3 48132292e42e447fa5f9471796bc9f98 97e899d710f94e92a84bdaae574fc4a3--48132292e42e447fa5f9471796bc9f98 f5953f17dcd64cd49dd6f56fdd9a3635 48132292e42e447fa5f9471796bc9f98--f5953f17dcd64cd49dd6f56fdd9a3635 9586db7873184b89a835533f31bea8d8 f5953f17dcd64cd49dd6f56fdd9a3635--9586db7873184b89a835533f31bea8d8 6b42958e268e4620a729c2476407c3e1 9586db7873184b89a835533f31bea8d8--6b42958e268e4620a729c2476407c3e1 64e29d1e009749bea47dd9cce3fb2b04 6b42958e268e4620a729c2476407c3e1--64e29d1e009749bea47dd9cce3fb2b04 bbe4a7a5a07e4230a210f004af03f22c X 64e29d1e009749bea47dd9cce3fb2b04--bbe4a7a5a07e4230a210f004af03f22c bbe4a7a5a07e4230a210f004af03f22c--5ae494b3cd534c068b9e9a23f9933627 8806df1280a845c3bf5b35e462812016 RZ(-1.0*g1) bbe4a7a5a07e4230a210f004af03f22c--8806df1280a845c3bf5b35e462812016 256ede860d4c40ef9f1ebd256a7f23e3 X 8806df1280a845c3bf5b35e462812016--256ede860d4c40ef9f1ebd256a7f23e3 256ede860d4c40ef9f1ebd256a7f23e3--2b75ba86dec14e4fb397821f1e1043c0 7ff3a7fa4de849bfab86a340668d5f55 256ede860d4c40ef9f1ebd256a7f23e3--7ff3a7fa4de849bfab86a340668d5f55 7c440a43a4da4e90a45c711d43c3d929 7ff3a7fa4de849bfab86a340668d5f55--7c440a43a4da4e90a45c711d43c3d929 73b74516bebc4acb828d2e04eb50e2dd 7c440a43a4da4e90a45c711d43c3d929--73b74516bebc4acb828d2e04eb50e2dd 1fb760fa7d6e441596098b35260eabcc 73b74516bebc4acb828d2e04eb50e2dd--1fb760fa7d6e441596098b35260eabcc cfaf1e3dd77e4d139f9aca904323a700 1fb760fa7d6e441596098b35260eabcc--cfaf1e3dd77e4d139f9aca904323a700 e65a75bd6efc435480c4b993b50c7aad cfaf1e3dd77e4d139f9aca904323a700--e65a75bd6efc435480c4b993b50c7aad d4aff5db774d46bcad82f9730e8adebf e65a75bd6efc435480c4b993b50c7aad--d4aff5db774d46bcad82f9730e8adebf 1a736b0a3e5e444e9c3fec6ede51f226 d4aff5db774d46bcad82f9730e8adebf--1a736b0a3e5e444e9c3fec6ede51f226 e780351fb50c4337941cf1fbd3f2e6c4 1a736b0a3e5e444e9c3fec6ede51f226--e780351fb50c4337941cf1fbd3f2e6c4 8aed64d3a71b4ed5b7427d5b34237ce2 X e780351fb50c4337941cf1fbd3f2e6c4--8aed64d3a71b4ed5b7427d5b34237ce2 8aed64d3a71b4ed5b7427d5b34237ce2--26f31e482edc4f5194a02d61d82fa4fc 2ec9fd8554f84a2b8c97a8e47a6f72d8 RZ(-1.0*g1) 8aed64d3a71b4ed5b7427d5b34237ce2--2ec9fd8554f84a2b8c97a8e47a6f72d8 f69ee14e32404d41b25092f95582aca0 X 2ec9fd8554f84a2b8c97a8e47a6f72d8--f69ee14e32404d41b25092f95582aca0 f69ee14e32404d41b25092f95582aca0--40119f201adf452db90c5dfb0e04d5bb 13f53c9e3a784f339ab60f93931d464d f69ee14e32404d41b25092f95582aca0--13f53c9e3a784f339ab60f93931d464d 970c6da9219a45aaa40d771acc94b538 13f53c9e3a784f339ab60f93931d464d--970c6da9219a45aaa40d771acc94b538 c922085b7da04590874eda9414ddb950 970c6da9219a45aaa40d771acc94b538--c922085b7da04590874eda9414ddb950 8cd8edafd1374aaa8315690c61b1d4d3 c922085b7da04590874eda9414ddb950--8cd8edafd1374aaa8315690c61b1d4d3 488d4198a3e840468284e00351cde0a4 8cd8edafd1374aaa8315690c61b1d4d3--488d4198a3e840468284e00351cde0a4 881db14632014212a555e213040ce412 488d4198a3e840468284e00351cde0a4--881db14632014212a555e213040ce412 cc615ca936e14c6fac37aba8c8b98a33 881db14632014212a555e213040ce412--cc615ca936e14c6fac37aba8c8b98a33 6a1813101f104b11b4d413a053ad47d0 cc615ca936e14c6fac37aba8c8b98a33--6a1813101f104b11b4d413a053ad47d0 cc0812d854f9462aabf2666e1a0af01c 6a1813101f104b11b4d413a053ad47d0--cc0812d854f9462aabf2666e1a0af01c 1e5324f9cba844689ac37556bb62232b cc0812d854f9462aabf2666e1a0af01c--1e5324f9cba844689ac37556bb62232b ab65ac32ecb74b7c91df47b4ae343450 1e5324f9cba844689ac37556bb62232b--ab65ac32ecb74b7c91df47b4ae343450 b741120c52c84e9aada3197ddf6ecdae ab65ac32ecb74b7c91df47b4ae343450--b741120c52c84e9aada3197ddf6ecdae 9024045c4bc24f4793f975b39df4d009 b741120c52c84e9aada3197ddf6ecdae--9024045c4bc24f4793f975b39df4d009 dedc49ca570444abbd5a5b8477e7c5b2 9024045c4bc24f4793f975b39df4d009--dedc49ca570444abbd5a5b8477e7c5b2 bdc18011bf544f4b920f9ab208ee84dc dedc49ca570444abbd5a5b8477e7c5b2--bdc18011bf544f4b920f9ab208ee84dc 8f53d23f98724378a8aea34fc25c41da X bdc18011bf544f4b920f9ab208ee84dc--8f53d23f98724378a8aea34fc25c41da 8f53d23f98724378a8aea34fc25c41da--57c82d071722499dbfe71f96c2d3409c 83df9aef54054a44b9f696bcd723fcd4 RZ(-1.0*g1) 8f53d23f98724378a8aea34fc25c41da--83df9aef54054a44b9f696bcd723fcd4 6dacb835654744909dd78c9fd7843c08 X 83df9aef54054a44b9f696bcd723fcd4--6dacb835654744909dd78c9fd7843c08 6dacb835654744909dd78c9fd7843c08--b7a7a3b4722347799b7e3ee55bef4c6a 4fd243ce015b4b60b7f34c1f63e7ac5d 6dacb835654744909dd78c9fd7843c08--4fd243ce015b4b60b7f34c1f63e7ac5d 1a0ce364b1de4f558454acf4510d5004 4fd243ce015b4b60b7f34c1f63e7ac5d--1a0ce364b1de4f558454acf4510d5004 8ac8e14fd3044392953e10016be091b3 1a0ce364b1de4f558454acf4510d5004--8ac8e14fd3044392953e10016be091b3 3e03885675894abf9931e95c65ef1e8b 8ac8e14fd3044392953e10016be091b3--3e03885675894abf9931e95c65ef1e8b 3b27c4ca86434c99806afbe0d11d93ce 3e03885675894abf9931e95c65ef1e8b--3b27c4ca86434c99806afbe0d11d93ce 1d764d049e294ece950ee4bcf28c7b2f 3b27c4ca86434c99806afbe0d11d93ce--1d764d049e294ece950ee4bcf28c7b2f 0cfad7c9e16e4df68fb830d847306dd0 X 1d764d049e294ece950ee4bcf28c7b2f--0cfad7c9e16e4df68fb830d847306dd0 0cfad7c9e16e4df68fb830d847306dd0--7f153e2b3a9a441984ab7e8500000b7c 16f559bdf7d2400ca477151cc074fe49 0cfad7c9e16e4df68fb830d847306dd0--16f559bdf7d2400ca477151cc074fe49 722181d904404562a8902327b5e00c79 16f559bdf7d2400ca477151cc074fe49--722181d904404562a8902327b5e00c79 c29439bc1a7e4923ae152baa0c2a811d 722181d904404562a8902327b5e00c79--c29439bc1a7e4923ae152baa0c2a811d 3a22dfa9b99d4163bb920bf6e8384cd0 X c29439bc1a7e4923ae152baa0c2a811d--3a22dfa9b99d4163bb920bf6e8384cd0 3a22dfa9b99d4163bb920bf6e8384cd0--8f752a7f019b4859a28c9c7b3cdc03cd bd6472cba89d4ebd8f93a0e4c7e06b33 3a22dfa9b99d4163bb920bf6e8384cd0--bd6472cba89d4ebd8f93a0e4c7e06b33 3605371948e94bee81274bee4aa783db bd6472cba89d4ebd8f93a0e4c7e06b33--3605371948e94bee81274bee4aa783db 599c480fce244870b75a2ddeece7b2bd 3605371948e94bee81274bee4aa783db--599c480fce244870b75a2ddeece7b2bd 26b703383b814088af7884d4d54ca0df 599c480fce244870b75a2ddeece7b2bd--26b703383b814088af7884d4d54ca0df 99fccc8e4d6741c2946094840e5d58e1 26b703383b814088af7884d4d54ca0df--99fccc8e4d6741c2946094840e5d58e1 6f85ca18b0f94ec2ab987880d5698b5e 99fccc8e4d6741c2946094840e5d58e1--6f85ca18b0f94ec2ab987880d5698b5e 87724984b9364053b8940a6ce896cd59 6f85ca18b0f94ec2ab987880d5698b5e--87724984b9364053b8940a6ce896cd59 5535c3db3c224260b11c31ab7c766e8f X 87724984b9364053b8940a6ce896cd59--5535c3db3c224260b11c31ab7c766e8f 5535c3db3c224260b11c31ab7c766e8f--1712ec44d23b4d32ae85f8fecad436a8 0cd1c6cf39844959a027167f304bfaec RZ(-1.0*g1) 5535c3db3c224260b11c31ab7c766e8f--0cd1c6cf39844959a027167f304bfaec ee08b3dd7a104cbcae2899ac8cee0ac5 X 0cd1c6cf39844959a027167f304bfaec--ee08b3dd7a104cbcae2899ac8cee0ac5 ee08b3dd7a104cbcae2899ac8cee0ac5--c821f9d5a7dc420da0468ed4a30981d3 e7fab51a4111490faf70b5c6cb1d94ef ee08b3dd7a104cbcae2899ac8cee0ac5--e7fab51a4111490faf70b5c6cb1d94ef 4531e7a7d8784de8ab80c82d532d7eda e7fab51a4111490faf70b5c6cb1d94ef--4531e7a7d8784de8ab80c82d532d7eda d1e73e6335734e3c804ec6a2ee31036b X 4531e7a7d8784de8ab80c82d532d7eda--d1e73e6335734e3c804ec6a2ee31036b d1e73e6335734e3c804ec6a2ee31036b--db009c9bd4574f49bddb0f2fc63e4177 4ddc8905c00d49c98044da8bd56030cf d1e73e6335734e3c804ec6a2ee31036b--4ddc8905c00d49c98044da8bd56030cf 32690ef6c19a43e68d9c37884ab5899c 4ddc8905c00d49c98044da8bd56030cf--32690ef6c19a43e68d9c37884ab5899c 8a9e78b4b44f48a0b70562fa00593edc 32690ef6c19a43e68d9c37884ab5899c--8a9e78b4b44f48a0b70562fa00593edc b77098bf94574808a80d27362bae4595 X 8a9e78b4b44f48a0b70562fa00593edc--b77098bf94574808a80d27362bae4595 b77098bf94574808a80d27362bae4595--5984524c241c49adb4527955f4b5ebe6 cbf21701143244c98b659830ae2c3e83 b77098bf94574808a80d27362bae4595--cbf21701143244c98b659830ae2c3e83 300932eb198c448489707b2b79fc3012 RX(b16) cbf21701143244c98b659830ae2c3e83--300932eb198c448489707b2b79fc3012 300932eb198c448489707b2b79fc3012--58fe48b198364de98687f57d283bd37b c9b71190925448b2959d3377c4fefe19 a6eef21f15a14d14b63175da18560049 8ce05e1eff12478b96fa045920405289--a6eef21f15a14d14b63175da18560049 9f4484d952b3472a8a5474681b56c426 a6eef21f15a14d14b63175da18560049--9f4484d952b3472a8a5474681b56c426 b1519bdb78454d9e89b37bb440071ae2 9f4484d952b3472a8a5474681b56c426--b1519bdb78454d9e89b37bb440071ae2 ffb948daec6a4b84adb65c721e10b1da b1519bdb78454d9e89b37bb440071ae2--ffb948daec6a4b84adb65c721e10b1da 4cfba0b4fcc04c56802ee98c1bfe9a88 ffb948daec6a4b84adb65c721e10b1da--4cfba0b4fcc04c56802ee98c1bfe9a88 2dda207df8eb40218956ee2f0fa59023 4cfba0b4fcc04c56802ee98c1bfe9a88--2dda207df8eb40218956ee2f0fa59023 d25bca40e56c44948ae1ee6ceb5a42f4 X 2dda207df8eb40218956ee2f0fa59023--d25bca40e56c44948ae1ee6ceb5a42f4 d25bca40e56c44948ae1ee6ceb5a42f4--75b4d53032b04170b10a0ac2870d0b58 bf9d4b4f1e8f490087b9f536b9251496 RZ(1.0*g0) d25bca40e56c44948ae1ee6ceb5a42f4--bf9d4b4f1e8f490087b9f536b9251496 99fb170fc965493682676e5c2a07b553 X bf9d4b4f1e8f490087b9f536b9251496--99fb170fc965493682676e5c2a07b553 99fb170fc965493682676e5c2a07b553--f1239f4c89dd44d0887101c57d251a15 db6a8b8af6fa4ec9917e2251a478f2fa 99fb170fc965493682676e5c2a07b553--db6a8b8af6fa4ec9917e2251a478f2fa a11354643d2244bc93ade70703fdc72d db6a8b8af6fa4ec9917e2251a478f2fa--a11354643d2244bc93ade70703fdc72d 94dfff95db10490c92b19cabebc232b0 a11354643d2244bc93ade70703fdc72d--94dfff95db10490c92b19cabebc232b0 1459b3b5f6b04dbdbb9041d24d426bef 94dfff95db10490c92b19cabebc232b0--1459b3b5f6b04dbdbb9041d24d426bef 470f2512fa2442d894b679867015b70c 1459b3b5f6b04dbdbb9041d24d426bef--470f2512fa2442d894b679867015b70c 9242d7eb27884034b83c0f92b7b7cf32 470f2512fa2442d894b679867015b70c--9242d7eb27884034b83c0f92b7b7cf32 fe797fc50f3f453d96d38a83e9ca5bf1 9242d7eb27884034b83c0f92b7b7cf32--fe797fc50f3f453d96d38a83e9ca5bf1 13721ba17dfc492997a6d3a274d142b0 fe797fc50f3f453d96d38a83e9ca5bf1--13721ba17dfc492997a6d3a274d142b0 95ee4d2ebee349e8821e23c0163cc4f3 13721ba17dfc492997a6d3a274d142b0--95ee4d2ebee349e8821e23c0163cc4f3 4dd10b5103074828b407a4b54081ce66 95ee4d2ebee349e8821e23c0163cc4f3--4dd10b5103074828b407a4b54081ce66 52fd653bcbf443a6a08ded3fd9ec4e18 4dd10b5103074828b407a4b54081ce66--52fd653bcbf443a6a08ded3fd9ec4e18 924c5fa0abb045a8a30a601065e8d201 52fd653bcbf443a6a08ded3fd9ec4e18--924c5fa0abb045a8a30a601065e8d201 963111c9a42d49b795abdf4658358388 924c5fa0abb045a8a30a601065e8d201--963111c9a42d49b795abdf4658358388 66b43079d6a4493a8861fa84cc5e5aba 963111c9a42d49b795abdf4658358388--66b43079d6a4493a8861fa84cc5e5aba 7139193b952f4bd5bb084becf2df35e2 66b43079d6a4493a8861fa84cc5e5aba--7139193b952f4bd5bb084becf2df35e2 109e0a69d37946ecba3d2063a96b381d 7139193b952f4bd5bb084becf2df35e2--109e0a69d37946ecba3d2063a96b381d 555213d5c52d45e6a9d9ec6dcba98ebf 109e0a69d37946ecba3d2063a96b381d--555213d5c52d45e6a9d9ec6dcba98ebf 89fffad8097d4a49888bcd7e6d47d3c6 555213d5c52d45e6a9d9ec6dcba98ebf--89fffad8097d4a49888bcd7e6d47d3c6 1d8e9b6477174cc1a1feda2c6d1f32c0 89fffad8097d4a49888bcd7e6d47d3c6--1d8e9b6477174cc1a1feda2c6d1f32c0 a44333a5863b47349ba62b91cd61ac3f 1d8e9b6477174cc1a1feda2c6d1f32c0--a44333a5863b47349ba62b91cd61ac3f f6e364a6a8ca45a6bb093836081aeea6 a44333a5863b47349ba62b91cd61ac3f--f6e364a6a8ca45a6bb093836081aeea6 9fc96518823e4d87978bb8dab3bfc9ac f6e364a6a8ca45a6bb093836081aeea6--9fc96518823e4d87978bb8dab3bfc9ac a041285b3ce344fab8b2dac50b39aa90 9fc96518823e4d87978bb8dab3bfc9ac--a041285b3ce344fab8b2dac50b39aa90 5366e9fe66134898a8020e780dc63df0 a041285b3ce344fab8b2dac50b39aa90--5366e9fe66134898a8020e780dc63df0 2f10f196eb4640e2b9af7698856806b9 5366e9fe66134898a8020e780dc63df0--2f10f196eb4640e2b9af7698856806b9 2395fae163914fb08f436d9cf87171d8 2f10f196eb4640e2b9af7698856806b9--2395fae163914fb08f436d9cf87171d8 90ca76d5a9174d9886044627a34b7a2f 2395fae163914fb08f436d9cf87171d8--90ca76d5a9174d9886044627a34b7a2f 7a1819b6e2ed48f9b167516895d593c3 90ca76d5a9174d9886044627a34b7a2f--7a1819b6e2ed48f9b167516895d593c3 8cf73f2c2cda428697afc602888154d8 7a1819b6e2ed48f9b167516895d593c3--8cf73f2c2cda428697afc602888154d8 02899b7e1b054d7583805cb5bcac8c12 8cf73f2c2cda428697afc602888154d8--02899b7e1b054d7583805cb5bcac8c12 a756353aefee4c19be197bbe91b3aabd 02899b7e1b054d7583805cb5bcac8c12--a756353aefee4c19be197bbe91b3aabd 1abe66c485204ac3900178a073e7fdae a756353aefee4c19be197bbe91b3aabd--1abe66c485204ac3900178a073e7fdae 4647964b30cf412db5d405daa8d9f6a5 1abe66c485204ac3900178a073e7fdae--4647964b30cf412db5d405daa8d9f6a5 25e7839096a842b399154cab89461381 4647964b30cf412db5d405daa8d9f6a5--25e7839096a842b399154cab89461381 06cf153ad7e945eab03e9ad265b98145 25e7839096a842b399154cab89461381--06cf153ad7e945eab03e9ad265b98145 33b8cd003b5d4585a76171965712b9b5 06cf153ad7e945eab03e9ad265b98145--33b8cd003b5d4585a76171965712b9b5 b77c104d5ba14b0aa3ef27fe45980c5d 33b8cd003b5d4585a76171965712b9b5--b77c104d5ba14b0aa3ef27fe45980c5d 3a9bcfd4e2ab4ab2ae977bcdad440318 b77c104d5ba14b0aa3ef27fe45980c5d--3a9bcfd4e2ab4ab2ae977bcdad440318 610613fe86a94bc184249f80685ff55e 3a9bcfd4e2ab4ab2ae977bcdad440318--610613fe86a94bc184249f80685ff55e ec03b3ba8f7a494c8c24c0b00a3e7252 610613fe86a94bc184249f80685ff55e--ec03b3ba8f7a494c8c24c0b00a3e7252 d82b31cc0ac94948a494cf409074485f ec03b3ba8f7a494c8c24c0b00a3e7252--d82b31cc0ac94948a494cf409074485f 5838c647d77c4e10b0e1e6f4f4baffec d82b31cc0ac94948a494cf409074485f--5838c647d77c4e10b0e1e6f4f4baffec f99fbb2800964495a75f5dd12e5178b5 5838c647d77c4e10b0e1e6f4f4baffec--f99fbb2800964495a75f5dd12e5178b5 1d4fe96051a14d00a116b563c174a2d4 f99fbb2800964495a75f5dd12e5178b5--1d4fe96051a14d00a116b563c174a2d4 e23fa2b7877d46e8a8e62bb207052a94 1d4fe96051a14d00a116b563c174a2d4--e23fa2b7877d46e8a8e62bb207052a94 be55b0a4627e44ee9f96ee996e496a4e e23fa2b7877d46e8a8e62bb207052a94--be55b0a4627e44ee9f96ee996e496a4e 34de45b0474047bd972fa39883d74157 be55b0a4627e44ee9f96ee996e496a4e--34de45b0474047bd972fa39883d74157 812b232e7dd244829662f94b97a9384b 34de45b0474047bd972fa39883d74157--812b232e7dd244829662f94b97a9384b d9baed53ffb6457b9376658321924800 812b232e7dd244829662f94b97a9384b--d9baed53ffb6457b9376658321924800 ce8f7ef731834363aa954baae3c0e5ab d9baed53ffb6457b9376658321924800--ce8f7ef731834363aa954baae3c0e5ab c5a39b2b2206406bbd8299c14d5b679a ce8f7ef731834363aa954baae3c0e5ab--c5a39b2b2206406bbd8299c14d5b679a 7720326c9bff4d6e83f9b1a224f72a2e c5a39b2b2206406bbd8299c14d5b679a--7720326c9bff4d6e83f9b1a224f72a2e 24eaa8aa79de42de8d0d93318432a811 7720326c9bff4d6e83f9b1a224f72a2e--24eaa8aa79de42de8d0d93318432a811 e8ff0545a0b84245a8f49b803293a394 24eaa8aa79de42de8d0d93318432a811--e8ff0545a0b84245a8f49b803293a394 993c4014b0c5444a8166c48f007f4ac7 e8ff0545a0b84245a8f49b803293a394--993c4014b0c5444a8166c48f007f4ac7 d4e2b9a938264135851d22ddcfe4b011 993c4014b0c5444a8166c48f007f4ac7--d4e2b9a938264135851d22ddcfe4b011 5b0531a99fc548bdaaa0b0857ff8749f d4e2b9a938264135851d22ddcfe4b011--5b0531a99fc548bdaaa0b0857ff8749f b95d9d5d42d24610add1e6b1047481a6 5b0531a99fc548bdaaa0b0857ff8749f--b95d9d5d42d24610add1e6b1047481a6 e913dba145114c78b7fac56fc59ba9a3 b95d9d5d42d24610add1e6b1047481a6--e913dba145114c78b7fac56fc59ba9a3 98be553af18c47db9c48e523067e524c e913dba145114c78b7fac56fc59ba9a3--98be553af18c47db9c48e523067e524c 797395c72201492db9996b00132d192d 98be553af18c47db9c48e523067e524c--797395c72201492db9996b00132d192d 2847e121cd53459dadcf4b322c12de39 797395c72201492db9996b00132d192d--2847e121cd53459dadcf4b322c12de39 f8970c56bfc346c294a76fb9be64289a 2847e121cd53459dadcf4b322c12de39--f8970c56bfc346c294a76fb9be64289a fbb182ee7c904f54baf3ebe0e3d51390 f8970c56bfc346c294a76fb9be64289a--fbb182ee7c904f54baf3ebe0e3d51390 f9c496e7d43143529034ab90c34daf67 fbb182ee7c904f54baf3ebe0e3d51390--f9c496e7d43143529034ab90c34daf67 40f00ce8b53d4fe8996f292ea2c43372 f9c496e7d43143529034ab90c34daf67--40f00ce8b53d4fe8996f292ea2c43372 3b6163839cbc442a8a1151ea0cb5cd0e 40f00ce8b53d4fe8996f292ea2c43372--3b6163839cbc442a8a1151ea0cb5cd0e 62ce202855dc417cade83432a2e6b62f 3b6163839cbc442a8a1151ea0cb5cd0e--62ce202855dc417cade83432a2e6b62f 7174e5f796b64a59a03cad3675ace1b3 62ce202855dc417cade83432a2e6b62f--7174e5f796b64a59a03cad3675ace1b3 1a1a05f107634e3a8dc63d6a8cf4f2f4 7174e5f796b64a59a03cad3675ace1b3--1a1a05f107634e3a8dc63d6a8cf4f2f4 c034c8d4bd6e4c5fbc94835e6ee47da6 1a1a05f107634e3a8dc63d6a8cf4f2f4--c034c8d4bd6e4c5fbc94835e6ee47da6 b45e8c751dc54dd485aece6b1c1eea1a c034c8d4bd6e4c5fbc94835e6ee47da6--b45e8c751dc54dd485aece6b1c1eea1a 893dee78490742c7960bdf20aa1e8c2a b45e8c751dc54dd485aece6b1c1eea1a--893dee78490742c7960bdf20aa1e8c2a bcb7b58796ac4d94bcb0ab1eeb035763 893dee78490742c7960bdf20aa1e8c2a--bcb7b58796ac4d94bcb0ab1eeb035763 0605d2856aaa48faa96342f75c564349 bcb7b58796ac4d94bcb0ab1eeb035763--0605d2856aaa48faa96342f75c564349 65d045f1a5ab43d1bba5bb9a1c76d7e9 0605d2856aaa48faa96342f75c564349--65d045f1a5ab43d1bba5bb9a1c76d7e9 c451c663968e4e8f888dd21baa379a86 65d045f1a5ab43d1bba5bb9a1c76d7e9--c451c663968e4e8f888dd21baa379a86 fb94fe5085e348a2805bf740d30dffe1 c451c663968e4e8f888dd21baa379a86--fb94fe5085e348a2805bf740d30dffe1 d59bdc65e6fc497fac24066db2f99a27 fb94fe5085e348a2805bf740d30dffe1--d59bdc65e6fc497fac24066db2f99a27 e64628fe498f441ba56f70d231411bc1 d59bdc65e6fc497fac24066db2f99a27--e64628fe498f441ba56f70d231411bc1 25d4a9ed2fcf4b45bd36deff7046bcfa e64628fe498f441ba56f70d231411bc1--25d4a9ed2fcf4b45bd36deff7046bcfa ae8d58934e984d03941b807037450a92 X 25d4a9ed2fcf4b45bd36deff7046bcfa--ae8d58934e984d03941b807037450a92 ae8d58934e984d03941b807037450a92--c9a41628a24f43fd8ab813cd0c8f18ab 76812b0ce9c349bbbc467acd0db90f2f RZ(-1.0*g0) ae8d58934e984d03941b807037450a92--76812b0ce9c349bbbc467acd0db90f2f a98b62d1b5e84ec0b363e25f5afc3795 X 76812b0ce9c349bbbc467acd0db90f2f--a98b62d1b5e84ec0b363e25f5afc3795 a98b62d1b5e84ec0b363e25f5afc3795--794a81d9d4a744879f99ec4a2c45e44e 059a217502174c258c4f6dc36db09402 a98b62d1b5e84ec0b363e25f5afc3795--059a217502174c258c4f6dc36db09402 b89f56d1a5704fde84965b05b04fb216 059a217502174c258c4f6dc36db09402--b89f56d1a5704fde84965b05b04fb216 08a60f31ac7545829fcb8638721e59a2 b89f56d1a5704fde84965b05b04fb216--08a60f31ac7545829fcb8638721e59a2 0b18a9fa5bc74f229c68a6071af73662 08a60f31ac7545829fcb8638721e59a2--0b18a9fa5bc74f229c68a6071af73662 a5a249dd55984e44ad74ef5258ee7f73 0b18a9fa5bc74f229c68a6071af73662--a5a249dd55984e44ad74ef5258ee7f73 224319425336427abf274df66f46a999 a5a249dd55984e44ad74ef5258ee7f73--224319425336427abf274df66f46a999 a16118cc38fe4792b5084e702366eb97 224319425336427abf274df66f46a999--a16118cc38fe4792b5084e702366eb97 1d703c4f036741b2ae7b1007b1630e4b a16118cc38fe4792b5084e702366eb97--1d703c4f036741b2ae7b1007b1630e4b f49246f121d14e329c7753d0d153f047 1d703c4f036741b2ae7b1007b1630e4b--f49246f121d14e329c7753d0d153f047 2c231998a8ca405c96252f2e82fa5f17 f49246f121d14e329c7753d0d153f047--2c231998a8ca405c96252f2e82fa5f17 4e54f51c7aab4d53b17e5f722261452d 2c231998a8ca405c96252f2e82fa5f17--4e54f51c7aab4d53b17e5f722261452d 77625a73ff104cb1a71755c405eeba1a 4e54f51c7aab4d53b17e5f722261452d--77625a73ff104cb1a71755c405eeba1a c116ce01964b473baea2e9ca310e9add 77625a73ff104cb1a71755c405eeba1a--c116ce01964b473baea2e9ca310e9add 289b35cde1f743bc92d2cb39fc271f3c c116ce01964b473baea2e9ca310e9add--289b35cde1f743bc92d2cb39fc271f3c 873c70fde09b43e9ae6d69d60e22dbc1 X 289b35cde1f743bc92d2cb39fc271f3c--873c70fde09b43e9ae6d69d60e22dbc1 873c70fde09b43e9ae6d69d60e22dbc1--9ad84a8fbd4a4b4cadb7c1e905901988 eea262d0ee964a4f94347fec41b98c52 RZ(-1.0*g0) 873c70fde09b43e9ae6d69d60e22dbc1--eea262d0ee964a4f94347fec41b98c52 b7f1bb28a9ec4918b71a8f7adb62b687 X eea262d0ee964a4f94347fec41b98c52--b7f1bb28a9ec4918b71a8f7adb62b687 b7f1bb28a9ec4918b71a8f7adb62b687--ec5c9e89656e43659c4e8434e5f1ceb8 7917dbf8d5074f59af0f9d4addb3f66f b7f1bb28a9ec4918b71a8f7adb62b687--7917dbf8d5074f59af0f9d4addb3f66f 2b9229e063f54e10ad331342f1a1c780 7917dbf8d5074f59af0f9d4addb3f66f--2b9229e063f54e10ad331342f1a1c780 b3327838a25b43ef9d267cd00b6d24f5 RX(b07) 2b9229e063f54e10ad331342f1a1c780--b3327838a25b43ef9d267cd00b6d24f5 8fffd2f623994753b4130e7d2cf1b8e2 b3327838a25b43ef9d267cd00b6d24f5--8fffd2f623994753b4130e7d2cf1b8e2 1326c1db5a094233ab847df6428225a1 8fffd2f623994753b4130e7d2cf1b8e2--1326c1db5a094233ab847df6428225a1 8599e2fdeae94df6bf304c3027a43c26 1326c1db5a094233ab847df6428225a1--8599e2fdeae94df6bf304c3027a43c26 b3444854fdc74ac9ab19b35bb5aad6c6 8599e2fdeae94df6bf304c3027a43c26--b3444854fdc74ac9ab19b35bb5aad6c6 a3e79158c6c4450f805f9a416308ff6e b3444854fdc74ac9ab19b35bb5aad6c6--a3e79158c6c4450f805f9a416308ff6e 77f48bbb312549c987a04559e634bf21 a3e79158c6c4450f805f9a416308ff6e--77f48bbb312549c987a04559e634bf21 8c2fd4b35d974bf5b4ff543ed4dba23e X 77f48bbb312549c987a04559e634bf21--8c2fd4b35d974bf5b4ff543ed4dba23e 8c2fd4b35d974bf5b4ff543ed4dba23e--86fc6d9b71f042c1972dff23e679a387 af1c37c19fcc4e308272284b8550e6c4 RZ(1.0*g1) 8c2fd4b35d974bf5b4ff543ed4dba23e--af1c37c19fcc4e308272284b8550e6c4 11533b85f7ab48988ced2c48879af67a X af1c37c19fcc4e308272284b8550e6c4--11533b85f7ab48988ced2c48879af67a 11533b85f7ab48988ced2c48879af67a--a073b65850b9484b8e4ebc87538f1f94 b9447bf9a1b64e298018db846a9e50d6 11533b85f7ab48988ced2c48879af67a--b9447bf9a1b64e298018db846a9e50d6 1dedccaa43704bd7b1dceaac92337263 b9447bf9a1b64e298018db846a9e50d6--1dedccaa43704bd7b1dceaac92337263 2dd01a865d0948c1b3d49ce853960def 1dedccaa43704bd7b1dceaac92337263--2dd01a865d0948c1b3d49ce853960def 6ad20272a2484011952ce1b8e08c481e 2dd01a865d0948c1b3d49ce853960def--6ad20272a2484011952ce1b8e08c481e 4c70972559514b3aaf7e3c5a899d906d 6ad20272a2484011952ce1b8e08c481e--4c70972559514b3aaf7e3c5a899d906d ce015fbfaed64d3e99d0a5f6ac1b59a3 4c70972559514b3aaf7e3c5a899d906d--ce015fbfaed64d3e99d0a5f6ac1b59a3 b4e730cb851f4cf19f089cf9776c86fc ce015fbfaed64d3e99d0a5f6ac1b59a3--b4e730cb851f4cf19f089cf9776c86fc cb86a1a8adc04301bae1b6087ae902b6 b4e730cb851f4cf19f089cf9776c86fc--cb86a1a8adc04301bae1b6087ae902b6 cd474b9933a64883abfdfb1f5759f440 cb86a1a8adc04301bae1b6087ae902b6--cd474b9933a64883abfdfb1f5759f440 b5c91051200f47e486100314f4fa4dec cd474b9933a64883abfdfb1f5759f440--b5c91051200f47e486100314f4fa4dec 13512a262ec94a18b89a133ffb95b41e b5c91051200f47e486100314f4fa4dec--13512a262ec94a18b89a133ffb95b41e 1e642978ed324a0594b5de2989720f3c 13512a262ec94a18b89a133ffb95b41e--1e642978ed324a0594b5de2989720f3c 5207d507e6b341aaa8d12ce8f61c86b5 1e642978ed324a0594b5de2989720f3c--5207d507e6b341aaa8d12ce8f61c86b5 06e7b05029084b30b201c5666e7f79f5 5207d507e6b341aaa8d12ce8f61c86b5--06e7b05029084b30b201c5666e7f79f5 35152b33f557475187aa82a86ccb1c1f 06e7b05029084b30b201c5666e7f79f5--35152b33f557475187aa82a86ccb1c1f 83458a3dca5a491cab9508c7f5e58f0d 35152b33f557475187aa82a86ccb1c1f--83458a3dca5a491cab9508c7f5e58f0d 8bb5a33f5c0f4ff2bef840f4892ec9ad 83458a3dca5a491cab9508c7f5e58f0d--8bb5a33f5c0f4ff2bef840f4892ec9ad cbdc094f2b464f72b6dbb27161a00d6b 8bb5a33f5c0f4ff2bef840f4892ec9ad--cbdc094f2b464f72b6dbb27161a00d6b 9f3ba9a9063241d0b4e38e9de4ac309f cbdc094f2b464f72b6dbb27161a00d6b--9f3ba9a9063241d0b4e38e9de4ac309f 7fe3203b6b164cf9adfe0f27a2ae20ed 9f3ba9a9063241d0b4e38e9de4ac309f--7fe3203b6b164cf9adfe0f27a2ae20ed 3e471b95f7294026b3100834780866ff 7fe3203b6b164cf9adfe0f27a2ae20ed--3e471b95f7294026b3100834780866ff 5ed84b833f574a98920bb709500e9bfe 3e471b95f7294026b3100834780866ff--5ed84b833f574a98920bb709500e9bfe 4dcb8c9c2c6245e2a2276e7dd95c243c 5ed84b833f574a98920bb709500e9bfe--4dcb8c9c2c6245e2a2276e7dd95c243c fefe1e6e35b0462c826d282e75a2ef72 4dcb8c9c2c6245e2a2276e7dd95c243c--fefe1e6e35b0462c826d282e75a2ef72 dbc4b29d100f4f5f8ecab56746071332 fefe1e6e35b0462c826d282e75a2ef72--dbc4b29d100f4f5f8ecab56746071332 089e677e20464e5ea4b469f12ac2732a dbc4b29d100f4f5f8ecab56746071332--089e677e20464e5ea4b469f12ac2732a 8d3e460b4ef740a1bf2b4bcb635ff6ed 089e677e20464e5ea4b469f12ac2732a--8d3e460b4ef740a1bf2b4bcb635ff6ed 3822bf97ce7540d0b0322cc3c6a54b1d 8d3e460b4ef740a1bf2b4bcb635ff6ed--3822bf97ce7540d0b0322cc3c6a54b1d b8e075a8bddc485ba8a996f4b4f64b61 3822bf97ce7540d0b0322cc3c6a54b1d--b8e075a8bddc485ba8a996f4b4f64b61 aefc6e62c55e485f8b6eb30aee323b33 b8e075a8bddc485ba8a996f4b4f64b61--aefc6e62c55e485f8b6eb30aee323b33 b6f8fb17a44244ab8cb02d39fcb2e33a aefc6e62c55e485f8b6eb30aee323b33--b6f8fb17a44244ab8cb02d39fcb2e33a f76ef9245ec5411eb773028fecf3dd3a b6f8fb17a44244ab8cb02d39fcb2e33a--f76ef9245ec5411eb773028fecf3dd3a 417d1977c2b44f858e0657e3b91ed6b7 f76ef9245ec5411eb773028fecf3dd3a--417d1977c2b44f858e0657e3b91ed6b7 0c597615a6e645a1a54f0e489882fe3c 417d1977c2b44f858e0657e3b91ed6b7--0c597615a6e645a1a54f0e489882fe3c 90fd675918c74fdd8d0d46cf24232092 0c597615a6e645a1a54f0e489882fe3c--90fd675918c74fdd8d0d46cf24232092 4d74adedef934d1aa16468712d32bb59 90fd675918c74fdd8d0d46cf24232092--4d74adedef934d1aa16468712d32bb59 37dce0aac8ca4a239901821f18a023a2 4d74adedef934d1aa16468712d32bb59--37dce0aac8ca4a239901821f18a023a2 97de5cb3bbad47cc802cf0d0075e80ce 37dce0aac8ca4a239901821f18a023a2--97de5cb3bbad47cc802cf0d0075e80ce 50c8f8ed3b594f729978ce653c1c1789 97de5cb3bbad47cc802cf0d0075e80ce--50c8f8ed3b594f729978ce653c1c1789 faf6414b3182413d9159dbfedbfc0821 50c8f8ed3b594f729978ce653c1c1789--faf6414b3182413d9159dbfedbfc0821 d42d736f2d1946f9997c901c078469d3 faf6414b3182413d9159dbfedbfc0821--d42d736f2d1946f9997c901c078469d3 95b4505172c64a89833711d34eff6823 d42d736f2d1946f9997c901c078469d3--95b4505172c64a89833711d34eff6823 6e8b89882b1a4459aa1ca05414216752 95b4505172c64a89833711d34eff6823--6e8b89882b1a4459aa1ca05414216752 4edeabc6e5014d44a4dd7c756fd4ae08 6e8b89882b1a4459aa1ca05414216752--4edeabc6e5014d44a4dd7c756fd4ae08 2bde4f89c3e9407582c34942e3658edd 4edeabc6e5014d44a4dd7c756fd4ae08--2bde4f89c3e9407582c34942e3658edd 262f39dd3f43441a80e62d0108aa0aac 2bde4f89c3e9407582c34942e3658edd--262f39dd3f43441a80e62d0108aa0aac 0f69d8c0929a4267aee1f75424111021 262f39dd3f43441a80e62d0108aa0aac--0f69d8c0929a4267aee1f75424111021 82c992c313de46cb9a0f2cb460cca5ee 0f69d8c0929a4267aee1f75424111021--82c992c313de46cb9a0f2cb460cca5ee ef9637e4f290424b880c2836fa274c82 82c992c313de46cb9a0f2cb460cca5ee--ef9637e4f290424b880c2836fa274c82 698b8f2b0fc44e83b12bc9f6869a3806 ef9637e4f290424b880c2836fa274c82--698b8f2b0fc44e83b12bc9f6869a3806 1966f8d4f5334b8c8c4bebea38091814 698b8f2b0fc44e83b12bc9f6869a3806--1966f8d4f5334b8c8c4bebea38091814 253dfeba332f4d0693fc5ea083a9128b 1966f8d4f5334b8c8c4bebea38091814--253dfeba332f4d0693fc5ea083a9128b de00d11db465439b9c6f663fad48cb12 253dfeba332f4d0693fc5ea083a9128b--de00d11db465439b9c6f663fad48cb12 0a30b19bb1234b15abf2315fd8ce1597 de00d11db465439b9c6f663fad48cb12--0a30b19bb1234b15abf2315fd8ce1597 2e92850d15d2441bb28e5378eab98e26 0a30b19bb1234b15abf2315fd8ce1597--2e92850d15d2441bb28e5378eab98e26 23e67e8fb79c4633bd10795de16f6fcd 2e92850d15d2441bb28e5378eab98e26--23e67e8fb79c4633bd10795de16f6fcd 8eb2a89bc1964995974f0e97e7097602 23e67e8fb79c4633bd10795de16f6fcd--8eb2a89bc1964995974f0e97e7097602 b51c179289d34fbb9b41e355f7d8dc20 8eb2a89bc1964995974f0e97e7097602--b51c179289d34fbb9b41e355f7d8dc20 6ac04e184a5f4226814a660b5c63a0fd b51c179289d34fbb9b41e355f7d8dc20--6ac04e184a5f4226814a660b5c63a0fd 7dd589e0bf2e492e81162768b3235226 6ac04e184a5f4226814a660b5c63a0fd--7dd589e0bf2e492e81162768b3235226 70a87e8fcddb48dfbef4083f7a3892c2 7dd589e0bf2e492e81162768b3235226--70a87e8fcddb48dfbef4083f7a3892c2 496ae37ee7b04bf9ad2bcf47f8510914 70a87e8fcddb48dfbef4083f7a3892c2--496ae37ee7b04bf9ad2bcf47f8510914 fd8ea9351fbf4af4bab71b94d377e272 496ae37ee7b04bf9ad2bcf47f8510914--fd8ea9351fbf4af4bab71b94d377e272 21e130977130463c980d8b3234b2c58e fd8ea9351fbf4af4bab71b94d377e272--21e130977130463c980d8b3234b2c58e f0a3306e583144399adc0d50947af578 21e130977130463c980d8b3234b2c58e--f0a3306e583144399adc0d50947af578 138bf14919254949b9dfec48f8bee6ec f0a3306e583144399adc0d50947af578--138bf14919254949b9dfec48f8bee6ec bd57f4e5dccf4aec92c77f885def7fc7 138bf14919254949b9dfec48f8bee6ec--bd57f4e5dccf4aec92c77f885def7fc7 4c89827b54d14d8cbb562e8e135d0ec4 bd57f4e5dccf4aec92c77f885def7fc7--4c89827b54d14d8cbb562e8e135d0ec4 5763961cadc24531bd4e15a504727b97 4c89827b54d14d8cbb562e8e135d0ec4--5763961cadc24531bd4e15a504727b97 f83a579e9783410facfacb141c8fe45f 5763961cadc24531bd4e15a504727b97--f83a579e9783410facfacb141c8fe45f 2eed1ff71a494f4a9d31b3a7ec19b741 f83a579e9783410facfacb141c8fe45f--2eed1ff71a494f4a9d31b3a7ec19b741 b0892ad5d0124a9682647683f58584f1 2eed1ff71a494f4a9d31b3a7ec19b741--b0892ad5d0124a9682647683f58584f1 b30b4a317730443fa8c7766a9381cd02 b0892ad5d0124a9682647683f58584f1--b30b4a317730443fa8c7766a9381cd02 ca970641651f4e498418a4370424f39a b30b4a317730443fa8c7766a9381cd02--ca970641651f4e498418a4370424f39a 2d6ec268af394db9998b096fab914ac8 ca970641651f4e498418a4370424f39a--2d6ec268af394db9998b096fab914ac8 75f8ceddd11047409eb634fc183d1e74 2d6ec268af394db9998b096fab914ac8--75f8ceddd11047409eb634fc183d1e74 a29aaf3e4a7b4ed1898d74858719b0df 75f8ceddd11047409eb634fc183d1e74--a29aaf3e4a7b4ed1898d74858719b0df 91afa792d2dd44c49320905e08f62c8a a29aaf3e4a7b4ed1898d74858719b0df--91afa792d2dd44c49320905e08f62c8a ebbb3f1bf44f4bff8848e4c3faec7cb7 91afa792d2dd44c49320905e08f62c8a--ebbb3f1bf44f4bff8848e4c3faec7cb7 d8ba2a608b3c4e4887cc6fb845ccd530 ebbb3f1bf44f4bff8848e4c3faec7cb7--d8ba2a608b3c4e4887cc6fb845ccd530 e3e42442afc04c1e8e6767828aa47cdf d8ba2a608b3c4e4887cc6fb845ccd530--e3e42442afc04c1e8e6767828aa47cdf 59d95d239fec4633b917b8942358ef56 X e3e42442afc04c1e8e6767828aa47cdf--59d95d239fec4633b917b8942358ef56 59d95d239fec4633b917b8942358ef56--16f559bdf7d2400ca477151cc074fe49 dca274493f014e4a80f93fe6a9f0dcd7 RZ(-1.0*g1) 59d95d239fec4633b917b8942358ef56--dca274493f014e4a80f93fe6a9f0dcd7 1ca6f47b03164acfb3a9d8edce03dac4 X dca274493f014e4a80f93fe6a9f0dcd7--1ca6f47b03164acfb3a9d8edce03dac4 1ca6f47b03164acfb3a9d8edce03dac4--c29439bc1a7e4923ae152baa0c2a811d 88f42955cc9747ddbccdb7984dcc9a2e 1ca6f47b03164acfb3a9d8edce03dac4--88f42955cc9747ddbccdb7984dcc9a2e 6910fe748f6b45b9baf3f6b8459b7f4e 88f42955cc9747ddbccdb7984dcc9a2e--6910fe748f6b45b9baf3f6b8459b7f4e aeb43c6f56f64d95ae5decb0b58d6bf6 6910fe748f6b45b9baf3f6b8459b7f4e--aeb43c6f56f64d95ae5decb0b58d6bf6 0445f588bce94a3abae5ef79d9a4a2b9 aeb43c6f56f64d95ae5decb0b58d6bf6--0445f588bce94a3abae5ef79d9a4a2b9 06e9a3c1f28c405b831a5a33b141539d 0445f588bce94a3abae5ef79d9a4a2b9--06e9a3c1f28c405b831a5a33b141539d d60144ba637548919346f36dd8483fd4 06e9a3c1f28c405b831a5a33b141539d--d60144ba637548919346f36dd8483fd4 a4bec802571b43a6a68f22cd7cb53cc9 d60144ba637548919346f36dd8483fd4--a4bec802571b43a6a68f22cd7cb53cc9 6be12d5369524e028fc47b0419f34e74 a4bec802571b43a6a68f22cd7cb53cc9--6be12d5369524e028fc47b0419f34e74 e1dbf1867bd74a828c1b0fc4f27d078b 6be12d5369524e028fc47b0419f34e74--e1dbf1867bd74a828c1b0fc4f27d078b fda4a885216a4aa09e0b07b38826876d e1dbf1867bd74a828c1b0fc4f27d078b--fda4a885216a4aa09e0b07b38826876d 3e580e5e73ac4ceb9d7f7459b48b0228 fda4a885216a4aa09e0b07b38826876d--3e580e5e73ac4ceb9d7f7459b48b0228 1f80a8d4e77c45a093cce65b5c7e0250 3e580e5e73ac4ceb9d7f7459b48b0228--1f80a8d4e77c45a093cce65b5c7e0250 ddaa095d489b4560aac6f6f618a2cc5c 1f80a8d4e77c45a093cce65b5c7e0250--ddaa095d489b4560aac6f6f618a2cc5c d807904f1880429fa52290e7c6dc2b75 ddaa095d489b4560aac6f6f618a2cc5c--d807904f1880429fa52290e7c6dc2b75 8d949625fc3b4b878e2da069144674e9 X d807904f1880429fa52290e7c6dc2b75--8d949625fc3b4b878e2da069144674e9 8d949625fc3b4b878e2da069144674e9--4ddc8905c00d49c98044da8bd56030cf 9cbe7429e6af412fbebe4b106cd2c452 RZ(-1.0*g1) 8d949625fc3b4b878e2da069144674e9--9cbe7429e6af412fbebe4b106cd2c452 6827877a33c64c03b480420107062dca X 9cbe7429e6af412fbebe4b106cd2c452--6827877a33c64c03b480420107062dca 6827877a33c64c03b480420107062dca--8a9e78b4b44f48a0b70562fa00593edc c05b8825a9d74af49ec2b445b00a3d44 6827877a33c64c03b480420107062dca--c05b8825a9d74af49ec2b445b00a3d44 a6d5c23dcaaf4e32a398fc7f90652532 c05b8825a9d74af49ec2b445b00a3d44--a6d5c23dcaaf4e32a398fc7f90652532 4083c928bf274e529d64a1613be3ad14 RX(b17) a6d5c23dcaaf4e32a398fc7f90652532--4083c928bf274e529d64a1613be3ad14 4083c928bf274e529d64a1613be3ad14--c9b71190925448b2959d3377c4fefe19"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -3.6905538956499044\nMaxCut cost at iteration 10: 9.463669940873352\nMaxCut cost at iteration 20: 9.95171393662615\nMaxCut cost at iteration 30: 9.997777542146933\nMaxCut cost at iteration 40: 9.996548680466175\nMaxCut cost at iteration 50: 9.999212712012435\nMaxCut cost at iteration 60: 9.999914476301042\nMaxCut cost at iteration 70: 9.999991518102432\nMaxCut cost at iteration 80: 9.999999166465695\nMaxCut cost at iteration 90: 9.999999918160269\nMaxCut cost at iteration 100: 9.999999991965337\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01101100  2023-11-05T22:47:30.158578 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-11-05T22:47:33.669439 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\nn_qubits = 3\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_758a059a95334e60a3722d71180a912f Constant Chebyshev FM cluster_0dd04badf485428e8abf58a777ff2d6f Constant Fourier FM 59801b5da1b4440eabdaaae892cbd786 0 43ccc946a9654afeae8776a5a5697a92 RX(phi) 59801b5da1b4440eabdaaae892cbd786--43ccc946a9654afeae8776a5a5697a92 a60c260d30814cc7b065cabaf39aa983 1 4de8ad6999c24b4bbc0fe0b9dac095e9 RX(acos(phi)) 43ccc946a9654afeae8776a5a5697a92--4de8ad6999c24b4bbc0fe0b9dac095e9 df7fbc791c66496491d171771a79be7e 4de8ad6999c24b4bbc0fe0b9dac095e9--df7fbc791c66496491d171771a79be7e 70ce6394beaa4426867e6426c3cb9557 65efe8d05399495f8f579310cf4d33ef RX(phi) a60c260d30814cc7b065cabaf39aa983--65efe8d05399495f8f579310cf4d33ef a5f38329f4a04f26806ee0ab81583d35 2 605cd29446c14fed99a166cbc8b711d5 RX(acos(phi)) 65efe8d05399495f8f579310cf4d33ef--605cd29446c14fed99a166cbc8b711d5 605cd29446c14fed99a166cbc8b711d5--70ce6394beaa4426867e6426c3cb9557 dc8fffcac5e04fbfbb18682d3806d67c 5045f273e50d43f1b066892c995bf25a RX(phi) a5f38329f4a04f26806ee0ab81583d35--5045f273e50d43f1b066892c995bf25a f79a29c26f1a40ac8ab805a3a46f552e RX(acos(phi)) 5045f273e50d43f1b066892c995bf25a--f79a29c26f1a40ac8ab805a3a46f552e f79a29c26f1a40ac8ab805a3a46f552e--dc8fffcac5e04fbfbb18682d3806d67c <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\nn_qubits = 3\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n@classmethod\ndef eval(cls, x):\nreturn asin(x) + x**2\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_bdee9219eef543049fa44c4f4926bbce Constant custom_func FM cluster_2df29e8f1569444496797beecd12a3af Constant asin FM d641f727c04d4a0da5810d981c3780a1 0 bf92965289504be3b8d475cfe2bd9c40 RX(asin(phi)) d641f727c04d4a0da5810d981c3780a1--bf92965289504be3b8d475cfe2bd9c40 6d3de42ef5ad4cf891a0aa1ae40e5ff5 1 7e595fcf9a8a4e2eb47fd966b0f62a85 RX(phi**2 + asin(phi)) bf92965289504be3b8d475cfe2bd9c40--7e595fcf9a8a4e2eb47fd966b0f62a85 a61fed6e624f46458cc4a591db2017c0 7e595fcf9a8a4e2eb47fd966b0f62a85--a61fed6e624f46458cc4a591db2017c0 06183281f56d476ebdfe10968b220b70 12079807f42840f2aa08006eaa0147a8 RX(asin(phi)) 6d3de42ef5ad4cf891a0aa1ae40e5ff5--12079807f42840f2aa08006eaa0147a8 d5db7a1a450c4cbfbc4a0f5cd4fa70af 2 3d6450d8f2654c3a9cb372d1ce03e08f RX(phi**2 + asin(phi)) 12079807f42840f2aa08006eaa0147a8--3d6450d8f2654c3a9cb372d1ce03e08f 3d6450d8f2654c3a9cb372d1ce03e08f--06183281f56d476ebdfe10968b220b70 ac391545f8c7409baa0ddcbb6e0f7dff 0116cc271a0a4022a6701d0c859233cc RX(asin(phi)) d5db7a1a450c4cbfbc4a0f5cd4fa70af--0116cc271a0a4022a6701d0c859233cc dce1e0c107cd4a89aa541b39193458e2 RX(phi**2 + asin(phi)) 0116cc271a0a4022a6701d0c859233cc--dce1e0c107cd4a89aa541b39193458e2 dce1e0c107cd4a89aa541b39193458e2--ac391545f8c7409baa0ddcbb6e0f7dff <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\nn_qubits = 5\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_209b33c9a9bd4cb598f01978d837b58d Exponential Fourier FM cluster_98a6fd9d28c144c683d4dfca6f542d7b Constant Fourier FM cluster_7a7a08e3a4bb48b09eaeca132cec5d55 Tower Fourier FM fc07a3677b524866bd284e94229d3ec4 0 41581f1e7b8940e784598b597f1df4c2 RX(phi) fc07a3677b524866bd284e94229d3ec4--41581f1e7b8940e784598b597f1df4c2 9ffcae60505843b2ac98bd4ca1623c1f 1 28cff5e665b545dc8deb3760fb8d966d RX(1.0*phi) 41581f1e7b8940e784598b597f1df4c2--28cff5e665b545dc8deb3760fb8d966d c849deb96ade40eabb209788850639d8 RX(1.0*phi) 28cff5e665b545dc8deb3760fb8d966d--c849deb96ade40eabb209788850639d8 443cbf72f300431091c292c5231e3ebf c849deb96ade40eabb209788850639d8--443cbf72f300431091c292c5231e3ebf cadba89747f740b6b9bfac5443ca5ba2 aa2faa7cd15f4ea4b678780b1a4f0044 RX(phi) 9ffcae60505843b2ac98bd4ca1623c1f--aa2faa7cd15f4ea4b678780b1a4f0044 f94e237828784cfda6e70061a91d2f80 2 933c43883580400b8bbc9eec0c71ae58 RX(2.0*phi) aa2faa7cd15f4ea4b678780b1a4f0044--933c43883580400b8bbc9eec0c71ae58 8bd4e4f4f7b54afea1ec21f15ce8683c RX(2.0*phi) 933c43883580400b8bbc9eec0c71ae58--8bd4e4f4f7b54afea1ec21f15ce8683c 8bd4e4f4f7b54afea1ec21f15ce8683c--cadba89747f740b6b9bfac5443ca5ba2 abde8a202d9142e5828051047144ffde aac4f85f5db845feb88a63140d4cfab5 RX(phi) f94e237828784cfda6e70061a91d2f80--aac4f85f5db845feb88a63140d4cfab5 96ca3facd3184f9cbcaa74a33cce5829 3 85282f23c1294641b407322b27991225 RX(3.0*phi) aac4f85f5db845feb88a63140d4cfab5--85282f23c1294641b407322b27991225 0603decbcf8b413a84a9347736315aa7 RX(4.0*phi) 85282f23c1294641b407322b27991225--0603decbcf8b413a84a9347736315aa7 0603decbcf8b413a84a9347736315aa7--abde8a202d9142e5828051047144ffde e770f1a415704bbfa32f7c1a572b3c5a 5a1d4b23672a4f4fa7c47ebeab18b5c5 RX(phi) 96ca3facd3184f9cbcaa74a33cce5829--5a1d4b23672a4f4fa7c47ebeab18b5c5 1570f8fff87242518731c2a2d1e063de 4 7fb5e176777c49c88dbf7892ffd3b5f9 RX(4.0*phi) 5a1d4b23672a4f4fa7c47ebeab18b5c5--7fb5e176777c49c88dbf7892ffd3b5f9 959425c21a164c118b3c3ca2703a5168 RX(8.0*phi) 7fb5e176777c49c88dbf7892ffd3b5f9--959425c21a164c118b3c3ca2703a5168 959425c21a164c118b3c3ca2703a5168--e770f1a415704bbfa32f7c1a572b3c5a ae0125abedbd4c2cb55d2f1c896189c5 027c3a018cf54c568f4cadd3207eaf68 RX(phi) 1570f8fff87242518731c2a2d1e063de--027c3a018cf54c568f4cadd3207eaf68 d80c579550ea4ee6b462890a4c3a8569 RX(5.0*phi) 027c3a018cf54c568f4cadd3207eaf68--d80c579550ea4ee6b462890a4c3a8569 0412809e56174dd9b6840e58b8ea53a8 RX(16.0*phi) d80c579550ea4ee6b462890a4c3a8569--0412809e56174dd9b6840e58b8ea53a8 0412809e56174dd9b6840e58b8ea53a8--ae0125abedbd4c2cb55d2f1c896189c5 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\ndef custom_scaling(i: int) -&gt; int | float:\n\"\"\"Sqrt(i+1)\"\"\"\nreturn (i+1) ** (0.5)\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 54f7c8059bd248649a3033ee5cd966d2 0 efe7c9baf1a74cf8b5876b9d2dfcdf35 RX(1.0*acos(phi)) 54f7c8059bd248649a3033ee5cd966d2--efe7c9baf1a74cf8b5876b9d2dfcdf35 5ed172d2325f40d2b97476592e27c151 1 0931de374ce04a678a62d48152ea2209 efe7c9baf1a74cf8b5876b9d2dfcdf35--0931de374ce04a678a62d48152ea2209 eb20aa1d709f4004aa092ea5e6196326 198e55bc0422464584568c97198ae976 RX(1.414*acos(phi)) 5ed172d2325f40d2b97476592e27c151--198e55bc0422464584568c97198ae976 8887603bc56648748e730217861bda58 2 198e55bc0422464584568c97198ae976--eb20aa1d709f4004aa092ea5e6196326 5fd96abaa4e840cba3a997579c11a197 3f52a11fd4044685a5aa7938d3ed9d3e RX(1.732*acos(phi)) 8887603bc56648748e730217861bda58--3f52a11fd4044685a5aa7938d3ed9d3e a9d4d5ba89374e6fb0f06568fbb6d024 3 3f52a11fd4044685a5aa7938d3ed9d3e--5fd96abaa4e840cba3a997579c11a197 0edf1130882b4543ad7b21cb61533b7a deac49ac43c04575b31b4b736243efdd RX(2.0*acos(phi)) a9d4d5ba89374e6fb0f06568fbb6d024--deac49ac43c04575b31b4b736243efdd 4a65e8fe8d0b48948500c98df1b89750 4 deac49ac43c04575b31b4b736243efdd--0edf1130882b4543ad7b21cb61533b7a 9e895a239962482d9f4a1681b76bf623 2257c0441f93422f9db918768709734d RX(2.236*acos(phi)) 4a65e8fe8d0b48948500c98df1b89750--2257c0441f93422f9db918768709734d 2257c0441f93422f9db918768709734d--9e895a239962482d9f4a1681b76bf623 <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\nn_qubits = 5\n# Custom scaling function\nfm_full = feature_map(\nn_qubits = n_qubits,\nsupport = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\nparam = \"x\", # Change the name of the parameter\nop = RY, # Change the rotation gate between RX, RY, RZ or PHASE\nfm_type = BasisSet.CHEBYSHEV,\nreupload_scaling = ReuploadScaling.EXP,\nfeature_range = (-1.0, 2.0), # Range from which the input data comes from\ntarget_range = (1.0, 3.0), # Range the encoder assumes as the natural range\nmultiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 abebfc6dc5f841239c696fb122b5d71a 0 11f6db15287448beb4438242a646971d RY(80.0*acos(0.667*x + 1.667)) abebfc6dc5f841239c696fb122b5d71a--11f6db15287448beb4438242a646971d 1cd51158668342fa8db76d6aa4e3c46c 1 d304f595dcbf4581b429af7635135df8 11f6db15287448beb4438242a646971d--d304f595dcbf4581b429af7635135df8 df9b44f4bd844c6cb9097523e6d76812 1e0f4a7e29444f5f97486d23db6164f1 RY(40.0*acos(0.667*x + 1.667)) 1cd51158668342fa8db76d6aa4e3c46c--1e0f4a7e29444f5f97486d23db6164f1 05e7312c0c38454b869118d7ec2e5230 2 1e0f4a7e29444f5f97486d23db6164f1--df9b44f4bd844c6cb9097523e6d76812 c87cce651d8c40389a393c249a8f6a60 4ed728abe86e4fa284469e736ace6469 RY(20.0*acos(0.667*x + 1.667)) 05e7312c0c38454b869118d7ec2e5230--4ed728abe86e4fa284469e736ace6469 2ba8c21b8e2645909a85179dd884ad27 3 4ed728abe86e4fa284469e736ace6469--c87cce651d8c40389a393c249a8f6a60 a2f04c3530f7410dbf85a9c9773f8bd0 9392c4c172d5411eb85ee41c1b478c1f RY(10.0*acos(0.667*x + 1.667)) 2ba8c21b8e2645909a85179dd884ad27--9392c4c172d5411eb85ee41c1b478c1f 86a1adfa06b84d82b468317fe62a6abe 4 9392c4c172d5411eb85ee41c1b478c1f--a2f04c3530f7410dbf85a9c9773f8bd0 8c1d88ce50074ab78cb650828b22ee81 2aee26613c9e418f96619720374538c4 RY(5.0*acos(0.667*x + 1.667)) 86a1adfa06b84d82b468317fe62a6abe--2aee26613c9e418f96619720374538c4 2aee26613c9e418f96619720374538c4--8c1d88ce50074ab78cb650828b22ee81"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> %3 019da967e9f64378be7c15c891742ee1 0 05afa4b9223a49af8bcd768fa0cf8fd5 RX(theta\u2080) 019da967e9f64378be7c15c891742ee1--05afa4b9223a49af8bcd768fa0cf8fd5 f491a78d383646dc80be0d76f5341b1d 1 f265ac295fc142ee865eac3e81aba5c7 RY(theta\u2083) 05afa4b9223a49af8bcd768fa0cf8fd5--f265ac295fc142ee865eac3e81aba5c7 6a29ab9154754667a1b86d19ddc0d99a RX(theta\u2086) f265ac295fc142ee865eac3e81aba5c7--6a29ab9154754667a1b86d19ddc0d99a 2de30353e78144e1a5df14cc93ef4046 6a29ab9154754667a1b86d19ddc0d99a--2de30353e78144e1a5df14cc93ef4046 045a8e265ab3424484e21c84fd8fa8c1 2de30353e78144e1a5df14cc93ef4046--045a8e265ab3424484e21c84fd8fa8c1 07a16e561ace4e66a01a07ff0b345dba RX(theta\u2089) 045a8e265ab3424484e21c84fd8fa8c1--07a16e561ace4e66a01a07ff0b345dba 073df38d39bd4f4fa1e852ff949d3fb2 RY(theta\u2081\u2082) 07a16e561ace4e66a01a07ff0b345dba--073df38d39bd4f4fa1e852ff949d3fb2 922dac29d6754a5dba2c252a580917b7 RX(theta\u2081\u2085) 073df38d39bd4f4fa1e852ff949d3fb2--922dac29d6754a5dba2c252a580917b7 2ec20ce51cc44a15b03cc82016afc9e0 922dac29d6754a5dba2c252a580917b7--2ec20ce51cc44a15b03cc82016afc9e0 e035a9afedf143389b546c492be7bd1d 2ec20ce51cc44a15b03cc82016afc9e0--e035a9afedf143389b546c492be7bd1d 1602fb64a8e246e08c304a8edfbea4b3 e035a9afedf143389b546c492be7bd1d--1602fb64a8e246e08c304a8edfbea4b3 01666e0cfd1c4dbf89332ba64d409639 06a88a54dfd44458816863cc1a876342 RX(theta\u2081) f491a78d383646dc80be0d76f5341b1d--06a88a54dfd44458816863cc1a876342 3c3a09b1ebb04ac5b8345f82e5101044 2 2b8a0912465e4cb8bb9e6e0ec23c3774 RY(theta\u2084) 06a88a54dfd44458816863cc1a876342--2b8a0912465e4cb8bb9e6e0ec23c3774 8f0268b8577c44c09087668e4de69bd2 RX(theta\u2087) 2b8a0912465e4cb8bb9e6e0ec23c3774--8f0268b8577c44c09087668e4de69bd2 0f2f1a05b7b8415fb49b16df55e27e8b X 8f0268b8577c44c09087668e4de69bd2--0f2f1a05b7b8415fb49b16df55e27e8b 0f2f1a05b7b8415fb49b16df55e27e8b--2de30353e78144e1a5df14cc93ef4046 8710d40443634a4292078332746a3106 0f2f1a05b7b8415fb49b16df55e27e8b--8710d40443634a4292078332746a3106 4356302642f8424287386ebe6b42e0b0 RX(theta\u2081\u2080) 8710d40443634a4292078332746a3106--4356302642f8424287386ebe6b42e0b0 d6b206a061f944689897ad2d8bf12c01 RY(theta\u2081\u2083) 4356302642f8424287386ebe6b42e0b0--d6b206a061f944689897ad2d8bf12c01 d6851c991ecf4ed182217fffcf0d0512 RX(theta\u2081\u2086) d6b206a061f944689897ad2d8bf12c01--d6851c991ecf4ed182217fffcf0d0512 6d19696b3e64499dae2df2b9fd5308aa X d6851c991ecf4ed182217fffcf0d0512--6d19696b3e64499dae2df2b9fd5308aa 6d19696b3e64499dae2df2b9fd5308aa--2ec20ce51cc44a15b03cc82016afc9e0 43785c59ff894bcfb03fd0fd5ff7c3bf 6d19696b3e64499dae2df2b9fd5308aa--43785c59ff894bcfb03fd0fd5ff7c3bf 43785c59ff894bcfb03fd0fd5ff7c3bf--01666e0cfd1c4dbf89332ba64d409639 5b0c2d44135a4748ba5382c533e9cca7 4ee8245c08074adf9715652bfd5cd26f RX(theta\u2082) 3c3a09b1ebb04ac5b8345f82e5101044--4ee8245c08074adf9715652bfd5cd26f 2628d20052ba41d0aa8eed7031e46996 RY(theta\u2085) 4ee8245c08074adf9715652bfd5cd26f--2628d20052ba41d0aa8eed7031e46996 1ff29f899ede448799a5118f52bab242 RX(theta\u2088) 2628d20052ba41d0aa8eed7031e46996--1ff29f899ede448799a5118f52bab242 bb7c17f8e2884e41bac04b5a2d36b773 1ff29f899ede448799a5118f52bab242--bb7c17f8e2884e41bac04b5a2d36b773 d97c45d0652c41e488d2ae5c33fed127 X bb7c17f8e2884e41bac04b5a2d36b773--d97c45d0652c41e488d2ae5c33fed127 d97c45d0652c41e488d2ae5c33fed127--8710d40443634a4292078332746a3106 c7c7126d842d4736a8d4ae4900ec056a RX(theta\u2081\u2081) d97c45d0652c41e488d2ae5c33fed127--c7c7126d842d4736a8d4ae4900ec056a d13503adfe3e47d8b2c1f4b527c9bfa9 RY(theta\u2081\u2084) c7c7126d842d4736a8d4ae4900ec056a--d13503adfe3e47d8b2c1f4b527c9bfa9 6e4eed695168469b9d2afea33b431cb7 RX(theta\u2081\u2087) d13503adfe3e47d8b2c1f4b527c9bfa9--6e4eed695168469b9d2afea33b431cb7 6990a9583d7249ff98bc20e1a55ea407 6e4eed695168469b9d2afea33b431cb7--6990a9583d7249ff98bc20e1a55ea407 3cdf962afb944470ac4033313c1dbf64 X 6990a9583d7249ff98bc20e1a55ea407--3cdf962afb944470ac4033313c1dbf64 3cdf962afb944470ac4033313c1dbf64--43785c59ff894bcfb03fd0fd5ff7c3bf 3cdf962afb944470ac4033313c1dbf64--5b0c2d44135a4748ba5382c533e9cca7 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> %3 a1134a267c8b472cba1cc9b663ce524b 0 7b97d432660c4a4780427cdbe368cf98 RX(phi\u2080) a1134a267c8b472cba1cc9b663ce524b--7b97d432660c4a4780427cdbe368cf98 7b19c461e0c242f6b2ff9c607010ca8c 1 fccbed018a9349ac96f9103d63ce3a86 RY(phi\u2083) 7b97d432660c4a4780427cdbe368cf98--fccbed018a9349ac96f9103d63ce3a86 6fc0ce94e057465399a8a3bf64a676b0 RX(phi\u2086) fccbed018a9349ac96f9103d63ce3a86--6fc0ce94e057465399a8a3bf64a676b0 8a2ba113d469467e9841193d85a9ed31 6fc0ce94e057465399a8a3bf64a676b0--8a2ba113d469467e9841193d85a9ed31 79beb19870184ec09e212cf452cb765a 8a2ba113d469467e9841193d85a9ed31--79beb19870184ec09e212cf452cb765a adc35a7329ca45018944765eb3868ff7 RX(phi\u2089) 79beb19870184ec09e212cf452cb765a--adc35a7329ca45018944765eb3868ff7 47f2eddf098d433b98e4dba9e6beb6e4 RY(phi\u2081\u2082) adc35a7329ca45018944765eb3868ff7--47f2eddf098d433b98e4dba9e6beb6e4 468bfc5a772448289b5217c86dc5a4d6 RX(phi\u2081\u2085) 47f2eddf098d433b98e4dba9e6beb6e4--468bfc5a772448289b5217c86dc5a4d6 bf08e8b3ceba4b8b9f37dccc2da3c026 468bfc5a772448289b5217c86dc5a4d6--bf08e8b3ceba4b8b9f37dccc2da3c026 8b84da891d6f4ca39881b255884a3012 bf08e8b3ceba4b8b9f37dccc2da3c026--8b84da891d6f4ca39881b255884a3012 3688df439b62430a82ef3e9df9b2a7e7 8b84da891d6f4ca39881b255884a3012--3688df439b62430a82ef3e9df9b2a7e7 090717d3a8b6480682a7e76797bd7993 ce267bc20af448d494f0d9eab627021c RX(phi\u2081) 7b19c461e0c242f6b2ff9c607010ca8c--ce267bc20af448d494f0d9eab627021c 0ed0b2027fcb4e128f99a81237cabefe 2 ee9e2c97e0484fffab9cd30d8a74a265 RY(phi\u2084) ce267bc20af448d494f0d9eab627021c--ee9e2c97e0484fffab9cd30d8a74a265 9936fe1c4eae4d9faec9c28e33fcbd08 RX(phi\u2087) ee9e2c97e0484fffab9cd30d8a74a265--9936fe1c4eae4d9faec9c28e33fcbd08 f0f6a61d302c403380918c832b40da61 PHASE(phi_ent\u2080) 9936fe1c4eae4d9faec9c28e33fcbd08--f0f6a61d302c403380918c832b40da61 f0f6a61d302c403380918c832b40da61--8a2ba113d469467e9841193d85a9ed31 de8b0ff0a6f94780b313f3afa116f2a9 f0f6a61d302c403380918c832b40da61--de8b0ff0a6f94780b313f3afa116f2a9 83421e5a17d140869c248a5c12ab8f49 RX(phi\u2081\u2080) de8b0ff0a6f94780b313f3afa116f2a9--83421e5a17d140869c248a5c12ab8f49 d35521d110c8460a94aff30cb5db6881 RY(phi\u2081\u2083) 83421e5a17d140869c248a5c12ab8f49--d35521d110c8460a94aff30cb5db6881 88278fe7500d4617825325b306d6294a RX(phi\u2081\u2086) d35521d110c8460a94aff30cb5db6881--88278fe7500d4617825325b306d6294a c6f5164498924b72b033799f0b3fb03f PHASE(phi_ent\u2082) 88278fe7500d4617825325b306d6294a--c6f5164498924b72b033799f0b3fb03f c6f5164498924b72b033799f0b3fb03f--bf08e8b3ceba4b8b9f37dccc2da3c026 0d4bac8a9ba94ede927cd5c28771a3cf c6f5164498924b72b033799f0b3fb03f--0d4bac8a9ba94ede927cd5c28771a3cf 0d4bac8a9ba94ede927cd5c28771a3cf--090717d3a8b6480682a7e76797bd7993 3633a2b8fa49410abc8770089f909f76 2aff43b81e2f4d8da69091362ac36fe0 RX(phi\u2082) 0ed0b2027fcb4e128f99a81237cabefe--2aff43b81e2f4d8da69091362ac36fe0 52f12cd20ac14673b737d8d51591e523 RY(phi\u2085) 2aff43b81e2f4d8da69091362ac36fe0--52f12cd20ac14673b737d8d51591e523 2d3b1a12c50e4f218dfa73fc0198d2d6 RX(phi\u2088) 52f12cd20ac14673b737d8d51591e523--2d3b1a12c50e4f218dfa73fc0198d2d6 a57d15576d79491298e3666f61b13731 2d3b1a12c50e4f218dfa73fc0198d2d6--a57d15576d79491298e3666f61b13731 2a99702476e84983976cd2f5798b8b4f PHASE(phi_ent\u2081) a57d15576d79491298e3666f61b13731--2a99702476e84983976cd2f5798b8b4f 2a99702476e84983976cd2f5798b8b4f--de8b0ff0a6f94780b313f3afa116f2a9 4ee7effa03434428834521ba205f7e26 RX(phi\u2081\u2081) 2a99702476e84983976cd2f5798b8b4f--4ee7effa03434428834521ba205f7e26 cc4e0d433b3d4297baafcde5cbbbaf75 RY(phi\u2081\u2084) 4ee7effa03434428834521ba205f7e26--cc4e0d433b3d4297baafcde5cbbbaf75 6ffd3df98f474472baf0264854a79ef1 RX(phi\u2081\u2087) cc4e0d433b3d4297baafcde5cbbbaf75--6ffd3df98f474472baf0264854a79ef1 93f64fed97014d2f8c9c8947f5cd908d 6ffd3df98f474472baf0264854a79ef1--93f64fed97014d2f8c9c8947f5cd908d 902c3ddd3fe5449bb0e50432a2efca5f PHASE(phi_ent\u2083) 93f64fed97014d2f8c9c8947f5cd908d--902c3ddd3fe5449bb0e50432a2efca5f 902c3ddd3fe5449bb0e50432a2efca5f--0d4bac8a9ba94ede927cd5c28771a3cf 902c3ddd3fe5449bb0e50432a2efca5f--3633a2b8fa49410abc8770089f909f76 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_c4f24e985372407487aabc930955e0a6 cluster_e534035a3b9b4854a67f338782b0dc8a 614334ffa7ec44078c5824f900105869 0 8e3ccbe30e2e4a67bfdb1a1e12daca00 RX(theta\u2080) 614334ffa7ec44078c5824f900105869--8e3ccbe30e2e4a67bfdb1a1e12daca00 6adcd59ca96c4285afa48b1ccae57d32 1 c1d996ac20df4b4aab7a4705f192fd58 RY(theta\u2083) 8e3ccbe30e2e4a67bfdb1a1e12daca00--c1d996ac20df4b4aab7a4705f192fd58 68ac2a00b2f743c1a85a1d4400da439a RX(theta\u2086) c1d996ac20df4b4aab7a4705f192fd58--68ac2a00b2f743c1a85a1d4400da439a c9502fd1082d40f6b04c0090c71eaad2 HamEvo 68ac2a00b2f743c1a85a1d4400da439a--c9502fd1082d40f6b04c0090c71eaad2 590014fda50d4308bad93448b9b7e6ca RX(theta\u2089) c9502fd1082d40f6b04c0090c71eaad2--590014fda50d4308bad93448b9b7e6ca 32a4f859578a4a6faa0d94b81c1279d9 RY(theta\u2081\u2082) 590014fda50d4308bad93448b9b7e6ca--32a4f859578a4a6faa0d94b81c1279d9 28b0972b9ed845df9c07a08a9966031a RX(theta\u2081\u2085) 32a4f859578a4a6faa0d94b81c1279d9--28b0972b9ed845df9c07a08a9966031a 1d0a006af8a4411585b31befaf47563a HamEvo 28b0972b9ed845df9c07a08a9966031a--1d0a006af8a4411585b31befaf47563a 510c012a22dd4ed58ee40747eef45367 1d0a006af8a4411585b31befaf47563a--510c012a22dd4ed58ee40747eef45367 d7be3d7660974a42882ef3c19f3bdba1 e7d96c1d1aa34a74a4e666ec9a8d1e75 RX(theta\u2081) 6adcd59ca96c4285afa48b1ccae57d32--e7d96c1d1aa34a74a4e666ec9a8d1e75 72248a7467714a79b36729389713e314 2 f8b3eee68d3f417fb4b3d07fa9ce0419 RY(theta\u2084) e7d96c1d1aa34a74a4e666ec9a8d1e75--f8b3eee68d3f417fb4b3d07fa9ce0419 231c04e89bb446db8f67becd51a3c45e RX(theta\u2087) f8b3eee68d3f417fb4b3d07fa9ce0419--231c04e89bb446db8f67becd51a3c45e 72490701118442c0ab17b80f57fef758 t = theta_t\u2080 231c04e89bb446db8f67becd51a3c45e--72490701118442c0ab17b80f57fef758 c4a037c6ae0446d2acf3916039c59d1a RX(theta\u2081\u2080) 72490701118442c0ab17b80f57fef758--c4a037c6ae0446d2acf3916039c59d1a beea4477ab264840a08c6c917f6abe36 RY(theta\u2081\u2083) c4a037c6ae0446d2acf3916039c59d1a--beea4477ab264840a08c6c917f6abe36 668274852c9043e298f5fdbfb73de409 RX(theta\u2081\u2086) beea4477ab264840a08c6c917f6abe36--668274852c9043e298f5fdbfb73de409 e614bfe1179f491b921f9b58cfd866ee t = theta_t\u2081 668274852c9043e298f5fdbfb73de409--e614bfe1179f491b921f9b58cfd866ee e614bfe1179f491b921f9b58cfd866ee--d7be3d7660974a42882ef3c19f3bdba1 d0a97d9498f7438a87297732092b6d12 b3859460a7444dd5bf975321e1613ce2 RX(theta\u2082) 72248a7467714a79b36729389713e314--b3859460a7444dd5bf975321e1613ce2 065f82010e1445a1814613a2b1cd7d52 RY(theta\u2085) b3859460a7444dd5bf975321e1613ce2--065f82010e1445a1814613a2b1cd7d52 8e16366656594bcc93ded30014ccb076 RX(theta\u2088) 065f82010e1445a1814613a2b1cd7d52--8e16366656594bcc93ded30014ccb076 d2831d27ee5844aaba7d0e2d140435ef 8e16366656594bcc93ded30014ccb076--d2831d27ee5844aaba7d0e2d140435ef 46cf5dc644b74f17b40885fcc6f72b89 RX(theta\u2081\u2081) d2831d27ee5844aaba7d0e2d140435ef--46cf5dc644b74f17b40885fcc6f72b89 fc93d4d75a8343a0a9f863827e02f683 RY(theta\u2081\u2084) 46cf5dc644b74f17b40885fcc6f72b89--fc93d4d75a8343a0a9f863827e02f683 306099cf8b4444099532f18113cbcbd7 RX(theta\u2081\u2087) fc93d4d75a8343a0a9f863827e02f683--306099cf8b4444099532f18113cbcbd7 725cd7853ad74bc6842df77e763a54d4 306099cf8b4444099532f18113cbcbd7--725cd7853ad74bc6842df77e763a54d4 725cd7853ad74bc6842df77e763a54d4--d0a97d9498f7438a87297732092b6d12 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_ac403d4f593548068c66b21ce045be86 cluster_9e2cd26f85be477f91c0e4b1cd9a2aee 1b97efb69b0c4bc6b59163a34a5b6803 0 eb021d941d9441fab869a65078e47574 RX(theta\u2080) 1b97efb69b0c4bc6b59163a34a5b6803--eb021d941d9441fab869a65078e47574 6d0765a820104ca083e1d55f1beea72c 1 72f222e771504ab1a2ac4aba9bdefa41 RY(theta\u2086) eb021d941d9441fab869a65078e47574--72f222e771504ab1a2ac4aba9bdefa41 6d44acaa77214edfad721e7c2349b062 RX(theta\u2081\u2082) 72f222e771504ab1a2ac4aba9bdefa41--6d44acaa77214edfad721e7c2349b062 37f4e2f73a3a4a449178914b9a740355 6d44acaa77214edfad721e7c2349b062--37f4e2f73a3a4a449178914b9a740355 b6ae5b126bd34d9aa49fcccb615e567c RX(theta\u2081\u2088) 37f4e2f73a3a4a449178914b9a740355--b6ae5b126bd34d9aa49fcccb615e567c 4095ed890c314c77bcd82313dc80fd3c RY(theta\u2082\u2084) b6ae5b126bd34d9aa49fcccb615e567c--4095ed890c314c77bcd82313dc80fd3c 85022dd479374ce28e668d1b79e70e1b RX(theta\u2083\u2080) 4095ed890c314c77bcd82313dc80fd3c--85022dd479374ce28e668d1b79e70e1b 6fc72a748feb44c7b9dac16c75a1bb0a 85022dd479374ce28e668d1b79e70e1b--6fc72a748feb44c7b9dac16c75a1bb0a 19b2e84865654521a11c47df22d9f280 6fc72a748feb44c7b9dac16c75a1bb0a--19b2e84865654521a11c47df22d9f280 af8dc6e651374fda90b52aedfe6098c1 6a67487420e4438c980e12c1f4a0f4f0 RX(theta\u2081) 6d0765a820104ca083e1d55f1beea72c--6a67487420e4438c980e12c1f4a0f4f0 e4e1fc916fe645738495bc9ad2e40aca 2 fc1a18f7c9b24944a74ff614026c57c6 RY(theta\u2087) 6a67487420e4438c980e12c1f4a0f4f0--fc1a18f7c9b24944a74ff614026c57c6 213682f710424e079666bf5a00c21078 RX(theta\u2081\u2083) fc1a18f7c9b24944a74ff614026c57c6--213682f710424e079666bf5a00c21078 22b7a1b6eeca480786d173eeff111559 213682f710424e079666bf5a00c21078--22b7a1b6eeca480786d173eeff111559 9b7d9188d4d9417693f60c889ac7bbf8 RX(theta\u2081\u2089) 22b7a1b6eeca480786d173eeff111559--9b7d9188d4d9417693f60c889ac7bbf8 c08adbd416954441ada6dd899adc9a6b RY(theta\u2082\u2085) 9b7d9188d4d9417693f60c889ac7bbf8--c08adbd416954441ada6dd899adc9a6b 79229a5405ed4600a95068fefa704e7b RX(theta\u2083\u2081) c08adbd416954441ada6dd899adc9a6b--79229a5405ed4600a95068fefa704e7b 5c34db55132d4749844d937cc6244c61 79229a5405ed4600a95068fefa704e7b--5c34db55132d4749844d937cc6244c61 5c34db55132d4749844d937cc6244c61--af8dc6e651374fda90b52aedfe6098c1 0fd8e1c6d8d3453b844dc939ac4ae2dd 90e79083361742aaa1f820a4ef950e78 RX(theta\u2082) e4e1fc916fe645738495bc9ad2e40aca--90e79083361742aaa1f820a4ef950e78 b2234ad3e7de47a68e8b4a29b0224642 3 29a67e15b6a14da6a542748d92990c2d RY(theta\u2088) 90e79083361742aaa1f820a4ef950e78--29a67e15b6a14da6a542748d92990c2d 47bc3875ac7245a7b4a177b5101a1b48 RX(theta\u2081\u2084) 29a67e15b6a14da6a542748d92990c2d--47bc3875ac7245a7b4a177b5101a1b48 e605c3452c8e4ab09971ce75c5615127 HamEvo 47bc3875ac7245a7b4a177b5101a1b48--e605c3452c8e4ab09971ce75c5615127 5907b2396afa4d41a1b54794aef8cf6e RX(theta\u2082\u2080) e605c3452c8e4ab09971ce75c5615127--5907b2396afa4d41a1b54794aef8cf6e 49e4418a9fd3460dbcba576854f9b7c8 RY(theta\u2082\u2086) 5907b2396afa4d41a1b54794aef8cf6e--49e4418a9fd3460dbcba576854f9b7c8 8757a8de26064853a7d01e44d3854376 RX(theta\u2083\u2082) 49e4418a9fd3460dbcba576854f9b7c8--8757a8de26064853a7d01e44d3854376 2229cb3d39ac47a0957fb56d7c6289d1 HamEvo 8757a8de26064853a7d01e44d3854376--2229cb3d39ac47a0957fb56d7c6289d1 2229cb3d39ac47a0957fb56d7c6289d1--0fd8e1c6d8d3453b844dc939ac4ae2dd 650b36a286d9426bb4c668251d86404c 9dc4e6ee8b1a4a68ad76e17a1e10b3d5 RX(theta\u2083) b2234ad3e7de47a68e8b4a29b0224642--9dc4e6ee8b1a4a68ad76e17a1e10b3d5 97232596aafb40dfb21b86db8d83fec4 4 69f2645a95f442b8908c674df19bcbb7 RY(theta\u2089) 9dc4e6ee8b1a4a68ad76e17a1e10b3d5--69f2645a95f442b8908c674df19bcbb7 7176fab096a34ef784a1a1c8c9c881f9 RX(theta\u2081\u2085) 69f2645a95f442b8908c674df19bcbb7--7176fab096a34ef784a1a1c8c9c881f9 4ba35d83278741488d2ec9bf0d5c90e5 t = theta_t\u2080 7176fab096a34ef784a1a1c8c9c881f9--4ba35d83278741488d2ec9bf0d5c90e5 29a3b4c5ee9f48c4b6ccba25133446f5 RX(theta\u2082\u2081) 4ba35d83278741488d2ec9bf0d5c90e5--29a3b4c5ee9f48c4b6ccba25133446f5 09e2718e53644de38bdc028e5eed245b RY(theta\u2082\u2087) 29a3b4c5ee9f48c4b6ccba25133446f5--09e2718e53644de38bdc028e5eed245b b8bc28fe60b741ef90cecf7fad8e57b3 RX(theta\u2083\u2083) 09e2718e53644de38bdc028e5eed245b--b8bc28fe60b741ef90cecf7fad8e57b3 c03c6172c7a447baa4afb28655fe81c9 t = theta_t\u2081 b8bc28fe60b741ef90cecf7fad8e57b3--c03c6172c7a447baa4afb28655fe81c9 c03c6172c7a447baa4afb28655fe81c9--650b36a286d9426bb4c668251d86404c ad12b641cc7947eca728d4b68bff4d66 01b839853f8d47b58a69c2d6349673cd RX(theta\u2084) 97232596aafb40dfb21b86db8d83fec4--01b839853f8d47b58a69c2d6349673cd ff9f695c780c453d9b580b31b5d53319 5 85f703ce043c406cac932b748ca5f57c RY(theta\u2081\u2080) 01b839853f8d47b58a69c2d6349673cd--85f703ce043c406cac932b748ca5f57c 79e85f1035284dea84e9a758071d7013 RX(theta\u2081\u2086) 85f703ce043c406cac932b748ca5f57c--79e85f1035284dea84e9a758071d7013 38688f2d16cc41fbbd1832e2c38db87b 79e85f1035284dea84e9a758071d7013--38688f2d16cc41fbbd1832e2c38db87b 93b172843a2e4878892ce8689e8ec135 RX(theta\u2082\u2082) 38688f2d16cc41fbbd1832e2c38db87b--93b172843a2e4878892ce8689e8ec135 76936e4356dc40b9835863dd90ce8b77 RY(theta\u2082\u2088) 93b172843a2e4878892ce8689e8ec135--76936e4356dc40b9835863dd90ce8b77 b5ae20952f3f41c29679a12ef993c677 RX(theta\u2083\u2084) 76936e4356dc40b9835863dd90ce8b77--b5ae20952f3f41c29679a12ef993c677 3beeb6160b674decaaa9e98606db9326 b5ae20952f3f41c29679a12ef993c677--3beeb6160b674decaaa9e98606db9326 3beeb6160b674decaaa9e98606db9326--ad12b641cc7947eca728d4b68bff4d66 66b41b8916d94795bee3f9fb1528fff6 d969ad1f918a4693bd8598fc473317ba RX(theta\u2085) ff9f695c780c453d9b580b31b5d53319--d969ad1f918a4693bd8598fc473317ba 73f05ab42c604be88c1f56dd347defb7 RY(theta\u2081\u2081) d969ad1f918a4693bd8598fc473317ba--73f05ab42c604be88c1f56dd347defb7 9623054ec3ac4e13923abef75f5ea744 RX(theta\u2081\u2087) 73f05ab42c604be88c1f56dd347defb7--9623054ec3ac4e13923abef75f5ea744 f6b72d1310a74d9a804bcbacd7c5d6c4 9623054ec3ac4e13923abef75f5ea744--f6b72d1310a74d9a804bcbacd7c5d6c4 e40ca65fe9a44441907c7a6e60af7ef9 RX(theta\u2082\u2083) f6b72d1310a74d9a804bcbacd7c5d6c4--e40ca65fe9a44441907c7a6e60af7ef9 4edc46530a47479a9b5290693341e781 RY(theta\u2082\u2089) e40ca65fe9a44441907c7a6e60af7ef9--4edc46530a47479a9b5290693341e781 b284abdf2ca9469fb148dd4423c398dc RX(theta\u2083\u2085) 4edc46530a47479a9b5290693341e781--b284abdf2ca9469fb148dd4423c398dc 775706d1042a44f7a4fda33244edce4f b284abdf2ca9469fb148dd4423c398dc--775706d1042a44f7a4fda33244edce4f 775706d1042a44f7a4fda33244edce4f--66b41b8916d94795bee3f9fb1528fff6"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 61a02f87-5777-4829-a62f-f71d245bf94d, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': c3c75cb8-297e-4a26-b2ec-bc08a97610e4, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 23c6d852-29bf-4ace-82b7-b27e161008ea, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 6405d3ec-d8d9-408d-a8b8-56a4387d9a44, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': e3cae9c3-a343-42d9-b65c-7cd9345967b9, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': b7bfbde5-b65d-444d-af3c-3cd04579f5b7, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': b15e64e4-9f49-4440-99a4-32ed777221c7, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': c2b3e290-3c21-43e0-96cb-57c27a9bea89, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ff5df7e0-1179-4433-b5ff-2fa970424e7c, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': cb9d4d78-ad19-4e17-aea2-4eb4a638783d, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 92ef9029-5fec-4155-b2b0-47915fe30d17, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_1: tensor([0.2035], requires_grad=True)\ntheta_6: tensor([0.7306], requires_grad=True)\ntheta_3: tensor([0.0577], requires_grad=True)\ntheta_5: tensor([0.3965], requires_grad=True)\ntheta_0: tensor([0.8941], requires_grad=True)\ntheta_4: tensor([0.9744], requires_grad=True)\ntheta_2: tensor([0.0558], requires_grad=True)\ntheta_7: tensor([0.6091], requires_grad=True)\ntheta_8: tensor([0.2952], requires_grad=True)\n}\nembedded = {\n61a02f87-5777-4829-a62f-f71d245bf94d: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\nc3c75cb8-297e-4a26-b2ec-bc08a97610e4: tensor([2., 2.])\n23c6d852-29bf-4ace-82b7-b27e161008ea: tensor([0.8941], grad_fn=&lt;ViewBackward0&gt;)\n6405d3ec-d8d9-408d-a8b8-56a4387d9a44: tensor([0.2035], grad_fn=&lt;ViewBackward0&gt;)\ne3cae9c3-a343-42d9-b65c-7cd9345967b9: tensor([0.0558], grad_fn=&lt;ViewBackward0&gt;)\nb7bfbde5-b65d-444d-af3c-3cd04579f5b7: tensor([0.0577], grad_fn=&lt;ViewBackward0&gt;)\nb15e64e4-9f49-4440-99a4-32ed777221c7: tensor([0.9744], grad_fn=&lt;ViewBackward0&gt;)\nc2b3e290-3c21-43e0-96cb-57c27a9bea89: tensor([0.3965], grad_fn=&lt;ViewBackward0&gt;)\nff5df7e0-1179-4433-b5ff-2fa970424e7c: tensor([0.7306], grad_fn=&lt;ViewBackward0&gt;)\ncb9d4d78-ad19-4e17-aea2-4eb4a638783d: tensor([0.6091], grad_fn=&lt;ViewBackward0&gt;)\n92ef9029-5fec-4155-b2b0-47915fe30d17: tensor([0.2952], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_6: tensor([0.7306], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.2035], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.0577], grad_fn=&lt;ViewBackward0&gt;)\ntheta_5: tensor([0.3965], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.8941], grad_fn=&lt;ViewBackward0&gt;)\ntheta_4: tensor([0.9744], grad_fn=&lt;ViewBackward0&gt;)\ntheta_2: tensor([0.0558], grad_fn=&lt;ViewBackward0&gt;)\ntheta_7: tensor([0.6091], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_8: tensor([0.2952], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.3854-0.1967j,  0.0458-0.1071j,  0.0059+0.1483j, -0.3360+0.4374j,\n-0.4565-0.3294j, -0.1511+0.0105j,  0.0796+0.0516j,  0.1044+0.3365j],\n[ 0.3854-0.1967j,  0.0458-0.1071j,  0.0059+0.1483j, -0.3360+0.4374j,\n-0.4565-0.3294j, -0.1511+0.0105j,  0.0796+0.0516j,  0.1044+0.3365j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'100': 184, '000': 183, '011': 182, '111': 136, '010': 85, '110': 80, '101': 77, '001': 73})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(61a02f87-5777-4829-a62f-f71d245bf94d)-C----------------------------------------Rx(23c6d852-29bf-4ace-82b7-b27e161008ea)-Ry(b7bfbde5-b65d-444d-af3c-3cd04579f5b7)-Rx(ff5df7e0-1179-4433-b5ff-2fa970424e7c)-C---\n|                                                                                                                                                                   |   q1 : -Rz(c3c75cb8-297e-4a26-b2ec-bc08a97610e4)-X----------------------------------------Rx(6405d3ec-d8d9-408d-a8b8-56a4387d9a44)-Ry(b15e64e4-9f49-4440-99a4-32ed777221c7)-Rx(cb9d4d78-ad19-4e17-aea2-4eb4a638783d)-X-C-\n| q2 : -Rx(e3cae9c3-a343-42d9-b65c-7cd9345967b9)-Ry(c2b3e290-3c21-43e0-96cb-57c27a9bea89)-Rx(92ef9029-5fec-4155-b2b0-47915fe30d17)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [23c6d852-29bf-4ace-82b7-b27e161008ea, 61a02f87-5777-4829-a62f-f71d245bf94d, 6405d3ec-d8d9-408d-a8b8-56a4387d9a44, 92ef9029-5fec-4155-b2b0-47915fe30d17, b15e64e4-9f49-4440-99a4-32ed777221c7, b7bfbde5-b65d-444d-af3c-3cd04579f5b7, c2b3e290-3c21-43e0-96cb-57c27a9bea89, c3c75cb8-297e-4a26-b2ec-bc08a97610e4, cb9d4d78-ad19-4e17-aea2-4eb4a638783d, e3cae9c3-a343-42d9-b65c-7cd9345967b9, ff5df7e0-1179-4433-b5ff-2fa970424e7c].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(2.81)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.89)-DEPO(0.1)-Ry(0.06)-DEPO(0.1)-Rx(0.73)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.45)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.20)-DEPO(0.1)-Ry(0.97)-DEPO(0.1)-Rx(0.61)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.06)-DEPO(0.1)-Ry(0.40)-DEPO(0.1)-Rx(0.30)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 cb04d3abc47941f29b9974566147995b 0 d4efb23addcb4155a096ed129690b29b X cb04d3abc47941f29b9974566147995b--d4efb23addcb4155a096ed129690b29b 4061badf9a98411b9290d4d363fdaaa6 1 41a0a392e9b2472099894cd3e7357cbe d4efb23addcb4155a096ed129690b29b--41a0a392e9b2472099894cd3e7357cbe 29025db6c53c4e70abff071f242df748 2d6d8f37955945ceb6a938b6986d1699 Y 4061badf9a98411b9290d4d363fdaaa6--2d6d8f37955945ceb6a938b6986d1699 2d6d8f37955945ceb6a938b6986d1699--29025db6c53c4e70abff071f242df748 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 709087a8db4542249b1a79e689fb7383 0 b8aaee1166da480b88c142d70f83230f RX(0.5) 709087a8db4542249b1a79e689fb7383--b8aaee1166da480b88c142d70f83230f 74b903e6e3264fc09aa4d7a828266373 b8aaee1166da480b88c142d70f83230f--74b903e6e3264fc09aa4d7a828266373 <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 e5d3f2c5c0124e2bb8951dad91c2182c 0 d40ff151b4904adabded1d5e1406c0b8 e5d3f2c5c0124e2bb8951dad91c2182c--d40ff151b4904adabded1d5e1406c0b8 be90977e5676434e8fef9e3800c93bab 1 8b2df78552d24aad942f3aa719c97898 d40ff151b4904adabded1d5e1406c0b8--8b2df78552d24aad942f3aa719c97898 081f6825034748d99c506432a56552ee 79d3792f9eeb40bbab415b40ce44a914 X be90977e5676434e8fef9e3800c93bab--79d3792f9eeb40bbab415b40ce44a914 79d3792f9eeb40bbab415b40ce44a914--d40ff151b4904adabded1d5e1406c0b8 79d3792f9eeb40bbab415b40ce44a914--081f6825034748d99c506432a56552ee <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 d9f9506f7bc14709925fc7740187d0ec 0 580c8eea9cf24609b33d72bb2baaacb3 X d9f9506f7bc14709925fc7740187d0ec--580c8eea9cf24609b33d72bb2baaacb3 f9b6fa8dd94c4153bf361d609f23c086 X 580c8eea9cf24609b33d72bb2baaacb3--f9b6fa8dd94c4153bf361d609f23c086 01de1ef67ef8469aa1316917f2402b75 f9b6fa8dd94c4153bf361d609f23c086--01de1ef67ef8469aa1316917f2402b75 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 56ff2c85a6fd4bfbace20b412aa6d5f6 0 92c2d1c71b6e41928079bb831d685cb0 X 56ff2c85a6fd4bfbace20b412aa6d5f6--92c2d1c71b6e41928079bb831d685cb0 679a2fb83140491aaa0a1c0af8e0e4e5 1 7ed7af06b5314427a8a18a9e7ddb9cd9 92c2d1c71b6e41928079bb831d685cb0--7ed7af06b5314427a8a18a9e7ddb9cd9 c8d9b965d672494487af1bb023189a88 7ed7af06b5314427a8a18a9e7ddb9cd9--c8d9b965d672494487af1bb023189a88 5a4ace73f0544b93bf2e56fce337380f 88c9f337d2cd4482a17d543f92cbdf0f 679a2fb83140491aaa0a1c0af8e0e4e5--88c9f337d2cd4482a17d543f92cbdf0f 8882ba44990c437e87768d5316d9c424 X 88c9f337d2cd4482a17d543f92cbdf0f--8882ba44990c437e87768d5316d9c424 8882ba44990c437e87768d5316d9c424--5a4ace73f0544b93bf2e56fce337380f </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 2e5a827019d847ea8c16611b5e3543b2 0 60fc0e8344db4697aa999e5b474e8624 X 2e5a827019d847ea8c16611b5e3543b2--60fc0e8344db4697aa999e5b474e8624 209ec6ef619d42c58d1ef7f610ee95f2 1 13f4667bbb9148ed99dd5d94aff84066 60fc0e8344db4697aa999e5b474e8624--13f4667bbb9148ed99dd5d94aff84066 f460d81b27274ee593601b148fce6d58 10a16a78c3a7490dba9877ec5ccab847 X 209ec6ef619d42c58d1ef7f610ee95f2--10a16a78c3a7490dba9877ec5ccab847 10a16a78c3a7490dba9877ec5ccab847--f460d81b27274ee593601b148fce6d58 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_7717bdd1f8164e38b01b3549e0f1ca69 subblock cluster_bbf70e4aa067470b94267dc85ffbcc88 subblock 873325dfce0643999863f752716c2e7b 0 78431007ab4b4641810a8c93598f97c9 X 873325dfce0643999863f752716c2e7b--78431007ab4b4641810a8c93598f97c9 339885b0d46c46b88dced994701ae4ad 1 a889129398a14a28939bd70aadfd502e X 78431007ab4b4641810a8c93598f97c9--a889129398a14a28939bd70aadfd502e c8294c6a12884bd5a3be6d1670ca016e a889129398a14a28939bd70aadfd502e--c8294c6a12884bd5a3be6d1670ca016e f3e9728231444fcba5ed3a2caace87d9 595cf708c27849fe926b9babee5ba424 Y 339885b0d46c46b88dced994701ae4ad--595cf708c27849fe926b9babee5ba424 9f764e8548a141b28b804bc7a0eeb425 2 be883be41c1a4264900b3cc153b1af20 Y 595cf708c27849fe926b9babee5ba424--be883be41c1a4264900b3cc153b1af20 be883be41c1a4264900b3cc153b1af20--f3e9728231444fcba5ed3a2caace87d9 ec3ff8b6e4d04bcfaa620008b31f0c9a b93275bf43ed4c228d3e79de358af2ad 9f764e8548a141b28b804bc7a0eeb425--b93275bf43ed4c228d3e79de358af2ad 840646dd90e545a888eeaba9bf76eeeb 3 e73ab4b56dae41298640bc6f95271582 b93275bf43ed4c228d3e79de358af2ad--e73ab4b56dae41298640bc6f95271582 e73ab4b56dae41298640bc6f95271582--ec3ff8b6e4d04bcfaa620008b31f0c9a 24586bfca64d40fbae3d363465feaee6 deeaf964dd4645f0bacd7a347ae336d7 840646dd90e545a888eeaba9bf76eeeb--deeaf964dd4645f0bacd7a347ae336d7 c57a6eec72c64952bf88d678c61084f8 4 040e5ba6e87144838632e3e874e0fe44 deeaf964dd4645f0bacd7a347ae336d7--040e5ba6e87144838632e3e874e0fe44 040e5ba6e87144838632e3e874e0fe44--24586bfca64d40fbae3d363465feaee6 22bbc7b8e7c6497080a31daa8b9add47 90d0236bc86f44a0bbdac09dc562b118 X c57a6eec72c64952bf88d678c61084f8--90d0236bc86f44a0bbdac09dc562b118 90d0236bc86f44a0bbdac09dc562b118--deeaf964dd4645f0bacd7a347ae336d7 7a14c6d816fc4433b4f8137528ff2bf7 X 90d0236bc86f44a0bbdac09dc562b118--7a14c6d816fc4433b4f8137528ff2bf7 7a14c6d816fc4433b4f8137528ff2bf7--040e5ba6e87144838632e3e874e0fe44 7a14c6d816fc4433b4f8137528ff2bf7--22bbc7b8e7c6497080a31daa8b9add47"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'00': 271, '10': 252, '01': 244, '11': 233})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'100': 30, '110': 25, '000': 24, '010': 21})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[ 2.5000e-01, -3.3307e-16],\n[-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2524, -0.0104],\n[ 0.0020,  0.0012]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9903+0.0000j, 0.0000-0.1388j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8950+0.0000j, 0.0000-0.4460j],\n[0.9960+0.0000j, 0.0000-0.0893j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.7308+0.0000j, 0.6788+0.0000j, 0.0000-0.0523j, 0.0000-0.0486j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_9aa7e5cbc3c442c7a073b572eb4d4460 [* 2] cluster_378cf4964662445f837893df4790c1fb Rotations df84abf7f0f94f98a91c407ac2c39b17 0 3bcd7ebc1d024ecbbbee121b6ea10bda RX(phi/theta) df84abf7f0f94f98a91c407ac2c39b17--3bcd7ebc1d024ecbbbee121b6ea10bda f3ce1eb1046e47668a5a94fd07a53c77 1 67b4fbdb84c547cfb2e54a43aa103a8c RX(phi) 3bcd7ebc1d024ecbbbee121b6ea10bda--67b4fbdb84c547cfb2e54a43aa103a8c 0470deebc089482ea8c214ddb60ee1d5 RX(phi) 67b4fbdb84c547cfb2e54a43aa103a8c--0470deebc089482ea8c214ddb60ee1d5 375485c6f9cb4b489b5fe9869f4bbf3d RX(phi + theta) 0470deebc089482ea8c214ddb60ee1d5--375485c6f9cb4b489b5fe9869f4bbf3d 02280914d36240a899d1cbad7fd7134c 375485c6f9cb4b489b5fe9869f4bbf3d--02280914d36240a899d1cbad7fd7134c 0aa3dc67ed7144329bbeac0d443cd8f8 02280914d36240a899d1cbad7fd7134c--0aa3dc67ed7144329bbeac0d443cd8f8 9d97e180fb504a7b8293da97e9986c38 Z 0aa3dc67ed7144329bbeac0d443cd8f8--9d97e180fb504a7b8293da97e9986c38 c363e1fa79b24f1cb2cce61fc2f567fc 9d97e180fb504a7b8293da97e9986c38--c363e1fa79b24f1cb2cce61fc2f567fc 040ddf7e4e1340d694c39ae3fddfe589 96fb2fc5cc3949c5966800dff5ed7a63 RY(2*theta) f3ce1eb1046e47668a5a94fd07a53c77--96fb2fc5cc3949c5966800dff5ed7a63 dd4215f55c9640e0b534c19fe7af3355 2 8907a0d298ba432fb77817a1dd7ce662 RY(theta) 96fb2fc5cc3949c5966800dff5ed7a63--8907a0d298ba432fb77817a1dd7ce662 a8774afdadd94ecb910546254ec9fb65 RY(theta) 8907a0d298ba432fb77817a1dd7ce662--a8774afdadd94ecb910546254ec9fb65 d575ba7ddf0f4695a78ba0c40edaa24a RY(theta**2) a8774afdadd94ecb910546254ec9fb65--d575ba7ddf0f4695a78ba0c40edaa24a 8fbaccfd34cb49c194645ccf9b3a9365 X d575ba7ddf0f4695a78ba0c40edaa24a--8fbaccfd34cb49c194645ccf9b3a9365 8fbaccfd34cb49c194645ccf9b3a9365--02280914d36240a899d1cbad7fd7134c ac9a4f86fefd49f1a24ab2ddffe284f2 8fbaccfd34cb49c194645ccf9b3a9365--ac9a4f86fefd49f1a24ab2ddffe284f2 3fb6e1422f814c6e8726e046712d04a5 Z ac9a4f86fefd49f1a24ab2ddffe284f2--3fb6e1422f814c6e8726e046712d04a5 3fb6e1422f814c6e8726e046712d04a5--040ddf7e4e1340d694c39ae3fddfe589 9ce444796cbe4bdaadc43862f8e706ff 328ce74e0f30427e868f8a359f3f2b18 RZ(cos(phi)) dd4215f55c9640e0b534c19fe7af3355--328ce74e0f30427e868f8a359f3f2b18 e8249fc78bbe473ba2b9852f8334e69d RZ(phi) 328ce74e0f30427e868f8a359f3f2b18--e8249fc78bbe473ba2b9852f8334e69d d2bc140fa4f24948a624a1fbdeaa824e RZ(phi) e8249fc78bbe473ba2b9852f8334e69d--d2bc140fa4f24948a624a1fbdeaa824e 686821479795441eb23b8975470a3cfa RZ(cos(phi)) d2bc140fa4f24948a624a1fbdeaa824e--686821479795441eb23b8975470a3cfa 88ac8214e5a445e790a4826f2aa1c6a6 686821479795441eb23b8975470a3cfa--88ac8214e5a445e790a4826f2aa1c6a6 3e90e5c90ae141af860831558ca34ef8 X 88ac8214e5a445e790a4826f2aa1c6a6--3e90e5c90ae141af860831558ca34ef8 3e90e5c90ae141af860831558ca34ef8--ac9a4f86fefd49f1a24ab2ddffe284f2 c72d7dcd0960404d8a79d7e67ac62052 Z 3e90e5c90ae141af860831558ca34ef8--c72d7dcd0960404d8a79d7e67ac62052 c72d7dcd0960404d8a79d7e67ac62052--9ce444796cbe4bdaadc43862f8e706ff <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.1479]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9868+0.0000j, 0.1142+0.0000j, 0.0000-0.1142j, 0.0000-0.0132j],\n[0.9047+0.0000j, 0.2937+0.0000j, 0.0000-0.2937j, 0.0000-0.0953j],\n[0.8202+0.0000j, 0.3840+0.0000j, 0.0000-0.3840j, 0.0000-0.1798j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 dc76db6ec219418686f3e9f833d769cb 0 1f2dc5ae6446455a89777a345c54d4a5 RX(theta\u2080) dc76db6ec219418686f3e9f833d769cb--1f2dc5ae6446455a89777a345c54d4a5 bbd409c1550a4ad9bc5e091dd2359159 1 477fb21f31ec4eb18bdb7694a61043a9 RY(theta\u2084) 1f2dc5ae6446455a89777a345c54d4a5--477fb21f31ec4eb18bdb7694a61043a9 1abc1d3bdc9b4962960bda5db8eb4f39 RX(theta\u2088) 477fb21f31ec4eb18bdb7694a61043a9--1abc1d3bdc9b4962960bda5db8eb4f39 6805df645eb0496aa795460abdee85da 1abc1d3bdc9b4962960bda5db8eb4f39--6805df645eb0496aa795460abdee85da f5c96a57c6a445c5a9cedb7ef55d489e 6805df645eb0496aa795460abdee85da--f5c96a57c6a445c5a9cedb7ef55d489e 06afcb57155247f786278c50145f8199 RX(theta\u2081\u2082) f5c96a57c6a445c5a9cedb7ef55d489e--06afcb57155247f786278c50145f8199 0babb7438a5c46a38235d8f4b4ae7849 RY(theta\u2081\u2086) 06afcb57155247f786278c50145f8199--0babb7438a5c46a38235d8f4b4ae7849 7179fd6275e44db38604b5d8fca32325 RX(theta\u2082\u2080) 0babb7438a5c46a38235d8f4b4ae7849--7179fd6275e44db38604b5d8fca32325 ea035ba6ea244169842642d8282c65da 7179fd6275e44db38604b5d8fca32325--ea035ba6ea244169842642d8282c65da b2102d1979894277b1619d3981c2ab93 ea035ba6ea244169842642d8282c65da--b2102d1979894277b1619d3981c2ab93 a29437c70e9741e59cf0bd2d499be90a b2102d1979894277b1619d3981c2ab93--a29437c70e9741e59cf0bd2d499be90a 6ae2eeb7f1154c008af032a449d93306 aa4626b57c2349919d8347e6f9c7e324 RX(theta\u2081) bbd409c1550a4ad9bc5e091dd2359159--aa4626b57c2349919d8347e6f9c7e324 49b1760fb51d41eda1c5ebc66bd68107 2 94c1d3107c5e4932bf3b6e7c039d640e RY(theta\u2085) aa4626b57c2349919d8347e6f9c7e324--94c1d3107c5e4932bf3b6e7c039d640e 89787966ab344e22950e6b10c1cd0c9a RX(theta\u2089) 94c1d3107c5e4932bf3b6e7c039d640e--89787966ab344e22950e6b10c1cd0c9a 1ed2686395254075aa3e4d64c75579d9 X 89787966ab344e22950e6b10c1cd0c9a--1ed2686395254075aa3e4d64c75579d9 1ed2686395254075aa3e4d64c75579d9--6805df645eb0496aa795460abdee85da f89a73b6d9974ee3a450cba53158e144 1ed2686395254075aa3e4d64c75579d9--f89a73b6d9974ee3a450cba53158e144 13badfda85b24f7a9b918d660f150e23 RX(theta\u2081\u2083) f89a73b6d9974ee3a450cba53158e144--13badfda85b24f7a9b918d660f150e23 7c8f1e24ee4040c3b5695cb1c0b12009 RY(theta\u2081\u2087) 13badfda85b24f7a9b918d660f150e23--7c8f1e24ee4040c3b5695cb1c0b12009 a65015a6ccda4ae9b486c53627212853 RX(theta\u2082\u2081) 7c8f1e24ee4040c3b5695cb1c0b12009--a65015a6ccda4ae9b486c53627212853 fa3f20b7c6f44c61bd882bde9914727a X a65015a6ccda4ae9b486c53627212853--fa3f20b7c6f44c61bd882bde9914727a fa3f20b7c6f44c61bd882bde9914727a--ea035ba6ea244169842642d8282c65da d891f339b84f4164abe5dc646b519dd2 fa3f20b7c6f44c61bd882bde9914727a--d891f339b84f4164abe5dc646b519dd2 d891f339b84f4164abe5dc646b519dd2--6ae2eeb7f1154c008af032a449d93306 74de9b235ed745d2b6cbf11a72e00aec 02665a1dbc1b46128291a9a390f54d09 RX(theta\u2082) 49b1760fb51d41eda1c5ebc66bd68107--02665a1dbc1b46128291a9a390f54d09 5b0f4a43bd974782a8a6834760d5ac78 3 b2d007ce917842f987c4a5d7ff1f6384 RY(theta\u2086) 02665a1dbc1b46128291a9a390f54d09--b2d007ce917842f987c4a5d7ff1f6384 02ebf66f29594d0491f45c845c1e4693 RX(theta\u2081\u2080) b2d007ce917842f987c4a5d7ff1f6384--02ebf66f29594d0491f45c845c1e4693 71ca3745c0dd4fdf84b5f0f75e21813d 02ebf66f29594d0491f45c845c1e4693--71ca3745c0dd4fdf84b5f0f75e21813d 41bbd6c180404139b929e207576baecc X 71ca3745c0dd4fdf84b5f0f75e21813d--41bbd6c180404139b929e207576baecc 41bbd6c180404139b929e207576baecc--f89a73b6d9974ee3a450cba53158e144 61e897850d9849d9b0a8e154ad4ba4c5 RX(theta\u2081\u2084) 41bbd6c180404139b929e207576baecc--61e897850d9849d9b0a8e154ad4ba4c5 9a2559c306514473b3db95b370a6e47f RY(theta\u2081\u2088) 61e897850d9849d9b0a8e154ad4ba4c5--9a2559c306514473b3db95b370a6e47f 3efde368b5074cebaa5dcab70f35b689 RX(theta\u2082\u2082) 9a2559c306514473b3db95b370a6e47f--3efde368b5074cebaa5dcab70f35b689 6890a6d9dce24ec78eb520c6e2adcbf9 3efde368b5074cebaa5dcab70f35b689--6890a6d9dce24ec78eb520c6e2adcbf9 4c34ae869d744aa5803c7e1af0a1b705 X 6890a6d9dce24ec78eb520c6e2adcbf9--4c34ae869d744aa5803c7e1af0a1b705 4c34ae869d744aa5803c7e1af0a1b705--d891f339b84f4164abe5dc646b519dd2 4c34ae869d744aa5803c7e1af0a1b705--74de9b235ed745d2b6cbf11a72e00aec 9bdcd00b86e54819b825980995360708 4879fd281ae647b29c1410ef437258a0 RX(theta\u2083) 5b0f4a43bd974782a8a6834760d5ac78--4879fd281ae647b29c1410ef437258a0 c7a749163cca44bc9ed6da029c79ef06 RY(theta\u2087) 4879fd281ae647b29c1410ef437258a0--c7a749163cca44bc9ed6da029c79ef06 77580ecc7fe64375b8765e667b158b22 RX(theta\u2081\u2081) c7a749163cca44bc9ed6da029c79ef06--77580ecc7fe64375b8765e667b158b22 7b6f31215c614cc0b4612490f7940ab7 X 77580ecc7fe64375b8765e667b158b22--7b6f31215c614cc0b4612490f7940ab7 7b6f31215c614cc0b4612490f7940ab7--71ca3745c0dd4fdf84b5f0f75e21813d fd9f44905e164372aa9caf9b98ed6d48 7b6f31215c614cc0b4612490f7940ab7--fd9f44905e164372aa9caf9b98ed6d48 d53bc3fa8d9b4e5da5604ab6ef2bf798 RX(theta\u2081\u2085) fd9f44905e164372aa9caf9b98ed6d48--d53bc3fa8d9b4e5da5604ab6ef2bf798 c9addcb944f247df8aaa35c6fc25b485 RY(theta\u2081\u2089) d53bc3fa8d9b4e5da5604ab6ef2bf798--c9addcb944f247df8aaa35c6fc25b485 09aeac1ce6af4c1ba9329bb66595a371 RX(theta\u2082\u2083) c9addcb944f247df8aaa35c6fc25b485--09aeac1ce6af4c1ba9329bb66595a371 56c95012005c4af3a124799baa3dde94 X 09aeac1ce6af4c1ba9329bb66595a371--56c95012005c4af3a124799baa3dde94 56c95012005c4af3a124799baa3dde94--6890a6d9dce24ec78eb520c6e2adcbf9 a7e3ff84458c4308a43db3baf193cf7a 56c95012005c4af3a124799baa3dde94--a7e3ff84458c4308a43db3baf193cf7a a7e3ff84458c4308a43db3baf193cf7a--9bdcd00b86e54819b825980995360708 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_053be443493843e48dc0b6cfa30978f0 HEA cluster_e9cdae40075b482292b72dab8ae51be3 HEA 8175c34943a9489482bfdec2094ab2e5 0 8cf4e0d7873b4cd1a4e80d4c1d685f1c RX(theta\u2080) 8175c34943a9489482bfdec2094ab2e5--8cf4e0d7873b4cd1a4e80d4c1d685f1c 50963c388a2d45a8a37195e9c44a23d5 1 b101c15148cf45aa821cbd77d9b9c998 RY(theta\u2084) 8cf4e0d7873b4cd1a4e80d4c1d685f1c--b101c15148cf45aa821cbd77d9b9c998 169f840298484012b376b339095432c5 RX(theta\u2088) b101c15148cf45aa821cbd77d9b9c998--169f840298484012b376b339095432c5 baf92e5b562a47888457cb36cd099779 169f840298484012b376b339095432c5--baf92e5b562a47888457cb36cd099779 50f29f299db64e35a8ee1039bd0a8d97 baf92e5b562a47888457cb36cd099779--50f29f299db64e35a8ee1039bd0a8d97 7fa428a83b38445b9b1972f88fae19d7 RX(theta\u2081\u2082) 50f29f299db64e35a8ee1039bd0a8d97--7fa428a83b38445b9b1972f88fae19d7 5df1ac861f2d4c9ca6d52c4ada80289b RY(theta\u2081\u2086) 7fa428a83b38445b9b1972f88fae19d7--5df1ac861f2d4c9ca6d52c4ada80289b d95291722ec842348962e1ddb1c2c741 RX(theta\u2082\u2080) 5df1ac861f2d4c9ca6d52c4ada80289b--d95291722ec842348962e1ddb1c2c741 00aa1646311a4c30871a130e270a7946 d95291722ec842348962e1ddb1c2c741--00aa1646311a4c30871a130e270a7946 7035ced06d3a41f095e0db7564a3217c 00aa1646311a4c30871a130e270a7946--7035ced06d3a41f095e0db7564a3217c 1ba92aae8e954e5f8c7ee654ed95d148 RX(theta\u2080) 7035ced06d3a41f095e0db7564a3217c--1ba92aae8e954e5f8c7ee654ed95d148 54469788c3f6493dab90acc74032dc59 RY(theta\u2084) 1ba92aae8e954e5f8c7ee654ed95d148--54469788c3f6493dab90acc74032dc59 ba4e1e4db60644fe82366b5d4c095785 RX(theta\u2088) 54469788c3f6493dab90acc74032dc59--ba4e1e4db60644fe82366b5d4c095785 27b1fdda4c274416a331d95dc6caedc0 ba4e1e4db60644fe82366b5d4c095785--27b1fdda4c274416a331d95dc6caedc0 c45b15a5f0d541c9bc11d86005d18d57 27b1fdda4c274416a331d95dc6caedc0--c45b15a5f0d541c9bc11d86005d18d57 a8e7ad2e48db4768be86b5be8498eeb7 RX(theta\u2081\u2082) c45b15a5f0d541c9bc11d86005d18d57--a8e7ad2e48db4768be86b5be8498eeb7 135921978d1d4c8d91d9490a3eb89241 RY(theta\u2081\u2086) a8e7ad2e48db4768be86b5be8498eeb7--135921978d1d4c8d91d9490a3eb89241 58eab06bd6054980ae049b809ca8a88b RX(theta\u2082\u2080) 135921978d1d4c8d91d9490a3eb89241--58eab06bd6054980ae049b809ca8a88b 1c14be7b28d24dda8040df74aef9c045 58eab06bd6054980ae049b809ca8a88b--1c14be7b28d24dda8040df74aef9c045 993f844c450f4f0f827df134f94037ce 1c14be7b28d24dda8040df74aef9c045--993f844c450f4f0f827df134f94037ce a0de7e0f9b464f0b87ec0b02784e070b 993f844c450f4f0f827df134f94037ce--a0de7e0f9b464f0b87ec0b02784e070b ed2c8bdbd6ac4f6cabeaaf28c72660ed 8824247294c04e77b82eb82f601ffe99 RX(theta\u2081) 50963c388a2d45a8a37195e9c44a23d5--8824247294c04e77b82eb82f601ffe99 1407bacc2232448b822afc647c208d1f 2 2c0216ef77424d17b70179b69c21147f RY(theta\u2085) 8824247294c04e77b82eb82f601ffe99--2c0216ef77424d17b70179b69c21147f d8547d6eafd644e897110ba9bff526ba RX(theta\u2089) 2c0216ef77424d17b70179b69c21147f--d8547d6eafd644e897110ba9bff526ba b47e1e69463840a993ab14a017974925 X d8547d6eafd644e897110ba9bff526ba--b47e1e69463840a993ab14a017974925 b47e1e69463840a993ab14a017974925--baf92e5b562a47888457cb36cd099779 a4c1050d430540b5abda81d362c7990c b47e1e69463840a993ab14a017974925--a4c1050d430540b5abda81d362c7990c e2576e760cf9454e948259ca59c85b8d RX(theta\u2081\u2083) a4c1050d430540b5abda81d362c7990c--e2576e760cf9454e948259ca59c85b8d 2c71367eb1844802914074a8b14eb631 RY(theta\u2081\u2087) e2576e760cf9454e948259ca59c85b8d--2c71367eb1844802914074a8b14eb631 7f5d0e442d24409b939a83fd93fde11d RX(theta\u2082\u2081) 2c71367eb1844802914074a8b14eb631--7f5d0e442d24409b939a83fd93fde11d 6daa4d944fe84e20b271935e2ccadeab X 7f5d0e442d24409b939a83fd93fde11d--6daa4d944fe84e20b271935e2ccadeab 6daa4d944fe84e20b271935e2ccadeab--00aa1646311a4c30871a130e270a7946 cceaf3de94884926b39cb0035cf8b71e 6daa4d944fe84e20b271935e2ccadeab--cceaf3de94884926b39cb0035cf8b71e 0467d5cbcb684c09a02e5ce9505c63d6 RX(theta\u2081) cceaf3de94884926b39cb0035cf8b71e--0467d5cbcb684c09a02e5ce9505c63d6 01e7c62b6ab24bd39272e4aab35d7773 RY(theta\u2085) 0467d5cbcb684c09a02e5ce9505c63d6--01e7c62b6ab24bd39272e4aab35d7773 cb38f4eedad945eaa1eda5359d1043b5 RX(theta\u2089) 01e7c62b6ab24bd39272e4aab35d7773--cb38f4eedad945eaa1eda5359d1043b5 aca0ca29c878474cb746199a48a9213f X cb38f4eedad945eaa1eda5359d1043b5--aca0ca29c878474cb746199a48a9213f aca0ca29c878474cb746199a48a9213f--27b1fdda4c274416a331d95dc6caedc0 5884b27520384884b7a2592b55a6766f aca0ca29c878474cb746199a48a9213f--5884b27520384884b7a2592b55a6766f c7f3d7aca36f46c6891662d40ae95b08 RX(theta\u2081\u2083) 5884b27520384884b7a2592b55a6766f--c7f3d7aca36f46c6891662d40ae95b08 f69de6c7772a421b8bde507a00f61cf7 RY(theta\u2081\u2087) c7f3d7aca36f46c6891662d40ae95b08--f69de6c7772a421b8bde507a00f61cf7 e320f3b9fea5485d8a3afe460f2edeb3 RX(theta\u2082\u2081) f69de6c7772a421b8bde507a00f61cf7--e320f3b9fea5485d8a3afe460f2edeb3 5a7d0d363e0e45cc86d9bc8af171f140 X e320f3b9fea5485d8a3afe460f2edeb3--5a7d0d363e0e45cc86d9bc8af171f140 5a7d0d363e0e45cc86d9bc8af171f140--1c14be7b28d24dda8040df74aef9c045 c6921ae30ac247c1adb4b7bf8c700d34 5a7d0d363e0e45cc86d9bc8af171f140--c6921ae30ac247c1adb4b7bf8c700d34 c6921ae30ac247c1adb4b7bf8c700d34--ed2c8bdbd6ac4f6cabeaaf28c72660ed 65ea8f3d345d400e8c3f855f70546ed7 a14fd72f21844f2d9a837816d326b81f RX(theta\u2082) 1407bacc2232448b822afc647c208d1f--a14fd72f21844f2d9a837816d326b81f a951716e9a6840e7a1b30078a675dfb4 3 b8b1c101835e4cceac522129a5021beb RY(theta\u2086) a14fd72f21844f2d9a837816d326b81f--b8b1c101835e4cceac522129a5021beb 4651ca6dc43e47e392da9c2917b25009 RX(theta\u2081\u2080) b8b1c101835e4cceac522129a5021beb--4651ca6dc43e47e392da9c2917b25009 3be16a1e2ff843abaa5bfd67216f5d7f 4651ca6dc43e47e392da9c2917b25009--3be16a1e2ff843abaa5bfd67216f5d7f 8faed86b9b1a488fbd38a1af15ae146d X 3be16a1e2ff843abaa5bfd67216f5d7f--8faed86b9b1a488fbd38a1af15ae146d 8faed86b9b1a488fbd38a1af15ae146d--a4c1050d430540b5abda81d362c7990c db2d8bb27cdd41339467ba3da723b7a2 RX(theta\u2081\u2084) 8faed86b9b1a488fbd38a1af15ae146d--db2d8bb27cdd41339467ba3da723b7a2 7560bbc2c6fe45ebbe6af6a73182cfdb RY(theta\u2081\u2088) db2d8bb27cdd41339467ba3da723b7a2--7560bbc2c6fe45ebbe6af6a73182cfdb 9921d4a1a5004281b8c44de12d317da9 RX(theta\u2082\u2082) 7560bbc2c6fe45ebbe6af6a73182cfdb--9921d4a1a5004281b8c44de12d317da9 ec9b0744009a4422afbc7771e41c2187 9921d4a1a5004281b8c44de12d317da9--ec9b0744009a4422afbc7771e41c2187 7c91f8d509a84cf69bfd70d19b2eed21 X ec9b0744009a4422afbc7771e41c2187--7c91f8d509a84cf69bfd70d19b2eed21 7c91f8d509a84cf69bfd70d19b2eed21--cceaf3de94884926b39cb0035cf8b71e 169ccb94a68f4701969b1582c38a84e3 RX(theta\u2082) 7c91f8d509a84cf69bfd70d19b2eed21--169ccb94a68f4701969b1582c38a84e3 7e6b61b04a854546b71246b6369daa9d RY(theta\u2086) 169ccb94a68f4701969b1582c38a84e3--7e6b61b04a854546b71246b6369daa9d c202dc3a99b54e7cba1b48c22bfa0605 RX(theta\u2081\u2080) 7e6b61b04a854546b71246b6369daa9d--c202dc3a99b54e7cba1b48c22bfa0605 6fbe1682b5a64625b7eb0332ec137c39 c202dc3a99b54e7cba1b48c22bfa0605--6fbe1682b5a64625b7eb0332ec137c39 071fa610a5574040982e5ee2fc77e9b8 X 6fbe1682b5a64625b7eb0332ec137c39--071fa610a5574040982e5ee2fc77e9b8 071fa610a5574040982e5ee2fc77e9b8--5884b27520384884b7a2592b55a6766f 144a8f39853844c8b50728da57ee6335 RX(theta\u2081\u2084) 071fa610a5574040982e5ee2fc77e9b8--144a8f39853844c8b50728da57ee6335 14af9f077012440396da2b66fcdbaa80 RY(theta\u2081\u2088) 144a8f39853844c8b50728da57ee6335--14af9f077012440396da2b66fcdbaa80 55738cf902844fbb9c77fe330236c577 RX(theta\u2082\u2082) 14af9f077012440396da2b66fcdbaa80--55738cf902844fbb9c77fe330236c577 87c6b9596c154d73a7bf8e89fc0264b2 55738cf902844fbb9c77fe330236c577--87c6b9596c154d73a7bf8e89fc0264b2 7237181572bd424283f3a7648c004ee5 X 87c6b9596c154d73a7bf8e89fc0264b2--7237181572bd424283f3a7648c004ee5 7237181572bd424283f3a7648c004ee5--c6921ae30ac247c1adb4b7bf8c700d34 7237181572bd424283f3a7648c004ee5--65ea8f3d345d400e8c3f855f70546ed7 3da82fdf129f4b5d9e2a37c973adeb97 1f301856fb03483e8852a5e9c952440a RX(theta\u2083) a951716e9a6840e7a1b30078a675dfb4--1f301856fb03483e8852a5e9c952440a 4ef5f8e1088c410c839a51dfa558b953 RY(theta\u2087) 1f301856fb03483e8852a5e9c952440a--4ef5f8e1088c410c839a51dfa558b953 38493ecbc395454ebe66356b8cb1446b RX(theta\u2081\u2081) 4ef5f8e1088c410c839a51dfa558b953--38493ecbc395454ebe66356b8cb1446b 64f8b20cf7e447fdb3fc00e95e5b0771 X 38493ecbc395454ebe66356b8cb1446b--64f8b20cf7e447fdb3fc00e95e5b0771 64f8b20cf7e447fdb3fc00e95e5b0771--3be16a1e2ff843abaa5bfd67216f5d7f d9941d5ca5f841b5bdcc0800a9a4237c 64f8b20cf7e447fdb3fc00e95e5b0771--d9941d5ca5f841b5bdcc0800a9a4237c 01f23bf082374b218182675d0ec7ce43 RX(theta\u2081\u2085) d9941d5ca5f841b5bdcc0800a9a4237c--01f23bf082374b218182675d0ec7ce43 d48766a7f864467cac5728ef8e393495 RY(theta\u2081\u2089) 01f23bf082374b218182675d0ec7ce43--d48766a7f864467cac5728ef8e393495 e301417d597e4fe4bf5abd758753da31 RX(theta\u2082\u2083) d48766a7f864467cac5728ef8e393495--e301417d597e4fe4bf5abd758753da31 0a10a88b4d824b1da707ec09033904b1 X e301417d597e4fe4bf5abd758753da31--0a10a88b4d824b1da707ec09033904b1 0a10a88b4d824b1da707ec09033904b1--ec9b0744009a4422afbc7771e41c2187 01cd1dc473eb46d1bc389fec0619445b 0a10a88b4d824b1da707ec09033904b1--01cd1dc473eb46d1bc389fec0619445b 678861f286b44fa5a761274b61911091 RX(theta\u2083) 01cd1dc473eb46d1bc389fec0619445b--678861f286b44fa5a761274b61911091 525a146a50d0454fa2eba4df8794e2d4 RY(theta\u2087) 678861f286b44fa5a761274b61911091--525a146a50d0454fa2eba4df8794e2d4 5075ab8da1a9409a94047b82e9122cb6 RX(theta\u2081\u2081) 525a146a50d0454fa2eba4df8794e2d4--5075ab8da1a9409a94047b82e9122cb6 0823553d60f9408bbaa35b10e121b6ce X 5075ab8da1a9409a94047b82e9122cb6--0823553d60f9408bbaa35b10e121b6ce 0823553d60f9408bbaa35b10e121b6ce--6fbe1682b5a64625b7eb0332ec137c39 a522f98b87f0440cb0d635510aad971c 0823553d60f9408bbaa35b10e121b6ce--a522f98b87f0440cb0d635510aad971c 1ec96c56cd5a4fb2b04142e0b3464020 RX(theta\u2081\u2085) a522f98b87f0440cb0d635510aad971c--1ec96c56cd5a4fb2b04142e0b3464020 6c50d659d81c48dcb9e4c290f035149e RY(theta\u2081\u2089) 1ec96c56cd5a4fb2b04142e0b3464020--6c50d659d81c48dcb9e4c290f035149e 5e778a5da34b41db8c1b02b0d6a8984f RX(theta\u2082\u2083) 6c50d659d81c48dcb9e4c290f035149e--5e778a5da34b41db8c1b02b0d6a8984f 2550c191ca3e42b38e66d7cdd21f19d9 X 5e778a5da34b41db8c1b02b0d6a8984f--2550c191ca3e42b38e66d7cdd21f19d9 2550c191ca3e42b38e66d7cdd21f19d9--87c6b9596c154d73a7bf8e89fc0264b2 40e288b310db43de9be0f09ffb157ade 2550c191ca3e42b38e66d7cdd21f19d9--40e288b310db43de9be0f09ffb157ade 40e288b310db43de9be0f09ffb157ade--3da82fdf129f4b5d9e2a37c973adeb97 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_f781f5d63ba040f1ac68416f7e2c1da1 HEA cluster_c2e912ff01694829bbdd790e8bed2829 HEA 38ef22e8533f41dbad3e1c2313e53d5d 0 afd4cedfcb9f4b15b87095ad037a18bb RX(p1\u2080) 38ef22e8533f41dbad3e1c2313e53d5d--afd4cedfcb9f4b15b87095ad037a18bb 4008d7092eb34f4fab2578cf305c27de 1 6dd572797383433e9922041d78480a50 RY(p1\u2084) afd4cedfcb9f4b15b87095ad037a18bb--6dd572797383433e9922041d78480a50 426465ebd27046ee8b6eb7f9b72221f3 RX(p1\u2088) 6dd572797383433e9922041d78480a50--426465ebd27046ee8b6eb7f9b72221f3 93d79b3244df45268b3dba0e9763e1fd 426465ebd27046ee8b6eb7f9b72221f3--93d79b3244df45268b3dba0e9763e1fd 496a98f610d541e9bde16ba9d625db5d 93d79b3244df45268b3dba0e9763e1fd--496a98f610d541e9bde16ba9d625db5d d7079b537a8f46f69474e666d2d04810 RX(p1\u2081\u2082) 496a98f610d541e9bde16ba9d625db5d--d7079b537a8f46f69474e666d2d04810 b8c467d62be04ed5ae9cb729999591c6 RY(p1\u2081\u2086) d7079b537a8f46f69474e666d2d04810--b8c467d62be04ed5ae9cb729999591c6 609f24d4debc4237a40d59572d965a16 RX(p1\u2082\u2080) b8c467d62be04ed5ae9cb729999591c6--609f24d4debc4237a40d59572d965a16 fff75b967b2f4579ac94500e89a254d1 609f24d4debc4237a40d59572d965a16--fff75b967b2f4579ac94500e89a254d1 0e8386d368514c2d8a7bc18f038c979c fff75b967b2f4579ac94500e89a254d1--0e8386d368514c2d8a7bc18f038c979c dede1728619c4d918a05d89464d161dd RX(p2\u2080) 0e8386d368514c2d8a7bc18f038c979c--dede1728619c4d918a05d89464d161dd 1cad34d183c94af2963a3f96a3045be1 RY(p2\u2084) dede1728619c4d918a05d89464d161dd--1cad34d183c94af2963a3f96a3045be1 217921fcc4804d87a08bae7e69014b77 RX(p2\u2088) 1cad34d183c94af2963a3f96a3045be1--217921fcc4804d87a08bae7e69014b77 42b72869a11b45ca88428f6de284dc62 217921fcc4804d87a08bae7e69014b77--42b72869a11b45ca88428f6de284dc62 898400c0adde45a49f8156fc8af3d9c4 42b72869a11b45ca88428f6de284dc62--898400c0adde45a49f8156fc8af3d9c4 d05c861d30c34dbe9093957e727f6d56 RX(p2\u2081\u2082) 898400c0adde45a49f8156fc8af3d9c4--d05c861d30c34dbe9093957e727f6d56 e1c8520619bc4e3782d48102e8883812 RY(p2\u2081\u2086) d05c861d30c34dbe9093957e727f6d56--e1c8520619bc4e3782d48102e8883812 258c38c1148d46d29f2eafafbeeb4517 RX(p2\u2082\u2080) e1c8520619bc4e3782d48102e8883812--258c38c1148d46d29f2eafafbeeb4517 fd8dc9d7020140dda166a79aff910fec 258c38c1148d46d29f2eafafbeeb4517--fd8dc9d7020140dda166a79aff910fec 65a4192367db47b9b0514b29c6f66139 fd8dc9d7020140dda166a79aff910fec--65a4192367db47b9b0514b29c6f66139 71253492466d44c49e705ab161790622 65a4192367db47b9b0514b29c6f66139--71253492466d44c49e705ab161790622 6e14cbe3473c489ea9980b3ae236fb87 fa0333e0ab5547419fc4ac387090cb40 RX(p1\u2081) 4008d7092eb34f4fab2578cf305c27de--fa0333e0ab5547419fc4ac387090cb40 9af881a4bdeb43ddb08dd60adc1cfc47 2 4857f1f9264c42d4a5675eca4f646284 RY(p1\u2085) fa0333e0ab5547419fc4ac387090cb40--4857f1f9264c42d4a5675eca4f646284 0f18ff6a27464c6d9dc0ccaa54d23c9a RX(p1\u2089) 4857f1f9264c42d4a5675eca4f646284--0f18ff6a27464c6d9dc0ccaa54d23c9a 73a21f2a206c4d25b9f97aae7eea0a88 X 0f18ff6a27464c6d9dc0ccaa54d23c9a--73a21f2a206c4d25b9f97aae7eea0a88 73a21f2a206c4d25b9f97aae7eea0a88--93d79b3244df45268b3dba0e9763e1fd 7946449448544a839524b9a74cfda043 73a21f2a206c4d25b9f97aae7eea0a88--7946449448544a839524b9a74cfda043 8d8a0bf333a14700aeaf87c7f8da5dd0 RX(p1\u2081\u2083) 7946449448544a839524b9a74cfda043--8d8a0bf333a14700aeaf87c7f8da5dd0 df8c894a02494ddb88c873d46b0114d4 RY(p1\u2081\u2087) 8d8a0bf333a14700aeaf87c7f8da5dd0--df8c894a02494ddb88c873d46b0114d4 98afeb59b37a41eab97143809079a14d RX(p1\u2082\u2081) df8c894a02494ddb88c873d46b0114d4--98afeb59b37a41eab97143809079a14d d80a58592cbd47669d502471d32da8c1 X 98afeb59b37a41eab97143809079a14d--d80a58592cbd47669d502471d32da8c1 d80a58592cbd47669d502471d32da8c1--fff75b967b2f4579ac94500e89a254d1 ae0a754fe29e42bd9f2a50d24e64e139 d80a58592cbd47669d502471d32da8c1--ae0a754fe29e42bd9f2a50d24e64e139 f49e0510dc2e40d7a235edac4b9f766a RX(p2\u2081) ae0a754fe29e42bd9f2a50d24e64e139--f49e0510dc2e40d7a235edac4b9f766a 9b17adddc4784fce92f2d26546108d65 RY(p2\u2085) f49e0510dc2e40d7a235edac4b9f766a--9b17adddc4784fce92f2d26546108d65 97049297d4ec4b70929a30015e4b754a RX(p2\u2089) 9b17adddc4784fce92f2d26546108d65--97049297d4ec4b70929a30015e4b754a 0f3f73855fa646dda53d12bd17f44ae8 X 97049297d4ec4b70929a30015e4b754a--0f3f73855fa646dda53d12bd17f44ae8 0f3f73855fa646dda53d12bd17f44ae8--42b72869a11b45ca88428f6de284dc62 5f76b822db054d88a1bb64b90a74c369 0f3f73855fa646dda53d12bd17f44ae8--5f76b822db054d88a1bb64b90a74c369 748b8be73b8543b2905865b11324a901 RX(p2\u2081\u2083) 5f76b822db054d88a1bb64b90a74c369--748b8be73b8543b2905865b11324a901 8f31ad4ffcf44fea89ad5d39316bbad1 RY(p2\u2081\u2087) 748b8be73b8543b2905865b11324a901--8f31ad4ffcf44fea89ad5d39316bbad1 97938bc12567484ea76456bce33e19cf RX(p2\u2082\u2081) 8f31ad4ffcf44fea89ad5d39316bbad1--97938bc12567484ea76456bce33e19cf 1a6fbc99012f49348a7fd58ca84ae039 X 97938bc12567484ea76456bce33e19cf--1a6fbc99012f49348a7fd58ca84ae039 1a6fbc99012f49348a7fd58ca84ae039--fd8dc9d7020140dda166a79aff910fec 757a7d9c380a405a8f40fdcf838dcad8 1a6fbc99012f49348a7fd58ca84ae039--757a7d9c380a405a8f40fdcf838dcad8 757a7d9c380a405a8f40fdcf838dcad8--6e14cbe3473c489ea9980b3ae236fb87 5951ea99116b458e8fe10b68361247bd bbb35da1e3ae4ae9bbb44e9dc47154de RX(p1\u2082) 9af881a4bdeb43ddb08dd60adc1cfc47--bbb35da1e3ae4ae9bbb44e9dc47154de 06a1a57ba4bf419cb921796762f9274a 3 4d14debb083e4b9890632b90b9ffacf3 RY(p1\u2086) bbb35da1e3ae4ae9bbb44e9dc47154de--4d14debb083e4b9890632b90b9ffacf3 fb07d40a65904d3aa774ad5c8543297d RX(p1\u2081\u2080) 4d14debb083e4b9890632b90b9ffacf3--fb07d40a65904d3aa774ad5c8543297d fc2c815f43844ee2a65f91331715ddcf fb07d40a65904d3aa774ad5c8543297d--fc2c815f43844ee2a65f91331715ddcf 9e56da7e5a6a4bc4a125b24b2a4139dd X fc2c815f43844ee2a65f91331715ddcf--9e56da7e5a6a4bc4a125b24b2a4139dd 9e56da7e5a6a4bc4a125b24b2a4139dd--7946449448544a839524b9a74cfda043 677ba165ac5c4d1e8ef5424caee571c1 RX(p1\u2081\u2084) 9e56da7e5a6a4bc4a125b24b2a4139dd--677ba165ac5c4d1e8ef5424caee571c1 6713fbdae84142f5893e1e936885d0ba RY(p1\u2081\u2088) 677ba165ac5c4d1e8ef5424caee571c1--6713fbdae84142f5893e1e936885d0ba 47b755a70be14433bf90793ab8761ec1 RX(p1\u2082\u2082) 6713fbdae84142f5893e1e936885d0ba--47b755a70be14433bf90793ab8761ec1 ed46abe8ed4d41a7a13afeccab7b7165 47b755a70be14433bf90793ab8761ec1--ed46abe8ed4d41a7a13afeccab7b7165 5e429e85c882463392c6482edf181456 X ed46abe8ed4d41a7a13afeccab7b7165--5e429e85c882463392c6482edf181456 5e429e85c882463392c6482edf181456--ae0a754fe29e42bd9f2a50d24e64e139 db6ffdd6941746b198fdd1004aa7b359 RX(p2\u2082) 5e429e85c882463392c6482edf181456--db6ffdd6941746b198fdd1004aa7b359 3333784745114a5fa6d1712a0e116550 RY(p2\u2086) db6ffdd6941746b198fdd1004aa7b359--3333784745114a5fa6d1712a0e116550 d1ad1f1cf39d475aad272bc33c1f1ac3 RX(p2\u2081\u2080) 3333784745114a5fa6d1712a0e116550--d1ad1f1cf39d475aad272bc33c1f1ac3 4d0dcc51e52848798d16563d551e3c77 d1ad1f1cf39d475aad272bc33c1f1ac3--4d0dcc51e52848798d16563d551e3c77 218c3aca295740fc8e83901a64e1c00a X 4d0dcc51e52848798d16563d551e3c77--218c3aca295740fc8e83901a64e1c00a 218c3aca295740fc8e83901a64e1c00a--5f76b822db054d88a1bb64b90a74c369 5f96dfab247f4c2eb5541dca440b6318 RX(p2\u2081\u2084) 218c3aca295740fc8e83901a64e1c00a--5f96dfab247f4c2eb5541dca440b6318 a82a421da23f464db525f8702da34c44 RY(p2\u2081\u2088) 5f96dfab247f4c2eb5541dca440b6318--a82a421da23f464db525f8702da34c44 38a53c6b1079435890ef09452a6d551b RX(p2\u2082\u2082) a82a421da23f464db525f8702da34c44--38a53c6b1079435890ef09452a6d551b d2f6d59cbb814e0797f1061a10574822 38a53c6b1079435890ef09452a6d551b--d2f6d59cbb814e0797f1061a10574822 6d8c91a1a44d41e98c0795b9231c613f X d2f6d59cbb814e0797f1061a10574822--6d8c91a1a44d41e98c0795b9231c613f 6d8c91a1a44d41e98c0795b9231c613f--757a7d9c380a405a8f40fdcf838dcad8 6d8c91a1a44d41e98c0795b9231c613f--5951ea99116b458e8fe10b68361247bd bec17f24bb464ca9aafd286531583200 eaa2e4bba4e04cd4bd20bddee47de0f2 RX(p1\u2083) 06a1a57ba4bf419cb921796762f9274a--eaa2e4bba4e04cd4bd20bddee47de0f2 eda650f0a5964f1db9a4d4fa1d50e25f RY(p1\u2087) eaa2e4bba4e04cd4bd20bddee47de0f2--eda650f0a5964f1db9a4d4fa1d50e25f 9e804ecc859642958d76cb9f85380762 RX(p1\u2081\u2081) eda650f0a5964f1db9a4d4fa1d50e25f--9e804ecc859642958d76cb9f85380762 fb7d3dec734d46bb9b9c0831f55befff X 9e804ecc859642958d76cb9f85380762--fb7d3dec734d46bb9b9c0831f55befff fb7d3dec734d46bb9b9c0831f55befff--fc2c815f43844ee2a65f91331715ddcf 6b9285a2fbfc423893d988b3818bfcc4 fb7d3dec734d46bb9b9c0831f55befff--6b9285a2fbfc423893d988b3818bfcc4 aee48ba6290a46819a4c995ee73a18df RX(p1\u2081\u2085) 6b9285a2fbfc423893d988b3818bfcc4--aee48ba6290a46819a4c995ee73a18df d376978168ea4a02998ee6efcaf3ba1d RY(p1\u2081\u2089) aee48ba6290a46819a4c995ee73a18df--d376978168ea4a02998ee6efcaf3ba1d 43520c90db1140939cfad5a24be76756 RX(p1\u2082\u2083) d376978168ea4a02998ee6efcaf3ba1d--43520c90db1140939cfad5a24be76756 a51d595a41e74b0bad1da0261c029276 X 43520c90db1140939cfad5a24be76756--a51d595a41e74b0bad1da0261c029276 a51d595a41e74b0bad1da0261c029276--ed46abe8ed4d41a7a13afeccab7b7165 3f27058d3d1948998fc6b679b26f1c7c a51d595a41e74b0bad1da0261c029276--3f27058d3d1948998fc6b679b26f1c7c da03bc3349294571b3781e045fd296cf RX(p2\u2083) 3f27058d3d1948998fc6b679b26f1c7c--da03bc3349294571b3781e045fd296cf 28ebbc47626a4cfdbebb5971e048243e RY(p2\u2087) da03bc3349294571b3781e045fd296cf--28ebbc47626a4cfdbebb5971e048243e a9091d3494364a5ba9bc374773e8abef RX(p2\u2081\u2081) 28ebbc47626a4cfdbebb5971e048243e--a9091d3494364a5ba9bc374773e8abef 0a5a17800b0c4eebaa84b205da25bf2c X a9091d3494364a5ba9bc374773e8abef--0a5a17800b0c4eebaa84b205da25bf2c 0a5a17800b0c4eebaa84b205da25bf2c--4d0dcc51e52848798d16563d551e3c77 c84100b726a8448aa0c3b4ff581918e3 0a5a17800b0c4eebaa84b205da25bf2c--c84100b726a8448aa0c3b4ff581918e3 7ecd115aa4f042b197468c4413e6e7b8 RX(p2\u2081\u2085) c84100b726a8448aa0c3b4ff581918e3--7ecd115aa4f042b197468c4413e6e7b8 a56f94090cca49c18ea69a19da68ee17 RY(p2\u2081\u2089) 7ecd115aa4f042b197468c4413e6e7b8--a56f94090cca49c18ea69a19da68ee17 4797a46d8d9940cf9df0fc71d2b6c1ac RX(p2\u2082\u2083) a56f94090cca49c18ea69a19da68ee17--4797a46d8d9940cf9df0fc71d2b6c1ac 2a60bd7635d2466d84c469f926ee8e2e X 4797a46d8d9940cf9df0fc71d2b6c1ac--2a60bd7635d2466d84c469f926ee8e2e 2a60bd7635d2466d84c469f926ee8e2e--d2f6d59cbb814e0797f1061a10574822 f75a2315ef9841e5aebe2cc3a3793cda 2a60bd7635d2466d84c469f926ee8e2e--f75a2315ef9841e5aebe2cc3a3793cda f75a2315ef9841e5aebe2cc3a3793cda--bec17f24bb464ca9aafd286531583200 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6032])), ('theta_0', tensor([0.7060])), ('theta_1', tensor([0.8729])), ('theta_10', tensor([0.5824])), ('theta_11', tensor([0.7651])), ('theta_12', tensor([0.7259])), ('theta_13', tensor([0.8999])), ('theta_14', tensor([0.5249])), ('theta_15', tensor([0.8056])), ('theta_16', tensor([0.8753])), ('theta_17', tensor([0.9508])), ('theta_18', tensor([0.5994])), ('theta_19', tensor([0.5960])), ('theta_2', tensor([0.3586])), ('theta_20', tensor([0.0068])), ('theta_21', tensor([0.4744])), ('theta_22', tensor([0.3152])), ('theta_23', tensor([0.4480])), ('theta_3', tensor([0.7231])), ('theta_4', tensor([0.2878])), ('theta_5', tensor([0.8199])), ('theta_6', tensor([0.4943])), ('theta_7', tensor([0.6892])), ('theta_8', tensor([0.0667])), ('theta_9', tensor([0.9967]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6022])), ('theta_0', tensor([0.7070])), ('theta_1', tensor([0.8719])), ('theta_10', tensor([0.5834])), ('theta_11', tensor([0.7661])), ('theta_12', tensor([0.7269])), ('theta_13', tensor([0.9009])), ('theta_14', tensor([0.5259])), ('theta_15', tensor([0.8066])), ('theta_16', tensor([0.8763])), ('theta_17', tensor([0.9518])), ('theta_18', tensor([0.5984])), ('theta_19', tensor([0.5970])), ('theta_2', tensor([0.3596])), ('theta_20', tensor([0.0078])), ('theta_21', tensor([0.4754])), ('theta_22', tensor([0.3162])), ('theta_23', tensor([0.4490])), ('theta_3', tensor([0.7241])), ('theta_4', tensor([0.2888])), ('theta_5', tensor([0.8209])), ('theta_6', tensor([0.4953])), ('theta_7', tensor([0.6902])), ('theta_8', tensor([0.0677])), ('theta_9', tensor([0.9957]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): RX(qubit_support=(0,))\n(1): RX(qubit_support=(1,))\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9968+0.0000j,  0.0000-0.0567j,  0.0000-0.0567j, -0.0032+0.0000j],\n[ 0.9533+0.0000j,  0.0000-0.2109j,  0.0000-0.2109j, -0.0467+0.0000j],\n[ 0.9707+0.0000j,  0.0000-0.1686j,  0.0000-0.1686j, -0.0293+0.0000j]])\nxs = [Counter({'00': 100}), Counter({'00': 92, '10': 5, '11': 2, '01': 1}), Counter({'00': 95, '01': 4, '10': 1})]\nex = tensor([[0.9936],\n[0.9067],\n[0.9414]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9936, 0.9936],\n[0.9067, 0.9067],\n[0.9414, 0.9414]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-11-05T22:47:35.223483 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-11-05T22:47:35.566460 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-11-05T22:47:35.667612 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>Qubits coordinates in Qadence are dimensionless but converted to the required unit when executed on a backend. For instance, Pulser uses \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interaction must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 53, '01': 47})]\nSample in little endian = [Counter({'10': 60, '00': 40})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 53, '10': 47})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 89, '01': 11})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 88, '01': 12})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9223+0.0000j, 0.0000-0.3865j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [0.45600936-0.30375134j 0.        +0.j         0.69621865-0.46375659j\n0.        +0.j        ]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_1470f093a2614456bb63468ce533dbf8 Circuit block cluster_7732a9e748b04b2b9cbdcc364bee83d2 Prep block d63a14db489c4bb896ff39c412caaf50 0 fbfd4821c30f48359169c6d13c09ab50 d63a14db489c4bb896ff39c412caaf50--fbfd4821c30f48359169c6d13c09ab50 d92c9688af524a9d947e4831af580c19 1 527e9a5960f64a2fa0e6b80a0287ef5e RX(theta\u2080) fbfd4821c30f48359169c6d13c09ab50--527e9a5960f64a2fa0e6b80a0287ef5e 4b294d579c5149c59dfff9474fe928dd RY(theta\u2084) 527e9a5960f64a2fa0e6b80a0287ef5e--4b294d579c5149c59dfff9474fe928dd bdab414212b34eaab6c1f6e237e563a3 RX(theta\u2088) 4b294d579c5149c59dfff9474fe928dd--bdab414212b34eaab6c1f6e237e563a3 f6e49552e5d64f89b09960b704e5317c bdab414212b34eaab6c1f6e237e563a3--f6e49552e5d64f89b09960b704e5317c 503c69bbcbc54d10a6c69c3def479093 f6e49552e5d64f89b09960b704e5317c--503c69bbcbc54d10a6c69c3def479093 257fa4ce6a664fc3a3e8020294a26624 RX(theta\u2081\u2082) 503c69bbcbc54d10a6c69c3def479093--257fa4ce6a664fc3a3e8020294a26624 dff5294bd59b498a89b781eb47b69562 RY(theta\u2081\u2086) 257fa4ce6a664fc3a3e8020294a26624--dff5294bd59b498a89b781eb47b69562 022c1410ba1946eaa86002fe39caa0f2 RX(theta\u2082\u2080) dff5294bd59b498a89b781eb47b69562--022c1410ba1946eaa86002fe39caa0f2 728ee556f2bb455e824e7dd9bac4c87a 022c1410ba1946eaa86002fe39caa0f2--728ee556f2bb455e824e7dd9bac4c87a 60f54b6068c6427b98e6e06340fe47a9 728ee556f2bb455e824e7dd9bac4c87a--60f54b6068c6427b98e6e06340fe47a9 581628ad3f3942d98df3fed234aa9f8e 60f54b6068c6427b98e6e06340fe47a9--581628ad3f3942d98df3fed234aa9f8e df0be16186ae4472aefebb71425f7784 2385913ddd4c4704bd28cb2d34966821 d92c9688af524a9d947e4831af580c19--2385913ddd4c4704bd28cb2d34966821 d0e22f55040c467cb10c2151ebb6b920 2 854d65ad89e24ac58fbb0d2cd6e053d0 RX(theta\u2081) 2385913ddd4c4704bd28cb2d34966821--854d65ad89e24ac58fbb0d2cd6e053d0 a338bc3e53414ac2bf1665b5a13de5d7 RY(theta\u2085) 854d65ad89e24ac58fbb0d2cd6e053d0--a338bc3e53414ac2bf1665b5a13de5d7 08d98fe1db6a4b7b8b60a92cadd06ed7 RX(theta\u2089) a338bc3e53414ac2bf1665b5a13de5d7--08d98fe1db6a4b7b8b60a92cadd06ed7 c8becf221fbb46978fdc148323cdaa4e X 08d98fe1db6a4b7b8b60a92cadd06ed7--c8becf221fbb46978fdc148323cdaa4e c8becf221fbb46978fdc148323cdaa4e--f6e49552e5d64f89b09960b704e5317c b88d4001c78942b8890e08d5e7aca18a c8becf221fbb46978fdc148323cdaa4e--b88d4001c78942b8890e08d5e7aca18a feee3fc285b945a09903d4b9400fe136 RX(theta\u2081\u2083) b88d4001c78942b8890e08d5e7aca18a--feee3fc285b945a09903d4b9400fe136 24239aa7f0d04c9dacda6f19d43058c0 RY(theta\u2081\u2087) feee3fc285b945a09903d4b9400fe136--24239aa7f0d04c9dacda6f19d43058c0 5b86f62d2f2e4e4e80d12dcfca7cee4e RX(theta\u2082\u2081) 24239aa7f0d04c9dacda6f19d43058c0--5b86f62d2f2e4e4e80d12dcfca7cee4e 6e5cf0e6a1c246878ab79aea96bd5783 X 5b86f62d2f2e4e4e80d12dcfca7cee4e--6e5cf0e6a1c246878ab79aea96bd5783 6e5cf0e6a1c246878ab79aea96bd5783--728ee556f2bb455e824e7dd9bac4c87a 1f51b4b4993a4f9f9f75337814536573 6e5cf0e6a1c246878ab79aea96bd5783--1f51b4b4993a4f9f9f75337814536573 1f51b4b4993a4f9f9f75337814536573--df0be16186ae4472aefebb71425f7784 db03575d38f4462786ff4c843a69e245 d1f1a55907f3410daf10496aa5acbc0d d0e22f55040c467cb10c2151ebb6b920--d1f1a55907f3410daf10496aa5acbc0d e316aba485864a01b4cdb79417dc36cf 3 858e55d5a1a446b0bc1fbf0b2fce419b RX(theta\u2082) d1f1a55907f3410daf10496aa5acbc0d--858e55d5a1a446b0bc1fbf0b2fce419b c0a8d8cea32744cea47416c593526ac9 RY(theta\u2086) 858e55d5a1a446b0bc1fbf0b2fce419b--c0a8d8cea32744cea47416c593526ac9 dba1bb30426e4c4095dd4fcfb1f7ae34 RX(theta\u2081\u2080) c0a8d8cea32744cea47416c593526ac9--dba1bb30426e4c4095dd4fcfb1f7ae34 d8d72ea272ab484a912441a947bc59b0 dba1bb30426e4c4095dd4fcfb1f7ae34--d8d72ea272ab484a912441a947bc59b0 09a8b1cf087d40debd7fca422b28e77e X d8d72ea272ab484a912441a947bc59b0--09a8b1cf087d40debd7fca422b28e77e 09a8b1cf087d40debd7fca422b28e77e--b88d4001c78942b8890e08d5e7aca18a dbd9824b72db4535b31a682b3ce1dbc6 RX(theta\u2081\u2084) 09a8b1cf087d40debd7fca422b28e77e--dbd9824b72db4535b31a682b3ce1dbc6 0741a3129df84c83a35072c44ce20474 RY(theta\u2081\u2088) dbd9824b72db4535b31a682b3ce1dbc6--0741a3129df84c83a35072c44ce20474 7c67fb0bf49c43d7b3c86ca5eb50dc52 RX(theta\u2082\u2082) 0741a3129df84c83a35072c44ce20474--7c67fb0bf49c43d7b3c86ca5eb50dc52 68e4b1a7155c4872ab8510cca7e48536 7c67fb0bf49c43d7b3c86ca5eb50dc52--68e4b1a7155c4872ab8510cca7e48536 14b4636e27c448af9e869ecd7cc80990 X 68e4b1a7155c4872ab8510cca7e48536--14b4636e27c448af9e869ecd7cc80990 14b4636e27c448af9e869ecd7cc80990--1f51b4b4993a4f9f9f75337814536573 14b4636e27c448af9e869ecd7cc80990--db03575d38f4462786ff4c843a69e245 24fa5775021a43b49b7340508bc19a71 d8d1f2293a2d4bc9a21bdd50276c9829 X e316aba485864a01b4cdb79417dc36cf--d8d1f2293a2d4bc9a21bdd50276c9829 19d994c0bdad4ac8a00f305d8080a566 RX(theta\u2083) d8d1f2293a2d4bc9a21bdd50276c9829--19d994c0bdad4ac8a00f305d8080a566 071744a6144c4e73be4606787107fc74 RY(theta\u2087) 19d994c0bdad4ac8a00f305d8080a566--071744a6144c4e73be4606787107fc74 aa40d011e7744173ad3430aa309ab606 RX(theta\u2081\u2081) 071744a6144c4e73be4606787107fc74--aa40d011e7744173ad3430aa309ab606 a9fbb69882c249efb63d3b3d5441f671 X aa40d011e7744173ad3430aa309ab606--a9fbb69882c249efb63d3b3d5441f671 a9fbb69882c249efb63d3b3d5441f671--d8d72ea272ab484a912441a947bc59b0 b8469f5de45a4ff29f8e306e7b3e2b49 a9fbb69882c249efb63d3b3d5441f671--b8469f5de45a4ff29f8e306e7b3e2b49 5320789a2e4242e5812b391b6fb572f3 RX(theta\u2081\u2085) b8469f5de45a4ff29f8e306e7b3e2b49--5320789a2e4242e5812b391b6fb572f3 04e013bdffe14458be7c27c9dde9ea82 RY(theta\u2081\u2089) 5320789a2e4242e5812b391b6fb572f3--04e013bdffe14458be7c27c9dde9ea82 d14ac4cc5ae34f44a56813f374d3bf2e RX(theta\u2082\u2083) 04e013bdffe14458be7c27c9dde9ea82--d14ac4cc5ae34f44a56813f374d3bf2e aafa2b924a1b448cb1da43863716e28e X d14ac4cc5ae34f44a56813f374d3bf2e--aafa2b924a1b448cb1da43863716e28e aafa2b924a1b448cb1da43863716e28e--68e4b1a7155c4872ab8510cca7e48536 ebe205a6ffb04f349cfd81d11fae1b96 aafa2b924a1b448cb1da43863716e28e--ebe205a6ffb04f349cfd81d11fae1b96 ebe205a6ffb04f349cfd81d11fae1b96--24fa5775021a43b49b7340508bc19a71  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.1938-0.0520j, -0.2004+0.3661j, -0.0483-0.0577j, -0.2657-0.3253j,\n0.4508+0.0664j,  0.2878+0.0577j, -0.2979+0.1222j, -0.0662+0.4491j],\n[ 0.2315-0.2451j,  0.2807+0.1053j, -0.3644+0.4587j, -0.0791+0.0530j,\n-0.0125-0.1685j,  0.2731-0.3878j, -0.3455-0.2506j, -0.0893-0.0241j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}