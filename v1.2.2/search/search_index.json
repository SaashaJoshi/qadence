{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n\n# Global analog RX block.\nblock = AnalogRX(pi)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 38, '01': 37, '10': 25})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-12-12T16:38:49.879972 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 ba8c9e9e9b304eeea98615be593a0cf3 0 22e9132b7176414c8a05f947a37fa1d6 X ba8c9e9e9b304eeea98615be593a0cf3--22e9132b7176414c8a05f947a37fa1d6 c1760d3e88684e80acf755e51e04b665 1 5384ed69d59b42ee9cd05d82ad58eff1 22e9132b7176414c8a05f947a37fa1d6--5384ed69d59b42ee9cd05d82ad58eff1 03882abf6965441285d4e1d2b7ee6498 99f7244aebed48288316022386cc859d Y c1760d3e88684e80acf755e51e04b665--99f7244aebed48288316022386cc859d 99f7244aebed48288316022386cc859d--03882abf6965441285d4e1d2b7ee6498 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 3afb5811dcff4fd9bdfd9c2c0957dd3e 0 498e68d7af664ae1ac41610bef478090 X 3afb5811dcff4fd9bdfd9c2c0957dd3e--498e68d7af664ae1ac41610bef478090 058591cc8bd544bc8db722aa5bfd0b8c Y 498e68d7af664ae1ac41610bef478090--058591cc8bd544bc8db722aa5bfd0b8c 466679780f43473fa66edbe261c58762 058591cc8bd544bc8db722aa5bfd0b8c--466679780f43473fa66edbe261c58762 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 61a272104bbc42d3bfcedd45654ba905 0 d84df934bb4f47bfbc1af88b5e40468d X 61a272104bbc42d3bfcedd45654ba905--d84df934bb4f47bfbc1af88b5e40468d 5ccf31e27cc14f94af61f7db25143c42 1 75c168ff77be44e5af7c591256ee1862 d84df934bb4f47bfbc1af88b5e40468d--75c168ff77be44e5af7c591256ee1862 bb1840989439417caa81033446d5f165 75c168ff77be44e5af7c591256ee1862--bb1840989439417caa81033446d5f165 8f8caf2dd3354befbeea0585b8730bb9 aba44802fbc048e08d4d933d3f2b8731 5ccf31e27cc14f94af61f7db25143c42--aba44802fbc048e08d4d933d3f2b8731 3114b45a377a495fae41ef33cbf4b2c5 Y aba44802fbc048e08d4d933d3f2b8731--3114b45a377a495fae41ef33cbf4b2c5 3114b45a377a495fae41ef33cbf4b2c5--8f8caf2dd3354befbeea0585b8730bb9 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_3fd6aced336a4b5b9a92c1ab5a7d3ebc 39343b237cef4c7f8599463248a411c2 0 3607cfb4328c4f57a98805fe0186b6e5 39343b237cef4c7f8599463248a411c2--3607cfb4328c4f57a98805fe0186b6e5 8b275aa962d5408ab6e06ac7cb06d61f 1 f35f9066b10d4bd1b277861d16abde7f 3607cfb4328c4f57a98805fe0186b6e5--f35f9066b10d4bd1b277861d16abde7f 593a5344818a4b40b0220c4008c6fb28 dfa6af22f118461b921e8791bc74ca57 AddBlock 8b275aa962d5408ab6e06ac7cb06d61f--dfa6af22f118461b921e8791bc74ca57 a34beee6bafd4508922ea4376ac67be5 2 dfa6af22f118461b921e8791bc74ca57--593a5344818a4b40b0220c4008c6fb28 994e83e7dc1a4a0c8b94136aefa4364b bfc55ed3e12846108e2442306f7a662f a34beee6bafd4508922ea4376ac67be5--bfc55ed3e12846108e2442306f7a662f bfc55ed3e12846108e2442306f7a662f--994e83e7dc1a4a0c8b94136aefa4364b <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_167dd15c1896462b93f2775d36cbbb26 cluster_ac8fb995e1bb4f89a33e4a90438fe4bf rx d61bdea1971f44c3a8df4a1ff552c568 0 9235729a0ff24e4e9545eb5c6062b704 X d61bdea1971f44c3a8df4a1ff552c568--9235729a0ff24e4e9545eb5c6062b704 6e95f7e4992d4a65bf026525e65e02a0 1 992bed1953dd4035a930e30a65bf4638 9235729a0ff24e4e9545eb5c6062b704--992bed1953dd4035a930e30a65bf4638 a8fa119457d54f6c94217a0480a365b0 992bed1953dd4035a930e30a65bf4638--a8fa119457d54f6c94217a0480a365b0 8fbdc9c7fa0f48bab99f04b0c41d20bc a8fa119457d54f6c94217a0480a365b0--8fbdc9c7fa0f48bab99f04b0c41d20bc 74c40788d9084c188fe7eb5e0e3e7019 2ca3c9a5e2164b70a3749abdc1c7af06 Y 6e95f7e4992d4a65bf026525e65e02a0--2ca3c9a5e2164b70a3749abdc1c7af06 3681bec2317b4299b5f9da3042ec1856 2 47a6337120764126a9706e4e605ceffc 2ca3c9a5e2164b70a3749abdc1c7af06--47a6337120764126a9706e4e605ceffc d69e8145f7ff4a59a730d004850c2394 HamEvo 47a6337120764126a9706e4e605ceffc--d69e8145f7ff4a59a730d004850c2394 d69e8145f7ff4a59a730d004850c2394--74c40788d9084c188fe7eb5e0e3e7019 1d8ad8cf035a4c8f9f4178bfe00229eb cf2b96d70adb42ccb58519dafd36dd1a RX(x) 3681bec2317b4299b5f9da3042ec1856--cf2b96d70adb42ccb58519dafd36dd1a 45d8022a8ebe42f8a0aedba400bf6412 3 4ccdfcd814d846188fbc6099681fd87b cf2b96d70adb42ccb58519dafd36dd1a--4ccdfcd814d846188fbc6099681fd87b 3345219a6e494ef3a26ddca28d129496 t = 10 4ccdfcd814d846188fbc6099681fd87b--3345219a6e494ef3a26ddca28d129496 3345219a6e494ef3a26ddca28d129496--1d8ad8cf035a4c8f9f4178bfe00229eb b7399478eb3f4cbfabd52a9b263eb36a 5a047ea5f9294a3fbe586ae98395d311 RX(0.5) 45d8022a8ebe42f8a0aedba400bf6412--5a047ea5f9294a3fbe586ae98395d311 b20f7c7738b14fcb953c2949c9ef0d15 X 5a047ea5f9294a3fbe586ae98395d311--b20f7c7738b14fcb953c2949c9ef0d15 b20f7c7738b14fcb953c2949c9ef0d15--4ccdfcd814d846188fbc6099681fd87b 3fc2b94a4a1f40fa93a485d959f5a4dc b20f7c7738b14fcb953c2949c9ef0d15--3fc2b94a4a1f40fa93a485d959f5a4dc 3fc2b94a4a1f40fa93a485d959f5a4dc--b7399478eb3f4cbfabd52a9b263eb36a <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_e851226b55454f8091e69738cc5f53bb HEA cluster_4b69cef6de2f4bc493d7722abd465207 Tower Fourier FM eec0e26cf9ac4b79b77550ab4f72f67d 0 44873bc822d14c18bb7b10e0758bffff RX(1.0*phi) eec0e26cf9ac4b79b77550ab4f72f67d--44873bc822d14c18bb7b10e0758bffff 554b3775e1574476bd3b5f6f196d10f9 1 79754e34c01f47aca37e7f8399c9b42b RX(theta\u2080) 44873bc822d14c18bb7b10e0758bffff--79754e34c01f47aca37e7f8399c9b42b a302a37a6ef94541b8557b46834fa116 RY(theta\u2084) 79754e34c01f47aca37e7f8399c9b42b--a302a37a6ef94541b8557b46834fa116 933a61985a7e445f8943593cde380ba5 RX(theta\u2088) a302a37a6ef94541b8557b46834fa116--933a61985a7e445f8943593cde380ba5 5c37d3f654d240ac856d3fd76ad09a0a 933a61985a7e445f8943593cde380ba5--5c37d3f654d240ac856d3fd76ad09a0a beabbd1a84ea46d0852e7a864e9d72b4 5c37d3f654d240ac856d3fd76ad09a0a--beabbd1a84ea46d0852e7a864e9d72b4 45d723772e46403e97991911bf61bb17 RX(theta\u2081\u2082) beabbd1a84ea46d0852e7a864e9d72b4--45d723772e46403e97991911bf61bb17 1b630617d6b84ff78256df82374865fa RY(theta\u2081\u2086) 45d723772e46403e97991911bf61bb17--1b630617d6b84ff78256df82374865fa 695cf3bd2c514c7f8f4000af4f1ef1a4 RX(theta\u2082\u2080) 1b630617d6b84ff78256df82374865fa--695cf3bd2c514c7f8f4000af4f1ef1a4 e8b9d1cb429049c4a5d8840a8d0302d9 695cf3bd2c514c7f8f4000af4f1ef1a4--e8b9d1cb429049c4a5d8840a8d0302d9 843791828bb34b60858a835afd51b7a3 e8b9d1cb429049c4a5d8840a8d0302d9--843791828bb34b60858a835afd51b7a3 0a97ef68283c4095ab717911a5a3ee2b 843791828bb34b60858a835afd51b7a3--0a97ef68283c4095ab717911a5a3ee2b 56cf3a21352841d783d37b14dcdf6518 6daf50d19a3a4988b6814c90e20196f4 RX(2.0*phi) 554b3775e1574476bd3b5f6f196d10f9--6daf50d19a3a4988b6814c90e20196f4 cf5e575adf6649d6a400fe6d1413a982 2 ceaaf4b1615a4bbeaa0e84b98cc95fdd RX(theta\u2081) 6daf50d19a3a4988b6814c90e20196f4--ceaaf4b1615a4bbeaa0e84b98cc95fdd 3ae79cbb215c49ef92b4601d095c1327 RY(theta\u2085) ceaaf4b1615a4bbeaa0e84b98cc95fdd--3ae79cbb215c49ef92b4601d095c1327 1901b3a797fb4080b2f07ebc436f0530 RX(theta\u2089) 3ae79cbb215c49ef92b4601d095c1327--1901b3a797fb4080b2f07ebc436f0530 f7817c2397114d45865f69928c6e5476 X 1901b3a797fb4080b2f07ebc436f0530--f7817c2397114d45865f69928c6e5476 f7817c2397114d45865f69928c6e5476--5c37d3f654d240ac856d3fd76ad09a0a 7ad81dd45304454c8ef65a3f1c2725bf f7817c2397114d45865f69928c6e5476--7ad81dd45304454c8ef65a3f1c2725bf 290a89afdda4468ea003f2a093938f0e RX(theta\u2081\u2083) 7ad81dd45304454c8ef65a3f1c2725bf--290a89afdda4468ea003f2a093938f0e e4c3c3f229c649a6a20344f98527f350 RY(theta\u2081\u2087) 290a89afdda4468ea003f2a093938f0e--e4c3c3f229c649a6a20344f98527f350 003905bb675548f5bbd076aa896e6ffb RX(theta\u2082\u2081) e4c3c3f229c649a6a20344f98527f350--003905bb675548f5bbd076aa896e6ffb 95fcc00c367e49b9b5bd96df7a8dc99a X 003905bb675548f5bbd076aa896e6ffb--95fcc00c367e49b9b5bd96df7a8dc99a 95fcc00c367e49b9b5bd96df7a8dc99a--e8b9d1cb429049c4a5d8840a8d0302d9 d024be2bf17a4c51ab165524979ba11a 95fcc00c367e49b9b5bd96df7a8dc99a--d024be2bf17a4c51ab165524979ba11a d024be2bf17a4c51ab165524979ba11a--56cf3a21352841d783d37b14dcdf6518 f95cc9bffe754ae4afaa033d2392595c ce7d9736d23d4fcca0b734cbc9f657f6 RX(3.0*phi) cf5e575adf6649d6a400fe6d1413a982--ce7d9736d23d4fcca0b734cbc9f657f6 2699085219aa461a9eadf8d49f367a55 3 08f469a6198d438a8670c8a4162aa025 RX(theta\u2082) ce7d9736d23d4fcca0b734cbc9f657f6--08f469a6198d438a8670c8a4162aa025 8f42d007eb244aeaafe130a6275f5bfc RY(theta\u2086) 08f469a6198d438a8670c8a4162aa025--8f42d007eb244aeaafe130a6275f5bfc 7b675896924843b6b41f2af20798907e RX(theta\u2081\u2080) 8f42d007eb244aeaafe130a6275f5bfc--7b675896924843b6b41f2af20798907e 3734db71883e4902bbaece18413b4f09 7b675896924843b6b41f2af20798907e--3734db71883e4902bbaece18413b4f09 dae556c540d64da69438a3c28692fcae X 3734db71883e4902bbaece18413b4f09--dae556c540d64da69438a3c28692fcae dae556c540d64da69438a3c28692fcae--7ad81dd45304454c8ef65a3f1c2725bf 0a88adece9d54eae84ed238b6b79c405 RX(theta\u2081\u2084) dae556c540d64da69438a3c28692fcae--0a88adece9d54eae84ed238b6b79c405 6f55497b5be84cdca2f0cab306a93031 RY(theta\u2081\u2088) 0a88adece9d54eae84ed238b6b79c405--6f55497b5be84cdca2f0cab306a93031 4c7e4d3864ea4c54a44c4d4e7fae4740 RX(theta\u2082\u2082) 6f55497b5be84cdca2f0cab306a93031--4c7e4d3864ea4c54a44c4d4e7fae4740 756a8c1285f54bbfac00ff9e7454e172 4c7e4d3864ea4c54a44c4d4e7fae4740--756a8c1285f54bbfac00ff9e7454e172 1e9a005efb3840f28ad091afcecf2e8f X 756a8c1285f54bbfac00ff9e7454e172--1e9a005efb3840f28ad091afcecf2e8f 1e9a005efb3840f28ad091afcecf2e8f--d024be2bf17a4c51ab165524979ba11a 1e9a005efb3840f28ad091afcecf2e8f--f95cc9bffe754ae4afaa033d2392595c f00313b4e3cb4e56af2a38ba6179785a 3f743f59c0874f5e8c70306261d3b0d3 RX(4.0*phi) 2699085219aa461a9eadf8d49f367a55--3f743f59c0874f5e8c70306261d3b0d3 b239b1611832434fafa7d81b823c20fa RX(theta\u2083) 3f743f59c0874f5e8c70306261d3b0d3--b239b1611832434fafa7d81b823c20fa da1d4d327afe480598080fa467479caa RY(theta\u2087) b239b1611832434fafa7d81b823c20fa--da1d4d327afe480598080fa467479caa a48563c5ec3e4a928f554cc1bd828f69 RX(theta\u2081\u2081) da1d4d327afe480598080fa467479caa--a48563c5ec3e4a928f554cc1bd828f69 7fdfa8fc083c4e94bf744cee8fe014d8 X a48563c5ec3e4a928f554cc1bd828f69--7fdfa8fc083c4e94bf744cee8fe014d8 7fdfa8fc083c4e94bf744cee8fe014d8--3734db71883e4902bbaece18413b4f09 1a3a7ad6dc754e6485192bfefb8404e6 7fdfa8fc083c4e94bf744cee8fe014d8--1a3a7ad6dc754e6485192bfefb8404e6 a8b00aad1a4e47b193cbaf5c36ef9906 RX(theta\u2081\u2085) 1a3a7ad6dc754e6485192bfefb8404e6--a8b00aad1a4e47b193cbaf5c36ef9906 aa2106ad25d74a63a00c369d642656e6 RY(theta\u2081\u2089) a8b00aad1a4e47b193cbaf5c36ef9906--aa2106ad25d74a63a00c369d642656e6 57e7b133197241048d2c8a97d09c86e0 RX(theta\u2082\u2083) aa2106ad25d74a63a00c369d642656e6--57e7b133197241048d2c8a97d09c86e0 8943396161334737a90e7458d547ce93 X 57e7b133197241048d2c8a97d09c86e0--8943396161334737a90e7458d547ce93 8943396161334737a90e7458d547ce93--756a8c1285f54bbfac00ff9e7454e172 6df92e44a2444c9687d7de93ffe2fd07 8943396161334737a90e7458d547ce93--6df92e44a2444c9687d7de93ffe2fd07 6df92e44a2444c9687d7de93ffe2fd07--f00313b4e3cb4e56af2a38ba6179785a <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_1f2e64d452df4f4685b5264a41542ece Obs. cluster_6ecb97dd336b429a9b2642ac3f9b3c5f cluster_3de192d14bd9448b8e4a17a29d4a070e HEA d08dec7bc7e641d9bb4410a963ddad97 0 6362823bfc0c431cbafa88629d373c6c RX(theta\u2080) d08dec7bc7e641d9bb4410a963ddad97--6362823bfc0c431cbafa88629d373c6c e22d7fe87de747cb80310c9dd70f3c07 1 a11ca3434be3409d8bee106ffaf9fc77 RY(theta\u2083) 6362823bfc0c431cbafa88629d373c6c--a11ca3434be3409d8bee106ffaf9fc77 65679b3ba542416983c18b02c86da0a4 RX(theta\u2086) a11ca3434be3409d8bee106ffaf9fc77--65679b3ba542416983c18b02c86da0a4 e1e2a645cc4c4e588da28c9f454115db 65679b3ba542416983c18b02c86da0a4--e1e2a645cc4c4e588da28c9f454115db 3802dd6f7f7b4422ba53a48249b8c05f e1e2a645cc4c4e588da28c9f454115db--3802dd6f7f7b4422ba53a48249b8c05f fcbf89a953e447e997a00c46d2c4789b RX(theta\u2089) 3802dd6f7f7b4422ba53a48249b8c05f--fcbf89a953e447e997a00c46d2c4789b 0866aaa6b2e74457ab1ad2b2a22343a8 RY(theta\u2081\u2082) fcbf89a953e447e997a00c46d2c4789b--0866aaa6b2e74457ab1ad2b2a22343a8 3aa614a9a5d54d62ba1160763ea32ac3 RX(theta\u2081\u2085) 0866aaa6b2e74457ab1ad2b2a22343a8--3aa614a9a5d54d62ba1160763ea32ac3 f117f7fcec974d889050216ca5e2202f 3aa614a9a5d54d62ba1160763ea32ac3--f117f7fcec974d889050216ca5e2202f da01574b5cb4431f9f1c3c585ffaeac7 f117f7fcec974d889050216ca5e2202f--da01574b5cb4431f9f1c3c585ffaeac7 f6ff5edd72fe4decb945b5a506be07a6 da01574b5cb4431f9f1c3c585ffaeac7--f6ff5edd72fe4decb945b5a506be07a6 d72d07afc2f74f26861803152c350f49 f6ff5edd72fe4decb945b5a506be07a6--d72d07afc2f74f26861803152c350f49 04348084acf04dd2ae8ece36ede69109 d2b455cecda54e6d9c96318dd1833209 RX(theta\u2081) e22d7fe87de747cb80310c9dd70f3c07--d2b455cecda54e6d9c96318dd1833209 acb617c980b34b3ab5d0ab73b3eed746 2 2dab2c9c972d4fef988bb39000ed7667 RY(theta\u2084) d2b455cecda54e6d9c96318dd1833209--2dab2c9c972d4fef988bb39000ed7667 894923cadc904cc88fbd6cd05e637b50 RX(theta\u2087) 2dab2c9c972d4fef988bb39000ed7667--894923cadc904cc88fbd6cd05e637b50 89b3fbb084d647eda2e9b5623cd53b4e X 894923cadc904cc88fbd6cd05e637b50--89b3fbb084d647eda2e9b5623cd53b4e 89b3fbb084d647eda2e9b5623cd53b4e--e1e2a645cc4c4e588da28c9f454115db 50bd348fb3f74dcb82dd06b8bbc990b7 89b3fbb084d647eda2e9b5623cd53b4e--50bd348fb3f74dcb82dd06b8bbc990b7 31c36ba7468948c192e589e919274bef RX(theta\u2081\u2080) 50bd348fb3f74dcb82dd06b8bbc990b7--31c36ba7468948c192e589e919274bef b66e7d15bbd1474788a48a7060b2c14a RY(theta\u2081\u2083) 31c36ba7468948c192e589e919274bef--b66e7d15bbd1474788a48a7060b2c14a 68d1a96b9c014c40b9684d65c8f6ebe2 RX(theta\u2081\u2086) b66e7d15bbd1474788a48a7060b2c14a--68d1a96b9c014c40b9684d65c8f6ebe2 40bfa95beb4745f9a9b8a4b21cd18d8e X 68d1a96b9c014c40b9684d65c8f6ebe2--40bfa95beb4745f9a9b8a4b21cd18d8e 40bfa95beb4745f9a9b8a4b21cd18d8e--f117f7fcec974d889050216ca5e2202f 5f6d96c7750e47fdac3c2b04a78f16b9 40bfa95beb4745f9a9b8a4b21cd18d8e--5f6d96c7750e47fdac3c2b04a78f16b9 724f92dbb4004f4db592b62d4c68d219 AddBlock 5f6d96c7750e47fdac3c2b04a78f16b9--724f92dbb4004f4db592b62d4c68d219 724f92dbb4004f4db592b62d4c68d219--04348084acf04dd2ae8ece36ede69109 48656ee100024cc299666d587631d454 435b4125c9a242a39d9625ab980961a0 RX(theta\u2082) acb617c980b34b3ab5d0ab73b3eed746--435b4125c9a242a39d9625ab980961a0 02c2d2d09a3a437985fbfa1831a4eb66 RY(theta\u2085) 435b4125c9a242a39d9625ab980961a0--02c2d2d09a3a437985fbfa1831a4eb66 5e40c5421e0e48e0ad11aa913fa0237f RX(theta\u2088) 02c2d2d09a3a437985fbfa1831a4eb66--5e40c5421e0e48e0ad11aa913fa0237f 30d74566871946048a0ab281143161a3 5e40c5421e0e48e0ad11aa913fa0237f--30d74566871946048a0ab281143161a3 58669962b08e4bab8b44c73e8be998ee X 30d74566871946048a0ab281143161a3--58669962b08e4bab8b44c73e8be998ee 58669962b08e4bab8b44c73e8be998ee--50bd348fb3f74dcb82dd06b8bbc990b7 469309d52d864e998889829cb15c0034 RX(theta\u2081\u2081) 58669962b08e4bab8b44c73e8be998ee--469309d52d864e998889829cb15c0034 5be51dbdb287480f8a688e1dceee08bc RY(theta\u2081\u2084) 469309d52d864e998889829cb15c0034--5be51dbdb287480f8a688e1dceee08bc 2c21996ca2524f12a5ad28a4e9ecdf0a RX(theta\u2081\u2087) 5be51dbdb287480f8a688e1dceee08bc--2c21996ca2524f12a5ad28a4e9ecdf0a 203f66f79c9b48d68901fbfb0d3395dc 2c21996ca2524f12a5ad28a4e9ecdf0a--203f66f79c9b48d68901fbfb0d3395dc c50e427a61b1406bbfc6a1300225b047 X 203f66f79c9b48d68901fbfb0d3395dc--c50e427a61b1406bbfc6a1300225b047 c50e427a61b1406bbfc6a1300225b047--5f6d96c7750e47fdac3c2b04a78f16b9 4bd8b839556f497592e85be7cdcf714e c50e427a61b1406bbfc6a1300225b047--4bd8b839556f497592e85be7cdcf714e 4bd8b839556f497592e85be7cdcf714e--48656ee100024cc299666d587631d454 <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 b6ea8a86bae245e9b55ff86e372e5076 0 f572e90184ac451aab79dcb761bea0a3 b6ea8a86bae245e9b55ff86e372e5076--f572e90184ac451aab79dcb761bea0a3 cc563b03ae104d2cb7e0105c1676e5ce 1 158c9f0d67af4212b89778814fe8fce4 cd612778277f4fe8a350b264bbc7ad35 f572e90184ac451aab79dcb761bea0a3--cd612778277f4fe8a350b264bbc7ad35 fa7a2435eb63476d9c05c54a3d6fcc9f 158c9f0d67af4212b89778814fe8fce4--fa7a2435eb63476d9c05c54a3d6fcc9f 51ea6dbd93484158a2bf96bb8c370f4e a25f85f2c0154c9a843f5748dd67c410 fa7a2435eb63476d9c05c54a3d6fcc9f--a25f85f2c0154c9a843f5748dd67c410 56a7c943f01f4ce5ac1b841ffdc6cf7a 51ea6dbd93484158a2bf96bb8c370f4e--56a7c943f01f4ce5ac1b841ffdc6cf7a 271b851e69f44986b7e697523ed53729 65d109788c064c02a51d8a0e6d1a7f82 cc563b03ae104d2cb7e0105c1676e5ce--65d109788c064c02a51d8a0e6d1a7f82 998a55f974e543f9ae3ac30269ed0c69 2 65d109788c064c02a51d8a0e6d1a7f82--158c9f0d67af4212b89778814fe8fce4 23729789557f40b1be4b7794282b0a9d cd612778277f4fe8a350b264bbc7ad35--23729789557f40b1be4b7794282b0a9d bb3d54bb0edb48f88e83a3fdfcef66a7 23729789557f40b1be4b7794282b0a9d--bb3d54bb0edb48f88e83a3fdfcef66a7 bb3d54bb0edb48f88e83a3fdfcef66a7--271b851e69f44986b7e697523ed53729 7243d49a57fa469f96a3b9606c58b2fd 5a3c759db20c4c9d8a4918d3e83db756 998a55f974e543f9ae3ac30269ed0c69--5a3c759db20c4c9d8a4918d3e83db756 c9b127d85e934403b136b5be7520c43b 3 a7429a3a0cc74394bd9b2c7bc0a8e275 5a3c759db20c4c9d8a4918d3e83db756--a7429a3a0cc74394bd9b2c7bc0a8e275 fdeeb7b58d79440890a2e5d0f9267b9b a7429a3a0cc74394bd9b2c7bc0a8e275--fdeeb7b58d79440890a2e5d0f9267b9b b902aa135bcb42e48770ee7fa6006b47 fdeeb7b58d79440890a2e5d0f9267b9b--b902aa135bcb42e48770ee7fa6006b47 b902aa135bcb42e48770ee7fa6006b47--7243d49a57fa469f96a3b9606c58b2fd 590c9b2957cc422aaedd205f683d0fcd dfc19db35e3c46a1b463a230f462eb77 c9b127d85e934403b136b5be7520c43b--dfc19db35e3c46a1b463a230f462eb77 dc5329fdb79841c98543d49967d6ea2d dfc19db35e3c46a1b463a230f462eb77--dc5329fdb79841c98543d49967d6ea2d 72acef8e1f1f40bf98ef7722cbf5c3ac dc5329fdb79841c98543d49967d6ea2d--72acef8e1f1f40bf98ef7722cbf5c3ac 72acef8e1f1f40bf98ef7722cbf5c3ac--51ea6dbd93484158a2bf96bb8c370f4e a25f85f2c0154c9a843f5748dd67c410--590c9b2957cc422aaedd205f683d0fcd <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 9ed2b425edf2451397a3a303a9122763 0 b3a61a76d03e4fe7bdaa2a1d20ac70c4 9ed2b425edf2451397a3a303a9122763--b3a61a76d03e4fe7bdaa2a1d20ac70c4 21a816877fa24a3b91bbf30e3c0d639b 1 69ce70317e5e4ab7b7941b58047cedd4 b3a61a76d03e4fe7bdaa2a1d20ac70c4--69ce70317e5e4ab7b7941b58047cedd4 c6e9a2583d00462eb91f4fdcc4e0659a 69ce70317e5e4ab7b7941b58047cedd4--c6e9a2583d00462eb91f4fdcc4e0659a 72be0461deef463898bbd3f77b7bc596 c6e9a2583d00462eb91f4fdcc4e0659a--72be0461deef463898bbd3f77b7bc596 943c1fccbeb844539f4974a9b7f4130f 9f4cc71f00844b8c943ceacd7617af07 PHASE(0.5) 21a816877fa24a3b91bbf30e3c0d639b--9f4cc71f00844b8c943ceacd7617af07 ff9e8363ebc34a94a9c897389989122f 2 9f4cc71f00844b8c943ceacd7617af07--b3a61a76d03e4fe7bdaa2a1d20ac70c4 415a6b38c25e4fff97339ab34227000b 9f4cc71f00844b8c943ceacd7617af07--415a6b38c25e4fff97339ab34227000b 90b83476b403401d97c532d9fcd202a8 415a6b38c25e4fff97339ab34227000b--90b83476b403401d97c532d9fcd202a8 90b83476b403401d97c532d9fcd202a8--943c1fccbeb844539f4974a9b7f4130f 3302778de17d47af94413bbdc4066257 7de4bacd606b45199260859eb04fa1ac ff9e8363ebc34a94a9c897389989122f--7de4bacd606b45199260859eb04fa1ac 61390a1f32f94248a8de858ad82217db 3 5a98443088d84d14a4c4fb21ab9a33aa PHASE(0.5) 7de4bacd606b45199260859eb04fa1ac--5a98443088d84d14a4c4fb21ab9a33aa 5a98443088d84d14a4c4fb21ab9a33aa--69ce70317e5e4ab7b7941b58047cedd4 9039a5e3b4554b8bb93f9174b5bc78df 5a98443088d84d14a4c4fb21ab9a33aa--9039a5e3b4554b8bb93f9174b5bc78df 9039a5e3b4554b8bb93f9174b5bc78df--3302778de17d47af94413bbdc4066257 883b6a10eac04d3bb8aa796464222687 863da0eee0f54b1da7d7693e0d8058b8 61390a1f32f94248a8de858ad82217db--863da0eee0f54b1da7d7693e0d8058b8 8a2ae533f9364825b3ff260043ab4398 863da0eee0f54b1da7d7693e0d8058b8--8a2ae533f9364825b3ff260043ab4398 38901dfd97e74c11b2b30cecd660e15e PHASE(0.5) 8a2ae533f9364825b3ff260043ab4398--38901dfd97e74c11b2b30cecd660e15e 38901dfd97e74c11b2b30cecd660e15e--c6e9a2583d00462eb91f4fdcc4e0659a 38901dfd97e74c11b2b30cecd660e15e--883b6a10eac04d3bb8aa796464222687"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from math import pi\nfrom qadence import AnalogRot\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = pi, # [rad/\u03bcs]\n    delta = pi, # [rad/\u03bcs]\n    phase = pi, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run\nfrom qadence.analog.constants import C6_DICT\nfrom math import pi, cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = pi\ndelta = pi\nphase = pi\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run\nfrom math import pi\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = pi\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>wait</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, wait, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = wait(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction\nfrom math import pi\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * pi * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * pi * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice\nfrom math import pi\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = pi)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all the Analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>wait</code> operation initializes a <code>WaitBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = \"global\"</code>. However, the blocks do support local qubit supports, with some constraints. The main constraint is that using <code>kron</code> on operators with different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, wait\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    wait(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    wait(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    wait(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2023-12-12T16:38:53.544407 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>Warning</p> <p>Tutorial to be updated</p> <p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\nfrom pulser.devices import Chadoq2\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n\n\ndef qubo_register_coords(Q):\n    \"\"\"Compute coordinates for register.\"\"\"\n    bitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\n    costs = []\n    # this takes exponential time with the dimension of the QUBO\n    for b in bitstrings:\n        z = np.array(list(b), dtype=int)\n        cost = z.T @ Q @ z\n        costs.append(cost)\n    zipped = zip(bitstrings, costs)\n    sort_zipped = sorted(zipped, key=lambda x: x[1])\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        new_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    costs = []\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom qadence import chain\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRZ, AnalogRX\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\n    z = np.array(list(bitstring), dtype=int)\n    cost = z.T @ Q @ z\n    return cost\n\n# Cost function.\ndef cost_fn(counter, Q):\n    cost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\n    return cost / sum(counter.values())  # Divide by total samples\n\n\n# Weights.\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in Pulser, and set the device specs with the updated Rydberg level.</p> <pre><code># Register with device specs\ndevice = RydbergDevice(rydberg_level = 70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q),\n    device_specs = device\n)\n\n# Analog circuit\nlayers = 2\n\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\n</code></pre> <pre><code>\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(\n    QuantumCircuit(reg, block),\n    backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 101, '10000': 87, '01000': 75, '00110': 72, '00100': 70, '01010': 64, '01001': 62, '00101': 53, '00010': 51, '00011': 48, '01011': 46, '00001': 45, '10010': 45, '00111': 38, '10001': 34, '11000': 29, '10100': 18, '01100': 14, '01110': 11, '01111': 10, '10110': 7, '11001': 7, '11010': 6, '01101': 4, '10101': 2, '10011': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\n    Q = args[0]\n    param = torch.tensor(param)\n    model.reset_vparams(param)\n    C = model.sample({}, n_shots=1000)[0]\n    return cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\n    res = minimize(\n        loss,\n        args=Q,\n        x0=np.random.uniform(1, 10, size=2 * layers),\n        method=\"COBYLA\",\n        tol=1e-8,\n        options={\"maxiter\": 20},\n    )\n\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 233, '01011': 208, '00000': 104, '01001': 85, '00100': 75, '00110': 71, '01000': 70, '00101': 33, '00010': 27, '00001': 26, '01010': 24, '00011': 15, '10011': 11, '10000': 10, '01100': 3, '10101': 2, '01111': 1, '10100': 1, '10110': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-12-12T16:38:55.454519 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=torch.pi,      # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_634a8ea8b91747119f38a15f9107d72a cluster_1ef5c58a31604f1f8ca6bcd9ee6890e2 cluster_cfe8d4dbe594426ca533aea2e73f5eb1 cluster_e735bb9ddef3400d8aa2baea03e3458f cluster_783bf2ab68d24991988fe18e6cd3c069 cluster_a08ae363f10942f5971ad1c2ffc3ddb0 cluster_123c1aedce974fe58726b29cf346099d 2245a229cefe43cb8bcd873044f874ae 0 ec80fb775e4d40bdb20a16eabd5401d7 HamEvo 2245a229cefe43cb8bcd873044f874ae--ec80fb775e4d40bdb20a16eabd5401d7 c6437aae1b51465d9c1525b6dca9454c 1 6c810c31c7e74e918035b52f16615e07 HamEvo ec80fb775e4d40bdb20a16eabd5401d7--6c810c31c7e74e918035b52f16615e07 ec99bc1bfbda4e54944186a5098d57b1 HamEvo 6c810c31c7e74e918035b52f16615e07--ec99bc1bfbda4e54944186a5098d57b1 bb89fe123cba4a51894e39fc64778a04 X ec99bc1bfbda4e54944186a5098d57b1--bb89fe123cba4a51894e39fc64778a04 47dfaaf8d31c4ef0a975ca4a4c1b2ddb HamEvo bb89fe123cba4a51894e39fc64778a04--47dfaaf8d31c4ef0a975ca4a4c1b2ddb e722087a41c7414b961e3647ca49d4f0 HamEvo 47dfaaf8d31c4ef0a975ca4a4c1b2ddb--e722087a41c7414b961e3647ca49d4f0 0d3aea03822849adabd353901e644373 X e722087a41c7414b961e3647ca49d4f0--0d3aea03822849adabd353901e644373 a78c3e3b9f384c4f909fb30bad8ea5d0 0d3aea03822849adabd353901e644373--a78c3e3b9f384c4f909fb30bad8ea5d0 a97245174b8446f990da881dcc9dcaf0 HamEvo a78c3e3b9f384c4f909fb30bad8ea5d0--a97245174b8446f990da881dcc9dcaf0 22933e6bbd2b4ccb85ddc95f38ace563 HamEvo a97245174b8446f990da881dcc9dcaf0--22933e6bbd2b4ccb85ddc95f38ace563 c416e26f28a644e389c1460cc00bfdfc 22933e6bbd2b4ccb85ddc95f38ace563--c416e26f28a644e389c1460cc00bfdfc b31197adb17b4928ab981b1aad26368c c416e26f28a644e389c1460cc00bfdfc--b31197adb17b4928ab981b1aad26368c 315d81ebd84b4e48b3bc7e954564512b 25bb71c703374d0195f03b3717866939 t = -3.142 c6437aae1b51465d9c1525b6dca9454c--25bb71c703374d0195f03b3717866939 6d9fad433d654b2fbefe2fa1bcce9323 2 691aa2734364447cb06a25399f2231c4 t = 3.142 25bb71c703374d0195f03b3717866939--691aa2734364447cb06a25399f2231c4 610f791a185143a9a20373081aa974ac t = -3.142 691aa2734364447cb06a25399f2231c4--610f791a185143a9a20373081aa974ac 46f235f5c8d54bc2ace281ce18d77983 610f791a185143a9a20373081aa974ac--46f235f5c8d54bc2ace281ce18d77983 545c8ba88b914381a31848f4ef1e8d2b t = 1.571 46f235f5c8d54bc2ace281ce18d77983--545c8ba88b914381a31848f4ef1e8d2b 6b3561978737496a8cfd3c7fd2facc0d t = 1.571 545c8ba88b914381a31848f4ef1e8d2b--6b3561978737496a8cfd3c7fd2facc0d 8b3626a631624f11be30887041881f20 6b3561978737496a8cfd3c7fd2facc0d--8b3626a631624f11be30887041881f20 a2e8b47cf9504a3d94214d2760703893 X 8b3626a631624f11be30887041881f20--a2e8b47cf9504a3d94214d2760703893 07961532c4bb4110bebff73db13ea21a t = 1.571 a2e8b47cf9504a3d94214d2760703893--07961532c4bb4110bebff73db13ea21a a73d1452169f4550a8ce8dc92d6d63a3 t = 1.571 07961532c4bb4110bebff73db13ea21a--a73d1452169f4550a8ce8dc92d6d63a3 d09a707850e544369d041210d6d5d6f0 X a73d1452169f4550a8ce8dc92d6d63a3--d09a707850e544369d041210d6d5d6f0 d09a707850e544369d041210d6d5d6f0--315d81ebd84b4e48b3bc7e954564512b 769dde1907ba435e9e88709aa5fcb448 b0e9d15d43894e97b3ad1ed0832a2dc7 6d9fad433d654b2fbefe2fa1bcce9323--b0e9d15d43894e97b3ad1ed0832a2dc7 ce125d51b01541b0b8ae9654871572b8 b0e9d15d43894e97b3ad1ed0832a2dc7--ce125d51b01541b0b8ae9654871572b8 4d6a0daa02f643b6814927fd2a76ba3c ce125d51b01541b0b8ae9654871572b8--4d6a0daa02f643b6814927fd2a76ba3c f2b65156fdff4537b7b6f1f5a33a23f5 X 4d6a0daa02f643b6814927fd2a76ba3c--f2b65156fdff4537b7b6f1f5a33a23f5 aa9198a3c373471fa96b67424cd66171 f2b65156fdff4537b7b6f1f5a33a23f5--aa9198a3c373471fa96b67424cd66171 17d8efb3ec85435b9bd745d8a8370283 aa9198a3c373471fa96b67424cd66171--17d8efb3ec85435b9bd745d8a8370283 8e9dd685593a4aaeb2f2dafd6a50b773 X 17d8efb3ec85435b9bd745d8a8370283--8e9dd685593a4aaeb2f2dafd6a50b773 cee98ba206554a1d96377c497a4c0c77 X 8e9dd685593a4aaeb2f2dafd6a50b773--cee98ba206554a1d96377c497a4c0c77 b151bc58b1fc454f8cd70edc8f0ebb2d cee98ba206554a1d96377c497a4c0c77--b151bc58b1fc454f8cd70edc8f0ebb2d 85ce8e2e101b424cbe9b46bf4cf57c71 b151bc58b1fc454f8cd70edc8f0ebb2d--85ce8e2e101b424cbe9b46bf4cf57c71 d3e366b63c9c48ec9b8c282f6fba9dac X 85ce8e2e101b424cbe9b46bf4cf57c71--d3e366b63c9c48ec9b8c282f6fba9dac d3e366b63c9c48ec9b8c282f6fba9dac--769dde1907ba435e9e88709aa5fcb448 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_d9b646df72b14a72ae7633f763396686 cluster_85751fe7daa842bebdcf00356894bf95 db81a21b2a0f466d802af48ab54d6711 0 28dc4b9dcf90487eb7a079573077c898 X db81a21b2a0f466d802af48ab54d6711--28dc4b9dcf90487eb7a079573077c898 e5d4dc8af1904849a887ffbcc33b7c1a 1 d2f3f7d2959c4d50baf13c4b988fdd85 HamEvo 28dc4b9dcf90487eb7a079573077c898--d2f3f7d2959c4d50baf13c4b988fdd85 a6d9421a0bd34a2389b60eae0b57a370 X d2f3f7d2959c4d50baf13c4b988fdd85--a6d9421a0bd34a2389b60eae0b57a370 5cd9c23853be48c7a28c8dbbb6d00961 a6d9421a0bd34a2389b60eae0b57a370--5cd9c23853be48c7a28c8dbbb6d00961 2468ce05e7d741869bb6d9bde9638c8d HamEvo 5cd9c23853be48c7a28c8dbbb6d00961--2468ce05e7d741869bb6d9bde9638c8d 6e8957b3660b4579943da543359e6b53 2468ce05e7d741869bb6d9bde9638c8d--6e8957b3660b4579943da543359e6b53 9a003926c0ed430e80da046867e8512d 6e8957b3660b4579943da543359e6b53--9a003926c0ed430e80da046867e8512d f9bf76896bef4aac9dbe52548494a397 5f5a4537d9504ebeb36adf5a65fc679a e5d4dc8af1904849a887ffbcc33b7c1a--5f5a4537d9504ebeb36adf5a65fc679a 3cec9b2b5f124d339dee41cfff0e2740 2 30f38ec8edbe4c629bb3cc42a4e2ed40 t = -0.500 5f5a4537d9504ebeb36adf5a65fc679a--30f38ec8edbe4c629bb3cc42a4e2ed40 74d8be659a9e4c6a88539ccbce16e7c0 30f38ec8edbe4c629bb3cc42a4e2ed40--74d8be659a9e4c6a88539ccbce16e7c0 bef651d829734fea85b2da068dcba12a X 74d8be659a9e4c6a88539ccbce16e7c0--bef651d829734fea85b2da068dcba12a 4218830eb7db43aeb32c88ded13fa7cc t = -0.500 bef651d829734fea85b2da068dcba12a--4218830eb7db43aeb32c88ded13fa7cc 6735260f9dcf49e6a756356999f154ce X 4218830eb7db43aeb32c88ded13fa7cc--6735260f9dcf49e6a756356999f154ce 6735260f9dcf49e6a756356999f154ce--f9bf76896bef4aac9dbe52548494a397 0d27ad53848a411190f7677a6c70b4f4 3b579c3763054727a7cab23ce385e53f X 3cec9b2b5f124d339dee41cfff0e2740--3b579c3763054727a7cab23ce385e53f 512ccec2d45540ce93eebc8ebb013330 3b579c3763054727a7cab23ce385e53f--512ccec2d45540ce93eebc8ebb013330 b0755cf04fed43bc8c745d15b8935fba X 512ccec2d45540ce93eebc8ebb013330--b0755cf04fed43bc8c745d15b8935fba 1747b07678b34c5486ba02826cda251f X b0755cf04fed43bc8c745d15b8935fba--1747b07678b34c5486ba02826cda251f b96cd519dddf4e24bf099f34c76da2de 1747b07678b34c5486ba02826cda251f--b96cd519dddf4e24bf099f34c76da2de 8584fd83d4c44199bfefa4fabd27b4ab X b96cd519dddf4e24bf099f34c76da2de--8584fd83d4c44199bfefa4fabd27b4ab 8584fd83d4c44199bfefa4fabd27b4ab--0d27ad53848a411190f7677a6c70b4f4 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_c35d7f5c09ff49c898ef0869d459d682 cluster_c4ccee7c0f6a417bbc030ea4448ca14d 1d47a015a2a6477fa26a7b3c315b6678 0 d6908d9780f3488c9a0a195186789f1f X 1d47a015a2a6477fa26a7b3c315b6678--d6908d9780f3488c9a0a195186789f1f 875ca6876c344ac6a58dc51d8eac49fa 1 c772183b5ffc4b4f90649e9fc680d0ab HamEvo d6908d9780f3488c9a0a195186789f1f--c772183b5ffc4b4f90649e9fc680d0ab 1446509e7b6a41b1abff9b01101bf2c7 X c772183b5ffc4b4f90649e9fc680d0ab--1446509e7b6a41b1abff9b01101bf2c7 217a10a92022449a9386357a2a98ddf5 1446509e7b6a41b1abff9b01101bf2c7--217a10a92022449a9386357a2a98ddf5 72b128e7809c4c92845268db591decc1 HamEvo 217a10a92022449a9386357a2a98ddf5--72b128e7809c4c92845268db591decc1 61075b965e65499183e57eadae520d0d 72b128e7809c4c92845268db591decc1--61075b965e65499183e57eadae520d0d 306df4bc83234c7d81d39ca87c612bad 61075b965e65499183e57eadae520d0d--306df4bc83234c7d81d39ca87c612bad 4560970e4a5b4a6ca123f73a19c45056 85f5004311c24edcbbf3dd5fc0d780fd 875ca6876c344ac6a58dc51d8eac49fa--85f5004311c24edcbbf3dd5fc0d780fd 7fb398f98c8840f8a72f9baea5a2a314 2 5d3b512d289c4a01a19114a708302923 t = -500.000000000000 85f5004311c24edcbbf3dd5fc0d780fd--5d3b512d289c4a01a19114a708302923 45a4c1e226724aeea612b08c35f4742f 5d3b512d289c4a01a19114a708302923--45a4c1e226724aeea612b08c35f4742f 724182a4eda24b5cbefc342dae13a973 X 45a4c1e226724aeea612b08c35f4742f--724182a4eda24b5cbefc342dae13a973 b56dc6389c0149149ae45bdbd3166d84 t = -500.000000000000 724182a4eda24b5cbefc342dae13a973--b56dc6389c0149149ae45bdbd3166d84 cfaec5f5901b4be9ac431c95ed6f9c0c X b56dc6389c0149149ae45bdbd3166d84--cfaec5f5901b4be9ac431c95ed6f9c0c cfaec5f5901b4be9ac431c95ed6f9c0c--4560970e4a5b4a6ca123f73a19c45056 5f89247a26f44c1fb9638ce9c29e51fc 356be98436ed4e3a94c2079a8dfac1de X 7fb398f98c8840f8a72f9baea5a2a314--356be98436ed4e3a94c2079a8dfac1de 4e32a250b8894415b852de79fd0df07b 356be98436ed4e3a94c2079a8dfac1de--4e32a250b8894415b852de79fd0df07b b4ec1c6cd950463980492d9165e57b28 X 4e32a250b8894415b852de79fd0df07b--b4ec1c6cd950463980492d9165e57b28 bd99a0ddaf454b2f8a3945564153e645 X b4ec1c6cd950463980492d9165e57b28--bd99a0ddaf454b2f8a3945564153e645 01eececbabf1420aa75b929e57825aaf bd99a0ddaf454b2f8a3945564153e645--01eececbabf1420aa75b929e57825aaf 65a3e993c4904643a572a059527ff0cc X 01eececbabf1420aa75b929e57825aaf--65a3e993c4904643a572a059527ff0cc 65a3e993c4904643a572a059527ff0cc--5f89247a26f44c1fb9638ce9c29e51fc <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.847190727211437, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 27, '11': 23})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-12-12T16:38:55.970798 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-12-12T16:38:56.092806 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 23})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-torch.pi / 2),\n        wait(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([torch.pi / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-12-12T16:38:56.758174 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(torch.pi/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-12-12T16:38:56.906547 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.2723])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.2742])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(torch.pi)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.1391]) The trained function value:  tensor([[0.1391]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\n\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.3978-0.0938j, -0.7308-0.5009j, -0.1796-0.0595j,  0.0092+0.1104j],\n         [ 0.6745-0.4435j,  0.3860+0.1615j, -0.2943-0.2427j, -0.1161-0.1194j],\n         [ 0.0071-0.3775j, -0.0791-0.1563j,  0.7486-0.2045j,  0.0188-0.4734j],\n         [-0.1418-0.1366j,  0.0787-0.0558j, -0.0827-0.4578j,  0.8310+0.2120j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * pi),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    transformed_feature = fm_parameter(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    # Backwards compatibility\n    if fm_type == \"tower\":\n        logger.warning(\"Forcing reupload scaling strategy to TOWER\")\n        reupload_scaling = ReuploadScaling.TOWER\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    for i, qubit in enumerate(support):\n        op_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        int_fn = INTERACTION_DICT.get(interaction, None)\n        if int_fn is None:\n            raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f9d77f4b1c0&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f9d77f4acb0&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.8553, 0.4821]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n[tensor([0.8860, 0.1588, 0.1412, 0.8215, 0.9256]), tensor([0.6628, 0.0107, 0.0522, 0.5735, 0.7052]), tensor([0.0385, 0.0183, 0.7463, 0.0388, 0.6066])]\n[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.0448-1.9079e-17j, -0.3027+5.5272e-18j],\n        [ 1.0892-2.7965e-17j, -0.4317+1.1084e-17j]])\ntensor([[1.5334-1.1262j, 0.9423-0.6638j],\n        [1.2765-0.4016j, 0.4069-0.1863j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-np.pi / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = np.pi\n    duration = alpha / delta * 1000\n    ps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=0.0)\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter = 1000.0,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    alpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000\n    ps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; WaitBlock:\n    \"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n\n    Returns:\n        a `WaitBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return WaitBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['95f19767-2f46-4729-b84c-2aa29a3ab909', '3aebf18f-3d92-4dcf-a986-fc0876bd59a9'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.7262773469971591\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.450972795899503\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e542d20d-2556-4748-a9ff-7ded19930059', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7a4211c2-9b30-4c2d-9309-9ff0fb080255', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.5107891929577533'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4a014c76-9dd6-4664-b00c-25e93fb36122', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.16650538174477025'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2ef1cdf1-183a-4f83-b20f-6abfda4342df', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.42675966503419094'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b9c5388d-468f-4eab-beda-d6ea742f1281', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6686059935634905'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c24fcd13-3d23-4daa-8420-26f8a8511a40', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.2969019264041437'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ac9f1294-9c34-4e75-ad19-8e99da063850', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.657268166920075'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('32bc5f9e-0f37-40ae-9737-17009ad314a1', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9040698059531549'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b566b930-6443-4365-9a25-810b1ea0a26e', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.11147726187362894'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('d261d493-d6d8-45e5-89bc-130672600003', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.3319225908813115'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('9bb718a8-4793-4292-b62f-471978beb061', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.732528137502527'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ccfa2673-38fa-464b-9b7b-c5e3cfe8faa0', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.6009734758603325'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>10010111\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.0972+0.0300j,  0.7390-0.0408j,  0.2991-0.5066j, -0.2463-0.1876j]])\ntensor([[0.6176-0.7591j, 0.0000+0.0000j, 0.1297-0.1595j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 91, '0010': 3, '0001': 2, '0100': 2, '1000': 2})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[0.1102],\n        [0.0714],\n        [0.1501],\n        [0.0039],\n        [0.0344],\n        [0.1196],\n        [0.0958],\n        [0.1658],\n        [0.0453],\n        [0.1395]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4482],\n        [0.2437],\n        [0.1200],\n        [0.5725],\n        [0.5203]]), tensor([[0.4334],\n        [0.2413],\n        [0.1197],\n        [0.5417],\n        [0.4971]])], 'y2': [tensor([[0.0801],\n        [0.4220],\n        [0.5646],\n        [0.1147],\n        [0.5553]]), tensor([[0.0800],\n        [0.4096],\n        [0.5351],\n        [0.1144],\n        [0.5272]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-12-12T16:39:18.891350 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2023-12-12T16:39:19.450370 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_3f4f7ed1c78e49aa933ba7dc804f9c7d mixing cluster_a1b0ac265b0745e1a13bf62bc00e8ee0 cost cluster_0df34cff03eb4e059022d14f368fdb6b mixing cluster_179cf4f64c1444b3bdb75ad39af30658 cost 63bd11c80b7e476ea7f08058e68db427 0 35d3c132e23d4f01a240602c22e57856 63bd11c80b7e476ea7f08058e68db427--35d3c132e23d4f01a240602c22e57856 fca92a2af5b241709f0171da2592eb2e 1 5225176e356a4a73b6ac5152ff61321a 35d3c132e23d4f01a240602c22e57856--5225176e356a4a73b6ac5152ff61321a e9a6826d65ce47a49d511416523b3f5a 5225176e356a4a73b6ac5152ff61321a--e9a6826d65ce47a49d511416523b3f5a fd1a34474dbe4f9ea6ea4e505f770937 e9a6826d65ce47a49d511416523b3f5a--fd1a34474dbe4f9ea6ea4e505f770937 51f31f777d3e4ee48334569da0c475a8 fd1a34474dbe4f9ea6ea4e505f770937--51f31f777d3e4ee48334569da0c475a8 3caf5c6d86e045adb06b5bb3eb1a7b5f 51f31f777d3e4ee48334569da0c475a8--3caf5c6d86e045adb06b5bb3eb1a7b5f ac2314fe6cbd4d73bd7bf49de47cc827 3caf5c6d86e045adb06b5bb3eb1a7b5f--ac2314fe6cbd4d73bd7bf49de47cc827 715712483ecf48dbb6120ab434b12434 ac2314fe6cbd4d73bd7bf49de47cc827--715712483ecf48dbb6120ab434b12434 dee7dcc36e094977b9f057c5344d8f1a 715712483ecf48dbb6120ab434b12434--dee7dcc36e094977b9f057c5344d8f1a 167e31d2f9524e33a1a4fe9170d6e2cc dee7dcc36e094977b9f057c5344d8f1a--167e31d2f9524e33a1a4fe9170d6e2cc 2e729ab7a8ce45e7b289f3261d1ea2c2 167e31d2f9524e33a1a4fe9170d6e2cc--2e729ab7a8ce45e7b289f3261d1ea2c2 78a5a290d5d940b9918b443c50fc0795 2e729ab7a8ce45e7b289f3261d1ea2c2--78a5a290d5d940b9918b443c50fc0795 d8417c02590a43d489167dab943ba2f9 78a5a290d5d940b9918b443c50fc0795--d8417c02590a43d489167dab943ba2f9 fb47de5f4e504fe3b14b8f80c87fdf36 d8417c02590a43d489167dab943ba2f9--fb47de5f4e504fe3b14b8f80c87fdf36 3d8c08f632ff4632bbb3f5894cb0428c fb47de5f4e504fe3b14b8f80c87fdf36--3d8c08f632ff4632bbb3f5894cb0428c 9f204442fed44186bb61afe6eafe32f8 3d8c08f632ff4632bbb3f5894cb0428c--9f204442fed44186bb61afe6eafe32f8 88c3a79cddef41ddb18560e0e62822d9 9f204442fed44186bb61afe6eafe32f8--88c3a79cddef41ddb18560e0e62822d9 cefef225c45241fc970506fbf51a78c1 88c3a79cddef41ddb18560e0e62822d9--cefef225c45241fc970506fbf51a78c1 839c34136a42429fa558a17753e44e28 cefef225c45241fc970506fbf51a78c1--839c34136a42429fa558a17753e44e28 10db4ff5bb0b4d758444461397083630 839c34136a42429fa558a17753e44e28--10db4ff5bb0b4d758444461397083630 7659bcb3bb9040529e9b8dc3ff3e478d 10db4ff5bb0b4d758444461397083630--7659bcb3bb9040529e9b8dc3ff3e478d 911404d4885d482c857c86d7ad67c13c 7659bcb3bb9040529e9b8dc3ff3e478d--911404d4885d482c857c86d7ad67c13c 351a732dd6c94ee29f7b95fb05e7457d 911404d4885d482c857c86d7ad67c13c--351a732dd6c94ee29f7b95fb05e7457d 09c662d6dc5f421f96eb3b79a3789f32 351a732dd6c94ee29f7b95fb05e7457d--09c662d6dc5f421f96eb3b79a3789f32 c4f4240c8dba49fc902b4380b1f9c6b2 09c662d6dc5f421f96eb3b79a3789f32--c4f4240c8dba49fc902b4380b1f9c6b2 8cda6cc396c84ecc937f33e2eed332ba c4f4240c8dba49fc902b4380b1f9c6b2--8cda6cc396c84ecc937f33e2eed332ba 49c3587cc12149bbbc3db0cdb5421596 8cda6cc396c84ecc937f33e2eed332ba--49c3587cc12149bbbc3db0cdb5421596 7097aec6aec444a7be08e252aae13e76 49c3587cc12149bbbc3db0cdb5421596--7097aec6aec444a7be08e252aae13e76 bd0acd90b34c4cf9920c81a5b193cd28 7097aec6aec444a7be08e252aae13e76--bd0acd90b34c4cf9920c81a5b193cd28 171233fd833b4561b7dd405a9de991b9 bd0acd90b34c4cf9920c81a5b193cd28--171233fd833b4561b7dd405a9de991b9 39726273127241f0831fce012a50ef51 171233fd833b4561b7dd405a9de991b9--39726273127241f0831fce012a50ef51 42e2744042604354bb22ea0bb77cbec9 39726273127241f0831fce012a50ef51--42e2744042604354bb22ea0bb77cbec9 f3e39d04bdfd45d292f74f2bc1ce63ae 42e2744042604354bb22ea0bb77cbec9--f3e39d04bdfd45d292f74f2bc1ce63ae 99cf35de345a4a9f84b754f51ea906db f3e39d04bdfd45d292f74f2bc1ce63ae--99cf35de345a4a9f84b754f51ea906db a2b5a20524e34acaa90d4f422a2ea140 99cf35de345a4a9f84b754f51ea906db--a2b5a20524e34acaa90d4f422a2ea140 0cba3651f2c5418bb8cddaa9e4c161eb a2b5a20524e34acaa90d4f422a2ea140--0cba3651f2c5418bb8cddaa9e4c161eb 2fdbda0c09fd4b7da38f9820b9fab571 0cba3651f2c5418bb8cddaa9e4c161eb--2fdbda0c09fd4b7da38f9820b9fab571 3207f60143cb4a0fbc90d435378049e4 2fdbda0c09fd4b7da38f9820b9fab571--3207f60143cb4a0fbc90d435378049e4 c5dcd3af735a49ca9c861236d6556db2 3207f60143cb4a0fbc90d435378049e4--c5dcd3af735a49ca9c861236d6556db2 6ab4cb0bdf184744a685fbe342bedb53 c5dcd3af735a49ca9c861236d6556db2--6ab4cb0bdf184744a685fbe342bedb53 429d84f98b9b4ac49b1d2ad8aa78e6b7 6ab4cb0bdf184744a685fbe342bedb53--429d84f98b9b4ac49b1d2ad8aa78e6b7 d9917d59eec44f01a2302e6533e72646 429d84f98b9b4ac49b1d2ad8aa78e6b7--d9917d59eec44f01a2302e6533e72646 5614a09cdfc44a139fcd64897fdba88b d9917d59eec44f01a2302e6533e72646--5614a09cdfc44a139fcd64897fdba88b b4b060bbe21f4119b81e8af641df31b4 5614a09cdfc44a139fcd64897fdba88b--b4b060bbe21f4119b81e8af641df31b4 f4e50a368a174a8d998fb1c4c40f4eb7 b4b060bbe21f4119b81e8af641df31b4--f4e50a368a174a8d998fb1c4c40f4eb7 28a38345f6504934bd1d7afff067664c f4e50a368a174a8d998fb1c4c40f4eb7--28a38345f6504934bd1d7afff067664c d80110d37b5b451da0b12dcff5238b14 28a38345f6504934bd1d7afff067664c--d80110d37b5b451da0b12dcff5238b14 6d6fa4f017bf46ab8712f315313256c2 d80110d37b5b451da0b12dcff5238b14--6d6fa4f017bf46ab8712f315313256c2 fc64efbf7ba6496aa11a6d4721bdc33e 6d6fa4f017bf46ab8712f315313256c2--fc64efbf7ba6496aa11a6d4721bdc33e b7774fa5983e43889058d3537869521c fc64efbf7ba6496aa11a6d4721bdc33e--b7774fa5983e43889058d3537869521c 357485d6ea0b429ca6aac1020ce471e8 b7774fa5983e43889058d3537869521c--357485d6ea0b429ca6aac1020ce471e8 861cd7e9020140b49003dbaca245fa2d 357485d6ea0b429ca6aac1020ce471e8--861cd7e9020140b49003dbaca245fa2d a8289d73016f455eaed2cca556ae3d26 861cd7e9020140b49003dbaca245fa2d--a8289d73016f455eaed2cca556ae3d26 b24ae2a406ed435ab2b52cb469263e06 a8289d73016f455eaed2cca556ae3d26--b24ae2a406ed435ab2b52cb469263e06 8fa77bf23e554e14bb5efa0804309a2c b24ae2a406ed435ab2b52cb469263e06--8fa77bf23e554e14bb5efa0804309a2c b78a64d91d26478f94837189a22cac7e 8fa77bf23e554e14bb5efa0804309a2c--b78a64d91d26478f94837189a22cac7e b4fadc7acc3a468f94550a14a9bb67fb b78a64d91d26478f94837189a22cac7e--b4fadc7acc3a468f94550a14a9bb67fb 776470fb88a94d44abab0ae49fe92e4e b4fadc7acc3a468f94550a14a9bb67fb--776470fb88a94d44abab0ae49fe92e4e cefa1ca66fd046f897dd8c7d5e4cb85a 776470fb88a94d44abab0ae49fe92e4e--cefa1ca66fd046f897dd8c7d5e4cb85a 0c120589216f4f4ba7f929faa519943f cefa1ca66fd046f897dd8c7d5e4cb85a--0c120589216f4f4ba7f929faa519943f 2b6d1942436f4c5b8cdea32b859ed3e8 0c120589216f4f4ba7f929faa519943f--2b6d1942436f4c5b8cdea32b859ed3e8 92ccaf9bd860444db681eee797b03548 2b6d1942436f4c5b8cdea32b859ed3e8--92ccaf9bd860444db681eee797b03548 a8756a8782a847f48424dca8aad85f20 92ccaf9bd860444db681eee797b03548--a8756a8782a847f48424dca8aad85f20 6873912d17254e0faf94f7c5d89fdb53 a8756a8782a847f48424dca8aad85f20--6873912d17254e0faf94f7c5d89fdb53 24e06a43d69341c3a9e24f6cd418b763 6873912d17254e0faf94f7c5d89fdb53--24e06a43d69341c3a9e24f6cd418b763 dce572c68f19463fb7d314d773923acc 24e06a43d69341c3a9e24f6cd418b763--dce572c68f19463fb7d314d773923acc 13a964e364704b6fb4651e30c057281c dce572c68f19463fb7d314d773923acc--13a964e364704b6fb4651e30c057281c 259a9bea16644ca0b2e82725e40baa69 13a964e364704b6fb4651e30c057281c--259a9bea16644ca0b2e82725e40baa69 409c5fcd42424263b9d6e01720d4d6f3 259a9bea16644ca0b2e82725e40baa69--409c5fcd42424263b9d6e01720d4d6f3 4e6ea95e82474854aaff654207631ccb 409c5fcd42424263b9d6e01720d4d6f3--4e6ea95e82474854aaff654207631ccb 76f1df3316b54731b5a4dfac88428690 4e6ea95e82474854aaff654207631ccb--76f1df3316b54731b5a4dfac88428690 248841298eb54904be0130f9f601b629 76f1df3316b54731b5a4dfac88428690--248841298eb54904be0130f9f601b629 2cb2caec706e493a8eeb27541bf493e8 248841298eb54904be0130f9f601b629--2cb2caec706e493a8eeb27541bf493e8 485e2f3c2af94b9dba50fdb119eea7ba 2cb2caec706e493a8eeb27541bf493e8--485e2f3c2af94b9dba50fdb119eea7ba b27948fd1b024221a8c6e1e80fe5395e 485e2f3c2af94b9dba50fdb119eea7ba--b27948fd1b024221a8c6e1e80fe5395e 6e63e5c0e3334840a1527254b0c9364f b27948fd1b024221a8c6e1e80fe5395e--6e63e5c0e3334840a1527254b0c9364f 4a1c16b52c8f49409ac7ad63c6190665 6e63e5c0e3334840a1527254b0c9364f--4a1c16b52c8f49409ac7ad63c6190665 0c3fd78e5f0c493c8cf60e95aeb3f408 4a1c16b52c8f49409ac7ad63c6190665--0c3fd78e5f0c493c8cf60e95aeb3f408 e37db79a6c174cab81b324500fbd48a0 0c3fd78e5f0c493c8cf60e95aeb3f408--e37db79a6c174cab81b324500fbd48a0 af1fdbae11b74fa9bd8563aef549067d e37db79a6c174cab81b324500fbd48a0--af1fdbae11b74fa9bd8563aef549067d 6bffbbd483e74783a2e86aa905cf3066 af1fdbae11b74fa9bd8563aef549067d--6bffbbd483e74783a2e86aa905cf3066 b01e2cf623e34a20a629bfe6c9feb446 6bffbbd483e74783a2e86aa905cf3066--b01e2cf623e34a20a629bfe6c9feb446 e5d26a65031847c5aee0384c93af0052 b01e2cf623e34a20a629bfe6c9feb446--e5d26a65031847c5aee0384c93af0052 eb8ebbf5d53a4484a087b4fa8a3dc439 e5d26a65031847c5aee0384c93af0052--eb8ebbf5d53a4484a087b4fa8a3dc439 a4d9f76f4452408687c2755c4e9d1249 eb8ebbf5d53a4484a087b4fa8a3dc439--a4d9f76f4452408687c2755c4e9d1249 719bd9899e294b67ab7dddaac39ce47e a4d9f76f4452408687c2755c4e9d1249--719bd9899e294b67ab7dddaac39ce47e 9ac915fee6b044969ced6814eb5f69a4 719bd9899e294b67ab7dddaac39ce47e--9ac915fee6b044969ced6814eb5f69a4 e6d5baef01a24afeaebdea2cfe190266 9ac915fee6b044969ced6814eb5f69a4--e6d5baef01a24afeaebdea2cfe190266 c50fb5e4a6aa451b822c8fa48c7b694b e6d5baef01a24afeaebdea2cfe190266--c50fb5e4a6aa451b822c8fa48c7b694b dc475b1feee94d40a09f6678bc279657 c50fb5e4a6aa451b822c8fa48c7b694b--dc475b1feee94d40a09f6678bc279657 3ca1aac745b540ec8354c0e9c8e34a91 dc475b1feee94d40a09f6678bc279657--3ca1aac745b540ec8354c0e9c8e34a91 5bae55a7665d4ab4b6b120b826916887 3ca1aac745b540ec8354c0e9c8e34a91--5bae55a7665d4ab4b6b120b826916887 2a498743541f4694ac4ef83f6eaae5e6 5bae55a7665d4ab4b6b120b826916887--2a498743541f4694ac4ef83f6eaae5e6 80cb8e3405364fae92353bf532ed0c78 2a498743541f4694ac4ef83f6eaae5e6--80cb8e3405364fae92353bf532ed0c78 e02f3ba6248c47cbaede371bb2a25640 80cb8e3405364fae92353bf532ed0c78--e02f3ba6248c47cbaede371bb2a25640 95eecac4810740d6b64e2e470b176108 e02f3ba6248c47cbaede371bb2a25640--95eecac4810740d6b64e2e470b176108 0eb80b04c1c845d8b1054cb5c10b8c50 95eecac4810740d6b64e2e470b176108--0eb80b04c1c845d8b1054cb5c10b8c50 f16fd631ce1a41b982885cbe967211ee 0eb80b04c1c845d8b1054cb5c10b8c50--f16fd631ce1a41b982885cbe967211ee 761dfa12255540f99bb019e386bb08bb f16fd631ce1a41b982885cbe967211ee--761dfa12255540f99bb019e386bb08bb b969ba4a39ac49f7bbea64a35c7a2f0e 761dfa12255540f99bb019e386bb08bb--b969ba4a39ac49f7bbea64a35c7a2f0e a5e808532f504673b0e61cffac83e562 b969ba4a39ac49f7bbea64a35c7a2f0e--a5e808532f504673b0e61cffac83e562 5b77fc6dbcf64b979c5d645c9cbf6701 a5e808532f504673b0e61cffac83e562--5b77fc6dbcf64b979c5d645c9cbf6701 1c3836bb9aad417f87b770c61fd6ec42 5b77fc6dbcf64b979c5d645c9cbf6701--1c3836bb9aad417f87b770c61fd6ec42 503502c56599432ba1aa391a4a56d904 1c3836bb9aad417f87b770c61fd6ec42--503502c56599432ba1aa391a4a56d904 8e637bac78934a6e8f1e168e6f2a6d70 503502c56599432ba1aa391a4a56d904--8e637bac78934a6e8f1e168e6f2a6d70 2b4038a8bfa949378c7ea19ac3281ee0 8e637bac78934a6e8f1e168e6f2a6d70--2b4038a8bfa949378c7ea19ac3281ee0 18b255065d0f4b4dab8334d4c6c21055 2b4038a8bfa949378c7ea19ac3281ee0--18b255065d0f4b4dab8334d4c6c21055 0673625335444f1683d64f1aac1729db 18b255065d0f4b4dab8334d4c6c21055--0673625335444f1683d64f1aac1729db ebe40a3fb8bf4af68a7ecab629636abc 0673625335444f1683d64f1aac1729db--ebe40a3fb8bf4af68a7ecab629636abc 16c5e18c340248fca005e897bbf778e2 ebe40a3fb8bf4af68a7ecab629636abc--16c5e18c340248fca005e897bbf778e2 e36cb8f55cae49ea82fdd2a153efab9f 16c5e18c340248fca005e897bbf778e2--e36cb8f55cae49ea82fdd2a153efab9f eef96f1107024e269865813c787bf4a8 e36cb8f55cae49ea82fdd2a153efab9f--eef96f1107024e269865813c787bf4a8 6a9a319843bd435db45bf40fa85a09e0 eef96f1107024e269865813c787bf4a8--6a9a319843bd435db45bf40fa85a09e0 9fa704049c004e758bfd9f4036e5601a 6a9a319843bd435db45bf40fa85a09e0--9fa704049c004e758bfd9f4036e5601a 3b404dd7b5e94d87abad48775b45db0b 9fa704049c004e758bfd9f4036e5601a--3b404dd7b5e94d87abad48775b45db0b d68013f5fe4441cca2d5660bafce63d7 3b404dd7b5e94d87abad48775b45db0b--d68013f5fe4441cca2d5660bafce63d7 cf6beb4351104e77a5f254841fb00523 d68013f5fe4441cca2d5660bafce63d7--cf6beb4351104e77a5f254841fb00523 08cf19d0a8914753bc7391f246eb2e93 cf6beb4351104e77a5f254841fb00523--08cf19d0a8914753bc7391f246eb2e93 33b7a03648414c7d83f52ca2a2c66ab7 08cf19d0a8914753bc7391f246eb2e93--33b7a03648414c7d83f52ca2a2c66ab7 a8e9deb57dec450189e1855122ea10e1 33b7a03648414c7d83f52ca2a2c66ab7--a8e9deb57dec450189e1855122ea10e1 83fd4262ce5e4dcdaded8e336f5afc3c RX(b00) a8e9deb57dec450189e1855122ea10e1--83fd4262ce5e4dcdaded8e336f5afc3c a5b19d2c9842463ca3474d46c8047457 83fd4262ce5e4dcdaded8e336f5afc3c--a5b19d2c9842463ca3474d46c8047457 e751cc4e270d4ddabecdd925e10c4abd a5b19d2c9842463ca3474d46c8047457--e751cc4e270d4ddabecdd925e10c4abd e4979b76dcc6402394f8430adce7e97d e751cc4e270d4ddabecdd925e10c4abd--e4979b76dcc6402394f8430adce7e97d 913879d862204e719c8412c4050f279f e4979b76dcc6402394f8430adce7e97d--913879d862204e719c8412c4050f279f a61aabbb5564480d8a4a26e71e079d0e 913879d862204e719c8412c4050f279f--a61aabbb5564480d8a4a26e71e079d0e 8236d2b3c40e4163bc10b898ae4a0438 a61aabbb5564480d8a4a26e71e079d0e--8236d2b3c40e4163bc10b898ae4a0438 b8603beb36fb4d888b1b16dcf5dc9d65 8236d2b3c40e4163bc10b898ae4a0438--b8603beb36fb4d888b1b16dcf5dc9d65 178d8290f85d4ade979e0d2347941cdb b8603beb36fb4d888b1b16dcf5dc9d65--178d8290f85d4ade979e0d2347941cdb d7d0d8ec945f4fa99f7c41706fcf3e8b 178d8290f85d4ade979e0d2347941cdb--d7d0d8ec945f4fa99f7c41706fcf3e8b 1ce8db4d8bb54a96863f5dc9a97affed d7d0d8ec945f4fa99f7c41706fcf3e8b--1ce8db4d8bb54a96863f5dc9a97affed eed9e4ce8b244180b2701dde396e1667 1ce8db4d8bb54a96863f5dc9a97affed--eed9e4ce8b244180b2701dde396e1667 c3658b7690014a28ad344833750178ca eed9e4ce8b244180b2701dde396e1667--c3658b7690014a28ad344833750178ca 02a15b304f684ad28380f6082477eb83 c3658b7690014a28ad344833750178ca--02a15b304f684ad28380f6082477eb83 551c587f7ecf447292ae69e867b8e7f1 02a15b304f684ad28380f6082477eb83--551c587f7ecf447292ae69e867b8e7f1 ead30ed1928848219944776086d66b4e 551c587f7ecf447292ae69e867b8e7f1--ead30ed1928848219944776086d66b4e 5641f2a05e634501a658168e8f833483 ead30ed1928848219944776086d66b4e--5641f2a05e634501a658168e8f833483 9a33fcaf6bf441ed841dd62210ce7aee 5641f2a05e634501a658168e8f833483--9a33fcaf6bf441ed841dd62210ce7aee 063bb19be22440e3b484f1c4b3b2fe4e 9a33fcaf6bf441ed841dd62210ce7aee--063bb19be22440e3b484f1c4b3b2fe4e 94c46c30573c45ccacec279bd8710f61 063bb19be22440e3b484f1c4b3b2fe4e--94c46c30573c45ccacec279bd8710f61 6a4b00ba7b8b4c98861f302492368972 94c46c30573c45ccacec279bd8710f61--6a4b00ba7b8b4c98861f302492368972 0038059d131b4be0ab59f19ce090a2e4 6a4b00ba7b8b4c98861f302492368972--0038059d131b4be0ab59f19ce090a2e4 bfbc38af25e14ba3a6f22b87cde94f7c 0038059d131b4be0ab59f19ce090a2e4--bfbc38af25e14ba3a6f22b87cde94f7c dab243eee9524eb6bd311f02c0ddd016 bfbc38af25e14ba3a6f22b87cde94f7c--dab243eee9524eb6bd311f02c0ddd016 9afe990f50d440a39fae208284190656 dab243eee9524eb6bd311f02c0ddd016--9afe990f50d440a39fae208284190656 35aac114faf44cf1b3072829b5fdf5f4 9afe990f50d440a39fae208284190656--35aac114faf44cf1b3072829b5fdf5f4 250fe77893eb478ea3dae55ed13a0700 35aac114faf44cf1b3072829b5fdf5f4--250fe77893eb478ea3dae55ed13a0700 ae1496daeb2f491d8d0c4c7dfe4759eb 250fe77893eb478ea3dae55ed13a0700--ae1496daeb2f491d8d0c4c7dfe4759eb 814be57eecac462ab80f0c0385161307 ae1496daeb2f491d8d0c4c7dfe4759eb--814be57eecac462ab80f0c0385161307 ff15682802d5485b888cc1e4292705be 814be57eecac462ab80f0c0385161307--ff15682802d5485b888cc1e4292705be d8023aace54b408689047f44aece3d52 ff15682802d5485b888cc1e4292705be--d8023aace54b408689047f44aece3d52 335097029fe94fa092e64d3f28f12eea d8023aace54b408689047f44aece3d52--335097029fe94fa092e64d3f28f12eea a6a429d968cd4c40b6b96275421235c6 335097029fe94fa092e64d3f28f12eea--a6a429d968cd4c40b6b96275421235c6 ba0e7a472f964874bedfdbb28f93cb14 a6a429d968cd4c40b6b96275421235c6--ba0e7a472f964874bedfdbb28f93cb14 1076bb5abc0e40528cea8c221681c163 ba0e7a472f964874bedfdbb28f93cb14--1076bb5abc0e40528cea8c221681c163 01bc66d3a1b84b33af04e8818672069c 1076bb5abc0e40528cea8c221681c163--01bc66d3a1b84b33af04e8818672069c 61aa1c5c5bb94dd6bea152491faf9c11 01bc66d3a1b84b33af04e8818672069c--61aa1c5c5bb94dd6bea152491faf9c11 1156985e18574ae3af8e9ad9285eaf96 61aa1c5c5bb94dd6bea152491faf9c11--1156985e18574ae3af8e9ad9285eaf96 c40a57d2042741f0b3b1ba7d4f3f4c41 1156985e18574ae3af8e9ad9285eaf96--c40a57d2042741f0b3b1ba7d4f3f4c41 1ca240848468488cb7ed6626d92fe46b c40a57d2042741f0b3b1ba7d4f3f4c41--1ca240848468488cb7ed6626d92fe46b d312fe17e60c414d8f9933176d2c64b1 1ca240848468488cb7ed6626d92fe46b--d312fe17e60c414d8f9933176d2c64b1 f8d2b5292176416abcc45ae9cd4b7bf3 d312fe17e60c414d8f9933176d2c64b1--f8d2b5292176416abcc45ae9cd4b7bf3 91a8d8520e3841c0991354a5ffb9d2ee f8d2b5292176416abcc45ae9cd4b7bf3--91a8d8520e3841c0991354a5ffb9d2ee c0f872ea753441fc87983420ec591c87 91a8d8520e3841c0991354a5ffb9d2ee--c0f872ea753441fc87983420ec591c87 86ee9b4c693f4acaaceb7d046a090c63 c0f872ea753441fc87983420ec591c87--86ee9b4c693f4acaaceb7d046a090c63 4053ddb51a6b4aed89d81bfd9033649a 86ee9b4c693f4acaaceb7d046a090c63--4053ddb51a6b4aed89d81bfd9033649a 5a8830f9dcfb42d38eafad62284ee35c 4053ddb51a6b4aed89d81bfd9033649a--5a8830f9dcfb42d38eafad62284ee35c d33e752c51c24968a8f57abb44f8f7e2 5a8830f9dcfb42d38eafad62284ee35c--d33e752c51c24968a8f57abb44f8f7e2 6900182bb07c40358a3b55d00a395528 d33e752c51c24968a8f57abb44f8f7e2--6900182bb07c40358a3b55d00a395528 396871eb512a4f71b0f452b592c5bb4e 6900182bb07c40358a3b55d00a395528--396871eb512a4f71b0f452b592c5bb4e 5f2c6eaf7dd24f08917a80f8d3428617 396871eb512a4f71b0f452b592c5bb4e--5f2c6eaf7dd24f08917a80f8d3428617 0299b6f2a504413e90151b196401531b 5f2c6eaf7dd24f08917a80f8d3428617--0299b6f2a504413e90151b196401531b d89335ac5b7449f08f3e0f1ee8ef2fea 0299b6f2a504413e90151b196401531b--d89335ac5b7449f08f3e0f1ee8ef2fea 957e20009ae2413d83b8760fa3296742 d89335ac5b7449f08f3e0f1ee8ef2fea--957e20009ae2413d83b8760fa3296742 d97f10681a3e4da8b1f469840d61206f 957e20009ae2413d83b8760fa3296742--d97f10681a3e4da8b1f469840d61206f a5dd6d5e26ba44aea73470f8323b3ecd d97f10681a3e4da8b1f469840d61206f--a5dd6d5e26ba44aea73470f8323b3ecd 935287b63a4f411cbf8261369235804c a5dd6d5e26ba44aea73470f8323b3ecd--935287b63a4f411cbf8261369235804c 3e9ae530edd24a55bfa14783c994304a 935287b63a4f411cbf8261369235804c--3e9ae530edd24a55bfa14783c994304a 6445202fb75d4a12b132584e78df01ef 3e9ae530edd24a55bfa14783c994304a--6445202fb75d4a12b132584e78df01ef ff3573d0864540c19bb0de1ec2c8f22c 6445202fb75d4a12b132584e78df01ef--ff3573d0864540c19bb0de1ec2c8f22c 24a89335d77e477493e4d28fc2f55a0c ff3573d0864540c19bb0de1ec2c8f22c--24a89335d77e477493e4d28fc2f55a0c 42fde1fd95ce424a8cfee664af685b38 24a89335d77e477493e4d28fc2f55a0c--42fde1fd95ce424a8cfee664af685b38 8043084e1d06460db628c60bd874514a 42fde1fd95ce424a8cfee664af685b38--8043084e1d06460db628c60bd874514a dddeb42c5b9b4d5498f3857d6f8c1df0 8043084e1d06460db628c60bd874514a--dddeb42c5b9b4d5498f3857d6f8c1df0 438f4cc50b574de9a2c4b220dcede81b dddeb42c5b9b4d5498f3857d6f8c1df0--438f4cc50b574de9a2c4b220dcede81b 7952c588722c46998089e4a7cee71961 438f4cc50b574de9a2c4b220dcede81b--7952c588722c46998089e4a7cee71961 129f25a7da64467e90ab683c75a443a4 7952c588722c46998089e4a7cee71961--129f25a7da64467e90ab683c75a443a4 8887aad6933649c7b11201504ef4c1d3 129f25a7da64467e90ab683c75a443a4--8887aad6933649c7b11201504ef4c1d3 d53db9b306214977b25810ff18837b11 8887aad6933649c7b11201504ef4c1d3--d53db9b306214977b25810ff18837b11 3090f9b5b838421692366ebae965ba25 d53db9b306214977b25810ff18837b11--3090f9b5b838421692366ebae965ba25 1360f6fe9d694fa6a118eb5e1e305ddc 3090f9b5b838421692366ebae965ba25--1360f6fe9d694fa6a118eb5e1e305ddc 9ccaf3a1342347b085c7c73d7f395743 1360f6fe9d694fa6a118eb5e1e305ddc--9ccaf3a1342347b085c7c73d7f395743 91d95ea699f444d8b0e45f958f5b1862 9ccaf3a1342347b085c7c73d7f395743--91d95ea699f444d8b0e45f958f5b1862 c2c6c64c0b7241da82ffc74c6d2906cd 91d95ea699f444d8b0e45f958f5b1862--c2c6c64c0b7241da82ffc74c6d2906cd 838dcf843d024f5284e59a955b6ad368 c2c6c64c0b7241da82ffc74c6d2906cd--838dcf843d024f5284e59a955b6ad368 82577a8c237c4d63951d40c76210e4ad 838dcf843d024f5284e59a955b6ad368--82577a8c237c4d63951d40c76210e4ad 97ec4af8f2cb4702aa6441c0d13f642f 82577a8c237c4d63951d40c76210e4ad--97ec4af8f2cb4702aa6441c0d13f642f f4a2a7d97cda4830ac24f7d0b9f618a3 97ec4af8f2cb4702aa6441c0d13f642f--f4a2a7d97cda4830ac24f7d0b9f618a3 b108b4a5094747c1badfafa63fef2f96 f4a2a7d97cda4830ac24f7d0b9f618a3--b108b4a5094747c1badfafa63fef2f96 5b358d320ce24e7ba39ff1d9102d574b b108b4a5094747c1badfafa63fef2f96--5b358d320ce24e7ba39ff1d9102d574b 85db501d0e4f4a5b8ac20e1b4fe5502c 5b358d320ce24e7ba39ff1d9102d574b--85db501d0e4f4a5b8ac20e1b4fe5502c 4ec36310405946f695cf735939e549ba 85db501d0e4f4a5b8ac20e1b4fe5502c--4ec36310405946f695cf735939e549ba 48991910474148d18fdd87f8857292ee 4ec36310405946f695cf735939e549ba--48991910474148d18fdd87f8857292ee ee5e5c90074345e890d0234183844825 48991910474148d18fdd87f8857292ee--ee5e5c90074345e890d0234183844825 49ed05c228c04a549a766ca4d9187084 ee5e5c90074345e890d0234183844825--49ed05c228c04a549a766ca4d9187084 15cc659dc69c4c9fac689b20ddf6c4cb 49ed05c228c04a549a766ca4d9187084--15cc659dc69c4c9fac689b20ddf6c4cb 30ace64b8f6249a1acc2dd74e9245564 15cc659dc69c4c9fac689b20ddf6c4cb--30ace64b8f6249a1acc2dd74e9245564 81562f47044a4d4bb30d79b76ad0d204 30ace64b8f6249a1acc2dd74e9245564--81562f47044a4d4bb30d79b76ad0d204 60a0e30289164c73897c26000c7fd2e2 81562f47044a4d4bb30d79b76ad0d204--60a0e30289164c73897c26000c7fd2e2 bdcb31e7cfa442adbf52965fd4fc4d17 60a0e30289164c73897c26000c7fd2e2--bdcb31e7cfa442adbf52965fd4fc4d17 93917edd06684ce79a15df626b45271f bdcb31e7cfa442adbf52965fd4fc4d17--93917edd06684ce79a15df626b45271f d68af33316c84530a2055d6c119605ac 93917edd06684ce79a15df626b45271f--d68af33316c84530a2055d6c119605ac 15f4428fb7ff44d5baa4adf833b8f529 d68af33316c84530a2055d6c119605ac--15f4428fb7ff44d5baa4adf833b8f529 d12ede1dca5d4328adbce3ac083b27dd 15f4428fb7ff44d5baa4adf833b8f529--d12ede1dca5d4328adbce3ac083b27dd ae0564462a974df69ff5a9ad53dc8be7 d12ede1dca5d4328adbce3ac083b27dd--ae0564462a974df69ff5a9ad53dc8be7 6f59f9d5865c494aab5accee2aedbf4e ae0564462a974df69ff5a9ad53dc8be7--6f59f9d5865c494aab5accee2aedbf4e e7c0146f82c249db85d57cb3d4ff6bef 6f59f9d5865c494aab5accee2aedbf4e--e7c0146f82c249db85d57cb3d4ff6bef 15bbc53106e541488c76c9b8441d28d4 e7c0146f82c249db85d57cb3d4ff6bef--15bbc53106e541488c76c9b8441d28d4 a9d19e26018f42c8a9fa5b9a9c30b944 15bbc53106e541488c76c9b8441d28d4--a9d19e26018f42c8a9fa5b9a9c30b944 438f4a67c26040849179fdebdbe520e6 a9d19e26018f42c8a9fa5b9a9c30b944--438f4a67c26040849179fdebdbe520e6 b3071da7828746feb298b2eb42ddf3a9 438f4a67c26040849179fdebdbe520e6--b3071da7828746feb298b2eb42ddf3a9 5e872903d9ca40bc80fa59001ce2aa7d b3071da7828746feb298b2eb42ddf3a9--5e872903d9ca40bc80fa59001ce2aa7d 240b9b6099a7405f8a7d7a4134e1c18e 5e872903d9ca40bc80fa59001ce2aa7d--240b9b6099a7405f8a7d7a4134e1c18e 8020f3cecadf466da6bcdd5206dbdc91 240b9b6099a7405f8a7d7a4134e1c18e--8020f3cecadf466da6bcdd5206dbdc91 bbc874f501904954a3190d1691494d58 8020f3cecadf466da6bcdd5206dbdc91--bbc874f501904954a3190d1691494d58 5420e896654540ce9a75f3e100883f9a bbc874f501904954a3190d1691494d58--5420e896654540ce9a75f3e100883f9a 9f8419e6e3af41ccbcdbe946c9b742c5 5420e896654540ce9a75f3e100883f9a--9f8419e6e3af41ccbcdbe946c9b742c5 1029ca31010b457da23cde12cfc2a1c5 9f8419e6e3af41ccbcdbe946c9b742c5--1029ca31010b457da23cde12cfc2a1c5 d97c519ff7df4789a08dbb4ee880ada9 1029ca31010b457da23cde12cfc2a1c5--d97c519ff7df4789a08dbb4ee880ada9 c3a27f1c047c4d9a95beb61877b05083 d97c519ff7df4789a08dbb4ee880ada9--c3a27f1c047c4d9a95beb61877b05083 99ce78e52e094806b52cfbb2246ed070 c3a27f1c047c4d9a95beb61877b05083--99ce78e52e094806b52cfbb2246ed070 cdb0641f040447be87becbe8e97800c6 99ce78e52e094806b52cfbb2246ed070--cdb0641f040447be87becbe8e97800c6 be587a0772564999807c35a5eb12a76e cdb0641f040447be87becbe8e97800c6--be587a0772564999807c35a5eb12a76e 8c75934ea4ce48099b1f6da133c68a1d be587a0772564999807c35a5eb12a76e--8c75934ea4ce48099b1f6da133c68a1d 47d260daab5c49eba0574c649a32c1d1 8c75934ea4ce48099b1f6da133c68a1d--47d260daab5c49eba0574c649a32c1d1 ffb0b7b35cb14bf196ee45892066b051 47d260daab5c49eba0574c649a32c1d1--ffb0b7b35cb14bf196ee45892066b051 c0622eef3c314738b69cfa9d8fe263cc ffb0b7b35cb14bf196ee45892066b051--c0622eef3c314738b69cfa9d8fe263cc 38c3cb0863c5414689d2e0f992c31868 c0622eef3c314738b69cfa9d8fe263cc--38c3cb0863c5414689d2e0f992c31868 9b53a6435cc24d638f7fd0044d37454a 38c3cb0863c5414689d2e0f992c31868--9b53a6435cc24d638f7fd0044d37454a 56bc2436a88045feb0c2be0ed0595cca 9b53a6435cc24d638f7fd0044d37454a--56bc2436a88045feb0c2be0ed0595cca c41ec7458b6c40a698ed50b9231cc276 56bc2436a88045feb0c2be0ed0595cca--c41ec7458b6c40a698ed50b9231cc276 419b757132cd4f2b92119728d3635796 RX(b10) c41ec7458b6c40a698ed50b9231cc276--419b757132cd4f2b92119728d3635796 d9e8ed3a41c74dd5a0d452bac667f756 419b757132cd4f2b92119728d3635796--d9e8ed3a41c74dd5a0d452bac667f756 fa997255424448cb9d4faec3a0eddd32 4d94e4c683244729abf86040d326a5a4 X fca92a2af5b241709f0171da2592eb2e--4d94e4c683244729abf86040d326a5a4 33bcce7fee034d39b9fe7901651eaf2d 2 4d94e4c683244729abf86040d326a5a4--35d3c132e23d4f01a240602c22e57856 e1cfd726d01e468aaba93f92028b9ccf 4d94e4c683244729abf86040d326a5a4--e1cfd726d01e468aaba93f92028b9ccf 6b64eb652b5e4245a1445c559e741e1a e1cfd726d01e468aaba93f92028b9ccf--6b64eb652b5e4245a1445c559e741e1a 693d2367f6de42a092a53c78175eeb02 6b64eb652b5e4245a1445c559e741e1a--693d2367f6de42a092a53c78175eeb02 57c40cad1b3a45ef81405aa7607346af 693d2367f6de42a092a53c78175eeb02--57c40cad1b3a45ef81405aa7607346af 1fca74afa8894e438fbfb8603eebfe7b 57c40cad1b3a45ef81405aa7607346af--1fca74afa8894e438fbfb8603eebfe7b 421b50c92cba4460abb169d0a7adb1f9 1fca74afa8894e438fbfb8603eebfe7b--421b50c92cba4460abb169d0a7adb1f9 49f021af6ad34d099291b9916b6be29f 421b50c92cba4460abb169d0a7adb1f9--49f021af6ad34d099291b9916b6be29f e69f3a263a8541a5b5fe01c38f3abf20 49f021af6ad34d099291b9916b6be29f--e69f3a263a8541a5b5fe01c38f3abf20 200c1dc21a0f4885831c47e5e9ffea24 e69f3a263a8541a5b5fe01c38f3abf20--200c1dc21a0f4885831c47e5e9ffea24 1c7563ce6ff548cca41ec62924c890be 200c1dc21a0f4885831c47e5e9ffea24--1c7563ce6ff548cca41ec62924c890be 3d1254fbef2047c99a9d051738856831 1c7563ce6ff548cca41ec62924c890be--3d1254fbef2047c99a9d051738856831 33705c0a31d043ee9cae232d481c72f6 3d1254fbef2047c99a9d051738856831--33705c0a31d043ee9cae232d481c72f6 9e25ee09f1754496b2dce83b6dc39c23 33705c0a31d043ee9cae232d481c72f6--9e25ee09f1754496b2dce83b6dc39c23 b56ada07dcff457ebcddfbd83b047382 X 9e25ee09f1754496b2dce83b6dc39c23--b56ada07dcff457ebcddfbd83b047382 b56ada07dcff457ebcddfbd83b047382--3d8c08f632ff4632bbb3f5894cb0428c 7195c511f645493f960a1f4f77dba8ba X b56ada07dcff457ebcddfbd83b047382--7195c511f645493f960a1f4f77dba8ba 7195c511f645493f960a1f4f77dba8ba--9f204442fed44186bb61afe6eafe32f8 6d06ebf027f340f1a3447871fe5d8335 RZ(-1.0*g0) 7195c511f645493f960a1f4f77dba8ba--6d06ebf027f340f1a3447871fe5d8335 f84f995326aa45539b985fb073b6a33a X 6d06ebf027f340f1a3447871fe5d8335--f84f995326aa45539b985fb073b6a33a f84f995326aa45539b985fb073b6a33a--cefef225c45241fc970506fbf51a78c1 1446466977dd420388b9c56e1452a649 X f84f995326aa45539b985fb073b6a33a--1446466977dd420388b9c56e1452a649 1446466977dd420388b9c56e1452a649--839c34136a42429fa558a17753e44e28 27480d234c1747cfa06f8d8e7ea8c678 1446466977dd420388b9c56e1452a649--27480d234c1747cfa06f8d8e7ea8c678 be70619e30f840879e552a5ed3f5d8ca 27480d234c1747cfa06f8d8e7ea8c678--be70619e30f840879e552a5ed3f5d8ca 00ba056a9b3741a7ae8d516b7985e5e9 be70619e30f840879e552a5ed3f5d8ca--00ba056a9b3741a7ae8d516b7985e5e9 811121fde2f047dd9851c59e15b217ec 00ba056a9b3741a7ae8d516b7985e5e9--811121fde2f047dd9851c59e15b217ec bb996a4152274948b001e2a853f2139f 811121fde2f047dd9851c59e15b217ec--bb996a4152274948b001e2a853f2139f b40425e1c0d345618de6982a746a6324 bb996a4152274948b001e2a853f2139f--b40425e1c0d345618de6982a746a6324 8e0ad6fcdd22488a947c32dcbe54e168 b40425e1c0d345618de6982a746a6324--8e0ad6fcdd22488a947c32dcbe54e168 2699f23aa2f64b30903ce72e8aae3622 X 8e0ad6fcdd22488a947c32dcbe54e168--2699f23aa2f64b30903ce72e8aae3622 2699f23aa2f64b30903ce72e8aae3622--49c3587cc12149bbbc3db0cdb5421596 febafbcd7f454e35bcf28d804ed77276 X 2699f23aa2f64b30903ce72e8aae3622--febafbcd7f454e35bcf28d804ed77276 febafbcd7f454e35bcf28d804ed77276--7097aec6aec444a7be08e252aae13e76 7e9136c5f6bc4c16bb46de6c5c4c1429 febafbcd7f454e35bcf28d804ed77276--7e9136c5f6bc4c16bb46de6c5c4c1429 a74cf31b0aa2498eb99cb11c2b6e06d4 7e9136c5f6bc4c16bb46de6c5c4c1429--a74cf31b0aa2498eb99cb11c2b6e06d4 23077e6eb8554f8ca9c44cb22c517c7d a74cf31b0aa2498eb99cb11c2b6e06d4--23077e6eb8554f8ca9c44cb22c517c7d d518ec7dcdee43ab96c93499228f12c2 23077e6eb8554f8ca9c44cb22c517c7d--d518ec7dcdee43ab96c93499228f12c2 a8ff17db5bf74df29e0c7a72b22a7a31 d518ec7dcdee43ab96c93499228f12c2--a8ff17db5bf74df29e0c7a72b22a7a31 e549004193b84058a332fb9da28772fe a8ff17db5bf74df29e0c7a72b22a7a31--e549004193b84058a332fb9da28772fe e920b3a3dd9a4fe69bc52b468c36dcb5 e549004193b84058a332fb9da28772fe--e920b3a3dd9a4fe69bc52b468c36dcb5 9657ef727199474d86c49535b5ac74a3 e920b3a3dd9a4fe69bc52b468c36dcb5--9657ef727199474d86c49535b5ac74a3 7ad96883c98a426dae460b3da1df8952 9657ef727199474d86c49535b5ac74a3--7ad96883c98a426dae460b3da1df8952 22a1f662e6c94b4baf3e06a0e73f5349 X 7ad96883c98a426dae460b3da1df8952--22a1f662e6c94b4baf3e06a0e73f5349 22a1f662e6c94b4baf3e06a0e73f5349--3207f60143cb4a0fbc90d435378049e4 f6f87a6673214ce78697870a907dac77 X 22a1f662e6c94b4baf3e06a0e73f5349--f6f87a6673214ce78697870a907dac77 f6f87a6673214ce78697870a907dac77--c5dcd3af735a49ca9c861236d6556db2 3ecf27823405488ba7bf5daa1e834f5a f6f87a6673214ce78697870a907dac77--3ecf27823405488ba7bf5daa1e834f5a 214c4190d3e14446890b1fc386d0a9de 3ecf27823405488ba7bf5daa1e834f5a--214c4190d3e14446890b1fc386d0a9de 947ff134293e47fc88e058fb96f58594 214c4190d3e14446890b1fc386d0a9de--947ff134293e47fc88e058fb96f58594 5c954379b8104b04826821ee7d12ef1a 947ff134293e47fc88e058fb96f58594--5c954379b8104b04826821ee7d12ef1a fd3c4a3c859646b5a4cedce4dfef0402 5c954379b8104b04826821ee7d12ef1a--fd3c4a3c859646b5a4cedce4dfef0402 461de507312d434ca7a367bb1e128b23 fd3c4a3c859646b5a4cedce4dfef0402--461de507312d434ca7a367bb1e128b23 7f44a5da4c0d45c4a2a7d4c175f63334 461de507312d434ca7a367bb1e128b23--7f44a5da4c0d45c4a2a7d4c175f63334 50f2fb2bc1eb4b07b93a880792ce6a21 7f44a5da4c0d45c4a2a7d4c175f63334--50f2fb2bc1eb4b07b93a880792ce6a21 2d36495f9e9c47e3b57d180333c25129 50f2fb2bc1eb4b07b93a880792ce6a21--2d36495f9e9c47e3b57d180333c25129 9ec5aacf99e14f49a39a463338a9832a 2d36495f9e9c47e3b57d180333c25129--9ec5aacf99e14f49a39a463338a9832a 859a9d09f7fc48d48085dfb70455c24f 9ec5aacf99e14f49a39a463338a9832a--859a9d09f7fc48d48085dfb70455c24f 0c5544804df84320846fb0279f791115 859a9d09f7fc48d48085dfb70455c24f--0c5544804df84320846fb0279f791115 a31fb65eee424bad93dd3dfd189545f9 0c5544804df84320846fb0279f791115--a31fb65eee424bad93dd3dfd189545f9 101bc4e5b2bb4665a40b036805513c7f X a31fb65eee424bad93dd3dfd189545f9--101bc4e5b2bb4665a40b036805513c7f 101bc4e5b2bb4665a40b036805513c7f--a8289d73016f455eaed2cca556ae3d26 711869d945c5419980fec413ad37af92 101bc4e5b2bb4665a40b036805513c7f--711869d945c5419980fec413ad37af92 96c199628336483bbfb2454935411f08 711869d945c5419980fec413ad37af92--96c199628336483bbfb2454935411f08 8b72126c3bc349cc91203fcea8b28e58 96c199628336483bbfb2454935411f08--8b72126c3bc349cc91203fcea8b28e58 79ab7378f59e4113a2fe5432a84c785f 8b72126c3bc349cc91203fcea8b28e58--79ab7378f59e4113a2fe5432a84c785f 502719e6215d4ef59ad9e1f341a98316 79ab7378f59e4113a2fe5432a84c785f--502719e6215d4ef59ad9e1f341a98316 e8ea2c97270b4b04889bc9d3732900d9 502719e6215d4ef59ad9e1f341a98316--e8ea2c97270b4b04889bc9d3732900d9 e4fa658568fb4f49902b352925f077d1 e8ea2c97270b4b04889bc9d3732900d9--e4fa658568fb4f49902b352925f077d1 d7092c46b00a439b83553fa7adeeeb46 e4fa658568fb4f49902b352925f077d1--d7092c46b00a439b83553fa7adeeeb46 7028e338227642cb9806ed94eb13fa4c d7092c46b00a439b83553fa7adeeeb46--7028e338227642cb9806ed94eb13fa4c 873657c7447f4594b4b46f586a3e835e 7028e338227642cb9806ed94eb13fa4c--873657c7447f4594b4b46f586a3e835e 4f5a7e6ab3f848e890eb39ec78c77161 873657c7447f4594b4b46f586a3e835e--4f5a7e6ab3f848e890eb39ec78c77161 9abe8afe312e4189a808243ab12a837d 4f5a7e6ab3f848e890eb39ec78c77161--9abe8afe312e4189a808243ab12a837d f39bf74d8a9c4536be10d94dce767e38 9abe8afe312e4189a808243ab12a837d--f39bf74d8a9c4536be10d94dce767e38 8970c91a1abe49f5b6ea15c759a6d23a f39bf74d8a9c4536be10d94dce767e38--8970c91a1abe49f5b6ea15c759a6d23a 7d915c81d26e44f1a5d85436475c2aaa 8970c91a1abe49f5b6ea15c759a6d23a--7d915c81d26e44f1a5d85436475c2aaa 6764464349c443b78f1a609af4e1549e 7d915c81d26e44f1a5d85436475c2aaa--6764464349c443b78f1a609af4e1549e 555be8f39b5c4adab8fe2e8c2e621c91 6764464349c443b78f1a609af4e1549e--555be8f39b5c4adab8fe2e8c2e621c91 25aba4fbcd25482e8854bee7035d1991 555be8f39b5c4adab8fe2e8c2e621c91--25aba4fbcd25482e8854bee7035d1991 3e7aa6a7b5e14640b9ea4c2b4898d827 25aba4fbcd25482e8854bee7035d1991--3e7aa6a7b5e14640b9ea4c2b4898d827 f1b63b16dd8844c0abb3c0be52d3cd2e 3e7aa6a7b5e14640b9ea4c2b4898d827--f1b63b16dd8844c0abb3c0be52d3cd2e edb210b38b89477d85e0cf2dcfd5779a f1b63b16dd8844c0abb3c0be52d3cd2e--edb210b38b89477d85e0cf2dcfd5779a e8ccd0a9578c463caaa811b0702fd315 edb210b38b89477d85e0cf2dcfd5779a--e8ccd0a9578c463caaa811b0702fd315 e7ac7d8edca24427a1bdf100dbf84b7f e8ccd0a9578c463caaa811b0702fd315--e7ac7d8edca24427a1bdf100dbf84b7f 1fb1d446948b44888dba60868c850eec e7ac7d8edca24427a1bdf100dbf84b7f--1fb1d446948b44888dba60868c850eec 5e5bfe8ec0ed496282a97afe26b9d3e3 1fb1d446948b44888dba60868c850eec--5e5bfe8ec0ed496282a97afe26b9d3e3 c27fe5e7f0a148cf9f207a97b04e0290 5e5bfe8ec0ed496282a97afe26b9d3e3--c27fe5e7f0a148cf9f207a97b04e0290 18266e661e8f4ea2b3cebfa7d7011172 c27fe5e7f0a148cf9f207a97b04e0290--18266e661e8f4ea2b3cebfa7d7011172 e395130a82444279b76ddd88ec703a15 18266e661e8f4ea2b3cebfa7d7011172--e395130a82444279b76ddd88ec703a15 38f059616efe45a1a116731c17676f47 e395130a82444279b76ddd88ec703a15--38f059616efe45a1a116731c17676f47 cb6380ffde324ca29188cee170319a98 38f059616efe45a1a116731c17676f47--cb6380ffde324ca29188cee170319a98 7507aec9e36f44d58860d2fa9e9ea56a cb6380ffde324ca29188cee170319a98--7507aec9e36f44d58860d2fa9e9ea56a a3517fd44c0f4ce1ab85f94dc094a9f8 7507aec9e36f44d58860d2fa9e9ea56a--a3517fd44c0f4ce1ab85f94dc094a9f8 3b0144c17fac4952a7d7e0d92beff8ec a3517fd44c0f4ce1ab85f94dc094a9f8--3b0144c17fac4952a7d7e0d92beff8ec 8dccd8211b964e9fb2b157c3163d5b6e 3b0144c17fac4952a7d7e0d92beff8ec--8dccd8211b964e9fb2b157c3163d5b6e 9aa37fec189d4af590fd694c49de9acb 8dccd8211b964e9fb2b157c3163d5b6e--9aa37fec189d4af590fd694c49de9acb faaa4883a7f54d838c5997f109841d07 9aa37fec189d4af590fd694c49de9acb--faaa4883a7f54d838c5997f109841d07 5856fd34e35f4c47a3a574b9291c4fc4 faaa4883a7f54d838c5997f109841d07--5856fd34e35f4c47a3a574b9291c4fc4 71d026ab9ee6449ead7c517ca095756c 5856fd34e35f4c47a3a574b9291c4fc4--71d026ab9ee6449ead7c517ca095756c fb740d63e2614f45a9196c1ab2af6c64 71d026ab9ee6449ead7c517ca095756c--fb740d63e2614f45a9196c1ab2af6c64 dd53ce9b4538497a910f53276e72fbcf fb740d63e2614f45a9196c1ab2af6c64--dd53ce9b4538497a910f53276e72fbcf cc72f54966ae436293af6797bc78e624 dd53ce9b4538497a910f53276e72fbcf--cc72f54966ae436293af6797bc78e624 cfc8dad3f69540debafa93688ea90d5c cc72f54966ae436293af6797bc78e624--cfc8dad3f69540debafa93688ea90d5c 4bffdd33b2034272b2f5f371bb1b2f5e cfc8dad3f69540debafa93688ea90d5c--4bffdd33b2034272b2f5f371bb1b2f5e 0c8b7b10d39245bb93f713488f2efa62 4bffdd33b2034272b2f5f371bb1b2f5e--0c8b7b10d39245bb93f713488f2efa62 01c511c3de5b47188ef5cdcfd6f7efbe 0c8b7b10d39245bb93f713488f2efa62--01c511c3de5b47188ef5cdcfd6f7efbe 875dc36227494467b6c492daf19681c6 01c511c3de5b47188ef5cdcfd6f7efbe--875dc36227494467b6c492daf19681c6 969871f1e1714a5cb55ecdc2ef54e7ff 875dc36227494467b6c492daf19681c6--969871f1e1714a5cb55ecdc2ef54e7ff f4790c90359a479eb57d4659a102732e 969871f1e1714a5cb55ecdc2ef54e7ff--f4790c90359a479eb57d4659a102732e a1da78c665904a4eac0016f8115adf35 f4790c90359a479eb57d4659a102732e--a1da78c665904a4eac0016f8115adf35 b88cff7cdec9454ea14d81799837a3ce a1da78c665904a4eac0016f8115adf35--b88cff7cdec9454ea14d81799837a3ce 1e9fe518c72d4f92b3a4596d53f2ebbc b88cff7cdec9454ea14d81799837a3ce--1e9fe518c72d4f92b3a4596d53f2ebbc 657997c56b654e34acea66d14d48a26c 1e9fe518c72d4f92b3a4596d53f2ebbc--657997c56b654e34acea66d14d48a26c a8ce73b4ce444014944b14dfcd1a5993 657997c56b654e34acea66d14d48a26c--a8ce73b4ce444014944b14dfcd1a5993 694775d796104a3a9103d1fc617804e5 a8ce73b4ce444014944b14dfcd1a5993--694775d796104a3a9103d1fc617804e5 7099a5aa71c64f0c8ff53e788293e35c 694775d796104a3a9103d1fc617804e5--7099a5aa71c64f0c8ff53e788293e35c 81502d21292f47278bdf312f9eb6f831 7099a5aa71c64f0c8ff53e788293e35c--81502d21292f47278bdf312f9eb6f831 ba03d38ce353471cb36a4f0f1092c5da 81502d21292f47278bdf312f9eb6f831--ba03d38ce353471cb36a4f0f1092c5da 32569461323d45c2a9eee02d82ded387 ba03d38ce353471cb36a4f0f1092c5da--32569461323d45c2a9eee02d82ded387 9b75beebd85247038491f29505f56f81 32569461323d45c2a9eee02d82ded387--9b75beebd85247038491f29505f56f81 482d46d6a84b4d658b32fc38bb331051 9b75beebd85247038491f29505f56f81--482d46d6a84b4d658b32fc38bb331051 0c4b6c39e1c84d2886d55daa1c919576 482d46d6a84b4d658b32fc38bb331051--0c4b6c39e1c84d2886d55daa1c919576 d2b8d7eecb22463d885cf37f0b538ac9 0c4b6c39e1c84d2886d55daa1c919576--d2b8d7eecb22463d885cf37f0b538ac9 1a666136d6e64ce4bb32a61a0566ac8b d2b8d7eecb22463d885cf37f0b538ac9--1a666136d6e64ce4bb32a61a0566ac8b 1a0114f35a10405b85411a40bf250020 1a666136d6e64ce4bb32a61a0566ac8b--1a0114f35a10405b85411a40bf250020 fc9ce3eaeb304030baec2218a28d2f4c 1a0114f35a10405b85411a40bf250020--fc9ce3eaeb304030baec2218a28d2f4c 2049a40648d249629f017d61caa28d26 fc9ce3eaeb304030baec2218a28d2f4c--2049a40648d249629f017d61caa28d26 9a6bd73441f44b94ae0343ee3243a613 2049a40648d249629f017d61caa28d26--9a6bd73441f44b94ae0343ee3243a613 2f402cc146b047ea92218477f7ddf591 RX(b01) 9a6bd73441f44b94ae0343ee3243a613--2f402cc146b047ea92218477f7ddf591 a5ba3f4e27854073bba38e8a36115971 X 2f402cc146b047ea92218477f7ddf591--a5ba3f4e27854073bba38e8a36115971 a5ba3f4e27854073bba38e8a36115971--a5b19d2c9842463ca3474d46c8047457 791d2b89365a4d16a3f7887164a36e2d a5ba3f4e27854073bba38e8a36115971--791d2b89365a4d16a3f7887164a36e2d aade22d8035e406f8ffc513525c02b2e 791d2b89365a4d16a3f7887164a36e2d--aade22d8035e406f8ffc513525c02b2e c307767fabbc4626adf50f2671baecfe aade22d8035e406f8ffc513525c02b2e--c307767fabbc4626adf50f2671baecfe 9f5460434a744f439d54217d08c7e2b6 c307767fabbc4626adf50f2671baecfe--9f5460434a744f439d54217d08c7e2b6 16d4d65fe6a2445982da2e8528e77117 9f5460434a744f439d54217d08c7e2b6--16d4d65fe6a2445982da2e8528e77117 9ba99fe10ee740058415b77acdaa68c4 16d4d65fe6a2445982da2e8528e77117--9ba99fe10ee740058415b77acdaa68c4 55faec6e1fa6493e9f85ed637d5109e1 9ba99fe10ee740058415b77acdaa68c4--55faec6e1fa6493e9f85ed637d5109e1 36e397db01d84c13ad5bf83160858d6f 55faec6e1fa6493e9f85ed637d5109e1--36e397db01d84c13ad5bf83160858d6f dc26d9695b244f9c9eea5d11b01ff9bd 36e397db01d84c13ad5bf83160858d6f--dc26d9695b244f9c9eea5d11b01ff9bd 89d05bde17b84f93866380b507ae67b0 dc26d9695b244f9c9eea5d11b01ff9bd--89d05bde17b84f93866380b507ae67b0 d5eeff1c4b694de09f3a7223b5bed8f0 89d05bde17b84f93866380b507ae67b0--d5eeff1c4b694de09f3a7223b5bed8f0 e57fcfdf420f41569094689815285fe6 d5eeff1c4b694de09f3a7223b5bed8f0--e57fcfdf420f41569094689815285fe6 8c4ab967c9cd4a83818d7c14672524b0 e57fcfdf420f41569094689815285fe6--8c4ab967c9cd4a83818d7c14672524b0 f25e57b51f074936a000b85b49966f23 X 8c4ab967c9cd4a83818d7c14672524b0--f25e57b51f074936a000b85b49966f23 f25e57b51f074936a000b85b49966f23--ead30ed1928848219944776086d66b4e b8ac1841f4a944a998c9fcc55a49f1bf X f25e57b51f074936a000b85b49966f23--b8ac1841f4a944a998c9fcc55a49f1bf b8ac1841f4a944a998c9fcc55a49f1bf--5641f2a05e634501a658168e8f833483 383c1a7a3dff4602a9ab53904a1746a4 RZ(-1.0*g1) b8ac1841f4a944a998c9fcc55a49f1bf--383c1a7a3dff4602a9ab53904a1746a4 51ed1b34aa684425a7b32b3eb4b5eb5e X 383c1a7a3dff4602a9ab53904a1746a4--51ed1b34aa684425a7b32b3eb4b5eb5e 51ed1b34aa684425a7b32b3eb4b5eb5e--063bb19be22440e3b484f1c4b3b2fe4e f33930a747c74de998cd069006f93f8e X 51ed1b34aa684425a7b32b3eb4b5eb5e--f33930a747c74de998cd069006f93f8e f33930a747c74de998cd069006f93f8e--94c46c30573c45ccacec279bd8710f61 58875e9be3e549d8925181919353b60d f33930a747c74de998cd069006f93f8e--58875e9be3e549d8925181919353b60d a64c30b59d4b4ec6b1b48b3d6f403229 58875e9be3e549d8925181919353b60d--a64c30b59d4b4ec6b1b48b3d6f403229 7926b66d615f418ca5eadf232eb4a14b a64c30b59d4b4ec6b1b48b3d6f403229--7926b66d615f418ca5eadf232eb4a14b 39f198f156d54d588f66f697092bc4f9 7926b66d615f418ca5eadf232eb4a14b--39f198f156d54d588f66f697092bc4f9 5bedc23ae4ef4d1e8aa280253374ab11 39f198f156d54d588f66f697092bc4f9--5bedc23ae4ef4d1e8aa280253374ab11 608d0da9140a4c7ca1f965f597328221 5bedc23ae4ef4d1e8aa280253374ab11--608d0da9140a4c7ca1f965f597328221 cf73283a5ca74b24a16172db35a64ae4 608d0da9140a4c7ca1f965f597328221--cf73283a5ca74b24a16172db35a64ae4 37e93729e58e433492ff09350139e866 X cf73283a5ca74b24a16172db35a64ae4--37e93729e58e433492ff09350139e866 37e93729e58e433492ff09350139e866--ae1496daeb2f491d8d0c4c7dfe4759eb 646e1aea13d042cca3a8c79b58572b20 X 37e93729e58e433492ff09350139e866--646e1aea13d042cca3a8c79b58572b20 646e1aea13d042cca3a8c79b58572b20--814be57eecac462ab80f0c0385161307 10f29353344f4d1bb63b3079b5198e8d 646e1aea13d042cca3a8c79b58572b20--10f29353344f4d1bb63b3079b5198e8d a95b991337064447985c0c40b64bf2fb 10f29353344f4d1bb63b3079b5198e8d--a95b991337064447985c0c40b64bf2fb 67396eb926044b31bade405e38715013 a95b991337064447985c0c40b64bf2fb--67396eb926044b31bade405e38715013 a255080397664606bcd224516cb095d8 67396eb926044b31bade405e38715013--a255080397664606bcd224516cb095d8 008e4ab858c44cdc8c8baa5d43c1c727 a255080397664606bcd224516cb095d8--008e4ab858c44cdc8c8baa5d43c1c727 ef6dfbd0bde249e0aef54b770d9fdfd5 008e4ab858c44cdc8c8baa5d43c1c727--ef6dfbd0bde249e0aef54b770d9fdfd5 cfb3808a1eb4490d8de92ac0cddddc24 ef6dfbd0bde249e0aef54b770d9fdfd5--cfb3808a1eb4490d8de92ac0cddddc24 50c3f9334ca8444eb773ffeab3cffc8c cfb3808a1eb4490d8de92ac0cddddc24--50c3f9334ca8444eb773ffeab3cffc8c 0a849f89f1d74265bac427b6c126f7bb 50c3f9334ca8444eb773ffeab3cffc8c--0a849f89f1d74265bac427b6c126f7bb 1b0d36a661ff430fad953729e496d731 X 0a849f89f1d74265bac427b6c126f7bb--1b0d36a661ff430fad953729e496d731 1b0d36a661ff430fad953729e496d731--c40a57d2042741f0b3b1ba7d4f3f4c41 fded7030bd574867ba1c021f520793b2 X 1b0d36a661ff430fad953729e496d731--fded7030bd574867ba1c021f520793b2 fded7030bd574867ba1c021f520793b2--1ca240848468488cb7ed6626d92fe46b 82aa81f0e103447a8805d8c5cf3c917a fded7030bd574867ba1c021f520793b2--82aa81f0e103447a8805d8c5cf3c917a 840f9ba63d874c8d9c0164b1b2cc9bc9 82aa81f0e103447a8805d8c5cf3c917a--840f9ba63d874c8d9c0164b1b2cc9bc9 87f041d430db4db183495bed7cd16713 840f9ba63d874c8d9c0164b1b2cc9bc9--87f041d430db4db183495bed7cd16713 a6304d52490e415e8eb8b26f98f2282e 87f041d430db4db183495bed7cd16713--a6304d52490e415e8eb8b26f98f2282e 8e98e5433277420783e64ffddf2faa54 a6304d52490e415e8eb8b26f98f2282e--8e98e5433277420783e64ffddf2faa54 134835e4aa984cd9a8df37a447b98534 8e98e5433277420783e64ffddf2faa54--134835e4aa984cd9a8df37a447b98534 d3d3963101dc48258a914c4c8f0430d5 134835e4aa984cd9a8df37a447b98534--d3d3963101dc48258a914c4c8f0430d5 9f660b249dee49adb393f4d24cb5ac49 d3d3963101dc48258a914c4c8f0430d5--9f660b249dee49adb393f4d24cb5ac49 13625bf5c7fb4b6193466002320f03e0 9f660b249dee49adb393f4d24cb5ac49--13625bf5c7fb4b6193466002320f03e0 27ca34e58f6e4bd3bc7803b167c2c3c5 13625bf5c7fb4b6193466002320f03e0--27ca34e58f6e4bd3bc7803b167c2c3c5 c0cfb90890ce459e8844e04c933a9476 27ca34e58f6e4bd3bc7803b167c2c3c5--c0cfb90890ce459e8844e04c933a9476 16e624940b784ef1a49917b5e3e331d1 c0cfb90890ce459e8844e04c933a9476--16e624940b784ef1a49917b5e3e331d1 b022f9bde5fe49359367f811ca07943e 16e624940b784ef1a49917b5e3e331d1--b022f9bde5fe49359367f811ca07943e 1ecd6fee3ee54bdc92f175f233bc89a1 X b022f9bde5fe49359367f811ca07943e--1ecd6fee3ee54bdc92f175f233bc89a1 1ecd6fee3ee54bdc92f175f233bc89a1--957e20009ae2413d83b8760fa3296742 835f8b90f00746a1906e1b5dd0eec8a8 1ecd6fee3ee54bdc92f175f233bc89a1--835f8b90f00746a1906e1b5dd0eec8a8 63d2ebe66cef4e67bcfa0d6d15c1a6ac 835f8b90f00746a1906e1b5dd0eec8a8--63d2ebe66cef4e67bcfa0d6d15c1a6ac fd618ea7ec4948d799dc84e3813810ba 63d2ebe66cef4e67bcfa0d6d15c1a6ac--fd618ea7ec4948d799dc84e3813810ba cdb560914910471da858193e0315b601 fd618ea7ec4948d799dc84e3813810ba--cdb560914910471da858193e0315b601 cbb1a1de1eea4daf8d3dcd6e00e3ddc0 cdb560914910471da858193e0315b601--cbb1a1de1eea4daf8d3dcd6e00e3ddc0 2a4e6bcd6a1e49b3997dff35609224ff cbb1a1de1eea4daf8d3dcd6e00e3ddc0--2a4e6bcd6a1e49b3997dff35609224ff f5baf451e1224e478a6d9d4f701e5927 2a4e6bcd6a1e49b3997dff35609224ff--f5baf451e1224e478a6d9d4f701e5927 fc25d06788f94f1eba79ce36d5825a01 f5baf451e1224e478a6d9d4f701e5927--fc25d06788f94f1eba79ce36d5825a01 15fcb8d306c34ad3aa60012709dec0f2 fc25d06788f94f1eba79ce36d5825a01--15fcb8d306c34ad3aa60012709dec0f2 0b0ccc1a2f1f4c5284368c44be054e02 15fcb8d306c34ad3aa60012709dec0f2--0b0ccc1a2f1f4c5284368c44be054e02 2c05cb0bd26e47ad9b57b91f213c7cc9 0b0ccc1a2f1f4c5284368c44be054e02--2c05cb0bd26e47ad9b57b91f213c7cc9 74bc9dd9c7074c24b4147e306167f95f 2c05cb0bd26e47ad9b57b91f213c7cc9--74bc9dd9c7074c24b4147e306167f95f f02eb4ee07c949348944cb28ea03a57f 74bc9dd9c7074c24b4147e306167f95f--f02eb4ee07c949348944cb28ea03a57f 861e30a14cca44e18744f4e2a60ffebd f02eb4ee07c949348944cb28ea03a57f--861e30a14cca44e18744f4e2a60ffebd 3aa424db3ab34b659027a73086f0a141 861e30a14cca44e18744f4e2a60ffebd--3aa424db3ab34b659027a73086f0a141 654aa0d8f5d84d7f856a330b952eb8cc 3aa424db3ab34b659027a73086f0a141--654aa0d8f5d84d7f856a330b952eb8cc b3e7596b1611467ea408967d92f31680 654aa0d8f5d84d7f856a330b952eb8cc--b3e7596b1611467ea408967d92f31680 91357293003a4dabb0d0a17c7bd0e2e4 b3e7596b1611467ea408967d92f31680--91357293003a4dabb0d0a17c7bd0e2e4 8b0d95cfb5e14e1bb6f467480d980c23 91357293003a4dabb0d0a17c7bd0e2e4--8b0d95cfb5e14e1bb6f467480d980c23 c3921d8edcb5478cb3c52352f25bea79 8b0d95cfb5e14e1bb6f467480d980c23--c3921d8edcb5478cb3c52352f25bea79 2af5fa1fc168435a815cccbea82977ae c3921d8edcb5478cb3c52352f25bea79--2af5fa1fc168435a815cccbea82977ae 76126d864cb94ad68f2b41766f05e7f5 2af5fa1fc168435a815cccbea82977ae--76126d864cb94ad68f2b41766f05e7f5 065cdc4206134838b653b1044914effd 76126d864cb94ad68f2b41766f05e7f5--065cdc4206134838b653b1044914effd 0560fd246d9a400cb789267c2a6ca778 065cdc4206134838b653b1044914effd--0560fd246d9a400cb789267c2a6ca778 2b43a55582f341dbbd44c24ef2fcc3d9 0560fd246d9a400cb789267c2a6ca778--2b43a55582f341dbbd44c24ef2fcc3d9 4b87ea8ac73b4f5797b27899bc26a284 2b43a55582f341dbbd44c24ef2fcc3d9--4b87ea8ac73b4f5797b27899bc26a284 328890e503204c48b93fbc587608bd45 4b87ea8ac73b4f5797b27899bc26a284--328890e503204c48b93fbc587608bd45 4d8840d4cecb49b795b4a23241eb0353 328890e503204c48b93fbc587608bd45--4d8840d4cecb49b795b4a23241eb0353 04232fb2f1ef4f6693013bc68219810c 4d8840d4cecb49b795b4a23241eb0353--04232fb2f1ef4f6693013bc68219810c 4ad6a73d557441ccbece2cc2825b1c3d 04232fb2f1ef4f6693013bc68219810c--4ad6a73d557441ccbece2cc2825b1c3d f5878bdb2d53498099dc8d7ab43f82b9 4ad6a73d557441ccbece2cc2825b1c3d--f5878bdb2d53498099dc8d7ab43f82b9 01578252268b456495e7232c3dfccc13 f5878bdb2d53498099dc8d7ab43f82b9--01578252268b456495e7232c3dfccc13 d9cb5616d634494988c9479da6baa064 01578252268b456495e7232c3dfccc13--d9cb5616d634494988c9479da6baa064 c8feaffcd16c40c09ae45cb0d07b6925 d9cb5616d634494988c9479da6baa064--c8feaffcd16c40c09ae45cb0d07b6925 030ce43c008842eaad4b9ce688f76ad3 c8feaffcd16c40c09ae45cb0d07b6925--030ce43c008842eaad4b9ce688f76ad3 cec5ac8501964c9f8ec2c80d287cbb90 030ce43c008842eaad4b9ce688f76ad3--cec5ac8501964c9f8ec2c80d287cbb90 ee36725f390049b9b0b7073e7b9214b2 cec5ac8501964c9f8ec2c80d287cbb90--ee36725f390049b9b0b7073e7b9214b2 8c9ce056f6ea4440a00649e04526ad23 ee36725f390049b9b0b7073e7b9214b2--8c9ce056f6ea4440a00649e04526ad23 f94b7fbf5d0c4ccda121c7bd83aac819 8c9ce056f6ea4440a00649e04526ad23--f94b7fbf5d0c4ccda121c7bd83aac819 68e43b3a04e14281b31a43eb57cf507d f94b7fbf5d0c4ccda121c7bd83aac819--68e43b3a04e14281b31a43eb57cf507d 44f1d1abf295422bac2096b2481a44cc 68e43b3a04e14281b31a43eb57cf507d--44f1d1abf295422bac2096b2481a44cc cb68970d0e174f55a91aebcc8f1d87a3 44f1d1abf295422bac2096b2481a44cc--cb68970d0e174f55a91aebcc8f1d87a3 17c614d2b40e4e2d820572f4b58840c3 cb68970d0e174f55a91aebcc8f1d87a3--17c614d2b40e4e2d820572f4b58840c3 863ec15065794a88bbcd854876af2e26 17c614d2b40e4e2d820572f4b58840c3--863ec15065794a88bbcd854876af2e26 85b2cbd1ad324c119153415d8154b595 863ec15065794a88bbcd854876af2e26--85b2cbd1ad324c119153415d8154b595 2526477458ae431a82e1f397e9d3849e 85b2cbd1ad324c119153415d8154b595--2526477458ae431a82e1f397e9d3849e 29c3d625624a4877b56ce96ef45ef989 2526477458ae431a82e1f397e9d3849e--29c3d625624a4877b56ce96ef45ef989 84acfdb170df40dc98bde66e6df6f591 29c3d625624a4877b56ce96ef45ef989--84acfdb170df40dc98bde66e6df6f591 d21c1023757647a7b4c311a0e398d679 84acfdb170df40dc98bde66e6df6f591--d21c1023757647a7b4c311a0e398d679 6bb87b40236646218044bf2bc0e54d12 d21c1023757647a7b4c311a0e398d679--6bb87b40236646218044bf2bc0e54d12 e49978b796c14b5fa0356609eb10725f 6bb87b40236646218044bf2bc0e54d12--e49978b796c14b5fa0356609eb10725f 7c6998bbd36942b3b928fedbf8c6dbd4 e49978b796c14b5fa0356609eb10725f--7c6998bbd36942b3b928fedbf8c6dbd4 a054546d7ca14823843744add00c33e2 7c6998bbd36942b3b928fedbf8c6dbd4--a054546d7ca14823843744add00c33e2 6752bb6817f3439c83cc2304a686dfe5 a054546d7ca14823843744add00c33e2--6752bb6817f3439c83cc2304a686dfe5 3861780805d046a9922b366511f8ad5d 6752bb6817f3439c83cc2304a686dfe5--3861780805d046a9922b366511f8ad5d 59e24edcc46d4773af372f780cc20bbf 3861780805d046a9922b366511f8ad5d--59e24edcc46d4773af372f780cc20bbf e694dc19a84a4b6bbe604ae67d01e575 59e24edcc46d4773af372f780cc20bbf--e694dc19a84a4b6bbe604ae67d01e575 afc5da0e497e41d9927333a8a7cf8ef5 e694dc19a84a4b6bbe604ae67d01e575--afc5da0e497e41d9927333a8a7cf8ef5 a1c0ef71f4c343deb8445fbdfbac6e9a afc5da0e497e41d9927333a8a7cf8ef5--a1c0ef71f4c343deb8445fbdfbac6e9a ac88d7be44ef4fb788969bf0e962e124 a1c0ef71f4c343deb8445fbdfbac6e9a--ac88d7be44ef4fb788969bf0e962e124 43f8b62f210d4f45aa64247eebbd9d7f ac88d7be44ef4fb788969bf0e962e124--43f8b62f210d4f45aa64247eebbd9d7f 8a1a3780b9d1413892c644949185c4ae 43f8b62f210d4f45aa64247eebbd9d7f--8a1a3780b9d1413892c644949185c4ae 991ba393f69b46728564248596072fad 8a1a3780b9d1413892c644949185c4ae--991ba393f69b46728564248596072fad 44e2d59c7bcf4e3d81e629fd306625dc 991ba393f69b46728564248596072fad--44e2d59c7bcf4e3d81e629fd306625dc 374a09ca23c442a187446263fc487655 44e2d59c7bcf4e3d81e629fd306625dc--374a09ca23c442a187446263fc487655 83301d6edc9845efa0ef1728fdd8a175 374a09ca23c442a187446263fc487655--83301d6edc9845efa0ef1728fdd8a175 0949d84aafbf4802be5a578874a352b7 83301d6edc9845efa0ef1728fdd8a175--0949d84aafbf4802be5a578874a352b7 29298133288040b18710c0cdcbc0d836 RX(b11) 0949d84aafbf4802be5a578874a352b7--29298133288040b18710c0cdcbc0d836 29298133288040b18710c0cdcbc0d836--fa997255424448cb9d4faec3a0eddd32 eaaf3a11779442c8935677f82d705564 3ad57a7b5c6744c7801cf9f51260a6c9 33bcce7fee034d39b9fe7901651eaf2d--3ad57a7b5c6744c7801cf9f51260a6c9 1bfd987198444ad784bf1165bdd746c3 3 58d483f9729f477f810a7ef49b3a5918 X 3ad57a7b5c6744c7801cf9f51260a6c9--58d483f9729f477f810a7ef49b3a5918 58d483f9729f477f810a7ef49b3a5918--e1cfd726d01e468aaba93f92028b9ccf 7fd4e0a1dc39421c8f1e457e9da1e3e0 58d483f9729f477f810a7ef49b3a5918--7fd4e0a1dc39421c8f1e457e9da1e3e0 2d92ecbf203342ceab695acf0fb202c6 7fd4e0a1dc39421c8f1e457e9da1e3e0--2d92ecbf203342ceab695acf0fb202c6 f357711241194defb27ac0768216c6f5 2d92ecbf203342ceab695acf0fb202c6--f357711241194defb27ac0768216c6f5 76496beb043e4856966f241b2af48d75 f357711241194defb27ac0768216c6f5--76496beb043e4856966f241b2af48d75 ac99018bcb5340abb5cc4af409e5307e 76496beb043e4856966f241b2af48d75--ac99018bcb5340abb5cc4af409e5307e b73ecf58c0854f8ebe9a08881228f5ba ac99018bcb5340abb5cc4af409e5307e--b73ecf58c0854f8ebe9a08881228f5ba 0670b06b6b68466e843b866dba2eb8b4 b73ecf58c0854f8ebe9a08881228f5ba--0670b06b6b68466e843b866dba2eb8b4 598537b94d3445599e3d7526518768a6 0670b06b6b68466e843b866dba2eb8b4--598537b94d3445599e3d7526518768a6 b6f688d41cf14a33ba0a1781bacfe75a 598537b94d3445599e3d7526518768a6--b6f688d41cf14a33ba0a1781bacfe75a 1b8fb5d818b4419e92c3b7f349db50b1 b6f688d41cf14a33ba0a1781bacfe75a--1b8fb5d818b4419e92c3b7f349db50b1 5e6c6a1f718e45c0ae4f14862f8f2cf8 1b8fb5d818b4419e92c3b7f349db50b1--5e6c6a1f718e45c0ae4f14862f8f2cf8 d03574b0b9fa4a5da95b915bc5949e07 X 5e6c6a1f718e45c0ae4f14862f8f2cf8--d03574b0b9fa4a5da95b915bc5949e07 d03574b0b9fa4a5da95b915bc5949e07--9e25ee09f1754496b2dce83b6dc39c23 2203ba5e0f164087b01f212d537e6838 d03574b0b9fa4a5da95b915bc5949e07--2203ba5e0f164087b01f212d537e6838 84cb130796ff42f0a8342558b2d14c83 2203ba5e0f164087b01f212d537e6838--84cb130796ff42f0a8342558b2d14c83 b21fe02c9ca742d79f6047cfbb15a3df 84cb130796ff42f0a8342558b2d14c83--b21fe02c9ca742d79f6047cfbb15a3df 39b8033abd8a4c85acf97b4b062f7fe7 b21fe02c9ca742d79f6047cfbb15a3df--39b8033abd8a4c85acf97b4b062f7fe7 8e81f5be18ae4fb7982fc91c6534ddd3 39b8033abd8a4c85acf97b4b062f7fe7--8e81f5be18ae4fb7982fc91c6534ddd3 ecf0ade0d7c844a095094925e75afc69 X 8e81f5be18ae4fb7982fc91c6534ddd3--ecf0ade0d7c844a095094925e75afc69 ecf0ade0d7c844a095094925e75afc69--27480d234c1747cfa06f8d8e7ea8c678 7e682ab8e338442792996e9b5d3e0d55 ecf0ade0d7c844a095094925e75afc69--7e682ab8e338442792996e9b5d3e0d55 7abf2c35d3e24df5a2019eaead915bf1 7e682ab8e338442792996e9b5d3e0d55--7abf2c35d3e24df5a2019eaead915bf1 df4718c866c34816933a331c572b13c9 7abf2c35d3e24df5a2019eaead915bf1--df4718c866c34816933a331c572b13c9 f262b98f936a4e139ab801c9c869126c df4718c866c34816933a331c572b13c9--f262b98f936a4e139ab801c9c869126c a529f5c7a61549f9a7440b531c73fca5 f262b98f936a4e139ab801c9c869126c--a529f5c7a61549f9a7440b531c73fca5 fc408e3d402248d581784c9f57a49cd7 X a529f5c7a61549f9a7440b531c73fca5--fc408e3d402248d581784c9f57a49cd7 fc408e3d402248d581784c9f57a49cd7--8e0ad6fcdd22488a947c32dcbe54e168 87b522faee46482fa2eaee9839cf7793 fc408e3d402248d581784c9f57a49cd7--87b522faee46482fa2eaee9839cf7793 6f3f3abde89a49ed80f1e8eaf4b8f524 87b522faee46482fa2eaee9839cf7793--6f3f3abde89a49ed80f1e8eaf4b8f524 2b81b3c7c1804bcd9636754133f86266 X 6f3f3abde89a49ed80f1e8eaf4b8f524--2b81b3c7c1804bcd9636754133f86266 2b81b3c7c1804bcd9636754133f86266--7e9136c5f6bc4c16bb46de6c5c4c1429 e367faa8061a4f81982a8535926c5658 2b81b3c7c1804bcd9636754133f86266--e367faa8061a4f81982a8535926c5658 f54270543d454e30a1ac5700b886e6b8 e367faa8061a4f81982a8535926c5658--f54270543d454e30a1ac5700b886e6b8 dc2ba2e9b7214597bb0f5eeff4b88a9b f54270543d454e30a1ac5700b886e6b8--dc2ba2e9b7214597bb0f5eeff4b88a9b c3631a6c39884ba1908861c4dcf0bc72 dc2ba2e9b7214597bb0f5eeff4b88a9b--c3631a6c39884ba1908861c4dcf0bc72 1d2307dbdfae4a22916a4fcaa6ea242b c3631a6c39884ba1908861c4dcf0bc72--1d2307dbdfae4a22916a4fcaa6ea242b 0aaba1aaa8b444ce8c04bb666fdd2031 1d2307dbdfae4a22916a4fcaa6ea242b--0aaba1aaa8b444ce8c04bb666fdd2031 4a46a904386e4b4aa8929295c19ea454 0aaba1aaa8b444ce8c04bb666fdd2031--4a46a904386e4b4aa8929295c19ea454 8b979ff1d3b048f88d9892f6b7ae1b15 X 4a46a904386e4b4aa8929295c19ea454--8b979ff1d3b048f88d9892f6b7ae1b15 8b979ff1d3b048f88d9892f6b7ae1b15--7ad96883c98a426dae460b3da1df8952 f7f556f2365d43b3acc3b6dc8e4795d7 8b979ff1d3b048f88d9892f6b7ae1b15--f7f556f2365d43b3acc3b6dc8e4795d7 405985aad14d483ca27fbeef4b3d7db7 f7f556f2365d43b3acc3b6dc8e4795d7--405985aad14d483ca27fbeef4b3d7db7 b0ac265346864db586418d70f28b072f X 405985aad14d483ca27fbeef4b3d7db7--b0ac265346864db586418d70f28b072f b0ac265346864db586418d70f28b072f--3ecf27823405488ba7bf5daa1e834f5a 5850215a96d9497babb67e26d3a9b171 b0ac265346864db586418d70f28b072f--5850215a96d9497babb67e26d3a9b171 9dcb0b746bed4ccc94682cb5c0f76561 5850215a96d9497babb67e26d3a9b171--9dcb0b746bed4ccc94682cb5c0f76561 5399b1dbf1e644778955d55c16c5f91c 9dcb0b746bed4ccc94682cb5c0f76561--5399b1dbf1e644778955d55c16c5f91c 696b2aa7014348439add64253e89fe0a 5399b1dbf1e644778955d55c16c5f91c--696b2aa7014348439add64253e89fe0a d6f2636ad995483987c7f6b5b1c54a16 696b2aa7014348439add64253e89fe0a--d6f2636ad995483987c7f6b5b1c54a16 550dfc7991634cd79f6cbb882408c770 d6f2636ad995483987c7f6b5b1c54a16--550dfc7991634cd79f6cbb882408c770 37efdbca810f413ea3dc5e3462b55dde 550dfc7991634cd79f6cbb882408c770--37efdbca810f413ea3dc5e3462b55dde e7ba1f97dc3f47348b6766da5c0f71a4 37efdbca810f413ea3dc5e3462b55dde--e7ba1f97dc3f47348b6766da5c0f71a4 041a4213127f480b9a8ced0da32dadae e7ba1f97dc3f47348b6766da5c0f71a4--041a4213127f480b9a8ced0da32dadae d8f9503b9e5f4a33ad27134a97ffaea1 041a4213127f480b9a8ced0da32dadae--d8f9503b9e5f4a33ad27134a97ffaea1 8f627203439d4c35b031d7c30341c5cc d8f9503b9e5f4a33ad27134a97ffaea1--8f627203439d4c35b031d7c30341c5cc c013ea2d2974424397faee8e8667ec6f X 8f627203439d4c35b031d7c30341c5cc--c013ea2d2974424397faee8e8667ec6f c013ea2d2974424397faee8e8667ec6f--a31fb65eee424bad93dd3dfd189545f9 fa3e6c16e93744d8ae93730d0ab5c585 c013ea2d2974424397faee8e8667ec6f--fa3e6c16e93744d8ae93730d0ab5c585 a63a64da44784a50963d6c88d32a35c2 X fa3e6c16e93744d8ae93730d0ab5c585--a63a64da44784a50963d6c88d32a35c2 a63a64da44784a50963d6c88d32a35c2--711869d945c5419980fec413ad37af92 81f40bd3abf3412ab0a17c458623c2b2 RZ(-1.0*g0) a63a64da44784a50963d6c88d32a35c2--81f40bd3abf3412ab0a17c458623c2b2 be1d8b447c294d1a85d4e646f66fd0f7 X 81f40bd3abf3412ab0a17c458623c2b2--be1d8b447c294d1a85d4e646f66fd0f7 be1d8b447c294d1a85d4e646f66fd0f7--8b72126c3bc349cc91203fcea8b28e58 ffb3337b3651497a9fac54fe93c9fb3a X be1d8b447c294d1a85d4e646f66fd0f7--ffb3337b3651497a9fac54fe93c9fb3a ffb3337b3651497a9fac54fe93c9fb3a--79ab7378f59e4113a2fe5432a84c785f 725397047939455cb9e54b3aa9417a90 ffb3337b3651497a9fac54fe93c9fb3a--725397047939455cb9e54b3aa9417a90 76a582fdc2314a4c9c7b6a1a10048d0e 725397047939455cb9e54b3aa9417a90--76a582fdc2314a4c9c7b6a1a10048d0e c9281469717e4b1bbf59107afd033049 76a582fdc2314a4c9c7b6a1a10048d0e--c9281469717e4b1bbf59107afd033049 a70a2801defb472baf8b2a2fdb4e62d4 X c9281469717e4b1bbf59107afd033049--a70a2801defb472baf8b2a2fdb4e62d4 a70a2801defb472baf8b2a2fdb4e62d4--d7092c46b00a439b83553fa7adeeeb46 7b8ca7a93f5a498c83f560ca32194a2c X a70a2801defb472baf8b2a2fdb4e62d4--7b8ca7a93f5a498c83f560ca32194a2c 7b8ca7a93f5a498c83f560ca32194a2c--7028e338227642cb9806ed94eb13fa4c 07f36ccfe946431a8129ec3085a76fc8 7b8ca7a93f5a498c83f560ca32194a2c--07f36ccfe946431a8129ec3085a76fc8 b8f33114e850481e8f20c1d343edbc05 07f36ccfe946431a8129ec3085a76fc8--b8f33114e850481e8f20c1d343edbc05 696c24cfe9a74d1ea83f247b6e2c9ba6 b8f33114e850481e8f20c1d343edbc05--696c24cfe9a74d1ea83f247b6e2c9ba6 a2e734bae1274ba896c63b12dee40f0b 696c24cfe9a74d1ea83f247b6e2c9ba6--a2e734bae1274ba896c63b12dee40f0b dc3612f4a9cf4cf3830d9b18d2f8b2cc a2e734bae1274ba896c63b12dee40f0b--dc3612f4a9cf4cf3830d9b18d2f8b2cc 2052dae6ae8f412b9340a4a392dcc563 dc3612f4a9cf4cf3830d9b18d2f8b2cc--2052dae6ae8f412b9340a4a392dcc563 dc7bb8025c9948fd8568eeeec339b342 2052dae6ae8f412b9340a4a392dcc563--dc7bb8025c9948fd8568eeeec339b342 ebad7b4cd49d4851b70509c62351908f X dc7bb8025c9948fd8568eeeec339b342--ebad7b4cd49d4851b70509c62351908f ebad7b4cd49d4851b70509c62351908f--555be8f39b5c4adab8fe2e8c2e621c91 821ca04efd4c486f93e1839c1e57d2a6 X ebad7b4cd49d4851b70509c62351908f--821ca04efd4c486f93e1839c1e57d2a6 821ca04efd4c486f93e1839c1e57d2a6--25aba4fbcd25482e8854bee7035d1991 e2a7ddff2ccf478387de9a078268f4be 821ca04efd4c486f93e1839c1e57d2a6--e2a7ddff2ccf478387de9a078268f4be 422f2afa785f48778b98f8a779d358e4 e2a7ddff2ccf478387de9a078268f4be--422f2afa785f48778b98f8a779d358e4 926a5515d4e946d3baa147a24b504048 422f2afa785f48778b98f8a779d358e4--926a5515d4e946d3baa147a24b504048 cddf057cf40e4e44bf967ecd359274b5 926a5515d4e946d3baa147a24b504048--cddf057cf40e4e44bf967ecd359274b5 8f0cd46ab247400296bc865982ce074c cddf057cf40e4e44bf967ecd359274b5--8f0cd46ab247400296bc865982ce074c c693661c6b5547d999f9cd59a347d8bf 8f0cd46ab247400296bc865982ce074c--c693661c6b5547d999f9cd59a347d8bf 686d4c98ae314974813c29af7cce2e24 c693661c6b5547d999f9cd59a347d8bf--686d4c98ae314974813c29af7cce2e24 b404883707e843bd903ea28993fe2514 686d4c98ae314974813c29af7cce2e24--b404883707e843bd903ea28993fe2514 4a8d1f0b35514e2d966559a994808231 b404883707e843bd903ea28993fe2514--4a8d1f0b35514e2d966559a994808231 9ea4c163af694adf8e3f6d88f875d4b1 4a8d1f0b35514e2d966559a994808231--9ea4c163af694adf8e3f6d88f875d4b1 66c6254363bd47fb8937e6efa2f6fc64 9ea4c163af694adf8e3f6d88f875d4b1--66c6254363bd47fb8937e6efa2f6fc64 d6317ddc99ef4b35a5d8b02eb936e097 X 66c6254363bd47fb8937e6efa2f6fc64--d6317ddc99ef4b35a5d8b02eb936e097 d6317ddc99ef4b35a5d8b02eb936e097--cb6380ffde324ca29188cee170319a98 630195895b9541c2a1a445010d3dcd8f d6317ddc99ef4b35a5d8b02eb936e097--630195895b9541c2a1a445010d3dcd8f a12e1603ccc2461597095f2558f03a04 630195895b9541c2a1a445010d3dcd8f--a12e1603ccc2461597095f2558f03a04 c18ef241d33b498ea31a15060c1c469d a12e1603ccc2461597095f2558f03a04--c18ef241d33b498ea31a15060c1c469d 04b277454af64b5198a641090a51079a c18ef241d33b498ea31a15060c1c469d--04b277454af64b5198a641090a51079a f00627118ef14c7da1280a4e3d2a0a77 04b277454af64b5198a641090a51079a--f00627118ef14c7da1280a4e3d2a0a77 adb001c8e96648fcbde7864f62484650 f00627118ef14c7da1280a4e3d2a0a77--adb001c8e96648fcbde7864f62484650 cb5bba4874e2488fb04373211b1d0e0f adb001c8e96648fcbde7864f62484650--cb5bba4874e2488fb04373211b1d0e0f f2cbd5f150104733a669eb7444f0849d cb5bba4874e2488fb04373211b1d0e0f--f2cbd5f150104733a669eb7444f0849d fffd33d14c3940d3a06dc9c6a7c38881 f2cbd5f150104733a669eb7444f0849d--fffd33d14c3940d3a06dc9c6a7c38881 893753ad03134d9f8a98b66932ef2e27 fffd33d14c3940d3a06dc9c6a7c38881--893753ad03134d9f8a98b66932ef2e27 71a251795ecf44f2bd27086305d917bd 893753ad03134d9f8a98b66932ef2e27--71a251795ecf44f2bd27086305d917bd acaec86cff104675972290cd99cf6f6b 71a251795ecf44f2bd27086305d917bd--acaec86cff104675972290cd99cf6f6b 788b33b3f52f43f29ba17ff29c58fa09 acaec86cff104675972290cd99cf6f6b--788b33b3f52f43f29ba17ff29c58fa09 b3e8d29848d144c09b9f4d8b703ba7ff 788b33b3f52f43f29ba17ff29c58fa09--b3e8d29848d144c09b9f4d8b703ba7ff f0f7786e02cc467e9d080c4737bf6090 b3e8d29848d144c09b9f4d8b703ba7ff--f0f7786e02cc467e9d080c4737bf6090 8133f9bce638437487ebfafdbae98125 f0f7786e02cc467e9d080c4737bf6090--8133f9bce638437487ebfafdbae98125 fa6a76b896754396b30963d18ac422f5 8133f9bce638437487ebfafdbae98125--fa6a76b896754396b30963d18ac422f5 cea171aad08f49f780f327294944cf5a fa6a76b896754396b30963d18ac422f5--cea171aad08f49f780f327294944cf5a fb2c7a8aaf8244c69416bf2cd93f45f1 cea171aad08f49f780f327294944cf5a--fb2c7a8aaf8244c69416bf2cd93f45f1 7e6840e214c4422285faf632b123aee1 fb2c7a8aaf8244c69416bf2cd93f45f1--7e6840e214c4422285faf632b123aee1 43b5865e877c45bf9f91f197d64e94df 7e6840e214c4422285faf632b123aee1--43b5865e877c45bf9f91f197d64e94df 6522017171424af79428e51a3d3fd0b2 43b5865e877c45bf9f91f197d64e94df--6522017171424af79428e51a3d3fd0b2 abf0c3f96ec343c19c23e89aa33ee1ec 6522017171424af79428e51a3d3fd0b2--abf0c3f96ec343c19c23e89aa33ee1ec 06714e1b09eb4b78bbd6e0dfab2d7d6a abf0c3f96ec343c19c23e89aa33ee1ec--06714e1b09eb4b78bbd6e0dfab2d7d6a b8362a4e6bc445748290f2c13918f584 06714e1b09eb4b78bbd6e0dfab2d7d6a--b8362a4e6bc445748290f2c13918f584 49eca77724e64c0899fa8708e0d1d0f7 b8362a4e6bc445748290f2c13918f584--49eca77724e64c0899fa8708e0d1d0f7 fc07e51249df4d18a4a19caf250ae7c6 49eca77724e64c0899fa8708e0d1d0f7--fc07e51249df4d18a4a19caf250ae7c6 824a2fff7204442d942b085f58c59064 fc07e51249df4d18a4a19caf250ae7c6--824a2fff7204442d942b085f58c59064 2cc42b8e7dad43619f5d773f1524290a 824a2fff7204442d942b085f58c59064--2cc42b8e7dad43619f5d773f1524290a 44e201eff4a34648834220982eb0b3de 2cc42b8e7dad43619f5d773f1524290a--44e201eff4a34648834220982eb0b3de ffac6c4b7de6467b82f4ce76f7b15347 44e201eff4a34648834220982eb0b3de--ffac6c4b7de6467b82f4ce76f7b15347 a3a5a4b05f3f4bb99c1fa8affe18a75f ffac6c4b7de6467b82f4ce76f7b15347--a3a5a4b05f3f4bb99c1fa8affe18a75f c5ff2463206540beb9b036ab8d2e7535 a3a5a4b05f3f4bb99c1fa8affe18a75f--c5ff2463206540beb9b036ab8d2e7535 78904fc2f26e4cff859c23e1eb325090 c5ff2463206540beb9b036ab8d2e7535--78904fc2f26e4cff859c23e1eb325090 3b82e259df7e42ebb5ede8ded262f629 78904fc2f26e4cff859c23e1eb325090--3b82e259df7e42ebb5ede8ded262f629 606f8de4e08a474189b4c091021f629f 3b82e259df7e42ebb5ede8ded262f629--606f8de4e08a474189b4c091021f629f 1e0adaf7c0cd4ba5b28761fc7f40d14e 606f8de4e08a474189b4c091021f629f--1e0adaf7c0cd4ba5b28761fc7f40d14e 7b4f4036a680498ebe742432b14c76b2 RX(b02) 1e0adaf7c0cd4ba5b28761fc7f40d14e--7b4f4036a680498ebe742432b14c76b2 7ca44f4c212c4dd09d119a5420ab0ba7 7b4f4036a680498ebe742432b14c76b2--7ca44f4c212c4dd09d119a5420ab0ba7 fb34187e41824245909da5897d3876f4 X 7ca44f4c212c4dd09d119a5420ab0ba7--fb34187e41824245909da5897d3876f4 fb34187e41824245909da5897d3876f4--791d2b89365a4d16a3f7887164a36e2d 8ba43caa764f4fec866276fc02b453e9 fb34187e41824245909da5897d3876f4--8ba43caa764f4fec866276fc02b453e9 3d47366e45204af79cff40c2529db190 8ba43caa764f4fec866276fc02b453e9--3d47366e45204af79cff40c2529db190 77efa09703924058a3ba2f865f84c161 3d47366e45204af79cff40c2529db190--77efa09703924058a3ba2f865f84c161 1c84b8a142404461be9c9ff0ce617f92 77efa09703924058a3ba2f865f84c161--1c84b8a142404461be9c9ff0ce617f92 872c17ce41cd4c0e9fd91e7b97ccb856 1c84b8a142404461be9c9ff0ce617f92--872c17ce41cd4c0e9fd91e7b97ccb856 474c3986c3d3460191e0aa80ef13a171 872c17ce41cd4c0e9fd91e7b97ccb856--474c3986c3d3460191e0aa80ef13a171 60df2f887e3d48f198fa60f0905fa0cb 474c3986c3d3460191e0aa80ef13a171--60df2f887e3d48f198fa60f0905fa0cb 33c7295fae9a4d79a267df1eae05636a 60df2f887e3d48f198fa60f0905fa0cb--33c7295fae9a4d79a267df1eae05636a 6c438fcd1e84452982c7a65641cc3679 33c7295fae9a4d79a267df1eae05636a--6c438fcd1e84452982c7a65641cc3679 d9af5d8e5ac746b39ca316fe249feec0 6c438fcd1e84452982c7a65641cc3679--d9af5d8e5ac746b39ca316fe249feec0 dff99ae3b25d45658d0e8c98d9e7a921 d9af5d8e5ac746b39ca316fe249feec0--dff99ae3b25d45658d0e8c98d9e7a921 c3799ca1cea046eeb03d1170ec27daa4 X dff99ae3b25d45658d0e8c98d9e7a921--c3799ca1cea046eeb03d1170ec27daa4 c3799ca1cea046eeb03d1170ec27daa4--8c4ab967c9cd4a83818d7c14672524b0 d0c8da9500d14d2d9a5b505adf39978c c3799ca1cea046eeb03d1170ec27daa4--d0c8da9500d14d2d9a5b505adf39978c 0a6be98edf0349abbff0f435df51a65c d0c8da9500d14d2d9a5b505adf39978c--0a6be98edf0349abbff0f435df51a65c 8d97e36494974d11a26f067b6daae8e3 0a6be98edf0349abbff0f435df51a65c--8d97e36494974d11a26f067b6daae8e3 dd35cf51cce34a21aae6b0250e5eb5c8 8d97e36494974d11a26f067b6daae8e3--dd35cf51cce34a21aae6b0250e5eb5c8 3881b21a5ed241e88daa4e5deccf0f5d dd35cf51cce34a21aae6b0250e5eb5c8--3881b21a5ed241e88daa4e5deccf0f5d 9e5decbc567c4167a9fdb8f59969aa30 X 3881b21a5ed241e88daa4e5deccf0f5d--9e5decbc567c4167a9fdb8f59969aa30 9e5decbc567c4167a9fdb8f59969aa30--58875e9be3e549d8925181919353b60d ffe070976a554a27adace4f5ff2896a8 9e5decbc567c4167a9fdb8f59969aa30--ffe070976a554a27adace4f5ff2896a8 fb60519b7b31426588b2d39f5a612513 ffe070976a554a27adace4f5ff2896a8--fb60519b7b31426588b2d39f5a612513 25b3da226cb0410baa4f8bb5a59af51a fb60519b7b31426588b2d39f5a612513--25b3da226cb0410baa4f8bb5a59af51a 5db1288f8d8249bfabef422b6b02a556 25b3da226cb0410baa4f8bb5a59af51a--5db1288f8d8249bfabef422b6b02a556 e917a587ea51473c9b01d5f541f77a8e 5db1288f8d8249bfabef422b6b02a556--e917a587ea51473c9b01d5f541f77a8e 886ab659808740b09af747081f8016b5 X e917a587ea51473c9b01d5f541f77a8e--886ab659808740b09af747081f8016b5 886ab659808740b09af747081f8016b5--cf73283a5ca74b24a16172db35a64ae4 a94344c175344f1cb1c6fe8f4f67968d 886ab659808740b09af747081f8016b5--a94344c175344f1cb1c6fe8f4f67968d e9568485e41944349ccd908324f393b7 a94344c175344f1cb1c6fe8f4f67968d--e9568485e41944349ccd908324f393b7 7fcfa52ac111463a90b34babb5324f5c X e9568485e41944349ccd908324f393b7--7fcfa52ac111463a90b34babb5324f5c 7fcfa52ac111463a90b34babb5324f5c--10f29353344f4d1bb63b3079b5198e8d 47de2f257dd146f6806a5a7ca7d2804c 7fcfa52ac111463a90b34babb5324f5c--47de2f257dd146f6806a5a7ca7d2804c b812a3c65a8e43c2beae29d18ad16397 47de2f257dd146f6806a5a7ca7d2804c--b812a3c65a8e43c2beae29d18ad16397 a038a0e2352442b58cf8b434aab81416 b812a3c65a8e43c2beae29d18ad16397--a038a0e2352442b58cf8b434aab81416 02e6323f74314bfdb12e7c418209e384 a038a0e2352442b58cf8b434aab81416--02e6323f74314bfdb12e7c418209e384 fad6868ad6904d62ba3878312939863b 02e6323f74314bfdb12e7c418209e384--fad6868ad6904d62ba3878312939863b 52f6a0408bef41bfb964aeb9630e73f9 fad6868ad6904d62ba3878312939863b--52f6a0408bef41bfb964aeb9630e73f9 9349f60915d54a9186555af99af60f64 52f6a0408bef41bfb964aeb9630e73f9--9349f60915d54a9186555af99af60f64 e12ca4c94ef4488b8dc76d1f57e83044 X 9349f60915d54a9186555af99af60f64--e12ca4c94ef4488b8dc76d1f57e83044 e12ca4c94ef4488b8dc76d1f57e83044--0a849f89f1d74265bac427b6c126f7bb 7eb9afaee0504761b66f41118c46f861 e12ca4c94ef4488b8dc76d1f57e83044--7eb9afaee0504761b66f41118c46f861 28ddfc1f4f1f445485bfe8a0eff1382d 7eb9afaee0504761b66f41118c46f861--28ddfc1f4f1f445485bfe8a0eff1382d d267097251d245c19c4761743ee09345 X 28ddfc1f4f1f445485bfe8a0eff1382d--d267097251d245c19c4761743ee09345 d267097251d245c19c4761743ee09345--82aa81f0e103447a8805d8c5cf3c917a 6aabbddb67284d36b3c77f77d6fcb1e5 d267097251d245c19c4761743ee09345--6aabbddb67284d36b3c77f77d6fcb1e5 e8195d4a70774665b598cd898031edbd 6aabbddb67284d36b3c77f77d6fcb1e5--e8195d4a70774665b598cd898031edbd fca54e427a044d0c9dd3198d255f2a20 e8195d4a70774665b598cd898031edbd--fca54e427a044d0c9dd3198d255f2a20 f1f18fab400a4c5a8c18ee07528b7af7 fca54e427a044d0c9dd3198d255f2a20--f1f18fab400a4c5a8c18ee07528b7af7 fde8ea33cae24fb696ae64b21a846b05 f1f18fab400a4c5a8c18ee07528b7af7--fde8ea33cae24fb696ae64b21a846b05 45b3d33c5fef4f4fae280355a5ccc9d1 fde8ea33cae24fb696ae64b21a846b05--45b3d33c5fef4f4fae280355a5ccc9d1 79c09e17870b4911ae813ecc99acd7f9 45b3d33c5fef4f4fae280355a5ccc9d1--79c09e17870b4911ae813ecc99acd7f9 75a10af9f7b5444a9051716c569a180b 79c09e17870b4911ae813ecc99acd7f9--75a10af9f7b5444a9051716c569a180b e5f9b40f1968448183fe5b5f81ce4cbf 75a10af9f7b5444a9051716c569a180b--e5f9b40f1968448183fe5b5f81ce4cbf c392c4ffd90a4a898bc2b92c5f9a495d e5f9b40f1968448183fe5b5f81ce4cbf--c392c4ffd90a4a898bc2b92c5f9a495d db75b2eee51a4cd4a09d6d6601413bae c392c4ffd90a4a898bc2b92c5f9a495d--db75b2eee51a4cd4a09d6d6601413bae 6ebd058cf2174ae0bb2864fb3ccfe773 X db75b2eee51a4cd4a09d6d6601413bae--6ebd058cf2174ae0bb2864fb3ccfe773 6ebd058cf2174ae0bb2864fb3ccfe773--b022f9bde5fe49359367f811ca07943e 1ead93ab69ab4188b203bb42026d8c53 6ebd058cf2174ae0bb2864fb3ccfe773--1ead93ab69ab4188b203bb42026d8c53 265b06c2f236430898721bc5a59cd061 X 1ead93ab69ab4188b203bb42026d8c53--265b06c2f236430898721bc5a59cd061 265b06c2f236430898721bc5a59cd061--835f8b90f00746a1906e1b5dd0eec8a8 df2881600a5f4338973a29be7cf6c92a RZ(-1.0*g1) 265b06c2f236430898721bc5a59cd061--df2881600a5f4338973a29be7cf6c92a 6201065091b94b7c837b2f0246b071e2 X df2881600a5f4338973a29be7cf6c92a--6201065091b94b7c837b2f0246b071e2 6201065091b94b7c837b2f0246b071e2--fd618ea7ec4948d799dc84e3813810ba 2b6c6c73844a4fd38f0a0ae3e0a81b6b X 6201065091b94b7c837b2f0246b071e2--2b6c6c73844a4fd38f0a0ae3e0a81b6b 2b6c6c73844a4fd38f0a0ae3e0a81b6b--cdb560914910471da858193e0315b601 afd797f698114c3788646e48a1fff8dd 2b6c6c73844a4fd38f0a0ae3e0a81b6b--afd797f698114c3788646e48a1fff8dd 69dfd1f1753d405ebc008ff8b403edf1 afd797f698114c3788646e48a1fff8dd--69dfd1f1753d405ebc008ff8b403edf1 bc4e820b3beb4ea09cf96599646e8f5c 69dfd1f1753d405ebc008ff8b403edf1--bc4e820b3beb4ea09cf96599646e8f5c b7a2fed2096c48b3b81642816ace7176 X bc4e820b3beb4ea09cf96599646e8f5c--b7a2fed2096c48b3b81642816ace7176 b7a2fed2096c48b3b81642816ace7176--fc25d06788f94f1eba79ce36d5825a01 259aad348a4043c0af396ac77bd20d62 X b7a2fed2096c48b3b81642816ace7176--259aad348a4043c0af396ac77bd20d62 259aad348a4043c0af396ac77bd20d62--15fcb8d306c34ad3aa60012709dec0f2 d59ea11505124985904136b8e3c63a14 259aad348a4043c0af396ac77bd20d62--d59ea11505124985904136b8e3c63a14 a1bb482a375743ba8737947b9bcf14e8 d59ea11505124985904136b8e3c63a14--a1bb482a375743ba8737947b9bcf14e8 b274fcd2f2784892a0e7d0320f4389b2 a1bb482a375743ba8737947b9bcf14e8--b274fcd2f2784892a0e7d0320f4389b2 4b2e86df14584d5891fb935df90dfd4c b274fcd2f2784892a0e7d0320f4389b2--4b2e86df14584d5891fb935df90dfd4c 7a129889530a45a1addabaa8824f8e71 4b2e86df14584d5891fb935df90dfd4c--7a129889530a45a1addabaa8824f8e71 90787416f2644a32bd76bf880cb1c11a 7a129889530a45a1addabaa8824f8e71--90787416f2644a32bd76bf880cb1c11a f658e368491c4eb1b34c868642f2264a 90787416f2644a32bd76bf880cb1c11a--f658e368491c4eb1b34c868642f2264a c25598eeecc54c3c9c51533b51f9f733 X f658e368491c4eb1b34c868642f2264a--c25598eeecc54c3c9c51533b51f9f733 c25598eeecc54c3c9c51533b51f9f733--b3e7596b1611467ea408967d92f31680 8d1ba3da71b54b2881230899097931b9 X c25598eeecc54c3c9c51533b51f9f733--8d1ba3da71b54b2881230899097931b9 8d1ba3da71b54b2881230899097931b9--91357293003a4dabb0d0a17c7bd0e2e4 6c7935bcaf8b47f784f0173d69e60d31 8d1ba3da71b54b2881230899097931b9--6c7935bcaf8b47f784f0173d69e60d31 c2448e4d98a44486a75e2b13e2c25d97 6c7935bcaf8b47f784f0173d69e60d31--c2448e4d98a44486a75e2b13e2c25d97 a192e373b85c432b9e49beae966ee3bc c2448e4d98a44486a75e2b13e2c25d97--a192e373b85c432b9e49beae966ee3bc 7819200d530e42fb8023c5c5728496cc a192e373b85c432b9e49beae966ee3bc--7819200d530e42fb8023c5c5728496cc fa507e613dc5470d964b143fdbe2ca6a 7819200d530e42fb8023c5c5728496cc--fa507e613dc5470d964b143fdbe2ca6a 12881bafc100451096a9f7f12fcc5df1 fa507e613dc5470d964b143fdbe2ca6a--12881bafc100451096a9f7f12fcc5df1 681a0ddab3804dddbf171044ed017eb1 12881bafc100451096a9f7f12fcc5df1--681a0ddab3804dddbf171044ed017eb1 465bfcf47b4340508795e89034063be5 681a0ddab3804dddbf171044ed017eb1--465bfcf47b4340508795e89034063be5 49ca249d0fff4aa1991c687bdcd4f81d 465bfcf47b4340508795e89034063be5--49ca249d0fff4aa1991c687bdcd4f81d 3c9efc11b80d468db0400f8a1f8b771a 49ca249d0fff4aa1991c687bdcd4f81d--3c9efc11b80d468db0400f8a1f8b771a e6906f5ac09a4662882077c29ed18fea 3c9efc11b80d468db0400f8a1f8b771a--e6906f5ac09a4662882077c29ed18fea 1a44454cfec344b79f0c814798056443 X e6906f5ac09a4662882077c29ed18fea--1a44454cfec344b79f0c814798056443 1a44454cfec344b79f0c814798056443--4ad6a73d557441ccbece2cc2825b1c3d 458a505d86174c50ac884014895c397a 1a44454cfec344b79f0c814798056443--458a505d86174c50ac884014895c397a 7d90718303a74a1b863a01db25a280f2 458a505d86174c50ac884014895c397a--7d90718303a74a1b863a01db25a280f2 7feeea51306c4d2d8a139be71db250b3 7d90718303a74a1b863a01db25a280f2--7feeea51306c4d2d8a139be71db250b3 7cfa1f4f5b044a068fddd33c1f1229f0 7feeea51306c4d2d8a139be71db250b3--7cfa1f4f5b044a068fddd33c1f1229f0 ded66f8d87f748fe95aeda1e5405384f 7cfa1f4f5b044a068fddd33c1f1229f0--ded66f8d87f748fe95aeda1e5405384f 33b50cfe347649b59442fc357dd64e04 ded66f8d87f748fe95aeda1e5405384f--33b50cfe347649b59442fc357dd64e04 7f4aadb1400045f0bb92169b2a7e6a40 33b50cfe347649b59442fc357dd64e04--7f4aadb1400045f0bb92169b2a7e6a40 106c80c2c3d345f597477f2f51e16846 7f4aadb1400045f0bb92169b2a7e6a40--106c80c2c3d345f597477f2f51e16846 6a6b2159090547d5bb005a9303435e86 106c80c2c3d345f597477f2f51e16846--6a6b2159090547d5bb005a9303435e86 c7f657c2f0d549a9b0d9e5d891609a72 6a6b2159090547d5bb005a9303435e86--c7f657c2f0d549a9b0d9e5d891609a72 259f714f1fa248e3bc390aba19c48fa7 c7f657c2f0d549a9b0d9e5d891609a72--259f714f1fa248e3bc390aba19c48fa7 1cfe3f78dbfd4be98581519268ef83ca 259f714f1fa248e3bc390aba19c48fa7--1cfe3f78dbfd4be98581519268ef83ca d7bae461d9f745519a53259ccfe6124a 1cfe3f78dbfd4be98581519268ef83ca--d7bae461d9f745519a53259ccfe6124a ed3d15acbec44af89409348bdd15b717 d7bae461d9f745519a53259ccfe6124a--ed3d15acbec44af89409348bdd15b717 51e1407586df4394a79effec4765caeb ed3d15acbec44af89409348bdd15b717--51e1407586df4394a79effec4765caeb b0a2deb2cad646dc9ff5eaabb1ac51e7 51e1407586df4394a79effec4765caeb--b0a2deb2cad646dc9ff5eaabb1ac51e7 8ce3cd0303cc429c8e44358d0e9152e6 b0a2deb2cad646dc9ff5eaabb1ac51e7--8ce3cd0303cc429c8e44358d0e9152e6 9b0424ebf726487b945e4d12718e506a 8ce3cd0303cc429c8e44358d0e9152e6--9b0424ebf726487b945e4d12718e506a e27b56bab8b94e1daaef0c1113bf9062 9b0424ebf726487b945e4d12718e506a--e27b56bab8b94e1daaef0c1113bf9062 1faedcb546b04f3199d9306346bc8cf2 e27b56bab8b94e1daaef0c1113bf9062--1faedcb546b04f3199d9306346bc8cf2 f24e1c904b53471287563ef42657b577 1faedcb546b04f3199d9306346bc8cf2--f24e1c904b53471287563ef42657b577 8392631af682451db6735e622ffff59c f24e1c904b53471287563ef42657b577--8392631af682451db6735e622ffff59c f106d06b1a594476b3b64fa747502c76 8392631af682451db6735e622ffff59c--f106d06b1a594476b3b64fa747502c76 770f790264ee444ebc6fc04d657b3d90 f106d06b1a594476b3b64fa747502c76--770f790264ee444ebc6fc04d657b3d90 2232023ea9ec401a9ccb39bca8253462 770f790264ee444ebc6fc04d657b3d90--2232023ea9ec401a9ccb39bca8253462 4ee66d68b39240c2906af2672a39f1d3 2232023ea9ec401a9ccb39bca8253462--4ee66d68b39240c2906af2672a39f1d3 9f6402313d014ccf9e1266510bf33e57 4ee66d68b39240c2906af2672a39f1d3--9f6402313d014ccf9e1266510bf33e57 ac5414a54e5b419fb4da54d534c7c4fb 9f6402313d014ccf9e1266510bf33e57--ac5414a54e5b419fb4da54d534c7c4fb 4ce2cab093944f6ea1c88f688594a1b0 ac5414a54e5b419fb4da54d534c7c4fb--4ce2cab093944f6ea1c88f688594a1b0 9402db2322d545a4a437d35f421ac7ca 4ce2cab093944f6ea1c88f688594a1b0--9402db2322d545a4a437d35f421ac7ca 7cb82e1131e5433eb34f19eed4aba70b 9402db2322d545a4a437d35f421ac7ca--7cb82e1131e5433eb34f19eed4aba70b 0a340d96108c423fa1c86b31b91aeaa3 7cb82e1131e5433eb34f19eed4aba70b--0a340d96108c423fa1c86b31b91aeaa3 81438bbd88d14c77b1b744fca38bf6d3 0a340d96108c423fa1c86b31b91aeaa3--81438bbd88d14c77b1b744fca38bf6d3 6b608f4bd4e249a5b2b5d68d9b848af9 81438bbd88d14c77b1b744fca38bf6d3--6b608f4bd4e249a5b2b5d68d9b848af9 a42ab7894ed24954917eea90ee9724f9 6b608f4bd4e249a5b2b5d68d9b848af9--a42ab7894ed24954917eea90ee9724f9 48de21b9e39746f3a28ef1d3375a633c a42ab7894ed24954917eea90ee9724f9--48de21b9e39746f3a28ef1d3375a633c abd1d6648f33456092bf8538eb9ac246 48de21b9e39746f3a28ef1d3375a633c--abd1d6648f33456092bf8538eb9ac246 91542376ec96408d9e728dde6462639c RX(b12) abd1d6648f33456092bf8538eb9ac246--91542376ec96408d9e728dde6462639c 91542376ec96408d9e728dde6462639c--eaaf3a11779442c8935677f82d705564 26977008c7804e9bb9b6224f18a03bce 48d8520ed7ee4879adfa66e03aaaf32a 1bfd987198444ad784bf1165bdd746c3--48d8520ed7ee4879adfa66e03aaaf32a d134ac83de91451a8b0c42dfba10cc45 4 6dcf0610e5794a108ac4a348da6ec6cc 48d8520ed7ee4879adfa66e03aaaf32a--6dcf0610e5794a108ac4a348da6ec6cc fa41e276c61746728260b071408b3272 X 6dcf0610e5794a108ac4a348da6ec6cc--fa41e276c61746728260b071408b3272 fa41e276c61746728260b071408b3272--7fd4e0a1dc39421c8f1e457e9da1e3e0 e99b38e72c5347829efa859e801f83c4 fa41e276c61746728260b071408b3272--e99b38e72c5347829efa859e801f83c4 e116c1ebbbcb427fb59165c865e7b23f e99b38e72c5347829efa859e801f83c4--e116c1ebbbcb427fb59165c865e7b23f 9dd6c8984ccf499d9086a26ea18c6907 e116c1ebbbcb427fb59165c865e7b23f--9dd6c8984ccf499d9086a26ea18c6907 72e992f80f18454e99ec98018b0e6fe1 9dd6c8984ccf499d9086a26ea18c6907--72e992f80f18454e99ec98018b0e6fe1 3a0c066e7c754a36aadf49b786bcdec2 72e992f80f18454e99ec98018b0e6fe1--3a0c066e7c754a36aadf49b786bcdec2 0568605eefc44a79a2fcd5b290c0c205 3a0c066e7c754a36aadf49b786bcdec2--0568605eefc44a79a2fcd5b290c0c205 37f41b23efbf4a068006fa295fc57416 0568605eefc44a79a2fcd5b290c0c205--37f41b23efbf4a068006fa295fc57416 1663932afd81420e9bef72c771eb0d82 37f41b23efbf4a068006fa295fc57416--1663932afd81420e9bef72c771eb0d82 1702e4ba31124999a7cfcd6fd2577a69 1663932afd81420e9bef72c771eb0d82--1702e4ba31124999a7cfcd6fd2577a69 b40d0e6e4267432bbc84b86524bfaefe X 1702e4ba31124999a7cfcd6fd2577a69--b40d0e6e4267432bbc84b86524bfaefe b40d0e6e4267432bbc84b86524bfaefe--5e6c6a1f718e45c0ae4f14862f8f2cf8 f6bb67eb72864919a39b04ae2ab0cead b40d0e6e4267432bbc84b86524bfaefe--f6bb67eb72864919a39b04ae2ab0cead b98ffde38b5d4acaafe43af22c844010 f6bb67eb72864919a39b04ae2ab0cead--b98ffde38b5d4acaafe43af22c844010 21ff0b4196404eca9384f3ff45011521 b98ffde38b5d4acaafe43af22c844010--21ff0b4196404eca9384f3ff45011521 bf73044ceeba42d3bae945e49650f579 21ff0b4196404eca9384f3ff45011521--bf73044ceeba42d3bae945e49650f579 5242f2dd3cc34f85a5efb9e7cbadeb08 bf73044ceeba42d3bae945e49650f579--5242f2dd3cc34f85a5efb9e7cbadeb08 813957ac492d47b58ea72b6bffb1c23d 5242f2dd3cc34f85a5efb9e7cbadeb08--813957ac492d47b58ea72b6bffb1c23d 68d02bfd1818407ca413288c24220dba 813957ac492d47b58ea72b6bffb1c23d--68d02bfd1818407ca413288c24220dba 99668d48d7fb40f78e94a5689bdb81fa X 68d02bfd1818407ca413288c24220dba--99668d48d7fb40f78e94a5689bdb81fa 99668d48d7fb40f78e94a5689bdb81fa--7e682ab8e338442792996e9b5d3e0d55 fd4de633d7d64e5ea9a8b264e0f3edc3 99668d48d7fb40f78e94a5689bdb81fa--fd4de633d7d64e5ea9a8b264e0f3edc3 e207dc38c948448abef53ef335376dec fd4de633d7d64e5ea9a8b264e0f3edc3--e207dc38c948448abef53ef335376dec 5c0851af0ce34feb9697769bedd57fa7 e207dc38c948448abef53ef335376dec--5c0851af0ce34feb9697769bedd57fa7 7c3c8d097b9744aaa59ad104f3c08a8f X 5c0851af0ce34feb9697769bedd57fa7--7c3c8d097b9744aaa59ad104f3c08a8f 7c3c8d097b9744aaa59ad104f3c08a8f--a529f5c7a61549f9a7440b531c73fca5 c44eede36c074e63b6e8c7d93d31ff36 7c3c8d097b9744aaa59ad104f3c08a8f--c44eede36c074e63b6e8c7d93d31ff36 4393025cbef341c6b40923c603fc5aa6 c44eede36c074e63b6e8c7d93d31ff36--4393025cbef341c6b40923c603fc5aa6 6b48e8c97b0e4ab5af6ab48a8d33e4f8 4393025cbef341c6b40923c603fc5aa6--6b48e8c97b0e4ab5af6ab48a8d33e4f8 d2c8e96ef4b14fbda4045ed361d9c52d 6b48e8c97b0e4ab5af6ab48a8d33e4f8--d2c8e96ef4b14fbda4045ed361d9c52d 3d37ab7914e74aaab2b18a5e8355d90e X d2c8e96ef4b14fbda4045ed361d9c52d--3d37ab7914e74aaab2b18a5e8355d90e 3d37ab7914e74aaab2b18a5e8355d90e--e367faa8061a4f81982a8535926c5658 ba249deacf5c4ac0864b269605bd026b 3d37ab7914e74aaab2b18a5e8355d90e--ba249deacf5c4ac0864b269605bd026b 707974df6dd74b4dab19fb2a4f903184 ba249deacf5c4ac0864b269605bd026b--707974df6dd74b4dab19fb2a4f903184 cfbf4a2a8811435d8248059474be2d5e 707974df6dd74b4dab19fb2a4f903184--cfbf4a2a8811435d8248059474be2d5e 091c6b0b76354a2d9b54bb90d96a2536 cfbf4a2a8811435d8248059474be2d5e--091c6b0b76354a2d9b54bb90d96a2536 79890e547a7a4c2b8330e6bb9875940c 091c6b0b76354a2d9b54bb90d96a2536--79890e547a7a4c2b8330e6bb9875940c e77ae23b6fb94219bcb3bef04e37a209 X 79890e547a7a4c2b8330e6bb9875940c--e77ae23b6fb94219bcb3bef04e37a209 e77ae23b6fb94219bcb3bef04e37a209--4a46a904386e4b4aa8929295c19ea454 f143bbc489004a29bdaf5368761eb82d e77ae23b6fb94219bcb3bef04e37a209--f143bbc489004a29bdaf5368761eb82d 58f85a780c2f40779707e603790862c4 f143bbc489004a29bdaf5368761eb82d--58f85a780c2f40779707e603790862c4 3c8d843f13464422a9a86260971fb335 58f85a780c2f40779707e603790862c4--3c8d843f13464422a9a86260971fb335 3a1effc1123943bdb0cf57e7a98d4425 3c8d843f13464422a9a86260971fb335--3a1effc1123943bdb0cf57e7a98d4425 37c5547abb1e4efd8250e8ada0d18e77 X 3a1effc1123943bdb0cf57e7a98d4425--37c5547abb1e4efd8250e8ada0d18e77 37c5547abb1e4efd8250e8ada0d18e77--5850215a96d9497babb67e26d3a9b171 fc44f8574c6c42688d5f8e9f03f7c98f 37c5547abb1e4efd8250e8ada0d18e77--fc44f8574c6c42688d5f8e9f03f7c98f 16da8af3e46d41b896eb705dfe23e2ee fc44f8574c6c42688d5f8e9f03f7c98f--16da8af3e46d41b896eb705dfe23e2ee 1db2bf1098b84351a7798ddf46767c64 16da8af3e46d41b896eb705dfe23e2ee--1db2bf1098b84351a7798ddf46767c64 e57bab423fe342df8b9e57928e54def7 1db2bf1098b84351a7798ddf46767c64--e57bab423fe342df8b9e57928e54def7 e3a71a51725648a982d3a3db75aaa2de e57bab423fe342df8b9e57928e54def7--e3a71a51725648a982d3a3db75aaa2de 920fd9685b0f4236bed2d77cb4688ac2 e3a71a51725648a982d3a3db75aaa2de--920fd9685b0f4236bed2d77cb4688ac2 bcd1247a4d7a4ff4b99ac89874104ab5 920fd9685b0f4236bed2d77cb4688ac2--bcd1247a4d7a4ff4b99ac89874104ab5 9c88aed7ae6144c5aa9e5ffba4097e6a bcd1247a4d7a4ff4b99ac89874104ab5--9c88aed7ae6144c5aa9e5ffba4097e6a 2c798ea177124f44ba7a1448ce554c95 9c88aed7ae6144c5aa9e5ffba4097e6a--2c798ea177124f44ba7a1448ce554c95 197fc643cf404834bbe4f70d9d4ac39e X 2c798ea177124f44ba7a1448ce554c95--197fc643cf404834bbe4f70d9d4ac39e 197fc643cf404834bbe4f70d9d4ac39e--8f627203439d4c35b031d7c30341c5cc 115a31ec9dbb44f3a2673a2b4da865df 197fc643cf404834bbe4f70d9d4ac39e--115a31ec9dbb44f3a2673a2b4da865df f6c960f5fa084035907470a6da3bbbda 115a31ec9dbb44f3a2673a2b4da865df--f6c960f5fa084035907470a6da3bbbda cfbcf0688901428da97f1555b5a9fe8b f6c960f5fa084035907470a6da3bbbda--cfbcf0688901428da97f1555b5a9fe8b 7ba4a867a6c042828863a02765343315 cfbcf0688901428da97f1555b5a9fe8b--7ba4a867a6c042828863a02765343315 9d585e43485d48449b10bfcaf62d4754 7ba4a867a6c042828863a02765343315--9d585e43485d48449b10bfcaf62d4754 3314708ca15b4a24903a4d38c9a55c0b 9d585e43485d48449b10bfcaf62d4754--3314708ca15b4a24903a4d38c9a55c0b 6533a3ac3263404b9f62b01821ee7eea X 3314708ca15b4a24903a4d38c9a55c0b--6533a3ac3263404b9f62b01821ee7eea 6533a3ac3263404b9f62b01821ee7eea--725397047939455cb9e54b3aa9417a90 884dd219317b4dc39b20c7acf1bf5b70 RZ(-1.0*g0) 6533a3ac3263404b9f62b01821ee7eea--884dd219317b4dc39b20c7acf1bf5b70 e310c9109a4c4ea991f8414b8ce3e5a1 X 884dd219317b4dc39b20c7acf1bf5b70--e310c9109a4c4ea991f8414b8ce3e5a1 e310c9109a4c4ea991f8414b8ce3e5a1--c9281469717e4b1bbf59107afd033049 556033d5c3984fd4817316e567b4a3e6 e310c9109a4c4ea991f8414b8ce3e5a1--556033d5c3984fd4817316e567b4a3e6 5a4ce0b6b60749319b21cec2e148b8ad 556033d5c3984fd4817316e567b4a3e6--5a4ce0b6b60749319b21cec2e148b8ad cf5675bd3ed74d6c98f53c2f04bd67f6 X 5a4ce0b6b60749319b21cec2e148b8ad--cf5675bd3ed74d6c98f53c2f04bd67f6 cf5675bd3ed74d6c98f53c2f04bd67f6--07f36ccfe946431a8129ec3085a76fc8 c61028810c234dc4a2e1a07e2362da62 cf5675bd3ed74d6c98f53c2f04bd67f6--c61028810c234dc4a2e1a07e2362da62 29fcd851fa6d431bb1cf2fe17c013bd0 c61028810c234dc4a2e1a07e2362da62--29fcd851fa6d431bb1cf2fe17c013bd0 704b581153a84e60b940c3b68e154985 29fcd851fa6d431bb1cf2fe17c013bd0--704b581153a84e60b940c3b68e154985 4021c9f205c341508af990d9d7546c2a 704b581153a84e60b940c3b68e154985--4021c9f205c341508af990d9d7546c2a 1e24a71dc8ba4d77939eb0982c5a53ed 4021c9f205c341508af990d9d7546c2a--1e24a71dc8ba4d77939eb0982c5a53ed 842b7da22f9244a3a6b5e41cc5e1bd43 X 1e24a71dc8ba4d77939eb0982c5a53ed--842b7da22f9244a3a6b5e41cc5e1bd43 842b7da22f9244a3a6b5e41cc5e1bd43--dc7bb8025c9948fd8568eeeec339b342 c2678b1054fd4a68afe96e28f0a5fac4 842b7da22f9244a3a6b5e41cc5e1bd43--c2678b1054fd4a68afe96e28f0a5fac4 3838258ccf9446a697f83565b297748f c2678b1054fd4a68afe96e28f0a5fac4--3838258ccf9446a697f83565b297748f e32f53170c5d479d8b28f3882c9ff5f3 X 3838258ccf9446a697f83565b297748f--e32f53170c5d479d8b28f3882c9ff5f3 e32f53170c5d479d8b28f3882c9ff5f3--e2a7ddff2ccf478387de9a078268f4be f39b68c60183432eac24b05618576292 e32f53170c5d479d8b28f3882c9ff5f3--f39b68c60183432eac24b05618576292 d643cbc5d7fe4bd8b51274a47eead9fb f39b68c60183432eac24b05618576292--d643cbc5d7fe4bd8b51274a47eead9fb 9bd0b1db6bf24fb3a873e3862c0028f3 d643cbc5d7fe4bd8b51274a47eead9fb--9bd0b1db6bf24fb3a873e3862c0028f3 32fab275fff24a1e9c9f1726f02b5cc2 9bd0b1db6bf24fb3a873e3862c0028f3--32fab275fff24a1e9c9f1726f02b5cc2 9eaf48477e09492b8a7c0c5a5902dc1c 32fab275fff24a1e9c9f1726f02b5cc2--9eaf48477e09492b8a7c0c5a5902dc1c 5f9d4c21675a46a98cc988a650932da5 9eaf48477e09492b8a7c0c5a5902dc1c--5f9d4c21675a46a98cc988a650932da5 df946e47d4d34e1bacda02eb06a398a2 5f9d4c21675a46a98cc988a650932da5--df946e47d4d34e1bacda02eb06a398a2 ec687a968af743bdbecdb4e343ecdaf4 df946e47d4d34e1bacda02eb06a398a2--ec687a968af743bdbecdb4e343ecdaf4 386f1d86b1444728b2637b76219445ed ec687a968af743bdbecdb4e343ecdaf4--386f1d86b1444728b2637b76219445ed a92391d3831047aba7d982db80e0501b X 386f1d86b1444728b2637b76219445ed--a92391d3831047aba7d982db80e0501b a92391d3831047aba7d982db80e0501b--66c6254363bd47fb8937e6efa2f6fc64 289f0bd3f9a0489aa4e131abe2d432a1 a92391d3831047aba7d982db80e0501b--289f0bd3f9a0489aa4e131abe2d432a1 972d67d9c8b24c39abcc8b76085fb499 X 289f0bd3f9a0489aa4e131abe2d432a1--972d67d9c8b24c39abcc8b76085fb499 972d67d9c8b24c39abcc8b76085fb499--630195895b9541c2a1a445010d3dcd8f 4c2694dace454a59ae6b0d5e436b7fdc RZ(-1.0*g0) 972d67d9c8b24c39abcc8b76085fb499--4c2694dace454a59ae6b0d5e436b7fdc 6eaff0971fed43dca71e18845de610e3 X 4c2694dace454a59ae6b0d5e436b7fdc--6eaff0971fed43dca71e18845de610e3 6eaff0971fed43dca71e18845de610e3--c18ef241d33b498ea31a15060c1c469d fc37ed39c3594e6db929dae228778fc7 6eaff0971fed43dca71e18845de610e3--fc37ed39c3594e6db929dae228778fc7 5d4974bd5b3540ac9e59883a3944380b fc37ed39c3594e6db929dae228778fc7--5d4974bd5b3540ac9e59883a3944380b 67e0d8686d1e466090c91c17163fc23c 5d4974bd5b3540ac9e59883a3944380b--67e0d8686d1e466090c91c17163fc23c e940d5197e1f421f8816796894a47987 67e0d8686d1e466090c91c17163fc23c--e940d5197e1f421f8816796894a47987 15ea39975b1645c4bff8c5aafd37eebd e940d5197e1f421f8816796894a47987--15ea39975b1645c4bff8c5aafd37eebd 3385446095074d9092dbd247a297fed1 15ea39975b1645c4bff8c5aafd37eebd--3385446095074d9092dbd247a297fed1 550aabec54e347369f3d3bc535de913f 3385446095074d9092dbd247a297fed1--550aabec54e347369f3d3bc535de913f 25c0a34f74344b4fa8ab59948bf34558 550aabec54e347369f3d3bc535de913f--25c0a34f74344b4fa8ab59948bf34558 eb926ea0c1584ece9ad77b19d15ba9b4 25c0a34f74344b4fa8ab59948bf34558--eb926ea0c1584ece9ad77b19d15ba9b4 da5f169fc464490e9e5b99cf61b8d5d7 eb926ea0c1584ece9ad77b19d15ba9b4--da5f169fc464490e9e5b99cf61b8d5d7 3ce506afc6ac46469aad4a486f395949 da5f169fc464490e9e5b99cf61b8d5d7--3ce506afc6ac46469aad4a486f395949 8f16c1f11379441a94100938e2c3703d 3ce506afc6ac46469aad4a486f395949--8f16c1f11379441a94100938e2c3703d 950e64f7633e47e586c48549e00f6c4b 8f16c1f11379441a94100938e2c3703d--950e64f7633e47e586c48549e00f6c4b 4b5e2571e1fe4ce685e81602f02ed148 950e64f7633e47e586c48549e00f6c4b--4b5e2571e1fe4ce685e81602f02ed148 0927e28e22694947be1314c33c196040 4b5e2571e1fe4ce685e81602f02ed148--0927e28e22694947be1314c33c196040 3fee30fd15174defb70d158c0ca70155 0927e28e22694947be1314c33c196040--3fee30fd15174defb70d158c0ca70155 c94004bc9fe94d918a507380341982d0 3fee30fd15174defb70d158c0ca70155--c94004bc9fe94d918a507380341982d0 2b85c6491d404cd6a42dd230e5eccb18 c94004bc9fe94d918a507380341982d0--2b85c6491d404cd6a42dd230e5eccb18 c3c6edde50114926842fc4854b088752 2b85c6491d404cd6a42dd230e5eccb18--c3c6edde50114926842fc4854b088752 86de266150b845da9fd4353ef487894e c3c6edde50114926842fc4854b088752--86de266150b845da9fd4353ef487894e 8b050a1c28564bc78ea6cb7a13e9b8e0 86de266150b845da9fd4353ef487894e--8b050a1c28564bc78ea6cb7a13e9b8e0 7184b11371a54127806802d9d30a12af 8b050a1c28564bc78ea6cb7a13e9b8e0--7184b11371a54127806802d9d30a12af cecf56bae9dd4ab4b6804714a21a2865 7184b11371a54127806802d9d30a12af--cecf56bae9dd4ab4b6804714a21a2865 cede509c4a324b2cb5de8c6988edd999 cecf56bae9dd4ab4b6804714a21a2865--cede509c4a324b2cb5de8c6988edd999 5f0b571655f94676a64df1287f4068c1 cede509c4a324b2cb5de8c6988edd999--5f0b571655f94676a64df1287f4068c1 2e039f21047744c794c4343dffaba9c4 5f0b571655f94676a64df1287f4068c1--2e039f21047744c794c4343dffaba9c4 b7ec77e12f314396b518c0e7c07cd2fd 2e039f21047744c794c4343dffaba9c4--b7ec77e12f314396b518c0e7c07cd2fd 1551ea73b42a40c9bce8de047ac6d0d0 b7ec77e12f314396b518c0e7c07cd2fd--1551ea73b42a40c9bce8de047ac6d0d0 3f7ad51b6344495f830a019023775427 1551ea73b42a40c9bce8de047ac6d0d0--3f7ad51b6344495f830a019023775427 a41c567402a7453a9f147bbba336b134 3f7ad51b6344495f830a019023775427--a41c567402a7453a9f147bbba336b134 012198c2d0284eb9ae68f0cffc090ca6 a41c567402a7453a9f147bbba336b134--012198c2d0284eb9ae68f0cffc090ca6 1b3166e0014b4262a0fc20ac197b6dd9 012198c2d0284eb9ae68f0cffc090ca6--1b3166e0014b4262a0fc20ac197b6dd9 afc8da2a9ac04aba9ebd0b03898f24c3 1b3166e0014b4262a0fc20ac197b6dd9--afc8da2a9ac04aba9ebd0b03898f24c3 570fd250b09241bdb336461d9f69c29f afc8da2a9ac04aba9ebd0b03898f24c3--570fd250b09241bdb336461d9f69c29f 6b56bf63914e4a5495fb5a9db238d33c RX(b03) 570fd250b09241bdb336461d9f69c29f--6b56bf63914e4a5495fb5a9db238d33c c00b61e49a30462d83abec8e0d4e4d1a 6b56bf63914e4a5495fb5a9db238d33c--c00b61e49a30462d83abec8e0d4e4d1a 92d32585af204638b9eba75941bf4505 c00b61e49a30462d83abec8e0d4e4d1a--92d32585af204638b9eba75941bf4505 065663b0ac68464eb81f54ac0044f81d X 92d32585af204638b9eba75941bf4505--065663b0ac68464eb81f54ac0044f81d 065663b0ac68464eb81f54ac0044f81d--8ba43caa764f4fec866276fc02b453e9 b3e7ea5ab27d4375805c4b5704077ace 065663b0ac68464eb81f54ac0044f81d--b3e7ea5ab27d4375805c4b5704077ace e010baea982549a4950ecbf285c7cf32 b3e7ea5ab27d4375805c4b5704077ace--e010baea982549a4950ecbf285c7cf32 c26af6ccc6b2464ebe2dc66b0e957d2d e010baea982549a4950ecbf285c7cf32--c26af6ccc6b2464ebe2dc66b0e957d2d 96cae2e5e03c455abd8a2d3dd6c3e858 c26af6ccc6b2464ebe2dc66b0e957d2d--96cae2e5e03c455abd8a2d3dd6c3e858 822ed29e892b4370867c58794cb87d88 96cae2e5e03c455abd8a2d3dd6c3e858--822ed29e892b4370867c58794cb87d88 684c1533940f4036960eae06f63e4c9e 822ed29e892b4370867c58794cb87d88--684c1533940f4036960eae06f63e4c9e 06b31e8682d4459ea5f2d20473cb27e5 684c1533940f4036960eae06f63e4c9e--06b31e8682d4459ea5f2d20473cb27e5 ca336390b4174c58ab3aa1bf70fdb641 06b31e8682d4459ea5f2d20473cb27e5--ca336390b4174c58ab3aa1bf70fdb641 cf6a34ac27614b8091b949d97265196d ca336390b4174c58ab3aa1bf70fdb641--cf6a34ac27614b8091b949d97265196d 1c0709c3d2234222bfe7ec33aa474f3d X cf6a34ac27614b8091b949d97265196d--1c0709c3d2234222bfe7ec33aa474f3d 1c0709c3d2234222bfe7ec33aa474f3d--dff99ae3b25d45658d0e8c98d9e7a921 4481eb4d4ccd4431832bb7d2219a0cc7 1c0709c3d2234222bfe7ec33aa474f3d--4481eb4d4ccd4431832bb7d2219a0cc7 332d0f82cf9a47c5bbcca3463e90f134 4481eb4d4ccd4431832bb7d2219a0cc7--332d0f82cf9a47c5bbcca3463e90f134 a1363951f2ea4f8386969b6daf25f690 332d0f82cf9a47c5bbcca3463e90f134--a1363951f2ea4f8386969b6daf25f690 49ebee0384a242d58637357a399915ef a1363951f2ea4f8386969b6daf25f690--49ebee0384a242d58637357a399915ef 3d8424810a874bfcbd7c0f1f2a179655 49ebee0384a242d58637357a399915ef--3d8424810a874bfcbd7c0f1f2a179655 d3bd541340b7433a85b3e96b2c5fbbd1 3d8424810a874bfcbd7c0f1f2a179655--d3bd541340b7433a85b3e96b2c5fbbd1 7ae662975bcc4f7398122bef4566ec3a d3bd541340b7433a85b3e96b2c5fbbd1--7ae662975bcc4f7398122bef4566ec3a fd8629864d714bbdb893540f8392c8c1 X 7ae662975bcc4f7398122bef4566ec3a--fd8629864d714bbdb893540f8392c8c1 fd8629864d714bbdb893540f8392c8c1--ffe070976a554a27adace4f5ff2896a8 a9855ca42a4b4823809de31b7e153649 fd8629864d714bbdb893540f8392c8c1--a9855ca42a4b4823809de31b7e153649 f2b1593e3bc3444dad29cd73ac6d6ac0 a9855ca42a4b4823809de31b7e153649--f2b1593e3bc3444dad29cd73ac6d6ac0 b155a7280b26469e8fcf0c0e3a93a131 f2b1593e3bc3444dad29cd73ac6d6ac0--b155a7280b26469e8fcf0c0e3a93a131 7ad39826c6bd4092b10508ddd463e21c X b155a7280b26469e8fcf0c0e3a93a131--7ad39826c6bd4092b10508ddd463e21c 7ad39826c6bd4092b10508ddd463e21c--e917a587ea51473c9b01d5f541f77a8e f74b6987e028465f8b3048bb956e788d 7ad39826c6bd4092b10508ddd463e21c--f74b6987e028465f8b3048bb956e788d 526ffebdbb5748d4934691713ed1da57 f74b6987e028465f8b3048bb956e788d--526ffebdbb5748d4934691713ed1da57 7498534837b14a44ae7f1d388c7ebc9a 526ffebdbb5748d4934691713ed1da57--7498534837b14a44ae7f1d388c7ebc9a 6adaf098098a4e64badd18f1292c6bab 7498534837b14a44ae7f1d388c7ebc9a--6adaf098098a4e64badd18f1292c6bab 752543ef37ac462a94072fc8f899d906 X 6adaf098098a4e64badd18f1292c6bab--752543ef37ac462a94072fc8f899d906 752543ef37ac462a94072fc8f899d906--47de2f257dd146f6806a5a7ca7d2804c 4f5bc9b01c1842f79058c3ca10d31436 752543ef37ac462a94072fc8f899d906--4f5bc9b01c1842f79058c3ca10d31436 765119cd94d9404eb8a09988983da753 4f5bc9b01c1842f79058c3ca10d31436--765119cd94d9404eb8a09988983da753 0db2e82276c84c4584ed693e6981ca91 765119cd94d9404eb8a09988983da753--0db2e82276c84c4584ed693e6981ca91 bf69fdfdccdc4f82ba3a6dfc46678bed 0db2e82276c84c4584ed693e6981ca91--bf69fdfdccdc4f82ba3a6dfc46678bed dc294f0b4ee046cf98a405b20c3d5d6b bf69fdfdccdc4f82ba3a6dfc46678bed--dc294f0b4ee046cf98a405b20c3d5d6b 4e16204e0036440585b87add10356543 X dc294f0b4ee046cf98a405b20c3d5d6b--4e16204e0036440585b87add10356543 4e16204e0036440585b87add10356543--9349f60915d54a9186555af99af60f64 f6e3461657474a458b209eabed09bba9 4e16204e0036440585b87add10356543--f6e3461657474a458b209eabed09bba9 7e1e8458fce641349f244419fa36b471 f6e3461657474a458b209eabed09bba9--7e1e8458fce641349f244419fa36b471 be22c05d5b9044678bd762fa92b0441c 7e1e8458fce641349f244419fa36b471--be22c05d5b9044678bd762fa92b0441c 45be0c00385a4cf79bd486c1062dab0c be22c05d5b9044678bd762fa92b0441c--45be0c00385a4cf79bd486c1062dab0c f78f6deca9d34dceb014fc4c9f1a856b X 45be0c00385a4cf79bd486c1062dab0c--f78f6deca9d34dceb014fc4c9f1a856b f78f6deca9d34dceb014fc4c9f1a856b--6aabbddb67284d36b3c77f77d6fcb1e5 1e64b95678444299843faa856fac0e47 f78f6deca9d34dceb014fc4c9f1a856b--1e64b95678444299843faa856fac0e47 343742dce7c04161a2ca13fbb15778a7 1e64b95678444299843faa856fac0e47--343742dce7c04161a2ca13fbb15778a7 09063206f81f4311b1826f1b04c48de0 343742dce7c04161a2ca13fbb15778a7--09063206f81f4311b1826f1b04c48de0 44a5971b61cb474586d7a9eaa5586498 09063206f81f4311b1826f1b04c48de0--44a5971b61cb474586d7a9eaa5586498 bc54ef05e5b34365b05edcd5a23c66df 44a5971b61cb474586d7a9eaa5586498--bc54ef05e5b34365b05edcd5a23c66df 9e596bd1099e4a8e9401b1320d8b166c bc54ef05e5b34365b05edcd5a23c66df--9e596bd1099e4a8e9401b1320d8b166c c1d8311f099d4206bcb4b4482eb8e8f2 9e596bd1099e4a8e9401b1320d8b166c--c1d8311f099d4206bcb4b4482eb8e8f2 37f47d17d509484f99eb122d82458f33 c1d8311f099d4206bcb4b4482eb8e8f2--37f47d17d509484f99eb122d82458f33 58663aae2c93431297bdd09ff085a077 37f47d17d509484f99eb122d82458f33--58663aae2c93431297bdd09ff085a077 681c97a8239c400e976f6ac18f5e916d X 58663aae2c93431297bdd09ff085a077--681c97a8239c400e976f6ac18f5e916d 681c97a8239c400e976f6ac18f5e916d--db75b2eee51a4cd4a09d6d6601413bae 12e4512dbfdb481e964d176b5de303d4 681c97a8239c400e976f6ac18f5e916d--12e4512dbfdb481e964d176b5de303d4 a009e5fc71284adeb86fae342ce95b05 12e4512dbfdb481e964d176b5de303d4--a009e5fc71284adeb86fae342ce95b05 f419371be8a240989731786ad2422284 a009e5fc71284adeb86fae342ce95b05--f419371be8a240989731786ad2422284 af021c23fe7f433cb2e446ab7bfb7c4e f419371be8a240989731786ad2422284--af021c23fe7f433cb2e446ab7bfb7c4e 453f8d6fd19b473db54d8155d923ffbc af021c23fe7f433cb2e446ab7bfb7c4e--453f8d6fd19b473db54d8155d923ffbc 2d03301bf79640dd8db24aa196248c5c 453f8d6fd19b473db54d8155d923ffbc--2d03301bf79640dd8db24aa196248c5c b14a430cc19e46139dcf0d27d0bc0a9f X 2d03301bf79640dd8db24aa196248c5c--b14a430cc19e46139dcf0d27d0bc0a9f b14a430cc19e46139dcf0d27d0bc0a9f--afd797f698114c3788646e48a1fff8dd 26314712dc1b4244ab556da7b27f22d1 RZ(-1.0*g1) b14a430cc19e46139dcf0d27d0bc0a9f--26314712dc1b4244ab556da7b27f22d1 ef01f12e06c44f53a9da5eb39d891b67 X 26314712dc1b4244ab556da7b27f22d1--ef01f12e06c44f53a9da5eb39d891b67 ef01f12e06c44f53a9da5eb39d891b67--bc4e820b3beb4ea09cf96599646e8f5c 87f2b5df460541bfbf0bb36bbe82d422 ef01f12e06c44f53a9da5eb39d891b67--87f2b5df460541bfbf0bb36bbe82d422 7d50bc7a110a4f3bb04f86804a8d66a1 87f2b5df460541bfbf0bb36bbe82d422--7d50bc7a110a4f3bb04f86804a8d66a1 451ce3ddd59d4aa0b5f93b814512a4ff X 7d50bc7a110a4f3bb04f86804a8d66a1--451ce3ddd59d4aa0b5f93b814512a4ff 451ce3ddd59d4aa0b5f93b814512a4ff--d59ea11505124985904136b8e3c63a14 3f87b4aaff954a3e96e55e34e3f70222 451ce3ddd59d4aa0b5f93b814512a4ff--3f87b4aaff954a3e96e55e34e3f70222 c56fc3ca375348be8f80b03a188ba28d 3f87b4aaff954a3e96e55e34e3f70222--c56fc3ca375348be8f80b03a188ba28d 8bf8a86b4adc48088e398f74800835e6 c56fc3ca375348be8f80b03a188ba28d--8bf8a86b4adc48088e398f74800835e6 864a2634d3344e9b984efbc7a8cf1839 8bf8a86b4adc48088e398f74800835e6--864a2634d3344e9b984efbc7a8cf1839 459a40a8713840359d33c67405e0863d 864a2634d3344e9b984efbc7a8cf1839--459a40a8713840359d33c67405e0863d eae953a2c6d040dc9915d9e5138a0a3b X 459a40a8713840359d33c67405e0863d--eae953a2c6d040dc9915d9e5138a0a3b eae953a2c6d040dc9915d9e5138a0a3b--f658e368491c4eb1b34c868642f2264a cd8b17960d7e40f7aaf2d7bef2f6bf8e eae953a2c6d040dc9915d9e5138a0a3b--cd8b17960d7e40f7aaf2d7bef2f6bf8e bdec099ef04c4b04a1908851c28a7d2b cd8b17960d7e40f7aaf2d7bef2f6bf8e--bdec099ef04c4b04a1908851c28a7d2b 13ffbab1f560427ea15399c4180b1751 X bdec099ef04c4b04a1908851c28a7d2b--13ffbab1f560427ea15399c4180b1751 13ffbab1f560427ea15399c4180b1751--6c7935bcaf8b47f784f0173d69e60d31 8e1f1b1a5a4a4634a0717b8a5043e0f0 13ffbab1f560427ea15399c4180b1751--8e1f1b1a5a4a4634a0717b8a5043e0f0 ddabc949fb5e43c68bcc12debbf79906 8e1f1b1a5a4a4634a0717b8a5043e0f0--ddabc949fb5e43c68bcc12debbf79906 bcccd71f7e764a2086c0a121099a2d1f ddabc949fb5e43c68bcc12debbf79906--bcccd71f7e764a2086c0a121099a2d1f b67872b9149f4af89705dc7ca24a2e7e bcccd71f7e764a2086c0a121099a2d1f--b67872b9149f4af89705dc7ca24a2e7e 421a46664c0f4c4d9a53f0be955df7d6 b67872b9149f4af89705dc7ca24a2e7e--421a46664c0f4c4d9a53f0be955df7d6 61cbabcab36f49798602b5cc5d35d829 421a46664c0f4c4d9a53f0be955df7d6--61cbabcab36f49798602b5cc5d35d829 eaec2059ada740cbb4752e396e963471 61cbabcab36f49798602b5cc5d35d829--eaec2059ada740cbb4752e396e963471 1e9e1920b4a64040bafe77dad88be62c eaec2059ada740cbb4752e396e963471--1e9e1920b4a64040bafe77dad88be62c efbead9c5f274d49a6fc8697f5e89466 1e9e1920b4a64040bafe77dad88be62c--efbead9c5f274d49a6fc8697f5e89466 a97f6ffa51da40058b6cbd12b6f0334c X efbead9c5f274d49a6fc8697f5e89466--a97f6ffa51da40058b6cbd12b6f0334c a97f6ffa51da40058b6cbd12b6f0334c--e6906f5ac09a4662882077c29ed18fea c3d447a6108444988f2536a5d450b697 a97f6ffa51da40058b6cbd12b6f0334c--c3d447a6108444988f2536a5d450b697 781737a02bda457aabef512027ed069a X c3d447a6108444988f2536a5d450b697--781737a02bda457aabef512027ed069a 781737a02bda457aabef512027ed069a--458a505d86174c50ac884014895c397a ea0a47642418402b8ad377c006dfd2e4 RZ(-1.0*g1) 781737a02bda457aabef512027ed069a--ea0a47642418402b8ad377c006dfd2e4 eaa4211edf4442b1a139aab0cfc65a87 X ea0a47642418402b8ad377c006dfd2e4--eaa4211edf4442b1a139aab0cfc65a87 eaa4211edf4442b1a139aab0cfc65a87--7feeea51306c4d2d8a139be71db250b3 4b18739423b04e0286f68c5576c52c01 eaa4211edf4442b1a139aab0cfc65a87--4b18739423b04e0286f68c5576c52c01 80808828036241aaa3d9fe6bbe6e192a 4b18739423b04e0286f68c5576c52c01--80808828036241aaa3d9fe6bbe6e192a 82aa24456f4c49edb50b672dfedc64bd 80808828036241aaa3d9fe6bbe6e192a--82aa24456f4c49edb50b672dfedc64bd c05f12b8975447d29214af0a3bd15979 82aa24456f4c49edb50b672dfedc64bd--c05f12b8975447d29214af0a3bd15979 6704d50cf2a8418c842b4fb7242dff07 c05f12b8975447d29214af0a3bd15979--6704d50cf2a8418c842b4fb7242dff07 66e381c3421148c88b9c9c13eba1c830 6704d50cf2a8418c842b4fb7242dff07--66e381c3421148c88b9c9c13eba1c830 2efb01bc03ef4caea174916078c82964 66e381c3421148c88b9c9c13eba1c830--2efb01bc03ef4caea174916078c82964 cd9237a8e0254c0e9c6d7011364e0e1c 2efb01bc03ef4caea174916078c82964--cd9237a8e0254c0e9c6d7011364e0e1c 2361484d1d8449408396c4db63951f71 cd9237a8e0254c0e9c6d7011364e0e1c--2361484d1d8449408396c4db63951f71 8a93b51e82344b46a855d9ee21e2af80 2361484d1d8449408396c4db63951f71--8a93b51e82344b46a855d9ee21e2af80 7ef0d5cce8d34b6fa1d22a43003452c8 8a93b51e82344b46a855d9ee21e2af80--7ef0d5cce8d34b6fa1d22a43003452c8 370d3313a8334e94944675d4ebfdd420 7ef0d5cce8d34b6fa1d22a43003452c8--370d3313a8334e94944675d4ebfdd420 87352e8f0a8d4d85b2945b96a49a0963 370d3313a8334e94944675d4ebfdd420--87352e8f0a8d4d85b2945b96a49a0963 5fea32a71ff14e7ab9c57991f0317e09 87352e8f0a8d4d85b2945b96a49a0963--5fea32a71ff14e7ab9c57991f0317e09 e6913e0810f344a997cef80d3e14f97a 5fea32a71ff14e7ab9c57991f0317e09--e6913e0810f344a997cef80d3e14f97a f5e468f0859a4562a239f9d5e3b79b0f e6913e0810f344a997cef80d3e14f97a--f5e468f0859a4562a239f9d5e3b79b0f be7d56f4d81d478c85ff38151746ec97 f5e468f0859a4562a239f9d5e3b79b0f--be7d56f4d81d478c85ff38151746ec97 241675d8d45e49b0838ec2d951ee8d62 be7d56f4d81d478c85ff38151746ec97--241675d8d45e49b0838ec2d951ee8d62 284870321b764c8baacc8ee90253fbc2 241675d8d45e49b0838ec2d951ee8d62--284870321b764c8baacc8ee90253fbc2 abcb72f7d2b44545b66d317ac11d036c 284870321b764c8baacc8ee90253fbc2--abcb72f7d2b44545b66d317ac11d036c 794e7f578bfe482cad435809d7831aa4 abcb72f7d2b44545b66d317ac11d036c--794e7f578bfe482cad435809d7831aa4 9b87eb07231b4e14bc7f4ca1e2577a56 794e7f578bfe482cad435809d7831aa4--9b87eb07231b4e14bc7f4ca1e2577a56 63be19bd338146caa173902bb4a4a48d 9b87eb07231b4e14bc7f4ca1e2577a56--63be19bd338146caa173902bb4a4a48d 3e521e4b4e1243d092435187287e864f 63be19bd338146caa173902bb4a4a48d--3e521e4b4e1243d092435187287e864f bf8ec24194344ac8885700f62c357db3 3e521e4b4e1243d092435187287e864f--bf8ec24194344ac8885700f62c357db3 cdda823715e842c58e77b9c5a5879b0d bf8ec24194344ac8885700f62c357db3--cdda823715e842c58e77b9c5a5879b0d 10f7fa32a29a410a89476e3f3f18eb98 cdda823715e842c58e77b9c5a5879b0d--10f7fa32a29a410a89476e3f3f18eb98 95d5b77c9ad84946bf2ec0189cff1382 10f7fa32a29a410a89476e3f3f18eb98--95d5b77c9ad84946bf2ec0189cff1382 ab2db691d7274441ae231e99234fa086 95d5b77c9ad84946bf2ec0189cff1382--ab2db691d7274441ae231e99234fa086 1e08c97470814e74b24bd0ff075ecd4d ab2db691d7274441ae231e99234fa086--1e08c97470814e74b24bd0ff075ecd4d af68c24f0a9f416ea6933f38ee8e76d5 1e08c97470814e74b24bd0ff075ecd4d--af68c24f0a9f416ea6933f38ee8e76d5 d3245155fd0948e48442d13386697846 af68c24f0a9f416ea6933f38ee8e76d5--d3245155fd0948e48442d13386697846 aeea7ab0028740309f8fff94ef22c0a0 d3245155fd0948e48442d13386697846--aeea7ab0028740309f8fff94ef22c0a0 327b6c6f187642738472674e4d4a29b6 aeea7ab0028740309f8fff94ef22c0a0--327b6c6f187642738472674e4d4a29b6 6b95e0fb66d14aabbeb550094f41b8d9 RX(b13) 327b6c6f187642738472674e4d4a29b6--6b95e0fb66d14aabbeb550094f41b8d9 6b95e0fb66d14aabbeb550094f41b8d9--26977008c7804e9bb9b6224f18a03bce 8f4f9d8809724ffab6ce665a5c19feca fa250c93e4424c0abe815f6d858b33c7 d134ac83de91451a8b0c42dfba10cc45--fa250c93e4424c0abe815f6d858b33c7 fdbbc62bfeda42f68db0db6d3e498779 5 4db1b789e86b406cb33934486a196852 fa250c93e4424c0abe815f6d858b33c7--4db1b789e86b406cb33934486a196852 65d63e7829bd4e09b9a020f348e69bb2 4db1b789e86b406cb33934486a196852--65d63e7829bd4e09b9a020f348e69bb2 fed2558823da4b6081acff2ec3d69d1f X 65d63e7829bd4e09b9a020f348e69bb2--fed2558823da4b6081acff2ec3d69d1f fed2558823da4b6081acff2ec3d69d1f--e99b38e72c5347829efa859e801f83c4 9af69b91bd0b468c875706f02506113a fed2558823da4b6081acff2ec3d69d1f--9af69b91bd0b468c875706f02506113a d1f9e744d18a40dfaa5ee59abe74530d 9af69b91bd0b468c875706f02506113a--d1f9e744d18a40dfaa5ee59abe74530d 4dc77a3922df4e4e8c5f4acaaf55761e d1f9e744d18a40dfaa5ee59abe74530d--4dc77a3922df4e4e8c5f4acaaf55761e d2e406ba1af8413c8bd4ffd252863390 4dc77a3922df4e4e8c5f4acaaf55761e--d2e406ba1af8413c8bd4ffd252863390 13a145e81cac466baddfd2a020c0155d d2e406ba1af8413c8bd4ffd252863390--13a145e81cac466baddfd2a020c0155d 19cf5a5f72d44f90b865586cfcd5e753 13a145e81cac466baddfd2a020c0155d--19cf5a5f72d44f90b865586cfcd5e753 5a2a261c50904b53a3dfdcc508d34e81 19cf5a5f72d44f90b865586cfcd5e753--5a2a261c50904b53a3dfdcc508d34e81 124dfcc19395484db4f7533f108f1381 X 5a2a261c50904b53a3dfdcc508d34e81--124dfcc19395484db4f7533f108f1381 124dfcc19395484db4f7533f108f1381--1702e4ba31124999a7cfcd6fd2577a69 2e06fe711db34ba4a0c6b407bea6b015 124dfcc19395484db4f7533f108f1381--2e06fe711db34ba4a0c6b407bea6b015 bf3592477cbf4c1b982f7bea4b8bdf55 2e06fe711db34ba4a0c6b407bea6b015--bf3592477cbf4c1b982f7bea4b8bdf55 625cd1b48e13428184ddbb23c38df4d5 bf3592477cbf4c1b982f7bea4b8bdf55--625cd1b48e13428184ddbb23c38df4d5 2d2d8ea02b1849e782b60b5f2373ad62 625cd1b48e13428184ddbb23c38df4d5--2d2d8ea02b1849e782b60b5f2373ad62 d200f46893e9413eafa299e59020d422 2d2d8ea02b1849e782b60b5f2373ad62--d200f46893e9413eafa299e59020d422 9654592c38cc4e0ab22ac369e01c5d94 d200f46893e9413eafa299e59020d422--9654592c38cc4e0ab22ac369e01c5d94 c8faafdba13a4163a98276f0736ceb00 9654592c38cc4e0ab22ac369e01c5d94--c8faafdba13a4163a98276f0736ceb00 f2271293c9f04d3ca51450197698fa5f c8faafdba13a4163a98276f0736ceb00--f2271293c9f04d3ca51450197698fa5f 126e429d6fed4bbca0935de7378a9e81 f2271293c9f04d3ca51450197698fa5f--126e429d6fed4bbca0935de7378a9e81 8c54559f725943c1a43931f89c802878 X 126e429d6fed4bbca0935de7378a9e81--8c54559f725943c1a43931f89c802878 8c54559f725943c1a43931f89c802878--fd4de633d7d64e5ea9a8b264e0f3edc3 40ade9fe8b9e4c97827f0224aa6eb9d7 RZ(-1.0*g0) 8c54559f725943c1a43931f89c802878--40ade9fe8b9e4c97827f0224aa6eb9d7 40aae58cffbf4b658a02d98f8a40b64f X 40ade9fe8b9e4c97827f0224aa6eb9d7--40aae58cffbf4b658a02d98f8a40b64f 40aae58cffbf4b658a02d98f8a40b64f--5c0851af0ce34feb9697769bedd57fa7 29973c9062f64f10b4ed0962df97b25a 40aae58cffbf4b658a02d98f8a40b64f--29973c9062f64f10b4ed0962df97b25a 46a3447d0b5041b8ab5c44d2093aa36f 29973c9062f64f10b4ed0962df97b25a--46a3447d0b5041b8ab5c44d2093aa36f fcad42625c5242b684b3439553bd07ca 46a3447d0b5041b8ab5c44d2093aa36f--fcad42625c5242b684b3439553bd07ca 1776e84927ea4185a1d3ba5730972516 fcad42625c5242b684b3439553bd07ca--1776e84927ea4185a1d3ba5730972516 0b9b7fbe0b824ebdbde0f3d6361739b8 1776e84927ea4185a1d3ba5730972516--0b9b7fbe0b824ebdbde0f3d6361739b8 8e2a1fee04a642738a49a175c929c89f 0b9b7fbe0b824ebdbde0f3d6361739b8--8e2a1fee04a642738a49a175c929c89f 93ff03872d484781bce6148612b0dd24 X 8e2a1fee04a642738a49a175c929c89f--93ff03872d484781bce6148612b0dd24 93ff03872d484781bce6148612b0dd24--ba249deacf5c4ac0864b269605bd026b 19aa0edfa2da4de59c7b0418e08cc37b 93ff03872d484781bce6148612b0dd24--19aa0edfa2da4de59c7b0418e08cc37b 765175bc618240978c4802e720f2b2fe 19aa0edfa2da4de59c7b0418e08cc37b--765175bc618240978c4802e720f2b2fe 1fa2ea218d014176b500e8e8a5903627 765175bc618240978c4802e720f2b2fe--1fa2ea218d014176b500e8e8a5903627 962cef74e9c84f58b62203aeb3af3ce0 X 1fa2ea218d014176b500e8e8a5903627--962cef74e9c84f58b62203aeb3af3ce0 962cef74e9c84f58b62203aeb3af3ce0--79890e547a7a4c2b8330e6bb9875940c dbeabac8dd3a48d6bd354b90c6b17499 962cef74e9c84f58b62203aeb3af3ce0--dbeabac8dd3a48d6bd354b90c6b17499 9ad9a04fb75b4c34a2031120c22ac31f dbeabac8dd3a48d6bd354b90c6b17499--9ad9a04fb75b4c34a2031120c22ac31f a71d11296294437cadf16b74f5710c45 9ad9a04fb75b4c34a2031120c22ac31f--a71d11296294437cadf16b74f5710c45 46a0e3a9cd984c6aa29c0a4f530f22c4 a71d11296294437cadf16b74f5710c45--46a0e3a9cd984c6aa29c0a4f530f22c4 281a92a5e4b74280b1da9d80c0f91467 46a0e3a9cd984c6aa29c0a4f530f22c4--281a92a5e4b74280b1da9d80c0f91467 ecdde7a69555471692943cddbfd93c86 281a92a5e4b74280b1da9d80c0f91467--ecdde7a69555471692943cddbfd93c86 5f55c21154734245afff7bf67924af68 X ecdde7a69555471692943cddbfd93c86--5f55c21154734245afff7bf67924af68 5f55c21154734245afff7bf67924af68--fc44f8574c6c42688d5f8e9f03f7c98f 32cade06314b4570b39c1bf6417c3df4 5f55c21154734245afff7bf67924af68--32cade06314b4570b39c1bf6417c3df4 cae313b93a2748bf9589bba8d92e8d50 32cade06314b4570b39c1bf6417c3df4--cae313b93a2748bf9589bba8d92e8d50 304b7efffbe8481ab3bbe708d6bb1e44 cae313b93a2748bf9589bba8d92e8d50--304b7efffbe8481ab3bbe708d6bb1e44 7ce5cf69ba084340ae0f696635a577ac 304b7efffbe8481ab3bbe708d6bb1e44--7ce5cf69ba084340ae0f696635a577ac 5aa755110f9443ee95ec323adfbdfe7b 7ce5cf69ba084340ae0f696635a577ac--5aa755110f9443ee95ec323adfbdfe7b ecc26d72ba3b487a87129c6077222dcb 5aa755110f9443ee95ec323adfbdfe7b--ecc26d72ba3b487a87129c6077222dcb e1e0b076415e45839f470dea0531ded0 ecc26d72ba3b487a87129c6077222dcb--e1e0b076415e45839f470dea0531ded0 ad25c99e58264e31a1c2af4d3c226782 X e1e0b076415e45839f470dea0531ded0--ad25c99e58264e31a1c2af4d3c226782 ad25c99e58264e31a1c2af4d3c226782--2c798ea177124f44ba7a1448ce554c95 c57dba2e32dc4085906a9ea4eae18eb8 ad25c99e58264e31a1c2af4d3c226782--c57dba2e32dc4085906a9ea4eae18eb8 6d144b78c47c4e55897430cb54d334a5 c57dba2e32dc4085906a9ea4eae18eb8--6d144b78c47c4e55897430cb54d334a5 399e45536e854bfa99d0340ec76e9fd5 6d144b78c47c4e55897430cb54d334a5--399e45536e854bfa99d0340ec76e9fd5 361fe2be0dea4e498d5e2bf7e1dbd46e 399e45536e854bfa99d0340ec76e9fd5--361fe2be0dea4e498d5e2bf7e1dbd46e d732f4ba917c4c3ca2cf99a9a63043e3 361fe2be0dea4e498d5e2bf7e1dbd46e--d732f4ba917c4c3ca2cf99a9a63043e3 7f979a89ba384cd2a93486544937654c d732f4ba917c4c3ca2cf99a9a63043e3--7f979a89ba384cd2a93486544937654c 673a2358e6b2412eb364f823f139f53d 7f979a89ba384cd2a93486544937654c--673a2358e6b2412eb364f823f139f53d 84e980846e3546a59a3e23d20d977bcf 673a2358e6b2412eb364f823f139f53d--84e980846e3546a59a3e23d20d977bcf 8a023ca011b4469aaeeeac2ac7ec0d65 84e980846e3546a59a3e23d20d977bcf--8a023ca011b4469aaeeeac2ac7ec0d65 01ac4693e8714d528fe1af1b31244a84 8a023ca011b4469aaeeeac2ac7ec0d65--01ac4693e8714d528fe1af1b31244a84 3744d1d820bf44339f07668550642937 01ac4693e8714d528fe1af1b31244a84--3744d1d820bf44339f07668550642937 8fdc670b5b1c4834bfa29b62c8cedc3e 3744d1d820bf44339f07668550642937--8fdc670b5b1c4834bfa29b62c8cedc3e 3141762e97334c5fade64d389962c223 8fdc670b5b1c4834bfa29b62c8cedc3e--3141762e97334c5fade64d389962c223 9e5092688c494849a4d9ad5f22a53b66 X 3141762e97334c5fade64d389962c223--9e5092688c494849a4d9ad5f22a53b66 9e5092688c494849a4d9ad5f22a53b66--c61028810c234dc4a2e1a07e2362da62 01de38b290194db786f3fd9196764ff7 9e5092688c494849a4d9ad5f22a53b66--01de38b290194db786f3fd9196764ff7 e67be925ed5e460c8f49fdef58ea8c6b 01de38b290194db786f3fd9196764ff7--e67be925ed5e460c8f49fdef58ea8c6b acc5d69f302c45a7b36a3c1f3df9947d e67be925ed5e460c8f49fdef58ea8c6b--acc5d69f302c45a7b36a3c1f3df9947d 232b142a33be42bc810dc4fdcdf370f9 X acc5d69f302c45a7b36a3c1f3df9947d--232b142a33be42bc810dc4fdcdf370f9 232b142a33be42bc810dc4fdcdf370f9--1e24a71dc8ba4d77939eb0982c5a53ed ac33f57561d041d2b832b4da4da8d6ec 232b142a33be42bc810dc4fdcdf370f9--ac33f57561d041d2b832b4da4da8d6ec 88ec97ceab9d45c69a559c0817899094 ac33f57561d041d2b832b4da4da8d6ec--88ec97ceab9d45c69a559c0817899094 2d0c579e54fe4f1b887fdf02672bd95a 88ec97ceab9d45c69a559c0817899094--2d0c579e54fe4f1b887fdf02672bd95a c075c723c1914c009d8694eeca12d150 2d0c579e54fe4f1b887fdf02672bd95a--c075c723c1914c009d8694eeca12d150 f53d322fa9c1415791a5cecdfa04e9c6 X c075c723c1914c009d8694eeca12d150--f53d322fa9c1415791a5cecdfa04e9c6 f53d322fa9c1415791a5cecdfa04e9c6--f39b68c60183432eac24b05618576292 5cad1d0c7db242cc9fe4ef53e2496418 f53d322fa9c1415791a5cecdfa04e9c6--5cad1d0c7db242cc9fe4ef53e2496418 cf71a160f91e4cc784eeabd16f62fc6b 5cad1d0c7db242cc9fe4ef53e2496418--cf71a160f91e4cc784eeabd16f62fc6b 0c5bb795b3c0458493e4dc815a3e1bd5 cf71a160f91e4cc784eeabd16f62fc6b--0c5bb795b3c0458493e4dc815a3e1bd5 ad5f4fc46378410bae67c3173e9919c8 0c5bb795b3c0458493e4dc815a3e1bd5--ad5f4fc46378410bae67c3173e9919c8 b21b301b97fe4ec9b77a78bdc9e1cd0a ad5f4fc46378410bae67c3173e9919c8--b21b301b97fe4ec9b77a78bdc9e1cd0a 9e71bf0b17ea4c5e9cf83bfa500c9070 b21b301b97fe4ec9b77a78bdc9e1cd0a--9e71bf0b17ea4c5e9cf83bfa500c9070 e4a4c03ff60344b9996434cd0f981ccd 9e71bf0b17ea4c5e9cf83bfa500c9070--e4a4c03ff60344b9996434cd0f981ccd a562d806b12d47a8a45c66cc4512bee9 X e4a4c03ff60344b9996434cd0f981ccd--a562d806b12d47a8a45c66cc4512bee9 a562d806b12d47a8a45c66cc4512bee9--386f1d86b1444728b2637b76219445ed 6ad56c90d21140dd871b784a32d782dd a562d806b12d47a8a45c66cc4512bee9--6ad56c90d21140dd871b784a32d782dd 6b3ba30631db42a0bcba8acecc8ec7d4 6ad56c90d21140dd871b784a32d782dd--6b3ba30631db42a0bcba8acecc8ec7d4 12266d7d1344420bb2565bbecbb6998f 6b3ba30631db42a0bcba8acecc8ec7d4--12266d7d1344420bb2565bbecbb6998f defc23555d6746b49e57fa608569018b 12266d7d1344420bb2565bbecbb6998f--defc23555d6746b49e57fa608569018b 3f16ae9c9dfc463c816fb05bc4e5e8c6 defc23555d6746b49e57fa608569018b--3f16ae9c9dfc463c816fb05bc4e5e8c6 1c10755b4ab0443d9fb55933fb849058 X 3f16ae9c9dfc463c816fb05bc4e5e8c6--1c10755b4ab0443d9fb55933fb849058 1c10755b4ab0443d9fb55933fb849058--fc37ed39c3594e6db929dae228778fc7 22973e066e3e4717a471037274262aae RZ(-1.0*g0) 1c10755b4ab0443d9fb55933fb849058--22973e066e3e4717a471037274262aae 8d07054c759a411083d2f38c9314b3b1 X 22973e066e3e4717a471037274262aae--8d07054c759a411083d2f38c9314b3b1 8d07054c759a411083d2f38c9314b3b1--67e0d8686d1e466090c91c17163fc23c aab91ac2cb984af7bdb63aa01125bfe8 X 8d07054c759a411083d2f38c9314b3b1--aab91ac2cb984af7bdb63aa01125bfe8 aab91ac2cb984af7bdb63aa01125bfe8--e940d5197e1f421f8816796894a47987 fc09a069a9d346efa2a0fc45c15348aa aab91ac2cb984af7bdb63aa01125bfe8--fc09a069a9d346efa2a0fc45c15348aa fe8d089b995f4390b59c2a3debb1d37a fc09a069a9d346efa2a0fc45c15348aa--fe8d089b995f4390b59c2a3debb1d37a 5b5a2bbf607949c09659e5d234c5db6a fe8d089b995f4390b59c2a3debb1d37a--5b5a2bbf607949c09659e5d234c5db6a 9470f0697c0f4ac6bc3ed8f6829f1654 5b5a2bbf607949c09659e5d234c5db6a--9470f0697c0f4ac6bc3ed8f6829f1654 dc92050fda8e45f0aca0f2c2f28cf5e9 9470f0697c0f4ac6bc3ed8f6829f1654--dc92050fda8e45f0aca0f2c2f28cf5e9 53f571e84f084fc59ce1275a20b5bd01 X dc92050fda8e45f0aca0f2c2f28cf5e9--53f571e84f084fc59ce1275a20b5bd01 53f571e84f084fc59ce1275a20b5bd01--da5f169fc464490e9e5b99cf61b8d5d7 5122f1fcc9d94f32b13c60238004d664 X 53f571e84f084fc59ce1275a20b5bd01--5122f1fcc9d94f32b13c60238004d664 5122f1fcc9d94f32b13c60238004d664--3ce506afc6ac46469aad4a486f395949 732d1daea57d4d13ad2ea57339f149a9 5122f1fcc9d94f32b13c60238004d664--732d1daea57d4d13ad2ea57339f149a9 22cfb5fb3b5443bdb17a60e9cffc480b 732d1daea57d4d13ad2ea57339f149a9--22cfb5fb3b5443bdb17a60e9cffc480b 47deab0c61fe41508abcd9b0aaa65ab4 22cfb5fb3b5443bdb17a60e9cffc480b--47deab0c61fe41508abcd9b0aaa65ab4 583adff5947b450aa938d395ec94c507 47deab0c61fe41508abcd9b0aaa65ab4--583adff5947b450aa938d395ec94c507 9c70c21e03c44b169fd1af00d739163f 583adff5947b450aa938d395ec94c507--9c70c21e03c44b169fd1af00d739163f 9852d6b9eb3c4c898bc359a21cb247f4 9c70c21e03c44b169fd1af00d739163f--9852d6b9eb3c4c898bc359a21cb247f4 cbd90bf3151f4064b9c92f0fbb9042f6 9852d6b9eb3c4c898bc359a21cb247f4--cbd90bf3151f4064b9c92f0fbb9042f6 15b0ba71f38d42a6beef66f4c82dbdd9 X cbd90bf3151f4064b9c92f0fbb9042f6--15b0ba71f38d42a6beef66f4c82dbdd9 15b0ba71f38d42a6beef66f4c82dbdd9--c3c6edde50114926842fc4854b088752 aa9ca054d6df40f7824ebe11067c9157 15b0ba71f38d42a6beef66f4c82dbdd9--aa9ca054d6df40f7824ebe11067c9157 fdc2a4f297a34455ae14f68a96742bde aa9ca054d6df40f7824ebe11067c9157--fdc2a4f297a34455ae14f68a96742bde 5fdc6f28162c47858fabd046c45751cc fdc2a4f297a34455ae14f68a96742bde--5fdc6f28162c47858fabd046c45751cc 34e232d40e054b799bd4e9fdef43619b 5fdc6f28162c47858fabd046c45751cc--34e232d40e054b799bd4e9fdef43619b d4cd111494554a3ea80cb67d09363756 34e232d40e054b799bd4e9fdef43619b--d4cd111494554a3ea80cb67d09363756 b4b78595342c456fa603709f965baaf3 d4cd111494554a3ea80cb67d09363756--b4b78595342c456fa603709f965baaf3 f98d30de5f7e45cabcc8ca757de5ef11 b4b78595342c456fa603709f965baaf3--f98d30de5f7e45cabcc8ca757de5ef11 fd8a0334cc8148a7939c4577f511cb57 f98d30de5f7e45cabcc8ca757de5ef11--fd8a0334cc8148a7939c4577f511cb57 fff79365809a4432be93b49b7fd962ba fd8a0334cc8148a7939c4577f511cb57--fff79365809a4432be93b49b7fd962ba fc07a2a0aa2d4786bfa52601308c0989 fff79365809a4432be93b49b7fd962ba--fc07a2a0aa2d4786bfa52601308c0989 3a1e763a3cfe4351af69cc39c6999b0e fc07a2a0aa2d4786bfa52601308c0989--3a1e763a3cfe4351af69cc39c6999b0e b4a0f34f2c00498dac97bf439e2edb8b 3a1e763a3cfe4351af69cc39c6999b0e--b4a0f34f2c00498dac97bf439e2edb8b 461a7fbc7fc245c68bbb55d1e9c84f56 b4a0f34f2c00498dac97bf439e2edb8b--461a7fbc7fc245c68bbb55d1e9c84f56 544b4c3ec35a4ea295c5c7247f133ecd 461a7fbc7fc245c68bbb55d1e9c84f56--544b4c3ec35a4ea295c5c7247f133ecd 352b9cfbaf54466b9083e679007e030b 544b4c3ec35a4ea295c5c7247f133ecd--352b9cfbaf54466b9083e679007e030b 6244660cdd7643f181868aac2a35a5e9 RX(b04) 352b9cfbaf54466b9083e679007e030b--6244660cdd7643f181868aac2a35a5e9 aba1449e045e4c7ab8ef0c21bae2a0f5 6244660cdd7643f181868aac2a35a5e9--aba1449e045e4c7ab8ef0c21bae2a0f5 e8ba420f0a274ffbb6b412e8eb00b77f aba1449e045e4c7ab8ef0c21bae2a0f5--e8ba420f0a274ffbb6b412e8eb00b77f 53358e9344d94342bb02a635ba55fa59 e8ba420f0a274ffbb6b412e8eb00b77f--53358e9344d94342bb02a635ba55fa59 ad9734cae4604cbd89da95c58a102357 X 53358e9344d94342bb02a635ba55fa59--ad9734cae4604cbd89da95c58a102357 ad9734cae4604cbd89da95c58a102357--b3e7ea5ab27d4375805c4b5704077ace 12b51755b52b4c639cb5c8e111a4eb4a ad9734cae4604cbd89da95c58a102357--12b51755b52b4c639cb5c8e111a4eb4a fbf466cfe3184d83b007007ba21eb8f8 12b51755b52b4c639cb5c8e111a4eb4a--fbf466cfe3184d83b007007ba21eb8f8 4d3d045193df4e91ac3f098d594368b4 fbf466cfe3184d83b007007ba21eb8f8--4d3d045193df4e91ac3f098d594368b4 1529187e0a2a426782b351c80a186c54 4d3d045193df4e91ac3f098d594368b4--1529187e0a2a426782b351c80a186c54 521a1ff818554804b98fc2109de19ee8 1529187e0a2a426782b351c80a186c54--521a1ff818554804b98fc2109de19ee8 8754f62d947f4ac3a12337548a7e7ae8 521a1ff818554804b98fc2109de19ee8--8754f62d947f4ac3a12337548a7e7ae8 2ec4d2c4cfe84e16a5a1d0f20bbe81b4 8754f62d947f4ac3a12337548a7e7ae8--2ec4d2c4cfe84e16a5a1d0f20bbe81b4 9eda2429646a48208babcb6b9bdf1331 X 2ec4d2c4cfe84e16a5a1d0f20bbe81b4--9eda2429646a48208babcb6b9bdf1331 9eda2429646a48208babcb6b9bdf1331--cf6a34ac27614b8091b949d97265196d ab20da72058a4efbbc11474116a3d067 9eda2429646a48208babcb6b9bdf1331--ab20da72058a4efbbc11474116a3d067 785ac55b3c63419a8825742349b01e47 ab20da72058a4efbbc11474116a3d067--785ac55b3c63419a8825742349b01e47 85145b18663d45208a2604df7e99cd7e 785ac55b3c63419a8825742349b01e47--85145b18663d45208a2604df7e99cd7e b8917d7cae974b3ba10d5f1fc039f121 85145b18663d45208a2604df7e99cd7e--b8917d7cae974b3ba10d5f1fc039f121 7a36599749914503babbd15584561e9e b8917d7cae974b3ba10d5f1fc039f121--7a36599749914503babbd15584561e9e 5e95559a6ed143269b52b2c0922317c7 7a36599749914503babbd15584561e9e--5e95559a6ed143269b52b2c0922317c7 ee31b5c1585a4dd6afa17baaa1691c4d 5e95559a6ed143269b52b2c0922317c7--ee31b5c1585a4dd6afa17baaa1691c4d 4d335e07bde54b4eafac40f7a1cada90 ee31b5c1585a4dd6afa17baaa1691c4d--4d335e07bde54b4eafac40f7a1cada90 5457b5a2ccac4da6b5e7090c0613fe24 4d335e07bde54b4eafac40f7a1cada90--5457b5a2ccac4da6b5e7090c0613fe24 f7e3f625aae444ebaf92227cc478040a X 5457b5a2ccac4da6b5e7090c0613fe24--f7e3f625aae444ebaf92227cc478040a f7e3f625aae444ebaf92227cc478040a--a9855ca42a4b4823809de31b7e153649 dd9ba4b8dca94518bce5f4fbcffe3f6a RZ(-1.0*g1) f7e3f625aae444ebaf92227cc478040a--dd9ba4b8dca94518bce5f4fbcffe3f6a 24bb8c38f5a74389b0f7821e4667cd46 X dd9ba4b8dca94518bce5f4fbcffe3f6a--24bb8c38f5a74389b0f7821e4667cd46 24bb8c38f5a74389b0f7821e4667cd46--b155a7280b26469e8fcf0c0e3a93a131 3ab093f7f28543f18053effd2443f32f 24bb8c38f5a74389b0f7821e4667cd46--3ab093f7f28543f18053effd2443f32f 24b231e237674ddab9fa1f5d8136e4a4 3ab093f7f28543f18053effd2443f32f--24b231e237674ddab9fa1f5d8136e4a4 e8496b3d263a40a3bfa24f204d29e279 24b231e237674ddab9fa1f5d8136e4a4--e8496b3d263a40a3bfa24f204d29e279 ce81dadc1acc490d94ebcb6a5afeac1c e8496b3d263a40a3bfa24f204d29e279--ce81dadc1acc490d94ebcb6a5afeac1c 6378a05f35f647b09080cfdbbc12c898 ce81dadc1acc490d94ebcb6a5afeac1c--6378a05f35f647b09080cfdbbc12c898 8fd0cd20aea84f2cac1d6a093f6dde40 6378a05f35f647b09080cfdbbc12c898--8fd0cd20aea84f2cac1d6a093f6dde40 b494b3397b7444ea847fc6b920ed589e X 8fd0cd20aea84f2cac1d6a093f6dde40--b494b3397b7444ea847fc6b920ed589e b494b3397b7444ea847fc6b920ed589e--4f5bc9b01c1842f79058c3ca10d31436 a70e8281359a49188093a902a96e9343 b494b3397b7444ea847fc6b920ed589e--a70e8281359a49188093a902a96e9343 3c1de620279143f6b6d1b1e53b812ad1 a70e8281359a49188093a902a96e9343--3c1de620279143f6b6d1b1e53b812ad1 d87ef445763f4573a8100a11a50ebb2b 3c1de620279143f6b6d1b1e53b812ad1--d87ef445763f4573a8100a11a50ebb2b 06876d86e12146ca9de6dc57086e3172 X d87ef445763f4573a8100a11a50ebb2b--06876d86e12146ca9de6dc57086e3172 06876d86e12146ca9de6dc57086e3172--dc294f0b4ee046cf98a405b20c3d5d6b d96c7187204a41bcb0bfed3d41577330 06876d86e12146ca9de6dc57086e3172--d96c7187204a41bcb0bfed3d41577330 1161bb0bf914417a8fd6ae8f20665b61 d96c7187204a41bcb0bfed3d41577330--1161bb0bf914417a8fd6ae8f20665b61 ce2f93797e2d405bb024517454860ab7 1161bb0bf914417a8fd6ae8f20665b61--ce2f93797e2d405bb024517454860ab7 3dea303a208c4811983f67000f3d2de1 ce2f93797e2d405bb024517454860ab7--3dea303a208c4811983f67000f3d2de1 55b3b95ddfd8498d8ed5b4590adea459 3dea303a208c4811983f67000f3d2de1--55b3b95ddfd8498d8ed5b4590adea459 3373b9fa1cc147be8a647e8f68ee690b 55b3b95ddfd8498d8ed5b4590adea459--3373b9fa1cc147be8a647e8f68ee690b 07fe10cce72847b8a8ea2024e302c0e8 X 3373b9fa1cc147be8a647e8f68ee690b--07fe10cce72847b8a8ea2024e302c0e8 07fe10cce72847b8a8ea2024e302c0e8--1e64b95678444299843faa856fac0e47 920319acb84a4416b2815458bc7064bf 07fe10cce72847b8a8ea2024e302c0e8--920319acb84a4416b2815458bc7064bf 5669b991a20d44b89bb8b4f226fdee67 920319acb84a4416b2815458bc7064bf--5669b991a20d44b89bb8b4f226fdee67 816e68fd01484204816272329f025c8f 5669b991a20d44b89bb8b4f226fdee67--816e68fd01484204816272329f025c8f 2da6f350b89f4750aec5a0802df396a6 816e68fd01484204816272329f025c8f--2da6f350b89f4750aec5a0802df396a6 421ce497635c47d3bc37b4e57735f65a 2da6f350b89f4750aec5a0802df396a6--421ce497635c47d3bc37b4e57735f65a eba54ce91988471db1095b2644417461 421ce497635c47d3bc37b4e57735f65a--eba54ce91988471db1095b2644417461 3bc83f8252494ace9de32eea38919dd0 eba54ce91988471db1095b2644417461--3bc83f8252494ace9de32eea38919dd0 d9ec8d67c526409b8da65a49e9241633 X 3bc83f8252494ace9de32eea38919dd0--d9ec8d67c526409b8da65a49e9241633 d9ec8d67c526409b8da65a49e9241633--58663aae2c93431297bdd09ff085a077 aff5c626e2664ac48262b29ac90cf0d9 d9ec8d67c526409b8da65a49e9241633--aff5c626e2664ac48262b29ac90cf0d9 b2c5e212a4944ef98e47e3521e66cb9b aff5c626e2664ac48262b29ac90cf0d9--b2c5e212a4944ef98e47e3521e66cb9b 98e48b6794c94656a211fa994a84e645 b2c5e212a4944ef98e47e3521e66cb9b--98e48b6794c94656a211fa994a84e645 8c635d18ee514309b46d28db3ab9adbb 98e48b6794c94656a211fa994a84e645--8c635d18ee514309b46d28db3ab9adbb 095b90e0b6d94cfaa2bb257b657f3157 8c635d18ee514309b46d28db3ab9adbb--095b90e0b6d94cfaa2bb257b657f3157 2b785f9d31aa4edaa178419c7cebe411 095b90e0b6d94cfaa2bb257b657f3157--2b785f9d31aa4edaa178419c7cebe411 e7d66fc56561436cb1f3fcb642b83b86 2b785f9d31aa4edaa178419c7cebe411--e7d66fc56561436cb1f3fcb642b83b86 eeaae990255a44aea31c594de613a03d e7d66fc56561436cb1f3fcb642b83b86--eeaae990255a44aea31c594de613a03d 22a08e64e6bb43e0b14212bbafb1cad1 eeaae990255a44aea31c594de613a03d--22a08e64e6bb43e0b14212bbafb1cad1 61a4036863ae42c093b070f1ba106839 22a08e64e6bb43e0b14212bbafb1cad1--61a4036863ae42c093b070f1ba106839 f212ab3fa7e744fcab10bafba40f5a48 61a4036863ae42c093b070f1ba106839--f212ab3fa7e744fcab10bafba40f5a48 5f7eb1bff0a54d2cbd5a782befa70e77 f212ab3fa7e744fcab10bafba40f5a48--5f7eb1bff0a54d2cbd5a782befa70e77 6be75d03f4cd4185855c96d0c449d2b5 5f7eb1bff0a54d2cbd5a782befa70e77--6be75d03f4cd4185855c96d0c449d2b5 00dbf9791fb5414996248539193d9111 X 6be75d03f4cd4185855c96d0c449d2b5--00dbf9791fb5414996248539193d9111 00dbf9791fb5414996248539193d9111--3f87b4aaff954a3e96e55e34e3f70222 1fc71910160144e8b292c3c0de373b93 00dbf9791fb5414996248539193d9111--1fc71910160144e8b292c3c0de373b93 bdbc22022dd743bc9e736142ce7d8295 1fc71910160144e8b292c3c0de373b93--bdbc22022dd743bc9e736142ce7d8295 3355e99cc005453588241d986d21e214 bdbc22022dd743bc9e736142ce7d8295--3355e99cc005453588241d986d21e214 28e2796055f246b8b01b29f4a4498b96 X 3355e99cc005453588241d986d21e214--28e2796055f246b8b01b29f4a4498b96 28e2796055f246b8b01b29f4a4498b96--459a40a8713840359d33c67405e0863d 78faeb44fe4d47bf82238f4ed615a7ee 28e2796055f246b8b01b29f4a4498b96--78faeb44fe4d47bf82238f4ed615a7ee 61162fd6d3124a2ca2d2862764ff0aa9 78faeb44fe4d47bf82238f4ed615a7ee--61162fd6d3124a2ca2d2862764ff0aa9 f7827cd085814c1d8bb947b00a850bbf 61162fd6d3124a2ca2d2862764ff0aa9--f7827cd085814c1d8bb947b00a850bbf 860a0f75170346ada2f395268202ec27 f7827cd085814c1d8bb947b00a850bbf--860a0f75170346ada2f395268202ec27 5bc98b37b3ed494684efa7b09110255c X 860a0f75170346ada2f395268202ec27--5bc98b37b3ed494684efa7b09110255c 5bc98b37b3ed494684efa7b09110255c--8e1f1b1a5a4a4634a0717b8a5043e0f0 217b617781494d20997c187dfc2714c0 5bc98b37b3ed494684efa7b09110255c--217b617781494d20997c187dfc2714c0 ca131db8a45b4654bb6f4a15b81c0e1b 217b617781494d20997c187dfc2714c0--ca131db8a45b4654bb6f4a15b81c0e1b e2de4c665ac844f9a52f280eeacf7783 ca131db8a45b4654bb6f4a15b81c0e1b--e2de4c665ac844f9a52f280eeacf7783 418c9d8889494629a9596a13d95266a1 e2de4c665ac844f9a52f280eeacf7783--418c9d8889494629a9596a13d95266a1 2d0a2d16a1524ebba0bd5caee998f6fe 418c9d8889494629a9596a13d95266a1--2d0a2d16a1524ebba0bd5caee998f6fe e4e55639ff454c5fafd2bcfb05903d63 2d0a2d16a1524ebba0bd5caee998f6fe--e4e55639ff454c5fafd2bcfb05903d63 a38e6ef0a7d1498c8be63571e92e2872 e4e55639ff454c5fafd2bcfb05903d63--a38e6ef0a7d1498c8be63571e92e2872 b81a65056312467f94b171381b1f46cc X a38e6ef0a7d1498c8be63571e92e2872--b81a65056312467f94b171381b1f46cc b81a65056312467f94b171381b1f46cc--efbead9c5f274d49a6fc8697f5e89466 0c2c05ba5f7749588ebf0163c2de1381 b81a65056312467f94b171381b1f46cc--0c2c05ba5f7749588ebf0163c2de1381 2a9949e675b447d2907df5192a82d265 0c2c05ba5f7749588ebf0163c2de1381--2a9949e675b447d2907df5192a82d265 ada04550bdb1402ab5da1a71a47cb8d8 2a9949e675b447d2907df5192a82d265--ada04550bdb1402ab5da1a71a47cb8d8 c387c892c3da45a785dfad4267297bd4 ada04550bdb1402ab5da1a71a47cb8d8--c387c892c3da45a785dfad4267297bd4 bac4b48fdcf84ebeb8932f9dca2eee0b c387c892c3da45a785dfad4267297bd4--bac4b48fdcf84ebeb8932f9dca2eee0b 676af2ab64fc4fb8a0273f94492120e4 X bac4b48fdcf84ebeb8932f9dca2eee0b--676af2ab64fc4fb8a0273f94492120e4 676af2ab64fc4fb8a0273f94492120e4--4b18739423b04e0286f68c5576c52c01 24c3d08825014a3f8f706bd78907feee RZ(-1.0*g1) 676af2ab64fc4fb8a0273f94492120e4--24c3d08825014a3f8f706bd78907feee cde84ac55b954891a522bf6e11e0878e X 24c3d08825014a3f8f706bd78907feee--cde84ac55b954891a522bf6e11e0878e cde84ac55b954891a522bf6e11e0878e--82aa24456f4c49edb50b672dfedc64bd ce85e8949a38488f9e15c6023abf5254 X cde84ac55b954891a522bf6e11e0878e--ce85e8949a38488f9e15c6023abf5254 ce85e8949a38488f9e15c6023abf5254--c05f12b8975447d29214af0a3bd15979 dfd10982bd4449568dc61fa6f46f2d1a ce85e8949a38488f9e15c6023abf5254--dfd10982bd4449568dc61fa6f46f2d1a 4b7bee1c02584450afe5b9cae5ec9d37 dfd10982bd4449568dc61fa6f46f2d1a--4b7bee1c02584450afe5b9cae5ec9d37 cb85b59189cf4b8588c4a013b451e50c 4b7bee1c02584450afe5b9cae5ec9d37--cb85b59189cf4b8588c4a013b451e50c 9548322bef5a45b5a457d61d8d6a5f45 cb85b59189cf4b8588c4a013b451e50c--9548322bef5a45b5a457d61d8d6a5f45 addee800a903468298411c074e9b537e 9548322bef5a45b5a457d61d8d6a5f45--addee800a903468298411c074e9b537e e2b16537ce9b4412829cd5cc700c01e2 X addee800a903468298411c074e9b537e--e2b16537ce9b4412829cd5cc700c01e2 e2b16537ce9b4412829cd5cc700c01e2--8a93b51e82344b46a855d9ee21e2af80 db67367aefe64b8cbf06f907cfdb870c X e2b16537ce9b4412829cd5cc700c01e2--db67367aefe64b8cbf06f907cfdb870c db67367aefe64b8cbf06f907cfdb870c--7ef0d5cce8d34b6fa1d22a43003452c8 bd51e00ca0da40f5bda5c3191d449f6b db67367aefe64b8cbf06f907cfdb870c--bd51e00ca0da40f5bda5c3191d449f6b fa14357a0e154b78bf3b6b1b138ee965 bd51e00ca0da40f5bda5c3191d449f6b--fa14357a0e154b78bf3b6b1b138ee965 326f75168bb54d41878bf98eea0f3c15 fa14357a0e154b78bf3b6b1b138ee965--326f75168bb54d41878bf98eea0f3c15 a312a787e7164a9a90f3a0c2526ac146 326f75168bb54d41878bf98eea0f3c15--a312a787e7164a9a90f3a0c2526ac146 640c75e1edc94e1dbffb5139afd587c2 a312a787e7164a9a90f3a0c2526ac146--640c75e1edc94e1dbffb5139afd587c2 dd35aec30a804bbf8d63045ff65288c6 640c75e1edc94e1dbffb5139afd587c2--dd35aec30a804bbf8d63045ff65288c6 0adcb772104242a48fea41a8c18cdcc3 dd35aec30a804bbf8d63045ff65288c6--0adcb772104242a48fea41a8c18cdcc3 214d3075e24d4ce5bb39c748a79cf8ca X 0adcb772104242a48fea41a8c18cdcc3--214d3075e24d4ce5bb39c748a79cf8ca 214d3075e24d4ce5bb39c748a79cf8ca--284870321b764c8baacc8ee90253fbc2 4dbb32c38a434814b2beb547480aebff 214d3075e24d4ce5bb39c748a79cf8ca--4dbb32c38a434814b2beb547480aebff a59431c95548444da79f83268b680dad 4dbb32c38a434814b2beb547480aebff--a59431c95548444da79f83268b680dad 23237033609143f68072fb469beede7f a59431c95548444da79f83268b680dad--23237033609143f68072fb469beede7f 17635983e0f543d580c6b4a8cfe56891 23237033609143f68072fb469beede7f--17635983e0f543d580c6b4a8cfe56891 e2eba72f06a64f0fa67db75b5ca42b33 17635983e0f543d580c6b4a8cfe56891--e2eba72f06a64f0fa67db75b5ca42b33 7f084f7c799e4327b17a754c8584c0ad e2eba72f06a64f0fa67db75b5ca42b33--7f084f7c799e4327b17a754c8584c0ad 78cde63afce6457692ff0875470942f2 7f084f7c799e4327b17a754c8584c0ad--78cde63afce6457692ff0875470942f2 c669a980299d4bdfb29cc368b53a847a 78cde63afce6457692ff0875470942f2--c669a980299d4bdfb29cc368b53a847a 2c9dd2731a3a42189eb5a461971518e4 c669a980299d4bdfb29cc368b53a847a--2c9dd2731a3a42189eb5a461971518e4 e88dd67c609844d3906150dad213f937 2c9dd2731a3a42189eb5a461971518e4--e88dd67c609844d3906150dad213f937 32d8c200359b40bf9829a67afd9f3feb e88dd67c609844d3906150dad213f937--32d8c200359b40bf9829a67afd9f3feb 97589119302c41ab8825926664ee9673 32d8c200359b40bf9829a67afd9f3feb--97589119302c41ab8825926664ee9673 4a36f9cb09f64b249394f2e8209eba9b 97589119302c41ab8825926664ee9673--4a36f9cb09f64b249394f2e8209eba9b 1ff3fd7eee0c4ebc9657a7bf1d351a71 4a36f9cb09f64b249394f2e8209eba9b--1ff3fd7eee0c4ebc9657a7bf1d351a71 4b63e81d3b7f4646802b6ff3f5ebd50b 1ff3fd7eee0c4ebc9657a7bf1d351a71--4b63e81d3b7f4646802b6ff3f5ebd50b da9f37cf8c2e4f8b921b23c48416b531 RX(b14) 4b63e81d3b7f4646802b6ff3f5ebd50b--da9f37cf8c2e4f8b921b23c48416b531 da9f37cf8c2e4f8b921b23c48416b531--8f4f9d8809724ffab6ce665a5c19feca 1522a065126748f4b129e755ee1622c6 9e41c5b963f14353929f5a58fa5d719a fdbbc62bfeda42f68db0db6d3e498779--9e41c5b963f14353929f5a58fa5d719a e40419ba4d0d4bb1bba9073ad7eac966 6 4878ed837859451c95adeecddaa429e3 9e41c5b963f14353929f5a58fa5d719a--4878ed837859451c95adeecddaa429e3 7e4d572a26f043bdabd7be652d0a6877 4878ed837859451c95adeecddaa429e3--7e4d572a26f043bdabd7be652d0a6877 45ded7583f9645bd89f9779e92558381 7e4d572a26f043bdabd7be652d0a6877--45ded7583f9645bd89f9779e92558381 f4fa6e7ecee04a558f432fa06346c881 X 45ded7583f9645bd89f9779e92558381--f4fa6e7ecee04a558f432fa06346c881 f4fa6e7ecee04a558f432fa06346c881--9af69b91bd0b468c875706f02506113a 9dd60e286b1d4433bab86fa5fb5dd936 f4fa6e7ecee04a558f432fa06346c881--9dd60e286b1d4433bab86fa5fb5dd936 f297a5c3024a403a902862d689357024 9dd60e286b1d4433bab86fa5fb5dd936--f297a5c3024a403a902862d689357024 3a898e72afd24d4b85735426cc261867 f297a5c3024a403a902862d689357024--3a898e72afd24d4b85735426cc261867 d294f217a8314963962747d0c0cb2aea 3a898e72afd24d4b85735426cc261867--d294f217a8314963962747d0c0cb2aea d0eba6b572df4e6993e861f6b3d87214 d294f217a8314963962747d0c0cb2aea--d0eba6b572df4e6993e861f6b3d87214 ec24202f542c47849a50a566ea4d7d12 X d0eba6b572df4e6993e861f6b3d87214--ec24202f542c47849a50a566ea4d7d12 ec24202f542c47849a50a566ea4d7d12--5a2a261c50904b53a3dfdcc508d34e81 bcb8a13029ee47189727751e8be5fc17 ec24202f542c47849a50a566ea4d7d12--bcb8a13029ee47189727751e8be5fc17 33d3931fcea7438c836e386b9bc830ea bcb8a13029ee47189727751e8be5fc17--33d3931fcea7438c836e386b9bc830ea 8cfd06629dc243cba09d0cd45586ccb8 33d3931fcea7438c836e386b9bc830ea--8cfd06629dc243cba09d0cd45586ccb8 fa65256c3fc4443793e4fc78fba2b722 8cfd06629dc243cba09d0cd45586ccb8--fa65256c3fc4443793e4fc78fba2b722 a82d4888ad0b4086b44e7a7de59f64ac fa65256c3fc4443793e4fc78fba2b722--a82d4888ad0b4086b44e7a7de59f64ac 5af3bf7d949642c4ad5831a2b88ec749 a82d4888ad0b4086b44e7a7de59f64ac--5af3bf7d949642c4ad5831a2b88ec749 29592aed6e1843a4bc54f4b56c177c8d 5af3bf7d949642c4ad5831a2b88ec749--29592aed6e1843a4bc54f4b56c177c8d 278b778199a74ff0914c5eadb9ed8f33 29592aed6e1843a4bc54f4b56c177c8d--278b778199a74ff0914c5eadb9ed8f33 7147ae7da8594a37ae9d3f6f17795730 278b778199a74ff0914c5eadb9ed8f33--7147ae7da8594a37ae9d3f6f17795730 bc067335f0b74788bb5c47bdc4574100 7147ae7da8594a37ae9d3f6f17795730--bc067335f0b74788bb5c47bdc4574100 0f8f6baf39eb41adb1e6017f8f40d43e bc067335f0b74788bb5c47bdc4574100--0f8f6baf39eb41adb1e6017f8f40d43e aeaf8c773851401aaa3101865cd7e2d0 0f8f6baf39eb41adb1e6017f8f40d43e--aeaf8c773851401aaa3101865cd7e2d0 a0f17222132c4564b77c5e254d5dabe3 aeaf8c773851401aaa3101865cd7e2d0--a0f17222132c4564b77c5e254d5dabe3 1ac329ea55fa48e58304cf2ecedab4c2 a0f17222132c4564b77c5e254d5dabe3--1ac329ea55fa48e58304cf2ecedab4c2 a2b893a23c4549e489b7d64f20e3dc08 1ac329ea55fa48e58304cf2ecedab4c2--a2b893a23c4549e489b7d64f20e3dc08 060d4d448444480c8a11a9671a496c20 a2b893a23c4549e489b7d64f20e3dc08--060d4d448444480c8a11a9671a496c20 8dfc38176aa14fa2b82f3e28d9bf2f86 060d4d448444480c8a11a9671a496c20--8dfc38176aa14fa2b82f3e28d9bf2f86 663d738091a34f06b2db57408768bf62 8dfc38176aa14fa2b82f3e28d9bf2f86--663d738091a34f06b2db57408768bf62 2c98191b54d6443f885d8c1dc842b8c2 663d738091a34f06b2db57408768bf62--2c98191b54d6443f885d8c1dc842b8c2 8eec3cdbc6bd4261b8db283c0b408895 2c98191b54d6443f885d8c1dc842b8c2--8eec3cdbc6bd4261b8db283c0b408895 7d5993cef2e046d1889f0e739c8a92f8 X 8eec3cdbc6bd4261b8db283c0b408895--7d5993cef2e046d1889f0e739c8a92f8 7d5993cef2e046d1889f0e739c8a92f8--19aa0edfa2da4de59c7b0418e08cc37b 164f60c8296c4fe0b31df7e836849b9d RZ(-1.0*g0) 7d5993cef2e046d1889f0e739c8a92f8--164f60c8296c4fe0b31df7e836849b9d 384444b51a10465884563ebe3f6beb0c X 164f60c8296c4fe0b31df7e836849b9d--384444b51a10465884563ebe3f6beb0c 384444b51a10465884563ebe3f6beb0c--1fa2ea218d014176b500e8e8a5903627 10ebfc8711134a33a4524dd79bfb94f9 384444b51a10465884563ebe3f6beb0c--10ebfc8711134a33a4524dd79bfb94f9 e8e991a4db9547a59a556d3fce0a6ce9 10ebfc8711134a33a4524dd79bfb94f9--e8e991a4db9547a59a556d3fce0a6ce9 c83db6be234b433ca2817c15d79796dd e8e991a4db9547a59a556d3fce0a6ce9--c83db6be234b433ca2817c15d79796dd ce403263d6bc4c84a2f8e0467203e91d c83db6be234b433ca2817c15d79796dd--ce403263d6bc4c84a2f8e0467203e91d e5fa7f7a25f54aef93572a9c622541fa ce403263d6bc4c84a2f8e0467203e91d--e5fa7f7a25f54aef93572a9c622541fa d3c84f5638574ea0a0a837d4f7d7656c e5fa7f7a25f54aef93572a9c622541fa--d3c84f5638574ea0a0a837d4f7d7656c 4b3c75998c634dab84debdf6c05a83e9 d3c84f5638574ea0a0a837d4f7d7656c--4b3c75998c634dab84debdf6c05a83e9 5717a427243f4f1589dc7c744dd6f51c 4b3c75998c634dab84debdf6c05a83e9--5717a427243f4f1589dc7c744dd6f51c c4ddd5d10b62401da6a5964e3126b237 X 5717a427243f4f1589dc7c744dd6f51c--c4ddd5d10b62401da6a5964e3126b237 c4ddd5d10b62401da6a5964e3126b237--32cade06314b4570b39c1bf6417c3df4 331d849ee06441caa9d482e1ecb514a7 c4ddd5d10b62401da6a5964e3126b237--331d849ee06441caa9d482e1ecb514a7 86c4dc50131c4118a2fa49f066f6016e 331d849ee06441caa9d482e1ecb514a7--86c4dc50131c4118a2fa49f066f6016e 565c65b689424b108dfc550b46bc64b6 86c4dc50131c4118a2fa49f066f6016e--565c65b689424b108dfc550b46bc64b6 aaafad13e1f54a3ca81f9161b5247e7e 565c65b689424b108dfc550b46bc64b6--aaafad13e1f54a3ca81f9161b5247e7e 69118cf3d5a84065bdfa0ef268c810b0 aaafad13e1f54a3ca81f9161b5247e7e--69118cf3d5a84065bdfa0ef268c810b0 76f007fec6c0480e87b24d2656ffc97e X 69118cf3d5a84065bdfa0ef268c810b0--76f007fec6c0480e87b24d2656ffc97e 76f007fec6c0480e87b24d2656ffc97e--e1e0b076415e45839f470dea0531ded0 18dcda35e6b044368b34c47126e5ab27 76f007fec6c0480e87b24d2656ffc97e--18dcda35e6b044368b34c47126e5ab27 6cc070a8399c47aca5cf8c264959ed30 18dcda35e6b044368b34c47126e5ab27--6cc070a8399c47aca5cf8c264959ed30 95220a9a70454e08a400c45522975a74 6cc070a8399c47aca5cf8c264959ed30--95220a9a70454e08a400c45522975a74 f3b0176940e8435c9d3b819135274d11 95220a9a70454e08a400c45522975a74--f3b0176940e8435c9d3b819135274d11 530ccd87f2e147a6a6ded11608d9e41c f3b0176940e8435c9d3b819135274d11--530ccd87f2e147a6a6ded11608d9e41c 7fc3412c4542402c8b9fea09367e61c8 530ccd87f2e147a6a6ded11608d9e41c--7fc3412c4542402c8b9fea09367e61c8 1d7981fb328641dcbecd8a5e6cbe4e65 7fc3412c4542402c8b9fea09367e61c8--1d7981fb328641dcbecd8a5e6cbe4e65 98b619fc9ca9497c80ada557f415d46e 1d7981fb328641dcbecd8a5e6cbe4e65--98b619fc9ca9497c80ada557f415d46e ad9a47a141e041518f6e9252496619a1 98b619fc9ca9497c80ada557f415d46e--ad9a47a141e041518f6e9252496619a1 d0e57553f7554565bdbf44d13fcc7220 ad9a47a141e041518f6e9252496619a1--d0e57553f7554565bdbf44d13fcc7220 6ff41fdf4fd845f087fa3c811cc1a16a d0e57553f7554565bdbf44d13fcc7220--6ff41fdf4fd845f087fa3c811cc1a16a e0646da59a24411680d88abe6f8ad168 6ff41fdf4fd845f087fa3c811cc1a16a--e0646da59a24411680d88abe6f8ad168 fcec30db63134204b18961bd3c9f4254 e0646da59a24411680d88abe6f8ad168--fcec30db63134204b18961bd3c9f4254 98f95ac4d30c482db3cc4cf11bd51e90 fcec30db63134204b18961bd3c9f4254--98f95ac4d30c482db3cc4cf11bd51e90 8eddbd92080244a98238e464b462859a 98f95ac4d30c482db3cc4cf11bd51e90--8eddbd92080244a98238e464b462859a d49b7dc4dbcc4e2ca90bfb973c7bbe78 X 8eddbd92080244a98238e464b462859a--d49b7dc4dbcc4e2ca90bfb973c7bbe78 d49b7dc4dbcc4e2ca90bfb973c7bbe78--01de38b290194db786f3fd9196764ff7 11976d6d89404f94b54c55bbcb296910 RZ(-1.0*g0) d49b7dc4dbcc4e2ca90bfb973c7bbe78--11976d6d89404f94b54c55bbcb296910 e4eec1f315bf4411a1bcfe0c54ba6510 X 11976d6d89404f94b54c55bbcb296910--e4eec1f315bf4411a1bcfe0c54ba6510 e4eec1f315bf4411a1bcfe0c54ba6510--acc5d69f302c45a7b36a3c1f3df9947d 9574c00e37c64f8bb1a912ece0d2f047 e4eec1f315bf4411a1bcfe0c54ba6510--9574c00e37c64f8bb1a912ece0d2f047 469a83b01bf74b30ac6c7a9cf1593e3f 9574c00e37c64f8bb1a912ece0d2f047--469a83b01bf74b30ac6c7a9cf1593e3f b1f60ca87b104899ab5010b3727f8b51 469a83b01bf74b30ac6c7a9cf1593e3f--b1f60ca87b104899ab5010b3727f8b51 c86f6fa6ffec453ab05dc2036987660a b1f60ca87b104899ab5010b3727f8b51--c86f6fa6ffec453ab05dc2036987660a b7b0f86ac2114babbf644033c840b4f9 c86f6fa6ffec453ab05dc2036987660a--b7b0f86ac2114babbf644033c840b4f9 2d4ede62e9e54a979964a51083901876 b7b0f86ac2114babbf644033c840b4f9--2d4ede62e9e54a979964a51083901876 381ef85d157b4883ab60cf2c8de66c01 X 2d4ede62e9e54a979964a51083901876--381ef85d157b4883ab60cf2c8de66c01 381ef85d157b4883ab60cf2c8de66c01--5cad1d0c7db242cc9fe4ef53e2496418 ee378f59ebfd40deba0556693e295bf6 381ef85d157b4883ab60cf2c8de66c01--ee378f59ebfd40deba0556693e295bf6 0da6a6598b904f8c87e5c0c28d4ed3a5 ee378f59ebfd40deba0556693e295bf6--0da6a6598b904f8c87e5c0c28d4ed3a5 fdfd4c8ce8214d42b38ab3f3fe2b4424 0da6a6598b904f8c87e5c0c28d4ed3a5--fdfd4c8ce8214d42b38ab3f3fe2b4424 ffe70ec1e62e45908050a8967d0dd19f fdfd4c8ce8214d42b38ab3f3fe2b4424--ffe70ec1e62e45908050a8967d0dd19f 15074c66e42347639d54a9ed9e6ffa7b ffe70ec1e62e45908050a8967d0dd19f--15074c66e42347639d54a9ed9e6ffa7b 2f33c9fbb0694ef480c07c04c3b70799 X 15074c66e42347639d54a9ed9e6ffa7b--2f33c9fbb0694ef480c07c04c3b70799 2f33c9fbb0694ef480c07c04c3b70799--e4a4c03ff60344b9996434cd0f981ccd e06639ff3d2244bc99d7543c25eff23f 2f33c9fbb0694ef480c07c04c3b70799--e06639ff3d2244bc99d7543c25eff23f 37a1cf330b394acabcae00fcd6c3d914 e06639ff3d2244bc99d7543c25eff23f--37a1cf330b394acabcae00fcd6c3d914 0de7b3a0a49d4d318997ca7252bfccd9 37a1cf330b394acabcae00fcd6c3d914--0de7b3a0a49d4d318997ca7252bfccd9 5324bf01330b49279e35f70d043ec014 0de7b3a0a49d4d318997ca7252bfccd9--5324bf01330b49279e35f70d043ec014 d2dd26c32e9c46d4b6a2c0c4db5d391a 5324bf01330b49279e35f70d043ec014--d2dd26c32e9c46d4b6a2c0c4db5d391a 0c694c2959e949f1ba18dea212f6b9f1 d2dd26c32e9c46d4b6a2c0c4db5d391a--0c694c2959e949f1ba18dea212f6b9f1 e5f7b38e4f0a430d9256412e1aad67c2 0c694c2959e949f1ba18dea212f6b9f1--e5f7b38e4f0a430d9256412e1aad67c2 b6b1dd30398e4671957cb2d3cf6bb9b1 e5f7b38e4f0a430d9256412e1aad67c2--b6b1dd30398e4671957cb2d3cf6bb9b1 66d62e51dbfb473498dafa73c2b738d4 b6b1dd30398e4671957cb2d3cf6bb9b1--66d62e51dbfb473498dafa73c2b738d4 f750405418744aa3b5eaacb778cfffde 66d62e51dbfb473498dafa73c2b738d4--f750405418744aa3b5eaacb778cfffde 206fca58b6804d70aa09eb18cda0a26b X f750405418744aa3b5eaacb778cfffde--206fca58b6804d70aa09eb18cda0a26b 206fca58b6804d70aa09eb18cda0a26b--fc09a069a9d346efa2a0fc45c15348aa 1ea48e2acb9b4bfabf04aabb32a47a53 206fca58b6804d70aa09eb18cda0a26b--1ea48e2acb9b4bfabf04aabb32a47a53 a46b406222bc41d0a98d8a2a615d5d1b 1ea48e2acb9b4bfabf04aabb32a47a53--a46b406222bc41d0a98d8a2a615d5d1b 88ffa9da434a41cbaf8ddcc554223731 a46b406222bc41d0a98d8a2a615d5d1b--88ffa9da434a41cbaf8ddcc554223731 ea457a66ab274b11a32985ce95ad3b28 X 88ffa9da434a41cbaf8ddcc554223731--ea457a66ab274b11a32985ce95ad3b28 ea457a66ab274b11a32985ce95ad3b28--dc92050fda8e45f0aca0f2c2f28cf5e9 0f8ec9eaffdc4f4c897072abeffe3832 ea457a66ab274b11a32985ce95ad3b28--0f8ec9eaffdc4f4c897072abeffe3832 acc2b387a81f446684d0639487821d06 0f8ec9eaffdc4f4c897072abeffe3832--acc2b387a81f446684d0639487821d06 4c6df29e09ca4691adc3cb1f7867e50c X acc2b387a81f446684d0639487821d06--4c6df29e09ca4691adc3cb1f7867e50c 4c6df29e09ca4691adc3cb1f7867e50c--732d1daea57d4d13ad2ea57339f149a9 2247f897697d458ba4898f80ce80151b 4c6df29e09ca4691adc3cb1f7867e50c--2247f897697d458ba4898f80ce80151b 987939b36dbc4f1aaff9b9d9189f85bb 2247f897697d458ba4898f80ce80151b--987939b36dbc4f1aaff9b9d9189f85bb 9810ee4b257648f7a2be9989c5a25a12 987939b36dbc4f1aaff9b9d9189f85bb--9810ee4b257648f7a2be9989c5a25a12 24c800d1c1a34a0db9ec0a4c6f6dfab9 9810ee4b257648f7a2be9989c5a25a12--24c800d1c1a34a0db9ec0a4c6f6dfab9 b6ff61ba136c4a00bb31e90e8ae59831 24c800d1c1a34a0db9ec0a4c6f6dfab9--b6ff61ba136c4a00bb31e90e8ae59831 93c0a60b148d43e58a8df845fc1bc426 X b6ff61ba136c4a00bb31e90e8ae59831--93c0a60b148d43e58a8df845fc1bc426 93c0a60b148d43e58a8df845fc1bc426--cbd90bf3151f4064b9c92f0fbb9042f6 83e9d74b237648869c641bfdc63635a6 93c0a60b148d43e58a8df845fc1bc426--83e9d74b237648869c641bfdc63635a6 f3f05eed6bfa4df38a9684c653518ce5 X 83e9d74b237648869c641bfdc63635a6--f3f05eed6bfa4df38a9684c653518ce5 f3f05eed6bfa4df38a9684c653518ce5--aa9ca054d6df40f7824ebe11067c9157 fcd1fb0ab15949c0bc889da6b406ae1d RZ(-1.0*g0) f3f05eed6bfa4df38a9684c653518ce5--fcd1fb0ab15949c0bc889da6b406ae1d 830fa4ce58e048869bd2fd9d4a0be4aa X fcd1fb0ab15949c0bc889da6b406ae1d--830fa4ce58e048869bd2fd9d4a0be4aa 830fa4ce58e048869bd2fd9d4a0be4aa--5fdc6f28162c47858fabd046c45751cc efcbf65a1bf740d3b822fc8b9a76cc77 X 830fa4ce58e048869bd2fd9d4a0be4aa--efcbf65a1bf740d3b822fc8b9a76cc77 efcbf65a1bf740d3b822fc8b9a76cc77--34e232d40e054b799bd4e9fdef43619b 83918d3b921d4612bb2431163a200f48 efcbf65a1bf740d3b822fc8b9a76cc77--83918d3b921d4612bb2431163a200f48 8e2f618fda344a2c8f590e0967dd4fd8 83918d3b921d4612bb2431163a200f48--8e2f618fda344a2c8f590e0967dd4fd8 9125831762ce4dc28bae455efe9b5a6b 8e2f618fda344a2c8f590e0967dd4fd8--9125831762ce4dc28bae455efe9b5a6b 3dbb98ccd112420bab2a5febf1853c58 X 9125831762ce4dc28bae455efe9b5a6b--3dbb98ccd112420bab2a5febf1853c58 3dbb98ccd112420bab2a5febf1853c58--fd8a0334cc8148a7939c4577f511cb57 3c02c9422d8f42298d0fe003f9ac4a32 X 3dbb98ccd112420bab2a5febf1853c58--3c02c9422d8f42298d0fe003f9ac4a32 3c02c9422d8f42298d0fe003f9ac4a32--fff79365809a4432be93b49b7fd962ba 9970f988fb1340429fce1ac852ba1a0b 3c02c9422d8f42298d0fe003f9ac4a32--9970f988fb1340429fce1ac852ba1a0b 48e358f18cac4ce49dae81095123490d 9970f988fb1340429fce1ac852ba1a0b--48e358f18cac4ce49dae81095123490d 0d8ce9f032aa498eac0e6bfb5b04838d 48e358f18cac4ce49dae81095123490d--0d8ce9f032aa498eac0e6bfb5b04838d 2c231ef987d343d4b797a987e6f6a51c 0d8ce9f032aa498eac0e6bfb5b04838d--2c231ef987d343d4b797a987e6f6a51c dc48679ce1b546f094b46f8e49cfe4d6 2c231ef987d343d4b797a987e6f6a51c--dc48679ce1b546f094b46f8e49cfe4d6 34ffa6116aaf4d78bcfeadcc5091619f X dc48679ce1b546f094b46f8e49cfe4d6--34ffa6116aaf4d78bcfeadcc5091619f 34ffa6116aaf4d78bcfeadcc5091619f--352b9cfbaf54466b9083e679007e030b 391fd804037b4974ab66351defcbf101 RX(b05) 34ffa6116aaf4d78bcfeadcc5091619f--391fd804037b4974ab66351defcbf101 42cbb424f1324588972246a18db0dad5 391fd804037b4974ab66351defcbf101--42cbb424f1324588972246a18db0dad5 4b45373e44714784971a8b2100b86f43 42cbb424f1324588972246a18db0dad5--4b45373e44714784971a8b2100b86f43 c9816108b7594962b37b2b1c45fb646a 4b45373e44714784971a8b2100b86f43--c9816108b7594962b37b2b1c45fb646a d2c4998ff8c6450bbf87e38ef0971448 c9816108b7594962b37b2b1c45fb646a--d2c4998ff8c6450bbf87e38ef0971448 72b0046b575e474d91ebf0592a051267 X d2c4998ff8c6450bbf87e38ef0971448--72b0046b575e474d91ebf0592a051267 72b0046b575e474d91ebf0592a051267--12b51755b52b4c639cb5c8e111a4eb4a 36f99ea9646140ab8a9867eb14d3dbe6 72b0046b575e474d91ebf0592a051267--36f99ea9646140ab8a9867eb14d3dbe6 89fb198f811845fa84f1ff70cee89d0b 36f99ea9646140ab8a9867eb14d3dbe6--89fb198f811845fa84f1ff70cee89d0b 5965f461551444bbbcc3f5119029618f 89fb198f811845fa84f1ff70cee89d0b--5965f461551444bbbcc3f5119029618f 6a761dca5a074438b60143b2f06b9b0b 5965f461551444bbbcc3f5119029618f--6a761dca5a074438b60143b2f06b9b0b 582e5b3ff6bf4fbdba667366cd402430 6a761dca5a074438b60143b2f06b9b0b--582e5b3ff6bf4fbdba667366cd402430 c3fd9665e45e4a639a92960895831bd6 X 582e5b3ff6bf4fbdba667366cd402430--c3fd9665e45e4a639a92960895831bd6 c3fd9665e45e4a639a92960895831bd6--2ec4d2c4cfe84e16a5a1d0f20bbe81b4 354b824d806d42eebed07899769a2683 c3fd9665e45e4a639a92960895831bd6--354b824d806d42eebed07899769a2683 ab4cb7281aee4e8d987206ef81555a99 354b824d806d42eebed07899769a2683--ab4cb7281aee4e8d987206ef81555a99 972f7ef244894b0fb8fd19fe178a4ca5 ab4cb7281aee4e8d987206ef81555a99--972f7ef244894b0fb8fd19fe178a4ca5 3f5607359c204de9a16727f133905cd4 972f7ef244894b0fb8fd19fe178a4ca5--3f5607359c204de9a16727f133905cd4 ddca122b0d00459a8ea7028366685be2 3f5607359c204de9a16727f133905cd4--ddca122b0d00459a8ea7028366685be2 17700c8503a140d4987b9ced16673730 ddca122b0d00459a8ea7028366685be2--17700c8503a140d4987b9ced16673730 392dffdbc28545e7916c498b55e91298 17700c8503a140d4987b9ced16673730--392dffdbc28545e7916c498b55e91298 79d60ea67f6f4b5aacdb026cfff7c7f3 392dffdbc28545e7916c498b55e91298--79d60ea67f6f4b5aacdb026cfff7c7f3 6c7988a5aa21414c96a33e8c584538f3 79d60ea67f6f4b5aacdb026cfff7c7f3--6c7988a5aa21414c96a33e8c584538f3 f4e40ee47a3447b8ae25c884ae70faa5 6c7988a5aa21414c96a33e8c584538f3--f4e40ee47a3447b8ae25c884ae70faa5 c133c0853fc34b269a011663cbfe4b9c f4e40ee47a3447b8ae25c884ae70faa5--c133c0853fc34b269a011663cbfe4b9c 772d1c163fbf40188559270cbcf79e0a c133c0853fc34b269a011663cbfe4b9c--772d1c163fbf40188559270cbcf79e0a a2aa31c8ebea4c90a69beda00af8d7c7 772d1c163fbf40188559270cbcf79e0a--a2aa31c8ebea4c90a69beda00af8d7c7 09551aa16b43404ab90c388be4ef7e6c a2aa31c8ebea4c90a69beda00af8d7c7--09551aa16b43404ab90c388be4ef7e6c 56560f70067c4a0283b01c969712a4bd 09551aa16b43404ab90c388be4ef7e6c--56560f70067c4a0283b01c969712a4bd 1f252bf1ef114007b0242b5cae24068d 56560f70067c4a0283b01c969712a4bd--1f252bf1ef114007b0242b5cae24068d 85202ef991bf404aace0c95dcbd30b42 1f252bf1ef114007b0242b5cae24068d--85202ef991bf404aace0c95dcbd30b42 6eb0b6b3359f43cab8f37a71c677c5b0 85202ef991bf404aace0c95dcbd30b42--6eb0b6b3359f43cab8f37a71c677c5b0 258b9c4f9f6849ba8b4da0bd02524680 6eb0b6b3359f43cab8f37a71c677c5b0--258b9c4f9f6849ba8b4da0bd02524680 277b688d6c1f4e9cbf315ec4a994c114 258b9c4f9f6849ba8b4da0bd02524680--277b688d6c1f4e9cbf315ec4a994c114 9987150710e7427b80c986039945ef66 X 277b688d6c1f4e9cbf315ec4a994c114--9987150710e7427b80c986039945ef66 9987150710e7427b80c986039945ef66--a70e8281359a49188093a902a96e9343 6e280e272de748b19de6e1b521fe0976 RZ(-1.0*g1) 9987150710e7427b80c986039945ef66--6e280e272de748b19de6e1b521fe0976 21e4078af364414cae5c478d72801fce X 6e280e272de748b19de6e1b521fe0976--21e4078af364414cae5c478d72801fce 21e4078af364414cae5c478d72801fce--d87ef445763f4573a8100a11a50ebb2b 2b4d0aded1ae44f088e148ea11605f75 21e4078af364414cae5c478d72801fce--2b4d0aded1ae44f088e148ea11605f75 116e4fb542264549afad461211ac80e4 2b4d0aded1ae44f088e148ea11605f75--116e4fb542264549afad461211ac80e4 935adabcfcea47b7ae9221640d0e08e0 116e4fb542264549afad461211ac80e4--935adabcfcea47b7ae9221640d0e08e0 88078b0208434b6c93ea73099fead9eb 935adabcfcea47b7ae9221640d0e08e0--88078b0208434b6c93ea73099fead9eb 568312a156f94204965ae5211b51f0b8 88078b0208434b6c93ea73099fead9eb--568312a156f94204965ae5211b51f0b8 997b947bc0da414a95a86c8ff6e54185 568312a156f94204965ae5211b51f0b8--997b947bc0da414a95a86c8ff6e54185 f80f71e9cbf548599ac5047bb39b64f9 997b947bc0da414a95a86c8ff6e54185--f80f71e9cbf548599ac5047bb39b64f9 93e3a77b4c38483b9cf9c6ef11765dff f80f71e9cbf548599ac5047bb39b64f9--93e3a77b4c38483b9cf9c6ef11765dff fdf74848cc4f41ec8596561de0e267d4 X 93e3a77b4c38483b9cf9c6ef11765dff--fdf74848cc4f41ec8596561de0e267d4 fdf74848cc4f41ec8596561de0e267d4--920319acb84a4416b2815458bc7064bf 88fd82c3b2774405afda04ccdc30fb00 fdf74848cc4f41ec8596561de0e267d4--88fd82c3b2774405afda04ccdc30fb00 65b97ad864a842a6b53f73443742df31 88fd82c3b2774405afda04ccdc30fb00--65b97ad864a842a6b53f73443742df31 10b5f9c7cd8b4756a39bd78a5f855642 65b97ad864a842a6b53f73443742df31--10b5f9c7cd8b4756a39bd78a5f855642 3d866b35ca3646dda7f3c778e556054d 10b5f9c7cd8b4756a39bd78a5f855642--3d866b35ca3646dda7f3c778e556054d f5bb49165eac45a081c33c8a40279b8b 3d866b35ca3646dda7f3c778e556054d--f5bb49165eac45a081c33c8a40279b8b 7f7f075ceeb843ecb0b748ce4ed55288 X f5bb49165eac45a081c33c8a40279b8b--7f7f075ceeb843ecb0b748ce4ed55288 7f7f075ceeb843ecb0b748ce4ed55288--3bc83f8252494ace9de32eea38919dd0 2def6f0c992440fc9fb01a89d456754f 7f7f075ceeb843ecb0b748ce4ed55288--2def6f0c992440fc9fb01a89d456754f 6e89fb6b9bc74a1ab3add1256a39f1e3 2def6f0c992440fc9fb01a89d456754f--6e89fb6b9bc74a1ab3add1256a39f1e3 75ba30d19f634642ad6da24e945bea84 6e89fb6b9bc74a1ab3add1256a39f1e3--75ba30d19f634642ad6da24e945bea84 90609d8270df4d09bc408e5aba4a5af4 75ba30d19f634642ad6da24e945bea84--90609d8270df4d09bc408e5aba4a5af4 6eda064217694931a827dabb9beb2244 90609d8270df4d09bc408e5aba4a5af4--6eda064217694931a827dabb9beb2244 e1b0f95cd03143548c00fde4b338a37c 6eda064217694931a827dabb9beb2244--e1b0f95cd03143548c00fde4b338a37c bd4e743da0de4e74979f194ad6f25729 e1b0f95cd03143548c00fde4b338a37c--bd4e743da0de4e74979f194ad6f25729 e981aefc789345848c850b57c190e471 bd4e743da0de4e74979f194ad6f25729--e981aefc789345848c850b57c190e471 28ff1628163645848eeb01eaeb67f285 e981aefc789345848c850b57c190e471--28ff1628163645848eeb01eaeb67f285 72ace6108dc14d11b39c47df5a464d3e 28ff1628163645848eeb01eaeb67f285--72ace6108dc14d11b39c47df5a464d3e fe1f9b8e7c1a41e38ceac4a9fbf9f705 72ace6108dc14d11b39c47df5a464d3e--fe1f9b8e7c1a41e38ceac4a9fbf9f705 1fdbe25f98924abf9d83bbf664cbca4b fe1f9b8e7c1a41e38ceac4a9fbf9f705--1fdbe25f98924abf9d83bbf664cbca4b 34b27b740a2e4b159e4e53227e26330b 1fdbe25f98924abf9d83bbf664cbca4b--34b27b740a2e4b159e4e53227e26330b 5f7a5c6a5c104d67babd1e60a7c0e5c8 34b27b740a2e4b159e4e53227e26330b--5f7a5c6a5c104d67babd1e60a7c0e5c8 6009350936f04837b1675e1c35b93882 5f7a5c6a5c104d67babd1e60a7c0e5c8--6009350936f04837b1675e1c35b93882 7bf8592fff534dc5839e057ebe7b24c6 X 6009350936f04837b1675e1c35b93882--7bf8592fff534dc5839e057ebe7b24c6 7bf8592fff534dc5839e057ebe7b24c6--1fc71910160144e8b292c3c0de373b93 03d72a2601cb460b92ca7b599256cd3d RZ(-1.0*g1) 7bf8592fff534dc5839e057ebe7b24c6--03d72a2601cb460b92ca7b599256cd3d 5581fcc9400e400d987dd8025cdce030 X 03d72a2601cb460b92ca7b599256cd3d--5581fcc9400e400d987dd8025cdce030 5581fcc9400e400d987dd8025cdce030--3355e99cc005453588241d986d21e214 3162638620c840978462d420ac6f3d07 5581fcc9400e400d987dd8025cdce030--3162638620c840978462d420ac6f3d07 10617d7d0ece4cdd84823b1c914dae86 3162638620c840978462d420ac6f3d07--10617d7d0ece4cdd84823b1c914dae86 f15d77e0b5724db59182dd9a3a83e2e7 10617d7d0ece4cdd84823b1c914dae86--f15d77e0b5724db59182dd9a3a83e2e7 feec023f613e4674a54ce59e0e51089f f15d77e0b5724db59182dd9a3a83e2e7--feec023f613e4674a54ce59e0e51089f a2d441818f664072b737c80b81e22399 feec023f613e4674a54ce59e0e51089f--a2d441818f664072b737c80b81e22399 a29c1030a671402fa40d590a941dc94b a2d441818f664072b737c80b81e22399--a29c1030a671402fa40d590a941dc94b c71d06154c4b452196afbb25f18598da X a29c1030a671402fa40d590a941dc94b--c71d06154c4b452196afbb25f18598da c71d06154c4b452196afbb25f18598da--217b617781494d20997c187dfc2714c0 f2b24d18c29443c6bec5f81609a82ef3 c71d06154c4b452196afbb25f18598da--f2b24d18c29443c6bec5f81609a82ef3 c17b8c659f3545c6be2f6d7704c93370 f2b24d18c29443c6bec5f81609a82ef3--c17b8c659f3545c6be2f6d7704c93370 e3333f8c624f44a392c303120b6306b8 c17b8c659f3545c6be2f6d7704c93370--e3333f8c624f44a392c303120b6306b8 9664b107ead7480abf1958f93122e266 e3333f8c624f44a392c303120b6306b8--9664b107ead7480abf1958f93122e266 f45b43688d534322a4b8b3fe8a52faaa 9664b107ead7480abf1958f93122e266--f45b43688d534322a4b8b3fe8a52faaa 69c4280cd9004be8afe9d3f7e9e31276 X f45b43688d534322a4b8b3fe8a52faaa--69c4280cd9004be8afe9d3f7e9e31276 69c4280cd9004be8afe9d3f7e9e31276--a38e6ef0a7d1498c8be63571e92e2872 dd86c40428f2434ca79cb61049adfc1d 69c4280cd9004be8afe9d3f7e9e31276--dd86c40428f2434ca79cb61049adfc1d 8b57f571399342dd8224c1ed82ec7e5b dd86c40428f2434ca79cb61049adfc1d--8b57f571399342dd8224c1ed82ec7e5b 3d38c4b0678e4f8aa73a03a6544d5920 8b57f571399342dd8224c1ed82ec7e5b--3d38c4b0678e4f8aa73a03a6544d5920 b3c4476843fc4a93ad34ff33e080e8c4 3d38c4b0678e4f8aa73a03a6544d5920--b3c4476843fc4a93ad34ff33e080e8c4 fbaa524bb29b4089aa8ee9484507b522 b3c4476843fc4a93ad34ff33e080e8c4--fbaa524bb29b4089aa8ee9484507b522 86728674a0274a2a84dcccb501965875 fbaa524bb29b4089aa8ee9484507b522--86728674a0274a2a84dcccb501965875 2d85c0c0a8d4493b993023ddfbc9e7e0 86728674a0274a2a84dcccb501965875--2d85c0c0a8d4493b993023ddfbc9e7e0 01cf6f836adb449ebb1cf909e54d79e4 2d85c0c0a8d4493b993023ddfbc9e7e0--01cf6f836adb449ebb1cf909e54d79e4 22932cf851584ef69addad73086af922 01cf6f836adb449ebb1cf909e54d79e4--22932cf851584ef69addad73086af922 d4224dc5ec7f4204a698895040d837e2 22932cf851584ef69addad73086af922--d4224dc5ec7f4204a698895040d837e2 c453249903544cf39f8bf7850a94ba64 X d4224dc5ec7f4204a698895040d837e2--c453249903544cf39f8bf7850a94ba64 c453249903544cf39f8bf7850a94ba64--dfd10982bd4449568dc61fa6f46f2d1a dc15e03d466048b796f3f1683eea80ce c453249903544cf39f8bf7850a94ba64--dc15e03d466048b796f3f1683eea80ce be368bf0923f4d03bf00f9726f2a8d11 dc15e03d466048b796f3f1683eea80ce--be368bf0923f4d03bf00f9726f2a8d11 9e46cd6bc93c4854b79fa8e3ea167622 be368bf0923f4d03bf00f9726f2a8d11--9e46cd6bc93c4854b79fa8e3ea167622 5c20ed6461e64316b704ae99d7905da1 X 9e46cd6bc93c4854b79fa8e3ea167622--5c20ed6461e64316b704ae99d7905da1 5c20ed6461e64316b704ae99d7905da1--addee800a903468298411c074e9b537e 758769c4187f4d3e8d24644a90cfa3b7 5c20ed6461e64316b704ae99d7905da1--758769c4187f4d3e8d24644a90cfa3b7 f2512bfc43ce4aa8bc70b0054eec66b7 758769c4187f4d3e8d24644a90cfa3b7--f2512bfc43ce4aa8bc70b0054eec66b7 3d855f400c074f1ebcb1655ea2a1a1cc X f2512bfc43ce4aa8bc70b0054eec66b7--3d855f400c074f1ebcb1655ea2a1a1cc 3d855f400c074f1ebcb1655ea2a1a1cc--bd51e00ca0da40f5bda5c3191d449f6b 5a91c7b3345e40749031b5103f5a30e7 3d855f400c074f1ebcb1655ea2a1a1cc--5a91c7b3345e40749031b5103f5a30e7 d58efe11316f442d92318d89fad20ec6 5a91c7b3345e40749031b5103f5a30e7--d58efe11316f442d92318d89fad20ec6 7cbf41adf6154f1d90fbd55dc65e6328 d58efe11316f442d92318d89fad20ec6--7cbf41adf6154f1d90fbd55dc65e6328 7ca0679e58244015ae4b25b223c8a0fa 7cbf41adf6154f1d90fbd55dc65e6328--7ca0679e58244015ae4b25b223c8a0fa d475a6aba1444947b5bdb33d6cd18f23 7ca0679e58244015ae4b25b223c8a0fa--d475a6aba1444947b5bdb33d6cd18f23 80872b11f96f4319b94cad503796abef X d475a6aba1444947b5bdb33d6cd18f23--80872b11f96f4319b94cad503796abef 80872b11f96f4319b94cad503796abef--0adcb772104242a48fea41a8c18cdcc3 e8278824d70748c99f115a22a0e46795 80872b11f96f4319b94cad503796abef--e8278824d70748c99f115a22a0e46795 8832ab42a39a463291c3a224448ebe8b X e8278824d70748c99f115a22a0e46795--8832ab42a39a463291c3a224448ebe8b 8832ab42a39a463291c3a224448ebe8b--4dbb32c38a434814b2beb547480aebff afea1e86a4764bab96089e73f1f50cf0 RZ(-1.0*g1) 8832ab42a39a463291c3a224448ebe8b--afea1e86a4764bab96089e73f1f50cf0 0f4290076d4b4e78bf8dee7b4f66fa69 X afea1e86a4764bab96089e73f1f50cf0--0f4290076d4b4e78bf8dee7b4f66fa69 0f4290076d4b4e78bf8dee7b4f66fa69--23237033609143f68072fb469beede7f f4f9f18c2fe64b829150a751550967b9 X 0f4290076d4b4e78bf8dee7b4f66fa69--f4f9f18c2fe64b829150a751550967b9 f4f9f18c2fe64b829150a751550967b9--17635983e0f543d580c6b4a8cfe56891 094bf25fd5014e4bbf0b329cee2aaf91 f4f9f18c2fe64b829150a751550967b9--094bf25fd5014e4bbf0b329cee2aaf91 55e95ac41bed499d810e89836e1f9262 094bf25fd5014e4bbf0b329cee2aaf91--55e95ac41bed499d810e89836e1f9262 84ce7bde2d5641e4b752d9e996f8a173 55e95ac41bed499d810e89836e1f9262--84ce7bde2d5641e4b752d9e996f8a173 8c08301a32e24bf0bce4062d4f9f37e8 X 84ce7bde2d5641e4b752d9e996f8a173--8c08301a32e24bf0bce4062d4f9f37e8 8c08301a32e24bf0bce4062d4f9f37e8--c669a980299d4bdfb29cc368b53a847a eb45e495ce154681b33bd220d891b8ed X 8c08301a32e24bf0bce4062d4f9f37e8--eb45e495ce154681b33bd220d891b8ed eb45e495ce154681b33bd220d891b8ed--2c9dd2731a3a42189eb5a461971518e4 766ac34cf89245d3900d0dc17924ad01 eb45e495ce154681b33bd220d891b8ed--766ac34cf89245d3900d0dc17924ad01 bd605424352d4d339dfadf99b96c9954 766ac34cf89245d3900d0dc17924ad01--bd605424352d4d339dfadf99b96c9954 c6fc321199b34c84a7695f3db8761882 bd605424352d4d339dfadf99b96c9954--c6fc321199b34c84a7695f3db8761882 86f3e861d67a44b1b3a8e291928f621a c6fc321199b34c84a7695f3db8761882--86f3e861d67a44b1b3a8e291928f621a dd5b25e5bb7348d8818dbc245648f1b2 86f3e861d67a44b1b3a8e291928f621a--dd5b25e5bb7348d8818dbc245648f1b2 a615b81249314b6fbc0a7b5f9e76d5ab X dd5b25e5bb7348d8818dbc245648f1b2--a615b81249314b6fbc0a7b5f9e76d5ab a615b81249314b6fbc0a7b5f9e76d5ab--4b63e81d3b7f4646802b6ff3f5ebd50b 3a650df688f74cd792b4b22efffe3e56 RX(b15) a615b81249314b6fbc0a7b5f9e76d5ab--3a650df688f74cd792b4b22efffe3e56 3a650df688f74cd792b4b22efffe3e56--1522a065126748f4b129e755ee1622c6 c0eb183827524f31b2f09431beba8def d04deb0c7b9644aabb7fc20e918ce459 e40419ba4d0d4bb1bba9073ad7eac966--d04deb0c7b9644aabb7fc20e918ce459 34ec8df807494a0c839f7a4d02bf125a 7 9e9eb4dd7a6746e9b78614f2b65464db d04deb0c7b9644aabb7fc20e918ce459--9e9eb4dd7a6746e9b78614f2b65464db 62575331c9bb4426a10760b7e77a7fe1 9e9eb4dd7a6746e9b78614f2b65464db--62575331c9bb4426a10760b7e77a7fe1 1c682b17d0844f3f8e9b6b11477ced6d 62575331c9bb4426a10760b7e77a7fe1--1c682b17d0844f3f8e9b6b11477ced6d de298d7e6bd24121966366f44882da92 1c682b17d0844f3f8e9b6b11477ced6d--de298d7e6bd24121966366f44882da92 12bc7a6735744d3ea02f05679829a6e4 X de298d7e6bd24121966366f44882da92--12bc7a6735744d3ea02f05679829a6e4 12bc7a6735744d3ea02f05679829a6e4--9dd60e286b1d4433bab86fa5fb5dd936 ef9e717223f2456193711514e4a28f88 12bc7a6735744d3ea02f05679829a6e4--ef9e717223f2456193711514e4a28f88 b0d7269df54547b0b81c95d8082b2f5f ef9e717223f2456193711514e4a28f88--b0d7269df54547b0b81c95d8082b2f5f 9b448d11015a463aaa8bdd932839b4fe b0d7269df54547b0b81c95d8082b2f5f--9b448d11015a463aaa8bdd932839b4fe 4ee778559c5e40c189ad85396695dc06 X 9b448d11015a463aaa8bdd932839b4fe--4ee778559c5e40c189ad85396695dc06 4ee778559c5e40c189ad85396695dc06--d0eba6b572df4e6993e861f6b3d87214 e3120656e4f74d14a8fe75408da1fa7a 4ee778559c5e40c189ad85396695dc06--e3120656e4f74d14a8fe75408da1fa7a 13f90fe1145e480cb7eb3708b0e1087d e3120656e4f74d14a8fe75408da1fa7a--13f90fe1145e480cb7eb3708b0e1087d 5125ea210abd4245b34ac89e6bc11d12 13f90fe1145e480cb7eb3708b0e1087d--5125ea210abd4245b34ac89e6bc11d12 2d5bd76068b6417f9998b5d7ad15bd1b 5125ea210abd4245b34ac89e6bc11d12--2d5bd76068b6417f9998b5d7ad15bd1b 0a1aae13f80046b7b5d67958dda90675 2d5bd76068b6417f9998b5d7ad15bd1b--0a1aae13f80046b7b5d67958dda90675 1f522574727a4eab9db175b6afb7193c 0a1aae13f80046b7b5d67958dda90675--1f522574727a4eab9db175b6afb7193c 20840e141d5849a4b66af03bc49d6160 1f522574727a4eab9db175b6afb7193c--20840e141d5849a4b66af03bc49d6160 e78588b46506445e871ac3e56fb4656f 20840e141d5849a4b66af03bc49d6160--e78588b46506445e871ac3e56fb4656f 16be8c8ef8e2467798bfd3dbc060e112 e78588b46506445e871ac3e56fb4656f--16be8c8ef8e2467798bfd3dbc060e112 a342f3dddc3c41fda683828136708c57 16be8c8ef8e2467798bfd3dbc060e112--a342f3dddc3c41fda683828136708c57 637fb5d4766547dbb173efe322c8d275 a342f3dddc3c41fda683828136708c57--637fb5d4766547dbb173efe322c8d275 f1225821b0614971803e210cbd1e049b 637fb5d4766547dbb173efe322c8d275--f1225821b0614971803e210cbd1e049b 91e80545bbd84845b0b92aaacfd0f87e f1225821b0614971803e210cbd1e049b--91e80545bbd84845b0b92aaacfd0f87e a1892809bad54df1aed8c8993bd8b384 91e80545bbd84845b0b92aaacfd0f87e--a1892809bad54df1aed8c8993bd8b384 1abbc1abeff94579a6e39b5116cee44e a1892809bad54df1aed8c8993bd8b384--1abbc1abeff94579a6e39b5116cee44e 5f677158f9c244d7aa22bff839161650 1abbc1abeff94579a6e39b5116cee44e--5f677158f9c244d7aa22bff839161650 1da95a96df5a46ddb0bcb29abca25a01 5f677158f9c244d7aa22bff839161650--1da95a96df5a46ddb0bcb29abca25a01 a3395e10b7a44ed4a4de0ffb9a6e34cb 1da95a96df5a46ddb0bcb29abca25a01--a3395e10b7a44ed4a4de0ffb9a6e34cb a82318a9886a467ba8b771f4d757600f a3395e10b7a44ed4a4de0ffb9a6e34cb--a82318a9886a467ba8b771f4d757600f 89f2ba18d56e4ff9b9323436afe1a64f a82318a9886a467ba8b771f4d757600f--89f2ba18d56e4ff9b9323436afe1a64f f0a78e2c0c6d422d995f073e9d4e64ed 89f2ba18d56e4ff9b9323436afe1a64f--f0a78e2c0c6d422d995f073e9d4e64ed a027745b46a943f4b52d7305077fc653 f0a78e2c0c6d422d995f073e9d4e64ed--a027745b46a943f4b52d7305077fc653 77a4b24838974e8aae98897c8fc47d03 a027745b46a943f4b52d7305077fc653--77a4b24838974e8aae98897c8fc47d03 a7b3cb6d5f6245c388ec8322e24bbc53 77a4b24838974e8aae98897c8fc47d03--a7b3cb6d5f6245c388ec8322e24bbc53 eff85d902c0f402eb4c855dc0b678f4e a7b3cb6d5f6245c388ec8322e24bbc53--eff85d902c0f402eb4c855dc0b678f4e 27c4f51268e4402c9ad612f699e153a6 eff85d902c0f402eb4c855dc0b678f4e--27c4f51268e4402c9ad612f699e153a6 36b31e17906e45fba05b4b24b228ae75 27c4f51268e4402c9ad612f699e153a6--36b31e17906e45fba05b4b24b228ae75 4d4e027f8b124de3afbd75e46e794e64 36b31e17906e45fba05b4b24b228ae75--4d4e027f8b124de3afbd75e46e794e64 e309e369089f41029b9184a86ecf7631 4d4e027f8b124de3afbd75e46e794e64--e309e369089f41029b9184a86ecf7631 8c6f87bc2c244959ab23403ff6c074be e309e369089f41029b9184a86ecf7631--8c6f87bc2c244959ab23403ff6c074be add156c5666649b99d45993dc0d43e5a 8c6f87bc2c244959ab23403ff6c074be--add156c5666649b99d45993dc0d43e5a 70639ec26a1441198d213f8714cf9e41 add156c5666649b99d45993dc0d43e5a--70639ec26a1441198d213f8714cf9e41 647ed7e6d88a44a5815090b097c099a7 70639ec26a1441198d213f8714cf9e41--647ed7e6d88a44a5815090b097c099a7 c0b7c9d682f640a2ba90d594b8c8e822 X 647ed7e6d88a44a5815090b097c099a7--c0b7c9d682f640a2ba90d594b8c8e822 c0b7c9d682f640a2ba90d594b8c8e822--331d849ee06441caa9d482e1ecb514a7 ec66d8ac807c4d46995c57e7e227b13c c0b7c9d682f640a2ba90d594b8c8e822--ec66d8ac807c4d46995c57e7e227b13c 9b2fbb528ce24db588085a7abd8f5dec ec66d8ac807c4d46995c57e7e227b13c--9b2fbb528ce24db588085a7abd8f5dec 0794c4c3ba294a859ea6a5a2c3affe7a 9b2fbb528ce24db588085a7abd8f5dec--0794c4c3ba294a859ea6a5a2c3affe7a d0e9ecadb60f438387b6e15f4ab61c36 X 0794c4c3ba294a859ea6a5a2c3affe7a--d0e9ecadb60f438387b6e15f4ab61c36 d0e9ecadb60f438387b6e15f4ab61c36--69118cf3d5a84065bdfa0ef268c810b0 0bf74e7da2604d9e8b3abd3e922b247c d0e9ecadb60f438387b6e15f4ab61c36--0bf74e7da2604d9e8b3abd3e922b247c ab145cfcea374495a1560c3ac10a9cab 0bf74e7da2604d9e8b3abd3e922b247c--ab145cfcea374495a1560c3ac10a9cab 69197107e65f47078ab8542baec19ea5 ab145cfcea374495a1560c3ac10a9cab--69197107e65f47078ab8542baec19ea5 e299a8329fd147a099757150d01348f1 69197107e65f47078ab8542baec19ea5--e299a8329fd147a099757150d01348f1 372c5296f6374a3aa49ab108ddd7538e e299a8329fd147a099757150d01348f1--372c5296f6374a3aa49ab108ddd7538e f698d06b44a64c638484c266c0f4f79e 372c5296f6374a3aa49ab108ddd7538e--f698d06b44a64c638484c266c0f4f79e 4d9f6777ac6042db9948b17f583036cd f698d06b44a64c638484c266c0f4f79e--4d9f6777ac6042db9948b17f583036cd e778f8c4cbfc4be5999bc6a890b3a9d5 4d9f6777ac6042db9948b17f583036cd--e778f8c4cbfc4be5999bc6a890b3a9d5 bcc7d4cb520b4491ae5515279c12baef e778f8c4cbfc4be5999bc6a890b3a9d5--bcc7d4cb520b4491ae5515279c12baef d3959338e3b84574b2785f6dea5699bd bcc7d4cb520b4491ae5515279c12baef--d3959338e3b84574b2785f6dea5699bd 4f27dd2e7fdf493bac3cf915028c18e3 d3959338e3b84574b2785f6dea5699bd--4f27dd2e7fdf493bac3cf915028c18e3 bd669eddf535441d84fc508e2f44d617 4f27dd2e7fdf493bac3cf915028c18e3--bd669eddf535441d84fc508e2f44d617 b1cb1185e10743839b2857f6cc48989c bd669eddf535441d84fc508e2f44d617--b1cb1185e10743839b2857f6cc48989c e03755e84ed44f8187b63de271406971 b1cb1185e10743839b2857f6cc48989c--e03755e84ed44f8187b63de271406971 b821ff20d78b488b82a1c7263e008ac7 e03755e84ed44f8187b63de271406971--b821ff20d78b488b82a1c7263e008ac7 7c125c612cfb4cb2bb284de6c1e890dd b821ff20d78b488b82a1c7263e008ac7--7c125c612cfb4cb2bb284de6c1e890dd 0f2d01db12f947de864fddd33d085669 7c125c612cfb4cb2bb284de6c1e890dd--0f2d01db12f947de864fddd33d085669 755aac68aa2741f68a05b4fca61e76db 0f2d01db12f947de864fddd33d085669--755aac68aa2741f68a05b4fca61e76db fdfcd0c7c0ad4267b4a7697de53e071f 755aac68aa2741f68a05b4fca61e76db--fdfcd0c7c0ad4267b4a7697de53e071f d3b64b0423454cea9017f5bb0fd5a14c fdfcd0c7c0ad4267b4a7697de53e071f--d3b64b0423454cea9017f5bb0fd5a14c d81e71ca150c4b85b43416004e1ef3fc d3b64b0423454cea9017f5bb0fd5a14c--d81e71ca150c4b85b43416004e1ef3fc 942d649c12054345ad3653c38cdd9d76 d81e71ca150c4b85b43416004e1ef3fc--942d649c12054345ad3653c38cdd9d76 85c14af087824042853463963b543bb2 942d649c12054345ad3653c38cdd9d76--85c14af087824042853463963b543bb2 a40aea855a674183aaf3479728f0f3a4 85c14af087824042853463963b543bb2--a40aea855a674183aaf3479728f0f3a4 75332d77bb904272b2f8ca48135cc998 a40aea855a674183aaf3479728f0f3a4--75332d77bb904272b2f8ca48135cc998 a4444146769f4aea951660e306a4ea88 75332d77bb904272b2f8ca48135cc998--a4444146769f4aea951660e306a4ea88 f3127d95c3be4ddca3e667616f68143d X a4444146769f4aea951660e306a4ea88--f3127d95c3be4ddca3e667616f68143d f3127d95c3be4ddca3e667616f68143d--ee378f59ebfd40deba0556693e295bf6 0f45ed51e72548ce80d83acd2712f695 f3127d95c3be4ddca3e667616f68143d--0f45ed51e72548ce80d83acd2712f695 95c87c3e3ca64261bd985f207783c60f 0f45ed51e72548ce80d83acd2712f695--95c87c3e3ca64261bd985f207783c60f 3aab0641d6c14a00bcd8ceddc402f85d 95c87c3e3ca64261bd985f207783c60f--3aab0641d6c14a00bcd8ceddc402f85d 9b0883c8b3d845648522b5a4467c1f15 X 3aab0641d6c14a00bcd8ceddc402f85d--9b0883c8b3d845648522b5a4467c1f15 9b0883c8b3d845648522b5a4467c1f15--15074c66e42347639d54a9ed9e6ffa7b fdcf0aa2993e4d75a88f2a9ecbe14bff 9b0883c8b3d845648522b5a4467c1f15--fdcf0aa2993e4d75a88f2a9ecbe14bff 35d48128378b4cffba226ea3f9a6f38f fdcf0aa2993e4d75a88f2a9ecbe14bff--35d48128378b4cffba226ea3f9a6f38f 93e95ac44ca7416d820a1105c78c9b64 35d48128378b4cffba226ea3f9a6f38f--93e95ac44ca7416d820a1105c78c9b64 a610eb12c2cd4905887983ef40ab345a 93e95ac44ca7416d820a1105c78c9b64--a610eb12c2cd4905887983ef40ab345a 56615911c2c348ebb12a38c570c01d80 a610eb12c2cd4905887983ef40ab345a--56615911c2c348ebb12a38c570c01d80 7da7fb28b7c44f7b9e7510d37b6b1d82 56615911c2c348ebb12a38c570c01d80--7da7fb28b7c44f7b9e7510d37b6b1d82 2b3e6afc075743c48a5cfe357ebdcef6 7da7fb28b7c44f7b9e7510d37b6b1d82--2b3e6afc075743c48a5cfe357ebdcef6 d6135917e8034334be38e0209fff5226 2b3e6afc075743c48a5cfe357ebdcef6--d6135917e8034334be38e0209fff5226 3d7f4ee937f849278ce3758d7ae4baf5 d6135917e8034334be38e0209fff5226--3d7f4ee937f849278ce3758d7ae4baf5 559c7ed0a0ab4d4187a9ca3d4e9dfa1e 3d7f4ee937f849278ce3758d7ae4baf5--559c7ed0a0ab4d4187a9ca3d4e9dfa1e 7374a9f13152492399a1ea6188f0307e 559c7ed0a0ab4d4187a9ca3d4e9dfa1e--7374a9f13152492399a1ea6188f0307e fc43e7b25c924d8b80438f7046d29cb0 7374a9f13152492399a1ea6188f0307e--fc43e7b25c924d8b80438f7046d29cb0 3ce2549712c8420e903ba5efeba012e6 X fc43e7b25c924d8b80438f7046d29cb0--3ce2549712c8420e903ba5efeba012e6 3ce2549712c8420e903ba5efeba012e6--1ea48e2acb9b4bfabf04aabb32a47a53 3b578db01cc4437d8af5fa3035d78736 RZ(-1.0*g0) 3ce2549712c8420e903ba5efeba012e6--3b578db01cc4437d8af5fa3035d78736 f3a0a82d717843c29274fb64943f6d7e X 3b578db01cc4437d8af5fa3035d78736--f3a0a82d717843c29274fb64943f6d7e f3a0a82d717843c29274fb64943f6d7e--88ffa9da434a41cbaf8ddcc554223731 2104ca59662a4ee5932d14283e1ef49f f3a0a82d717843c29274fb64943f6d7e--2104ca59662a4ee5932d14283e1ef49f 10727f1a1d194d259dda92757d4e43b3 2104ca59662a4ee5932d14283e1ef49f--10727f1a1d194d259dda92757d4e43b3 37e259ed95c64acf860e62de342052f8 10727f1a1d194d259dda92757d4e43b3--37e259ed95c64acf860e62de342052f8 0618923032d34f699f089a44f337ca6a 37e259ed95c64acf860e62de342052f8--0618923032d34f699f089a44f337ca6a 0bb8c6eac7364cfc9a78fd16b67676d3 X 0618923032d34f699f089a44f337ca6a--0bb8c6eac7364cfc9a78fd16b67676d3 0bb8c6eac7364cfc9a78fd16b67676d3--2247f897697d458ba4898f80ce80151b faf87e8cb5f74625af15887d10be6f43 0bb8c6eac7364cfc9a78fd16b67676d3--faf87e8cb5f74625af15887d10be6f43 b7695b30a9ad4a6bba49b26c20109b76 faf87e8cb5f74625af15887d10be6f43--b7695b30a9ad4a6bba49b26c20109b76 58c2eaa17fbb4c23ab311dedd849d1ce b7695b30a9ad4a6bba49b26c20109b76--58c2eaa17fbb4c23ab311dedd849d1ce 9568d5be317f48238b1f6beb6a82b0f8 X 58c2eaa17fbb4c23ab311dedd849d1ce--9568d5be317f48238b1f6beb6a82b0f8 9568d5be317f48238b1f6beb6a82b0f8--b6ff61ba136c4a00bb31e90e8ae59831 632fe19832a04f7b80bf7670f33d81d6 9568d5be317f48238b1f6beb6a82b0f8--632fe19832a04f7b80bf7670f33d81d6 eb9c1eff12ee42a6a0806218f6ca9436 632fe19832a04f7b80bf7670f33d81d6--eb9c1eff12ee42a6a0806218f6ca9436 867198340656482993d0d551c3822e8c eb9c1eff12ee42a6a0806218f6ca9436--867198340656482993d0d551c3822e8c dc35a1216be94edf998180a1f8f4b382 867198340656482993d0d551c3822e8c--dc35a1216be94edf998180a1f8f4b382 527b55b2419a47cea7311db017c44eff dc35a1216be94edf998180a1f8f4b382--527b55b2419a47cea7311db017c44eff df672193bdec478d842442a6930d887b 527b55b2419a47cea7311db017c44eff--df672193bdec478d842442a6930d887b a9ebfda748d14659afdb49420536d00b X df672193bdec478d842442a6930d887b--a9ebfda748d14659afdb49420536d00b a9ebfda748d14659afdb49420536d00b--83918d3b921d4612bb2431163a200f48 0061ec863ba04e1f80646828025e4951 RZ(-1.0*g0) a9ebfda748d14659afdb49420536d00b--0061ec863ba04e1f80646828025e4951 384d3467a4434ac7b4f96907bbbf5d40 X 0061ec863ba04e1f80646828025e4951--384d3467a4434ac7b4f96907bbbf5d40 384d3467a4434ac7b4f96907bbbf5d40--9125831762ce4dc28bae455efe9b5a6b e1de4b2f92144294bf356db653f7313e 384d3467a4434ac7b4f96907bbbf5d40--e1de4b2f92144294bf356db653f7313e 8edfb0aec84c474bb986a794c7ba6e1d e1de4b2f92144294bf356db653f7313e--8edfb0aec84c474bb986a794c7ba6e1d 04b28fe724294e7884b8c7930d06795f X 8edfb0aec84c474bb986a794c7ba6e1d--04b28fe724294e7884b8c7930d06795f 04b28fe724294e7884b8c7930d06795f--9970f988fb1340429fce1ac852ba1a0b df41c8713b2b4202bdba28a3446ce64b 04b28fe724294e7884b8c7930d06795f--df41c8713b2b4202bdba28a3446ce64b b2f5b41c5be34b1d822a8f0aac3281cc df41c8713b2b4202bdba28a3446ce64b--b2f5b41c5be34b1d822a8f0aac3281cc 86165a1ea2f64a5dbc704218ec670fc6 b2f5b41c5be34b1d822a8f0aac3281cc--86165a1ea2f64a5dbc704218ec670fc6 d0f4c35cd55444999aa442bda72ce7d6 X 86165a1ea2f64a5dbc704218ec670fc6--d0f4c35cd55444999aa442bda72ce7d6 d0f4c35cd55444999aa442bda72ce7d6--dc48679ce1b546f094b46f8e49cfe4d6 43046b80836e4583b799abc2e7733a53 d0f4c35cd55444999aa442bda72ce7d6--43046b80836e4583b799abc2e7733a53 cff3c2d3158646f49065768d2f5aab54 RX(b06) 43046b80836e4583b799abc2e7733a53--cff3c2d3158646f49065768d2f5aab54 e2d0ab0d6f3548d0bf24578405095d3b cff3c2d3158646f49065768d2f5aab54--e2d0ab0d6f3548d0bf24578405095d3b eeb5a1e2b60f4f8292b5b23a4745747b e2d0ab0d6f3548d0bf24578405095d3b--eeb5a1e2b60f4f8292b5b23a4745747b b1ef269a6d064804880904c671005101 eeb5a1e2b60f4f8292b5b23a4745747b--b1ef269a6d064804880904c671005101 447d23bae085421c88fd14bedac83113 b1ef269a6d064804880904c671005101--447d23bae085421c88fd14bedac83113 85a28739d5aa474c9db8326a9dd06e4f 447d23bae085421c88fd14bedac83113--85a28739d5aa474c9db8326a9dd06e4f df103b83286144118f16374d44c0470c X 85a28739d5aa474c9db8326a9dd06e4f--df103b83286144118f16374d44c0470c df103b83286144118f16374d44c0470c--36f99ea9646140ab8a9867eb14d3dbe6 d5e2ac7380b148f2b1144fdf371e9eff df103b83286144118f16374d44c0470c--d5e2ac7380b148f2b1144fdf371e9eff eb633e516bd44ee59276dcd3d045510e d5e2ac7380b148f2b1144fdf371e9eff--eb633e516bd44ee59276dcd3d045510e c900541b76814901aa54e1ef7dc2372b eb633e516bd44ee59276dcd3d045510e--c900541b76814901aa54e1ef7dc2372b a8d7a26d2581448b9e5b33a6f9b3e521 X c900541b76814901aa54e1ef7dc2372b--a8d7a26d2581448b9e5b33a6f9b3e521 a8d7a26d2581448b9e5b33a6f9b3e521--582e5b3ff6bf4fbdba667366cd402430 bd0ce562f57c4f028af26e8c3fdc4c58 a8d7a26d2581448b9e5b33a6f9b3e521--bd0ce562f57c4f028af26e8c3fdc4c58 22b78879f83943498887ddc5e146d137 bd0ce562f57c4f028af26e8c3fdc4c58--22b78879f83943498887ddc5e146d137 f7344d8ca3a04f4a9595c8089de22400 22b78879f83943498887ddc5e146d137--f7344d8ca3a04f4a9595c8089de22400 2794e087ec584df7936441f8d0c2a1d6 f7344d8ca3a04f4a9595c8089de22400--2794e087ec584df7936441f8d0c2a1d6 f9d587f432ae45398d5a4fcf2887b5c6 2794e087ec584df7936441f8d0c2a1d6--f9d587f432ae45398d5a4fcf2887b5c6 6587cb28aa0f43bc9f1d5f7ff19be8b5 f9d587f432ae45398d5a4fcf2887b5c6--6587cb28aa0f43bc9f1d5f7ff19be8b5 0731e5e99d2243689c67a50348e54452 6587cb28aa0f43bc9f1d5f7ff19be8b5--0731e5e99d2243689c67a50348e54452 30e4878ac7d741b1bf40e53c452f327a 0731e5e99d2243689c67a50348e54452--30e4878ac7d741b1bf40e53c452f327a 4f5d639047114e7eb173ee44a95bfb5b 30e4878ac7d741b1bf40e53c452f327a--4f5d639047114e7eb173ee44a95bfb5b 5c160bb8211f4f3caec38121bf6b716f 4f5d639047114e7eb173ee44a95bfb5b--5c160bb8211f4f3caec38121bf6b716f 05f8699ccbbc475aaa9c867d665abe72 5c160bb8211f4f3caec38121bf6b716f--05f8699ccbbc475aaa9c867d665abe72 31b8e47eca154ce0b883faec1b8815cb 05f8699ccbbc475aaa9c867d665abe72--31b8e47eca154ce0b883faec1b8815cb a6f59627bcd74f1689507ea43da4dca9 31b8e47eca154ce0b883faec1b8815cb--a6f59627bcd74f1689507ea43da4dca9 4670d25cfad9401ba426ccb34e464506 a6f59627bcd74f1689507ea43da4dca9--4670d25cfad9401ba426ccb34e464506 8e88eaf3c1aa47ab8251e48f0e69d763 4670d25cfad9401ba426ccb34e464506--8e88eaf3c1aa47ab8251e48f0e69d763 fff6ae34a2b94f5ba198dbf16f82ed5b 8e88eaf3c1aa47ab8251e48f0e69d763--fff6ae34a2b94f5ba198dbf16f82ed5b 9d8ad2b48abc49af83aa65ee98307ee5 fff6ae34a2b94f5ba198dbf16f82ed5b--9d8ad2b48abc49af83aa65ee98307ee5 07d7d4201a0341cdb6ed23c056a84c92 9d8ad2b48abc49af83aa65ee98307ee5--07d7d4201a0341cdb6ed23c056a84c92 106910aec20943bb8eb16b2277520925 07d7d4201a0341cdb6ed23c056a84c92--106910aec20943bb8eb16b2277520925 22464090a9b646d79fcd2184ef58a4b4 106910aec20943bb8eb16b2277520925--22464090a9b646d79fcd2184ef58a4b4 840b416716ec48ac943d268aba89775a 22464090a9b646d79fcd2184ef58a4b4--840b416716ec48ac943d268aba89775a ce176777d0a84c16a17a237ef75341c4 840b416716ec48ac943d268aba89775a--ce176777d0a84c16a17a237ef75341c4 ec65051a331146c091916bbe5062fbc6 ce176777d0a84c16a17a237ef75341c4--ec65051a331146c091916bbe5062fbc6 99ee7efcc32f4341a998c25823ad026d ec65051a331146c091916bbe5062fbc6--99ee7efcc32f4341a998c25823ad026d 05073e154fcb48d99f415f5625300cb0 99ee7efcc32f4341a998c25823ad026d--05073e154fcb48d99f415f5625300cb0 07fe01d7f781491287de299da150b738 05073e154fcb48d99f415f5625300cb0--07fe01d7f781491287de299da150b738 89fd1ba1f02a41e0925867d8ba5bd26d 07fe01d7f781491287de299da150b738--89fd1ba1f02a41e0925867d8ba5bd26d baeddcd0dfc144849f4d7b95c2f0b72c 89fd1ba1f02a41e0925867d8ba5bd26d--baeddcd0dfc144849f4d7b95c2f0b72c 117b0b043d8e4804976c40c3081bec13 baeddcd0dfc144849f4d7b95c2f0b72c--117b0b043d8e4804976c40c3081bec13 68ebef1dab11485b92676aa9a864f926 117b0b043d8e4804976c40c3081bec13--68ebef1dab11485b92676aa9a864f926 83e72abf5390460b9d68abf3d664fc6c 68ebef1dab11485b92676aa9a864f926--83e72abf5390460b9d68abf3d664fc6c 0deedcd4a48a4650894b3d1c22818d78 83e72abf5390460b9d68abf3d664fc6c--0deedcd4a48a4650894b3d1c22818d78 a2695c3ba4304f908f1ac05f0ebfa2ea 0deedcd4a48a4650894b3d1c22818d78--a2695c3ba4304f908f1ac05f0ebfa2ea a50f9db9aa53475c8dcc12aa3a9b3541 X a2695c3ba4304f908f1ac05f0ebfa2ea--a50f9db9aa53475c8dcc12aa3a9b3541 a50f9db9aa53475c8dcc12aa3a9b3541--88fd82c3b2774405afda04ccdc30fb00 3ef6006c895b43f28034a0180862a667 a50f9db9aa53475c8dcc12aa3a9b3541--3ef6006c895b43f28034a0180862a667 adbe6180acbe42e389add41c8654f1ea 3ef6006c895b43f28034a0180862a667--adbe6180acbe42e389add41c8654f1ea e3d9b7b7adf449a5ba10a303cbdd7315 adbe6180acbe42e389add41c8654f1ea--e3d9b7b7adf449a5ba10a303cbdd7315 73e59611545b4cee8777c9ce2c8a4da4 X e3d9b7b7adf449a5ba10a303cbdd7315--73e59611545b4cee8777c9ce2c8a4da4 73e59611545b4cee8777c9ce2c8a4da4--f5bb49165eac45a081c33c8a40279b8b 92d3526061a944bda601124c9a00a794 73e59611545b4cee8777c9ce2c8a4da4--92d3526061a944bda601124c9a00a794 adcbe3b37f3d4ed9a64bf926607e0a25 92d3526061a944bda601124c9a00a794--adcbe3b37f3d4ed9a64bf926607e0a25 9f24f16ea916414e8a34c024a3fec3d8 adcbe3b37f3d4ed9a64bf926607e0a25--9f24f16ea916414e8a34c024a3fec3d8 9c3ca31a2e444d11ac5167242365cf03 9f24f16ea916414e8a34c024a3fec3d8--9c3ca31a2e444d11ac5167242365cf03 d2466fe2d4f541ba876b7270322a9d6c 9c3ca31a2e444d11ac5167242365cf03--d2466fe2d4f541ba876b7270322a9d6c 625746082155492696bcc0613460f8dd d2466fe2d4f541ba876b7270322a9d6c--625746082155492696bcc0613460f8dd 043cb61d262449a5a12e7b0917fcdc90 625746082155492696bcc0613460f8dd--043cb61d262449a5a12e7b0917fcdc90 7c182de582b04c8db8eb24ed30473308 043cb61d262449a5a12e7b0917fcdc90--7c182de582b04c8db8eb24ed30473308 9744e07d12cb4112bbaf63e6e7e953be 7c182de582b04c8db8eb24ed30473308--9744e07d12cb4112bbaf63e6e7e953be c6d8a3c93f2a43f9b0357d67bc2e65a2 9744e07d12cb4112bbaf63e6e7e953be--c6d8a3c93f2a43f9b0357d67bc2e65a2 a2db01f4febd47abbfe6c519fb2100fd c6d8a3c93f2a43f9b0357d67bc2e65a2--a2db01f4febd47abbfe6c519fb2100fd d5f83f9defdc428c921ee09b767400fa a2db01f4febd47abbfe6c519fb2100fd--d5f83f9defdc428c921ee09b767400fa 764d8f0a0b3048f191015468402e7e8d d5f83f9defdc428c921ee09b767400fa--764d8f0a0b3048f191015468402e7e8d c5109904a9ae4140ab2ed47e02c48896 764d8f0a0b3048f191015468402e7e8d--c5109904a9ae4140ab2ed47e02c48896 58e4c079b7c34e8f8d0c94c85f71dbee c5109904a9ae4140ab2ed47e02c48896--58e4c079b7c34e8f8d0c94c85f71dbee 07682622264749deb7ceb18c56ffa927 58e4c079b7c34e8f8d0c94c85f71dbee--07682622264749deb7ceb18c56ffa927 8a115a94f89841fba57ed2d529c4016e 07682622264749deb7ceb18c56ffa927--8a115a94f89841fba57ed2d529c4016e dc00d668dee047ba81767c4c26d3be5b 8a115a94f89841fba57ed2d529c4016e--dc00d668dee047ba81767c4c26d3be5b ab7ca4ce11b041fca6dd9912880e6999 dc00d668dee047ba81767c4c26d3be5b--ab7ca4ce11b041fca6dd9912880e6999 e071eb114822475a9c0992d6d461789a ab7ca4ce11b041fca6dd9912880e6999--e071eb114822475a9c0992d6d461789a 1d2e441922484769b7454bd9ff2b7ddb e071eb114822475a9c0992d6d461789a--1d2e441922484769b7454bd9ff2b7ddb f4359408efca494c8d71679e479af029 1d2e441922484769b7454bd9ff2b7ddb--f4359408efca494c8d71679e479af029 4a516562ce27445484f4bf61ed5e7205 f4359408efca494c8d71679e479af029--4a516562ce27445484f4bf61ed5e7205 e8eac622f00e4e0187d03e86228991bc 4a516562ce27445484f4bf61ed5e7205--e8eac622f00e4e0187d03e86228991bc e4eead36dcda49b4ac9e2a794ef9eb35 e8eac622f00e4e0187d03e86228991bc--e4eead36dcda49b4ac9e2a794ef9eb35 9ffc2adbe9994347b43fcda21b3ff4c0 e4eead36dcda49b4ac9e2a794ef9eb35--9ffc2adbe9994347b43fcda21b3ff4c0 58a6aeeb02794aa290e043c8af199194 X 9ffc2adbe9994347b43fcda21b3ff4c0--58a6aeeb02794aa290e043c8af199194 58a6aeeb02794aa290e043c8af199194--f2b24d18c29443c6bec5f81609a82ef3 d491f63bed5a4177aeee6e93023e78a8 58a6aeeb02794aa290e043c8af199194--d491f63bed5a4177aeee6e93023e78a8 13dd018f56894412b07cccd83ca7524f d491f63bed5a4177aeee6e93023e78a8--13dd018f56894412b07cccd83ca7524f 25a89dacb944464a904b31b4f21b084f 13dd018f56894412b07cccd83ca7524f--25a89dacb944464a904b31b4f21b084f 4e0d2551d8d5486bb6a4d16f8c60fb05 X 25a89dacb944464a904b31b4f21b084f--4e0d2551d8d5486bb6a4d16f8c60fb05 4e0d2551d8d5486bb6a4d16f8c60fb05--f45b43688d534322a4b8b3fe8a52faaa da59e9de8af24cc6856176c7fbb2ed70 4e0d2551d8d5486bb6a4d16f8c60fb05--da59e9de8af24cc6856176c7fbb2ed70 580407244f9a4a779719ec29f7d5acc8 da59e9de8af24cc6856176c7fbb2ed70--580407244f9a4a779719ec29f7d5acc8 f8ec5a9ad9e448548eb4f531cc3b503a 580407244f9a4a779719ec29f7d5acc8--f8ec5a9ad9e448548eb4f531cc3b503a 1ab0387659c149d9aacb9a2412f8047e f8ec5a9ad9e448548eb4f531cc3b503a--1ab0387659c149d9aacb9a2412f8047e e5b26d0b421a4c9db4db1c3a42da71e5 1ab0387659c149d9aacb9a2412f8047e--e5b26d0b421a4c9db4db1c3a42da71e5 aa76588c9af14d8980b582e016449848 e5b26d0b421a4c9db4db1c3a42da71e5--aa76588c9af14d8980b582e016449848 967894fd51dc45ffa8946c007e0ad242 aa76588c9af14d8980b582e016449848--967894fd51dc45ffa8946c007e0ad242 1e525b4794ce49b0a16e411a9277a903 967894fd51dc45ffa8946c007e0ad242--1e525b4794ce49b0a16e411a9277a903 0cbc0dfd012545368dcb724a4a55b115 1e525b4794ce49b0a16e411a9277a903--0cbc0dfd012545368dcb724a4a55b115 7d4f07deafc5470cbec6801dc1c46812 0cbc0dfd012545368dcb724a4a55b115--7d4f07deafc5470cbec6801dc1c46812 01bec4acade84ea8b21aaf7352a4fe35 7d4f07deafc5470cbec6801dc1c46812--01bec4acade84ea8b21aaf7352a4fe35 841dfae23bd04555bc9e8d39b7ca3704 01bec4acade84ea8b21aaf7352a4fe35--841dfae23bd04555bc9e8d39b7ca3704 976d9241cfae4ffd8f593be41cdaca75 X 841dfae23bd04555bc9e8d39b7ca3704--976d9241cfae4ffd8f593be41cdaca75 976d9241cfae4ffd8f593be41cdaca75--dc15e03d466048b796f3f1683eea80ce 4e8e5b7614684695a33418441dcb7a16 RZ(-1.0*g1) 976d9241cfae4ffd8f593be41cdaca75--4e8e5b7614684695a33418441dcb7a16 8d0f849cf31d4ef9a1a8509505fe4949 X 4e8e5b7614684695a33418441dcb7a16--8d0f849cf31d4ef9a1a8509505fe4949 8d0f849cf31d4ef9a1a8509505fe4949--9e46cd6bc93c4854b79fa8e3ea167622 4cc9d21974094654b675ebf316b9f922 8d0f849cf31d4ef9a1a8509505fe4949--4cc9d21974094654b675ebf316b9f922 20ed93a01f164752a6d0856b73ec6c26 4cc9d21974094654b675ebf316b9f922--20ed93a01f164752a6d0856b73ec6c26 74cf1518642a4ce496b121557b1bf8c4 20ed93a01f164752a6d0856b73ec6c26--74cf1518642a4ce496b121557b1bf8c4 6ceae0b76f2d46e59ece08d79b33a218 74cf1518642a4ce496b121557b1bf8c4--6ceae0b76f2d46e59ece08d79b33a218 d56c2284a7904b8ca49f938b1ef220a2 X 6ceae0b76f2d46e59ece08d79b33a218--d56c2284a7904b8ca49f938b1ef220a2 d56c2284a7904b8ca49f938b1ef220a2--5a91c7b3345e40749031b5103f5a30e7 024fa8a0553e4987b96bacf715d9cc53 d56c2284a7904b8ca49f938b1ef220a2--024fa8a0553e4987b96bacf715d9cc53 4e5f529aeaa94dea99319edee91ace1c 024fa8a0553e4987b96bacf715d9cc53--4e5f529aeaa94dea99319edee91ace1c a1ea1b42a8664666bd6de7594c9ce376 4e5f529aeaa94dea99319edee91ace1c--a1ea1b42a8664666bd6de7594c9ce376 d2e902a5c9904f2eae2517cfcc6a9c52 X a1ea1b42a8664666bd6de7594c9ce376--d2e902a5c9904f2eae2517cfcc6a9c52 d2e902a5c9904f2eae2517cfcc6a9c52--d475a6aba1444947b5bdb33d6cd18f23 13ecc7316caa44a5b092838df2ae5d8e d2e902a5c9904f2eae2517cfcc6a9c52--13ecc7316caa44a5b092838df2ae5d8e 722a8b43a49440ac927ef347001171c3 13ecc7316caa44a5b092838df2ae5d8e--722a8b43a49440ac927ef347001171c3 7035fca9e6eb44d3b2d11609f8fc8624 722a8b43a49440ac927ef347001171c3--7035fca9e6eb44d3b2d11609f8fc8624 ad185706990042dbbf77ccdb191cda5a 7035fca9e6eb44d3b2d11609f8fc8624--ad185706990042dbbf77ccdb191cda5a 5f03fe62eb13423b95929b07ad34db9d ad185706990042dbbf77ccdb191cda5a--5f03fe62eb13423b95929b07ad34db9d fa0b9824d9c2418a923ca325907088f9 5f03fe62eb13423b95929b07ad34db9d--fa0b9824d9c2418a923ca325907088f9 ca3eee2aaefe4dd0a579bb0bc2ffef34 X fa0b9824d9c2418a923ca325907088f9--ca3eee2aaefe4dd0a579bb0bc2ffef34 ca3eee2aaefe4dd0a579bb0bc2ffef34--094bf25fd5014e4bbf0b329cee2aaf91 efd26574a7644d7281e7d9cdb4aad250 RZ(-1.0*g1) ca3eee2aaefe4dd0a579bb0bc2ffef34--efd26574a7644d7281e7d9cdb4aad250 e5142a90dfba4367a846af59394db819 X efd26574a7644d7281e7d9cdb4aad250--e5142a90dfba4367a846af59394db819 e5142a90dfba4367a846af59394db819--84ce7bde2d5641e4b752d9e996f8a173 2f10c0e4116749ee9e89907336d7597f e5142a90dfba4367a846af59394db819--2f10c0e4116749ee9e89907336d7597f 14e22533917c4f10b5e0bd06543b5599 2f10c0e4116749ee9e89907336d7597f--14e22533917c4f10b5e0bd06543b5599 0cd78632a5b041d8804f3ffee5607d05 X 14e22533917c4f10b5e0bd06543b5599--0cd78632a5b041d8804f3ffee5607d05 0cd78632a5b041d8804f3ffee5607d05--766ac34cf89245d3900d0dc17924ad01 ccd80c33eea94d659d466d12449adaed 0cd78632a5b041d8804f3ffee5607d05--ccd80c33eea94d659d466d12449adaed 147df7006ef448dda3a3744e6e255d7b ccd80c33eea94d659d466d12449adaed--147df7006ef448dda3a3744e6e255d7b 2a6b24179c844f8692c1d72b9a0e4cd2 147df7006ef448dda3a3744e6e255d7b--2a6b24179c844f8692c1d72b9a0e4cd2 3f0d5ba206f54f45b67fcb92dc87c78a X 2a6b24179c844f8692c1d72b9a0e4cd2--3f0d5ba206f54f45b67fcb92dc87c78a 3f0d5ba206f54f45b67fcb92dc87c78a--dd5b25e5bb7348d8818dbc245648f1b2 3a2fc578665643c2bcbff47677cba3f7 3f0d5ba206f54f45b67fcb92dc87c78a--3a2fc578665643c2bcbff47677cba3f7 03a458a862ab444b9425b3563df4080d RX(b16) 3a2fc578665643c2bcbff47677cba3f7--03a458a862ab444b9425b3563df4080d 03a458a862ab444b9425b3563df4080d--c0eb183827524f31b2f09431beba8def 0ec236b6f33943c6b099628cee343a78 d4623b9b85b34ac5afde3e55455b647a 34ec8df807494a0c839f7a4d02bf125a--d4623b9b85b34ac5afde3e55455b647a de72f2e3134c435e8ddefce6c1feab28 d4623b9b85b34ac5afde3e55455b647a--de72f2e3134c435e8ddefce6c1feab28 06ae239a2857487e8020d4cf03f7f8d1 de72f2e3134c435e8ddefce6c1feab28--06ae239a2857487e8020d4cf03f7f8d1 a37cd545b00743d4b7e4b67cb329dfe3 06ae239a2857487e8020d4cf03f7f8d1--a37cd545b00743d4b7e4b67cb329dfe3 54bfac10ae474803a798782c5d05e55d a37cd545b00743d4b7e4b67cb329dfe3--54bfac10ae474803a798782c5d05e55d 2b23c292455f4f7ab7d9bd5601f539bb 54bfac10ae474803a798782c5d05e55d--2b23c292455f4f7ab7d9bd5601f539bb 12001b5818c84790aec6c833a824ab01 X 2b23c292455f4f7ab7d9bd5601f539bb--12001b5818c84790aec6c833a824ab01 12001b5818c84790aec6c833a824ab01--ef9e717223f2456193711514e4a28f88 0643a4e024e64449b55ea4171bd286a5 RZ(1.0*g0) 12001b5818c84790aec6c833a824ab01--0643a4e024e64449b55ea4171bd286a5 855945cd2a744387a5f7d84c354bf90c X 0643a4e024e64449b55ea4171bd286a5--855945cd2a744387a5f7d84c354bf90c 855945cd2a744387a5f7d84c354bf90c--9b448d11015a463aaa8bdd932839b4fe f8c2e75295ec4d8ea41d70a9b5aa0188 855945cd2a744387a5f7d84c354bf90c--f8c2e75295ec4d8ea41d70a9b5aa0188 3d459ca4d66a460c96f0c64212a28054 f8c2e75295ec4d8ea41d70a9b5aa0188--3d459ca4d66a460c96f0c64212a28054 46d40eddd965480ea270b9d97d64ce1b 3d459ca4d66a460c96f0c64212a28054--46d40eddd965480ea270b9d97d64ce1b cf109a04149b4cf49ab7e3cd98ea9cea 46d40eddd965480ea270b9d97d64ce1b--cf109a04149b4cf49ab7e3cd98ea9cea 16cdf66ee2d5414eb34a35f5f91f4f3a cf109a04149b4cf49ab7e3cd98ea9cea--16cdf66ee2d5414eb34a35f5f91f4f3a 57a210c6da4b4b4e973534b2b6d19d0a 16cdf66ee2d5414eb34a35f5f91f4f3a--57a210c6da4b4b4e973534b2b6d19d0a 425bb335d897400d8103688b7685d869 57a210c6da4b4b4e973534b2b6d19d0a--425bb335d897400d8103688b7685d869 f218f09ea3b34642acbe4a55bc8ce725 425bb335d897400d8103688b7685d869--f218f09ea3b34642acbe4a55bc8ce725 c32ce296796f4ce5a3d5c5599c8949e5 f218f09ea3b34642acbe4a55bc8ce725--c32ce296796f4ce5a3d5c5599c8949e5 37c6808130a34019b3f17996fef84028 c32ce296796f4ce5a3d5c5599c8949e5--37c6808130a34019b3f17996fef84028 c7bd382d60e34ffa89fd8ab9d67f2819 37c6808130a34019b3f17996fef84028--c7bd382d60e34ffa89fd8ab9d67f2819 0db9f91f3e73472e80d59e281c75d6c8 c7bd382d60e34ffa89fd8ab9d67f2819--0db9f91f3e73472e80d59e281c75d6c8 6f69ba17f1bd41f6af57fe1888529809 0db9f91f3e73472e80d59e281c75d6c8--6f69ba17f1bd41f6af57fe1888529809 ea16dd63d9ae48eebe88b6e4938f4a65 6f69ba17f1bd41f6af57fe1888529809--ea16dd63d9ae48eebe88b6e4938f4a65 307dfb44c80b455381fae00178384ff0 ea16dd63d9ae48eebe88b6e4938f4a65--307dfb44c80b455381fae00178384ff0 85582c3d1f2b473c957f17053483277e 307dfb44c80b455381fae00178384ff0--85582c3d1f2b473c957f17053483277e 7819a6ed003f41aeb74bf6d2142cad84 85582c3d1f2b473c957f17053483277e--7819a6ed003f41aeb74bf6d2142cad84 eb1096c812d54d07b7aae78e187a4324 7819a6ed003f41aeb74bf6d2142cad84--eb1096c812d54d07b7aae78e187a4324 2597faedc1354aa4b6a7728c0ea59ad3 eb1096c812d54d07b7aae78e187a4324--2597faedc1354aa4b6a7728c0ea59ad3 c7cda0aada3f47a0a773dc07858b77c4 2597faedc1354aa4b6a7728c0ea59ad3--c7cda0aada3f47a0a773dc07858b77c4 b511525d1f5f4bc8820a2d1ff7c89977 c7cda0aada3f47a0a773dc07858b77c4--b511525d1f5f4bc8820a2d1ff7c89977 68bb97d5bb2c45e0991f908af2b5745e b511525d1f5f4bc8820a2d1ff7c89977--68bb97d5bb2c45e0991f908af2b5745e 31f9a797fb7f43c6bdd8b566ef3a586a 68bb97d5bb2c45e0991f908af2b5745e--31f9a797fb7f43c6bdd8b566ef3a586a 66d4173c1676404492d187564ee14083 31f9a797fb7f43c6bdd8b566ef3a586a--66d4173c1676404492d187564ee14083 b0bcb1032b974f0caaf1af30aa0607fb 66d4173c1676404492d187564ee14083--b0bcb1032b974f0caaf1af30aa0607fb 4a25ebd52c3c493da6c3f36840f8c09c b0bcb1032b974f0caaf1af30aa0607fb--4a25ebd52c3c493da6c3f36840f8c09c 35bfad2d27984d8a9e3a89ba73bea392 4a25ebd52c3c493da6c3f36840f8c09c--35bfad2d27984d8a9e3a89ba73bea392 766180877c9a4d73a466a3002fb5e123 35bfad2d27984d8a9e3a89ba73bea392--766180877c9a4d73a466a3002fb5e123 d651f3bbba3c4a97b10b119cd387495c 766180877c9a4d73a466a3002fb5e123--d651f3bbba3c4a97b10b119cd387495c fc04f608fa2c4f9faefc70563a76eb92 d651f3bbba3c4a97b10b119cd387495c--fc04f608fa2c4f9faefc70563a76eb92 73028ac73de646d5a8a9ee886f76db00 fc04f608fa2c4f9faefc70563a76eb92--73028ac73de646d5a8a9ee886f76db00 6df880e379d64971b275cfbcb021c8b8 73028ac73de646d5a8a9ee886f76db00--6df880e379d64971b275cfbcb021c8b8 c15fd6dccccd4b6fa676648e90103626 6df880e379d64971b275cfbcb021c8b8--c15fd6dccccd4b6fa676648e90103626 d03cdca66f7c4805b674d4ef9d6bf784 c15fd6dccccd4b6fa676648e90103626--d03cdca66f7c4805b674d4ef9d6bf784 e79972e143594805a8632e998dbd039c d03cdca66f7c4805b674d4ef9d6bf784--e79972e143594805a8632e998dbd039c 3e3693e4207346b0aa7a93aec2fedc1d X e79972e143594805a8632e998dbd039c--3e3693e4207346b0aa7a93aec2fedc1d 3e3693e4207346b0aa7a93aec2fedc1d--ec66d8ac807c4d46995c57e7e227b13c 5ab6830fa47b4920a07af3929e80e21d RZ(-1.0*g0) 3e3693e4207346b0aa7a93aec2fedc1d--5ab6830fa47b4920a07af3929e80e21d e0f40c93d8fd4d94a2de26b8ca224633 X 5ab6830fa47b4920a07af3929e80e21d--e0f40c93d8fd4d94a2de26b8ca224633 e0f40c93d8fd4d94a2de26b8ca224633--0794c4c3ba294a859ea6a5a2c3affe7a 3407a4c41cf1461cbfafa922aadd9467 e0f40c93d8fd4d94a2de26b8ca224633--3407a4c41cf1461cbfafa922aadd9467 8cc9d85258b2444a95e778b18781d124 3407a4c41cf1461cbfafa922aadd9467--8cc9d85258b2444a95e778b18781d124 b8b6d470494b44fb928d94c5cd1c26a7 8cc9d85258b2444a95e778b18781d124--b8b6d470494b44fb928d94c5cd1c26a7 6b70eab756da4957a5edcf922fddd075 b8b6d470494b44fb928d94c5cd1c26a7--6b70eab756da4957a5edcf922fddd075 ea2f93b90b6d40c59882b54e1ef4331b 6b70eab756da4957a5edcf922fddd075--ea2f93b90b6d40c59882b54e1ef4331b c6f7ef43ee434e769d31e0f2e79d0441 ea2f93b90b6d40c59882b54e1ef4331b--c6f7ef43ee434e769d31e0f2e79d0441 58a12f7de7ab4721b9a6abd993e1d03e c6f7ef43ee434e769d31e0f2e79d0441--58a12f7de7ab4721b9a6abd993e1d03e 767ec04ef2c44da2b887391d74d3f4aa 58a12f7de7ab4721b9a6abd993e1d03e--767ec04ef2c44da2b887391d74d3f4aa 29884a107e914f5599551d4e4f1b68bb 767ec04ef2c44da2b887391d74d3f4aa--29884a107e914f5599551d4e4f1b68bb e4a2a2e9f04b4551b45e6a9adcc3a7ee 29884a107e914f5599551d4e4f1b68bb--e4a2a2e9f04b4551b45e6a9adcc3a7ee be9fd14d310f483fadbdbf26b28b0d8a e4a2a2e9f04b4551b45e6a9adcc3a7ee--be9fd14d310f483fadbdbf26b28b0d8a bcd9ec1f5c9440b4a01c72a9b1923b02 be9fd14d310f483fadbdbf26b28b0d8a--bcd9ec1f5c9440b4a01c72a9b1923b02 ca8148a5038243868b1b4a81c06fa8f8 bcd9ec1f5c9440b4a01c72a9b1923b02--ca8148a5038243868b1b4a81c06fa8f8 5d50899792da474b8b8dfc1f440a569e ca8148a5038243868b1b4a81c06fa8f8--5d50899792da474b8b8dfc1f440a569e 2e85ea8e0f3d4e6588a96cb8c896ddf9 5d50899792da474b8b8dfc1f440a569e--2e85ea8e0f3d4e6588a96cb8c896ddf9 b66dfff303fe4e85b7a801e35eca7281 2e85ea8e0f3d4e6588a96cb8c896ddf9--b66dfff303fe4e85b7a801e35eca7281 4b947a304f134abdacbf74627f0cb76c b66dfff303fe4e85b7a801e35eca7281--4b947a304f134abdacbf74627f0cb76c 17508e23f6c84e56983936f1cb9c3e70 4b947a304f134abdacbf74627f0cb76c--17508e23f6c84e56983936f1cb9c3e70 7ffc48cd2ef54a47a5ac9c7a2027e698 17508e23f6c84e56983936f1cb9c3e70--7ffc48cd2ef54a47a5ac9c7a2027e698 25c3db48a5f843c6a4c9c2ac373981ea 7ffc48cd2ef54a47a5ac9c7a2027e698--25c3db48a5f843c6a4c9c2ac373981ea 4fb372b95f044d96bcad5a04ff210b71 25c3db48a5f843c6a4c9c2ac373981ea--4fb372b95f044d96bcad5a04ff210b71 ea716691051240cb98bda5667eb3dfa7 4fb372b95f044d96bcad5a04ff210b71--ea716691051240cb98bda5667eb3dfa7 344439e747d84fc2b9bc2eab2769122f ea716691051240cb98bda5667eb3dfa7--344439e747d84fc2b9bc2eab2769122f 5c827c836ca54a5dbae90af899eec745 344439e747d84fc2b9bc2eab2769122f--5c827c836ca54a5dbae90af899eec745 4e7ceab582084031a99ad7dbf5f85e78 5c827c836ca54a5dbae90af899eec745--4e7ceab582084031a99ad7dbf5f85e78 e2da4f8a38e24ade9e01bc9314ce075f 4e7ceab582084031a99ad7dbf5f85e78--e2da4f8a38e24ade9e01bc9314ce075f fe5cc63a01f149f09e5347c7e278a6ca e2da4f8a38e24ade9e01bc9314ce075f--fe5cc63a01f149f09e5347c7e278a6ca d8a3bb7a068d43a19db9235cdbb74b2e fe5cc63a01f149f09e5347c7e278a6ca--d8a3bb7a068d43a19db9235cdbb74b2e 8fef650332d8403f927121f49d1ca114 X d8a3bb7a068d43a19db9235cdbb74b2e--8fef650332d8403f927121f49d1ca114 8fef650332d8403f927121f49d1ca114--0f45ed51e72548ce80d83acd2712f695 0c28a7ae124f4031be7e80ac638516da RZ(-1.0*g0) 8fef650332d8403f927121f49d1ca114--0c28a7ae124f4031be7e80ac638516da 9bb2967bb52b43e0a05a8c04d63dbfba X 0c28a7ae124f4031be7e80ac638516da--9bb2967bb52b43e0a05a8c04d63dbfba 9bb2967bb52b43e0a05a8c04d63dbfba--3aab0641d6c14a00bcd8ceddc402f85d 3d8d7249316d4740b583f081e9816583 9bb2967bb52b43e0a05a8c04d63dbfba--3d8d7249316d4740b583f081e9816583 3df9ee218b394daa97729f2629fb12db 3d8d7249316d4740b583f081e9816583--3df9ee218b394daa97729f2629fb12db 2705858f599546e9bab1cc8c5329d1c5 3df9ee218b394daa97729f2629fb12db--2705858f599546e9bab1cc8c5329d1c5 6e8b8f9ac6574a8180bc84a49f2a4d92 2705858f599546e9bab1cc8c5329d1c5--6e8b8f9ac6574a8180bc84a49f2a4d92 e0e4442de0d44353abec7960e2c182f0 6e8b8f9ac6574a8180bc84a49f2a4d92--e0e4442de0d44353abec7960e2c182f0 17e4304777144cfaa601084e17d80b61 e0e4442de0d44353abec7960e2c182f0--17e4304777144cfaa601084e17d80b61 68f92ea2b6ea48ee8d31383f616c7427 17e4304777144cfaa601084e17d80b61--68f92ea2b6ea48ee8d31383f616c7427 fcc708c05e774455b1c7a8c8a748ec00 68f92ea2b6ea48ee8d31383f616c7427--fcc708c05e774455b1c7a8c8a748ec00 99db27db1fa14e8da1c845fa9d24e433 fcc708c05e774455b1c7a8c8a748ec00--99db27db1fa14e8da1c845fa9d24e433 e384a57cab5342dd91dc19f49010afa1 99db27db1fa14e8da1c845fa9d24e433--e384a57cab5342dd91dc19f49010afa1 6a3cb45d1bfb4d25b82789a11eeb30c0 e384a57cab5342dd91dc19f49010afa1--6a3cb45d1bfb4d25b82789a11eeb30c0 a81c825c79a84e13af897d6874181286 6a3cb45d1bfb4d25b82789a11eeb30c0--a81c825c79a84e13af897d6874181286 104694de5a76443fbe194ad423cf0956 a81c825c79a84e13af897d6874181286--104694de5a76443fbe194ad423cf0956 f4175f0b05364a4788b05f6c8df1056a 104694de5a76443fbe194ad423cf0956--f4175f0b05364a4788b05f6c8df1056a ab4e3f4aa0d947eca61cfe149cbabcf3 f4175f0b05364a4788b05f6c8df1056a--ab4e3f4aa0d947eca61cfe149cbabcf3 936d0162f238451f9aa3cf5e878bbba8 ab4e3f4aa0d947eca61cfe149cbabcf3--936d0162f238451f9aa3cf5e878bbba8 abb6f7331512448393534f2f0a9bc106 936d0162f238451f9aa3cf5e878bbba8--abb6f7331512448393534f2f0a9bc106 a5dbb93d60d24a71b66b6fba3b26ebc9 abb6f7331512448393534f2f0a9bc106--a5dbb93d60d24a71b66b6fba3b26ebc9 33033802577544a2a33039fbb1331fd5 a5dbb93d60d24a71b66b6fba3b26ebc9--33033802577544a2a33039fbb1331fd5 7f4244d5fa584ad88da78e18f93b9556 33033802577544a2a33039fbb1331fd5--7f4244d5fa584ad88da78e18f93b9556 ad48a6a86f8145eabec4104bd4c41abf 7f4244d5fa584ad88da78e18f93b9556--ad48a6a86f8145eabec4104bd4c41abf edaf0ea3fe784750834c94b68520daf0 X ad48a6a86f8145eabec4104bd4c41abf--edaf0ea3fe784750834c94b68520daf0 edaf0ea3fe784750834c94b68520daf0--faf87e8cb5f74625af15887d10be6f43 39dced2c1f954a40addcc4e7cd21d350 RZ(-1.0*g0) edaf0ea3fe784750834c94b68520daf0--39dced2c1f954a40addcc4e7cd21d350 b468f89fa6034b77b6dcd7f1a96f812e X 39dced2c1f954a40addcc4e7cd21d350--b468f89fa6034b77b6dcd7f1a96f812e b468f89fa6034b77b6dcd7f1a96f812e--58c2eaa17fbb4c23ab311dedd849d1ce 48082022b48040d89165e495875a4a55 b468f89fa6034b77b6dcd7f1a96f812e--48082022b48040d89165e495875a4a55 f0b449f2415a41468cd4accf1c174844 48082022b48040d89165e495875a4a55--f0b449f2415a41468cd4accf1c174844 02e31e6e6d834e0286ff841efd65413c f0b449f2415a41468cd4accf1c174844--02e31e6e6d834e0286ff841efd65413c 8e05f9f4f4664e41a7934ed629ebf052 02e31e6e6d834e0286ff841efd65413c--8e05f9f4f4664e41a7934ed629ebf052 260637ffe8ed401e85bce5c480982506 8e05f9f4f4664e41a7934ed629ebf052--260637ffe8ed401e85bce5c480982506 4f30e23414bd4669b8ee825c30f54ac0 260637ffe8ed401e85bce5c480982506--4f30e23414bd4669b8ee825c30f54ac0 6e06bbd38b784014aa7f22162cc2c0be 4f30e23414bd4669b8ee825c30f54ac0--6e06bbd38b784014aa7f22162cc2c0be 9b4575bc7425425a84d6a9130d2e6185 6e06bbd38b784014aa7f22162cc2c0be--9b4575bc7425425a84d6a9130d2e6185 0d4eac1cd9a04cb1939f5f1618d61df4 9b4575bc7425425a84d6a9130d2e6185--0d4eac1cd9a04cb1939f5f1618d61df4 d0f98cbdc5a04c53a5157abcd0ac7a39 0d4eac1cd9a04cb1939f5f1618d61df4--d0f98cbdc5a04c53a5157abcd0ac7a39 428207f05f1041e9a1f74a327d218496 d0f98cbdc5a04c53a5157abcd0ac7a39--428207f05f1041e9a1f74a327d218496 a76ae686d2d34ec5908701d85b07a286 428207f05f1041e9a1f74a327d218496--a76ae686d2d34ec5908701d85b07a286 449e80d8dac240ebafe30eb3f44f7ee5 a76ae686d2d34ec5908701d85b07a286--449e80d8dac240ebafe30eb3f44f7ee5 717093f286984a5fb69efe1f190591b8 X 449e80d8dac240ebafe30eb3f44f7ee5--717093f286984a5fb69efe1f190591b8 717093f286984a5fb69efe1f190591b8--df41c8713b2b4202bdba28a3446ce64b 17f5d58e3d4846e5aec993580c393da7 RZ(-1.0*g0) 717093f286984a5fb69efe1f190591b8--17f5d58e3d4846e5aec993580c393da7 9d9a4ff6b13c475eaea455917f107446 X 17f5d58e3d4846e5aec993580c393da7--9d9a4ff6b13c475eaea455917f107446 9d9a4ff6b13c475eaea455917f107446--86165a1ea2f64a5dbc704218ec670fc6 6c47542bf7d54f418f8bd52b18323894 9d9a4ff6b13c475eaea455917f107446--6c47542bf7d54f418f8bd52b18323894 695f72a86f8f4f8fb15d37855d8e2b7e 6c47542bf7d54f418f8bd52b18323894--695f72a86f8f4f8fb15d37855d8e2b7e 7579869366ef49c3a9f57ad5c43bb8d0 RX(b07) 695f72a86f8f4f8fb15d37855d8e2b7e--7579869366ef49c3a9f57ad5c43bb8d0 f2355204b4064c05890c8b89736109d9 7579869366ef49c3a9f57ad5c43bb8d0--f2355204b4064c05890c8b89736109d9 98c5b60210dd42d3abc84fd7dc7a8c2b f2355204b4064c05890c8b89736109d9--98c5b60210dd42d3abc84fd7dc7a8c2b b8b5403520d64f88ae8b82fd10fc4e15 98c5b60210dd42d3abc84fd7dc7a8c2b--b8b5403520d64f88ae8b82fd10fc4e15 44d0512049584f0b81ebf5977d092a70 b8b5403520d64f88ae8b82fd10fc4e15--44d0512049584f0b81ebf5977d092a70 3ce6ead3757b48f1a348c43f8a429bc7 44d0512049584f0b81ebf5977d092a70--3ce6ead3757b48f1a348c43f8a429bc7 b4865bc4b62643e398af0148071d2941 3ce6ead3757b48f1a348c43f8a429bc7--b4865bc4b62643e398af0148071d2941 8bfeb03fc3f8433e8dc7b0415a953568 X b4865bc4b62643e398af0148071d2941--8bfeb03fc3f8433e8dc7b0415a953568 8bfeb03fc3f8433e8dc7b0415a953568--d5e2ac7380b148f2b1144fdf371e9eff 5eb7b6df9d384808ac0e9172f540f4a8 RZ(1.0*g1) 8bfeb03fc3f8433e8dc7b0415a953568--5eb7b6df9d384808ac0e9172f540f4a8 36a0cc66ec004770ba21c58013607f50 X 5eb7b6df9d384808ac0e9172f540f4a8--36a0cc66ec004770ba21c58013607f50 36a0cc66ec004770ba21c58013607f50--c900541b76814901aa54e1ef7dc2372b b1300c0725cb4691906ebba3a583907e 36a0cc66ec004770ba21c58013607f50--b1300c0725cb4691906ebba3a583907e e6b423ccb08e493faf205d4c8b480b8a b1300c0725cb4691906ebba3a583907e--e6b423ccb08e493faf205d4c8b480b8a 197cd82c11dc44d6a4749366546d3861 e6b423ccb08e493faf205d4c8b480b8a--197cd82c11dc44d6a4749366546d3861 b72431c9a84543918d8e658aeaf61281 197cd82c11dc44d6a4749366546d3861--b72431c9a84543918d8e658aeaf61281 440237b0b3e044fd9af7191bcab5c4ce b72431c9a84543918d8e658aeaf61281--440237b0b3e044fd9af7191bcab5c4ce dfc81efd0cef4eb1bdf1e7e2ce82165a 440237b0b3e044fd9af7191bcab5c4ce--dfc81efd0cef4eb1bdf1e7e2ce82165a e780d22d642a412293312abe856ff4c7 dfc81efd0cef4eb1bdf1e7e2ce82165a--e780d22d642a412293312abe856ff4c7 92cbe92816ca4c5f8ffafaaadc9e1b65 e780d22d642a412293312abe856ff4c7--92cbe92816ca4c5f8ffafaaadc9e1b65 d3476366cda744c0ba8f9f49e9484bc4 92cbe92816ca4c5f8ffafaaadc9e1b65--d3476366cda744c0ba8f9f49e9484bc4 536b794a96d041f088d31c759fcb490d d3476366cda744c0ba8f9f49e9484bc4--536b794a96d041f088d31c759fcb490d 2cc71bed75e74dcd83a306bebcc972e8 536b794a96d041f088d31c759fcb490d--2cc71bed75e74dcd83a306bebcc972e8 45f7329289224f9893d1ac10c356d569 2cc71bed75e74dcd83a306bebcc972e8--45f7329289224f9893d1ac10c356d569 2216e000e9634417b943d49b4cd0a4c5 45f7329289224f9893d1ac10c356d569--2216e000e9634417b943d49b4cd0a4c5 db7b76cd9219465686d52b47d2c4607c 2216e000e9634417b943d49b4cd0a4c5--db7b76cd9219465686d52b47d2c4607c 11854547555746e482fb77c605e68040 db7b76cd9219465686d52b47d2c4607c--11854547555746e482fb77c605e68040 4f8900025faa4451ac868e703010c579 11854547555746e482fb77c605e68040--4f8900025faa4451ac868e703010c579 2ef41088df1147c191c7c516a4f3abfd 4f8900025faa4451ac868e703010c579--2ef41088df1147c191c7c516a4f3abfd 0d639240189540029eefd6552d9b0c9d 2ef41088df1147c191c7c516a4f3abfd--0d639240189540029eefd6552d9b0c9d 4d012395a1904b0781f4f9aa66abc72a 0d639240189540029eefd6552d9b0c9d--4d012395a1904b0781f4f9aa66abc72a 8fc33202b19b4e8fb9472060285d08cc 4d012395a1904b0781f4f9aa66abc72a--8fc33202b19b4e8fb9472060285d08cc 085d1ccbe9374047be0e01f0bcf00732 8fc33202b19b4e8fb9472060285d08cc--085d1ccbe9374047be0e01f0bcf00732 77732ae1d596415d8be8361662a2ba09 085d1ccbe9374047be0e01f0bcf00732--77732ae1d596415d8be8361662a2ba09 08023a2c586e4c99946e357a1419375e 77732ae1d596415d8be8361662a2ba09--08023a2c586e4c99946e357a1419375e b0ee70391c3b429a87ca2168fd22abfa 08023a2c586e4c99946e357a1419375e--b0ee70391c3b429a87ca2168fd22abfa 82e79ecd937b4e0db2b90852c0224a88 b0ee70391c3b429a87ca2168fd22abfa--82e79ecd937b4e0db2b90852c0224a88 812057a189c74b91a36363dd8c7eeeba 82e79ecd937b4e0db2b90852c0224a88--812057a189c74b91a36363dd8c7eeeba 9fcf9ebb322b4ed4aa6b41c6416bd068 812057a189c74b91a36363dd8c7eeeba--9fcf9ebb322b4ed4aa6b41c6416bd068 d2dd4ee2df434dcd9c0ee3eef161010e 9fcf9ebb322b4ed4aa6b41c6416bd068--d2dd4ee2df434dcd9c0ee3eef161010e e982c22d90db45f2988d95e38c7d56ad d2dd4ee2df434dcd9c0ee3eef161010e--e982c22d90db45f2988d95e38c7d56ad 99a1be946b0c4432b414fca078492924 e982c22d90db45f2988d95e38c7d56ad--99a1be946b0c4432b414fca078492924 0fe7a4e92b1847c98cd47b47c1221b21 99a1be946b0c4432b414fca078492924--0fe7a4e92b1847c98cd47b47c1221b21 28e0325e7c8544a2b2eb117f39aabe8b 0fe7a4e92b1847c98cd47b47c1221b21--28e0325e7c8544a2b2eb117f39aabe8b ad083345c9534fc7b4c60a5baa45445c 28e0325e7c8544a2b2eb117f39aabe8b--ad083345c9534fc7b4c60a5baa45445c 34353f643df54bb2a6f9befef55fe651 ad083345c9534fc7b4c60a5baa45445c--34353f643df54bb2a6f9befef55fe651 5bd7df32b9d94a8fa682563038c72ad8 34353f643df54bb2a6f9befef55fe651--5bd7df32b9d94a8fa682563038c72ad8 9d3b95ae24024b3fa99764f60afdf95c X 5bd7df32b9d94a8fa682563038c72ad8--9d3b95ae24024b3fa99764f60afdf95c 9d3b95ae24024b3fa99764f60afdf95c--3ef6006c895b43f28034a0180862a667 cf3b560f1af7468ebc04e3c595fe0472 RZ(-1.0*g1) 9d3b95ae24024b3fa99764f60afdf95c--cf3b560f1af7468ebc04e3c595fe0472 af8a1bbc3e294f1e91c06b71445a55fc X cf3b560f1af7468ebc04e3c595fe0472--af8a1bbc3e294f1e91c06b71445a55fc af8a1bbc3e294f1e91c06b71445a55fc--e3d9b7b7adf449a5ba10a303cbdd7315 8b6f3f833af84911ac702bfcd5a8e5a7 af8a1bbc3e294f1e91c06b71445a55fc--8b6f3f833af84911ac702bfcd5a8e5a7 d4cedd8af6b64e75848955444e0405f0 8b6f3f833af84911ac702bfcd5a8e5a7--d4cedd8af6b64e75848955444e0405f0 f2d107588197435dbb322cae13f15570 d4cedd8af6b64e75848955444e0405f0--f2d107588197435dbb322cae13f15570 248def7dad14419a80e37b21f8a3c078 f2d107588197435dbb322cae13f15570--248def7dad14419a80e37b21f8a3c078 9000018bd0ec4944be30f8d643cb0678 248def7dad14419a80e37b21f8a3c078--9000018bd0ec4944be30f8d643cb0678 d80ac351434a43d7a93c4ad841558ffe 9000018bd0ec4944be30f8d643cb0678--d80ac351434a43d7a93c4ad841558ffe 170434dff42a4ca6baf9260a17cd4b0b d80ac351434a43d7a93c4ad841558ffe--170434dff42a4ca6baf9260a17cd4b0b 87840fbbc8ca4db79a036c6b0fdd2b1b 170434dff42a4ca6baf9260a17cd4b0b--87840fbbc8ca4db79a036c6b0fdd2b1b c0c7ad11eeb84ebba451a6259180f334 87840fbbc8ca4db79a036c6b0fdd2b1b--c0c7ad11eeb84ebba451a6259180f334 677011d0707d49abbdc1aeb0fc6b05d2 c0c7ad11eeb84ebba451a6259180f334--677011d0707d49abbdc1aeb0fc6b05d2 b3f8c30b362c499d9488fc5b6bf8c672 677011d0707d49abbdc1aeb0fc6b05d2--b3f8c30b362c499d9488fc5b6bf8c672 1a314a25788e4c6db691780a2a446d89 b3f8c30b362c499d9488fc5b6bf8c672--1a314a25788e4c6db691780a2a446d89 5cf13fb53a56478a811ee4647ecb7d29 1a314a25788e4c6db691780a2a446d89--5cf13fb53a56478a811ee4647ecb7d29 8546c549d3e7476e9b19ebd8112c160b 5cf13fb53a56478a811ee4647ecb7d29--8546c549d3e7476e9b19ebd8112c160b 918250004fc5430bad8906cfcaee61a5 8546c549d3e7476e9b19ebd8112c160b--918250004fc5430bad8906cfcaee61a5 4c9d2363fa9d4e9cb1b1968b9fb20817 918250004fc5430bad8906cfcaee61a5--4c9d2363fa9d4e9cb1b1968b9fb20817 0a146d9bbf25478293b7d775ac38ff9f 4c9d2363fa9d4e9cb1b1968b9fb20817--0a146d9bbf25478293b7d775ac38ff9f 58e8d6505d2d4a38876f0964b461a3d7 0a146d9bbf25478293b7d775ac38ff9f--58e8d6505d2d4a38876f0964b461a3d7 459f95cb66374c05a784e293652944db 58e8d6505d2d4a38876f0964b461a3d7--459f95cb66374c05a784e293652944db 62cf78cfb47148e19ad9e3daa4b7234b 459f95cb66374c05a784e293652944db--62cf78cfb47148e19ad9e3daa4b7234b a03a57de57e74a6bac686147042b9dae 62cf78cfb47148e19ad9e3daa4b7234b--a03a57de57e74a6bac686147042b9dae 940f69e0c1e44db08729ab38e8347919 a03a57de57e74a6bac686147042b9dae--940f69e0c1e44db08729ab38e8347919 526217e8daa64c7eb7c098b2c17b4253 940f69e0c1e44db08729ab38e8347919--526217e8daa64c7eb7c098b2c17b4253 563b60d8dec34a13a2fec13ab00db8b4 526217e8daa64c7eb7c098b2c17b4253--563b60d8dec34a13a2fec13ab00db8b4 86e249f02c744ca6a5391d85bc3647d9 563b60d8dec34a13a2fec13ab00db8b4--86e249f02c744ca6a5391d85bc3647d9 8f3a412e234547e58caf1ac744cd6d75 86e249f02c744ca6a5391d85bc3647d9--8f3a412e234547e58caf1ac744cd6d75 cfe271ef92c546bcbf0f1108b24658db 8f3a412e234547e58caf1ac744cd6d75--cfe271ef92c546bcbf0f1108b24658db ba0df5c0377f4c93846dcebd18e490ef cfe271ef92c546bcbf0f1108b24658db--ba0df5c0377f4c93846dcebd18e490ef 2623f8371a2a48959a07429a537c633d X ba0df5c0377f4c93846dcebd18e490ef--2623f8371a2a48959a07429a537c633d 2623f8371a2a48959a07429a537c633d--d491f63bed5a4177aeee6e93023e78a8 ab9125bdecb64d12af67b98eea44a2a4 RZ(-1.0*g1) 2623f8371a2a48959a07429a537c633d--ab9125bdecb64d12af67b98eea44a2a4 9146f6adf55a4f9ead8c5cca95ff37e7 X ab9125bdecb64d12af67b98eea44a2a4--9146f6adf55a4f9ead8c5cca95ff37e7 9146f6adf55a4f9ead8c5cca95ff37e7--25a89dacb944464a904b31b4f21b084f 4a346de9c0f74e35af38f6e0c4260c1c 9146f6adf55a4f9ead8c5cca95ff37e7--4a346de9c0f74e35af38f6e0c4260c1c 0109969ffc2d4577b9225c4c55050d7c 4a346de9c0f74e35af38f6e0c4260c1c--0109969ffc2d4577b9225c4c55050d7c c408b849cb08412b8e5ba73d1a18bed8 0109969ffc2d4577b9225c4c55050d7c--c408b849cb08412b8e5ba73d1a18bed8 00b893012f3e44f59fe6ebcb47973778 c408b849cb08412b8e5ba73d1a18bed8--00b893012f3e44f59fe6ebcb47973778 808637bf6994429ab3f74ca5832e8498 00b893012f3e44f59fe6ebcb47973778--808637bf6994429ab3f74ca5832e8498 e41b3f7e6360411bb3586dc1412d420e 808637bf6994429ab3f74ca5832e8498--e41b3f7e6360411bb3586dc1412d420e eff258efa7e04fbf8d6707422e7d562a e41b3f7e6360411bb3586dc1412d420e--eff258efa7e04fbf8d6707422e7d562a 8c330602306546dc9c30302c809bbf20 eff258efa7e04fbf8d6707422e7d562a--8c330602306546dc9c30302c809bbf20 f7d2c6207e904c33aa5ef05a90e6a846 8c330602306546dc9c30302c809bbf20--f7d2c6207e904c33aa5ef05a90e6a846 3882077a85434d41b6425943a4560810 f7d2c6207e904c33aa5ef05a90e6a846--3882077a85434d41b6425943a4560810 4b20e76d79b94030a67cd8e61c1ce7cf 3882077a85434d41b6425943a4560810--4b20e76d79b94030a67cd8e61c1ce7cf 315971006e3e44e1ac47b4e470d10605 4b20e76d79b94030a67cd8e61c1ce7cf--315971006e3e44e1ac47b4e470d10605 db2f7abab30941ce8aca969849084dbc 315971006e3e44e1ac47b4e470d10605--db2f7abab30941ce8aca969849084dbc 1da77135a81b413dbb78af2953e4d424 db2f7abab30941ce8aca969849084dbc--1da77135a81b413dbb78af2953e4d424 f1260fc72ff044489735e783f905edfb 1da77135a81b413dbb78af2953e4d424--f1260fc72ff044489735e783f905edfb 0c72e5ae6fa24e1daf86d7dea97673d7 f1260fc72ff044489735e783f905edfb--0c72e5ae6fa24e1daf86d7dea97673d7 24128c9612e34bb893ca90ac95d5cbfb 0c72e5ae6fa24e1daf86d7dea97673d7--24128c9612e34bb893ca90ac95d5cbfb 769b12b684b5456ba965deff15449e62 24128c9612e34bb893ca90ac95d5cbfb--769b12b684b5456ba965deff15449e62 af759191409444c5bf176fde4b647d12 769b12b684b5456ba965deff15449e62--af759191409444c5bf176fde4b647d12 f31aabba9ff64bdfb75227416fa1bb91 af759191409444c5bf176fde4b647d12--f31aabba9ff64bdfb75227416fa1bb91 9baba5d370fc426d9385d3f947986fd5 f31aabba9ff64bdfb75227416fa1bb91--9baba5d370fc426d9385d3f947986fd5 54e43f0c8e7f4fbd9267a44f1e303684 X 9baba5d370fc426d9385d3f947986fd5--54e43f0c8e7f4fbd9267a44f1e303684 54e43f0c8e7f4fbd9267a44f1e303684--024fa8a0553e4987b96bacf715d9cc53 0bf4d585ef6e43e1a1299da513d88ef0 RZ(-1.0*g1) 54e43f0c8e7f4fbd9267a44f1e303684--0bf4d585ef6e43e1a1299da513d88ef0 35c6bb236c164513b2c43c15db2f0b65 X 0bf4d585ef6e43e1a1299da513d88ef0--35c6bb236c164513b2c43c15db2f0b65 35c6bb236c164513b2c43c15db2f0b65--a1ea1b42a8664666bd6de7594c9ce376 f5db115b557c4e3fb281df11e6820714 35c6bb236c164513b2c43c15db2f0b65--f5db115b557c4e3fb281df11e6820714 01f5266d0e9244a6b75222842ac7bacc f5db115b557c4e3fb281df11e6820714--01f5266d0e9244a6b75222842ac7bacc 76a27455b89848ada6a39bc9ce73b857 01f5266d0e9244a6b75222842ac7bacc--76a27455b89848ada6a39bc9ce73b857 52ab0f44c51a4ab1a7df5ae2801bc0ab 76a27455b89848ada6a39bc9ce73b857--52ab0f44c51a4ab1a7df5ae2801bc0ab ca7c41cec8ec46059e5ef1c07c7063cb 52ab0f44c51a4ab1a7df5ae2801bc0ab--ca7c41cec8ec46059e5ef1c07c7063cb 6c2df9ecc10c45f299817100de162f39 ca7c41cec8ec46059e5ef1c07c7063cb--6c2df9ecc10c45f299817100de162f39 677cf7c4ab144c82addaf8a9417b5227 6c2df9ecc10c45f299817100de162f39--677cf7c4ab144c82addaf8a9417b5227 86db0eb6262644f3905f1151f268f19b 677cf7c4ab144c82addaf8a9417b5227--86db0eb6262644f3905f1151f268f19b a4e44bd1401d40749b6940d52961e920 86db0eb6262644f3905f1151f268f19b--a4e44bd1401d40749b6940d52961e920 cb181a5677744b7ba9ad34c984e78135 a4e44bd1401d40749b6940d52961e920--cb181a5677744b7ba9ad34c984e78135 b020bf0a055e4d839cf25d8ae8cda6d5 cb181a5677744b7ba9ad34c984e78135--b020bf0a055e4d839cf25d8ae8cda6d5 58426baee4c245449a6549b32530c6ef b020bf0a055e4d839cf25d8ae8cda6d5--58426baee4c245449a6549b32530c6ef c0bbe801474f4e7993d249ac0673d997 58426baee4c245449a6549b32530c6ef--c0bbe801474f4e7993d249ac0673d997 8e8e2e1dbab14476b80cf9d90908375e X c0bbe801474f4e7993d249ac0673d997--8e8e2e1dbab14476b80cf9d90908375e 8e8e2e1dbab14476b80cf9d90908375e--ccd80c33eea94d659d466d12449adaed e2666c424f7c42b08ce52bf2745fbbed RZ(-1.0*g1) 8e8e2e1dbab14476b80cf9d90908375e--e2666c424f7c42b08ce52bf2745fbbed d61a9640c67f4a7ea4fb3ef2beb049ef X e2666c424f7c42b08ce52bf2745fbbed--d61a9640c67f4a7ea4fb3ef2beb049ef d61a9640c67f4a7ea4fb3ef2beb049ef--2a6b24179c844f8692c1d72b9a0e4cd2 35da8ad2de5542e0b03f16c7c121d8e9 d61a9640c67f4a7ea4fb3ef2beb049ef--35da8ad2de5542e0b03f16c7c121d8e9 8870142566d240fb94c7dbfcc370562a 35da8ad2de5542e0b03f16c7c121d8e9--8870142566d240fb94c7dbfcc370562a f1c0302730e44f478ba66f65bcebcbd7 RX(b17) 8870142566d240fb94c7dbfcc370562a--f1c0302730e44f478ba66f65bcebcbd7 f1c0302730e44f478ba66f65bcebcbd7--0ec236b6f33943c6b099628cee343a78"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.672640914369349\nMaxCut cost at iteration 10: 10.777335079223697\nMaxCut cost at iteration 20: 10.98925029331683\nMaxCut cost at iteration 30: 10.99995054066445\nMaxCut cost at iteration 40: 10.99999955300112\nMaxCut cost at iteration 50: 10.999999985157631\nMaxCut cost at iteration 60: 10.999999998954458\nMaxCut cost at iteration 70: 10.999999999917597\nMaxCut cost at iteration 80: 10.99999999999344\nMaxCut cost at iteration 90: 10.999999999999487\nMaxCut cost at iteration 100: 10.999999999999966\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01011000  2023-12-12T16:39:26.675208 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-12-12T16:39:31.044731 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_1e9a08cc6ade4f3eb1908f37963b72f8 Constant Chebyshev FM cluster_51af759c4bde4f978c666f421b0220cf Constant Fourier FM 82eb0ea0a7ee4bfcab9235aef4796b8e 0 7f5599e5e2274dd6aa849ad73ea897a8 RX(phi) 82eb0ea0a7ee4bfcab9235aef4796b8e--7f5599e5e2274dd6aa849ad73ea897a8 a0aea83ca182433dbf7d092af02fdd16 1 4fb57c4d8a7545d7bcacf0267020ff40 RX(acos(phi)) 7f5599e5e2274dd6aa849ad73ea897a8--4fb57c4d8a7545d7bcacf0267020ff40 da8cb7b97b6046d8a50ea9501e2845a6 4fb57c4d8a7545d7bcacf0267020ff40--da8cb7b97b6046d8a50ea9501e2845a6 f7be71f5614b44ef86522e6e709aca13 ec099600b0e44fcf968af9ced30c6c7c RX(phi) a0aea83ca182433dbf7d092af02fdd16--ec099600b0e44fcf968af9ced30c6c7c 37a4556d0b0841168874455fac2484ae 2 c1d73895d66848b3b533767dd361665a RX(acos(phi)) ec099600b0e44fcf968af9ced30c6c7c--c1d73895d66848b3b533767dd361665a c1d73895d66848b3b533767dd361665a--f7be71f5614b44ef86522e6e709aca13 5da37886d64f41d1b9c78dbf0aab85ef d5db96e9700b4e8d8f7fc4cacc3dacca RX(phi) 37a4556d0b0841168874455fac2484ae--d5db96e9700b4e8d8f7fc4cacc3dacca ee914920d40c41f39ec5e46da07486f7 RX(acos(phi)) d5db96e9700b4e8d8f7fc4cacc3dacca--ee914920d40c41f39ec5e46da07486f7 ee914920d40c41f39ec5e46da07486f7--5da37886d64f41d1b9c78dbf0aab85ef <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n    @classmethod\n    def eval(cls, x):\n        return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_03ca21a4b9c6417eb0e60343c9b27f82 Constant custom_func FM cluster_794066e5196541ff84f71703a7aecc4a Constant asin FM 6d49b54ac3a14034bd8f63c0fe0a1033 0 46fe25048a744c7d90afe94901be06b4 RX(asin(phi)) 6d49b54ac3a14034bd8f63c0fe0a1033--46fe25048a744c7d90afe94901be06b4 691fc37846784c13828eb9e9431811ad 1 3a3cbfe86b074a8da208733ccb147c07 RX(phi**2 + asin(phi)) 46fe25048a744c7d90afe94901be06b4--3a3cbfe86b074a8da208733ccb147c07 22b6a590aadd49efaddbab7445eda566 3a3cbfe86b074a8da208733ccb147c07--22b6a590aadd49efaddbab7445eda566 b2d4ff3b1aeb4f7cb47ad1f5b8b007c1 91a8ce6e8cb64938a8e2333a20bae0db RX(asin(phi)) 691fc37846784c13828eb9e9431811ad--91a8ce6e8cb64938a8e2333a20bae0db a97d625b52904d98b492d7b9c8eb0876 2 182f89f0cfc749ee8c725f700b2bf458 RX(phi**2 + asin(phi)) 91a8ce6e8cb64938a8e2333a20bae0db--182f89f0cfc749ee8c725f700b2bf458 182f89f0cfc749ee8c725f700b2bf458--b2d4ff3b1aeb4f7cb47ad1f5b8b007c1 634eb84c73e14ef0b1865e03697e5911 4a9b5341a58144c8bccc120e5f9bca93 RX(asin(phi)) a97d625b52904d98b492d7b9c8eb0876--4a9b5341a58144c8bccc120e5f9bca93 cd70217c36264990966a5e91977d9996 RX(phi**2 + asin(phi)) 4a9b5341a58144c8bccc120e5f9bca93--cd70217c36264990966a5e91977d9996 cd70217c36264990966a5e91977d9996--634eb84c73e14ef0b1865e03697e5911 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_6d8d67a86bcf404e8b476cecc56a7dd3 Exponential Fourier FM cluster_5b6193daf9f44d66b677d08727709d17 Constant Fourier FM cluster_b759ec7036cb41a4a7849588ebe8626a Tower Fourier FM b57aa53fd45f4e9082b85bd476f51a51 0 daa73389890b4c85a62c45d028360d6c RX(phi) b57aa53fd45f4e9082b85bd476f51a51--daa73389890b4c85a62c45d028360d6c 9975ca337475416cacf517dd20f894bd 1 428ac8e624ab4a60a9ab5ff2a384ce76 RX(1.0*phi) daa73389890b4c85a62c45d028360d6c--428ac8e624ab4a60a9ab5ff2a384ce76 991b9c6140a44f7fb4ede358927c312f RX(1.0*phi) 428ac8e624ab4a60a9ab5ff2a384ce76--991b9c6140a44f7fb4ede358927c312f 39fb62f7b64444b18b525fe6c37ee1a2 991b9c6140a44f7fb4ede358927c312f--39fb62f7b64444b18b525fe6c37ee1a2 d964fc97d7e24ee294815f90e5b35f79 118def6b3c18499cb41df42e7d2c0991 RX(phi) 9975ca337475416cacf517dd20f894bd--118def6b3c18499cb41df42e7d2c0991 630e0a651c6243c989532dac70f9f146 2 9c39cab71e9d450bb6c854dd63fe3576 RX(2.0*phi) 118def6b3c18499cb41df42e7d2c0991--9c39cab71e9d450bb6c854dd63fe3576 e67998ee98d248129b22232ac75e32ba RX(2.0*phi) 9c39cab71e9d450bb6c854dd63fe3576--e67998ee98d248129b22232ac75e32ba e67998ee98d248129b22232ac75e32ba--d964fc97d7e24ee294815f90e5b35f79 0e959467b2c844018d2fc0b3bdec546b 725805004ae04d74bf716d2012d2b80a RX(phi) 630e0a651c6243c989532dac70f9f146--725805004ae04d74bf716d2012d2b80a e90b50e58abf464ebe556c8c11caf55c 3 f1b4cecb33e34a1b94de5b5b703e41a8 RX(3.0*phi) 725805004ae04d74bf716d2012d2b80a--f1b4cecb33e34a1b94de5b5b703e41a8 1a99d7bf0e4d468881245eec7545a396 RX(4.0*phi) f1b4cecb33e34a1b94de5b5b703e41a8--1a99d7bf0e4d468881245eec7545a396 1a99d7bf0e4d468881245eec7545a396--0e959467b2c844018d2fc0b3bdec546b 42b757d04d504ee583d5b954fa46d5b6 f499ce5dcfad4cebb63953140ca79980 RX(phi) e90b50e58abf464ebe556c8c11caf55c--f499ce5dcfad4cebb63953140ca79980 ca5db714c9bb46ddac32dff9c4a6b627 4 c3f7286dd3fe415388f5d8ded1fcfeeb RX(4.0*phi) f499ce5dcfad4cebb63953140ca79980--c3f7286dd3fe415388f5d8ded1fcfeeb 6100b2cdafa1455ebf18d0d879422684 RX(8.0*phi) c3f7286dd3fe415388f5d8ded1fcfeeb--6100b2cdafa1455ebf18d0d879422684 6100b2cdafa1455ebf18d0d879422684--42b757d04d504ee583d5b954fa46d5b6 b60506cc3dcd40eeb5a5f8c91082ad18 87ee4bc14b404d13876d958d1e099834 RX(phi) ca5db714c9bb46ddac32dff9c4a6b627--87ee4bc14b404d13876d958d1e099834 f3197cced51d476abe7f96afb2c66ce4 RX(5.0*phi) 87ee4bc14b404d13876d958d1e099834--f3197cced51d476abe7f96afb2c66ce4 6c19caad99cd48f9880b852d8d0d7417 RX(16.0*phi) f3197cced51d476abe7f96afb2c66ce4--6c19caad99cd48f9880b852d8d0d7417 6c19caad99cd48f9880b852d8d0d7417--b60506cc3dcd40eeb5a5f8c91082ad18 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 6b5ffc8ac59b4fa68b87ff22195c477b 0 e8599dcbec1f40dfa37aa7ba0cc06dc4 RX(1.0*acos(phi)) 6b5ffc8ac59b4fa68b87ff22195c477b--e8599dcbec1f40dfa37aa7ba0cc06dc4 3e921829f9994c7e9b13233ef118303c 1 1364f456f4ce4f97aa2e39fbbb1122c0 e8599dcbec1f40dfa37aa7ba0cc06dc4--1364f456f4ce4f97aa2e39fbbb1122c0 ac95e39b4c6747f68777bfa7db97ca69 087ae46a8a2d497c87983e768e7daa82 RX(1.414*acos(phi)) 3e921829f9994c7e9b13233ef118303c--087ae46a8a2d497c87983e768e7daa82 a8224d9c689b4715a8ce63bc593f5c82 2 087ae46a8a2d497c87983e768e7daa82--ac95e39b4c6747f68777bfa7db97ca69 856cd770878d44738f8679a3a5094b44 244f68a72d40473cae12179dadf1362c RX(1.732*acos(phi)) a8224d9c689b4715a8ce63bc593f5c82--244f68a72d40473cae12179dadf1362c 5d76a23baec44fd8a0fd02665d6b2120 3 244f68a72d40473cae12179dadf1362c--856cd770878d44738f8679a3a5094b44 9a6f098950be48a8a216400cdb1380c2 4ccbc8e9c91c4fef9c7f3c9503f74d64 RX(2.0*acos(phi)) 5d76a23baec44fd8a0fd02665d6b2120--4ccbc8e9c91c4fef9c7f3c9503f74d64 0c15e0e2606e4f19809b74ffd30a09fd 4 4ccbc8e9c91c4fef9c7f3c9503f74d64--9a6f098950be48a8a216400cdb1380c2 b61278cdf44e45a99faf5c68b1da9ca4 e9beb791cfc846e8a2821a0c795f36d6 RX(2.236*acos(phi)) 0c15e0e2606e4f19809b74ffd30a09fd--e9beb791cfc846e8a2821a0c795f36d6 e9beb791cfc846e8a2821a0c795f36d6--b61278cdf44e45a99faf5c68b1da9ca4 <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 c5e79596def64dd38c3cae65f607fffc 0 33670cfb072d41dcbb8574314037c6f3 RY(80.0*acos(0.667*x + 1.667)) c5e79596def64dd38c3cae65f607fffc--33670cfb072d41dcbb8574314037c6f3 4faff9011067408296d8acdd8e0d9028 1 18f7934d39064ac9b97b96841a289725 33670cfb072d41dcbb8574314037c6f3--18f7934d39064ac9b97b96841a289725 6a0b7e0524ac4a4e984c156c462f3a1f b5e5d6846dc949c795866c67282f91a7 RY(40.0*acos(0.667*x + 1.667)) 4faff9011067408296d8acdd8e0d9028--b5e5d6846dc949c795866c67282f91a7 769b25be35fe49c08934f358d4222e64 2 b5e5d6846dc949c795866c67282f91a7--6a0b7e0524ac4a4e984c156c462f3a1f 2656cfa1bf2f4a4ea5f679b21a2f1cdc 7c6024d78cc74279b4f3615a55d6c4f0 RY(20.0*acos(0.667*x + 1.667)) 769b25be35fe49c08934f358d4222e64--7c6024d78cc74279b4f3615a55d6c4f0 e004d2cf137f4d9d86436caf867505ea 3 7c6024d78cc74279b4f3615a55d6c4f0--2656cfa1bf2f4a4ea5f679b21a2f1cdc d40487908b1c4629a49f6f77ae248190 572a43f5b4844f8fb2f92c7c5633cbb0 RY(10.0*acos(0.667*x + 1.667)) e004d2cf137f4d9d86436caf867505ea--572a43f5b4844f8fb2f92c7c5633cbb0 b7a9d9dac33447b590bd8a32de93ff17 4 572a43f5b4844f8fb2f92c7c5633cbb0--d40487908b1c4629a49f6f77ae248190 9c191ac1af5646e8b544a20fe897305a a6ddfc0b0abc4ad7b1ee8f4db9e83168 RY(5.0*acos(0.667*x + 1.667)) b7a9d9dac33447b590bd8a32de93ff17--a6ddfc0b0abc4ad7b1ee8f4db9e83168 a6ddfc0b0abc4ad7b1ee8f4db9e83168--9c191ac1af5646e8b544a20fe897305a"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 6995d35613fd40d68e46622961a5aa37 0 09380df27f9f4a0bb03f579a89152652 RX(theta\u2080) 6995d35613fd40d68e46622961a5aa37--09380df27f9f4a0bb03f579a89152652 7e200a57e5884bc7840ac31f81856e0a 1 35c3da000f464346b3424436df3e762b RY(theta\u2083) 09380df27f9f4a0bb03f579a89152652--35c3da000f464346b3424436df3e762b 613a727cd0e049269ac7d046403cdbf1 RX(theta\u2086) 35c3da000f464346b3424436df3e762b--613a727cd0e049269ac7d046403cdbf1 acfb249e09c04dff9d53d184432f16bb 613a727cd0e049269ac7d046403cdbf1--acfb249e09c04dff9d53d184432f16bb ad427ac56968446882f205e5cececf70 acfb249e09c04dff9d53d184432f16bb--ad427ac56968446882f205e5cececf70 bd5b8bbaad414057918e3fea839c739e RX(theta\u2089) ad427ac56968446882f205e5cececf70--bd5b8bbaad414057918e3fea839c739e fdf170dba3e64d3cbe84eb869f92f20f RY(theta\u2081\u2082) bd5b8bbaad414057918e3fea839c739e--fdf170dba3e64d3cbe84eb869f92f20f 5d670825daf7487e9662e99ccee03860 RX(theta\u2081\u2085) fdf170dba3e64d3cbe84eb869f92f20f--5d670825daf7487e9662e99ccee03860 42d4157b832546f4abde37584caf85bd 5d670825daf7487e9662e99ccee03860--42d4157b832546f4abde37584caf85bd 9aa6d6d6a4b94837b76cd642e88b2295 42d4157b832546f4abde37584caf85bd--9aa6d6d6a4b94837b76cd642e88b2295 737add4191a2481b833816a09ace53e1 9aa6d6d6a4b94837b76cd642e88b2295--737add4191a2481b833816a09ace53e1 58e20f193377413cb2e1396b19711b4e 7a41504db7b344faabc4b12d4bb90e8d RX(theta\u2081) 7e200a57e5884bc7840ac31f81856e0a--7a41504db7b344faabc4b12d4bb90e8d 66de8a6ee66f4b7d86e6fc10e9ee9f66 2 f49a2f038133463690e3baf443f0d6a9 RY(theta\u2084) 7a41504db7b344faabc4b12d4bb90e8d--f49a2f038133463690e3baf443f0d6a9 d00a1087787a4091ada35129d22da798 RX(theta\u2087) f49a2f038133463690e3baf443f0d6a9--d00a1087787a4091ada35129d22da798 aa74309a43514567bc66588c428f2578 X d00a1087787a4091ada35129d22da798--aa74309a43514567bc66588c428f2578 aa74309a43514567bc66588c428f2578--acfb249e09c04dff9d53d184432f16bb 07c244c8068d42229b63633f90a11e01 aa74309a43514567bc66588c428f2578--07c244c8068d42229b63633f90a11e01 a66e1ccb31324c828822892b2173156f RX(theta\u2081\u2080) 07c244c8068d42229b63633f90a11e01--a66e1ccb31324c828822892b2173156f e3b3ce10e73d4bb4aedff7189a448073 RY(theta\u2081\u2083) a66e1ccb31324c828822892b2173156f--e3b3ce10e73d4bb4aedff7189a448073 7ef9bbdcc4204741829d8ed0ac79eb49 RX(theta\u2081\u2086) e3b3ce10e73d4bb4aedff7189a448073--7ef9bbdcc4204741829d8ed0ac79eb49 3b6b443cbca24f8ba14d72d3974c05a5 X 7ef9bbdcc4204741829d8ed0ac79eb49--3b6b443cbca24f8ba14d72d3974c05a5 3b6b443cbca24f8ba14d72d3974c05a5--42d4157b832546f4abde37584caf85bd 80d4ee8ce6a843e5856deb7caa4fbc89 3b6b443cbca24f8ba14d72d3974c05a5--80d4ee8ce6a843e5856deb7caa4fbc89 80d4ee8ce6a843e5856deb7caa4fbc89--58e20f193377413cb2e1396b19711b4e 1d903356e923458fa59fcccf99f5fe26 fddf4d7ea07549259764c55b5e1e1245 RX(theta\u2082) 66de8a6ee66f4b7d86e6fc10e9ee9f66--fddf4d7ea07549259764c55b5e1e1245 958691b439824c85993ae5613c347f8f RY(theta\u2085) fddf4d7ea07549259764c55b5e1e1245--958691b439824c85993ae5613c347f8f 992a3b59b1e7419986d4d91b1ce6e9e4 RX(theta\u2088) 958691b439824c85993ae5613c347f8f--992a3b59b1e7419986d4d91b1ce6e9e4 eabc91192c72418d9d9f5c9032936afd 992a3b59b1e7419986d4d91b1ce6e9e4--eabc91192c72418d9d9f5c9032936afd c48d0b2456704b6eae6465dc5a6796ad X eabc91192c72418d9d9f5c9032936afd--c48d0b2456704b6eae6465dc5a6796ad c48d0b2456704b6eae6465dc5a6796ad--07c244c8068d42229b63633f90a11e01 03dc7abd535f4415aa888635a64aec08 RX(theta\u2081\u2081) c48d0b2456704b6eae6465dc5a6796ad--03dc7abd535f4415aa888635a64aec08 d58e3c529a4242148addab3c3aeebb3a RY(theta\u2081\u2084) 03dc7abd535f4415aa888635a64aec08--d58e3c529a4242148addab3c3aeebb3a 34f2c57c802647ea8a04a638cac9d76e RX(theta\u2081\u2087) d58e3c529a4242148addab3c3aeebb3a--34f2c57c802647ea8a04a638cac9d76e b4cd32aed6cd44d9912d4157f9c39d47 34f2c57c802647ea8a04a638cac9d76e--b4cd32aed6cd44d9912d4157f9c39d47 164ec3d61093411f9b5debdc4ce9097e X b4cd32aed6cd44d9912d4157f9c39d47--164ec3d61093411f9b5debdc4ce9097e 164ec3d61093411f9b5debdc4ce9097e--80d4ee8ce6a843e5856deb7caa4fbc89 164ec3d61093411f9b5debdc4ce9097e--1d903356e923458fa59fcccf99f5fe26 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 cbb8edc6d5ca4b6a8219b22a701092ed 0 7608df2cf4624503898d1a24061ef4a6 RX(phi\u2080) cbb8edc6d5ca4b6a8219b22a701092ed--7608df2cf4624503898d1a24061ef4a6 50c812ef29ac402999df3f57f1bd7d6c 1 9ecf9ca93c504d7b80ff2e7f05e47112 RY(phi\u2083) 7608df2cf4624503898d1a24061ef4a6--9ecf9ca93c504d7b80ff2e7f05e47112 0d17d58c69d34b9db8669bf892f21b89 RX(phi\u2086) 9ecf9ca93c504d7b80ff2e7f05e47112--0d17d58c69d34b9db8669bf892f21b89 30eed80745d941c08c81aba8f2d7b69a 0d17d58c69d34b9db8669bf892f21b89--30eed80745d941c08c81aba8f2d7b69a 0ebba8d374c54024916c42274da97f86 30eed80745d941c08c81aba8f2d7b69a--0ebba8d374c54024916c42274da97f86 6971b0877fc9452986f747a5da94a269 RX(phi\u2089) 0ebba8d374c54024916c42274da97f86--6971b0877fc9452986f747a5da94a269 2c30fa01a2fe47bdb36cb4060d352c61 RY(phi\u2081\u2082) 6971b0877fc9452986f747a5da94a269--2c30fa01a2fe47bdb36cb4060d352c61 fc2677b0d1934a9ba64489c491ecd00c RX(phi\u2081\u2085) 2c30fa01a2fe47bdb36cb4060d352c61--fc2677b0d1934a9ba64489c491ecd00c 18d544af14fe4c81b73021d711f0ca12 fc2677b0d1934a9ba64489c491ecd00c--18d544af14fe4c81b73021d711f0ca12 31be4714d02e43ce88758dc079bb3812 18d544af14fe4c81b73021d711f0ca12--31be4714d02e43ce88758dc079bb3812 ff6df7a63214444eb7f6f7b04127956a 31be4714d02e43ce88758dc079bb3812--ff6df7a63214444eb7f6f7b04127956a ccbf78241cdc482a99f3b480fb4b5141 4fc6bf8a3ef649458ec347f0801f095b RX(phi\u2081) 50c812ef29ac402999df3f57f1bd7d6c--4fc6bf8a3ef649458ec347f0801f095b 82fa91dd85ab4a3e85916402bd022a18 2 05a90a211ea3499ea2d2d99c82ce3d98 RY(phi\u2084) 4fc6bf8a3ef649458ec347f0801f095b--05a90a211ea3499ea2d2d99c82ce3d98 121f4281d49b4dff849777ed134c0971 RX(phi\u2087) 05a90a211ea3499ea2d2d99c82ce3d98--121f4281d49b4dff849777ed134c0971 b4190cdea2f64afaa92ef4e061d757c6 PHASE(phi_ent\u2080) 121f4281d49b4dff849777ed134c0971--b4190cdea2f64afaa92ef4e061d757c6 b4190cdea2f64afaa92ef4e061d757c6--30eed80745d941c08c81aba8f2d7b69a 713f48b637c24d628b0ab6e676e980db b4190cdea2f64afaa92ef4e061d757c6--713f48b637c24d628b0ab6e676e980db 9f41cbc4349d471a97cb7e396a359102 RX(phi\u2081\u2080) 713f48b637c24d628b0ab6e676e980db--9f41cbc4349d471a97cb7e396a359102 f1aa1cf697a64307a7b85dc38f64a532 RY(phi\u2081\u2083) 9f41cbc4349d471a97cb7e396a359102--f1aa1cf697a64307a7b85dc38f64a532 234e4c8ea6f241b5a9319b54b52fc9ec RX(phi\u2081\u2086) f1aa1cf697a64307a7b85dc38f64a532--234e4c8ea6f241b5a9319b54b52fc9ec fa9eab96e009404687fa92550cd2982d PHASE(phi_ent\u2082) 234e4c8ea6f241b5a9319b54b52fc9ec--fa9eab96e009404687fa92550cd2982d fa9eab96e009404687fa92550cd2982d--18d544af14fe4c81b73021d711f0ca12 6bb7d7466ae4402d82b2e89b1d7169e2 fa9eab96e009404687fa92550cd2982d--6bb7d7466ae4402d82b2e89b1d7169e2 6bb7d7466ae4402d82b2e89b1d7169e2--ccbf78241cdc482a99f3b480fb4b5141 cf1812b3210a4518b3dc247655a89058 69b250b2e7ca45cea1d86ccb00cdd252 RX(phi\u2082) 82fa91dd85ab4a3e85916402bd022a18--69b250b2e7ca45cea1d86ccb00cdd252 4d261f3eb40043589dea111d7f7d6f22 RY(phi\u2085) 69b250b2e7ca45cea1d86ccb00cdd252--4d261f3eb40043589dea111d7f7d6f22 641f849ccfc547d494b2b9e2712febbf RX(phi\u2088) 4d261f3eb40043589dea111d7f7d6f22--641f849ccfc547d494b2b9e2712febbf c1d3ddc99f9f473b9a22411abaae340c 641f849ccfc547d494b2b9e2712febbf--c1d3ddc99f9f473b9a22411abaae340c 5681796fdf044def9b60953321c5a7d1 PHASE(phi_ent\u2081) c1d3ddc99f9f473b9a22411abaae340c--5681796fdf044def9b60953321c5a7d1 5681796fdf044def9b60953321c5a7d1--713f48b637c24d628b0ab6e676e980db bf00ebecc36241b2ac8eebc4b623cb9e RX(phi\u2081\u2081) 5681796fdf044def9b60953321c5a7d1--bf00ebecc36241b2ac8eebc4b623cb9e 8aa3775a87b74fdf94385e431efcd3f7 RY(phi\u2081\u2084) bf00ebecc36241b2ac8eebc4b623cb9e--8aa3775a87b74fdf94385e431efcd3f7 91fcb2c990a04e96b7191387478efd24 RX(phi\u2081\u2087) 8aa3775a87b74fdf94385e431efcd3f7--91fcb2c990a04e96b7191387478efd24 cebb1b317faf4a1b9cac6de5e32249f4 91fcb2c990a04e96b7191387478efd24--cebb1b317faf4a1b9cac6de5e32249f4 a75b33f5624e48deadc6abe4d9b248ab PHASE(phi_ent\u2083) cebb1b317faf4a1b9cac6de5e32249f4--a75b33f5624e48deadc6abe4d9b248ab a75b33f5624e48deadc6abe4d9b248ab--6bb7d7466ae4402d82b2e89b1d7169e2 a75b33f5624e48deadc6abe4d9b248ab--cf1812b3210a4518b3dc247655a89058 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_3c2525660ad64251a2de1933371c8857 cluster_1672897efcd1436a9f2b3f4eb473bd3c 350cc0a27a8343d0b2d26d6a8e42c475 0 e8ad1f20868e47cd93e4eb1c6bdf2389 RX(theta\u2080) 350cc0a27a8343d0b2d26d6a8e42c475--e8ad1f20868e47cd93e4eb1c6bdf2389 8e251c2eee564831aac347607c5f7735 1 7d1ba564f55340179f22a477b1362000 RY(theta\u2083) e8ad1f20868e47cd93e4eb1c6bdf2389--7d1ba564f55340179f22a477b1362000 e103c5ef909c433e8dc35171d118a14f RX(theta\u2086) 7d1ba564f55340179f22a477b1362000--e103c5ef909c433e8dc35171d118a14f cf49252bf71043c5b561ac02f0ef361c HamEvo e103c5ef909c433e8dc35171d118a14f--cf49252bf71043c5b561ac02f0ef361c 5333a505211e47b6b4baf0974cef9373 RX(theta\u2089) cf49252bf71043c5b561ac02f0ef361c--5333a505211e47b6b4baf0974cef9373 dd77ba4131984f2c84badd98b77c97f8 RY(theta\u2081\u2082) 5333a505211e47b6b4baf0974cef9373--dd77ba4131984f2c84badd98b77c97f8 7cd726851f5a465fbdb4e72d92b165df RX(theta\u2081\u2085) dd77ba4131984f2c84badd98b77c97f8--7cd726851f5a465fbdb4e72d92b165df aeb5865fcf334776b539999fadc32b5a HamEvo 7cd726851f5a465fbdb4e72d92b165df--aeb5865fcf334776b539999fadc32b5a 81e60b91988d48448c6bba008503136b aeb5865fcf334776b539999fadc32b5a--81e60b91988d48448c6bba008503136b 47b2f7aed9334690a9790b15e959186e d1c1d583312c4997aab57bea8387be1d RX(theta\u2081) 8e251c2eee564831aac347607c5f7735--d1c1d583312c4997aab57bea8387be1d 7d8d8ea1ce2844ebbf8ee3874c0c37e5 2 794de0e909e54f60873826fdfe6ca361 RY(theta\u2084) d1c1d583312c4997aab57bea8387be1d--794de0e909e54f60873826fdfe6ca361 5a99a466d36e4d0d8341864dd7762139 RX(theta\u2087) 794de0e909e54f60873826fdfe6ca361--5a99a466d36e4d0d8341864dd7762139 1ef489252c6942e8af743c201e8eb650 t = theta_t\u2080 5a99a466d36e4d0d8341864dd7762139--1ef489252c6942e8af743c201e8eb650 17b3749a53754bf28310077a72b87be4 RX(theta\u2081\u2080) 1ef489252c6942e8af743c201e8eb650--17b3749a53754bf28310077a72b87be4 3b50ad793c9f45f28e6dba49e50e1ed7 RY(theta\u2081\u2083) 17b3749a53754bf28310077a72b87be4--3b50ad793c9f45f28e6dba49e50e1ed7 eeba7833fd894874bb92a41d4c329aec RX(theta\u2081\u2086) 3b50ad793c9f45f28e6dba49e50e1ed7--eeba7833fd894874bb92a41d4c329aec fa74818ead0341adb7c466c4e6280321 t = theta_t\u2081 eeba7833fd894874bb92a41d4c329aec--fa74818ead0341adb7c466c4e6280321 fa74818ead0341adb7c466c4e6280321--47b2f7aed9334690a9790b15e959186e e685a0af33d749e6944489f649a044ca af7fd7f2e0b84876b2b6aac0885701ff RX(theta\u2082) 7d8d8ea1ce2844ebbf8ee3874c0c37e5--af7fd7f2e0b84876b2b6aac0885701ff c0895767e5a2400c99653197ee2218b7 RY(theta\u2085) af7fd7f2e0b84876b2b6aac0885701ff--c0895767e5a2400c99653197ee2218b7 b1e3dd138fb3469a95528af07bb469c3 RX(theta\u2088) c0895767e5a2400c99653197ee2218b7--b1e3dd138fb3469a95528af07bb469c3 0638ac33e6984bfba8a2231ac75addfe b1e3dd138fb3469a95528af07bb469c3--0638ac33e6984bfba8a2231ac75addfe 8adddcd06e354b2895cebec8181c85af RX(theta\u2081\u2081) 0638ac33e6984bfba8a2231ac75addfe--8adddcd06e354b2895cebec8181c85af 0f1659fef5974e0fbc4072da3a9b3fe0 RY(theta\u2081\u2084) 8adddcd06e354b2895cebec8181c85af--0f1659fef5974e0fbc4072da3a9b3fe0 8ee9d7f5982842aa943e896fac21c5e5 RX(theta\u2081\u2087) 0f1659fef5974e0fbc4072da3a9b3fe0--8ee9d7f5982842aa943e896fac21c5e5 a38f4be605f64f4eb62cb75c940e3c57 8ee9d7f5982842aa943e896fac21c5e5--a38f4be605f64f4eb62cb75c940e3c57 a38f4be605f64f4eb62cb75c940e3c57--e685a0af33d749e6944489f649a044ca <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_0695bcc5e64f4d6f99475eee8e2b3125 cluster_8be37f0dce5d4c0a956a095b242cc947 c80dfce0709442609bbeb773a5c22020 0 de65721bf809401c86baaf7a77593d80 RX(theta\u2080) c80dfce0709442609bbeb773a5c22020--de65721bf809401c86baaf7a77593d80 6048e2241420444784c92ef8b4c28ad7 1 81185a00dd7e4284aecf7e5082e03bdd RY(theta\u2086) de65721bf809401c86baaf7a77593d80--81185a00dd7e4284aecf7e5082e03bdd bceefe323ab44b9a9fbc2e7007bc0906 RX(theta\u2081\u2082) 81185a00dd7e4284aecf7e5082e03bdd--bceefe323ab44b9a9fbc2e7007bc0906 267ca25cc099428db7660f9ad02d79a1 bceefe323ab44b9a9fbc2e7007bc0906--267ca25cc099428db7660f9ad02d79a1 c2385ce1ba2d4524b1aa3f8562b2f60e RX(theta\u2081\u2088) 267ca25cc099428db7660f9ad02d79a1--c2385ce1ba2d4524b1aa3f8562b2f60e c4c970ea4ae84091bcd4f7570a337fb0 RY(theta\u2082\u2084) c2385ce1ba2d4524b1aa3f8562b2f60e--c4c970ea4ae84091bcd4f7570a337fb0 195929c527b94148bfcb80de5a4ca4a1 RX(theta\u2083\u2080) c4c970ea4ae84091bcd4f7570a337fb0--195929c527b94148bfcb80de5a4ca4a1 a56463ff521a4e809eb1279b9b2cfdbb 195929c527b94148bfcb80de5a4ca4a1--a56463ff521a4e809eb1279b9b2cfdbb a14d1bb0787d4b7eac449d985596d608 a56463ff521a4e809eb1279b9b2cfdbb--a14d1bb0787d4b7eac449d985596d608 4b08640d78734528b6769405057209fa 1b1b050fb736411ba5fc0c3d7f165b75 RX(theta\u2081) 6048e2241420444784c92ef8b4c28ad7--1b1b050fb736411ba5fc0c3d7f165b75 db6c9afed54f4e3eb94131bffd00b5d7 2 45e9138961c649469065fde57bddb1bc RY(theta\u2087) 1b1b050fb736411ba5fc0c3d7f165b75--45e9138961c649469065fde57bddb1bc f9215840b5ab4a20b53b3751061617ab RX(theta\u2081\u2083) 45e9138961c649469065fde57bddb1bc--f9215840b5ab4a20b53b3751061617ab 86692a73b7c643208cc70ab05703a498 f9215840b5ab4a20b53b3751061617ab--86692a73b7c643208cc70ab05703a498 3efefa19cff7442b95501a68db9dfbe1 RX(theta\u2081\u2089) 86692a73b7c643208cc70ab05703a498--3efefa19cff7442b95501a68db9dfbe1 729cd4f6ff5345049263bdf76b83bdb9 RY(theta\u2082\u2085) 3efefa19cff7442b95501a68db9dfbe1--729cd4f6ff5345049263bdf76b83bdb9 8c65c9174dad4f2b8c2ea5d7fd7fe1e7 RX(theta\u2083\u2081) 729cd4f6ff5345049263bdf76b83bdb9--8c65c9174dad4f2b8c2ea5d7fd7fe1e7 3331a080d5144c5c91a9f775b70bd70f 8c65c9174dad4f2b8c2ea5d7fd7fe1e7--3331a080d5144c5c91a9f775b70bd70f 3331a080d5144c5c91a9f775b70bd70f--4b08640d78734528b6769405057209fa 99a99232e9a44fc1b9d1aa7399596028 c85e025188804997b12a344553605b41 RX(theta\u2082) db6c9afed54f4e3eb94131bffd00b5d7--c85e025188804997b12a344553605b41 3b9348b146a14bfd994b06770080c91c 3 6511291892484edb8c5b1934b22a3b9a RY(theta\u2088) c85e025188804997b12a344553605b41--6511291892484edb8c5b1934b22a3b9a c72bc6bdc70d4a178dc91a91d4779ba1 RX(theta\u2081\u2084) 6511291892484edb8c5b1934b22a3b9a--c72bc6bdc70d4a178dc91a91d4779ba1 500e96e1daf24a09bb3b6939e20d4c4c HamEvo c72bc6bdc70d4a178dc91a91d4779ba1--500e96e1daf24a09bb3b6939e20d4c4c 4cc988aba2e44c75ae0a0e724e30aefb RX(theta\u2082\u2080) 500e96e1daf24a09bb3b6939e20d4c4c--4cc988aba2e44c75ae0a0e724e30aefb afa4374ad4f0424fbbc806c9eb5bb585 RY(theta\u2082\u2086) 4cc988aba2e44c75ae0a0e724e30aefb--afa4374ad4f0424fbbc806c9eb5bb585 7dd92b0bb13d4a55992c6fb801b1cf93 RX(theta\u2083\u2082) afa4374ad4f0424fbbc806c9eb5bb585--7dd92b0bb13d4a55992c6fb801b1cf93 92e53c7845d94abbbe3dac2bde281b40 HamEvo 7dd92b0bb13d4a55992c6fb801b1cf93--92e53c7845d94abbbe3dac2bde281b40 92e53c7845d94abbbe3dac2bde281b40--99a99232e9a44fc1b9d1aa7399596028 a3f59de32ba14c48b9a10a786ba1e1e8 3a4b865ecf3445e49e98386cbc1ed5e0 RX(theta\u2083) 3b9348b146a14bfd994b06770080c91c--3a4b865ecf3445e49e98386cbc1ed5e0 8fdc3f7b8fa74837b894a132db10bb58 4 5a7db74078624918bdba3c2c9b4c4b0b RY(theta\u2089) 3a4b865ecf3445e49e98386cbc1ed5e0--5a7db74078624918bdba3c2c9b4c4b0b 825085cc3d5e4b2bb7bef637a71b9abf RX(theta\u2081\u2085) 5a7db74078624918bdba3c2c9b4c4b0b--825085cc3d5e4b2bb7bef637a71b9abf 10cc75c99a6f44f5ad2257f80d23fbce t = theta_t\u2080 825085cc3d5e4b2bb7bef637a71b9abf--10cc75c99a6f44f5ad2257f80d23fbce 8bf1607bd856438d890a24ccc477caec RX(theta\u2082\u2081) 10cc75c99a6f44f5ad2257f80d23fbce--8bf1607bd856438d890a24ccc477caec c095c8e0945f4199a7db4da584068104 RY(theta\u2082\u2087) 8bf1607bd856438d890a24ccc477caec--c095c8e0945f4199a7db4da584068104 85da97f63d2d437ca92cf554033b7434 RX(theta\u2083\u2083) c095c8e0945f4199a7db4da584068104--85da97f63d2d437ca92cf554033b7434 6c230a9e704d4cb39b6e96904f961993 t = theta_t\u2081 85da97f63d2d437ca92cf554033b7434--6c230a9e704d4cb39b6e96904f961993 6c230a9e704d4cb39b6e96904f961993--a3f59de32ba14c48b9a10a786ba1e1e8 97f24f28e12347549ecb9e2ebf92160a 8aef7ce2f1fe49eba7c68034f2120080 RX(theta\u2084) 8fdc3f7b8fa74837b894a132db10bb58--8aef7ce2f1fe49eba7c68034f2120080 e963178d88794a04be562c38b896b7eb 5 a9aa6d36427741e4a37c830d01a7188f RY(theta\u2081\u2080) 8aef7ce2f1fe49eba7c68034f2120080--a9aa6d36427741e4a37c830d01a7188f d260149cc4f54f098717f8b2c96a62ea RX(theta\u2081\u2086) a9aa6d36427741e4a37c830d01a7188f--d260149cc4f54f098717f8b2c96a62ea 04d2522e9acb4508aa10b5ce2f8c5b9a d260149cc4f54f098717f8b2c96a62ea--04d2522e9acb4508aa10b5ce2f8c5b9a fe7942b229d14e52a378212584d2bf15 RX(theta\u2082\u2082) 04d2522e9acb4508aa10b5ce2f8c5b9a--fe7942b229d14e52a378212584d2bf15 307291cbccb744d982a50f626efcaf25 RY(theta\u2082\u2088) fe7942b229d14e52a378212584d2bf15--307291cbccb744d982a50f626efcaf25 4a09f7ddfda74a54bee9b33d53c3f123 RX(theta\u2083\u2084) 307291cbccb744d982a50f626efcaf25--4a09f7ddfda74a54bee9b33d53c3f123 584a2215fbe74e08975737391168c42c 4a09f7ddfda74a54bee9b33d53c3f123--584a2215fbe74e08975737391168c42c 584a2215fbe74e08975737391168c42c--97f24f28e12347549ecb9e2ebf92160a abf5eee635c1453eb50898ac8b451a2e a98e78bde7db4ebc9a36d0d544a1ad7b RX(theta\u2085) e963178d88794a04be562c38b896b7eb--a98e78bde7db4ebc9a36d0d544a1ad7b 60974cd4249d4f7bb33b1ec3f5fabfb2 RY(theta\u2081\u2081) a98e78bde7db4ebc9a36d0d544a1ad7b--60974cd4249d4f7bb33b1ec3f5fabfb2 fa074a9ba51440388354dfc8545afb5e RX(theta\u2081\u2087) 60974cd4249d4f7bb33b1ec3f5fabfb2--fa074a9ba51440388354dfc8545afb5e a70e60ff791f4e4886b7476b4f773eab fa074a9ba51440388354dfc8545afb5e--a70e60ff791f4e4886b7476b4f773eab bedc2629ec034188a287c3a898676142 RX(theta\u2082\u2083) a70e60ff791f4e4886b7476b4f773eab--bedc2629ec034188a287c3a898676142 4d0f55eb3be34aa1b7b0a2bd755f8c86 RY(theta\u2082\u2089) bedc2629ec034188a287c3a898676142--4d0f55eb3be34aa1b7b0a2bd755f8c86 85226da7c38c493b8fa4fd840fcf8b77 RX(theta\u2083\u2085) 4d0f55eb3be34aa1b7b0a2bd755f8c86--85226da7c38c493b8fa4fd840fcf8b77 c78060edae3b4730ba87328c25b32bea 85226da7c38c493b8fa4fd840fcf8b77--c78060edae3b4730ba87328c25b32bea c78060edae3b4730ba87328c25b32bea--abf5eee635c1453eb50898ac8b451a2e"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_f1c3fd2379344d10976203bafa7c419f BPMA-1 cluster_4ed1c0d7ea414c3ea334732d25ba2fc8 BPMA-0 00529e3ae1e946bcbf2ef99d02a42536 0 f2808bd48e624e86b6877c2129a83548 RX(alpha\u2080\u2080) 00529e3ae1e946bcbf2ef99d02a42536--f2808bd48e624e86b6877c2129a83548 19714666e2324bd9841b2a2550edc070 1 80624f58025941eabedbe3f3d0e9bfed RY(alpha\u2080\u2083) f2808bd48e624e86b6877c2129a83548--80624f58025941eabedbe3f3d0e9bfed cc4edda15a964666a4218df5be9598eb 80624f58025941eabedbe3f3d0e9bfed--cc4edda15a964666a4218df5be9598eb 3fb1241c25e445feafb3e342f4cf5622 cc4edda15a964666a4218df5be9598eb--3fb1241c25e445feafb3e342f4cf5622 81baf6379a424e6390423e1625e32aba RX(gamma\u2080\u2080) 3fb1241c25e445feafb3e342f4cf5622--81baf6379a424e6390423e1625e32aba 2caf110adf784b23a25c78265adad6f9 81baf6379a424e6390423e1625e32aba--2caf110adf784b23a25c78265adad6f9 e071cdc6ab224ec9b52cfb4dac8f1d0f 2caf110adf784b23a25c78265adad6f9--e071cdc6ab224ec9b52cfb4dac8f1d0f f99c9f34c2d742f3917de97bfba1ed80 RY(beta\u2080\u2083) e071cdc6ab224ec9b52cfb4dac8f1d0f--f99c9f34c2d742f3917de97bfba1ed80 1d8caf297d3941118b79c7d8367f79cd RX(beta\u2080\u2080) f99c9f34c2d742f3917de97bfba1ed80--1d8caf297d3941118b79c7d8367f79cd ee8faf27c67d4f07a88fbc7705274bae RX(alpha\u2081\u2080) 1d8caf297d3941118b79c7d8367f79cd--ee8faf27c67d4f07a88fbc7705274bae 8678bbe739c142b1baeeaffb4d1953aa RY(alpha\u2081\u2083) ee8faf27c67d4f07a88fbc7705274bae--8678bbe739c142b1baeeaffb4d1953aa b8d177b0b32645f59951ede264616942 8678bbe739c142b1baeeaffb4d1953aa--b8d177b0b32645f59951ede264616942 edb750492aac4051b084668e3fc802d4 b8d177b0b32645f59951ede264616942--edb750492aac4051b084668e3fc802d4 68b9c014bbc341b7bd50ee484524b081 RX(gamma\u2081\u2080) edb750492aac4051b084668e3fc802d4--68b9c014bbc341b7bd50ee484524b081 63fa17587c044a61b2420dc32327f5e3 68b9c014bbc341b7bd50ee484524b081--63fa17587c044a61b2420dc32327f5e3 3c31fe8aee5249359f71e96d0f49999b 63fa17587c044a61b2420dc32327f5e3--3c31fe8aee5249359f71e96d0f49999b eb866fd13672426aaed5118d080392b1 RY(beta\u2081\u2083) 3c31fe8aee5249359f71e96d0f49999b--eb866fd13672426aaed5118d080392b1 6540392ed18b4a0fb674f3fe6d90a351 RX(beta\u2081\u2080) eb866fd13672426aaed5118d080392b1--6540392ed18b4a0fb674f3fe6d90a351 7eef3c81373f43fca5e9f1dd2c047ee0 6540392ed18b4a0fb674f3fe6d90a351--7eef3c81373f43fca5e9f1dd2c047ee0 058f18bcf74941c3b1949884745c3e3c c9d3d8550ff14019bf3cef3e1cbc43f9 RX(alpha\u2080\u2081) 19714666e2324bd9841b2a2550edc070--c9d3d8550ff14019bf3cef3e1cbc43f9 0e4eac0ec1774525a3d42315255c3d5b 2 3a77f80130cc4e23bbe050b62f35803e RY(alpha\u2080\u2084) c9d3d8550ff14019bf3cef3e1cbc43f9--3a77f80130cc4e23bbe050b62f35803e c38507fa2b4548abb235d8d0527b4e2f X 3a77f80130cc4e23bbe050b62f35803e--c38507fa2b4548abb235d8d0527b4e2f c38507fa2b4548abb235d8d0527b4e2f--cc4edda15a964666a4218df5be9598eb 11d6ecb5f4ac444bafad45553d1aa91d c38507fa2b4548abb235d8d0527b4e2f--11d6ecb5f4ac444bafad45553d1aa91d 620cf5b0154c45c5bebf4e647d393feb RX(gamma\u2080\u2081) 11d6ecb5f4ac444bafad45553d1aa91d--620cf5b0154c45c5bebf4e647d393feb 8c0f9d1dfce547578addee96b46e122a 620cf5b0154c45c5bebf4e647d393feb--8c0f9d1dfce547578addee96b46e122a be640405a98e4386b6039fe03e7a3628 X 8c0f9d1dfce547578addee96b46e122a--be640405a98e4386b6039fe03e7a3628 be640405a98e4386b6039fe03e7a3628--e071cdc6ab224ec9b52cfb4dac8f1d0f 21c2ddc916a34e85834966ce6061522b RY(beta\u2080\u2084) be640405a98e4386b6039fe03e7a3628--21c2ddc916a34e85834966ce6061522b 49f88541d4a64e4ba47726b14ef00f68 RX(beta\u2080\u2081) 21c2ddc916a34e85834966ce6061522b--49f88541d4a64e4ba47726b14ef00f68 6e85e8d376634f41a3988a7b2283f2b4 RX(alpha\u2081\u2081) 49f88541d4a64e4ba47726b14ef00f68--6e85e8d376634f41a3988a7b2283f2b4 075a6efc245345acb5a4d3621f9c3243 RY(alpha\u2081\u2084) 6e85e8d376634f41a3988a7b2283f2b4--075a6efc245345acb5a4d3621f9c3243 f7f28ad5961e4b2dbb01ae500560aff6 X 075a6efc245345acb5a4d3621f9c3243--f7f28ad5961e4b2dbb01ae500560aff6 f7f28ad5961e4b2dbb01ae500560aff6--b8d177b0b32645f59951ede264616942 de8561eacc2c4ce1b68e5712241f9a3f f7f28ad5961e4b2dbb01ae500560aff6--de8561eacc2c4ce1b68e5712241f9a3f db22bd5079354016bf58aff19f36f141 RX(gamma\u2081\u2081) de8561eacc2c4ce1b68e5712241f9a3f--db22bd5079354016bf58aff19f36f141 8248a58c3f1e484b99b0747d96bb1bb5 db22bd5079354016bf58aff19f36f141--8248a58c3f1e484b99b0747d96bb1bb5 601655d0f2c64b10beee0f83f4c0b83c X 8248a58c3f1e484b99b0747d96bb1bb5--601655d0f2c64b10beee0f83f4c0b83c 601655d0f2c64b10beee0f83f4c0b83c--3c31fe8aee5249359f71e96d0f49999b 07430f358158425d85f00aaeb0cc6a47 RY(beta\u2081\u2084) 601655d0f2c64b10beee0f83f4c0b83c--07430f358158425d85f00aaeb0cc6a47 b64d4c7683024d0796d67f86d0dbb38e RX(beta\u2081\u2081) 07430f358158425d85f00aaeb0cc6a47--b64d4c7683024d0796d67f86d0dbb38e b64d4c7683024d0796d67f86d0dbb38e--058f18bcf74941c3b1949884745c3e3c 1b3c18d90b784c99bb293e61bc67e1ce 5a865f4066b8449a970b31e503aad41f RX(alpha\u2080\u2082) 0e4eac0ec1774525a3d42315255c3d5b--5a865f4066b8449a970b31e503aad41f 47344108432d426895bb5b54b8d63aac RY(alpha\u2080\u2085) 5a865f4066b8449a970b31e503aad41f--47344108432d426895bb5b54b8d63aac 8b83e7e25403440da59ebc95525efc06 47344108432d426895bb5b54b8d63aac--8b83e7e25403440da59ebc95525efc06 d914256a91a64c5b801624627cd26075 X 8b83e7e25403440da59ebc95525efc06--d914256a91a64c5b801624627cd26075 d914256a91a64c5b801624627cd26075--11d6ecb5f4ac444bafad45553d1aa91d 4ad0cefea6054ca1ba9d7b288fc43f04 RX(gamma\u2080\u2082) d914256a91a64c5b801624627cd26075--4ad0cefea6054ca1ba9d7b288fc43f04 8d60d59d63be45b5bbba957b3ffa8150 X 4ad0cefea6054ca1ba9d7b288fc43f04--8d60d59d63be45b5bbba957b3ffa8150 8d60d59d63be45b5bbba957b3ffa8150--8c0f9d1dfce547578addee96b46e122a e9aa665d65714dfa9e61193cf8b05140 8d60d59d63be45b5bbba957b3ffa8150--e9aa665d65714dfa9e61193cf8b05140 3939d733bfd241a6bca914465de0232d RY(beta\u2080\u2085) e9aa665d65714dfa9e61193cf8b05140--3939d733bfd241a6bca914465de0232d 28ab65a65a1e44a1908c61fb07cd40e2 RX(beta\u2080\u2082) 3939d733bfd241a6bca914465de0232d--28ab65a65a1e44a1908c61fb07cd40e2 638d41348a4e48c6ba37643df105975c RX(alpha\u2081\u2082) 28ab65a65a1e44a1908c61fb07cd40e2--638d41348a4e48c6ba37643df105975c 81665203ce434253ad0b516d0975fbed RY(alpha\u2081\u2085) 638d41348a4e48c6ba37643df105975c--81665203ce434253ad0b516d0975fbed 6cfa33fed8404920912a1c4d1b0da5c0 81665203ce434253ad0b516d0975fbed--6cfa33fed8404920912a1c4d1b0da5c0 c5ae91a147294724913a546af6f5cb28 X 6cfa33fed8404920912a1c4d1b0da5c0--c5ae91a147294724913a546af6f5cb28 c5ae91a147294724913a546af6f5cb28--de8561eacc2c4ce1b68e5712241f9a3f 37f7e70bedfb4b2394230decea644d9a RX(gamma\u2081\u2082) c5ae91a147294724913a546af6f5cb28--37f7e70bedfb4b2394230decea644d9a a2ff05e603c046549f9d3a416b9a7191 X 37f7e70bedfb4b2394230decea644d9a--a2ff05e603c046549f9d3a416b9a7191 a2ff05e603c046549f9d3a416b9a7191--8248a58c3f1e484b99b0747d96bb1bb5 fb3066282aa34bfca3bc642a6acef3b2 a2ff05e603c046549f9d3a416b9a7191--fb3066282aa34bfca3bc642a6acef3b2 5c57b953ec9e4b8eb954394a639c0088 RY(beta\u2081\u2085) fb3066282aa34bfca3bc642a6acef3b2--5c57b953ec9e4b8eb954394a639c0088 6b98815142b042b5a333cc65cacdd2a6 RX(beta\u2081\u2082) 5c57b953ec9e4b8eb954394a639c0088--6b98815142b042b5a333cc65cacdd2a6 6b98815142b042b5a333cc65cacdd2a6--1b3c18d90b784c99bb293e61bc67e1ce"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>This section introduces the various measurement protocols.</p>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>This section introduces mitigation protocols.</p>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'00': 50, '10': 50})]\nnoisy = [Counter({'00': 46, '10': 42, '01': 6, '11': 6})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0026]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9704]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': d4a5460a-adb4-4984-a8c8-bf37680c15e7, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 9f5ba281-932e-4b88-8dd0-a092e8df57d5, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 9e4ae555-7b43-4517-a5e6-931accb309d2, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 85b073ed-e9c1-4937-b845-83fff52a0ed0, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 15d7cf54-67e9-4efc-9a7d-cce8898ba1ea, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': eba7e985-93df-47f3-8005-c20b9f2f4871, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 1308202f-0d25-4cfc-9bfb-8483c423eded, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 9ca49c5e-7aaf-4608-8bc1-f921a08afc58, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': a119d573-1e30-42fb-a4c0-957aac205b6f, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ddef7855-9577-40d5-8317-0d4085fe7023, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 2b7c65ba-10d9-46f8-a46b-48927a9afdbf, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_2: tensor([0.8550], requires_grad=True)\n  theta_7: tensor([0.9841], requires_grad=True)\n  theta_5: tensor([0.1050], requires_grad=True)\n  theta_8: tensor([0.8725], requires_grad=True)\n  theta_0: tensor([0.1505], requires_grad=True)\n  theta_6: tensor([0.7025], requires_grad=True)\n  theta_1: tensor([0.0848], requires_grad=True)\n  theta_3: tensor([0.9275], requires_grad=True)\n  theta_4: tensor([0.7986], requires_grad=True)\n}\nembedded = {\n  d4a5460a-adb4-4984-a8c8-bf37680c15e7: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  9f5ba281-932e-4b88-8dd0-a092e8df57d5: tensor([2., 2.])\n  9e4ae555-7b43-4517-a5e6-931accb309d2: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n  85b073ed-e9c1-4937-b845-83fff52a0ed0: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n  15d7cf54-67e9-4efc-9a7d-cce8898ba1ea: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n  eba7e985-93df-47f3-8005-c20b9f2f4871: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n  1308202f-0d25-4cfc-9bfb-8483c423eded: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n  9ca49c5e-7aaf-4608-8bc1-f921a08afc58: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\n  a119d573-1e30-42fb-a4c0-957aac205b6f: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n  ddef7855-9577-40d5-8317-0d4085fe7023: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n  2b7c65ba-10d9-46f8-a46b-48927a9afdbf: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_7: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  theta_3: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n         -0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j],\n        [ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n         -0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'001': 194, '000': 157, '110': 121, '010': 121, '101': 113, '011': 102, '100': 100, '111': 92})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(d4a5460a-adb4-4984-a8c8-bf37680c15e7)-C----------------------------------------Rx(9e4ae555-7b43-4517-a5e6-931accb309d2)-Ry(eba7e985-93df-47f3-8005-c20b9f2f4871)-Rx(a119d573-1e30-42fb-a4c0-957aac205b6f)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(9f5ba281-932e-4b88-8dd0-a092e8df57d5)-X----------------------------------------Rx(85b073ed-e9c1-4937-b845-83fff52a0ed0)-Ry(1308202f-0d25-4cfc-9bfb-8483c423eded)-Rx(ddef7855-9577-40d5-8317-0d4085fe7023)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(15d7cf54-67e9-4efc-9a7d-cce8898ba1ea)-Ry(9ca49c5e-7aaf-4608-8bc1-f921a08afc58)-Rx(2b7c65ba-10d9-46f8-a46b-48927a9afdbf)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [1308202f-0d25-4cfc-9bfb-8483c423eded, 15d7cf54-67e9-4efc-9a7d-cce8898ba1ea, 2b7c65ba-10d9-46f8-a46b-48927a9afdbf, 85b073ed-e9c1-4937-b845-83fff52a0ed0, 9ca49c5e-7aaf-4608-8bc1-f921a08afc58, 9e4ae555-7b43-4517-a5e6-931accb309d2, 9f5ba281-932e-4b88-8dd0-a092e8df57d5, a119d573-1e30-42fb-a4c0-957aac205b6f, d4a5460a-adb4-4984-a8c8-bf37680c15e7, ddef7855-9577-40d5-8317-0d4085fe7023, eba7e985-93df-47f3-8005-c20b9f2f4871].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(0.55)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.15)-DEPO(0.1)-Ry(0.93)-DEPO(0.1)-Rx(0.70)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.03)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.08)-DEPO(0.1)-Ry(0.80)-DEPO(0.1)-Rx(0.98)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.85)-DEPO(0.1)-Ry(0.10)-DEPO(0.1)-Rx(0.87)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 b2c59af6d61446a5a59594cdb598e4a5 0 9714c79c82c94e4d95145e4cbe020269 X b2c59af6d61446a5a59594cdb598e4a5--9714c79c82c94e4d95145e4cbe020269 aa55b6457aa34d438b1c53fb28804972 1 57a34b50524542779dda97a9f58af5e2 9714c79c82c94e4d95145e4cbe020269--57a34b50524542779dda97a9f58af5e2 70d6f7678d7f4467811f8bf4218aaca0 93fc4463fe0f4fa0bd80febde6f465a8 Y aa55b6457aa34d438b1c53fb28804972--93fc4463fe0f4fa0bd80febde6f465a8 93fc4463fe0f4fa0bd80febde6f465a8--70d6f7678d7f4467811f8bf4218aaca0 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 c63ef315fdf6471b860cf68d7b2557bf 0 737cddb6828a4d3a8bf4a992bddcd36d RX(0.5) c63ef315fdf6471b860cf68d7b2557bf--737cddb6828a4d3a8bf4a992bddcd36d dd66532f297243f2bd69ade5aab79820 737cddb6828a4d3a8bf4a992bddcd36d--dd66532f297243f2bd69ade5aab79820 <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 e1b60682e5384f64ae4b4cf9ac6289fd 0 98499d4dff7a43c2b44668e1db11bf6f e1b60682e5384f64ae4b4cf9ac6289fd--98499d4dff7a43c2b44668e1db11bf6f 71ceaf3e012846caa098e20387324192 1 728c9be4437742ef8b952450e89eebeb 98499d4dff7a43c2b44668e1db11bf6f--728c9be4437742ef8b952450e89eebeb 1a95e2d315c14fdda66071f022d22c70 723106a9beed45c18f4b34aaed85c912 X 71ceaf3e012846caa098e20387324192--723106a9beed45c18f4b34aaed85c912 723106a9beed45c18f4b34aaed85c912--98499d4dff7a43c2b44668e1db11bf6f 723106a9beed45c18f4b34aaed85c912--1a95e2d315c14fdda66071f022d22c70 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 79b842bafbf748e4a69678ac013c374f 0 7a3c02a34f214c148af5d29ee043bd43 X 79b842bafbf748e4a69678ac013c374f--7a3c02a34f214c148af5d29ee043bd43 14c813a15f304286b26f9e89b0e430fa X 7a3c02a34f214c148af5d29ee043bd43--14c813a15f304286b26f9e89b0e430fa 78185856cede4689ae3b398246544577 14c813a15f304286b26f9e89b0e430fa--78185856cede4689ae3b398246544577 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 631e49abb7314a909ed378006605e2dc 0 22b058b2daa24e2b9f21eb3fd73a004e X 631e49abb7314a909ed378006605e2dc--22b058b2daa24e2b9f21eb3fd73a004e 9e238c2fe3f0493a9f6fd26df7d580da 1 9f890214bb564574a79ae1c4d6ad6ea4 22b058b2daa24e2b9f21eb3fd73a004e--9f890214bb564574a79ae1c4d6ad6ea4 d5f7585ab88343b19e505f3b1d004c84 9f890214bb564574a79ae1c4d6ad6ea4--d5f7585ab88343b19e505f3b1d004c84 d0f36e07be7a4cc490ca214668975f66 fad80dc65fdd4b9086f5079a9e768893 9e238c2fe3f0493a9f6fd26df7d580da--fad80dc65fdd4b9086f5079a9e768893 e0b7a5d7338a489b828a6bce1ccf14b6 X fad80dc65fdd4b9086f5079a9e768893--e0b7a5d7338a489b828a6bce1ccf14b6 e0b7a5d7338a489b828a6bce1ccf14b6--d0f36e07be7a4cc490ca214668975f66 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 67645dc80a624f90a0f82043729e071e 0 cc050147b63044e3841e3ba30297f447 X 67645dc80a624f90a0f82043729e071e--cc050147b63044e3841e3ba30297f447 52e344e4e2774841bf9205ee7a2ab954 1 036c7607a28f4472907e4a259d2756d2 cc050147b63044e3841e3ba30297f447--036c7607a28f4472907e4a259d2756d2 1609cddaff244298b7f374bbf453eaa2 95279b3250644c90a4866f3471c63554 X 52e344e4e2774841bf9205ee7a2ab954--95279b3250644c90a4866f3471c63554 95279b3250644c90a4866f3471c63554--1609cddaff244298b7f374bbf453eaa2 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_b39c43d141674ffebfd88fd7b49f34f9 subblock cluster_efe39f9ac72347dfa8a9d2d406eb7cc0 subblock 96c06ebe86e34029ad5a260022700275 0 bdb8a57009c44cdd8462bf42ea9e0cbc X 96c06ebe86e34029ad5a260022700275--bdb8a57009c44cdd8462bf42ea9e0cbc 2b0273c499c94528ab2e3b11ced6d41a 1 17aee307a0af4ab2b2a1b5ff92ba4e7e X bdb8a57009c44cdd8462bf42ea9e0cbc--17aee307a0af4ab2b2a1b5ff92ba4e7e dea79c185504469faa2f906c694bef3c 17aee307a0af4ab2b2a1b5ff92ba4e7e--dea79c185504469faa2f906c694bef3c 2271babdb9fc48b089f03220cab62fa1 dfc7ce2e3b4f45c1a963d926b87a2ac5 Y 2b0273c499c94528ab2e3b11ced6d41a--dfc7ce2e3b4f45c1a963d926b87a2ac5 5fff877121ae4867b9a2540fa8dffd22 2 2d8e40f0871b4d93bdd9a72ffb5c0de2 Y dfc7ce2e3b4f45c1a963d926b87a2ac5--2d8e40f0871b4d93bdd9a72ffb5c0de2 2d8e40f0871b4d93bdd9a72ffb5c0de2--2271babdb9fc48b089f03220cab62fa1 b38dcc4eca9b47c9b3c2008a1c628383 7f5f54428265491583e67719a414876c 5fff877121ae4867b9a2540fa8dffd22--7f5f54428265491583e67719a414876c a77f34e155714a84ae01aefa01025e14 3 c25af4e7fcab4f0686a6b1f90c17b633 7f5f54428265491583e67719a414876c--c25af4e7fcab4f0686a6b1f90c17b633 c25af4e7fcab4f0686a6b1f90c17b633--b38dcc4eca9b47c9b3c2008a1c628383 e8ecabf1032d4e76a0adce3e4ff1a087 fe2f33cfd7184dfc9a8fbcf5a2951f60 a77f34e155714a84ae01aefa01025e14--fe2f33cfd7184dfc9a8fbcf5a2951f60 59615f3561e14f81a200a9cd25014add 4 533e12744bdc4bd1bac4f69945a32be8 fe2f33cfd7184dfc9a8fbcf5a2951f60--533e12744bdc4bd1bac4f69945a32be8 533e12744bdc4bd1bac4f69945a32be8--e8ecabf1032d4e76a0adce3e4ff1a087 41a5dc806ace43ebb2370999e1bb63e1 b302cf6649a34d3490ccec13f38dfbd8 X 59615f3561e14f81a200a9cd25014add--b302cf6649a34d3490ccec13f38dfbd8 b302cf6649a34d3490ccec13f38dfbd8--fe2f33cfd7184dfc9a8fbcf5a2951f60 bf5f86781d1a4a6b995dae79029c1aab X b302cf6649a34d3490ccec13f38dfbd8--bf5f86781d1a4a6b995dae79029c1aab bf5f86781d1a4a6b995dae79029c1aab--533e12744bdc4bd1bac4f69945a32be8 bf5f86781d1a4a6b995dae79029c1aab--41a5dc806ace43ebb2370999e1bb63e1"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 257, '10': 254, '00': 251, '01': 238})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '010': 22, '000': 20})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[ 0.2630, -0.0138],\n        [ 0.0106,  0.0010]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9754+0.0000j, 0.0000-0.2203j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.9058+0.0000j, 0.0000-0.4237j],\n        [0.9047+0.0000j, 0.0000-0.4260j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5444+0.0000j, 0.8070+0.0000j, 0.0000-0.1279j, 0.0000-0.1896j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_1878b17140774df69963839f70afbcbb [* 2] cluster_72f95b9eb79c4ca6a832ca2d28719c82 Rotations 2f7b96f2847a44cda5bbd084774a58ff 0 4636664afce04e4eb1a00ecbf296aaa2 RX(phi/theta) 2f7b96f2847a44cda5bbd084774a58ff--4636664afce04e4eb1a00ecbf296aaa2 17016e39bff449b695f08cbe37791eb6 1 319e7a5f08824e6aae31ff80221cfaa4 RX(phi) 4636664afce04e4eb1a00ecbf296aaa2--319e7a5f08824e6aae31ff80221cfaa4 f301b43583b7461eb3b5d6b06d304128 RX(phi) 319e7a5f08824e6aae31ff80221cfaa4--f301b43583b7461eb3b5d6b06d304128 45c9eeffdf554279962d7a0868c91de3 RX(phi + theta) f301b43583b7461eb3b5d6b06d304128--45c9eeffdf554279962d7a0868c91de3 9a3bd2a2e1db41cf8fa189cefddb4ac8 45c9eeffdf554279962d7a0868c91de3--9a3bd2a2e1db41cf8fa189cefddb4ac8 00602ad6d692488aa0750952e77b0e0c 9a3bd2a2e1db41cf8fa189cefddb4ac8--00602ad6d692488aa0750952e77b0e0c 28406704f63d4265be66e32815be0dbf Z 00602ad6d692488aa0750952e77b0e0c--28406704f63d4265be66e32815be0dbf 1f9da4f681eb48eeb7d2cbb613d9e6ed 28406704f63d4265be66e32815be0dbf--1f9da4f681eb48eeb7d2cbb613d9e6ed b2346decb3b543029932a52b4a3120b9 e190c6715197452c94e9158ab7080a05 RY(2*theta) 17016e39bff449b695f08cbe37791eb6--e190c6715197452c94e9158ab7080a05 610ac34af9fa46c2b366f5a345ef4a7b 2 293077c9abaa46d38021757ce1b29290 RY(theta) e190c6715197452c94e9158ab7080a05--293077c9abaa46d38021757ce1b29290 6dfef1dce4354d0d956c69c627a4fb52 RY(theta) 293077c9abaa46d38021757ce1b29290--6dfef1dce4354d0d956c69c627a4fb52 aeaeb724b3f745a19ab1a920671dc436 RY(theta**2) 6dfef1dce4354d0d956c69c627a4fb52--aeaeb724b3f745a19ab1a920671dc436 eaff4e8f4d7a4e48b5c01bb5656f1861 X aeaeb724b3f745a19ab1a920671dc436--eaff4e8f4d7a4e48b5c01bb5656f1861 eaff4e8f4d7a4e48b5c01bb5656f1861--9a3bd2a2e1db41cf8fa189cefddb4ac8 3bdfd4dbd3074a9db5521668895a51ed eaff4e8f4d7a4e48b5c01bb5656f1861--3bdfd4dbd3074a9db5521668895a51ed 0f0bab4d300f4237b5abc21a95744f55 Z 3bdfd4dbd3074a9db5521668895a51ed--0f0bab4d300f4237b5abc21a95744f55 0f0bab4d300f4237b5abc21a95744f55--b2346decb3b543029932a52b4a3120b9 2c135d0b97794d6999d30c383c3e42bb 6813f2a97230492ba661277924e51641 RZ(cos(phi)) 610ac34af9fa46c2b366f5a345ef4a7b--6813f2a97230492ba661277924e51641 68580746152f4d1495b5de995b9f378f RZ(phi) 6813f2a97230492ba661277924e51641--68580746152f4d1495b5de995b9f378f 761f87b4564b464084bc906430c3fe82 RZ(phi) 68580746152f4d1495b5de995b9f378f--761f87b4564b464084bc906430c3fe82 b59291ccff3444949e1b69e10d255aec RZ(cos(phi)) 761f87b4564b464084bc906430c3fe82--b59291ccff3444949e1b69e10d255aec 2e37c356d37848eca1078dcfcfc897c1 b59291ccff3444949e1b69e10d255aec--2e37c356d37848eca1078dcfcfc897c1 c3696d7c3d0e49e4aebf9021b34c0b6f X 2e37c356d37848eca1078dcfcfc897c1--c3696d7c3d0e49e4aebf9021b34c0b6f c3696d7c3d0e49e4aebf9021b34c0b6f--3bdfd4dbd3074a9db5521668895a51ed 80eb7615825441ff882e0021c12702c4 Z c3696d7c3d0e49e4aebf9021b34c0b6f--80eb7615825441ff882e0021c12702c4 80eb7615825441ff882e0021c12702c4--2c135d0b97794d6999d30c383c3e42bb <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.3193]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9192+0.0000j, 0.2725+0.0000j, 0.0000-0.2725j, 0.0000-0.0808j],\n        [0.7623+0.0000j, 0.4257+0.0000j, 0.0000-0.4257j, 0.0000-0.2377j],\n        [0.7010+0.0000j, 0.4578+0.0000j, 0.0000-0.4578j, 0.0000-0.2990j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 119481c1227047c7ae105c6987d60979 0 5888d5a129c5480fa36f26ccfb6991c8 RX(theta\u2080) 119481c1227047c7ae105c6987d60979--5888d5a129c5480fa36f26ccfb6991c8 2ddbcfd7a3854deb91ddde37a8113064 1 4fd0b7f9b62c464abb6ae15a457296ff RY(theta\u2084) 5888d5a129c5480fa36f26ccfb6991c8--4fd0b7f9b62c464abb6ae15a457296ff 1c32de07faf44c4f9ab4b2ae61091f5f RX(theta\u2088) 4fd0b7f9b62c464abb6ae15a457296ff--1c32de07faf44c4f9ab4b2ae61091f5f e60414fc644a4b47b56ad4286e546c1e 1c32de07faf44c4f9ab4b2ae61091f5f--e60414fc644a4b47b56ad4286e546c1e d9ea428adc2d48ef9145f00cae2293f4 e60414fc644a4b47b56ad4286e546c1e--d9ea428adc2d48ef9145f00cae2293f4 d3afd98ae24242e39e999eeefe866bf7 RX(theta\u2081\u2082) d9ea428adc2d48ef9145f00cae2293f4--d3afd98ae24242e39e999eeefe866bf7 bd01f6f7bb2b4566ad3f56810749856c RY(theta\u2081\u2086) d3afd98ae24242e39e999eeefe866bf7--bd01f6f7bb2b4566ad3f56810749856c bd20cba0e5324900b003a1db4bda27b2 RX(theta\u2082\u2080) bd01f6f7bb2b4566ad3f56810749856c--bd20cba0e5324900b003a1db4bda27b2 c06780699efd4c96a5ec0216fd6e9247 bd20cba0e5324900b003a1db4bda27b2--c06780699efd4c96a5ec0216fd6e9247 3837313ae66f4170a412902173dd7d1c c06780699efd4c96a5ec0216fd6e9247--3837313ae66f4170a412902173dd7d1c 98603f2e03e14f969a4724be62c6dd16 3837313ae66f4170a412902173dd7d1c--98603f2e03e14f969a4724be62c6dd16 1a6de37a1fa3433bb6a5bc14c0478add 8a273d0cf657439093564bae5b121070 RX(theta\u2081) 2ddbcfd7a3854deb91ddde37a8113064--8a273d0cf657439093564bae5b121070 f98898231a77496e8dd73e5aeab060a3 2 a57f08d838ca4f8db70b205cf5cf6d2b RY(theta\u2085) 8a273d0cf657439093564bae5b121070--a57f08d838ca4f8db70b205cf5cf6d2b 77cff9713994473293eba8f4d9316f2f RX(theta\u2089) a57f08d838ca4f8db70b205cf5cf6d2b--77cff9713994473293eba8f4d9316f2f fe8c2c22afc94d54bac01311eaafa015 X 77cff9713994473293eba8f4d9316f2f--fe8c2c22afc94d54bac01311eaafa015 fe8c2c22afc94d54bac01311eaafa015--e60414fc644a4b47b56ad4286e546c1e 66b738b268974190881fd82e037b1100 fe8c2c22afc94d54bac01311eaafa015--66b738b268974190881fd82e037b1100 cf61bbfe1d7f4209906a783ae3cf2a30 RX(theta\u2081\u2083) 66b738b268974190881fd82e037b1100--cf61bbfe1d7f4209906a783ae3cf2a30 e9bbc57d80bf419c81af51a39b6165b0 RY(theta\u2081\u2087) cf61bbfe1d7f4209906a783ae3cf2a30--e9bbc57d80bf419c81af51a39b6165b0 11aaba8b0d9549c085903170005aeb2a RX(theta\u2082\u2081) e9bbc57d80bf419c81af51a39b6165b0--11aaba8b0d9549c085903170005aeb2a b32fe347645b4bbc9e7c61bb09a54163 X 11aaba8b0d9549c085903170005aeb2a--b32fe347645b4bbc9e7c61bb09a54163 b32fe347645b4bbc9e7c61bb09a54163--c06780699efd4c96a5ec0216fd6e9247 e91b731abde645a1b9620d1d727129b2 b32fe347645b4bbc9e7c61bb09a54163--e91b731abde645a1b9620d1d727129b2 e91b731abde645a1b9620d1d727129b2--1a6de37a1fa3433bb6a5bc14c0478add a2e6958ad8f0435ea26bf9c2888d05bd 1a0ba21334de41dd8936a044413f19d9 RX(theta\u2082) f98898231a77496e8dd73e5aeab060a3--1a0ba21334de41dd8936a044413f19d9 21dd2a701a314302b976ce47f9846947 3 89c366096013476fa19fa2209c078291 RY(theta\u2086) 1a0ba21334de41dd8936a044413f19d9--89c366096013476fa19fa2209c078291 72ed189305bf4334a168baa78043cb28 RX(theta\u2081\u2080) 89c366096013476fa19fa2209c078291--72ed189305bf4334a168baa78043cb28 9cca6bee9d2446fc923ad2acc1ce8e9f 72ed189305bf4334a168baa78043cb28--9cca6bee9d2446fc923ad2acc1ce8e9f 006b6bcf7d33453c99e4c5258672dcb0 X 9cca6bee9d2446fc923ad2acc1ce8e9f--006b6bcf7d33453c99e4c5258672dcb0 006b6bcf7d33453c99e4c5258672dcb0--66b738b268974190881fd82e037b1100 ec372181c7684ba3a55cbd7f665e17f7 RX(theta\u2081\u2084) 006b6bcf7d33453c99e4c5258672dcb0--ec372181c7684ba3a55cbd7f665e17f7 fa7d5c143417453599364469c2ff45b8 RY(theta\u2081\u2088) ec372181c7684ba3a55cbd7f665e17f7--fa7d5c143417453599364469c2ff45b8 2bb3b2f076e843aba9816b0b0fb012e8 RX(theta\u2082\u2082) fa7d5c143417453599364469c2ff45b8--2bb3b2f076e843aba9816b0b0fb012e8 c96ecf461b9149b3b31c0bb9c39855a0 2bb3b2f076e843aba9816b0b0fb012e8--c96ecf461b9149b3b31c0bb9c39855a0 a47fb27240cc41929b7e3e9971269fae X c96ecf461b9149b3b31c0bb9c39855a0--a47fb27240cc41929b7e3e9971269fae a47fb27240cc41929b7e3e9971269fae--e91b731abde645a1b9620d1d727129b2 a47fb27240cc41929b7e3e9971269fae--a2e6958ad8f0435ea26bf9c2888d05bd 1fe7d0dc2984481facc5a6c66977d1c1 1f07f57dc71c4016abb0e694da3a650d RX(theta\u2083) 21dd2a701a314302b976ce47f9846947--1f07f57dc71c4016abb0e694da3a650d db15590b5ea54ebf826d102e5ac71b33 RY(theta\u2087) 1f07f57dc71c4016abb0e694da3a650d--db15590b5ea54ebf826d102e5ac71b33 4a25b11da6304711966ba834f7aa08a7 RX(theta\u2081\u2081) db15590b5ea54ebf826d102e5ac71b33--4a25b11da6304711966ba834f7aa08a7 a590cc93288443279fa4d7d67deb8a05 X 4a25b11da6304711966ba834f7aa08a7--a590cc93288443279fa4d7d67deb8a05 a590cc93288443279fa4d7d67deb8a05--9cca6bee9d2446fc923ad2acc1ce8e9f 09b6b6dc080f467998167b3df46aead0 a590cc93288443279fa4d7d67deb8a05--09b6b6dc080f467998167b3df46aead0 6d65b2e027c74d5284cc6e38f8ad69ad RX(theta\u2081\u2085) 09b6b6dc080f467998167b3df46aead0--6d65b2e027c74d5284cc6e38f8ad69ad 73171b4bd7c34229a82cbfe2515ee750 RY(theta\u2081\u2089) 6d65b2e027c74d5284cc6e38f8ad69ad--73171b4bd7c34229a82cbfe2515ee750 f526c89a26d7451bbeb30ffe92dcd068 RX(theta\u2082\u2083) 73171b4bd7c34229a82cbfe2515ee750--f526c89a26d7451bbeb30ffe92dcd068 57feeeb6d73f430caaa3678bce8853b2 X f526c89a26d7451bbeb30ffe92dcd068--57feeeb6d73f430caaa3678bce8853b2 57feeeb6d73f430caaa3678bce8853b2--c96ecf461b9149b3b31c0bb9c39855a0 5b18cff3ad6144158be978d1b9f9fff1 57feeeb6d73f430caaa3678bce8853b2--5b18cff3ad6144158be978d1b9f9fff1 5b18cff3ad6144158be978d1b9f9fff1--1fe7d0dc2984481facc5a6c66977d1c1 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_3ec20ca48f8544b386be0f09460f261b HEA cluster_b7f92c08130745a99a62a5af71a6f85b HEA f3eae8d85f99446bbaeb4b1f790265cd 0 f9fd531827ae415596cd3d3825b16a27 RX(theta\u2080) f3eae8d85f99446bbaeb4b1f790265cd--f9fd531827ae415596cd3d3825b16a27 fd6fd3f9c69646d881c094344482ed0f 1 aafc3540ce0d43b291afaedf95f3fbe2 RY(theta\u2084) f9fd531827ae415596cd3d3825b16a27--aafc3540ce0d43b291afaedf95f3fbe2 aaca4ca4daca47fe82b1a4e8f2b3e6f9 RX(theta\u2088) aafc3540ce0d43b291afaedf95f3fbe2--aaca4ca4daca47fe82b1a4e8f2b3e6f9 6ce5ff6925dd472a8cce10d017faa77f aaca4ca4daca47fe82b1a4e8f2b3e6f9--6ce5ff6925dd472a8cce10d017faa77f 451b3ab439e44c339d19829623ed7831 6ce5ff6925dd472a8cce10d017faa77f--451b3ab439e44c339d19829623ed7831 1f29c9374d26489da4bdada5b335b50c RX(theta\u2081\u2082) 451b3ab439e44c339d19829623ed7831--1f29c9374d26489da4bdada5b335b50c d7f1e77ef04e465a9b7193c652bc9e2e RY(theta\u2081\u2086) 1f29c9374d26489da4bdada5b335b50c--d7f1e77ef04e465a9b7193c652bc9e2e 4fbbd822d26641d3a6c0643b1322d16c RX(theta\u2082\u2080) d7f1e77ef04e465a9b7193c652bc9e2e--4fbbd822d26641d3a6c0643b1322d16c 4beb31862ccb4d9a835a59525bfc213a 4fbbd822d26641d3a6c0643b1322d16c--4beb31862ccb4d9a835a59525bfc213a f8135534532b4113af466a40bdff67ff 4beb31862ccb4d9a835a59525bfc213a--f8135534532b4113af466a40bdff67ff 22e48831191e4013a68dbd96e026791a RX(theta\u2080) f8135534532b4113af466a40bdff67ff--22e48831191e4013a68dbd96e026791a f4dbc8cb613544559bdd375f018bcbd0 RY(theta\u2084) 22e48831191e4013a68dbd96e026791a--f4dbc8cb613544559bdd375f018bcbd0 91e2938b4d3b4c7c97682351666bdc6a RX(theta\u2088) f4dbc8cb613544559bdd375f018bcbd0--91e2938b4d3b4c7c97682351666bdc6a 5be1c851459945fb85be1cea122d23b1 91e2938b4d3b4c7c97682351666bdc6a--5be1c851459945fb85be1cea122d23b1 26f9675260df41a380ea829d188423b1 5be1c851459945fb85be1cea122d23b1--26f9675260df41a380ea829d188423b1 d14c4f79be964857a6a2adf2a9b57697 RX(theta\u2081\u2082) 26f9675260df41a380ea829d188423b1--d14c4f79be964857a6a2adf2a9b57697 9acf75ab196546a6925e69bb37deba2b RY(theta\u2081\u2086) d14c4f79be964857a6a2adf2a9b57697--9acf75ab196546a6925e69bb37deba2b e7f32dc950354fdca46fe1dd62a08126 RX(theta\u2082\u2080) 9acf75ab196546a6925e69bb37deba2b--e7f32dc950354fdca46fe1dd62a08126 13bdde4285a042f9905f53e5ae0639ff e7f32dc950354fdca46fe1dd62a08126--13bdde4285a042f9905f53e5ae0639ff 3755bb27ebfc4536b213682da20d8f18 13bdde4285a042f9905f53e5ae0639ff--3755bb27ebfc4536b213682da20d8f18 d02fe07ef9744fc3b7839d56cc6e68dd 3755bb27ebfc4536b213682da20d8f18--d02fe07ef9744fc3b7839d56cc6e68dd 48c2747fb51a48bebd64a9d435d698d0 b139f2ac0b15431f9a9ecba90855be1d RX(theta\u2081) fd6fd3f9c69646d881c094344482ed0f--b139f2ac0b15431f9a9ecba90855be1d bd999002853a433c8a5836cbd0b843d1 2 bf0dbb58d97e42e6a3b893b33fc2a1ad RY(theta\u2085) b139f2ac0b15431f9a9ecba90855be1d--bf0dbb58d97e42e6a3b893b33fc2a1ad 8cd0076d424949b6a353934ff80d194e RX(theta\u2089) bf0dbb58d97e42e6a3b893b33fc2a1ad--8cd0076d424949b6a353934ff80d194e b5488a1f2e8b48f9834165dfc428e8ab X 8cd0076d424949b6a353934ff80d194e--b5488a1f2e8b48f9834165dfc428e8ab b5488a1f2e8b48f9834165dfc428e8ab--6ce5ff6925dd472a8cce10d017faa77f fbc05a64222f41048e59b0cdc203c7e3 b5488a1f2e8b48f9834165dfc428e8ab--fbc05a64222f41048e59b0cdc203c7e3 575fafd749b24c719d61f8c818f182b5 RX(theta\u2081\u2083) fbc05a64222f41048e59b0cdc203c7e3--575fafd749b24c719d61f8c818f182b5 a271f1f64e024979b78a00918c6f2220 RY(theta\u2081\u2087) 575fafd749b24c719d61f8c818f182b5--a271f1f64e024979b78a00918c6f2220 e6cee60a5c1b47bc9fe9d0d625c1b20e RX(theta\u2082\u2081) a271f1f64e024979b78a00918c6f2220--e6cee60a5c1b47bc9fe9d0d625c1b20e 3e0e8e2015704acfa0da8f90646f3ed7 X e6cee60a5c1b47bc9fe9d0d625c1b20e--3e0e8e2015704acfa0da8f90646f3ed7 3e0e8e2015704acfa0da8f90646f3ed7--4beb31862ccb4d9a835a59525bfc213a 3da695effcae4567b62496e2bec18f37 3e0e8e2015704acfa0da8f90646f3ed7--3da695effcae4567b62496e2bec18f37 f00a2972244c4072bf9f5bba6f2c18b9 RX(theta\u2081) 3da695effcae4567b62496e2bec18f37--f00a2972244c4072bf9f5bba6f2c18b9 5e8be17466e74a52b167c311f73a0271 RY(theta\u2085) f00a2972244c4072bf9f5bba6f2c18b9--5e8be17466e74a52b167c311f73a0271 f1cab22b9b6f409b9b7015f95833f9d9 RX(theta\u2089) 5e8be17466e74a52b167c311f73a0271--f1cab22b9b6f409b9b7015f95833f9d9 2434127c5c69427e86f8fe7610754bb0 X f1cab22b9b6f409b9b7015f95833f9d9--2434127c5c69427e86f8fe7610754bb0 2434127c5c69427e86f8fe7610754bb0--5be1c851459945fb85be1cea122d23b1 a2bae53785f44264a1c5fbb4c5c59594 2434127c5c69427e86f8fe7610754bb0--a2bae53785f44264a1c5fbb4c5c59594 aada61551c0243828d97f3af4cc90f39 RX(theta\u2081\u2083) a2bae53785f44264a1c5fbb4c5c59594--aada61551c0243828d97f3af4cc90f39 3752a0ad1d8b41e88726afb84deec029 RY(theta\u2081\u2087) aada61551c0243828d97f3af4cc90f39--3752a0ad1d8b41e88726afb84deec029 a71fcde43bb24527a3ee53a63c03cc57 RX(theta\u2082\u2081) 3752a0ad1d8b41e88726afb84deec029--a71fcde43bb24527a3ee53a63c03cc57 00aef2cf112446f9a73d16a9c0e59d6e X a71fcde43bb24527a3ee53a63c03cc57--00aef2cf112446f9a73d16a9c0e59d6e 00aef2cf112446f9a73d16a9c0e59d6e--13bdde4285a042f9905f53e5ae0639ff 8f160c9b50a54918a1cc6ca216cd923c 00aef2cf112446f9a73d16a9c0e59d6e--8f160c9b50a54918a1cc6ca216cd923c 8f160c9b50a54918a1cc6ca216cd923c--48c2747fb51a48bebd64a9d435d698d0 5c67d16b82104952b2eefb2d6e07d344 54aca9725f234d6dabc3ee4bae04ce59 RX(theta\u2082) bd999002853a433c8a5836cbd0b843d1--54aca9725f234d6dabc3ee4bae04ce59 6fd4a6ee395441da8df2e95dafbb2035 3 6f8ee89702c54c0b921e97221677a3ff RY(theta\u2086) 54aca9725f234d6dabc3ee4bae04ce59--6f8ee89702c54c0b921e97221677a3ff d43563e721fb4adba330c6ab0ea233df RX(theta\u2081\u2080) 6f8ee89702c54c0b921e97221677a3ff--d43563e721fb4adba330c6ab0ea233df c4b585d6a54d469aaba7704460f1542f d43563e721fb4adba330c6ab0ea233df--c4b585d6a54d469aaba7704460f1542f 44abae0470864922963cb89e948cb078 X c4b585d6a54d469aaba7704460f1542f--44abae0470864922963cb89e948cb078 44abae0470864922963cb89e948cb078--fbc05a64222f41048e59b0cdc203c7e3 9363c6419eea4252a4006049b2162590 RX(theta\u2081\u2084) 44abae0470864922963cb89e948cb078--9363c6419eea4252a4006049b2162590 25123f54fdae41938d9535ffbafb7aa9 RY(theta\u2081\u2088) 9363c6419eea4252a4006049b2162590--25123f54fdae41938d9535ffbafb7aa9 16ee3d2974b5461ebf4cfa807d09fb6f RX(theta\u2082\u2082) 25123f54fdae41938d9535ffbafb7aa9--16ee3d2974b5461ebf4cfa807d09fb6f 8d2daa112b714f298c548bac22b4f76f 16ee3d2974b5461ebf4cfa807d09fb6f--8d2daa112b714f298c548bac22b4f76f cc5c006af26e4c37b02ab556fcff6eeb X 8d2daa112b714f298c548bac22b4f76f--cc5c006af26e4c37b02ab556fcff6eeb cc5c006af26e4c37b02ab556fcff6eeb--3da695effcae4567b62496e2bec18f37 b82faba301d34fe298b2bfb744405174 RX(theta\u2082) cc5c006af26e4c37b02ab556fcff6eeb--b82faba301d34fe298b2bfb744405174 604fec9da3b1488fa0481afd3fbfd4c4 RY(theta\u2086) b82faba301d34fe298b2bfb744405174--604fec9da3b1488fa0481afd3fbfd4c4 7b090c75164041d9b333a96cbec6c2fb RX(theta\u2081\u2080) 604fec9da3b1488fa0481afd3fbfd4c4--7b090c75164041d9b333a96cbec6c2fb 7f547dadcd3d4efd9ef8a46b2baebd4a 7b090c75164041d9b333a96cbec6c2fb--7f547dadcd3d4efd9ef8a46b2baebd4a 884288bed6174940984f9137484573a3 X 7f547dadcd3d4efd9ef8a46b2baebd4a--884288bed6174940984f9137484573a3 884288bed6174940984f9137484573a3--a2bae53785f44264a1c5fbb4c5c59594 75ac2ba8625a4202a014367ed0a89e42 RX(theta\u2081\u2084) 884288bed6174940984f9137484573a3--75ac2ba8625a4202a014367ed0a89e42 dbbce75ac7d24c879d18bbc4ae172ab4 RY(theta\u2081\u2088) 75ac2ba8625a4202a014367ed0a89e42--dbbce75ac7d24c879d18bbc4ae172ab4 2d71efa8c6164c38916df414220b16af RX(theta\u2082\u2082) dbbce75ac7d24c879d18bbc4ae172ab4--2d71efa8c6164c38916df414220b16af 919e14f53935462e9ec475c9149bb129 2d71efa8c6164c38916df414220b16af--919e14f53935462e9ec475c9149bb129 8a60c39432b84eb98c8b5485d1f881bb X 919e14f53935462e9ec475c9149bb129--8a60c39432b84eb98c8b5485d1f881bb 8a60c39432b84eb98c8b5485d1f881bb--8f160c9b50a54918a1cc6ca216cd923c 8a60c39432b84eb98c8b5485d1f881bb--5c67d16b82104952b2eefb2d6e07d344 18987bd187ed4410b35465c1cd8f63b4 4d430131687a4622bb1aeb1ab96fbfe0 RX(theta\u2083) 6fd4a6ee395441da8df2e95dafbb2035--4d430131687a4622bb1aeb1ab96fbfe0 87fa23d15638469db46f34941d766718 RY(theta\u2087) 4d430131687a4622bb1aeb1ab96fbfe0--87fa23d15638469db46f34941d766718 b30ab8bc938b4bb787a802cdf96134d1 RX(theta\u2081\u2081) 87fa23d15638469db46f34941d766718--b30ab8bc938b4bb787a802cdf96134d1 6e9fff7565624716bc46f34fcaf7607d X b30ab8bc938b4bb787a802cdf96134d1--6e9fff7565624716bc46f34fcaf7607d 6e9fff7565624716bc46f34fcaf7607d--c4b585d6a54d469aaba7704460f1542f c839cb8010184ca09a9ba34179710db7 6e9fff7565624716bc46f34fcaf7607d--c839cb8010184ca09a9ba34179710db7 a9850d6ce48448f089cdf3a2258f8d32 RX(theta\u2081\u2085) c839cb8010184ca09a9ba34179710db7--a9850d6ce48448f089cdf3a2258f8d32 78e2b10868ad4ea4b3a3526b75501afa RY(theta\u2081\u2089) a9850d6ce48448f089cdf3a2258f8d32--78e2b10868ad4ea4b3a3526b75501afa ac1b22285903449fbc2e2d0afc740f00 RX(theta\u2082\u2083) 78e2b10868ad4ea4b3a3526b75501afa--ac1b22285903449fbc2e2d0afc740f00 5f874b77b2dc4608a57e9810c0a06a32 X ac1b22285903449fbc2e2d0afc740f00--5f874b77b2dc4608a57e9810c0a06a32 5f874b77b2dc4608a57e9810c0a06a32--8d2daa112b714f298c548bac22b4f76f 5cb16cfecdae444fab52f3ed886e5411 5f874b77b2dc4608a57e9810c0a06a32--5cb16cfecdae444fab52f3ed886e5411 a6f453038fc84c149b71ffdb9769af89 RX(theta\u2083) 5cb16cfecdae444fab52f3ed886e5411--a6f453038fc84c149b71ffdb9769af89 a13bfc77ff4742aa9951d3ce7769892e RY(theta\u2087) a6f453038fc84c149b71ffdb9769af89--a13bfc77ff4742aa9951d3ce7769892e cd8313a70b9a41ee9ea3dffca49808a6 RX(theta\u2081\u2081) a13bfc77ff4742aa9951d3ce7769892e--cd8313a70b9a41ee9ea3dffca49808a6 b664969d77f14d4e84db548240d847b7 X cd8313a70b9a41ee9ea3dffca49808a6--b664969d77f14d4e84db548240d847b7 b664969d77f14d4e84db548240d847b7--7f547dadcd3d4efd9ef8a46b2baebd4a bf1b4573510243b399bb2a8cb58eb625 b664969d77f14d4e84db548240d847b7--bf1b4573510243b399bb2a8cb58eb625 36630a8fb1ba41ca821177e2c7b77b90 RX(theta\u2081\u2085) bf1b4573510243b399bb2a8cb58eb625--36630a8fb1ba41ca821177e2c7b77b90 a9d9fd59bcad41a490981e64949982cd RY(theta\u2081\u2089) 36630a8fb1ba41ca821177e2c7b77b90--a9d9fd59bcad41a490981e64949982cd dc830c2050c04a3a9b4d72a6a05d3399 RX(theta\u2082\u2083) a9d9fd59bcad41a490981e64949982cd--dc830c2050c04a3a9b4d72a6a05d3399 4fbc37d524fb49b0b3599909b90eab56 X dc830c2050c04a3a9b4d72a6a05d3399--4fbc37d524fb49b0b3599909b90eab56 4fbc37d524fb49b0b3599909b90eab56--919e14f53935462e9ec475c9149bb129 d06f9a16b29648f6a74f626781eff512 4fbc37d524fb49b0b3599909b90eab56--d06f9a16b29648f6a74f626781eff512 d06f9a16b29648f6a74f626781eff512--18987bd187ed4410b35465c1cd8f63b4 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_1ed5770298874a3f800ebd8bc188bca9 HEA cluster_1125f47fbb2c43faadb7b35b1c31694c HEA 72c39073b21d4b8ebbb2a429e04a1040 0 886c3ba94e8749e8ac7ba54143964341 RX(p1\u2080) 72c39073b21d4b8ebbb2a429e04a1040--886c3ba94e8749e8ac7ba54143964341 1e24d33f1d51470abb13b49eb848d883 1 d6112eb383ff4e61a57b6543a393a5f2 RY(p1\u2084) 886c3ba94e8749e8ac7ba54143964341--d6112eb383ff4e61a57b6543a393a5f2 97a7a5572c9143608ec9c079c046d066 RX(p1\u2088) d6112eb383ff4e61a57b6543a393a5f2--97a7a5572c9143608ec9c079c046d066 c228215d4529408abd8544b73e7eb840 97a7a5572c9143608ec9c079c046d066--c228215d4529408abd8544b73e7eb840 c6f0be2e8164421888faa1ceaef84f83 c228215d4529408abd8544b73e7eb840--c6f0be2e8164421888faa1ceaef84f83 65b29d94e1e746769613fd5e7313402a RX(p1\u2081\u2082) c6f0be2e8164421888faa1ceaef84f83--65b29d94e1e746769613fd5e7313402a ca4daaf1fd9642768d75107bdd463a35 RY(p1\u2081\u2086) 65b29d94e1e746769613fd5e7313402a--ca4daaf1fd9642768d75107bdd463a35 529c9128858b446f94bbf486ac16f667 RX(p1\u2082\u2080) ca4daaf1fd9642768d75107bdd463a35--529c9128858b446f94bbf486ac16f667 7d9d3f32297f4e30b8450313fa042642 529c9128858b446f94bbf486ac16f667--7d9d3f32297f4e30b8450313fa042642 1b0124e204d4430993cf5e86b0d38b4a 7d9d3f32297f4e30b8450313fa042642--1b0124e204d4430993cf5e86b0d38b4a 1fdd60b0339a4ec3abbd3410005554dc RX(p2\u2080) 1b0124e204d4430993cf5e86b0d38b4a--1fdd60b0339a4ec3abbd3410005554dc 97986235897942e1b15bb440acdfe2a5 RY(p2\u2084) 1fdd60b0339a4ec3abbd3410005554dc--97986235897942e1b15bb440acdfe2a5 14b1f2604ac14412b8e966ef3879ae6a RX(p2\u2088) 97986235897942e1b15bb440acdfe2a5--14b1f2604ac14412b8e966ef3879ae6a 400156121fed488eb5bc27b4c94d4083 14b1f2604ac14412b8e966ef3879ae6a--400156121fed488eb5bc27b4c94d4083 afb3a3a76a1d4faba8287cfd0510b2e4 400156121fed488eb5bc27b4c94d4083--afb3a3a76a1d4faba8287cfd0510b2e4 74dab1caaaf04699a86ba93458f1f058 RX(p2\u2081\u2082) afb3a3a76a1d4faba8287cfd0510b2e4--74dab1caaaf04699a86ba93458f1f058 05c2724b629d48f896336fa546187e21 RY(p2\u2081\u2086) 74dab1caaaf04699a86ba93458f1f058--05c2724b629d48f896336fa546187e21 d77f9c1ff56e41949152c026e1ebd177 RX(p2\u2082\u2080) 05c2724b629d48f896336fa546187e21--d77f9c1ff56e41949152c026e1ebd177 f39359304f634fd6bd92a10be2c70c17 d77f9c1ff56e41949152c026e1ebd177--f39359304f634fd6bd92a10be2c70c17 2ad93507ca144598ae2e6c6ecf541fee f39359304f634fd6bd92a10be2c70c17--2ad93507ca144598ae2e6c6ecf541fee 82a4cd5b9d3c4dcfb963f54bf2384f4a 2ad93507ca144598ae2e6c6ecf541fee--82a4cd5b9d3c4dcfb963f54bf2384f4a 4cff4e7ce9644a518f58fd1e3e377822 3e958a36186f48f094925a8aee96a98a RX(p1\u2081) 1e24d33f1d51470abb13b49eb848d883--3e958a36186f48f094925a8aee96a98a f749cbe2831d40839120e5d5e451f3c7 2 8b00e7ed100142cb846b9233404f4df5 RY(p1\u2085) 3e958a36186f48f094925a8aee96a98a--8b00e7ed100142cb846b9233404f4df5 2e5cfc75322f465eaad013557bfdb7ab RX(p1\u2089) 8b00e7ed100142cb846b9233404f4df5--2e5cfc75322f465eaad013557bfdb7ab b88409c0236040b0bf22cf57e94e97bf X 2e5cfc75322f465eaad013557bfdb7ab--b88409c0236040b0bf22cf57e94e97bf b88409c0236040b0bf22cf57e94e97bf--c228215d4529408abd8544b73e7eb840 beaa530b0e564d359a21492bc24eb1af b88409c0236040b0bf22cf57e94e97bf--beaa530b0e564d359a21492bc24eb1af 59b1c3c373a246988f210f34784dde6b RX(p1\u2081\u2083) beaa530b0e564d359a21492bc24eb1af--59b1c3c373a246988f210f34784dde6b e1b142f345c642068869b0ed828d59c3 RY(p1\u2081\u2087) 59b1c3c373a246988f210f34784dde6b--e1b142f345c642068869b0ed828d59c3 8ab6d89f06de4d119af708deae8739fa RX(p1\u2082\u2081) e1b142f345c642068869b0ed828d59c3--8ab6d89f06de4d119af708deae8739fa 96a35520bf24485684b8929cd3acbe0a X 8ab6d89f06de4d119af708deae8739fa--96a35520bf24485684b8929cd3acbe0a 96a35520bf24485684b8929cd3acbe0a--7d9d3f32297f4e30b8450313fa042642 0fb98fb3242d4295acfa1699ca8e5623 96a35520bf24485684b8929cd3acbe0a--0fb98fb3242d4295acfa1699ca8e5623 e1267a9ac82c4b508650328babdcea17 RX(p2\u2081) 0fb98fb3242d4295acfa1699ca8e5623--e1267a9ac82c4b508650328babdcea17 5294409c4cda438db8c777b9c04582ff RY(p2\u2085) e1267a9ac82c4b508650328babdcea17--5294409c4cda438db8c777b9c04582ff e3008dbbf46b4e3b9d6683ca49d86803 RX(p2\u2089) 5294409c4cda438db8c777b9c04582ff--e3008dbbf46b4e3b9d6683ca49d86803 361b3aae84c24d4fb7b0d5a1faa1da66 X e3008dbbf46b4e3b9d6683ca49d86803--361b3aae84c24d4fb7b0d5a1faa1da66 361b3aae84c24d4fb7b0d5a1faa1da66--400156121fed488eb5bc27b4c94d4083 b29031359b2144e78732b9693cba6267 361b3aae84c24d4fb7b0d5a1faa1da66--b29031359b2144e78732b9693cba6267 1c5df76d2dae4eeca5ccbe2d70b18a13 RX(p2\u2081\u2083) b29031359b2144e78732b9693cba6267--1c5df76d2dae4eeca5ccbe2d70b18a13 b82632ce9ba540cebdf6cbfa70a29b9c RY(p2\u2081\u2087) 1c5df76d2dae4eeca5ccbe2d70b18a13--b82632ce9ba540cebdf6cbfa70a29b9c 7d2d99799dee4cd9b42ce4a47c495d1e RX(p2\u2082\u2081) b82632ce9ba540cebdf6cbfa70a29b9c--7d2d99799dee4cd9b42ce4a47c495d1e 990edf6a605d487590ba17209a7f771a X 7d2d99799dee4cd9b42ce4a47c495d1e--990edf6a605d487590ba17209a7f771a 990edf6a605d487590ba17209a7f771a--f39359304f634fd6bd92a10be2c70c17 8c3604775b0a4904bd5a3354e737deeb 990edf6a605d487590ba17209a7f771a--8c3604775b0a4904bd5a3354e737deeb 8c3604775b0a4904bd5a3354e737deeb--4cff4e7ce9644a518f58fd1e3e377822 4cf2da5a2f1443bdaa0d161c0e957559 5b6109c098a54ab2a3e777b4c94d01b8 RX(p1\u2082) f749cbe2831d40839120e5d5e451f3c7--5b6109c098a54ab2a3e777b4c94d01b8 dd9ba6e6fb954d0b85710d378248c162 3 a5b2bee893694d579c05197542223f0e RY(p1\u2086) 5b6109c098a54ab2a3e777b4c94d01b8--a5b2bee893694d579c05197542223f0e 1033093b53124bd99ab6dd11ea163e64 RX(p1\u2081\u2080) a5b2bee893694d579c05197542223f0e--1033093b53124bd99ab6dd11ea163e64 47be9533b29446c1b2a9fe80f7b20af6 1033093b53124bd99ab6dd11ea163e64--47be9533b29446c1b2a9fe80f7b20af6 ab082d39aa1c4d21a4d156e138d847fc X 47be9533b29446c1b2a9fe80f7b20af6--ab082d39aa1c4d21a4d156e138d847fc ab082d39aa1c4d21a4d156e138d847fc--beaa530b0e564d359a21492bc24eb1af c7150d82ecec4784a410a5b8f52bb86c RX(p1\u2081\u2084) ab082d39aa1c4d21a4d156e138d847fc--c7150d82ecec4784a410a5b8f52bb86c 9ef6527fcf8a4f53a9b9ff6935802deb RY(p1\u2081\u2088) c7150d82ecec4784a410a5b8f52bb86c--9ef6527fcf8a4f53a9b9ff6935802deb 10d91daf82a947219550b58d9a75ea50 RX(p1\u2082\u2082) 9ef6527fcf8a4f53a9b9ff6935802deb--10d91daf82a947219550b58d9a75ea50 a8f5f262a24d4e2ca6bd54774ab38a13 10d91daf82a947219550b58d9a75ea50--a8f5f262a24d4e2ca6bd54774ab38a13 5813d9a8ab1d44c8b6583606d8e18613 X a8f5f262a24d4e2ca6bd54774ab38a13--5813d9a8ab1d44c8b6583606d8e18613 5813d9a8ab1d44c8b6583606d8e18613--0fb98fb3242d4295acfa1699ca8e5623 a90a5b79cc5f41ab85dd28678072bfb6 RX(p2\u2082) 5813d9a8ab1d44c8b6583606d8e18613--a90a5b79cc5f41ab85dd28678072bfb6 4312724e06f640adb7ade9293f4ef6df RY(p2\u2086) a90a5b79cc5f41ab85dd28678072bfb6--4312724e06f640adb7ade9293f4ef6df 935dd1dd32524248b4122d38ad3b62d0 RX(p2\u2081\u2080) 4312724e06f640adb7ade9293f4ef6df--935dd1dd32524248b4122d38ad3b62d0 afaa8da439c34abea80953c8b10fecf2 935dd1dd32524248b4122d38ad3b62d0--afaa8da439c34abea80953c8b10fecf2 52071939335947c1a33e3acf6f45e36f X afaa8da439c34abea80953c8b10fecf2--52071939335947c1a33e3acf6f45e36f 52071939335947c1a33e3acf6f45e36f--b29031359b2144e78732b9693cba6267 eb3bd6013c464ed88260fdfde1307d1b RX(p2\u2081\u2084) 52071939335947c1a33e3acf6f45e36f--eb3bd6013c464ed88260fdfde1307d1b 66e667f098d141129d404fe431b3b74a RY(p2\u2081\u2088) eb3bd6013c464ed88260fdfde1307d1b--66e667f098d141129d404fe431b3b74a 573dbdd43c224489be74f3b8681a80ea RX(p2\u2082\u2082) 66e667f098d141129d404fe431b3b74a--573dbdd43c224489be74f3b8681a80ea f2712a854ecc44c3b90c7d7f22d66634 573dbdd43c224489be74f3b8681a80ea--f2712a854ecc44c3b90c7d7f22d66634 e35fa204926d4b268237064c5914f86a X f2712a854ecc44c3b90c7d7f22d66634--e35fa204926d4b268237064c5914f86a e35fa204926d4b268237064c5914f86a--8c3604775b0a4904bd5a3354e737deeb e35fa204926d4b268237064c5914f86a--4cf2da5a2f1443bdaa0d161c0e957559 ac65a840bab14899b4ac21aa3efd9726 0bcbc722478748a197260cf46e5f301d RX(p1\u2083) dd9ba6e6fb954d0b85710d378248c162--0bcbc722478748a197260cf46e5f301d ae83819f605243d59eda6a5d82cf8241 RY(p1\u2087) 0bcbc722478748a197260cf46e5f301d--ae83819f605243d59eda6a5d82cf8241 76ed2912eedb43b8a8a8a386853a2e9d RX(p1\u2081\u2081) ae83819f605243d59eda6a5d82cf8241--76ed2912eedb43b8a8a8a386853a2e9d 4bbb33df2ab048f8af6aa9492fa49c46 X 76ed2912eedb43b8a8a8a386853a2e9d--4bbb33df2ab048f8af6aa9492fa49c46 4bbb33df2ab048f8af6aa9492fa49c46--47be9533b29446c1b2a9fe80f7b20af6 d2337c2106684f13b355cce5e5ca9ac1 4bbb33df2ab048f8af6aa9492fa49c46--d2337c2106684f13b355cce5e5ca9ac1 7e6f79788e194191b5bf23293708db05 RX(p1\u2081\u2085) d2337c2106684f13b355cce5e5ca9ac1--7e6f79788e194191b5bf23293708db05 2cbb99940bfc4a2c8e395299a62e3847 RY(p1\u2081\u2089) 7e6f79788e194191b5bf23293708db05--2cbb99940bfc4a2c8e395299a62e3847 96d1bec1824040f7ab139f17f801199c RX(p1\u2082\u2083) 2cbb99940bfc4a2c8e395299a62e3847--96d1bec1824040f7ab139f17f801199c 86725b0c51bb4c418e375fcddf0739c9 X 96d1bec1824040f7ab139f17f801199c--86725b0c51bb4c418e375fcddf0739c9 86725b0c51bb4c418e375fcddf0739c9--a8f5f262a24d4e2ca6bd54774ab38a13 1df9a71f78e5408cb9e1529ab511fb5a 86725b0c51bb4c418e375fcddf0739c9--1df9a71f78e5408cb9e1529ab511fb5a b051c97248004df68f58ad86c28f428a RX(p2\u2083) 1df9a71f78e5408cb9e1529ab511fb5a--b051c97248004df68f58ad86c28f428a a52f38adcb824ae68c79a39c519275d7 RY(p2\u2087) b051c97248004df68f58ad86c28f428a--a52f38adcb824ae68c79a39c519275d7 ed2b8ba9795141579edd2932b97c1648 RX(p2\u2081\u2081) a52f38adcb824ae68c79a39c519275d7--ed2b8ba9795141579edd2932b97c1648 4ccebdece6f94fe393ff20fd87b378d3 X ed2b8ba9795141579edd2932b97c1648--4ccebdece6f94fe393ff20fd87b378d3 4ccebdece6f94fe393ff20fd87b378d3--afaa8da439c34abea80953c8b10fecf2 142266455389487f8cb34151807223dc 4ccebdece6f94fe393ff20fd87b378d3--142266455389487f8cb34151807223dc d30d50199efb4e959f6aaab11a9bfcaa RX(p2\u2081\u2085) 142266455389487f8cb34151807223dc--d30d50199efb4e959f6aaab11a9bfcaa c05e642e9e5b4d69841fc3e51074118c RY(p2\u2081\u2089) d30d50199efb4e959f6aaab11a9bfcaa--c05e642e9e5b4d69841fc3e51074118c bc5cc85cc5de4e75a618d077051c4a61 RX(p2\u2082\u2083) c05e642e9e5b4d69841fc3e51074118c--bc5cc85cc5de4e75a618d077051c4a61 48fe344d52864b79991bd8fac36307e1 X bc5cc85cc5de4e75a618d077051c4a61--48fe344d52864b79991bd8fac36307e1 48fe344d52864b79991bd8fac36307e1--f2712a854ecc44c3b90c7d7f22d66634 863ed58cfdcb4fa2ac51d511d1e0223d 48fe344d52864b79991bd8fac36307e1--863ed58cfdcb4fa2ac51d511d1e0223d 863ed58cfdcb4fa2ac51d511d1e0223d--ac65a840bab14899b4ac21aa3efd9726 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6723])), ('theta_0', tensor([0.1476])), ('theta_1', tensor([0.6309])), ('theta_10', tensor([0.8657])), ('theta_11', tensor([0.8418])), ('theta_12', tensor([0.1063])), ('theta_13', tensor([0.6077])), ('theta_14', tensor([0.8846])), ('theta_15', tensor([0.9668])), ('theta_16', tensor([0.2565])), ('theta_17', tensor([0.1043])), ('theta_18', tensor([0.9783])), ('theta_19', tensor([0.0618])), ('theta_2', tensor([0.1834])), ('theta_20', tensor([0.4442])), ('theta_21', tensor([0.6389])), ('theta_22', tensor([0.6250])), ('theta_23', tensor([0.5487])), ('theta_3', tensor([0.8038])), ('theta_4', tensor([0.9408])), ('theta_5', tensor([0.4441])), ('theta_6', tensor([0.6926])), ('theta_7', tensor([0.3457])), ('theta_8', tensor([0.6128])), ('theta_9', tensor([0.6174]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6713])), ('theta_0', tensor([0.1486])), ('theta_1', tensor([0.6319])), ('theta_10', tensor([0.8667])), ('theta_11', tensor([0.8428])), ('theta_12', tensor([0.1073])), ('theta_13', tensor([0.6067])), ('theta_14', tensor([0.8856])), ('theta_15', tensor([0.9678])), ('theta_16', tensor([0.2575])), ('theta_17', tensor([0.1033])), ('theta_18', tensor([0.9773])), ('theta_19', tensor([0.0608])), ('theta_2', tensor([0.1844])), ('theta_20', tensor([0.4452])), ('theta_21', tensor([0.6379])), ('theta_22', tensor([0.6260])), ('theta_23', tensor([0.5497])), ('theta_3', tensor([0.8048])), ('theta_4', tensor([0.9418])), ('theta_5', tensor([0.4451])), ('theta_6', tensor([0.6936])), ('theta_7', tensor([0.3467])), ('theta_8', tensor([0.6138])), ('theta_9', tensor([0.6184]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9986+0.0000j,  0.0000-0.0369j,  0.0000-0.0369j, -0.0014+0.0000j],\n        [ 0.9556+0.0000j,  0.0000-0.2059j,  0.0000-0.2059j, -0.0444+0.0000j],\n        [ 0.9810+0.0000j,  0.0000-0.1367j,  0.0000-0.1367j, -0.0190+0.0000j]])\nxs = [Counter({'00': 99, '10': 1}), Counter({'00': 86, '01': 8, '10': 6}), Counter({'00': 95, '01': 4, '10': 1})]\nex = tensor([[0.9973],\n        [0.9113],\n        [0.9619]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9973, 0.9973],\n        [0.9113, 0.9113],\n        [0.9619, 0.9619]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-12-12T16:39:32.856799 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2023-12-12T16:39:33.189837 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 52, '00': 48})]\nSample in little endian = [Counter({'10': 52, '00': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 52, '00': 48})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 88, '01': 12})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 89, '01': 11})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [0.01809663-0.99983624j 0.        +0.j         0.        +0.j\n 0.        +0.j        ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_0a6b32fb99bb45c79da5aefd55f5b93e Circuit block cluster_b9ea93ae837045068d5b63cd7c6ac793 Prep block 3395f3e11b634dd6ae880c7e8ce821cd 0 d8c505d5762a45e7ac9d5b07d350d250 3395f3e11b634dd6ae880c7e8ce821cd--d8c505d5762a45e7ac9d5b07d350d250 b01be875bce64fdebb98c48465766b19 1 b192dcf6d9bf4ec19344509bb52726bb RX(theta\u2080) d8c505d5762a45e7ac9d5b07d350d250--b192dcf6d9bf4ec19344509bb52726bb e9388fceb3e74ef585803b47a76090ce RY(theta\u2084) b192dcf6d9bf4ec19344509bb52726bb--e9388fceb3e74ef585803b47a76090ce a183152b63e740db8e9bd0b9da0c99df RX(theta\u2088) e9388fceb3e74ef585803b47a76090ce--a183152b63e740db8e9bd0b9da0c99df 50aa66df7d214ee5adc06d31dc703a7f a183152b63e740db8e9bd0b9da0c99df--50aa66df7d214ee5adc06d31dc703a7f b46a4659b6aa44b7b6393050ef3ad8a7 50aa66df7d214ee5adc06d31dc703a7f--b46a4659b6aa44b7b6393050ef3ad8a7 3fb7a92dfd834ae0a342e870a4460432 RX(theta\u2081\u2082) b46a4659b6aa44b7b6393050ef3ad8a7--3fb7a92dfd834ae0a342e870a4460432 8e676596852242109be29f2282f2a24e RY(theta\u2081\u2086) 3fb7a92dfd834ae0a342e870a4460432--8e676596852242109be29f2282f2a24e 49f3749182c842f5bdac7507c044bb6a RX(theta\u2082\u2080) 8e676596852242109be29f2282f2a24e--49f3749182c842f5bdac7507c044bb6a 279827d0cf6d4e3394ff21a161ca963c 49f3749182c842f5bdac7507c044bb6a--279827d0cf6d4e3394ff21a161ca963c 315f4c4edfc14f7d80e15aedd2c99a98 279827d0cf6d4e3394ff21a161ca963c--315f4c4edfc14f7d80e15aedd2c99a98 8f1c38c85efe493aa343a887c09fd7b8 315f4c4edfc14f7d80e15aedd2c99a98--8f1c38c85efe493aa343a887c09fd7b8 2a4f3f880e8d444da77001145b26bdc3 3c1d533b1d7a4dada3c7de39ac6aaadc b01be875bce64fdebb98c48465766b19--3c1d533b1d7a4dada3c7de39ac6aaadc 3611ac2d67e241d2a0c53f2db7d1caf6 2 ae0a147f3eb74d2e865f38adb7e7ffa9 RX(theta\u2081) 3c1d533b1d7a4dada3c7de39ac6aaadc--ae0a147f3eb74d2e865f38adb7e7ffa9 b51b07f83d4944d595b8895a72f36bee RY(theta\u2085) ae0a147f3eb74d2e865f38adb7e7ffa9--b51b07f83d4944d595b8895a72f36bee 046cbbf4d632451f9d2166e20d0fc053 RX(theta\u2089) b51b07f83d4944d595b8895a72f36bee--046cbbf4d632451f9d2166e20d0fc053 2f619de87c4c4c65b92dec8b46af7fc8 X 046cbbf4d632451f9d2166e20d0fc053--2f619de87c4c4c65b92dec8b46af7fc8 2f619de87c4c4c65b92dec8b46af7fc8--50aa66df7d214ee5adc06d31dc703a7f bcf44f0223db4cb9a475fc48983d7b77 2f619de87c4c4c65b92dec8b46af7fc8--bcf44f0223db4cb9a475fc48983d7b77 5c99552e1c5740f698515f4cd98794d9 RX(theta\u2081\u2083) bcf44f0223db4cb9a475fc48983d7b77--5c99552e1c5740f698515f4cd98794d9 2c96bfdc1cca42088eccbb1d71cdaa8a RY(theta\u2081\u2087) 5c99552e1c5740f698515f4cd98794d9--2c96bfdc1cca42088eccbb1d71cdaa8a e8fafd4f1d654006aa15c404075eaab2 RX(theta\u2082\u2081) 2c96bfdc1cca42088eccbb1d71cdaa8a--e8fafd4f1d654006aa15c404075eaab2 8634cb80c97f4c99b0d5fce47bbb599d X e8fafd4f1d654006aa15c404075eaab2--8634cb80c97f4c99b0d5fce47bbb599d 8634cb80c97f4c99b0d5fce47bbb599d--279827d0cf6d4e3394ff21a161ca963c 5f87f084820e470791459c3c70a17de8 8634cb80c97f4c99b0d5fce47bbb599d--5f87f084820e470791459c3c70a17de8 5f87f084820e470791459c3c70a17de8--2a4f3f880e8d444da77001145b26bdc3 63c9bdfc81bc4680a20655deb8817f7f 6905ff0dea0c47578ffdcf6a2393cd4b 3611ac2d67e241d2a0c53f2db7d1caf6--6905ff0dea0c47578ffdcf6a2393cd4b 7e4646f2ba444fd98f6bdbff6b82ea10 3 67f47cf0cbb34e42968662f8e94638ce RX(theta\u2082) 6905ff0dea0c47578ffdcf6a2393cd4b--67f47cf0cbb34e42968662f8e94638ce eaf1e1c4367144bcaa764d4b2951a4b0 RY(theta\u2086) 67f47cf0cbb34e42968662f8e94638ce--eaf1e1c4367144bcaa764d4b2951a4b0 aa6f3329433146c7aa2c41543a70010f RX(theta\u2081\u2080) eaf1e1c4367144bcaa764d4b2951a4b0--aa6f3329433146c7aa2c41543a70010f 64d74eb36be54f4e8db1a6a575f772a4 aa6f3329433146c7aa2c41543a70010f--64d74eb36be54f4e8db1a6a575f772a4 ccc84665bd0240749e16ecb6eaa58455 X 64d74eb36be54f4e8db1a6a575f772a4--ccc84665bd0240749e16ecb6eaa58455 ccc84665bd0240749e16ecb6eaa58455--bcf44f0223db4cb9a475fc48983d7b77 eb0d50aaee464199987a8a614ba8383b RX(theta\u2081\u2084) ccc84665bd0240749e16ecb6eaa58455--eb0d50aaee464199987a8a614ba8383b 4b5e9cecbdb64f6b833691c5d6f1f8d6 RY(theta\u2081\u2088) eb0d50aaee464199987a8a614ba8383b--4b5e9cecbdb64f6b833691c5d6f1f8d6 e65768df075e40bda8e861756a5037e4 RX(theta\u2082\u2082) 4b5e9cecbdb64f6b833691c5d6f1f8d6--e65768df075e40bda8e861756a5037e4 870c2674b06d4648ab85364ff8d1b6de e65768df075e40bda8e861756a5037e4--870c2674b06d4648ab85364ff8d1b6de def1f895eabf470ca0902b7ad8860fe5 X 870c2674b06d4648ab85364ff8d1b6de--def1f895eabf470ca0902b7ad8860fe5 def1f895eabf470ca0902b7ad8860fe5--5f87f084820e470791459c3c70a17de8 def1f895eabf470ca0902b7ad8860fe5--63c9bdfc81bc4680a20655deb8817f7f 77c15032d8924f9884c2c28b39de4b97 514bf6d5bc2f4322ac831a0991c3c24f X 7e4646f2ba444fd98f6bdbff6b82ea10--514bf6d5bc2f4322ac831a0991c3c24f bff7b7daf9324c7db9af31ee2bdf3070 RX(theta\u2083) 514bf6d5bc2f4322ac831a0991c3c24f--bff7b7daf9324c7db9af31ee2bdf3070 3ec864544e1043d19da9c98308127315 RY(theta\u2087) bff7b7daf9324c7db9af31ee2bdf3070--3ec864544e1043d19da9c98308127315 9e6f78f2dc0244419317777e3153db86 RX(theta\u2081\u2081) 3ec864544e1043d19da9c98308127315--9e6f78f2dc0244419317777e3153db86 798779952d074ce08425946b88f23944 X 9e6f78f2dc0244419317777e3153db86--798779952d074ce08425946b88f23944 798779952d074ce08425946b88f23944--64d74eb36be54f4e8db1a6a575f772a4 7bd1283132834a319b25dd2ed83fe358 798779952d074ce08425946b88f23944--7bd1283132834a319b25dd2ed83fe358 84fc4f7fb71c405a987e8df99a0f7f16 RX(theta\u2081\u2085) 7bd1283132834a319b25dd2ed83fe358--84fc4f7fb71c405a987e8df99a0f7f16 a5ae50fc756f4c1a9a7a62e9df4701a5 RY(theta\u2081\u2089) 84fc4f7fb71c405a987e8df99a0f7f16--a5ae50fc756f4c1a9a7a62e9df4701a5 b252f48bc10847b28ca4d96f05452d82 RX(theta\u2082\u2083) a5ae50fc756f4c1a9a7a62e9df4701a5--b252f48bc10847b28ca4d96f05452d82 ea214093524b42c994aeb2ab39301901 X b252f48bc10847b28ca4d96f05452d82--ea214093524b42c994aeb2ab39301901 ea214093524b42c994aeb2ab39301901--870c2674b06d4648ab85364ff8d1b6de a4ca911d234847cb85dd724fa386d8ef ea214093524b42c994aeb2ab39301901--a4ca911d234847cb85dd724fa386d8ef a4ca911d234847cb85dd724fa386d8ef--77c15032d8924f9884c2c28b39de4b97  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.2561-0.1032j,  0.0494+0.0587j,  0.3258+0.1880j,  0.2518-0.0606j,\n         -0.3047-0.3365j, -0.0829+0.4560j,  0.2562+0.1226j, -0.1817+0.4180j],\n        [ 0.3139+0.4935j, -0.2357+0.3002j,  0.4257+0.0696j,  0.0326+0.0448j,\n          0.1226-0.1125j, -0.2873+0.1443j, -0.1797-0.3972j, -0.0041-0.0452j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}