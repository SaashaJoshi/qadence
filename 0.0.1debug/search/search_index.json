{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interation until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])  # Dimensionless.\nsamples = sample(register, block)\n# Interacting qubits as close together.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'01': 38, '00': 32, '10': 30})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket, pulser, visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        protocol: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._protocol = protocol\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code></p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        protocol: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nprotocol=protocol,\nconfiguration=configuration,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.transform(\nself.expectation(values=values, state=state, protocol=protocol, endianness=endianness)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-10-16T10:47:37.450533 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor field in fields(self):\nif not field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {field.name} - Type: {field.type} - Default value: {field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend. Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend. Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        protocol: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, state=None, n_shots=1, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nstate: Tensor | None = None,\nn_shots: int = 1,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>idealized device, least realistic</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>device with realistic specs</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction and loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing. Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates. Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: list[int] | tuple,\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single\n    call to _apply_batch_gate.\"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> %3 92a8b30949cc453fbac8223b2570ae91 0 82bb244640da4770909a762df858727d X 92a8b30949cc453fbac8223b2570ae91--82bb244640da4770909a762df858727d e4e3d0b33b984510be0ab5026476be04 1 cba43433e6af46478e07cc0e8f94d6c9 82bb244640da4770909a762df858727d--cba43433e6af46478e07cc0e8f94d6c9 13816cbc72d349efbde09bfd87b9007e cb2cb5939f2941c2a16569a7aebe4521 Y e4e3d0b33b984510be0ab5026476be04--cb2cb5939f2941c2a16569a7aebe4521 cb2cb5939f2941c2a16569a7aebe4521--13816cbc72d349efbde09bfd87b9007e <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> %3 c7a7777c14c74b85b13a0ff6d14966a5 0 afcb4a76603f4cd48733f2c6e468be23 X c7a7777c14c74b85b13a0ff6d14966a5--afcb4a76603f4cd48733f2c6e468be23 669f1c5b3f0e447a8fc9e5d22f995446 Y afcb4a76603f4cd48733f2c6e468be23--669f1c5b3f0e447a8fc9e5d22f995446 7160068fda624bd9a7ef3080753dd767 669f1c5b3f0e447a8fc9e5d22f995446--7160068fda624bd9a7ef3080753dd767 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> %3 ea733fa3b2204361a8b81e029dda7f97 0 f4a9cdddfba647e8bd0d6686509f305a X ea733fa3b2204361a8b81e029dda7f97--f4a9cdddfba647e8bd0d6686509f305a 8e3c78edda544474a95abc2e968732a3 1 d8d7d957cfad4c7a98e51b27737c41fc f4a9cdddfba647e8bd0d6686509f305a--d8d7d957cfad4c7a98e51b27737c41fc ee2dcea444584c9fa785dc2596bdbd2c d8d7d957cfad4c7a98e51b27737c41fc--ee2dcea444584c9fa785dc2596bdbd2c 3eb0679a2b894342bdc14b151e4ac818 56b788ebc2bf4552a63caa28558d1f32 8e3c78edda544474a95abc2e968732a3--56b788ebc2bf4552a63caa28558d1f32 a8fd63caa8c342e1932d34a0eb7d1177 Y 56b788ebc2bf4552a63caa28558d1f32--a8fd63caa8c342e1932d34a0eb7d1177 a8fd63caa8c342e1932d34a0eb7d1177--3eb0679a2b894342bdc14b151e4ac818 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_578581584c124f3389421908921ffb0f c23845f4048c4082861e9f93d6e6d200 0 43921e714f8f45fbaecf2626df2900b7 c23845f4048c4082861e9f93d6e6d200--43921e714f8f45fbaecf2626df2900b7 148fa4541d114db18f2195374d3a33f3 1 6b039a66e9a846918d602d4ca054d415 43921e714f8f45fbaecf2626df2900b7--6b039a66e9a846918d602d4ca054d415 16f38e7702d34af2a265b0c7aaa6d070 77390b3d117f4458bba74adea1652c5f AddBlock 148fa4541d114db18f2195374d3a33f3--77390b3d117f4458bba74adea1652c5f 67a9727522634432a1bb5885136fb282 2 77390b3d117f4458bba74adea1652c5f--16f38e7702d34af2a265b0c7aaa6d070 86b9cac7734c49a58dee7672d0b6d165 dc4d49dceba843e1bf2250de4935d42b 67a9727522634432a1bb5885136fb282--dc4d49dceba843e1bf2250de4935d42b dc4d49dceba843e1bf2250de4935d42b--86b9cac7734c49a58dee7672d0b6d165 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> %3 cluster_23fbfc7e0b9b4a3d9acf500115f050e0 cluster_49ceb20657cc44758c41208cafb95532 rx f12e9b83b6a042809e5300c7073f8360 0 9c10c28462164b94a5e3515392b7ce65 X f12e9b83b6a042809e5300c7073f8360--9c10c28462164b94a5e3515392b7ce65 eadb2e9510114260b088373ed43d507e 1 bb77fb7620aa4300b19d89088d105021 9c10c28462164b94a5e3515392b7ce65--bb77fb7620aa4300b19d89088d105021 baf94b6acc6149ed96dd95f6befd038f bb77fb7620aa4300b19d89088d105021--baf94b6acc6149ed96dd95f6befd038f 8a6d44d6b7764667a188c03d3ede063f baf94b6acc6149ed96dd95f6befd038f--8a6d44d6b7764667a188c03d3ede063f 76b0d7f92c0a4eb99fa930483ea5bf9c c6a573e4ca7b46ec90772f9e604f2e9a Y eadb2e9510114260b088373ed43d507e--c6a573e4ca7b46ec90772f9e604f2e9a 648e0ba86e9f4723ac8de4f0cca6fabb 2 ebced5fbeacd41f6839dda81048673a1 c6a573e4ca7b46ec90772f9e604f2e9a--ebced5fbeacd41f6839dda81048673a1 d2b4cc2a6d4c4f2bbc1f4349a397db06 HamEvo ebced5fbeacd41f6839dda81048673a1--d2b4cc2a6d4c4f2bbc1f4349a397db06 d2b4cc2a6d4c4f2bbc1f4349a397db06--76b0d7f92c0a4eb99fa930483ea5bf9c 84cb5886817946c3a104006b3f2e6830 2a49df06b9f6439e88d1a0803827c076 RX(x) 648e0ba86e9f4723ac8de4f0cca6fabb--2a49df06b9f6439e88d1a0803827c076 2ab3d3b29dd14e97b91600f96fb4d491 3 e078604996eb407fa19571d4dc75fd83 2a49df06b9f6439e88d1a0803827c076--e078604996eb407fa19571d4dc75fd83 2e8058d77b8441a896db4de45502b46d t = 10 e078604996eb407fa19571d4dc75fd83--2e8058d77b8441a896db4de45502b46d 2e8058d77b8441a896db4de45502b46d--84cb5886817946c3a104006b3f2e6830 ec64698a9c624a19a6a704a24486bc36 ac08a40945fd48dcbc5fe626bde72978 RX(0.5) 2ab3d3b29dd14e97b91600f96fb4d491--ac08a40945fd48dcbc5fe626bde72978 7de031d089fc419da1d4d74772fc323c X ac08a40945fd48dcbc5fe626bde72978--7de031d089fc419da1d4d74772fc323c 7de031d089fc419da1d4d74772fc323c--e078604996eb407fa19571d4dc75fd83 b3fbf80d1afc4df1869c9c69ca676e2e 7de031d089fc419da1d4d74772fc323c--b3fbf80d1afc4df1869c9c69ca676e2e b3fbf80d1afc4df1869c9c69ca676e2e--ec64698a9c624a19a6a704a24486bc36 <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, fm_type=\"tower\"), hea(4,2))\n</code></pre> %3 cluster_dc9479ba7af4495281d67a798c190615 HEA cluster_86061364ea0546ddaa8e2284fa2e5595 FM 58680ef6e0ad497a81f113c11588ffb7 0 04ffe59d107c41e290a48c97df008d9a RX(2*acos(phi)) 58680ef6e0ad497a81f113c11588ffb7--04ffe59d107c41e290a48c97df008d9a 5a71823d7d254015a74b400f27c85919 1 14909889acc14f5eb09dd54824ad6002 RX(theta\u2080) 04ffe59d107c41e290a48c97df008d9a--14909889acc14f5eb09dd54824ad6002 1f09441749e348709986db450d8ac6d8 RY(theta\u2084) 14909889acc14f5eb09dd54824ad6002--1f09441749e348709986db450d8ac6d8 f8a7ea9f058a4bc7881e4fc86947158c RX(theta\u2088) 1f09441749e348709986db450d8ac6d8--f8a7ea9f058a4bc7881e4fc86947158c e09c708b766a42c7bee0aaa4d9294ce1 f8a7ea9f058a4bc7881e4fc86947158c--e09c708b766a42c7bee0aaa4d9294ce1 98709817932c4a13b18c4bc851a67dbb e09c708b766a42c7bee0aaa4d9294ce1--98709817932c4a13b18c4bc851a67dbb 9826111be82a4351bfc465345c5a1dfd RX(theta\u2081\u2082) 98709817932c4a13b18c4bc851a67dbb--9826111be82a4351bfc465345c5a1dfd 34dc415724fb469ab082f78c447daf60 RY(theta\u2081\u2086) 9826111be82a4351bfc465345c5a1dfd--34dc415724fb469ab082f78c447daf60 ba681219d60040b3be2c65a2472ca234 RX(theta\u2082\u2080) 34dc415724fb469ab082f78c447daf60--ba681219d60040b3be2c65a2472ca234 111065751ff14cb78dd4a42c0639555c ba681219d60040b3be2c65a2472ca234--111065751ff14cb78dd4a42c0639555c 1fa096b0f13c4dbcbf16c836af2ea798 111065751ff14cb78dd4a42c0639555c--1fa096b0f13c4dbcbf16c836af2ea798 9a01cdd769f34068b210ae3aea49da7a 1fa096b0f13c4dbcbf16c836af2ea798--9a01cdd769f34068b210ae3aea49da7a 78fe8784696040b29f824631e32dd809 0d3ba58f4d934ddd92aeb1473904d310 RX(4*acos(phi)) 5a71823d7d254015a74b400f27c85919--0d3ba58f4d934ddd92aeb1473904d310 e08a5baa07844a228850c8539d29ce1e 2 7503080d9a0e4b839fa30e9b4fe0ca4b RX(theta\u2081) 0d3ba58f4d934ddd92aeb1473904d310--7503080d9a0e4b839fa30e9b4fe0ca4b ed543c79b2fa4160b09d4209aa6a62a1 RY(theta\u2085) 7503080d9a0e4b839fa30e9b4fe0ca4b--ed543c79b2fa4160b09d4209aa6a62a1 d548f5ba9710437a9d27f397bb492786 RX(theta\u2089) ed543c79b2fa4160b09d4209aa6a62a1--d548f5ba9710437a9d27f397bb492786 91cee8cdb3d54dbfadf982bdf59e8775 X d548f5ba9710437a9d27f397bb492786--91cee8cdb3d54dbfadf982bdf59e8775 91cee8cdb3d54dbfadf982bdf59e8775--e09c708b766a42c7bee0aaa4d9294ce1 0a2ff6409ce44634a9374993e3d67087 91cee8cdb3d54dbfadf982bdf59e8775--0a2ff6409ce44634a9374993e3d67087 455b2341e1e147ce90075d4cd91414e8 RX(theta\u2081\u2083) 0a2ff6409ce44634a9374993e3d67087--455b2341e1e147ce90075d4cd91414e8 d72e5ebc718244d0b0629a9af19f88ac RY(theta\u2081\u2087) 455b2341e1e147ce90075d4cd91414e8--d72e5ebc718244d0b0629a9af19f88ac 51da15517cf94acb9367affdc4ed6dec RX(theta\u2082\u2081) d72e5ebc718244d0b0629a9af19f88ac--51da15517cf94acb9367affdc4ed6dec 91fa24c8f90c4049b6aae6ff0813d9df X 51da15517cf94acb9367affdc4ed6dec--91fa24c8f90c4049b6aae6ff0813d9df 91fa24c8f90c4049b6aae6ff0813d9df--111065751ff14cb78dd4a42c0639555c 98f23a7012834059af5c953f195143a3 91fa24c8f90c4049b6aae6ff0813d9df--98f23a7012834059af5c953f195143a3 98f23a7012834059af5c953f195143a3--78fe8784696040b29f824631e32dd809 5869dfd9a7dc497681819f74dab5c1ab 17921ac421ac42e09536ac73364e7417 RX(6*acos(phi)) e08a5baa07844a228850c8539d29ce1e--17921ac421ac42e09536ac73364e7417 3b1e37a353704b078d35b50a4f1f2a71 3 cb384e4ddf0a4ff08cad1e753158ff69 RX(theta\u2082) 17921ac421ac42e09536ac73364e7417--cb384e4ddf0a4ff08cad1e753158ff69 461514908d124a27bcabef9d8b97963b RY(theta\u2086) cb384e4ddf0a4ff08cad1e753158ff69--461514908d124a27bcabef9d8b97963b e2c8d6255c6540be97ebe21a344ffb58 RX(theta\u2081\u2080) 461514908d124a27bcabef9d8b97963b--e2c8d6255c6540be97ebe21a344ffb58 2f624fce652b462985f57749dd79b562 e2c8d6255c6540be97ebe21a344ffb58--2f624fce652b462985f57749dd79b562 0b40f65961454fa0bafe9e5ee06de5d2 X 2f624fce652b462985f57749dd79b562--0b40f65961454fa0bafe9e5ee06de5d2 0b40f65961454fa0bafe9e5ee06de5d2--0a2ff6409ce44634a9374993e3d67087 44ec990476cd4646b5128492a35f95f5 RX(theta\u2081\u2084) 0b40f65961454fa0bafe9e5ee06de5d2--44ec990476cd4646b5128492a35f95f5 53f6a6ac02bc46d39268b6dd9ef91438 RY(theta\u2081\u2088) 44ec990476cd4646b5128492a35f95f5--53f6a6ac02bc46d39268b6dd9ef91438 69847bb6938a449a9a13ea8fad0cd304 RX(theta\u2082\u2082) 53f6a6ac02bc46d39268b6dd9ef91438--69847bb6938a449a9a13ea8fad0cd304 6fd933947c9b4f54bc5cb3979333791e 69847bb6938a449a9a13ea8fad0cd304--6fd933947c9b4f54bc5cb3979333791e c011188c5f1746cdb19430e692eca178 X 6fd933947c9b4f54bc5cb3979333791e--c011188c5f1746cdb19430e692eca178 c011188c5f1746cdb19430e692eca178--98f23a7012834059af5c953f195143a3 c011188c5f1746cdb19430e692eca178--5869dfd9a7dc497681819f74dab5c1ab 4ae332f27c6e4d30b4f1f14c771ceffd 5f8d23476dc04b759b40e14fd61bf82a RX(8*acos(phi)) 3b1e37a353704b078d35b50a4f1f2a71--5f8d23476dc04b759b40e14fd61bf82a f3f4fbc7db7e4bbe8c1bdcc14a65d4e9 RX(theta\u2083) 5f8d23476dc04b759b40e14fd61bf82a--f3f4fbc7db7e4bbe8c1bdcc14a65d4e9 f8645d20082e48b6ba2b2e3722154126 RY(theta\u2087) f3f4fbc7db7e4bbe8c1bdcc14a65d4e9--f8645d20082e48b6ba2b2e3722154126 36fc650e59fd4c39ae0ce2166a9e7b48 RX(theta\u2081\u2081) f8645d20082e48b6ba2b2e3722154126--36fc650e59fd4c39ae0ce2166a9e7b48 7d2a13043e0d4cdb94a666ac161cac0e X 36fc650e59fd4c39ae0ce2166a9e7b48--7d2a13043e0d4cdb94a666ac161cac0e 7d2a13043e0d4cdb94a666ac161cac0e--2f624fce652b462985f57749dd79b562 84661a0a8db8443d8ac0e6ef5abb2e49 7d2a13043e0d4cdb94a666ac161cac0e--84661a0a8db8443d8ac0e6ef5abb2e49 cc195a1bae1e4a49b8b4f20385891c50 RX(theta\u2081\u2085) 84661a0a8db8443d8ac0e6ef5abb2e49--cc195a1bae1e4a49b8b4f20385891c50 d4c188c2be92423b864347493f18ca92 RY(theta\u2081\u2089) cc195a1bae1e4a49b8b4f20385891c50--d4c188c2be92423b864347493f18ca92 a7b15ca488a5481fb9581b7a95fec620 RX(theta\u2082\u2083) d4c188c2be92423b864347493f18ca92--a7b15ca488a5481fb9581b7a95fec620 11ff9f1282804508a1050f0b9ebbe17b X a7b15ca488a5481fb9581b7a95fec620--11ff9f1282804508a1050f0b9ebbe17b 11ff9f1282804508a1050f0b9ebbe17b--6fd933947c9b4f54bc5cb3979333791e 5a11db77ccd14c898bb4a912e05eb901 11ff9f1282804508a1050f0b9ebbe17b--5a11db77ccd14c898bb4a912e05eb901 5a11db77ccd14c898bb4a912e05eb901--4ae332f27c6e4d30b4f1f14c771ceffd"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/","title":"Digital-Analog Emulation","text":""},{"location":"digital_analog_qc/analog-basics/#from-theory-to-implementation","title":"From theory to implementation","text":"<p>Qadence includes primitives for the construction of Ising-like Hamiltonians to account for custom qubit interaction. This allows to simulate systems close to real quantum computing platforms such as neutral atoms. The general form for time-independent Ising Hamiltonians is</p> \\[ \\mathcal{H} = \\sum_{i} \\frac{\\hbar\\Omega}{2} \\hat\\sigma^x_i - \\sum_{i} \\hbar\\delta \\hat n_i  + \\mathcal{H}_{\\textrm{int}}, \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\hat n = \\frac{1-\\hat\\sigma_z}{2}\\) is the number operator, and \\(\\mathcal{H}_{\\textrm{int}}\\) a pair-wise interaction term. Two central operations implement this Hamiltonian as blocks:</p> <ul> <li><code>WaitBlock</code> by free-evolving \\(\\mathcal{H}_{\\textrm{int}}\\)</li> <li><code>ConstantAnalogRotation</code> by free-evolving \\(\\mathcal{H}\\)</li> </ul> <p>The <code>wait</code> operation can be emulated with an \\(ZZ\\)- (Ising) or an \\(XY\\)-interaction:</p> <pre><code>from qadence import Register, wait, add_interaction, run, Interaction\nblock = wait(duration=3000)\nreg = Register.from_coordinates([(0,0), (0,5)])  # Dimensionless.\nemulated = add_interaction(reg, block, interaction=Interaction.XY)  # or Interaction.ZZ for Ising.\n</code></pre> <pre><code>block = WaitBlock(t=3000.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,)) emulated.generator = AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 29.600] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> <p>The <code>AnalogRot</code> constructor can be used to create a fully customizable <code>ConstantAnalogRotation</code> instances:</p> <pre><code>import torch\nfrom qadence import AnalogRot, AnalogRX\n# Implement a global RX rotation by setting all parameters.\nblock = AnalogRot(\nduration=1000., # [ns]\nomega=torch.pi, # [rad/\u03bcs]\ndelta=0,        # [rad/\u03bcs]\nphase=0,        # [rad]\n)\n# Or use the shortcut.\nblock = AnalogRX(torch.pi)\n</code></pre> <pre><code>AnalogRot = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\nAnalogRX = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\n</code></pre> <p>Automatic emulation in the PyQTorch backend</p> <p>All analog blocks are automatically translated to their emulated version when running them with the PyQTorch backend:</p> <p><pre><code>import torch\nfrom qadence import Register, AnalogRX, sample\nreg = Register.from_coordinates([(0,0), (0,5)])\nsample = sample(reg, AnalogRX(torch.pi))\n</code></pre> <pre><code>sample = [Counter({'00': 40, '10': 32, '01': 28})]\n</code></pre> </p> <p>To compose analog blocks, the regular <code>chain</code> and <code>kron</code> operations can be used under the following restrictions:</p> <ul> <li>The resulting <code>AnalogChain</code> type can only be constructed from <code>AnalogKron</code> blocks   or globally supported primitive analog blocks.</li> <li>The resulting <code>AnalogKron</code> type can only be constructed from non-global   analog blocks with the same duration.</li> </ul> <pre><code>import torch\nfrom qadence import AnalogRot, kron, chain, wait\n# Only analog blocks with a global qubit support can be composed\n# using chain.\nanalog_chain = chain(wait(duration=200), AnalogRot(duration=300, omega=2.0))\n# Only blocks with the same `duration` can be composed using kron.\nanalog_kron = kron(\nwait(duration=1000, qubit_support=(0,1)),\nAnalogRot(duration=1000, omega=2.0, qubit_support=(2,3))\n)\n</code></pre> <pre><code>Analog Chain block = AnalogChain(t=500.000000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u251c\u2500\u2500 WaitBlock(t=200.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=0.600000000000000, t=300, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\nAnalog Kron block = AnalogKron(t=1000, support=(0, 1, 2, 3))\n\u251c\u2500\u2500 WaitBlock(t=1000.0, support=(0, 1))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=2.00000000000000, t=1000, support=(2, 3), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\n</code></pre> <p>Composing digital &amp; analog blocks</p> <p>It is possible to compose digital and analog blocks where the additional restrictions for <code>chain</code> and <code>kron</code> only apply to composite blocks which contain analog blocks only. For further details, see <code>AnalogChain</code> and <code>AnalogKron</code>.</p>"},{"location":"digital_analog_qc/analog-basics/#fitting-a-simple-function","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and paramertized ansatze to fit a sine function. First, define an ansatz block and an observable:</p> <pre><code>import torch\nfrom qadence import Register, FeatureParameter, VariationalParameter\nfrom qadence import AnalogRX, AnalogRZ, Z\nfrom qadence import wait, chain, add\npi = torch.pi\n# A two qubit register.\nreg = Register.from_coordinates([(0, 0), (0, 12)])\n# An analog ansatz with an input time parameter.\nt = FeatureParameter(\"t\")\nblock = chain(\nAnalogRX(pi/2.),\nAnalogRZ(t),\nwait(1000 * VariationalParameter(\"theta\", value=0.5)),\nAnalogRX(pi/2),\n)\n# Total magnetization observable.\nobs = add(Z(i) for i in range(reg.n_qubits))\n</code></pre> Plotting functions <code>plot</code> and <code>scatter</code> <p><pre><code>def plot(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.plot(xnp, ynp, **kwargs)\ndef scatter(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.scatter(xnp, ynp, **kwargs)\n</code></pre> </p> <p>Next, define the dataset to train on and plot the initial prediction. The differentiation mode can be set to either <code>DiffMode.AD</code> or <code>DiffMode.GPSR</code>.</p> <pre><code>import matplotlib.pyplot as plt\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\n# Define a quantum model including digital-analog emulation.\ncirc = QuantumCircuit(reg, block)\nmodel = QuantumModel(circ, obs, diff_mode=DiffMode.GPSR)\n# Time support dataset.\nx_train = torch.linspace(0, 6, steps=30)\n# Function to fit.\ny_train = -0.64 * torch.sin(x_train + 0.33) + 0.1\n# Initial prediction.\ny_pred_initial = model.expectation({\"t\": x_train})\n</code></pre> 2023-10-16T10:47:38.279645 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Finally, the classical optimization part is handled by PyTorch:</p> <pre><code># Use PyTorch built-in functionality.\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-2)\n# Define a loss function.\ndef loss_fn(x_train, y_train):\nreturn mse_loss(model.expectation({\"t\": x_train}).squeeze(), y_train)\n# Number of epochs to train over.\nn_epochs = 200\n# Optimization loop.\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n# Get and visualize the final prediction.\ny_pred = model.expectation({\"t\": x_train})\n</code></pre> 2023-10-16T10:47:47.184031 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.transpile.emulate import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_4100727736005*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['39_0388262113427*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_4100727736005*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['39_0388262113427*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 90, '00100': 88, '00001': 74, '00010': 71, '10000': 70, '00101': 19, '11000': 19, '10100': 14, '10001': 13, '10010': 12, '00110': 11, '01001': 11, '00011': 9, '01010': 8, '01100': 6, '01101': 3, '10110': 3, '01011': 2, '01110': 2, '10011': 2, '11010': 2, '00111': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 299, '00011': 187, '01010': 94, '00010': 77, '00101': 62, '01011': 52, '00001': 49, '10010': 44, '00100': 42, '00110': 32, '01001': 15, '01000': 12, '10011': 10, '01111': 7, '10001': 6, '01110': 5, '00000': 3, '01100': 3, '01101': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-10-16T10:47:49.922626 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-basics/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>The DAQC paradigm is typically implemented on quantum computing hardware based on neutral-atoms where both these computations are realizable.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real neutral-atom devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/daqc-basics/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_adc29f451eaf4e86bed10ae30817d73c cluster_d2d97f739377445d80b928ec1d203835 cluster_6fd2244313bf4ae9bdd7158ab8bf3a55 cluster_fd3801d1d50e434ab97f7059e702358e cluster_c284fbd37c424061b078f87efcba7f90 cluster_8a2165c9aa0e449c89ba692a58d94463 cluster_c04f254f74da4426978c4d5264cb5be0 779d0a20bb574ce49984b9b563bf7d76 0 71af1ccdcdfb4da7a9d9d7decc5fca37 HamEvo 779d0a20bb574ce49984b9b563bf7d76--71af1ccdcdfb4da7a9d9d7decc5fca37 5fd5d755729b4f5aae878a725abbbbdd 1 02fe6e79f794415cb497bbd8e1e94b9b HamEvo 71af1ccdcdfb4da7a9d9d7decc5fca37--02fe6e79f794415cb497bbd8e1e94b9b 68739076e7ae4a92b01e290a0ad62a3c HamEvo 02fe6e79f794415cb497bbd8e1e94b9b--68739076e7ae4a92b01e290a0ad62a3c 75341c06704c464c897ef3592280c07d X 68739076e7ae4a92b01e290a0ad62a3c--75341c06704c464c897ef3592280c07d ddaf97a3177441aeb9133559311fe236 HamEvo 75341c06704c464c897ef3592280c07d--ddaf97a3177441aeb9133559311fe236 90feaa6a9f844bda827d2bfa4a6267e8 HamEvo ddaf97a3177441aeb9133559311fe236--90feaa6a9f844bda827d2bfa4a6267e8 3aa4da0ef34444a0bf68880b44587ebb X 90feaa6a9f844bda827d2bfa4a6267e8--3aa4da0ef34444a0bf68880b44587ebb 0f408d2e2c0b483a9e74e5f4ca33ddcb 3aa4da0ef34444a0bf68880b44587ebb--0f408d2e2c0b483a9e74e5f4ca33ddcb af197b99915644ae93bd64c9c05ffee1 HamEvo 0f408d2e2c0b483a9e74e5f4ca33ddcb--af197b99915644ae93bd64c9c05ffee1 666b7fdadb43475c8eb9c02340f4b10d HamEvo af197b99915644ae93bd64c9c05ffee1--666b7fdadb43475c8eb9c02340f4b10d 3b15d7171a7b4501b3fa33b5ffb94a70 666b7fdadb43475c8eb9c02340f4b10d--3b15d7171a7b4501b3fa33b5ffb94a70 d43c6d5be4a748dead0957a862e5e12a 3b15d7171a7b4501b3fa33b5ffb94a70--d43c6d5be4a748dead0957a862e5e12a 87d6a77b69384b2a8c7f07958981126a 91fd4513db0a49eead43d89b65c7231f t = -3.142 5fd5d755729b4f5aae878a725abbbbdd--91fd4513db0a49eead43d89b65c7231f ba57460652ef4329bbb228746567fde5 2 07a0ccd7a8fe4a338f1334a591275214 t = 3.142 91fd4513db0a49eead43d89b65c7231f--07a0ccd7a8fe4a338f1334a591275214 054f337d56504e68a40bec47dd5249c8 t = -3.142 07a0ccd7a8fe4a338f1334a591275214--054f337d56504e68a40bec47dd5249c8 329944a3ec20464db79d05d808dac8e7 054f337d56504e68a40bec47dd5249c8--329944a3ec20464db79d05d808dac8e7 5b0fa5c9aea94c179d87d27970bcf4b3 t = 1.571 329944a3ec20464db79d05d808dac8e7--5b0fa5c9aea94c179d87d27970bcf4b3 bed5e5b6f15a4c12b87fc4ffd222ef32 t = 1.571 5b0fa5c9aea94c179d87d27970bcf4b3--bed5e5b6f15a4c12b87fc4ffd222ef32 7a16246fda47433cb3323377624881e3 bed5e5b6f15a4c12b87fc4ffd222ef32--7a16246fda47433cb3323377624881e3 d318482bfc0d41178eba9015bdd42c55 X 7a16246fda47433cb3323377624881e3--d318482bfc0d41178eba9015bdd42c55 8ca3e50966774ddb974265af35a9a118 t = 1.571 d318482bfc0d41178eba9015bdd42c55--8ca3e50966774ddb974265af35a9a118 762a01cf0d0741cb9a9fc689ff6193d9 t = 1.571 8ca3e50966774ddb974265af35a9a118--762a01cf0d0741cb9a9fc689ff6193d9 8eb170b43662461ca2dc810e315316ed X 762a01cf0d0741cb9a9fc689ff6193d9--8eb170b43662461ca2dc810e315316ed 8eb170b43662461ca2dc810e315316ed--87d6a77b69384b2a8c7f07958981126a eb274e46d5ed42efb905fbb25e033fe4 c30380285bc0426599c333c08c96c712 ba57460652ef4329bbb228746567fde5--c30380285bc0426599c333c08c96c712 8093233b76f549b39f50609100bc12f5 c30380285bc0426599c333c08c96c712--8093233b76f549b39f50609100bc12f5 0933ecc793954a47a8f96ae7c66ab101 8093233b76f549b39f50609100bc12f5--0933ecc793954a47a8f96ae7c66ab101 d0e33fb2512b4ec4b9dada786fbffce1 X 0933ecc793954a47a8f96ae7c66ab101--d0e33fb2512b4ec4b9dada786fbffce1 c32a05b5b5e64c29972bfeb59ba3abd0 d0e33fb2512b4ec4b9dada786fbffce1--c32a05b5b5e64c29972bfeb59ba3abd0 f9a5646b5ff4406c8b5095fdd58f654f c32a05b5b5e64c29972bfeb59ba3abd0--f9a5646b5ff4406c8b5095fdd58f654f 6fde1aa1bcec40e5b548ad4ee2f2ca3e X f9a5646b5ff4406c8b5095fdd58f654f--6fde1aa1bcec40e5b548ad4ee2f2ca3e de62a54e193a45ac8c621678059c2fdc X 6fde1aa1bcec40e5b548ad4ee2f2ca3e--de62a54e193a45ac8c621678059c2fdc 1d221d0299254ed19bdf45491ff5e6de de62a54e193a45ac8c621678059c2fdc--1d221d0299254ed19bdf45491ff5e6de a4dbfab30d4943f0935f3442cf5a1dc4 1d221d0299254ed19bdf45491ff5e6de--a4dbfab30d4943f0935f3442cf5a1dc4 4d0e8cb692364712b561d054f6acd0b0 X a4dbfab30d4943f0935f3442cf5a1dc4--4d0e8cb692364712b561d054f6acd0b0 4d0e8cb692364712b561d054f6acd0b0--eb274e46d5ed42efb905fbb25e033fe4 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_545de99dd6e7454592760aba22b84eb0 cluster_fdad303591af46e79aa08cf2717274a7 9314569adc4e419ab44a3adfadd29e9d 0 deae0dc148184eb694d7e8bf87722f9f X 9314569adc4e419ab44a3adfadd29e9d--deae0dc148184eb694d7e8bf87722f9f 296d638c6a24457a9bdbf123a6b2efcf 1 4e8181fb87b94e1ca92b000444ee9a62 HamEvo deae0dc148184eb694d7e8bf87722f9f--4e8181fb87b94e1ca92b000444ee9a62 01bdf3a8578b4a6188fc35f4a0fa669b X 4e8181fb87b94e1ca92b000444ee9a62--01bdf3a8578b4a6188fc35f4a0fa669b 2a8595735bd142cba6c700a4a59d0ff4 01bdf3a8578b4a6188fc35f4a0fa669b--2a8595735bd142cba6c700a4a59d0ff4 d8c7cbb4098144ffba72824811f81727 HamEvo 2a8595735bd142cba6c700a4a59d0ff4--d8c7cbb4098144ffba72824811f81727 3723a96780d5449e8d923964d5892623 d8c7cbb4098144ffba72824811f81727--3723a96780d5449e8d923964d5892623 3b4be60af7414df6b4ea4e4beb7b9b1a 3723a96780d5449e8d923964d5892623--3b4be60af7414df6b4ea4e4beb7b9b1a e9c931a3efd24f3099ee5b5d95eea728 988fa8ca816c4a17ad9365e39e628d15 296d638c6a24457a9bdbf123a6b2efcf--988fa8ca816c4a17ad9365e39e628d15 150e81cf05ff43d8a45d9753bea37e52 2 fa3b72876953454db921e52e1e949975 t = -0.500 988fa8ca816c4a17ad9365e39e628d15--fa3b72876953454db921e52e1e949975 03a2c6680a18478a963cf1c0f92d713e fa3b72876953454db921e52e1e949975--03a2c6680a18478a963cf1c0f92d713e cf327aa6943c47938adf2a7cd23be74f X 03a2c6680a18478a963cf1c0f92d713e--cf327aa6943c47938adf2a7cd23be74f 6fbddf182b184437a1f9f72148006c74 t = -0.500 cf327aa6943c47938adf2a7cd23be74f--6fbddf182b184437a1f9f72148006c74 b26f82622fb545c48e68eb17f57bd038 X 6fbddf182b184437a1f9f72148006c74--b26f82622fb545c48e68eb17f57bd038 b26f82622fb545c48e68eb17f57bd038--e9c931a3efd24f3099ee5b5d95eea728 139a2221a6b24a2e88d2b344c4d72b41 1f560c8f7c314f64883c784170b09cb8 X 150e81cf05ff43d8a45d9753bea37e52--1f560c8f7c314f64883c784170b09cb8 556e707abb3b4eb28228f33b613a312d 1f560c8f7c314f64883c784170b09cb8--556e707abb3b4eb28228f33b613a312d 6cc3cfc55c82466ca029a82ba7087587 X 556e707abb3b4eb28228f33b613a312d--6cc3cfc55c82466ca029a82ba7087587 44bfe212a29d49808cef72218554cf37 X 6cc3cfc55c82466ca029a82ba7087587--44bfe212a29d49808cef72218554cf37 552b8f4893044de29f91eead82aca418 44bfe212a29d49808cef72218554cf37--552b8f4893044de29f91eead82aca418 3acdf0a8a5674d948cf46b841d48baeb X 552b8f4893044de29f91eead82aca418--3acdf0a8a5674d948cf46b841d48baeb 3acdf0a8a5674d948cf46b841d48baeb--139a2221a6b24a2e88d2b344c4d72b41 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_054d03c605844fd4b540ce0092f184b8 cluster_1b20459123fa471b8c1ffbead3b36ddb fca13c8d70954b53a5d7368e2657150d 0 6179d72423c545df811fc73e4202f7cc X fca13c8d70954b53a5d7368e2657150d--6179d72423c545df811fc73e4202f7cc 1d584da4e5df4ef5a621d6378a837242 1 893913b124a342da9f44130a19978881 HamEvo 6179d72423c545df811fc73e4202f7cc--893913b124a342da9f44130a19978881 5b764d33491f4e8fb47a4e3648ed6945 X 893913b124a342da9f44130a19978881--5b764d33491f4e8fb47a4e3648ed6945 44cdebc3c3d9431aae86fa67d1bfef3c 5b764d33491f4e8fb47a4e3648ed6945--44cdebc3c3d9431aae86fa67d1bfef3c b91ac4cd9b824084b6e38ae13d00e035 HamEvo 44cdebc3c3d9431aae86fa67d1bfef3c--b91ac4cd9b824084b6e38ae13d00e035 cfc8539d568748f98ad59dcd5722f2c7 b91ac4cd9b824084b6e38ae13d00e035--cfc8539d568748f98ad59dcd5722f2c7 259ff443ef7a459f9a1fbe02e7b3b162 cfc8539d568748f98ad59dcd5722f2c7--259ff443ef7a459f9a1fbe02e7b3b162 e68b3b3b482a4a7fab4d65ecf80b2d1e 7de49e27f19044f2926266eb9ff1c8c3 1d584da4e5df4ef5a621d6378a837242--7de49e27f19044f2926266eb9ff1c8c3 05b4b80760f34d7e9ec317a8b2749fe1 2 88579bf7a8cc469399dc9aad20cad596 t = -500.000000000000 7de49e27f19044f2926266eb9ff1c8c3--88579bf7a8cc469399dc9aad20cad596 c334b18ff4ce46749b31be622add74c5 88579bf7a8cc469399dc9aad20cad596--c334b18ff4ce46749b31be622add74c5 6a389f91c3ca413fafdb77d573f31824 X c334b18ff4ce46749b31be622add74c5--6a389f91c3ca413fafdb77d573f31824 9c02fdecfa5b4b8fa4a63486eaa223d3 t = -500.000000000000 6a389f91c3ca413fafdb77d573f31824--9c02fdecfa5b4b8fa4a63486eaa223d3 33f1d8880a324e958fe7c2bc7aa761ac X 9c02fdecfa5b4b8fa4a63486eaa223d3--33f1d8880a324e958fe7c2bc7aa761ac 33f1d8880a324e958fe7c2bc7aa761ac--e68b3b3b482a4a7fab4d65ecf80b2d1e 2e2233f1c2e6408c8277c3f85ace1339 d1328712813f4beaafb9a9e53899341e X 05b4b80760f34d7e9ec317a8b2749fe1--d1328712813f4beaafb9a9e53899341e 96bda9e9ec954f9c8feb833fc3a2af57 d1328712813f4beaafb9a9e53899341e--96bda9e9ec954f9c8feb833fc3a2af57 49bcf5abcd494ac09b63e5b29794ae5f X 96bda9e9ec954f9c8feb833fc3a2af57--49bcf5abcd494ac09b63e5b29794ae5f f68fc02b507c4f23b78325af75ee6464 X 49bcf5abcd494ac09b63e5b29794ae5f--f68fc02b507c4f23b78325af75ee6464 d6fe4e2da284410f9d6afa7635fd7aed f68fc02b507c4f23b78325af75ee6464--d6fe4e2da284410f9d6afa7635fd7aed f35e9422f0ba4923b52115f8cb8c23d7 X d6fe4e2da284410f9d6afa7635fd7aed--f35e9422f0ba4923b52115f8cb8c23d7 f35e9422f0ba4923b52115f8cb8c23d7--2e2233f1c2e6408c8277c3f85ace1339 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7080-0.0207j,  0.0395+0.3061j,  0.0039-0.0540j,  0.6220-0.1151j]])\nsample = Counter({'00': 27, '11': 18, '01': 5})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-10-16T10:47:50.773439 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-10-16T10:47:50.898240 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 26, '01': 18, '11': 6})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-10-16T10:47:51.434535 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-10-16T10:47:51.602856 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system. A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on. Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations such as single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks. Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks. Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time). Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time). Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian</p> <pre><code>H = \u2211\u1d62(h\u03a9/2 sin(\u03c6)*X\u1d62 - cos(\u03c6)*Y\u1d62 - h\u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits. In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interation</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially. On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially. On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically. On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically. On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks. Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially. Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed). Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally. Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.5034+0.1645j, -0.2575-0.4773j, -0.1863-0.2398j, -0.5771+0.0125j],\n[ 0.0301-0.4791j,  0.5561+0.0912j, -0.5891-0.2234j, -0.1547-0.1766j],\n[-0.1238-0.5348j, -0.3862-0.0394j,  0.2656+0.1068j, -0.1997-0.6528j],\n[-0.3733-0.2200j, -0.1777-0.4539j,  0.0268-0.6544j,  0.3337+0.1853j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"chebyshev\")\nreturn tag(fm, tag=\"ChebyshevFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nif support is None:\nsupport = tuple(range(n_qubits))\nxmax = max(feature_range)\nxmin = min(feature_range)\nx = Parameter(param, trainable=False)\n# The feature map works on the range of 0 to 2**n\nx_rescaled = 2 * np.pi * (x - xmin) / (xmax - xmin)\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = kron(RZ(support[i], x_rescaled * (2**i)) for i in range(n_qubits))\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type='fourier')</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Overrides <code>n_qubits</code>. Puts one rotation gate on every qubit in <code>support</code>.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map.</p> <p> TYPE: <code>Type[Rotation]</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Determines the additional expression the final feature parameter (the addtional term in front of <code>param</code>). <code>\"fourier\": param</code> (nothing is done to <code>param</code>) <code>\"chebyshev\": 2*acos(param)</code>, <code>\"tower\": (i+1)*2*acos(param)</code> (where <code>i</code> is the qubit index).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <p>Example: <pre><code>from qadence import feature_map\nfm = feature_map(3, fm_type=\"fourier\")\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=\"chebyshev\")\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=\"tower\")\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['2*acos(phi)']]\nfm = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['4*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['6*acos(phi)']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"phi\",\nop: Type[Rotation] = RX,\nfm_type: str = \"fourier\",\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Overrides `n_qubits`. Puts one rotation gate on every qubit in `support`.\n        param: Parameter of the feature map.\n        op: Rotation operation of the feature map.\n        fm_type: Determines the additional expression the final feature parameter (the addtional\n            term in front of `param`). `\"fourier\": param` (nothing is done to `param`)\n            `\"chebyshev\": 2*acos(param)`, `\"tower\": (i+1)*2*acos(param)` (where `i` is the qubit\n            index).\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map\n    fm = feature_map(3, fm_type=\"fourier\")\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=\"chebyshev\")\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=\"tower\")\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\nfparam = FeatureParameter(param)\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif fm_type == \"fourier\":\nfm = kron(*[op(qubit, fparam) for qubit in support])\nelif fm_type == \"chebyshev\":\nfm = kron(*[op(qubit, 2 * sympy.acos(fparam)) for qubit in support])\nelif fm_type == \"tower\":\nfm = kron(*[op(qubit, (i + 1) * 2 * sympy.acos(fparam)) for i, qubit in enumerate(support)])\nelse:\nraise NotImplementedError(f\"Feature map {fm_type} not implemented\")\nfm.tag = \"FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"fourier\")\nreturn tag(fm, tag=\"FourierFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: Type[Rotation] = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=\"tower\")\nreturn tag(fm, tag=\"TowerFM\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers using step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers\n    using step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian with another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian\n    with another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"\n    Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments (see in the examples).</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments\n    (see in the examples).\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function. The default value of each field can be customize with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f137b657e20&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f137b657eb0&gt;, batch_size=1)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>. Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.data_to_model","title":"<code>data_to_model(xs, device='cpu')</code>","text":"<p>Default behavior for single-dispatched function</p> <p>Just return the given data independently on the type</p> PARAMETER  DESCRIPTION <code>xs</code> <p>the input data</p> <p> TYPE: <code>Any</code> </p> <code>device</code> <p>The torch device. Not used in this implementation.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>the <code>xs</code> argument untouched</p> <p> TYPE: <code>Any</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>@singledispatch\ndef data_to_model(xs: Any, device: str = \"cpu\") -&gt; Any:\n\"\"\"Default behavior for single-dispatched function\n    Just return the given data independently on the type\n    Args:\n        xs (Any): the input data\n        device (str, optional): The torch device. Not used in this implementation.\n    Returns:\n        Any: the `xs` argument untouched\n    \"\"\"\nreturn xs\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs, device='cpu')</code>","text":"<p>Default Torch optimize step with closure</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> <code>device</code> <p>The device were computations are executed. Defaults to \"cpu\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\ndevice: str = \"cpu\",\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n        device (str, optional): The device were computations are executed.\n            Defaults to \"cpu\".\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | list[Tensor] | tuple[Tensor, Tensor] | None,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence.constructors import hamiltonian_factory, hea, feature_map\n    from qadence import chain, Parameter, QuantumCircuit, Z\n    from qadence.models import QNN\n    from qadence.ml_tools import train_with_grad, TrainConfig\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n        batch_size=batch_size,\n    )\n    batch_size = 25\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    train_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\nassert loss_fn is not None, \"Provide a valid loss function\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nif isinstance(dataloader, (list, tuple)):\nfrom qadence.ml_tools.data import to_dataloader\nassert len(dataloader) == 2, \"Please provide exactly two torch tensors.\"\nx, y = dataloader\ndataloader = to_dataloader(x=x, y=y, batch_size=config.batch_size)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, dataloader, device=device\n)\nloss = loss.item()\n# single epoch with DictDataloader using a single iteration method\n# DictDataloader returns a single sample of the data\n# with a given batch size decided when the dataloader is defined\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data, device=device)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\n# TODO: make sure to average metrics as well\nloss, metrics = optimize_step(\nmodel, optimizer, loss_fn, data, device=device\n)\nrunning_loss += loss.item()\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if isinstance(dataloader, DictDataLoader) else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, DictDataLoader):\n# resample all the time from the dataloader\n# by creating a fresh iterator if the dataloader\n# does not support automatically iterating datasets\nif not dataloader.has_automatic_iter:\ndl_iter = iter(dataloader)\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelif isinstance(dataloader, DataLoader):\n# single-epoch with standard DataLoader\n# otherwise a standard PyTorch DataLoader behavior\n# is assumed with optional mini-batches\nrunning_loss = 0.0\nfor i, data in enumerate(dataloader):\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nrunning_loss += loss\nloss = running_loss / (i + 1)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> A block implementing the Hamiltonian evolution operation H where <p>H = exp(-iG, t)</p> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.2374-5.1225e-17j, -0.7288+3.0170e-17j],\n[ 1.1660-4.0583e-17j, -0.5995+2.0868e-17j]])\ntensor([[1.7414-1.2075j, 0.7742-1.1094j],\n[1.3634-0.3266j, 0.4083-0.2874j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation. Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation. Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=np.pi / 2)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names. This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['8aa4c82d-e704-43a7-89ed-805aafeab6ee', '0d6b4a34-52a6-4454-9230-96080023dc31'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code> to include two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters. Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"PARAMETER  DESCRIPTION <code>name</code> <p>When given a string only, the class constructs a trainable Parameter with a a randomly initialized value.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> </p> <code>**assumptions</code> <p>are passed on to the parent class <code>sympy.Symbol</code>. Two new assumption kwargs are supported by this constructor: <code>trainable: bool</code>, and <code>value: TNumber</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>from qadence import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.854665659675864\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = torch.rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> <code>values</code> <p>values dict which contains values for the Parameters, if empty, Parameter.value will be used.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>as_torch</code> <p>Whether to retrieve a torch-differentiable expression result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.013496193764961003\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn torch.Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: torch.tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[expr], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>A QuantumCircuit instance is completely abstract and it needs to be passed to a quantum backend in order to be executed.</p> PARAMETER  DESCRIPTION <code>support</code> <p><code>Register</code> or number of qubits. If an integer is provided, a register is constructed with <code>Register.all_to_all(x)</code></p> <p> TYPE: <code>int | Register</code> </p> <code>*blocks</code> <p>(Possibly multiple) blocks to construct the circuit from.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag</p> <p>This function recurservily explores all composite blocks to find all the occurrences of a certain tag in the blocks</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag\n    This function recurservily explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates (needed for e.g. analog computing). The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates (needed for e.g. analog\n    computing). The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f61312ab-bc3c-4e97-ade0-75d4660cfd44', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9649102256983412'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4204b913-e515-467e-958b-963aa0093dc6', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.855299175233669'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('70885f9e-72c1-407a-8269-234faccec9ea', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.4821242625372467'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('860eed9a-f83d-4d64-a76f-699e49dd3d4d', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.7216139771883192'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0473227b-c410-4411-8fd8-e8ef8a5156b3', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5520005343296959'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3a0bfb92-362e-4829-b5ed-f7dadbf2b3fe', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.5128236248712018'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a0c7d6b1-b48c-436a-9ae7-43c9c6f95aba', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.7262773469971591'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('dc28d21e-d884-4c1e-b7fa-b3898a1821c7', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9592730319839947'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8ed131ca-81e5-4974-883e-023188699ec9', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.29853362350562773'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0ee63752-47eb-4828-9c22-6b77df2f4dbf', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.8358036266838368'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a0319e57-df01-41a3-a7b9-34c364ea158d', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.5395678859265043'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3c1419a2-1819-4fae-a76b-dd9bebbaf557', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>10101001\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.backend import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[0.3686-0.0605j, 0.2386+0.1186j, 0.0478+0.7804j, 0.0436-0.4199j]])\ntensor([[ 0.3878+0.j,  0.4348+0.j, -0.5409+0.j, -0.6066+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.backend import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = _run_state(_abstract_random_state(n_qubits, batch_size), backend)  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation. Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation. Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0,1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\nkronblocks = block.blocks  # type: ignore[attr-defined]\nn_blocks = len(kronblocks)\nchains = []\nfor qb_idx in range(block.n_qubits):\nprim_gates = []\nfor kron_idx in range(n_blocks):\nprim_gates.append(kronblocks[kron_idx][qb_idx])  # type: ignore[index]\nchains.append(chain(*prim_gates))\ntry:\nreturn kron(*chains)\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.flatten","title":"<code>flatten(block, types=[ChainBlock, KronBlock, AddBlock])</code>","text":"<p>Flattens the given types of <code>CompositeBlock</code>s if possible.</p> <p>Example: <pre><code>from qadence import chain, kron, X\nfrom qadence.transpile import flatten\nfrom qadence.blocks import ChainBlock, KronBlock, AddBlock\nx = chain(chain(chain(X(0))), kron(kron(X(0))))\n# flatten only `ChainBlock`s\nassert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n# flatten `ChainBlock`s and `KronBlock`s\nassert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n# flatten `AddBlock`s (does nothing in this case)\nassert flatten(x, [AddBlock]) == x\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def flatten(block: AbstractBlock, types: list = [ChainBlock, KronBlock, AddBlock]) -&gt; AbstractBlock:\n\"\"\"Flattens the given types of `CompositeBlock`s if possible.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import chain, kron, X\n    from qadence.transpile import flatten\n    from qadence.blocks import ChainBlock, KronBlock, AddBlock\n    x = chain(chain(chain(X(0))), kron(kron(X(0))))\n    # flatten only `ChainBlock`s\n    assert flatten(x, [ChainBlock]) == chain(X(0), kron(kron(X(0))))\n    # flatten `ChainBlock`s and `KronBlock`s\n    assert flatten(x, [ChainBlock, KronBlock]) == chain(X(0), kron(X(0)))\n    # flatten `AddBlock`s (does nothing in this case)\n    assert flatten(x, [AddBlock]) == x\n    ```\n    \"\"\"\nif isinstance(block, CompositeBlock):\ndef fn(b: AbstractBlock, T: Type) -&gt; AbstractBlock:\nreturn _construct(type(block), tuple(_flat_blocks(b, T)))\nreturn reduce(fn, types, block)  # type: ignore[arg-type]\nelif isinstance(block, ScaleBlock):\nblk = deepcopy(block)\nblk.block = flatten(block.block, types=types)\nreturn blk\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks, move the scale all the way down into the leaves of the block tree.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"When given a scaled CompositeBlock consisting of several PrimitiveBlocks,\n    move the scale all the way down into the leaves of the block tree.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks and reassigning qubit locations approriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks and reassigning\n    qubit locations approriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.emulate.add_interaction","title":"<code>add_interaction(x, *args, interaction=Interaction.NN, spacing=1.0)</code>","text":"<p>Turns blocks or circuits into (a chain of) <code>HamEvo</code> blocks including a chosen interaction term.</p> <p>This is a <code>@singledipatch</code>ed function which can be called in three ways:</p> <ul> <li>With a <code>QuantumCircuit</code> which contains all necessary information: <code>add_interaction(circuit)</code></li> <li>With a <code>Register</code> and an <code>AbstractBlock</code>: <code>add_interaction(reg, block)</code></li> <li>With an <code>AbstractBlock</code> only: <code>add_interaction(block)</code></li> </ul> <p>See the section about analog blocks for detailed information about how which types of blocks are translated.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit or block to be emulated. See the examples on which argument combinations are accepted.</p> <p> TYPE: <code>Register | QuantumCircuit | AbstractBlock</code> </p> <code>interaction</code> <p>Type of interaction that is added. Can also be a function that accepts a register and a list of edges that define which qubits interact (see the examples).</p> <p> TYPE: <code>Interaction | Callable</code> DEFAULT: <code>NN</code> </p> <code>spacing</code> <p>All qubit coordinates are multiplied by <code>spacing</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import QuantumCircuit, AnalogRX, add_interaction\nc = QuantumCircuit(2, AnalogRX(2.0))\ne = add_interaction(c)\n</code></pre> <pre><code>[mul: 0.0] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 AddBlock(0,1)\n\u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u251c\u2500\u2500 [mul: 1.571] \u2502       \u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u2502       \u251c\u2500\u2500 AddBlock(0)\n\u2502       \u2502       \u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502       \u2502   \u2502   \u2514\u2500\u2500 X(0)\n\u2502       \u2502       \u2502   \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502       \u2502       \u2514\u2500\u2500 Y(0)\n\u2502       \u2502       \u2514\u2500\u2500 AddBlock(1)\n\u2502       \u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502           \u2502   \u2514\u2500\u2500 X(1)\n\u2502       \u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502               \u2514\u2500\u2500 Y(1)\n\u2502       \u2514\u2500\u2500 [mul: 0.0] \u2502           \u2514\u2500\u2500 AddBlock(0,1)\n\u2502               \u251c\u2500\u2500 N(0)\n\u2502               \u2514\u2500\u2500 N(1)\n\u2514\u2500\u2500 AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 865723.020] \u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 N(0)\n\u2514\u2500\u2500 N(1)\n</code></pre>  You can also use <code>add_interaction</code> directly on a block, but you have to provide either the <code>Register</code> or define a non-global qubit support. <pre><code>from qadence import AnalogRX, Register, add_interaction\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b)\n# or provide only the block with local qubit support\n# in this case the register is created via `Register(b.n_qubits)`\ne = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\nprint(e.generator)\n</code></pre> <pre><code>[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n</code></pre>  You can specify a custom <code>interaction</code> function which has to accept a <code>Register</code> and a list of <code>edges: list[tuple[int, int]]</code>: <pre><code>from qadence import AnalogRX, Register, add_interaction\nfrom qadence.transpile.emulate import ising_interaction\ndef int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n# do either something completely custom\n# ...\n# or e.g. change the default kwargs to `ising_interaction`\nreturn ising_interaction(r, pairs, rydberg_level=70)\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b, interaction=int_fn)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/emulate.py</code> <pre><code>@singledispatch\ndef add_interaction(\nx: Register | QuantumCircuit | AbstractBlock,\n*args: Any,\ninteraction: Interaction | Callable = Interaction.NN,\nspacing: float = 1.0,\n) -&gt; QuantumCircuit | AbstractBlock:\n\"\"\"Turns blocks or circuits into (a chain of) `HamEvo` blocks including a\n    chosen interaction term.\n    This is a `@singledipatch`ed function which can be called in three ways:\n    * With a `QuantumCircuit` which contains all necessary information: `add_interaction(circuit)`\n    * With a `Register` and an `AbstractBlock`: `add_interaction(reg, block)`\n    * With an `AbstractBlock` only: `add_interaction(block)`\n    See the section about [analog blocks](/digital_analog_qc/analog-basics.md) for\n    detailed information about how which types of blocks are translated.\n    Arguments:\n        x: Circuit or block to be emulated. See the examples on which argument\n            combinations are accepted.\n        interaction: Type of interaction that is added. Can also be a function that accepts a\n            register and a list of edges that define which qubits interact (see the examples).\n        spacing: All qubit coordinates are multiplied by `spacing`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import QuantumCircuit, AnalogRX, add_interaction\n    c = QuantumCircuit(2, AnalogRX(2.0))\n    e = add_interaction(c)\n    print(str(e.block.generator)) # markdown-exec: hide\n    ```\n    You can also use `add_interaction` directly on a block, but you have to provide either\n    the `Register` or define a non-global qubit support.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b)\n    print(e.generator) # markdown-exec: hide\n    # or provide only the block with local qubit support\n    # in this case the register is created via `Register(b.n_qubits)`\n    e = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\n    print(e.generator)\n    ```\n    You can specify a custom `interaction` function which has to accept a `Register` and a list\n    of `edges: list[tuple[int, int]]`:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    from qadence.transpile.emulate import ising_interaction\n    def int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n        # do either something completely custom\n        # ...\n        # or e.g. change the default kwargs to `ising_interaction`\n        return ising_interaction(r, pairs, rydberg_level=70)\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b, interaction=int_fn)\n    ```\n    \"\"\"\nraise ValueError(f\"`add_interaction` is not implemented for {type(x)}\")\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, torch.Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[torch.Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, torch.Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in - <code>add_interaction</code>. - <code>hamiltonian_factory</code>.</p>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML) [^1] in particular are the target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\nfp = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(RX(i, 2 * acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(feature_map, values=inputs)\nprint(samples)\n</code></pre>   [Counter({'1111': 75, '1011': 9, '0111': 6, '1101': 4, '1110': 4, '0110': 2}), Counter({'1111': 24, '1110': 16, '1101': 9, '0111': 8, '1001': 7, '0011': 6, '0110': 6, '0100': 5, '1010': 5, '1011': 5, '0101': 3, '0010': 2, '1100': 2, '0000': 1, '0001': 1}), Counter({'0000': 28, '1000': 14, '0001': 12, '0010': 6, '0100': 6, '0101': 6, '1100': 6, '0011': 5, '0110': 4, '1001': 4, '1011': 2, '1101': 2, '1110': 2, '0111': 1, '1010': 1, '1111': 1})]    <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansaztz and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\nprint(f\"Quantum model output: {out}\")\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre>   Quantum model output: tensor([[0.1904],         [0.3953],         [0.2193],         [0.0431],         [0.2558],         [0.3160],         [0.0408],         [0.4406],         [0.4627],         [0.4138]], grad_fn=) First-order derivative w.r.t. the feature parameter: tensor([ 0.5730,  0.6237,  0.6140, -1.0375,  0.6560,  0.6914, -0.9687, -0.5948,         -0.1979, -0.8826], grad_fn=)    <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: {dout}\")\n</code></pre>   First-order derivative w.r.t. the feature parameter: tensor([ 0.5730,  0.6237,  0.6140, -1.0375,  0.6560,  0.6914, -0.9687, -0.5948,         -0.1979, -0.8826], grad_fn=)    <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-10-16T10:47:55.869046 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_588c94fa10994277873333d7b5962c7c mixing cluster_8f694f6e06f7467ea85f14ccd5e5506b cost cluster_21ab95b1d4db49658bcb51e3ce477268 mixing cluster_a12698e528ef4c62bdbecaac67699ff9 cost 4bbac93bd4d945c0b0ad6fe7260c245a 0 36e55aedf4e6439d96e2949646cd8776 4bbac93bd4d945c0b0ad6fe7260c245a--36e55aedf4e6439d96e2949646cd8776 2bf6aaddb8bb4850956ff790cdfc66c9 1 727b3528511a4ccd83b0c8fe2e78e123 36e55aedf4e6439d96e2949646cd8776--727b3528511a4ccd83b0c8fe2e78e123 7dc9611b87d44375b958b1979a67fc41 727b3528511a4ccd83b0c8fe2e78e123--7dc9611b87d44375b958b1979a67fc41 83b5471634164cdcab3dd077d783543f 7dc9611b87d44375b958b1979a67fc41--83b5471634164cdcab3dd077d783543f b45821aefd3e4ba1b3a1d651f1547d4d 83b5471634164cdcab3dd077d783543f--b45821aefd3e4ba1b3a1d651f1547d4d fd0d1928b04a4369914b39665e0f362e b45821aefd3e4ba1b3a1d651f1547d4d--fd0d1928b04a4369914b39665e0f362e f1504e7693d84ea6b64af4c074e93f45 fd0d1928b04a4369914b39665e0f362e--f1504e7693d84ea6b64af4c074e93f45 0b7db375066d4d79999da2a4c1db62e7 f1504e7693d84ea6b64af4c074e93f45--0b7db375066d4d79999da2a4c1db62e7 824640776b8043f0998fc5457f3c8960 0b7db375066d4d79999da2a4c1db62e7--824640776b8043f0998fc5457f3c8960 3ab7505862d84819a6cb4e8359a878f9 824640776b8043f0998fc5457f3c8960--3ab7505862d84819a6cb4e8359a878f9 310c155dc93046709f37f0d33db30911 3ab7505862d84819a6cb4e8359a878f9--310c155dc93046709f37f0d33db30911 3455c8743aba499ea443b1fac7a654b3 310c155dc93046709f37f0d33db30911--3455c8743aba499ea443b1fac7a654b3 ec4a48da67684e6292e0793e1af13b17 3455c8743aba499ea443b1fac7a654b3--ec4a48da67684e6292e0793e1af13b17 f1429e3d73d34f9693e7d3b6cb53ed32 ec4a48da67684e6292e0793e1af13b17--f1429e3d73d34f9693e7d3b6cb53ed32 15d8b5cc03564f27951ddfa5595ec358 f1429e3d73d34f9693e7d3b6cb53ed32--15d8b5cc03564f27951ddfa5595ec358 c4e7af3066d34999950e7ee405ed4b36 15d8b5cc03564f27951ddfa5595ec358--c4e7af3066d34999950e7ee405ed4b36 1124a537493c498682be5d9d3af10c24 c4e7af3066d34999950e7ee405ed4b36--1124a537493c498682be5d9d3af10c24 01a280e04fc84ea1992a3e8ec954ee1e 1124a537493c498682be5d9d3af10c24--01a280e04fc84ea1992a3e8ec954ee1e 2ef24df57f464b5f975a4d48874c204d 01a280e04fc84ea1992a3e8ec954ee1e--2ef24df57f464b5f975a4d48874c204d 6ecce35d13364dd79f969024e0463275 2ef24df57f464b5f975a4d48874c204d--6ecce35d13364dd79f969024e0463275 bb9f30713c45408ea6721ddedd57df26 6ecce35d13364dd79f969024e0463275--bb9f30713c45408ea6721ddedd57df26 5f800aff0a944008805c3452319e799b bb9f30713c45408ea6721ddedd57df26--5f800aff0a944008805c3452319e799b 4857ff07ab344de2b72530837b51c40d 5f800aff0a944008805c3452319e799b--4857ff07ab344de2b72530837b51c40d c72e1df1e7724e498084348a2c1dc87a 4857ff07ab344de2b72530837b51c40d--c72e1df1e7724e498084348a2c1dc87a 856a6d7b1a454675a219ddc29cedc32c c72e1df1e7724e498084348a2c1dc87a--856a6d7b1a454675a219ddc29cedc32c 81110719708d489e86b16399de333f7e 856a6d7b1a454675a219ddc29cedc32c--81110719708d489e86b16399de333f7e 74e9a8efb8934f4ca6dbf3be2ff23ed2 81110719708d489e86b16399de333f7e--74e9a8efb8934f4ca6dbf3be2ff23ed2 2f26245cffa74b4fb3e78d5739b22be2 74e9a8efb8934f4ca6dbf3be2ff23ed2--2f26245cffa74b4fb3e78d5739b22be2 86fab4dbb24f452f970d3a69c279203c 2f26245cffa74b4fb3e78d5739b22be2--86fab4dbb24f452f970d3a69c279203c a6b5937c8f374ce19daa0a5c125f073b 86fab4dbb24f452f970d3a69c279203c--a6b5937c8f374ce19daa0a5c125f073b 7a4bdaf303994e789e0b9910a4172bc1 a6b5937c8f374ce19daa0a5c125f073b--7a4bdaf303994e789e0b9910a4172bc1 209e16d2b5264f92948a89f11c10d743 7a4bdaf303994e789e0b9910a4172bc1--209e16d2b5264f92948a89f11c10d743 3d5999e8e6c9406ead928ef49fbf4a42 209e16d2b5264f92948a89f11c10d743--3d5999e8e6c9406ead928ef49fbf4a42 64d65d7d999143d3b16170574b91df1f 3d5999e8e6c9406ead928ef49fbf4a42--64d65d7d999143d3b16170574b91df1f 678a5dfde65442e695654bf81d71bda0 64d65d7d999143d3b16170574b91df1f--678a5dfde65442e695654bf81d71bda0 f0b782e003024d33951670e6950338b5 678a5dfde65442e695654bf81d71bda0--f0b782e003024d33951670e6950338b5 68f318d5438b418e9768e15045bd4633 f0b782e003024d33951670e6950338b5--68f318d5438b418e9768e15045bd4633 56457829e3fe4fd89f2fb036ba66a4cd 68f318d5438b418e9768e15045bd4633--56457829e3fe4fd89f2fb036ba66a4cd 3a0e5c333e0c45ce8c5fbcdf2a4f6907 56457829e3fe4fd89f2fb036ba66a4cd--3a0e5c333e0c45ce8c5fbcdf2a4f6907 e4e6900d4ff84cd79e4f896d83abb5ba 3a0e5c333e0c45ce8c5fbcdf2a4f6907--e4e6900d4ff84cd79e4f896d83abb5ba acdb8c2126b042bc980be4c01912d8ba e4e6900d4ff84cd79e4f896d83abb5ba--acdb8c2126b042bc980be4c01912d8ba adae58c0bd95497b960e12f6396231a8 acdb8c2126b042bc980be4c01912d8ba--adae58c0bd95497b960e12f6396231a8 d43a7d2095e84c13889b8d2cc74c2d24 adae58c0bd95497b960e12f6396231a8--d43a7d2095e84c13889b8d2cc74c2d24 e3257556fdfb4aa4b684a9b4a6de3616 d43a7d2095e84c13889b8d2cc74c2d24--e3257556fdfb4aa4b684a9b4a6de3616 177e3eb6d85140b2b94f9706699ceb11 e3257556fdfb4aa4b684a9b4a6de3616--177e3eb6d85140b2b94f9706699ceb11 be32c2f3536d4c21a35372239cfd0b42 177e3eb6d85140b2b94f9706699ceb11--be32c2f3536d4c21a35372239cfd0b42 7c61ab2d4d644ebeaacf5c87d5736302 be32c2f3536d4c21a35372239cfd0b42--7c61ab2d4d644ebeaacf5c87d5736302 2527e3ccbb1f49b49cdca49f1c6eacb6 7c61ab2d4d644ebeaacf5c87d5736302--2527e3ccbb1f49b49cdca49f1c6eacb6 bd179e4e6b8b4840809205e7228841d2 2527e3ccbb1f49b49cdca49f1c6eacb6--bd179e4e6b8b4840809205e7228841d2 cd919d935b5e4944b2c5dd370caf5647 bd179e4e6b8b4840809205e7228841d2--cd919d935b5e4944b2c5dd370caf5647 8532705db0b0489b89668faa53cb70ea cd919d935b5e4944b2c5dd370caf5647--8532705db0b0489b89668faa53cb70ea d09a1f5f2294468882853aafd6adc0c5 8532705db0b0489b89668faa53cb70ea--d09a1f5f2294468882853aafd6adc0c5 8053b6a17d17467b93cffc2b3ec2a032 d09a1f5f2294468882853aafd6adc0c5--8053b6a17d17467b93cffc2b3ec2a032 78477227b71c49a893e5c206adaad520 8053b6a17d17467b93cffc2b3ec2a032--78477227b71c49a893e5c206adaad520 7cf590dc3c674137aeb3806cf025d664 78477227b71c49a893e5c206adaad520--7cf590dc3c674137aeb3806cf025d664 39086fd0185c4b9b820fde42c5766c5d 7cf590dc3c674137aeb3806cf025d664--39086fd0185c4b9b820fde42c5766c5d 64dd732054c341d9bca9b9a6b1a3074b 39086fd0185c4b9b820fde42c5766c5d--64dd732054c341d9bca9b9a6b1a3074b 05b11417a3634331a189a8a917a803c5 64dd732054c341d9bca9b9a6b1a3074b--05b11417a3634331a189a8a917a803c5 b567a5ffc1f9420b80fb189d1822bc2f 05b11417a3634331a189a8a917a803c5--b567a5ffc1f9420b80fb189d1822bc2f 6d96761120fa43ad8c15e0c77506fc17 b567a5ffc1f9420b80fb189d1822bc2f--6d96761120fa43ad8c15e0c77506fc17 e383fe3270f24c80a4ce2e5d3327c29a 6d96761120fa43ad8c15e0c77506fc17--e383fe3270f24c80a4ce2e5d3327c29a 8dbcc45ca8184ece950e13c4d085e9ac e383fe3270f24c80a4ce2e5d3327c29a--8dbcc45ca8184ece950e13c4d085e9ac 0376c7b2456240f9aa488dccbfe5794a 8dbcc45ca8184ece950e13c4d085e9ac--0376c7b2456240f9aa488dccbfe5794a 177a58253a944440b397c1b5adb85641 0376c7b2456240f9aa488dccbfe5794a--177a58253a944440b397c1b5adb85641 c5ff7dac24cd4d0abb70f8362c9556c6 177a58253a944440b397c1b5adb85641--c5ff7dac24cd4d0abb70f8362c9556c6 8b70d3a47501424a898e7c361a4e31fc c5ff7dac24cd4d0abb70f8362c9556c6--8b70d3a47501424a898e7c361a4e31fc 40940bc4a60247b4b8274b5520e36a8e 8b70d3a47501424a898e7c361a4e31fc--40940bc4a60247b4b8274b5520e36a8e c10f130317294847a9668657bf098b0b 40940bc4a60247b4b8274b5520e36a8e--c10f130317294847a9668657bf098b0b 279a5834c2ae4714946ba654aa616a35 c10f130317294847a9668657bf098b0b--279a5834c2ae4714946ba654aa616a35 2a20262749c34a2082d15a8cd49a312a 279a5834c2ae4714946ba654aa616a35--2a20262749c34a2082d15a8cd49a312a 00c47e8d308043c68967ad67a0bcc7d3 2a20262749c34a2082d15a8cd49a312a--00c47e8d308043c68967ad67a0bcc7d3 d79e4c708afb4075a6a8742d3c527425 00c47e8d308043c68967ad67a0bcc7d3--d79e4c708afb4075a6a8742d3c527425 bfcb29dea4504fbcb737783350cf9682 d79e4c708afb4075a6a8742d3c527425--bfcb29dea4504fbcb737783350cf9682 f05f5953b141409091404e8ad5e7437e bfcb29dea4504fbcb737783350cf9682--f05f5953b141409091404e8ad5e7437e c5f19756f9cb40b4b5ac8e6abd75b84d f05f5953b141409091404e8ad5e7437e--c5f19756f9cb40b4b5ac8e6abd75b84d 850ee4dd8cb34d498d522b4e317ef9ff c5f19756f9cb40b4b5ac8e6abd75b84d--850ee4dd8cb34d498d522b4e317ef9ff 37a66f85fee948e5b912765edfcd0c98 850ee4dd8cb34d498d522b4e317ef9ff--37a66f85fee948e5b912765edfcd0c98 1446bf0ba69e4949a36c1d4ab31e1965 37a66f85fee948e5b912765edfcd0c98--1446bf0ba69e4949a36c1d4ab31e1965 65e974fd33ea4ce8bcd4b19a526b05ce 1446bf0ba69e4949a36c1d4ab31e1965--65e974fd33ea4ce8bcd4b19a526b05ce b4a90a3d9a4b4fad91590b5b125eebf6 65e974fd33ea4ce8bcd4b19a526b05ce--b4a90a3d9a4b4fad91590b5b125eebf6 9439291e0cb64bc2ac7efb3b571d4cdf b4a90a3d9a4b4fad91590b5b125eebf6--9439291e0cb64bc2ac7efb3b571d4cdf 0eb69e1fb4fa4d2ab6be27e6357cabe2 9439291e0cb64bc2ac7efb3b571d4cdf--0eb69e1fb4fa4d2ab6be27e6357cabe2 fd5db56aeb944e8e86bcaa90add6231f 0eb69e1fb4fa4d2ab6be27e6357cabe2--fd5db56aeb944e8e86bcaa90add6231f 29e5c60533184b2b927ee525a08fbf34 fd5db56aeb944e8e86bcaa90add6231f--29e5c60533184b2b927ee525a08fbf34 085735f6cd4e4582a956dd446f1eb648 29e5c60533184b2b927ee525a08fbf34--085735f6cd4e4582a956dd446f1eb648 a508aea59dcf4566bde21ad00582d9fc 085735f6cd4e4582a956dd446f1eb648--a508aea59dcf4566bde21ad00582d9fc 5c357050d04044a69e621d7b6123efce a508aea59dcf4566bde21ad00582d9fc--5c357050d04044a69e621d7b6123efce a0b5f081f8eb4381ac49bcf00cd34162 5c357050d04044a69e621d7b6123efce--a0b5f081f8eb4381ac49bcf00cd34162 9246789faac0404ab678fa3ed71efaf3 a0b5f081f8eb4381ac49bcf00cd34162--9246789faac0404ab678fa3ed71efaf3 75a095de391b4c10ab76567c415f1000 9246789faac0404ab678fa3ed71efaf3--75a095de391b4c10ab76567c415f1000 b2ffe81070754788b4fb06150f842e94 75a095de391b4c10ab76567c415f1000--b2ffe81070754788b4fb06150f842e94 c1ab6fca822841c7a00bdf289af7ec93 b2ffe81070754788b4fb06150f842e94--c1ab6fca822841c7a00bdf289af7ec93 6bcc44ee24bf4a368881adfbc232a5c7 c1ab6fca822841c7a00bdf289af7ec93--6bcc44ee24bf4a368881adfbc232a5c7 4be4e1e1d2b54a57ab8aeab394246798 6bcc44ee24bf4a368881adfbc232a5c7--4be4e1e1d2b54a57ab8aeab394246798 e60eebc3ff60429eb293b1ff6655e937 4be4e1e1d2b54a57ab8aeab394246798--e60eebc3ff60429eb293b1ff6655e937 a674071703db4b0d9336c902ca07e554 e60eebc3ff60429eb293b1ff6655e937--a674071703db4b0d9336c902ca07e554 c2be5c60f5584487a4d8ada40ab2d2b0 a674071703db4b0d9336c902ca07e554--c2be5c60f5584487a4d8ada40ab2d2b0 80aaaa7722ec46a0bc890d37ccffd81b c2be5c60f5584487a4d8ada40ab2d2b0--80aaaa7722ec46a0bc890d37ccffd81b e45ad03f7f3d44618275d3bcdaa5fc23 80aaaa7722ec46a0bc890d37ccffd81b--e45ad03f7f3d44618275d3bcdaa5fc23 04db8a6fe9df442cb0f44556595490e7 e45ad03f7f3d44618275d3bcdaa5fc23--04db8a6fe9df442cb0f44556595490e7 800cba70ff44497aad8ada2ed85833c5 04db8a6fe9df442cb0f44556595490e7--800cba70ff44497aad8ada2ed85833c5 71540e690cb74526b34fcc0072ff77cb 800cba70ff44497aad8ada2ed85833c5--71540e690cb74526b34fcc0072ff77cb 68225b415c274d82948ab1703ec7e5c6 71540e690cb74526b34fcc0072ff77cb--68225b415c274d82948ab1703ec7e5c6 0897f079f0a34de1960ffe7eae6fb372 68225b415c274d82948ab1703ec7e5c6--0897f079f0a34de1960ffe7eae6fb372 ad8759fbbf614291a98c98765cc070cf 0897f079f0a34de1960ffe7eae6fb372--ad8759fbbf614291a98c98765cc070cf 764e19f9c6ba4fe9b65dee83529a62d4 ad8759fbbf614291a98c98765cc070cf--764e19f9c6ba4fe9b65dee83529a62d4 7f0637d3ca094a49adc0812136d9f56f 764e19f9c6ba4fe9b65dee83529a62d4--7f0637d3ca094a49adc0812136d9f56f fa364739a9414dfb8fec3fbccc93f729 7f0637d3ca094a49adc0812136d9f56f--fa364739a9414dfb8fec3fbccc93f729 d311a55f1bed40db8f6f0d03e054787c fa364739a9414dfb8fec3fbccc93f729--d311a55f1bed40db8f6f0d03e054787c cec6767b3454462998a62549ba11e5cb RX(b00) d311a55f1bed40db8f6f0d03e054787c--cec6767b3454462998a62549ba11e5cb d442bc9d4ed7481fa10d38fcd9654c4d cec6767b3454462998a62549ba11e5cb--d442bc9d4ed7481fa10d38fcd9654c4d 214a1569b05f431a8c166905139d86cc d442bc9d4ed7481fa10d38fcd9654c4d--214a1569b05f431a8c166905139d86cc 77581a071aca4592ac6259ebefd58429 214a1569b05f431a8c166905139d86cc--77581a071aca4592ac6259ebefd58429 94a107f490954e3b9ec953f7ca18437b 77581a071aca4592ac6259ebefd58429--94a107f490954e3b9ec953f7ca18437b f4c321cce7c042b79024f1007de8e7bf 94a107f490954e3b9ec953f7ca18437b--f4c321cce7c042b79024f1007de8e7bf db2be6ace76c4ceca7820f2a2fd36801 f4c321cce7c042b79024f1007de8e7bf--db2be6ace76c4ceca7820f2a2fd36801 40e5630ab11f44039e434f61f9bfc613 db2be6ace76c4ceca7820f2a2fd36801--40e5630ab11f44039e434f61f9bfc613 a40c75062f304840a12ed98c9882123d 40e5630ab11f44039e434f61f9bfc613--a40c75062f304840a12ed98c9882123d 5e5c38d6f5064f9ebf1e0ae8815618a9 a40c75062f304840a12ed98c9882123d--5e5c38d6f5064f9ebf1e0ae8815618a9 9de3bff161a84f82844db1d96ab7b5d0 5e5c38d6f5064f9ebf1e0ae8815618a9--9de3bff161a84f82844db1d96ab7b5d0 59d93625390245639e740f5ffd3f5e74 9de3bff161a84f82844db1d96ab7b5d0--59d93625390245639e740f5ffd3f5e74 5239ecdff6a549d0a78086d96b971d90 59d93625390245639e740f5ffd3f5e74--5239ecdff6a549d0a78086d96b971d90 62e0b762f09f44ca9b3cfa0fc734e038 5239ecdff6a549d0a78086d96b971d90--62e0b762f09f44ca9b3cfa0fc734e038 f13bbc1cbc23450883972c8e8cacedf2 62e0b762f09f44ca9b3cfa0fc734e038--f13bbc1cbc23450883972c8e8cacedf2 aff06bede46c4aa996a3fd9a6c7c38d1 f13bbc1cbc23450883972c8e8cacedf2--aff06bede46c4aa996a3fd9a6c7c38d1 edbd82c8638b481ca4b2677e3687eff0 aff06bede46c4aa996a3fd9a6c7c38d1--edbd82c8638b481ca4b2677e3687eff0 3942a0394da8451c9e2dd0b1bef3fbf9 edbd82c8638b481ca4b2677e3687eff0--3942a0394da8451c9e2dd0b1bef3fbf9 5b97ea6a07b740ceb903c9eae92295e9 3942a0394da8451c9e2dd0b1bef3fbf9--5b97ea6a07b740ceb903c9eae92295e9 58fd595d31fd4dbfbd0afb5755a500ae 5b97ea6a07b740ceb903c9eae92295e9--58fd595d31fd4dbfbd0afb5755a500ae f8bd3e3c75e842bd916de2753afe8121 58fd595d31fd4dbfbd0afb5755a500ae--f8bd3e3c75e842bd916de2753afe8121 e8b08e294f0e496cbcec93a8cb0ffeaf f8bd3e3c75e842bd916de2753afe8121--e8b08e294f0e496cbcec93a8cb0ffeaf f9336e9b75064ee58e036b5c0fdd1c5d e8b08e294f0e496cbcec93a8cb0ffeaf--f9336e9b75064ee58e036b5c0fdd1c5d e5d41ceaf38847ba9d494b1c7e782199 f9336e9b75064ee58e036b5c0fdd1c5d--e5d41ceaf38847ba9d494b1c7e782199 93bb9c448a11445484768cea727a5900 e5d41ceaf38847ba9d494b1c7e782199--93bb9c448a11445484768cea727a5900 0db9b75db8814c918e2d4ca2c22365f7 93bb9c448a11445484768cea727a5900--0db9b75db8814c918e2d4ca2c22365f7 57519a39337546dda5482d269b151fa3 0db9b75db8814c918e2d4ca2c22365f7--57519a39337546dda5482d269b151fa3 46ddad18189c4f6d9fca0ef5859ade0a 57519a39337546dda5482d269b151fa3--46ddad18189c4f6d9fca0ef5859ade0a 4604897747c44edfb022b67cabaa1508 46ddad18189c4f6d9fca0ef5859ade0a--4604897747c44edfb022b67cabaa1508 13b964e9015f4932931dc97927812805 4604897747c44edfb022b67cabaa1508--13b964e9015f4932931dc97927812805 e36fc699189a40ffb2d0ccc01fcedca6 13b964e9015f4932931dc97927812805--e36fc699189a40ffb2d0ccc01fcedca6 d9ac40a5c9f34842a27a07f79489c6e6 e36fc699189a40ffb2d0ccc01fcedca6--d9ac40a5c9f34842a27a07f79489c6e6 e64d98077c654829b2c7aea0f0967a95 d9ac40a5c9f34842a27a07f79489c6e6--e64d98077c654829b2c7aea0f0967a95 c0ce9cfaab884fa08d507ac99dfbf5b5 e64d98077c654829b2c7aea0f0967a95--c0ce9cfaab884fa08d507ac99dfbf5b5 76b9124511134890bc085a587be12a80 c0ce9cfaab884fa08d507ac99dfbf5b5--76b9124511134890bc085a587be12a80 09ec4715641946f4a3b71f19f9bc85e3 76b9124511134890bc085a587be12a80--09ec4715641946f4a3b71f19f9bc85e3 495a178f3faf450ca7a6cac397d2ce1c 09ec4715641946f4a3b71f19f9bc85e3--495a178f3faf450ca7a6cac397d2ce1c fc2e00dc48f2477c8059994052edbe21 495a178f3faf450ca7a6cac397d2ce1c--fc2e00dc48f2477c8059994052edbe21 4c6230d4a99848af9bef611c724f9a4b fc2e00dc48f2477c8059994052edbe21--4c6230d4a99848af9bef611c724f9a4b 43741fab5e5f450d8219ee9d06160988 4c6230d4a99848af9bef611c724f9a4b--43741fab5e5f450d8219ee9d06160988 b7a8372a98ec48bcbcb8acbff818ce53 43741fab5e5f450d8219ee9d06160988--b7a8372a98ec48bcbcb8acbff818ce53 fe73bc4a12044fbfb99e8dda7a46b232 b7a8372a98ec48bcbcb8acbff818ce53--fe73bc4a12044fbfb99e8dda7a46b232 f7c94205135a4c9285e0e1d1eeddf94a fe73bc4a12044fbfb99e8dda7a46b232--f7c94205135a4c9285e0e1d1eeddf94a e5e35019ee6346fda418e57a5b787047 f7c94205135a4c9285e0e1d1eeddf94a--e5e35019ee6346fda418e57a5b787047 c987ee5db766476198985ff8df81e7a0 e5e35019ee6346fda418e57a5b787047--c987ee5db766476198985ff8df81e7a0 7bc3db30bf2d4b5eab02c782552da44f c987ee5db766476198985ff8df81e7a0--7bc3db30bf2d4b5eab02c782552da44f dddaeb9582f9433e83c085f4127df655 7bc3db30bf2d4b5eab02c782552da44f--dddaeb9582f9433e83c085f4127df655 1dbfffaae3bd4dc78498516730f659b5 dddaeb9582f9433e83c085f4127df655--1dbfffaae3bd4dc78498516730f659b5 9a7a0093677c4139b90fd1894e1d423b 1dbfffaae3bd4dc78498516730f659b5--9a7a0093677c4139b90fd1894e1d423b 779f54ec790a4a7f8a131f2a401f1f65 9a7a0093677c4139b90fd1894e1d423b--779f54ec790a4a7f8a131f2a401f1f65 a92aaa88b2b049b1a9fee70fc6de6806 779f54ec790a4a7f8a131f2a401f1f65--a92aaa88b2b049b1a9fee70fc6de6806 60ca6da4f1824ae9a43c77eba0b73c4a a92aaa88b2b049b1a9fee70fc6de6806--60ca6da4f1824ae9a43c77eba0b73c4a bd75d462455949b085a36b9041e9f2df 60ca6da4f1824ae9a43c77eba0b73c4a--bd75d462455949b085a36b9041e9f2df 940f579aa8be40d097a75f1a24c7f1fc bd75d462455949b085a36b9041e9f2df--940f579aa8be40d097a75f1a24c7f1fc 25724e824c3a40509e8f521e7495871b 940f579aa8be40d097a75f1a24c7f1fc--25724e824c3a40509e8f521e7495871b 0af8ef61ed8c4c9fbb7fec9cbe7b0f38 25724e824c3a40509e8f521e7495871b--0af8ef61ed8c4c9fbb7fec9cbe7b0f38 d02e506ba26a40d1ad2f1a85b6149d6b 0af8ef61ed8c4c9fbb7fec9cbe7b0f38--d02e506ba26a40d1ad2f1a85b6149d6b 61fb15b1f3a04819a0ddc442817b6573 d02e506ba26a40d1ad2f1a85b6149d6b--61fb15b1f3a04819a0ddc442817b6573 758dcd4b18aa46cc9216668e1bde1983 61fb15b1f3a04819a0ddc442817b6573--758dcd4b18aa46cc9216668e1bde1983 38dff2026c3d4adc917a756bcc8a43d0 758dcd4b18aa46cc9216668e1bde1983--38dff2026c3d4adc917a756bcc8a43d0 24cdaf58c58d441b988d793e3120f1b4 38dff2026c3d4adc917a756bcc8a43d0--24cdaf58c58d441b988d793e3120f1b4 a6570c7166bf4b10821ef2861d1cb9db 24cdaf58c58d441b988d793e3120f1b4--a6570c7166bf4b10821ef2861d1cb9db a36d34a32fac46d684f90662dc5b496d a6570c7166bf4b10821ef2861d1cb9db--a36d34a32fac46d684f90662dc5b496d e49ffae70a9a4cf4a6a5b04fef9067fa a36d34a32fac46d684f90662dc5b496d--e49ffae70a9a4cf4a6a5b04fef9067fa 140e1feb53514308a737b18cd3f4bb66 e49ffae70a9a4cf4a6a5b04fef9067fa--140e1feb53514308a737b18cd3f4bb66 0afa42ec7b08469c81c6f62b59af5789 140e1feb53514308a737b18cd3f4bb66--0afa42ec7b08469c81c6f62b59af5789 f11f646ccaee49ff848ced8a6cec164e 0afa42ec7b08469c81c6f62b59af5789--f11f646ccaee49ff848ced8a6cec164e cb20a7843da4488a9c5fc148de13e76f f11f646ccaee49ff848ced8a6cec164e--cb20a7843da4488a9c5fc148de13e76f 32ccd0165005496fb7a31b6559122fda cb20a7843da4488a9c5fc148de13e76f--32ccd0165005496fb7a31b6559122fda a2a730a063744284bfb2c98fa6769e53 32ccd0165005496fb7a31b6559122fda--a2a730a063744284bfb2c98fa6769e53 8428254946ff42f29bce0a542ec282ce a2a730a063744284bfb2c98fa6769e53--8428254946ff42f29bce0a542ec282ce 82943ed7ffdd40d9aa329016fc8f82aa 8428254946ff42f29bce0a542ec282ce--82943ed7ffdd40d9aa329016fc8f82aa 6c11ce5d3e1b4020a02dd7f989e5887b 82943ed7ffdd40d9aa329016fc8f82aa--6c11ce5d3e1b4020a02dd7f989e5887b c0641234722c4feab2ac3f938d9e2e66 6c11ce5d3e1b4020a02dd7f989e5887b--c0641234722c4feab2ac3f938d9e2e66 7c277a1ec9fe4421971b5b5e31e98cc7 c0641234722c4feab2ac3f938d9e2e66--7c277a1ec9fe4421971b5b5e31e98cc7 cbe7eb14bb3842988c044884e0395ea1 7c277a1ec9fe4421971b5b5e31e98cc7--cbe7eb14bb3842988c044884e0395ea1 e7919491c3234181a34e805641e3b7e7 cbe7eb14bb3842988c044884e0395ea1--e7919491c3234181a34e805641e3b7e7 2c00d0ed6b474d7fbc7b3a2e386652a6 e7919491c3234181a34e805641e3b7e7--2c00d0ed6b474d7fbc7b3a2e386652a6 6ecf5b3d994c4e5dbbde0d069aba0582 2c00d0ed6b474d7fbc7b3a2e386652a6--6ecf5b3d994c4e5dbbde0d069aba0582 4bfb639b45db498787f1a2f036c33806 6ecf5b3d994c4e5dbbde0d069aba0582--4bfb639b45db498787f1a2f036c33806 b8f03ba523c54c5c953ad0f1b2653e1b 4bfb639b45db498787f1a2f036c33806--b8f03ba523c54c5c953ad0f1b2653e1b 91f499dd9823452ba472e14a131149e4 b8f03ba523c54c5c953ad0f1b2653e1b--91f499dd9823452ba472e14a131149e4 f80039e2ec18482db4acf49224813707 91f499dd9823452ba472e14a131149e4--f80039e2ec18482db4acf49224813707 c0dd728a4e6641f1888a64ca31ce050c f80039e2ec18482db4acf49224813707--c0dd728a4e6641f1888a64ca31ce050c ff9dc022fec74c009f1b741c3ee12683 c0dd728a4e6641f1888a64ca31ce050c--ff9dc022fec74c009f1b741c3ee12683 0a8fe67bcc2147aebe197a7418350ddd ff9dc022fec74c009f1b741c3ee12683--0a8fe67bcc2147aebe197a7418350ddd 6e23019394684260874a4e23490f6df1 0a8fe67bcc2147aebe197a7418350ddd--6e23019394684260874a4e23490f6df1 0280c07d09e64529937e9940ca12d2bd 6e23019394684260874a4e23490f6df1--0280c07d09e64529937e9940ca12d2bd 1f4ed7fc7b334904962cfaf58162978b 0280c07d09e64529937e9940ca12d2bd--1f4ed7fc7b334904962cfaf58162978b 5eee22baceba404989845a454e03a631 1f4ed7fc7b334904962cfaf58162978b--5eee22baceba404989845a454e03a631 65565f15266a473b94606f524d4e6022 5eee22baceba404989845a454e03a631--65565f15266a473b94606f524d4e6022 4490bd6cd5a64e669995dd0c7474af6b 65565f15266a473b94606f524d4e6022--4490bd6cd5a64e669995dd0c7474af6b ab4c4557ceb944949503d99492ddd75b 4490bd6cd5a64e669995dd0c7474af6b--ab4c4557ceb944949503d99492ddd75b da8ebfe043784c14b24ea1bdf770ec3b ab4c4557ceb944949503d99492ddd75b--da8ebfe043784c14b24ea1bdf770ec3b 6d3d3929f22f412ea27083b07b981d2e da8ebfe043784c14b24ea1bdf770ec3b--6d3d3929f22f412ea27083b07b981d2e 31764f6194e64b94a7bf8f4ca51b9212 6d3d3929f22f412ea27083b07b981d2e--31764f6194e64b94a7bf8f4ca51b9212 f15f22623c424684b26a3f7c3a64dd3a 31764f6194e64b94a7bf8f4ca51b9212--f15f22623c424684b26a3f7c3a64dd3a d68b0b5697924251ae793da782e585d4 f15f22623c424684b26a3f7c3a64dd3a--d68b0b5697924251ae793da782e585d4 a43562ce5ddc4ca8bf6071b1ffd75613 d68b0b5697924251ae793da782e585d4--a43562ce5ddc4ca8bf6071b1ffd75613 5cd7c59b2979458d93483860c1d1ef8f a43562ce5ddc4ca8bf6071b1ffd75613--5cd7c59b2979458d93483860c1d1ef8f 5cd04b2f1b004785949ec37a8d13116c 5cd7c59b2979458d93483860c1d1ef8f--5cd04b2f1b004785949ec37a8d13116c 6554cdfd4df643ed8a10488764605a59 5cd04b2f1b004785949ec37a8d13116c--6554cdfd4df643ed8a10488764605a59 400ab2ff37094b10969b102a8cb765c4 6554cdfd4df643ed8a10488764605a59--400ab2ff37094b10969b102a8cb765c4 cc72e16b5d6c45f883cd475112bd0c00 400ab2ff37094b10969b102a8cb765c4--cc72e16b5d6c45f883cd475112bd0c00 4078855df37344e5a07c85d61a58bf09 cc72e16b5d6c45f883cd475112bd0c00--4078855df37344e5a07c85d61a58bf09 660970f3658b4750ae89e2e6d49d35ce 4078855df37344e5a07c85d61a58bf09--660970f3658b4750ae89e2e6d49d35ce 512c744a2cb94c18b6e9d94022711aaa 660970f3658b4750ae89e2e6d49d35ce--512c744a2cb94c18b6e9d94022711aaa 813aaf409b9e4102b3144bceba1f93da 512c744a2cb94c18b6e9d94022711aaa--813aaf409b9e4102b3144bceba1f93da 1e7347eb4789495e8f42a4dcef31a2d9 813aaf409b9e4102b3144bceba1f93da--1e7347eb4789495e8f42a4dcef31a2d9 c739de54af3b43a7b683f29916dce9a6 1e7347eb4789495e8f42a4dcef31a2d9--c739de54af3b43a7b683f29916dce9a6 aa6f807a69974641bb27d237394035c2 RX(b10) c739de54af3b43a7b683f29916dce9a6--aa6f807a69974641bb27d237394035c2 30af3c9523c4468f81b797e8ac3c468f aa6f807a69974641bb27d237394035c2--30af3c9523c4468f81b797e8ac3c468f 1c7dbe7ee157406ab98607162af29370 835528177eda48d6a467949757785e61 X 2bf6aaddb8bb4850956ff790cdfc66c9--835528177eda48d6a467949757785e61 f6556b8310cc445789d375080e4fb33a 2 835528177eda48d6a467949757785e61--36e55aedf4e6439d96e2949646cd8776 628bbf53c31847e4bd08b47e8130ddcd 835528177eda48d6a467949757785e61--628bbf53c31847e4bd08b47e8130ddcd 28e7abe5d47f439c87cffcc0035a5d70 628bbf53c31847e4bd08b47e8130ddcd--28e7abe5d47f439c87cffcc0035a5d70 4c682374a4c34dd880187601a09d2843 28e7abe5d47f439c87cffcc0035a5d70--4c682374a4c34dd880187601a09d2843 1ee16acac6054f1f976d4a8440fce864 4c682374a4c34dd880187601a09d2843--1ee16acac6054f1f976d4a8440fce864 267227f6e0974dc8aac600aa344459fa 1ee16acac6054f1f976d4a8440fce864--267227f6e0974dc8aac600aa344459fa ee9eeaeb28824088987aee0e58621c43 267227f6e0974dc8aac600aa344459fa--ee9eeaeb28824088987aee0e58621c43 d1d9216445984e53baffae393ec2170a ee9eeaeb28824088987aee0e58621c43--d1d9216445984e53baffae393ec2170a 2142ba3fb20f42e5862e36ffe3b787e9 d1d9216445984e53baffae393ec2170a--2142ba3fb20f42e5862e36ffe3b787e9 f7f9076f6916479d93078f8b76a08993 2142ba3fb20f42e5862e36ffe3b787e9--f7f9076f6916479d93078f8b76a08993 0b46e9542bab4c8cbdaf0f2b76821a6f f7f9076f6916479d93078f8b76a08993--0b46e9542bab4c8cbdaf0f2b76821a6f 576ef7fe5b8c4784a703004356f5344b 0b46e9542bab4c8cbdaf0f2b76821a6f--576ef7fe5b8c4784a703004356f5344b 966b5e78d4d440ada7c81babee6d907c 576ef7fe5b8c4784a703004356f5344b--966b5e78d4d440ada7c81babee6d907c c6ceeeae121847bc816068cdb4be05a2 966b5e78d4d440ada7c81babee6d907c--c6ceeeae121847bc816068cdb4be05a2 095d020c12944e9da3d8702cea71747c X c6ceeeae121847bc816068cdb4be05a2--095d020c12944e9da3d8702cea71747c 095d020c12944e9da3d8702cea71747c--15d8b5cc03564f27951ddfa5595ec358 05e0f0cda6db4a1a859636b15970cd03 X 095d020c12944e9da3d8702cea71747c--05e0f0cda6db4a1a859636b15970cd03 05e0f0cda6db4a1a859636b15970cd03--c4e7af3066d34999950e7ee405ed4b36 2bb23fb2578f4ce7bf69c1f0c4782cf8 RZ(-1.0*g0) 05e0f0cda6db4a1a859636b15970cd03--2bb23fb2578f4ce7bf69c1f0c4782cf8 4ab2f9726b924d8db554c0e6d73407f7 X 2bb23fb2578f4ce7bf69c1f0c4782cf8--4ab2f9726b924d8db554c0e6d73407f7 4ab2f9726b924d8db554c0e6d73407f7--01a280e04fc84ea1992a3e8ec954ee1e f998b7fa98324d28908483f523de44b7 X 4ab2f9726b924d8db554c0e6d73407f7--f998b7fa98324d28908483f523de44b7 f998b7fa98324d28908483f523de44b7--2ef24df57f464b5f975a4d48874c204d 0585541fb15e4470b1ef0fa6e89f2c81 f998b7fa98324d28908483f523de44b7--0585541fb15e4470b1ef0fa6e89f2c81 09f85d0c17314371902686c69ed215b6 0585541fb15e4470b1ef0fa6e89f2c81--09f85d0c17314371902686c69ed215b6 2ca854aa011e4c99b9b4aea6f1b28da3 09f85d0c17314371902686c69ed215b6--2ca854aa011e4c99b9b4aea6f1b28da3 332944f8f1a7422397c7a04a43d6fa35 2ca854aa011e4c99b9b4aea6f1b28da3--332944f8f1a7422397c7a04a43d6fa35 b7d68ebc81b242d7914d512f89f9f9d7 332944f8f1a7422397c7a04a43d6fa35--b7d68ebc81b242d7914d512f89f9f9d7 7c5c3017a6cf44c8afc3f9875d5aa374 b7d68ebc81b242d7914d512f89f9f9d7--7c5c3017a6cf44c8afc3f9875d5aa374 c8f8b7ab9be74c5db446791e711b363f 7c5c3017a6cf44c8afc3f9875d5aa374--c8f8b7ab9be74c5db446791e711b363f 9f5575a8efa0414eb5f798c8155ca485 X c8f8b7ab9be74c5db446791e711b363f--9f5575a8efa0414eb5f798c8155ca485 9f5575a8efa0414eb5f798c8155ca485--74e9a8efb8934f4ca6dbf3be2ff23ed2 8fa557fa705e4d69ae9e46174dda1b1a X 9f5575a8efa0414eb5f798c8155ca485--8fa557fa705e4d69ae9e46174dda1b1a 8fa557fa705e4d69ae9e46174dda1b1a--2f26245cffa74b4fb3e78d5739b22be2 fef9df1eee3d47e9993d655fed907e35 8fa557fa705e4d69ae9e46174dda1b1a--fef9df1eee3d47e9993d655fed907e35 57c08ac47d8e4c328d305f2a0ba180c4 fef9df1eee3d47e9993d655fed907e35--57c08ac47d8e4c328d305f2a0ba180c4 99b7a847daa24b79abc7dd795f2cd2b3 57c08ac47d8e4c328d305f2a0ba180c4--99b7a847daa24b79abc7dd795f2cd2b3 f2240dc1c13d4d8b8329485af70bdd92 99b7a847daa24b79abc7dd795f2cd2b3--f2240dc1c13d4d8b8329485af70bdd92 22d880486d674253956515aafbe34a7f f2240dc1c13d4d8b8329485af70bdd92--22d880486d674253956515aafbe34a7f f32ccda7d69247a293bcad7741d8664f 22d880486d674253956515aafbe34a7f--f32ccda7d69247a293bcad7741d8664f 230980dd262b4be985ae5735d5868cd3 f32ccda7d69247a293bcad7741d8664f--230980dd262b4be985ae5735d5868cd3 e74c5cba18514a339b6382a0d15f9cd0 230980dd262b4be985ae5735d5868cd3--e74c5cba18514a339b6382a0d15f9cd0 37c91f730d3143889bd976e95732250a e74c5cba18514a339b6382a0d15f9cd0--37c91f730d3143889bd976e95732250a 74fc5a62b52e4aa8bf75254e728d5b73 37c91f730d3143889bd976e95732250a--74fc5a62b52e4aa8bf75254e728d5b73 3ad382b8ed4a48348e6e536daca83b4a 74fc5a62b52e4aa8bf75254e728d5b73--3ad382b8ed4a48348e6e536daca83b4a a2f45e9ab2ec4fd4a7edb0733e5c8f5c X 3ad382b8ed4a48348e6e536daca83b4a--a2f45e9ab2ec4fd4a7edb0733e5c8f5c a2f45e9ab2ec4fd4a7edb0733e5c8f5c--e4e6900d4ff84cd79e4f896d83abb5ba e03d005978cb46d98fb89b2a8990f5ab a2f45e9ab2ec4fd4a7edb0733e5c8f5c--e03d005978cb46d98fb89b2a8990f5ab 17805b87a2294ffcaae96decd73ae349 e03d005978cb46d98fb89b2a8990f5ab--17805b87a2294ffcaae96decd73ae349 4dcd486e25184cddba53243c4662bcdd 17805b87a2294ffcaae96decd73ae349--4dcd486e25184cddba53243c4662bcdd 63175c939d854cc095ee5f40c06e82d9 4dcd486e25184cddba53243c4662bcdd--63175c939d854cc095ee5f40c06e82d9 242a0d1b9d3a4c60bc7d996e695438e3 63175c939d854cc095ee5f40c06e82d9--242a0d1b9d3a4c60bc7d996e695438e3 d7263b44f48243ae8e59524303765455 242a0d1b9d3a4c60bc7d996e695438e3--d7263b44f48243ae8e59524303765455 be1be9afb5dc43f4af73ac0039cade6e d7263b44f48243ae8e59524303765455--be1be9afb5dc43f4af73ac0039cade6e 692ad0498e344cc38239eb7901e91ca8 be1be9afb5dc43f4af73ac0039cade6e--692ad0498e344cc38239eb7901e91ca8 d2d567d845d041528e6e61025c8adb31 692ad0498e344cc38239eb7901e91ca8--d2d567d845d041528e6e61025c8adb31 d7d34cd8b8374b179d2dff8597b65ce2 d2d567d845d041528e6e61025c8adb31--d7d34cd8b8374b179d2dff8597b65ce2 7b5cc1d44513413680d6b1143ac52323 d7d34cd8b8374b179d2dff8597b65ce2--7b5cc1d44513413680d6b1143ac52323 13bcc124250e4b35afddbb8ec9003d11 7b5cc1d44513413680d6b1143ac52323--13bcc124250e4b35afddbb8ec9003d11 71806df027f84482994ac783ce660dd4 13bcc124250e4b35afddbb8ec9003d11--71806df027f84482994ac783ce660dd4 47e1ce1b4b244537881b5a4b8ec93975 71806df027f84482994ac783ce660dd4--47e1ce1b4b244537881b5a4b8ec93975 85808d30446046069b5bea607a2a3d8d 47e1ce1b4b244537881b5a4b8ec93975--85808d30446046069b5bea607a2a3d8d 83985334bf8845ed9cd1d1d916fd1ba7 85808d30446046069b5bea607a2a3d8d--83985334bf8845ed9cd1d1d916fd1ba7 7629aa83bd814e0188f0b0b03d7e7265 83985334bf8845ed9cd1d1d916fd1ba7--7629aa83bd814e0188f0b0b03d7e7265 c6e2362de54c4ac2b62f5517e207e3ba 7629aa83bd814e0188f0b0b03d7e7265--c6e2362de54c4ac2b62f5517e207e3ba 0fe0628aeb084fca8b9ae5c8c03de8bf c6e2362de54c4ac2b62f5517e207e3ba--0fe0628aeb084fca8b9ae5c8c03de8bf bc342581c6eb46c1834771ec0a4502f0 0fe0628aeb084fca8b9ae5c8c03de8bf--bc342581c6eb46c1834771ec0a4502f0 de0e2a4446264db68b6c5d262f29e12e bc342581c6eb46c1834771ec0a4502f0--de0e2a4446264db68b6c5d262f29e12e 1c89dea16f1343399b125553d875de0f de0e2a4446264db68b6c5d262f29e12e--1c89dea16f1343399b125553d875de0f 8335a2a5a85548c3b251542e87a41cea 1c89dea16f1343399b125553d875de0f--8335a2a5a85548c3b251542e87a41cea ed87a440d75540efb2edf673eae191cf 8335a2a5a85548c3b251542e87a41cea--ed87a440d75540efb2edf673eae191cf e49c120af6584fc48762bad03ba44892 ed87a440d75540efb2edf673eae191cf--e49c120af6584fc48762bad03ba44892 906c010b098c410c80fe66e8f21a92ea e49c120af6584fc48762bad03ba44892--906c010b098c410c80fe66e8f21a92ea 37a613ba372d4547bf386b691b0cc57e 906c010b098c410c80fe66e8f21a92ea--37a613ba372d4547bf386b691b0cc57e 1d4252d990544e6ba717c241555f194a 37a613ba372d4547bf386b691b0cc57e--1d4252d990544e6ba717c241555f194a 2f897050ffcf4dd7b0f3bd37aeb89017 1d4252d990544e6ba717c241555f194a--2f897050ffcf4dd7b0f3bd37aeb89017 7f96f07db0354e4d864d4c56f0105ff5 2f897050ffcf4dd7b0f3bd37aeb89017--7f96f07db0354e4d864d4c56f0105ff5 3795730031fe4ab69232b30a29602e96 7f96f07db0354e4d864d4c56f0105ff5--3795730031fe4ab69232b30a29602e96 637cc62b16224429a7e1743a09ec3ed9 3795730031fe4ab69232b30a29602e96--637cc62b16224429a7e1743a09ec3ed9 e71a8fbc7c944058a7b2ff54d7a51733 637cc62b16224429a7e1743a09ec3ed9--e71a8fbc7c944058a7b2ff54d7a51733 4a1682ba32854f9bbe5710d040ccacb4 e71a8fbc7c944058a7b2ff54d7a51733--4a1682ba32854f9bbe5710d040ccacb4 6bca91d328d44d0496fff893befa0041 4a1682ba32854f9bbe5710d040ccacb4--6bca91d328d44d0496fff893befa0041 d70b74b73a0c4588aa9ce4314b3c0083 6bca91d328d44d0496fff893befa0041--d70b74b73a0c4588aa9ce4314b3c0083 cd64dc1ed8ec4fd088959a9fd6a6134f d70b74b73a0c4588aa9ce4314b3c0083--cd64dc1ed8ec4fd088959a9fd6a6134f 6b412817737e4615b9d3ad92ce78aed9 cd64dc1ed8ec4fd088959a9fd6a6134f--6b412817737e4615b9d3ad92ce78aed9 430ad1cdddf5492b827a55ae26ce02df 6b412817737e4615b9d3ad92ce78aed9--430ad1cdddf5492b827a55ae26ce02df 6976bd6904d4441684f8d042f7cf2d64 430ad1cdddf5492b827a55ae26ce02df--6976bd6904d4441684f8d042f7cf2d64 c5600f76c58d41a4ab95b3235ceb97ce 6976bd6904d4441684f8d042f7cf2d64--c5600f76c58d41a4ab95b3235ceb97ce f07d2213987946a1971ecf8164456db1 c5600f76c58d41a4ab95b3235ceb97ce--f07d2213987946a1971ecf8164456db1 6bfb8ba236234976a26fae4654700a9f f07d2213987946a1971ecf8164456db1--6bfb8ba236234976a26fae4654700a9f 2c72123650064ddabebda9da0a9bf137 6bfb8ba236234976a26fae4654700a9f--2c72123650064ddabebda9da0a9bf137 b5f1cedd59be458bae92b2fa6181396c 2c72123650064ddabebda9da0a9bf137--b5f1cedd59be458bae92b2fa6181396c 7ed62c6bdf5e4f1381509ecb657abfd9 b5f1cedd59be458bae92b2fa6181396c--7ed62c6bdf5e4f1381509ecb657abfd9 83a50bf3036e4536aeea2d31fb696ce1 7ed62c6bdf5e4f1381509ecb657abfd9--83a50bf3036e4536aeea2d31fb696ce1 879e73d7c0374262a5518d23cf809562 83a50bf3036e4536aeea2d31fb696ce1--879e73d7c0374262a5518d23cf809562 e357b1b727f24c4382e0db07ee5c6c24 879e73d7c0374262a5518d23cf809562--e357b1b727f24c4382e0db07ee5c6c24 dc58848092ff4f90bd195064267a2ad1 e357b1b727f24c4382e0db07ee5c6c24--dc58848092ff4f90bd195064267a2ad1 59189a4b83884a66ae364d64c32caa5d dc58848092ff4f90bd195064267a2ad1--59189a4b83884a66ae364d64c32caa5d 1fa9650e4cee46d7a7911e8373a636b8 59189a4b83884a66ae364d64c32caa5d--1fa9650e4cee46d7a7911e8373a636b8 f70026e349344be5917eaaba9a36cd4a 1fa9650e4cee46d7a7911e8373a636b8--f70026e349344be5917eaaba9a36cd4a f8daf2f0516a4f1a9f6f068ab57bc305 f70026e349344be5917eaaba9a36cd4a--f8daf2f0516a4f1a9f6f068ab57bc305 ef4c4ab5bbf34f73ac8bf3863f45cd78 f8daf2f0516a4f1a9f6f068ab57bc305--ef4c4ab5bbf34f73ac8bf3863f45cd78 713ad3f745b3409ebe9cc10d4a1fe828 ef4c4ab5bbf34f73ac8bf3863f45cd78--713ad3f745b3409ebe9cc10d4a1fe828 213b2d5288b7482f844e6153861eb542 713ad3f745b3409ebe9cc10d4a1fe828--213b2d5288b7482f844e6153861eb542 796969f45d27467d9c1507285d9afc07 213b2d5288b7482f844e6153861eb542--796969f45d27467d9c1507285d9afc07 c9f3dd0356b94f3c97f45aa2c5e904cf 796969f45d27467d9c1507285d9afc07--c9f3dd0356b94f3c97f45aa2c5e904cf 9fbe9e40e97c4429ab9b6df844d1324e c9f3dd0356b94f3c97f45aa2c5e904cf--9fbe9e40e97c4429ab9b6df844d1324e a2c0967a963f4cf0a5f1f62f3c8268ca 9fbe9e40e97c4429ab9b6df844d1324e--a2c0967a963f4cf0a5f1f62f3c8268ca 25b8058ccf0e434aada85297e1a0ac3a a2c0967a963f4cf0a5f1f62f3c8268ca--25b8058ccf0e434aada85297e1a0ac3a 693d3d180a38487195c5429be0ee61ac 25b8058ccf0e434aada85297e1a0ac3a--693d3d180a38487195c5429be0ee61ac 5a17fd4784bc4cf38602844f3a5f4243 693d3d180a38487195c5429be0ee61ac--5a17fd4784bc4cf38602844f3a5f4243 154f516f27384fd7a4530f500306a064 5a17fd4784bc4cf38602844f3a5f4243--154f516f27384fd7a4530f500306a064 4acaa34f90374be0ba0fcea8b803cb03 154f516f27384fd7a4530f500306a064--4acaa34f90374be0ba0fcea8b803cb03 729beea5fcc04770a6a409c38efa29dd 4acaa34f90374be0ba0fcea8b803cb03--729beea5fcc04770a6a409c38efa29dd e2e8b945bd4f47f8a1904ee009a5da50 729beea5fcc04770a6a409c38efa29dd--e2e8b945bd4f47f8a1904ee009a5da50 f0f4f8290f244ab39649f9b088434101 e2e8b945bd4f47f8a1904ee009a5da50--f0f4f8290f244ab39649f9b088434101 d3c2a7c4b47f4c5ea0f502396a7b78f1 RX(b01) f0f4f8290f244ab39649f9b088434101--d3c2a7c4b47f4c5ea0f502396a7b78f1 1320fd626a144673831937bbc6682283 X d3c2a7c4b47f4c5ea0f502396a7b78f1--1320fd626a144673831937bbc6682283 1320fd626a144673831937bbc6682283--d442bc9d4ed7481fa10d38fcd9654c4d e116a8d4f85a443da77cd16163f4098e 1320fd626a144673831937bbc6682283--e116a8d4f85a443da77cd16163f4098e 026ea3a5533246d789a482dcdb1bf1df e116a8d4f85a443da77cd16163f4098e--026ea3a5533246d789a482dcdb1bf1df a4d3ab46dc064390ad9522015534a5ae 026ea3a5533246d789a482dcdb1bf1df--a4d3ab46dc064390ad9522015534a5ae 162c76c838b547a2b768232df26d7a37 a4d3ab46dc064390ad9522015534a5ae--162c76c838b547a2b768232df26d7a37 348cb2316017405181576ddac55329c4 162c76c838b547a2b768232df26d7a37--348cb2316017405181576ddac55329c4 c05276fdca214ea493945be681e64b7f 348cb2316017405181576ddac55329c4--c05276fdca214ea493945be681e64b7f 851ed655d0e24a6381666acd67d4ec8f c05276fdca214ea493945be681e64b7f--851ed655d0e24a6381666acd67d4ec8f fcf8db97f7a540e5a5c38bad9199ce82 851ed655d0e24a6381666acd67d4ec8f--fcf8db97f7a540e5a5c38bad9199ce82 6265fb18df8b43d08c537f0a6e64d8dd fcf8db97f7a540e5a5c38bad9199ce82--6265fb18df8b43d08c537f0a6e64d8dd ef9fa6538ddf46599897adf152290d9e 6265fb18df8b43d08c537f0a6e64d8dd--ef9fa6538ddf46599897adf152290d9e 7a5de404ac6649ffbc649b7d7ca6d9a6 ef9fa6538ddf46599897adf152290d9e--7a5de404ac6649ffbc649b7d7ca6d9a6 ed16d622cee6438c89a6fc926a60eddf 7a5de404ac6649ffbc649b7d7ca6d9a6--ed16d622cee6438c89a6fc926a60eddf 89f986dcb9104ab88a4b0f3b1533bbb4 ed16d622cee6438c89a6fc926a60eddf--89f986dcb9104ab88a4b0f3b1533bbb4 7a83f9f37a59411b9267d6ff2985ac9c X 89f986dcb9104ab88a4b0f3b1533bbb4--7a83f9f37a59411b9267d6ff2985ac9c 7a83f9f37a59411b9267d6ff2985ac9c--aff06bede46c4aa996a3fd9a6c7c38d1 de28174f399441129d1a00be4b6af902 X 7a83f9f37a59411b9267d6ff2985ac9c--de28174f399441129d1a00be4b6af902 de28174f399441129d1a00be4b6af902--edbd82c8638b481ca4b2677e3687eff0 4dd57ac62be54528b0dd4ae9c1f5de6c RZ(-1.0*g1) de28174f399441129d1a00be4b6af902--4dd57ac62be54528b0dd4ae9c1f5de6c f3334f41412e437ea3d1b05043d6b00b X 4dd57ac62be54528b0dd4ae9c1f5de6c--f3334f41412e437ea3d1b05043d6b00b f3334f41412e437ea3d1b05043d6b00b--5b97ea6a07b740ceb903c9eae92295e9 2f0b3eb25e2e4d479d30186dec7af82e X f3334f41412e437ea3d1b05043d6b00b--2f0b3eb25e2e4d479d30186dec7af82e 2f0b3eb25e2e4d479d30186dec7af82e--58fd595d31fd4dbfbd0afb5755a500ae fa1d3be2bd4b48be9125ca7d282a380c 2f0b3eb25e2e4d479d30186dec7af82e--fa1d3be2bd4b48be9125ca7d282a380c 1d01d7125ec240009280d7fa6c7330f0 fa1d3be2bd4b48be9125ca7d282a380c--1d01d7125ec240009280d7fa6c7330f0 146580212bac4c0cbb67b5f801e9f784 1d01d7125ec240009280d7fa6c7330f0--146580212bac4c0cbb67b5f801e9f784 593f23c3d0084eec9817f67f8cbe55c6 146580212bac4c0cbb67b5f801e9f784--593f23c3d0084eec9817f67f8cbe55c6 b078bc8948fd4c05b9feea404a3f6b09 593f23c3d0084eec9817f67f8cbe55c6--b078bc8948fd4c05b9feea404a3f6b09 1439a8f2222e40eaa9c8202ec0667076 b078bc8948fd4c05b9feea404a3f6b09--1439a8f2222e40eaa9c8202ec0667076 98f8fc9c0daf48ca92ff8f0eb6ad7cf2 1439a8f2222e40eaa9c8202ec0667076--98f8fc9c0daf48ca92ff8f0eb6ad7cf2 54b48deec7d2442eaf292f0f19f92f6b X 98f8fc9c0daf48ca92ff8f0eb6ad7cf2--54b48deec7d2442eaf292f0f19f92f6b 54b48deec7d2442eaf292f0f19f92f6b--46ddad18189c4f6d9fca0ef5859ade0a 1437f5730d704e3d875e368c930fa136 X 54b48deec7d2442eaf292f0f19f92f6b--1437f5730d704e3d875e368c930fa136 1437f5730d704e3d875e368c930fa136--4604897747c44edfb022b67cabaa1508 58d8770149f24be69d7694feab3978ed 1437f5730d704e3d875e368c930fa136--58d8770149f24be69d7694feab3978ed 9e6b80e4d1ce456c81cc7428f322b1ba 58d8770149f24be69d7694feab3978ed--9e6b80e4d1ce456c81cc7428f322b1ba d59d6fc2226646cabbeb49a2f36265e3 9e6b80e4d1ce456c81cc7428f322b1ba--d59d6fc2226646cabbeb49a2f36265e3 901339db59af467dbfb3c619b2df7f53 d59d6fc2226646cabbeb49a2f36265e3--901339db59af467dbfb3c619b2df7f53 db8ed753d616424d827bdd3746cb9b06 901339db59af467dbfb3c619b2df7f53--db8ed753d616424d827bdd3746cb9b06 27d8e0907e9945008e3af304e1277c29 db8ed753d616424d827bdd3746cb9b06--27d8e0907e9945008e3af304e1277c29 c4af1be937fa471ab84ecf8fc1eb1cee 27d8e0907e9945008e3af304e1277c29--c4af1be937fa471ab84ecf8fc1eb1cee 7a6c0c2171f1477bbd0e98a5ebadf5df c4af1be937fa471ab84ecf8fc1eb1cee--7a6c0c2171f1477bbd0e98a5ebadf5df 01594c13c30f4c1ea6fe52412cc259d6 7a6c0c2171f1477bbd0e98a5ebadf5df--01594c13c30f4c1ea6fe52412cc259d6 595d11f1dac74f6bafd86748c3e6d061 01594c13c30f4c1ea6fe52412cc259d6--595d11f1dac74f6bafd86748c3e6d061 a351bc53a0964bb3b2f6b2ce1ea8ff1a 595d11f1dac74f6bafd86748c3e6d061--a351bc53a0964bb3b2f6b2ce1ea8ff1a cb6e77afa5644f73b8e6bf8b949eea29 X a351bc53a0964bb3b2f6b2ce1ea8ff1a--cb6e77afa5644f73b8e6bf8b949eea29 cb6e77afa5644f73b8e6bf8b949eea29--b7a8372a98ec48bcbcb8acbff818ce53 61eab1dbc49a4c50a73a0429a07fc49f cb6e77afa5644f73b8e6bf8b949eea29--61eab1dbc49a4c50a73a0429a07fc49f 8214f505afb54fd6a65eaeeacc992ebb 61eab1dbc49a4c50a73a0429a07fc49f--8214f505afb54fd6a65eaeeacc992ebb 69dec752d85749008a2f80af585c8858 8214f505afb54fd6a65eaeeacc992ebb--69dec752d85749008a2f80af585c8858 9d72aafde2134c5ba9a93993ed69b9d2 69dec752d85749008a2f80af585c8858--9d72aafde2134c5ba9a93993ed69b9d2 3e3ec2d28f754782b2965b7e6d490cff 9d72aafde2134c5ba9a93993ed69b9d2--3e3ec2d28f754782b2965b7e6d490cff 56b48bcd55ec485494e3106d1741c065 3e3ec2d28f754782b2965b7e6d490cff--56b48bcd55ec485494e3106d1741c065 ce74dc1a2e5f48f1a0fcae947dab8973 56b48bcd55ec485494e3106d1741c065--ce74dc1a2e5f48f1a0fcae947dab8973 03b1305de6174495a43fe6214e4c8f0d ce74dc1a2e5f48f1a0fcae947dab8973--03b1305de6174495a43fe6214e4c8f0d 078b95d70bba4eb491ad13c1b30d935b 03b1305de6174495a43fe6214e4c8f0d--078b95d70bba4eb491ad13c1b30d935b 24c80c36a6f043fbb364255c1114e6aa 078b95d70bba4eb491ad13c1b30d935b--24c80c36a6f043fbb364255c1114e6aa 9d6ac1ff104d47b28072aa37c3eaf82e 24c80c36a6f043fbb364255c1114e6aa--9d6ac1ff104d47b28072aa37c3eaf82e ed828eb85cfc48b0993408fcaf27b583 9d6ac1ff104d47b28072aa37c3eaf82e--ed828eb85cfc48b0993408fcaf27b583 1931e5378396424a947d5c0013749978 ed828eb85cfc48b0993408fcaf27b583--1931e5378396424a947d5c0013749978 e452e78536c749a8b594db6979d3ec86 1931e5378396424a947d5c0013749978--e452e78536c749a8b594db6979d3ec86 19db692019ae4c6f8d87c168fab35cad e452e78536c749a8b594db6979d3ec86--19db692019ae4c6f8d87c168fab35cad ee8e74a86fd64a45878b20320b6187e5 19db692019ae4c6f8d87c168fab35cad--ee8e74a86fd64a45878b20320b6187e5 2a6df625ef234226993df1071c6c5f4e ee8e74a86fd64a45878b20320b6187e5--2a6df625ef234226993df1071c6c5f4e 6df0ce4860d84d58a8440a467516d247 2a6df625ef234226993df1071c6c5f4e--6df0ce4860d84d58a8440a467516d247 be12d5635d1545cc8f36fb6aa5c643e8 6df0ce4860d84d58a8440a467516d247--be12d5635d1545cc8f36fb6aa5c643e8 96f3c3afd46d4c13a1d1af0120c78083 be12d5635d1545cc8f36fb6aa5c643e8--96f3c3afd46d4c13a1d1af0120c78083 a40835c8eece4caf8fa6d866651e28b0 96f3c3afd46d4c13a1d1af0120c78083--a40835c8eece4caf8fa6d866651e28b0 d72bb706a7124b5b819a9591a77c5b31 a40835c8eece4caf8fa6d866651e28b0--d72bb706a7124b5b819a9591a77c5b31 4c0fefa9ffd34042af27a6ad6aa7da20 d72bb706a7124b5b819a9591a77c5b31--4c0fefa9ffd34042af27a6ad6aa7da20 ae2f35ffc4de41bbb3cc341ea7e79baa 4c0fefa9ffd34042af27a6ad6aa7da20--ae2f35ffc4de41bbb3cc341ea7e79baa 0ba333ce74504bf6a5e7b80bd6848f54 ae2f35ffc4de41bbb3cc341ea7e79baa--0ba333ce74504bf6a5e7b80bd6848f54 aabd24331b7d45318f81d8a19b60e321 0ba333ce74504bf6a5e7b80bd6848f54--aabd24331b7d45318f81d8a19b60e321 6c14d270c777492bb01c872c40a7eec1 aabd24331b7d45318f81d8a19b60e321--6c14d270c777492bb01c872c40a7eec1 d83d40f1bfab439d9f11e7b6bc932bb1 6c14d270c777492bb01c872c40a7eec1--d83d40f1bfab439d9f11e7b6bc932bb1 a81d3bb24b8f4ecba458d1e6fcf43fe4 d83d40f1bfab439d9f11e7b6bc932bb1--a81d3bb24b8f4ecba458d1e6fcf43fe4 872a176b941149b98ac23f077d8b9542 a81d3bb24b8f4ecba458d1e6fcf43fe4--872a176b941149b98ac23f077d8b9542 87d95523b4174b80a8a9bc3e2846d2a4 872a176b941149b98ac23f077d8b9542--87d95523b4174b80a8a9bc3e2846d2a4 62f54ea984194abbb5e630a4ddc0f3e4 87d95523b4174b80a8a9bc3e2846d2a4--62f54ea984194abbb5e630a4ddc0f3e4 59dcc7d1164442f9a94367e8e8028ce6 62f54ea984194abbb5e630a4ddc0f3e4--59dcc7d1164442f9a94367e8e8028ce6 157c9f834e614bbe8e6ad9189e36bd0c 59dcc7d1164442f9a94367e8e8028ce6--157c9f834e614bbe8e6ad9189e36bd0c 5850eee00bc14d7da2f9fc5f40e13710 157c9f834e614bbe8e6ad9189e36bd0c--5850eee00bc14d7da2f9fc5f40e13710 4bba6c67596e4d7f89af547ddf549fb4 5850eee00bc14d7da2f9fc5f40e13710--4bba6c67596e4d7f89af547ddf549fb4 3a301eb657a740e9ba2fdc9b8093c59f 4bba6c67596e4d7f89af547ddf549fb4--3a301eb657a740e9ba2fdc9b8093c59f b4586d1cb67a4845a8722ebd7dd89855 3a301eb657a740e9ba2fdc9b8093c59f--b4586d1cb67a4845a8722ebd7dd89855 b6cdeb3cf4e74086a2282ff5270b566e b4586d1cb67a4845a8722ebd7dd89855--b6cdeb3cf4e74086a2282ff5270b566e 99021548ab074a65b73c6e725a3c318e b6cdeb3cf4e74086a2282ff5270b566e--99021548ab074a65b73c6e725a3c318e 918e8d06b5944daab8104d47663eb72b 99021548ab074a65b73c6e725a3c318e--918e8d06b5944daab8104d47663eb72b 9258b1d152ac4e76a4f70e7f1dbd8052 918e8d06b5944daab8104d47663eb72b--9258b1d152ac4e76a4f70e7f1dbd8052 e8ea12b9f70a422cb211f333860fb47b 9258b1d152ac4e76a4f70e7f1dbd8052--e8ea12b9f70a422cb211f333860fb47b db3a69e9a7e5447c96bbee706ed1941e e8ea12b9f70a422cb211f333860fb47b--db3a69e9a7e5447c96bbee706ed1941e 63e8163867ce4adc9d391db716ade08b db3a69e9a7e5447c96bbee706ed1941e--63e8163867ce4adc9d391db716ade08b 0822065c9177468699fa4f78c83a565b 63e8163867ce4adc9d391db716ade08b--0822065c9177468699fa4f78c83a565b dc904dda7cfe4829871cca5aaf65f6c3 0822065c9177468699fa4f78c83a565b--dc904dda7cfe4829871cca5aaf65f6c3 aea802da53fa4fb48d0bbc14f4992a87 dc904dda7cfe4829871cca5aaf65f6c3--aea802da53fa4fb48d0bbc14f4992a87 000c399c8285401cac73a66ee49f800d aea802da53fa4fb48d0bbc14f4992a87--000c399c8285401cac73a66ee49f800d 28dba8099f40452aa2d49db9a95cc3b4 000c399c8285401cac73a66ee49f800d--28dba8099f40452aa2d49db9a95cc3b4 fe2272eb790f4c2fb6cc9aa152c36764 28dba8099f40452aa2d49db9a95cc3b4--fe2272eb790f4c2fb6cc9aa152c36764 936b5842866b47c38619a01a4ec1b845 fe2272eb790f4c2fb6cc9aa152c36764--936b5842866b47c38619a01a4ec1b845 aa49097da1424283bce06e7ba5caf196 936b5842866b47c38619a01a4ec1b845--aa49097da1424283bce06e7ba5caf196 0b1ad9e055e541f1b79693bd5d37f925 aa49097da1424283bce06e7ba5caf196--0b1ad9e055e541f1b79693bd5d37f925 f6732043a3ad4419ba410e6c1456d3fc 0b1ad9e055e541f1b79693bd5d37f925--f6732043a3ad4419ba410e6c1456d3fc dacca8fcd8db43ca8e5e1f2b82255769 f6732043a3ad4419ba410e6c1456d3fc--dacca8fcd8db43ca8e5e1f2b82255769 141ee427e9f14c5aae402fcb0a11ba0b dacca8fcd8db43ca8e5e1f2b82255769--141ee427e9f14c5aae402fcb0a11ba0b 8b534b47b83541c2a55ae9d24aa969e9 141ee427e9f14c5aae402fcb0a11ba0b--8b534b47b83541c2a55ae9d24aa969e9 5db431fc6d7c4599b21f3daa6111016a 8b534b47b83541c2a55ae9d24aa969e9--5db431fc6d7c4599b21f3daa6111016a 43b497ffe2534ad0a690c14a86f88e63 5db431fc6d7c4599b21f3daa6111016a--43b497ffe2534ad0a690c14a86f88e63 751adc0157b544ae9a52d5e4d8638ade 43b497ffe2534ad0a690c14a86f88e63--751adc0157b544ae9a52d5e4d8638ade d55d37b3397d4a75ab3e03c12b9303ea 751adc0157b544ae9a52d5e4d8638ade--d55d37b3397d4a75ab3e03c12b9303ea d3b0065f1e3746fa87dc08b9018027d3 d55d37b3397d4a75ab3e03c12b9303ea--d3b0065f1e3746fa87dc08b9018027d3 aef8bc5b08d14de6bba4bff81cb9fb57 d3b0065f1e3746fa87dc08b9018027d3--aef8bc5b08d14de6bba4bff81cb9fb57 17a2c77f2e834f2ea76bc269d7eaede6 aef8bc5b08d14de6bba4bff81cb9fb57--17a2c77f2e834f2ea76bc269d7eaede6 758b4485efc2416394e3764db115893d 17a2c77f2e834f2ea76bc269d7eaede6--758b4485efc2416394e3764db115893d 3b7f2d12629f46c2888d7202b5838550 758b4485efc2416394e3764db115893d--3b7f2d12629f46c2888d7202b5838550 5e7e0f9c46f9424eaa541677700ba1b2 3b7f2d12629f46c2888d7202b5838550--5e7e0f9c46f9424eaa541677700ba1b2 cdd9ea3077cb4ae4959b63c735047ed2 5e7e0f9c46f9424eaa541677700ba1b2--cdd9ea3077cb4ae4959b63c735047ed2 f15b6b94303640ee82220583586f0b51 RX(b11) cdd9ea3077cb4ae4959b63c735047ed2--f15b6b94303640ee82220583586f0b51 f15b6b94303640ee82220583586f0b51--1c7dbe7ee157406ab98607162af29370 6d7e9af3618d4423bf87cafa175c21fe 3ac24e54d529401a916a1bbe49e2f78a f6556b8310cc445789d375080e4fb33a--3ac24e54d529401a916a1bbe49e2f78a dbd7067e18e84d30aedfb79f001b6b5a 3 efbcc56c8959430081eea0cbb16648eb X 3ac24e54d529401a916a1bbe49e2f78a--efbcc56c8959430081eea0cbb16648eb efbcc56c8959430081eea0cbb16648eb--628bbf53c31847e4bd08b47e8130ddcd cb510c6a615b47e78ed79d0f0e8e11ec efbcc56c8959430081eea0cbb16648eb--cb510c6a615b47e78ed79d0f0e8e11ec 79950b0130a841c59345cf1dcc6b653f cb510c6a615b47e78ed79d0f0e8e11ec--79950b0130a841c59345cf1dcc6b653f bb879bf534c946c2b87072e1c328a228 79950b0130a841c59345cf1dcc6b653f--bb879bf534c946c2b87072e1c328a228 454acacd28324cbaa79d9cfd5ed36c85 bb879bf534c946c2b87072e1c328a228--454acacd28324cbaa79d9cfd5ed36c85 6743aa6f462d406bb3e1353316403935 454acacd28324cbaa79d9cfd5ed36c85--6743aa6f462d406bb3e1353316403935 cbe55f7bf0a04a6cb36dfc6c804895cc 6743aa6f462d406bb3e1353316403935--cbe55f7bf0a04a6cb36dfc6c804895cc 5e854919059549428b3125166ab3a27d cbe55f7bf0a04a6cb36dfc6c804895cc--5e854919059549428b3125166ab3a27d ed063281bbc74bdc9849cecb2873965f 5e854919059549428b3125166ab3a27d--ed063281bbc74bdc9849cecb2873965f a616592e0ac641a9bc3a98956483f0f7 ed063281bbc74bdc9849cecb2873965f--a616592e0ac641a9bc3a98956483f0f7 d7adf25b1a99477e9ff790272c057dab a616592e0ac641a9bc3a98956483f0f7--d7adf25b1a99477e9ff790272c057dab 954fa005f0e94315a573d3f5b451ed21 d7adf25b1a99477e9ff790272c057dab--954fa005f0e94315a573d3f5b451ed21 c0841e87286f40e8bf3661b9218596d6 X 954fa005f0e94315a573d3f5b451ed21--c0841e87286f40e8bf3661b9218596d6 c0841e87286f40e8bf3661b9218596d6--c6ceeeae121847bc816068cdb4be05a2 c6ff23a746c044bda9cb055fbf410ac7 c0841e87286f40e8bf3661b9218596d6--c6ff23a746c044bda9cb055fbf410ac7 54f67f1bc1464169b0accbdd3b5869bc c6ff23a746c044bda9cb055fbf410ac7--54f67f1bc1464169b0accbdd3b5869bc 98b5482049194d31aac475b83c7d57de 54f67f1bc1464169b0accbdd3b5869bc--98b5482049194d31aac475b83c7d57de 36690eebaac84b8bb6290b7d13a9dbbf 98b5482049194d31aac475b83c7d57de--36690eebaac84b8bb6290b7d13a9dbbf e02607972a01416e8e1bf52a7311c8c9 36690eebaac84b8bb6290b7d13a9dbbf--e02607972a01416e8e1bf52a7311c8c9 244e83955ee445f3a7cfd4f531045656 X e02607972a01416e8e1bf52a7311c8c9--244e83955ee445f3a7cfd4f531045656 244e83955ee445f3a7cfd4f531045656--0585541fb15e4470b1ef0fa6e89f2c81 808eab8cc80f4558b868b7b6419ec815 244e83955ee445f3a7cfd4f531045656--808eab8cc80f4558b868b7b6419ec815 2f03f3cea83a49919ddf6552ba9740ef 808eab8cc80f4558b868b7b6419ec815--2f03f3cea83a49919ddf6552ba9740ef 46c3139725364dcb963a4d0c7ff314aa 2f03f3cea83a49919ddf6552ba9740ef--46c3139725364dcb963a4d0c7ff314aa 793193d95f6648a1b2efe02cc78ac23f 46c3139725364dcb963a4d0c7ff314aa--793193d95f6648a1b2efe02cc78ac23f 98df35d6a0194e61afeddb3a1032c6df 793193d95f6648a1b2efe02cc78ac23f--98df35d6a0194e61afeddb3a1032c6df 7c7e06f0c5024b5285534b914cf7974f X 98df35d6a0194e61afeddb3a1032c6df--7c7e06f0c5024b5285534b914cf7974f 7c7e06f0c5024b5285534b914cf7974f--c8f8b7ab9be74c5db446791e711b363f 93b4ccae9f60476bb437e8a616cc4abd 7c7e06f0c5024b5285534b914cf7974f--93b4ccae9f60476bb437e8a616cc4abd b73f5e2aa0704325b4f26f4ec8942a42 93b4ccae9f60476bb437e8a616cc4abd--b73f5e2aa0704325b4f26f4ec8942a42 caf9dcc9b4f6412a9bd797976971b042 X b73f5e2aa0704325b4f26f4ec8942a42--caf9dcc9b4f6412a9bd797976971b042 caf9dcc9b4f6412a9bd797976971b042--fef9df1eee3d47e9993d655fed907e35 bb5909aa7af84c1596a0cdde6d2c7410 caf9dcc9b4f6412a9bd797976971b042--bb5909aa7af84c1596a0cdde6d2c7410 a35b3ec73f0744a1af15c6e77f9c88c3 bb5909aa7af84c1596a0cdde6d2c7410--a35b3ec73f0744a1af15c6e77f9c88c3 f3b41f1270684009a53455dc67263b61 a35b3ec73f0744a1af15c6e77f9c88c3--f3b41f1270684009a53455dc67263b61 a32f3878218d4daa9158e5d84ef8a7c0 f3b41f1270684009a53455dc67263b61--a32f3878218d4daa9158e5d84ef8a7c0 15b4a1069dbf468396933022cb992ee1 a32f3878218d4daa9158e5d84ef8a7c0--15b4a1069dbf468396933022cb992ee1 f31295817b774c57a0546578ca2d8016 15b4a1069dbf468396933022cb992ee1--f31295817b774c57a0546578ca2d8016 9ab79490741f4c4e9f8ffe1ac9db0738 f31295817b774c57a0546578ca2d8016--9ab79490741f4c4e9f8ffe1ac9db0738 e0555821ed2c43f593b7bfc51778b56d 9ab79490741f4c4e9f8ffe1ac9db0738--e0555821ed2c43f593b7bfc51778b56d 8b9f763bb919469b9456a1797e136c07 e0555821ed2c43f593b7bfc51778b56d--8b9f763bb919469b9456a1797e136c07 5579b4ba05854b25a3fadb024699367a X 8b9f763bb919469b9456a1797e136c07--5579b4ba05854b25a3fadb024699367a 5579b4ba05854b25a3fadb024699367a--3ad382b8ed4a48348e6e536daca83b4a 6e43c09afbb84dadb5c44949c66182c1 5579b4ba05854b25a3fadb024699367a--6e43c09afbb84dadb5c44949c66182c1 388fea9d7cd743c78e0f5edaf32a0c9e X 6e43c09afbb84dadb5c44949c66182c1--388fea9d7cd743c78e0f5edaf32a0c9e 388fea9d7cd743c78e0f5edaf32a0c9e--e03d005978cb46d98fb89b2a8990f5ab d4c05fdd0b404928beb24de2ac84eabd RZ(-1.0*g0) 388fea9d7cd743c78e0f5edaf32a0c9e--d4c05fdd0b404928beb24de2ac84eabd ac101d5bbcad4463bab86bb45b74fdaf X d4c05fdd0b404928beb24de2ac84eabd--ac101d5bbcad4463bab86bb45b74fdaf ac101d5bbcad4463bab86bb45b74fdaf--4dcd486e25184cddba53243c4662bcdd 5592af2a489b4e9fa153dc9870666fa6 X ac101d5bbcad4463bab86bb45b74fdaf--5592af2a489b4e9fa153dc9870666fa6 5592af2a489b4e9fa153dc9870666fa6--63175c939d854cc095ee5f40c06e82d9 95f301967434436aaa1511c4b4719037 5592af2a489b4e9fa153dc9870666fa6--95f301967434436aaa1511c4b4719037 631f63d01ebb47bcb04b4eb07c966f31 95f301967434436aaa1511c4b4719037--631f63d01ebb47bcb04b4eb07c966f31 d4dc6cba54af4b4bb1aee8c0ec744f74 631f63d01ebb47bcb04b4eb07c966f31--d4dc6cba54af4b4bb1aee8c0ec744f74 ebb6de815ca640848d58661b21d32e03 X d4dc6cba54af4b4bb1aee8c0ec744f74--ebb6de815ca640848d58661b21d32e03 ebb6de815ca640848d58661b21d32e03--692ad0498e344cc38239eb7901e91ca8 9ad1ef28091444ea9cf6c4f441e8b449 X ebb6de815ca640848d58661b21d32e03--9ad1ef28091444ea9cf6c4f441e8b449 9ad1ef28091444ea9cf6c4f441e8b449--d2d567d845d041528e6e61025c8adb31 331ed0ec1c864673aa47836addda7655 9ad1ef28091444ea9cf6c4f441e8b449--331ed0ec1c864673aa47836addda7655 4d761ae7cc3247a2bfa48493b1e4a94c 331ed0ec1c864673aa47836addda7655--4d761ae7cc3247a2bfa48493b1e4a94c 6eaa910019334e2abd579ca1d4b5a487 4d761ae7cc3247a2bfa48493b1e4a94c--6eaa910019334e2abd579ca1d4b5a487 a924e72afc5148c1852d30a32601d635 6eaa910019334e2abd579ca1d4b5a487--a924e72afc5148c1852d30a32601d635 51205be47acf4288b9a4f8a15b68a4f1 a924e72afc5148c1852d30a32601d635--51205be47acf4288b9a4f8a15b68a4f1 58dfaf0be4f944b8b57805c8ff1a257b 51205be47acf4288b9a4f8a15b68a4f1--58dfaf0be4f944b8b57805c8ff1a257b 866b8f2213a3484c91550df2548d659c 58dfaf0be4f944b8b57805c8ff1a257b--866b8f2213a3484c91550df2548d659c 1f878997a4e54c488ba7fb9e252ad231 X 866b8f2213a3484c91550df2548d659c--1f878997a4e54c488ba7fb9e252ad231 1f878997a4e54c488ba7fb9e252ad231--7629aa83bd814e0188f0b0b03d7e7265 6ccfe2f49e4d42239938ee702fdbbd0d X 1f878997a4e54c488ba7fb9e252ad231--6ccfe2f49e4d42239938ee702fdbbd0d 6ccfe2f49e4d42239938ee702fdbbd0d--c6e2362de54c4ac2b62f5517e207e3ba 5565c8f93aa8485caf59be501137aa62 6ccfe2f49e4d42239938ee702fdbbd0d--5565c8f93aa8485caf59be501137aa62 16ac24a3807641f585e884c5cd37d680 5565c8f93aa8485caf59be501137aa62--16ac24a3807641f585e884c5cd37d680 389156b87f2e479b85b0bfaa694e6be3 16ac24a3807641f585e884c5cd37d680--389156b87f2e479b85b0bfaa694e6be3 4d9a1b90d1674301af5158c0c0740635 389156b87f2e479b85b0bfaa694e6be3--4d9a1b90d1674301af5158c0c0740635 d106874b0ded48d5bb42a43a48552b2f 4d9a1b90d1674301af5158c0c0740635--d106874b0ded48d5bb42a43a48552b2f 921d75296cde4e4b80d95d0d9204d5ed d106874b0ded48d5bb42a43a48552b2f--921d75296cde4e4b80d95d0d9204d5ed 983688b359784ecb9a89eec139902e69 921d75296cde4e4b80d95d0d9204d5ed--983688b359784ecb9a89eec139902e69 b5a8f001be434021bc9169e239409f78 983688b359784ecb9a89eec139902e69--b5a8f001be434021bc9169e239409f78 185cbfd8a1c644f8817688def7e36c52 b5a8f001be434021bc9169e239409f78--185cbfd8a1c644f8817688def7e36c52 053488350d1744c9831e7ded6605b15a 185cbfd8a1c644f8817688def7e36c52--053488350d1744c9831e7ded6605b15a bb1de3d5d7c94d448fd8552f98a73229 053488350d1744c9831e7ded6605b15a--bb1de3d5d7c94d448fd8552f98a73229 94d5b676d70744f39fba7033e5dda81e X bb1de3d5d7c94d448fd8552f98a73229--94d5b676d70744f39fba7033e5dda81e 94d5b676d70744f39fba7033e5dda81e--7f96f07db0354e4d864d4c56f0105ff5 5e089e5952014e8f8f24bf2eebf40706 94d5b676d70744f39fba7033e5dda81e--5e089e5952014e8f8f24bf2eebf40706 6aba8f1ca3e543858a73761ab0987326 5e089e5952014e8f8f24bf2eebf40706--6aba8f1ca3e543858a73761ab0987326 8d9ef8b3c07545b78ed088ab58da7b02 6aba8f1ca3e543858a73761ab0987326--8d9ef8b3c07545b78ed088ab58da7b02 3eb29a3a9429477d9a4b22e047e52557 8d9ef8b3c07545b78ed088ab58da7b02--3eb29a3a9429477d9a4b22e047e52557 862fc76444db450eb39b5d378dfeecb5 3eb29a3a9429477d9a4b22e047e52557--862fc76444db450eb39b5d378dfeecb5 f575e4b75c304c1cbbc09b5064f6ff40 862fc76444db450eb39b5d378dfeecb5--f575e4b75c304c1cbbc09b5064f6ff40 ec90bc036b0a4173a0d1f89e2ed0e292 f575e4b75c304c1cbbc09b5064f6ff40--ec90bc036b0a4173a0d1f89e2ed0e292 ef2c3ba36e8948bea5d17ef5f8a4233c ec90bc036b0a4173a0d1f89e2ed0e292--ef2c3ba36e8948bea5d17ef5f8a4233c 3f26dfb5b1524788ae36ef3372d2ead9 ef2c3ba36e8948bea5d17ef5f8a4233c--3f26dfb5b1524788ae36ef3372d2ead9 2e9fb5ba2e8544b69d4cd4dc3fd01564 3f26dfb5b1524788ae36ef3372d2ead9--2e9fb5ba2e8544b69d4cd4dc3fd01564 c2806529d3be4e7d87dc2e6ad34ad59e 2e9fb5ba2e8544b69d4cd4dc3fd01564--c2806529d3be4e7d87dc2e6ad34ad59e 39fae68df19f4e6ca69848b4cc766f5f c2806529d3be4e7d87dc2e6ad34ad59e--39fae68df19f4e6ca69848b4cc766f5f ddec07c5387c40c6b656db270b732584 39fae68df19f4e6ca69848b4cc766f5f--ddec07c5387c40c6b656db270b732584 eff347698033417bab6a85b2c8879287 ddec07c5387c40c6b656db270b732584--eff347698033417bab6a85b2c8879287 079c4494f9ff4928a3751d69f57fa893 eff347698033417bab6a85b2c8879287--079c4494f9ff4928a3751d69f57fa893 31ce5b1acbb247a08de0339a6b8d47f0 079c4494f9ff4928a3751d69f57fa893--31ce5b1acbb247a08de0339a6b8d47f0 3575bd8e558c4782ada057addc27affd 31ce5b1acbb247a08de0339a6b8d47f0--3575bd8e558c4782ada057addc27affd 3c3978d46a94460a98bfa33620c150b6 3575bd8e558c4782ada057addc27affd--3c3978d46a94460a98bfa33620c150b6 59f89da0bb1147a3a2a2461e88efd056 3c3978d46a94460a98bfa33620c150b6--59f89da0bb1147a3a2a2461e88efd056 3ae5985f7b57487e9e438e0c92d5cf8d 59f89da0bb1147a3a2a2461e88efd056--3ae5985f7b57487e9e438e0c92d5cf8d b6b99ebab2624ec7b91531536582bb44 3ae5985f7b57487e9e438e0c92d5cf8d--b6b99ebab2624ec7b91531536582bb44 cff0728a54764c3998834b2a55476bb8 b6b99ebab2624ec7b91531536582bb44--cff0728a54764c3998834b2a55476bb8 73b73150ee2843eea830fb333974c853 cff0728a54764c3998834b2a55476bb8--73b73150ee2843eea830fb333974c853 11c496a16ae94fd79d8f735a31be096d 73b73150ee2843eea830fb333974c853--11c496a16ae94fd79d8f735a31be096d 4182c11946c84fc9a19d4ba3ade87b20 11c496a16ae94fd79d8f735a31be096d--4182c11946c84fc9a19d4ba3ade87b20 b1615d4fa4bd49e1a33b5d9d7119a187 4182c11946c84fc9a19d4ba3ade87b20--b1615d4fa4bd49e1a33b5d9d7119a187 7fd7755ad611488aa998cc206b818ac2 b1615d4fa4bd49e1a33b5d9d7119a187--7fd7755ad611488aa998cc206b818ac2 028bf5725b134ea39728a09163b8d4e6 7fd7755ad611488aa998cc206b818ac2--028bf5725b134ea39728a09163b8d4e6 2c11d1f9239e4339810bcaddcdc524b0 028bf5725b134ea39728a09163b8d4e6--2c11d1f9239e4339810bcaddcdc524b0 26ef4e27c433474188d59da79f00774e 2c11d1f9239e4339810bcaddcdc524b0--26ef4e27c433474188d59da79f00774e f0e9a17555e9419fadd3361a8ef21b8f 26ef4e27c433474188d59da79f00774e--f0e9a17555e9419fadd3361a8ef21b8f bdd223e0c2684fb2bba4129b5811cd85 f0e9a17555e9419fadd3361a8ef21b8f--bdd223e0c2684fb2bba4129b5811cd85 c203a9de11984994b5b5d33f83b8acc8 bdd223e0c2684fb2bba4129b5811cd85--c203a9de11984994b5b5d33f83b8acc8 4ec6064f197143108cde4f01e31bd0aa c203a9de11984994b5b5d33f83b8acc8--4ec6064f197143108cde4f01e31bd0aa 161f2ed93ac04d268d74f99973842a16 4ec6064f197143108cde4f01e31bd0aa--161f2ed93ac04d268d74f99973842a16 d7f61110f869465d868baa716b269435 161f2ed93ac04d268d74f99973842a16--d7f61110f869465d868baa716b269435 9d961f75d03b42aa9d9db805fb4d1f4b d7f61110f869465d868baa716b269435--9d961f75d03b42aa9d9db805fb4d1f4b 96b63814efc44516851cebca61e78273 9d961f75d03b42aa9d9db805fb4d1f4b--96b63814efc44516851cebca61e78273 6632fa1632de41afbbf9aa2bb7c60185 96b63814efc44516851cebca61e78273--6632fa1632de41afbbf9aa2bb7c60185 6c1e058af2064961ac182e0b32e3158a RX(b02) 6632fa1632de41afbbf9aa2bb7c60185--6c1e058af2064961ac182e0b32e3158a 806640e9c2164861bca2fcc98f3fd10e 6c1e058af2064961ac182e0b32e3158a--806640e9c2164861bca2fcc98f3fd10e f87d0faccae04eaa90410a7e88fcfe5f X 806640e9c2164861bca2fcc98f3fd10e--f87d0faccae04eaa90410a7e88fcfe5f f87d0faccae04eaa90410a7e88fcfe5f--e116a8d4f85a443da77cd16163f4098e 5e0786d6a7174ce384d65b34b07aaa04 f87d0faccae04eaa90410a7e88fcfe5f--5e0786d6a7174ce384d65b34b07aaa04 c8b104510ebe497fb2b7a6618cd0ffa4 5e0786d6a7174ce384d65b34b07aaa04--c8b104510ebe497fb2b7a6618cd0ffa4 33781572b4a74d90b42219c086adc733 c8b104510ebe497fb2b7a6618cd0ffa4--33781572b4a74d90b42219c086adc733 8e5b224065ff4532b5695645422e8f37 33781572b4a74d90b42219c086adc733--8e5b224065ff4532b5695645422e8f37 a026f7048e484e99a255673d175fd630 8e5b224065ff4532b5695645422e8f37--a026f7048e484e99a255673d175fd630 83191743092d4829ae3a8ca43052e8be a026f7048e484e99a255673d175fd630--83191743092d4829ae3a8ca43052e8be 9c90a1a75ec347608d80c9d69b3b87da 83191743092d4829ae3a8ca43052e8be--9c90a1a75ec347608d80c9d69b3b87da 4df109ec7a7148bcbb51aef1bb691779 9c90a1a75ec347608d80c9d69b3b87da--4df109ec7a7148bcbb51aef1bb691779 defcccd1e9de45afbda75c233bf48371 4df109ec7a7148bcbb51aef1bb691779--defcccd1e9de45afbda75c233bf48371 dc49d42065564b77acce3143247df2af defcccd1e9de45afbda75c233bf48371--dc49d42065564b77acce3143247df2af 6583765c51704ed0b5f57412f19205a8 dc49d42065564b77acce3143247df2af--6583765c51704ed0b5f57412f19205a8 eac47cdf1b0549b09f4400d187371524 X 6583765c51704ed0b5f57412f19205a8--eac47cdf1b0549b09f4400d187371524 eac47cdf1b0549b09f4400d187371524--89f986dcb9104ab88a4b0f3b1533bbb4 9c88fb1da2884560a08704c855bd6bd8 eac47cdf1b0549b09f4400d187371524--9c88fb1da2884560a08704c855bd6bd8 ff7a051a6c76483f88a5eb6ff2a6ffef 9c88fb1da2884560a08704c855bd6bd8--ff7a051a6c76483f88a5eb6ff2a6ffef 800719d4bb764edea110bb7e35fc672f ff7a051a6c76483f88a5eb6ff2a6ffef--800719d4bb764edea110bb7e35fc672f 5f88cf6062844d6dbeccc7ddb5412319 800719d4bb764edea110bb7e35fc672f--5f88cf6062844d6dbeccc7ddb5412319 a380f6834e3b4fbf86bb1f4d6210c899 5f88cf6062844d6dbeccc7ddb5412319--a380f6834e3b4fbf86bb1f4d6210c899 cdc39e113a0945ca91e952bb690c599b X a380f6834e3b4fbf86bb1f4d6210c899--cdc39e113a0945ca91e952bb690c599b cdc39e113a0945ca91e952bb690c599b--fa1d3be2bd4b48be9125ca7d282a380c ce86b8b0e79a475db7ef4a24c71568c9 cdc39e113a0945ca91e952bb690c599b--ce86b8b0e79a475db7ef4a24c71568c9 0fbcaf4155994963899a45c8bfd23959 ce86b8b0e79a475db7ef4a24c71568c9--0fbcaf4155994963899a45c8bfd23959 5463bbfecbd14d64a3ce8a1d5da084fe 0fbcaf4155994963899a45c8bfd23959--5463bbfecbd14d64a3ce8a1d5da084fe 72fa43aedcc14f098caac8b0141ac995 5463bbfecbd14d64a3ce8a1d5da084fe--72fa43aedcc14f098caac8b0141ac995 0c4f53ed8cb44e6a9874bf1436d74e95 72fa43aedcc14f098caac8b0141ac995--0c4f53ed8cb44e6a9874bf1436d74e95 bf7e2086f049406e9a53d0ecca49a2c9 X 0c4f53ed8cb44e6a9874bf1436d74e95--bf7e2086f049406e9a53d0ecca49a2c9 bf7e2086f049406e9a53d0ecca49a2c9--98f8fc9c0daf48ca92ff8f0eb6ad7cf2 cd40ea2520624e9dbd8d568fdfcc0dbc bf7e2086f049406e9a53d0ecca49a2c9--cd40ea2520624e9dbd8d568fdfcc0dbc 01f86c41801d4161990560ba695ff947 cd40ea2520624e9dbd8d568fdfcc0dbc--01f86c41801d4161990560ba695ff947 788c0a27ee14436f99328a23b28d3a76 X 01f86c41801d4161990560ba695ff947--788c0a27ee14436f99328a23b28d3a76 788c0a27ee14436f99328a23b28d3a76--58d8770149f24be69d7694feab3978ed c553917eb14c4209a15000b5cc98e76e 788c0a27ee14436f99328a23b28d3a76--c553917eb14c4209a15000b5cc98e76e 1283e3fe339b4442b84d4019ec6c1ea2 c553917eb14c4209a15000b5cc98e76e--1283e3fe339b4442b84d4019ec6c1ea2 cbc570f4867f4731b28a9c7e6ddb5550 1283e3fe339b4442b84d4019ec6c1ea2--cbc570f4867f4731b28a9c7e6ddb5550 f49f5b97204a4ea6ac5380b26632ff85 cbc570f4867f4731b28a9c7e6ddb5550--f49f5b97204a4ea6ac5380b26632ff85 00ffe341a80f41b9adeef22746d5226c f49f5b97204a4ea6ac5380b26632ff85--00ffe341a80f41b9adeef22746d5226c 55fe72f5244b444ebf43a4ed59d518c5 00ffe341a80f41b9adeef22746d5226c--55fe72f5244b444ebf43a4ed59d518c5 6b229b2b234c453c82faae2026c4f0e1 55fe72f5244b444ebf43a4ed59d518c5--6b229b2b234c453c82faae2026c4f0e1 1d34c56a85e9424e8de932afbed7cfbb 6b229b2b234c453c82faae2026c4f0e1--1d34c56a85e9424e8de932afbed7cfbb 500b4d3eb2a14cec8bbe24a31db0302c 1d34c56a85e9424e8de932afbed7cfbb--500b4d3eb2a14cec8bbe24a31db0302c ac34d2e0a22f4ca580fd1dfdd2ea84fa X 500b4d3eb2a14cec8bbe24a31db0302c--ac34d2e0a22f4ca580fd1dfdd2ea84fa ac34d2e0a22f4ca580fd1dfdd2ea84fa--a351bc53a0964bb3b2f6b2ce1ea8ff1a d4678a556c4e4f36a13e3d1392715316 ac34d2e0a22f4ca580fd1dfdd2ea84fa--d4678a556c4e4f36a13e3d1392715316 8355aad9bb0a497f9c1fa6f50e28853f X d4678a556c4e4f36a13e3d1392715316--8355aad9bb0a497f9c1fa6f50e28853f 8355aad9bb0a497f9c1fa6f50e28853f--61eab1dbc49a4c50a73a0429a07fc49f 48c8f5e51c8b4e31a3212b7326bdfc6b RZ(-1.0*g1) 8355aad9bb0a497f9c1fa6f50e28853f--48c8f5e51c8b4e31a3212b7326bdfc6b 38859ce3b34a44e89df05b7bdd75e16c X 48c8f5e51c8b4e31a3212b7326bdfc6b--38859ce3b34a44e89df05b7bdd75e16c 38859ce3b34a44e89df05b7bdd75e16c--69dec752d85749008a2f80af585c8858 70f9fa3417ac4b1da51a9f015ab06b5e X 38859ce3b34a44e89df05b7bdd75e16c--70f9fa3417ac4b1da51a9f015ab06b5e 70f9fa3417ac4b1da51a9f015ab06b5e--9d72aafde2134c5ba9a93993ed69b9d2 757e04b11cee4dea977ba6e9284b0105 70f9fa3417ac4b1da51a9f015ab06b5e--757e04b11cee4dea977ba6e9284b0105 3964655b38ff42c28e92514a64ef407c 757e04b11cee4dea977ba6e9284b0105--3964655b38ff42c28e92514a64ef407c 323d4587c26648529aa30645eaad3a21 3964655b38ff42c28e92514a64ef407c--323d4587c26648529aa30645eaad3a21 c9ec892b4ea940dc978db1a72786f501 X 323d4587c26648529aa30645eaad3a21--c9ec892b4ea940dc978db1a72786f501 c9ec892b4ea940dc978db1a72786f501--03b1305de6174495a43fe6214e4c8f0d c4b0a4cd40f44bceb27f062c9977deb0 X c9ec892b4ea940dc978db1a72786f501--c4b0a4cd40f44bceb27f062c9977deb0 c4b0a4cd40f44bceb27f062c9977deb0--078b95d70bba4eb491ad13c1b30d935b 019e257e765d434b89f9316c5fc64a34 c4b0a4cd40f44bceb27f062c9977deb0--019e257e765d434b89f9316c5fc64a34 92c977e1a5084667a9259499f4df3222 019e257e765d434b89f9316c5fc64a34--92c977e1a5084667a9259499f4df3222 c4bd0e04904e4a13beac182763622793 92c977e1a5084667a9259499f4df3222--c4bd0e04904e4a13beac182763622793 a43173a2a80f45b882c9cab3e116a9d9 c4bd0e04904e4a13beac182763622793--a43173a2a80f45b882c9cab3e116a9d9 bfcfae53218e4159b897d8cda8ea6235 a43173a2a80f45b882c9cab3e116a9d9--bfcfae53218e4159b897d8cda8ea6235 b42889e3842b4e2799aec3bb7ea79e7d bfcfae53218e4159b897d8cda8ea6235--b42889e3842b4e2799aec3bb7ea79e7d e4a11c8675f240d19f51e2cae408c76f b42889e3842b4e2799aec3bb7ea79e7d--e4a11c8675f240d19f51e2cae408c76f 13a9edbf3d7b453988b015ce2afabfc9 X e4a11c8675f240d19f51e2cae408c76f--13a9edbf3d7b453988b015ce2afabfc9 13a9edbf3d7b453988b015ce2afabfc9--2a6df625ef234226993df1071c6c5f4e 530d3f789a214156957abc7f7e0ac9bc X 13a9edbf3d7b453988b015ce2afabfc9--530d3f789a214156957abc7f7e0ac9bc 530d3f789a214156957abc7f7e0ac9bc--6df0ce4860d84d58a8440a467516d247 6c918f8dbf3d422ea471f1839b9f7dac 530d3f789a214156957abc7f7e0ac9bc--6c918f8dbf3d422ea471f1839b9f7dac 3c6ec5e718754deda07ea622a0174a65 6c918f8dbf3d422ea471f1839b9f7dac--3c6ec5e718754deda07ea622a0174a65 c908350bfb9747ffbde78c407e3d58d6 3c6ec5e718754deda07ea622a0174a65--c908350bfb9747ffbde78c407e3d58d6 ebe7c2a1d6844603b182eab92a0c7916 c908350bfb9747ffbde78c407e3d58d6--ebe7c2a1d6844603b182eab92a0c7916 991d16b29cca4a3b8244ee684b83b5ae ebe7c2a1d6844603b182eab92a0c7916--991d16b29cca4a3b8244ee684b83b5ae 25ae158210244286a5e7c74179f7a0a0 991d16b29cca4a3b8244ee684b83b5ae--25ae158210244286a5e7c74179f7a0a0 57688a3fbe7342f99065bd2440c59ba4 25ae158210244286a5e7c74179f7a0a0--57688a3fbe7342f99065bd2440c59ba4 9c483b73e87341249b025e3e37ebf7a0 57688a3fbe7342f99065bd2440c59ba4--9c483b73e87341249b025e3e37ebf7a0 fe8a5fb7258b4b8598ce1df4c5bcc33c 9c483b73e87341249b025e3e37ebf7a0--fe8a5fb7258b4b8598ce1df4c5bcc33c 52d237575d9a42788c3433df1dc8889b fe8a5fb7258b4b8598ce1df4c5bcc33c--52d237575d9a42788c3433df1dc8889b c950395755ee4568a43af6689c9cb1c9 52d237575d9a42788c3433df1dc8889b--c950395755ee4568a43af6689c9cb1c9 d2e8954d49414251bb1187f84df67651 X c950395755ee4568a43af6689c9cb1c9--d2e8954d49414251bb1187f84df67651 d2e8954d49414251bb1187f84df67651--872a176b941149b98ac23f077d8b9542 c35127650b9043dfbf2b467ea71c471e d2e8954d49414251bb1187f84df67651--c35127650b9043dfbf2b467ea71c471e 6826402e65bf48b49af9da3776470bcb c35127650b9043dfbf2b467ea71c471e--6826402e65bf48b49af9da3776470bcb 632fcc37ab854fb6a815e4daa1effd97 6826402e65bf48b49af9da3776470bcb--632fcc37ab854fb6a815e4daa1effd97 0b765e09833d479c9e04217e43f1ed56 632fcc37ab854fb6a815e4daa1effd97--0b765e09833d479c9e04217e43f1ed56 0e4c1dd8a890495a8f342f0887e9bb3f 0b765e09833d479c9e04217e43f1ed56--0e4c1dd8a890495a8f342f0887e9bb3f 1873baf733a94af9b506a63f0882f871 0e4c1dd8a890495a8f342f0887e9bb3f--1873baf733a94af9b506a63f0882f871 75e075646f4f46ca9e2601a4ad696fd9 1873baf733a94af9b506a63f0882f871--75e075646f4f46ca9e2601a4ad696fd9 11d206c248104cd09d6a7d981d7f7d50 75e075646f4f46ca9e2601a4ad696fd9--11d206c248104cd09d6a7d981d7f7d50 0254475874824fde8e9d43e61a6a279d 11d206c248104cd09d6a7d981d7f7d50--0254475874824fde8e9d43e61a6a279d 8926fcbf07d54eb5928c216b0f50e2b8 0254475874824fde8e9d43e61a6a279d--8926fcbf07d54eb5928c216b0f50e2b8 692749b1b0954e748754a25d514ae6ce 8926fcbf07d54eb5928c216b0f50e2b8--692749b1b0954e748754a25d514ae6ce 8a331522aedc4278a66ad7510aad9569 692749b1b0954e748754a25d514ae6ce--8a331522aedc4278a66ad7510aad9569 621afebced754642a5a5492e4ea4796b 8a331522aedc4278a66ad7510aad9569--621afebced754642a5a5492e4ea4796b a56478a551aa44e0bd88fda6e331f6da 621afebced754642a5a5492e4ea4796b--a56478a551aa44e0bd88fda6e331f6da f94f1318f1ac49eeaad74ab270a39944 a56478a551aa44e0bd88fda6e331f6da--f94f1318f1ac49eeaad74ab270a39944 b4fa2bfd60044939970508c2a974ad67 f94f1318f1ac49eeaad74ab270a39944--b4fa2bfd60044939970508c2a974ad67 f9272a0707cc425d9fe658dac8feef15 b4fa2bfd60044939970508c2a974ad67--f9272a0707cc425d9fe658dac8feef15 d6be706b38ba4c16b0b2b02a7485a52b f9272a0707cc425d9fe658dac8feef15--d6be706b38ba4c16b0b2b02a7485a52b 7e41306b93074282aa6044b11ebe56f8 d6be706b38ba4c16b0b2b02a7485a52b--7e41306b93074282aa6044b11ebe56f8 292779ce569c4135a2e3048e41ed6315 7e41306b93074282aa6044b11ebe56f8--292779ce569c4135a2e3048e41ed6315 b9a4960a75354a3ba01f8962205cf4c0 292779ce569c4135a2e3048e41ed6315--b9a4960a75354a3ba01f8962205cf4c0 f061e2ca20874453aa68b667786060de b9a4960a75354a3ba01f8962205cf4c0--f061e2ca20874453aa68b667786060de b446e09ae16e418eab1c8a6da47d4b58 f061e2ca20874453aa68b667786060de--b446e09ae16e418eab1c8a6da47d4b58 ff9aaf1299a344278684a7b5aa08a540 b446e09ae16e418eab1c8a6da47d4b58--ff9aaf1299a344278684a7b5aa08a540 61bc77e012a34639a32d76b3eddfbcfd ff9aaf1299a344278684a7b5aa08a540--61bc77e012a34639a32d76b3eddfbcfd 73eea990b8bc4b45b774d660ebcd17b7 61bc77e012a34639a32d76b3eddfbcfd--73eea990b8bc4b45b774d660ebcd17b7 aae1a8dd31d14e4cb093b67a74a8d23d 73eea990b8bc4b45b774d660ebcd17b7--aae1a8dd31d14e4cb093b67a74a8d23d 86053adb75584c32b4398214f9a51092 aae1a8dd31d14e4cb093b67a74a8d23d--86053adb75584c32b4398214f9a51092 75483e53b2e74b95b001c78dec7016fd 86053adb75584c32b4398214f9a51092--75483e53b2e74b95b001c78dec7016fd 3c28c2e7c692498ca620579d735a26f3 75483e53b2e74b95b001c78dec7016fd--3c28c2e7c692498ca620579d735a26f3 47f92f1202dc4958a6e6ff515f3e279c 3c28c2e7c692498ca620579d735a26f3--47f92f1202dc4958a6e6ff515f3e279c f053f51a961a45d3bb26b92908302777 47f92f1202dc4958a6e6ff515f3e279c--f053f51a961a45d3bb26b92908302777 6cc697761da3442c86658a825dd9af4c f053f51a961a45d3bb26b92908302777--6cc697761da3442c86658a825dd9af4c b9f7976466164263ad5929aa12521a55 6cc697761da3442c86658a825dd9af4c--b9f7976466164263ad5929aa12521a55 e00e775d7f834aa0a2dcb48e107c6850 b9f7976466164263ad5929aa12521a55--e00e775d7f834aa0a2dcb48e107c6850 b757c9543e584cc7b5c374c31ea18c95 e00e775d7f834aa0a2dcb48e107c6850--b757c9543e584cc7b5c374c31ea18c95 a8843d28e7d9448dae7435b3a72b7448 b757c9543e584cc7b5c374c31ea18c95--a8843d28e7d9448dae7435b3a72b7448 bb85676a9ca64ee092234c1c03d4e77c a8843d28e7d9448dae7435b3a72b7448--bb85676a9ca64ee092234c1c03d4e77c e591c80b18eb42978b4ecdfa18f0cdf7 bb85676a9ca64ee092234c1c03d4e77c--e591c80b18eb42978b4ecdfa18f0cdf7 d29ba9002e0449abafdb585a2acc95a4 RX(b12) e591c80b18eb42978b4ecdfa18f0cdf7--d29ba9002e0449abafdb585a2acc95a4 d29ba9002e0449abafdb585a2acc95a4--6d7e9af3618d4423bf87cafa175c21fe df64c4ce81ae4a5eae324c785c274474 7338daa537244db0b5c9704df93d909e dbd7067e18e84d30aedfb79f001b6b5a--7338daa537244db0b5c9704df93d909e 1e5345bb95d44866afe20f71f6d860f9 4 90059137be244bc89ba374e0aaba3d10 7338daa537244db0b5c9704df93d909e--90059137be244bc89ba374e0aaba3d10 2561b9a344f640e48164a482705fd0be X 90059137be244bc89ba374e0aaba3d10--2561b9a344f640e48164a482705fd0be 2561b9a344f640e48164a482705fd0be--cb510c6a615b47e78ed79d0f0e8e11ec cdf779a044414f4e8791406aaf1adf40 2561b9a344f640e48164a482705fd0be--cdf779a044414f4e8791406aaf1adf40 259725d0732341b0aaddbc157b8ca406 cdf779a044414f4e8791406aaf1adf40--259725d0732341b0aaddbc157b8ca406 6fd4b233780844d281f58d165d9a4368 259725d0732341b0aaddbc157b8ca406--6fd4b233780844d281f58d165d9a4368 3960adce807f44128edc5e4267462540 6fd4b233780844d281f58d165d9a4368--3960adce807f44128edc5e4267462540 caad5668d149468a8851283153737349 3960adce807f44128edc5e4267462540--caad5668d149468a8851283153737349 173a94b784e3405ab19dd7d5aeab4af8 caad5668d149468a8851283153737349--173a94b784e3405ab19dd7d5aeab4af8 d9e010c1813349f2928ce70f358d2544 173a94b784e3405ab19dd7d5aeab4af8--d9e010c1813349f2928ce70f358d2544 ebcd39715d824d9ebaa7b25918ee4a6c d9e010c1813349f2928ce70f358d2544--ebcd39715d824d9ebaa7b25918ee4a6c 295fe3f43b054f3c9a2d9bafff3c64aa ebcd39715d824d9ebaa7b25918ee4a6c--295fe3f43b054f3c9a2d9bafff3c64aa 4c0932a1ce2e4a56a062e898f43ce206 X 295fe3f43b054f3c9a2d9bafff3c64aa--4c0932a1ce2e4a56a062e898f43ce206 4c0932a1ce2e4a56a062e898f43ce206--954fa005f0e94315a573d3f5b451ed21 2d31c640cc1649dea7fe5aee3491bb75 4c0932a1ce2e4a56a062e898f43ce206--2d31c640cc1649dea7fe5aee3491bb75 15a2988f2d9d41a4a70cb8ae0b1b7554 2d31c640cc1649dea7fe5aee3491bb75--15a2988f2d9d41a4a70cb8ae0b1b7554 67bac26e7cd24ff381017cc02b1d970e 15a2988f2d9d41a4a70cb8ae0b1b7554--67bac26e7cd24ff381017cc02b1d970e 9467d4dee9a241a38511848ee3916151 67bac26e7cd24ff381017cc02b1d970e--9467d4dee9a241a38511848ee3916151 52004ac9dfd64d62a37afb4a3c6aa331 9467d4dee9a241a38511848ee3916151--52004ac9dfd64d62a37afb4a3c6aa331 5a0ad0a2603248fc9686e5b27ec80f40 52004ac9dfd64d62a37afb4a3c6aa331--5a0ad0a2603248fc9686e5b27ec80f40 6e576c21554041a58cab3f147c275367 5a0ad0a2603248fc9686e5b27ec80f40--6e576c21554041a58cab3f147c275367 210fb4d3572b4dd1b2540ee5c665f017 X 6e576c21554041a58cab3f147c275367--210fb4d3572b4dd1b2540ee5c665f017 210fb4d3572b4dd1b2540ee5c665f017--808eab8cc80f4558b868b7b6419ec815 7918237d77504eea816595ea1b5d19cd 210fb4d3572b4dd1b2540ee5c665f017--7918237d77504eea816595ea1b5d19cd 924d8b2d5b944a7cbacc80d82d1121af 7918237d77504eea816595ea1b5d19cd--924d8b2d5b944a7cbacc80d82d1121af aa18416f4e104a76a184cc934c7994df 924d8b2d5b944a7cbacc80d82d1121af--aa18416f4e104a76a184cc934c7994df ec691d50f4e94c8a922b8fc37d34ffc1 X aa18416f4e104a76a184cc934c7994df--ec691d50f4e94c8a922b8fc37d34ffc1 ec691d50f4e94c8a922b8fc37d34ffc1--98df35d6a0194e61afeddb3a1032c6df 47ce6a9851a34fc9afdb185de38326a9 ec691d50f4e94c8a922b8fc37d34ffc1--47ce6a9851a34fc9afdb185de38326a9 d6c02c4635674eb2b35bca61aa488ba5 47ce6a9851a34fc9afdb185de38326a9--d6c02c4635674eb2b35bca61aa488ba5 8c5697690c294e618a7532cf9c7a6ea5 d6c02c4635674eb2b35bca61aa488ba5--8c5697690c294e618a7532cf9c7a6ea5 402c33da254d44f3852d0719f27c8466 8c5697690c294e618a7532cf9c7a6ea5--402c33da254d44f3852d0719f27c8466 a997d26c09054478a1763d0f5bad82cb X 402c33da254d44f3852d0719f27c8466--a997d26c09054478a1763d0f5bad82cb a997d26c09054478a1763d0f5bad82cb--bb5909aa7af84c1596a0cdde6d2c7410 1b45e4824df44b4988b9b3077e273763 a997d26c09054478a1763d0f5bad82cb--1b45e4824df44b4988b9b3077e273763 4dedf7e02bf040619e0925f478e64e43 1b45e4824df44b4988b9b3077e273763--4dedf7e02bf040619e0925f478e64e43 4a6b833667c0412d9d791ff064d3919f 4dedf7e02bf040619e0925f478e64e43--4a6b833667c0412d9d791ff064d3919f 14171b3ff67f4c58a86afabbf44f254b 4a6b833667c0412d9d791ff064d3919f--14171b3ff67f4c58a86afabbf44f254b f2c1f86bb3e74a6db4c62bfbe4bb3575 14171b3ff67f4c58a86afabbf44f254b--f2c1f86bb3e74a6db4c62bfbe4bb3575 447495fb1dca458a8e3a5ff670b2c88b f2c1f86bb3e74a6db4c62bfbe4bb3575--447495fb1dca458a8e3a5ff670b2c88b 7aa5ce61b3be4414be566a5bb1ade563 447495fb1dca458a8e3a5ff670b2c88b--7aa5ce61b3be4414be566a5bb1ade563 6d55a78a79da49869772695b56e21b47 X 7aa5ce61b3be4414be566a5bb1ade563--6d55a78a79da49869772695b56e21b47 6d55a78a79da49869772695b56e21b47--8b9f763bb919469b9456a1797e136c07 90e22b347c9949178ae1bcec73cff5b6 6d55a78a79da49869772695b56e21b47--90e22b347c9949178ae1bcec73cff5b6 9f3c6bba1c0b470c93d9cd3f152ce59b 90e22b347c9949178ae1bcec73cff5b6--9f3c6bba1c0b470c93d9cd3f152ce59b 8f897c7590004edf921a033be7d36e47 9f3c6bba1c0b470c93d9cd3f152ce59b--8f897c7590004edf921a033be7d36e47 ef33930c11b24954a96e6eaf6dd3924d 8f897c7590004edf921a033be7d36e47--ef33930c11b24954a96e6eaf6dd3924d dfeb7b66208a4567817d23051f659399 ef33930c11b24954a96e6eaf6dd3924d--dfeb7b66208a4567817d23051f659399 2398cd611ec64e8b85631d1b9e6afe95 dfeb7b66208a4567817d23051f659399--2398cd611ec64e8b85631d1b9e6afe95 0a31f728f2704e1588c9da493d8e9841 X 2398cd611ec64e8b85631d1b9e6afe95--0a31f728f2704e1588c9da493d8e9841 0a31f728f2704e1588c9da493d8e9841--95f301967434436aaa1511c4b4719037 28d9660f4f1c498387b5a17313ea1436 RZ(-1.0*g0) 0a31f728f2704e1588c9da493d8e9841--28d9660f4f1c498387b5a17313ea1436 c01567638908494a9ca93753d8380495 X 28d9660f4f1c498387b5a17313ea1436--c01567638908494a9ca93753d8380495 c01567638908494a9ca93753d8380495--d4dc6cba54af4b4bb1aee8c0ec744f74 d9025717fc8f4779b1ae37846dff632d c01567638908494a9ca93753d8380495--d9025717fc8f4779b1ae37846dff632d 5382acd0fe324427b492d6b007d4b68c d9025717fc8f4779b1ae37846dff632d--5382acd0fe324427b492d6b007d4b68c 71a7f7f9429f4b9d9341776da6f2d424 X 5382acd0fe324427b492d6b007d4b68c--71a7f7f9429f4b9d9341776da6f2d424 71a7f7f9429f4b9d9341776da6f2d424--331ed0ec1c864673aa47836addda7655 396af02447d440ff9a3821a4f768e5a8 71a7f7f9429f4b9d9341776da6f2d424--396af02447d440ff9a3821a4f768e5a8 f0f08b59fbcd4d83b2b2656b9c77a6e3 396af02447d440ff9a3821a4f768e5a8--f0f08b59fbcd4d83b2b2656b9c77a6e3 3adb36231c3e46b9a8d30d9dbaad7eeb f0f08b59fbcd4d83b2b2656b9c77a6e3--3adb36231c3e46b9a8d30d9dbaad7eeb 6fdd731a5a874ca0b5535f2656196ed8 3adb36231c3e46b9a8d30d9dbaad7eeb--6fdd731a5a874ca0b5535f2656196ed8 26ffe34393ca4631ab56366959fabe06 6fdd731a5a874ca0b5535f2656196ed8--26ffe34393ca4631ab56366959fabe06 7052c47324b94f00a1d20e91a3c1fcd7 X 26ffe34393ca4631ab56366959fabe06--7052c47324b94f00a1d20e91a3c1fcd7 7052c47324b94f00a1d20e91a3c1fcd7--866b8f2213a3484c91550df2548d659c f96fbe3ebce84f43a24a774c7648df38 7052c47324b94f00a1d20e91a3c1fcd7--f96fbe3ebce84f43a24a774c7648df38 aeb51657ae594df1ac6f59457cd41178 f96fbe3ebce84f43a24a774c7648df38--aeb51657ae594df1ac6f59457cd41178 492cc655f7fb42a0b077bc67a6c24959 X aeb51657ae594df1ac6f59457cd41178--492cc655f7fb42a0b077bc67a6c24959 492cc655f7fb42a0b077bc67a6c24959--5565c8f93aa8485caf59be501137aa62 268c801ff08f41709d3472f646716425 492cc655f7fb42a0b077bc67a6c24959--268c801ff08f41709d3472f646716425 e7bcf3b8049d4ca1829189bed5b1c617 268c801ff08f41709d3472f646716425--e7bcf3b8049d4ca1829189bed5b1c617 52d4584748b64d608f91f31dfa6e180c e7bcf3b8049d4ca1829189bed5b1c617--52d4584748b64d608f91f31dfa6e180c 6e172c7d28cf42518a9785fed0810074 52d4584748b64d608f91f31dfa6e180c--6e172c7d28cf42518a9785fed0810074 8f6523d3e24e419fa881d5a67f6aabfe 6e172c7d28cf42518a9785fed0810074--8f6523d3e24e419fa881d5a67f6aabfe 3eea818583204c03ab44eb093268cc8a 8f6523d3e24e419fa881d5a67f6aabfe--3eea818583204c03ab44eb093268cc8a 7cf019ba4f024b2caf257f8322965549 3eea818583204c03ab44eb093268cc8a--7cf019ba4f024b2caf257f8322965549 f9a3ff8178044971acc6f234bde760a1 7cf019ba4f024b2caf257f8322965549--f9a3ff8178044971acc6f234bde760a1 2c0e86244b0c4aa49e02239a7aef962f f9a3ff8178044971acc6f234bde760a1--2c0e86244b0c4aa49e02239a7aef962f b676579804804554ab9bf16a914df1de X 2c0e86244b0c4aa49e02239a7aef962f--b676579804804554ab9bf16a914df1de b676579804804554ab9bf16a914df1de--bb1de3d5d7c94d448fd8552f98a73229 ea06a2e5f6274049a1f34fe6d864c940 b676579804804554ab9bf16a914df1de--ea06a2e5f6274049a1f34fe6d864c940 3924209c8aaf40649e9456fa3398ea92 X ea06a2e5f6274049a1f34fe6d864c940--3924209c8aaf40649e9456fa3398ea92 3924209c8aaf40649e9456fa3398ea92--5e089e5952014e8f8f24bf2eebf40706 37b82e862fca4f30b30ec1e8ba99f2d0 3924209c8aaf40649e9456fa3398ea92--37b82e862fca4f30b30ec1e8ba99f2d0 3ba95827fcb343179bbb71358e587b2c 37b82e862fca4f30b30ec1e8ba99f2d0--3ba95827fcb343179bbb71358e587b2c 1fa25f171a7c4b29980c73bca65f6698 3ba95827fcb343179bbb71358e587b2c--1fa25f171a7c4b29980c73bca65f6698 f41613ad27bf4d379290dcb0748f9f8d 1fa25f171a7c4b29980c73bca65f6698--f41613ad27bf4d379290dcb0748f9f8d cc34cdfa23f545178f07d51ea8713314 f41613ad27bf4d379290dcb0748f9f8d--cc34cdfa23f545178f07d51ea8713314 3910f4ed313e453287c2b6abf0a5fae7 X cc34cdfa23f545178f07d51ea8713314--3910f4ed313e453287c2b6abf0a5fae7 3910f4ed313e453287c2b6abf0a5fae7--ec90bc036b0a4173a0d1f89e2ed0e292 5bbe3ca988be43b7aee983d1bf22d3d6 X 3910f4ed313e453287c2b6abf0a5fae7--5bbe3ca988be43b7aee983d1bf22d3d6 5bbe3ca988be43b7aee983d1bf22d3d6--ef2c3ba36e8948bea5d17ef5f8a4233c 23d7a78cdcdc4569a09f451e828186d6 5bbe3ca988be43b7aee983d1bf22d3d6--23d7a78cdcdc4569a09f451e828186d6 fac3114dbf9f4850a8ec35366b92bbda 23d7a78cdcdc4569a09f451e828186d6--fac3114dbf9f4850a8ec35366b92bbda c859d3eb8ae2499da20e17fe13a02a4b fac3114dbf9f4850a8ec35366b92bbda--c859d3eb8ae2499da20e17fe13a02a4b 5be78aa91736466db2d5d8deea564545 c859d3eb8ae2499da20e17fe13a02a4b--5be78aa91736466db2d5d8deea564545 c69c4e8a6911462aaa8cd056a23b65bd 5be78aa91736466db2d5d8deea564545--c69c4e8a6911462aaa8cd056a23b65bd 2dc9f65e0e0949dfb3cb563481ec7f69 c69c4e8a6911462aaa8cd056a23b65bd--2dc9f65e0e0949dfb3cb563481ec7f69 5c99d29b041946d1a984332a654ddef2 2dc9f65e0e0949dfb3cb563481ec7f69--5c99d29b041946d1a984332a654ddef2 5a3fe2e315ae47b1b733f61a48346754 X 5c99d29b041946d1a984332a654ddef2--5a3fe2e315ae47b1b733f61a48346754 5a3fe2e315ae47b1b733f61a48346754--31ce5b1acbb247a08de0339a6b8d47f0 0ab38a0b7e144587b42caa9432a37e89 5a3fe2e315ae47b1b733f61a48346754--0ab38a0b7e144587b42caa9432a37e89 f90c746203184553b98ceec3d46abe82 0ab38a0b7e144587b42caa9432a37e89--f90c746203184553b98ceec3d46abe82 8160d4b19d7a45509f0f55f39f6c3024 f90c746203184553b98ceec3d46abe82--8160d4b19d7a45509f0f55f39f6c3024 1803608fcc364b328559e997a31d99c1 8160d4b19d7a45509f0f55f39f6c3024--1803608fcc364b328559e997a31d99c1 1c2b719d872d45c88439ea756bfbcb1e 1803608fcc364b328559e997a31d99c1--1c2b719d872d45c88439ea756bfbcb1e 39475ba42dd541bb88c8cbc6983b1dd2 1c2b719d872d45c88439ea756bfbcb1e--39475ba42dd541bb88c8cbc6983b1dd2 1f9c4620bcb8478fb0503105a53fda33 39475ba42dd541bb88c8cbc6983b1dd2--1f9c4620bcb8478fb0503105a53fda33 9560aaead38548a5b038280efb5b97f7 1f9c4620bcb8478fb0503105a53fda33--9560aaead38548a5b038280efb5b97f7 74f3673bdceb45b39a7e22915b2c6b32 9560aaead38548a5b038280efb5b97f7--74f3673bdceb45b39a7e22915b2c6b32 71abb1751aea477c8337218d42cfcff6 74f3673bdceb45b39a7e22915b2c6b32--71abb1751aea477c8337218d42cfcff6 43d1e7d3f16b48f694ce0bd4f8ebf868 71abb1751aea477c8337218d42cfcff6--43d1e7d3f16b48f694ce0bd4f8ebf868 62a18c3595c14e50a611011cf7a38063 43d1e7d3f16b48f694ce0bd4f8ebf868--62a18c3595c14e50a611011cf7a38063 52b45d6cccec4778b5f753506ea63f09 62a18c3595c14e50a611011cf7a38063--52b45d6cccec4778b5f753506ea63f09 f4cbc19c21c24728ba2a6611466244b0 52b45d6cccec4778b5f753506ea63f09--f4cbc19c21c24728ba2a6611466244b0 2cdd52c701a443c5b01f28c10194c4b2 f4cbc19c21c24728ba2a6611466244b0--2cdd52c701a443c5b01f28c10194c4b2 3b967d5f8ae642afb334b445473bdc36 2cdd52c701a443c5b01f28c10194c4b2--3b967d5f8ae642afb334b445473bdc36 b67b10615cd344f99e372ca26b1cffcd 3b967d5f8ae642afb334b445473bdc36--b67b10615cd344f99e372ca26b1cffcd e3a54d394da5474cb7f61eecff2d69c3 b67b10615cd344f99e372ca26b1cffcd--e3a54d394da5474cb7f61eecff2d69c3 0ee2d635c9964bd29d8367266451a0ab e3a54d394da5474cb7f61eecff2d69c3--0ee2d635c9964bd29d8367266451a0ab 0d1028a3a6414601a0a01aed4d18a9c3 0ee2d635c9964bd29d8367266451a0ab--0d1028a3a6414601a0a01aed4d18a9c3 d2d94b05327043a69dfe3db4a1a7ae73 0d1028a3a6414601a0a01aed4d18a9c3--d2d94b05327043a69dfe3db4a1a7ae73 5d8d383d5c3b4f2488aca1c525635dc7 d2d94b05327043a69dfe3db4a1a7ae73--5d8d383d5c3b4f2488aca1c525635dc7 ab33aa71daed4da896bc7006ed5ecb4c 5d8d383d5c3b4f2488aca1c525635dc7--ab33aa71daed4da896bc7006ed5ecb4c 55dfcbce8b07493589e8e6572de9bbfa RX(b03) ab33aa71daed4da896bc7006ed5ecb4c--55dfcbce8b07493589e8e6572de9bbfa 38fccd75ece74215804a22e637251114 55dfcbce8b07493589e8e6572de9bbfa--38fccd75ece74215804a22e637251114 6698ae0d6d364e85ab08bcd1650f59f2 38fccd75ece74215804a22e637251114--6698ae0d6d364e85ab08bcd1650f59f2 093abf262a74403c9a21acfab379fa1b X 6698ae0d6d364e85ab08bcd1650f59f2--093abf262a74403c9a21acfab379fa1b 093abf262a74403c9a21acfab379fa1b--5e0786d6a7174ce384d65b34b07aaa04 d33a68eb08564cd585ffd51b13ad2b00 093abf262a74403c9a21acfab379fa1b--d33a68eb08564cd585ffd51b13ad2b00 cc42f61ff55b494ca9ee195b4d00569d d33a68eb08564cd585ffd51b13ad2b00--cc42f61ff55b494ca9ee195b4d00569d 68ec6b1c30e54c9389c1db1af05e050d cc42f61ff55b494ca9ee195b4d00569d--68ec6b1c30e54c9389c1db1af05e050d e2b62b1d15eb447a922404821c929998 68ec6b1c30e54c9389c1db1af05e050d--e2b62b1d15eb447a922404821c929998 5b369dd4319f4921abc1ab5d1e0a56f8 e2b62b1d15eb447a922404821c929998--5b369dd4319f4921abc1ab5d1e0a56f8 de21ec8095eb47ad8a0d999db6a9fd66 5b369dd4319f4921abc1ab5d1e0a56f8--de21ec8095eb47ad8a0d999db6a9fd66 2caeb4a4f8b74b03abd91f8da06dc0fd de21ec8095eb47ad8a0d999db6a9fd66--2caeb4a4f8b74b03abd91f8da06dc0fd 11432e87efc24c41bd6cb5c31eff9d12 2caeb4a4f8b74b03abd91f8da06dc0fd--11432e87efc24c41bd6cb5c31eff9d12 d73258c7f651483293a357f0b95ea508 11432e87efc24c41bd6cb5c31eff9d12--d73258c7f651483293a357f0b95ea508 ea2233e450d645a2bd69247564d5cdba X d73258c7f651483293a357f0b95ea508--ea2233e450d645a2bd69247564d5cdba ea2233e450d645a2bd69247564d5cdba--6583765c51704ed0b5f57412f19205a8 36fda7df3370488891c786d2297f29a3 ea2233e450d645a2bd69247564d5cdba--36fda7df3370488891c786d2297f29a3 4e8ec9173e3549acbf5e9293894b1893 36fda7df3370488891c786d2297f29a3--4e8ec9173e3549acbf5e9293894b1893 cee40c61d48849808cad899269b914c2 4e8ec9173e3549acbf5e9293894b1893--cee40c61d48849808cad899269b914c2 3482f57a7fa94a58bfdaed2eef8ed9d7 cee40c61d48849808cad899269b914c2--3482f57a7fa94a58bfdaed2eef8ed9d7 ac1ba5862a31498d86a556de22856b9a 3482f57a7fa94a58bfdaed2eef8ed9d7--ac1ba5862a31498d86a556de22856b9a 164b0f7e838d4088883e59212406f3d1 ac1ba5862a31498d86a556de22856b9a--164b0f7e838d4088883e59212406f3d1 1d799718117c4555b99f755137823ffd 164b0f7e838d4088883e59212406f3d1--1d799718117c4555b99f755137823ffd 1397c3d7830c4365ad84ca0184925d90 X 1d799718117c4555b99f755137823ffd--1397c3d7830c4365ad84ca0184925d90 1397c3d7830c4365ad84ca0184925d90--ce86b8b0e79a475db7ef4a24c71568c9 d88385511e104f83b29011d4ace9633d 1397c3d7830c4365ad84ca0184925d90--d88385511e104f83b29011d4ace9633d 5460d35ef8894ac7b792b22b0ce3c4c0 d88385511e104f83b29011d4ace9633d--5460d35ef8894ac7b792b22b0ce3c4c0 4191ed3e46da4300b2a9bcf77fddc5ea 5460d35ef8894ac7b792b22b0ce3c4c0--4191ed3e46da4300b2a9bcf77fddc5ea 1db5ae5e3a3f42e6a1d4b057ca78c8c7 X 4191ed3e46da4300b2a9bcf77fddc5ea--1db5ae5e3a3f42e6a1d4b057ca78c8c7 1db5ae5e3a3f42e6a1d4b057ca78c8c7--0c4f53ed8cb44e6a9874bf1436d74e95 cbd724c9fa37409b89db91e2831cfbac 1db5ae5e3a3f42e6a1d4b057ca78c8c7--cbd724c9fa37409b89db91e2831cfbac b2792d10b5a54d86a42850a624e33540 cbd724c9fa37409b89db91e2831cfbac--b2792d10b5a54d86a42850a624e33540 58cb854c8dd44991b61aa2ccab011c17 b2792d10b5a54d86a42850a624e33540--58cb854c8dd44991b61aa2ccab011c17 17c25b54bbf6495eaee9c6ad235f6f99 58cb854c8dd44991b61aa2ccab011c17--17c25b54bbf6495eaee9c6ad235f6f99 719ae30859bf43428970fb90e82b5446 X 17c25b54bbf6495eaee9c6ad235f6f99--719ae30859bf43428970fb90e82b5446 719ae30859bf43428970fb90e82b5446--c553917eb14c4209a15000b5cc98e76e 0c5e4b6ba60c498d987d36bee7a3af3c 719ae30859bf43428970fb90e82b5446--0c5e4b6ba60c498d987d36bee7a3af3c 2e5a3e982d1a4c3da116d7a4d3d7d650 0c5e4b6ba60c498d987d36bee7a3af3c--2e5a3e982d1a4c3da116d7a4d3d7d650 c6664df5b3484b5c99c5045fae960308 2e5a3e982d1a4c3da116d7a4d3d7d650--c6664df5b3484b5c99c5045fae960308 af75597200a64b6b8711d2a3668c25dd c6664df5b3484b5c99c5045fae960308--af75597200a64b6b8711d2a3668c25dd 2f845baa10db47849bd24ceff4b0f0f1 af75597200a64b6b8711d2a3668c25dd--2f845baa10db47849bd24ceff4b0f0f1 d9ed5eb9ef514aa1bc1ffe775b165a7a 2f845baa10db47849bd24ceff4b0f0f1--d9ed5eb9ef514aa1bc1ffe775b165a7a d314db85630d44ee993700a7195544a0 d9ed5eb9ef514aa1bc1ffe775b165a7a--d314db85630d44ee993700a7195544a0 b19978c772c24fe489e635921fb16c7f X d314db85630d44ee993700a7195544a0--b19978c772c24fe489e635921fb16c7f b19978c772c24fe489e635921fb16c7f--500b4d3eb2a14cec8bbe24a31db0302c b0159d84f1c844cd9df10370cd1c90e0 b19978c772c24fe489e635921fb16c7f--b0159d84f1c844cd9df10370cd1c90e0 9c322428d3574202963a5961d01afb79 b0159d84f1c844cd9df10370cd1c90e0--9c322428d3574202963a5961d01afb79 935e555f5b524b4899692a0a97172e8a 9c322428d3574202963a5961d01afb79--935e555f5b524b4899692a0a97172e8a 4f32215770444e8e83b7908021bbf226 935e555f5b524b4899692a0a97172e8a--4f32215770444e8e83b7908021bbf226 7c49dcc1771342f5bc70c6f328ca9e94 4f32215770444e8e83b7908021bbf226--7c49dcc1771342f5bc70c6f328ca9e94 a0ed2bf28e5040bb86ba2351c11cf582 7c49dcc1771342f5bc70c6f328ca9e94--a0ed2bf28e5040bb86ba2351c11cf582 219785fffe1945c98ad71d14f6cbc400 X a0ed2bf28e5040bb86ba2351c11cf582--219785fffe1945c98ad71d14f6cbc400 219785fffe1945c98ad71d14f6cbc400--757e04b11cee4dea977ba6e9284b0105 7352c00759a846fc8de5995bc8f53a1d RZ(-1.0*g1) 219785fffe1945c98ad71d14f6cbc400--7352c00759a846fc8de5995bc8f53a1d 52093aff9dd44030b6fe2c2c2079ebe3 X 7352c00759a846fc8de5995bc8f53a1d--52093aff9dd44030b6fe2c2c2079ebe3 52093aff9dd44030b6fe2c2c2079ebe3--323d4587c26648529aa30645eaad3a21 587ae188dfed4978b55bbbc35cf38f39 52093aff9dd44030b6fe2c2c2079ebe3--587ae188dfed4978b55bbbc35cf38f39 a2747f2b3ee5409296d452fe050ef2e2 587ae188dfed4978b55bbbc35cf38f39--a2747f2b3ee5409296d452fe050ef2e2 cc755a02cc504c28aa0ee9db78897ea6 X a2747f2b3ee5409296d452fe050ef2e2--cc755a02cc504c28aa0ee9db78897ea6 cc755a02cc504c28aa0ee9db78897ea6--019e257e765d434b89f9316c5fc64a34 7a6eb7bb16d2421a8ad66bc62a9e9591 cc755a02cc504c28aa0ee9db78897ea6--7a6eb7bb16d2421a8ad66bc62a9e9591 3639cae2e5df46bbb173f7dc26e2ca28 7a6eb7bb16d2421a8ad66bc62a9e9591--3639cae2e5df46bbb173f7dc26e2ca28 eaae76b16fdc42cdb9956b91cf27c998 3639cae2e5df46bbb173f7dc26e2ca28--eaae76b16fdc42cdb9956b91cf27c998 a32ce6c4621d4fcf9d3721076013e002 eaae76b16fdc42cdb9956b91cf27c998--a32ce6c4621d4fcf9d3721076013e002 050df10e572d4e3881797a4a351e0454 a32ce6c4621d4fcf9d3721076013e002--050df10e572d4e3881797a4a351e0454 a83e5e08fba743f69b5882bbf737f676 X 050df10e572d4e3881797a4a351e0454--a83e5e08fba743f69b5882bbf737f676 a83e5e08fba743f69b5882bbf737f676--e4a11c8675f240d19f51e2cae408c76f ab1eabf81bad48dd898e2afbcaab8642 a83e5e08fba743f69b5882bbf737f676--ab1eabf81bad48dd898e2afbcaab8642 e5d07353f29947c4a21dff8dfe606284 ab1eabf81bad48dd898e2afbcaab8642--e5d07353f29947c4a21dff8dfe606284 be4998daac124dbd974a3bf73e2dec3d X e5d07353f29947c4a21dff8dfe606284--be4998daac124dbd974a3bf73e2dec3d be4998daac124dbd974a3bf73e2dec3d--6c918f8dbf3d422ea471f1839b9f7dac 2d5921f740b1431990b29be32666bba3 be4998daac124dbd974a3bf73e2dec3d--2d5921f740b1431990b29be32666bba3 6bcdfc7036ed4703899c5fd47ed4faf3 2d5921f740b1431990b29be32666bba3--6bcdfc7036ed4703899c5fd47ed4faf3 2589154b9c504a038c93bca694459e39 6bcdfc7036ed4703899c5fd47ed4faf3--2589154b9c504a038c93bca694459e39 b6a72d05fc5d4ecb9d58bfbd7c68e906 2589154b9c504a038c93bca694459e39--b6a72d05fc5d4ecb9d58bfbd7c68e906 9145710d6e51473b94b4f9be8d6148aa b6a72d05fc5d4ecb9d58bfbd7c68e906--9145710d6e51473b94b4f9be8d6148aa 98af5dbe0f7f4197ab6d76d5ba55a081 9145710d6e51473b94b4f9be8d6148aa--98af5dbe0f7f4197ab6d76d5ba55a081 1fc6218553094bc29146a98d5c43376e 98af5dbe0f7f4197ab6d76d5ba55a081--1fc6218553094bc29146a98d5c43376e d5a7dc230ef641a798f67693c26470a3 1fc6218553094bc29146a98d5c43376e--d5a7dc230ef641a798f67693c26470a3 ec6b6db6d0c74b04b14c36974aee8770 d5a7dc230ef641a798f67693c26470a3--ec6b6db6d0c74b04b14c36974aee8770 1aafab0018d04ba685022ccdc83f6425 X ec6b6db6d0c74b04b14c36974aee8770--1aafab0018d04ba685022ccdc83f6425 1aafab0018d04ba685022ccdc83f6425--c950395755ee4568a43af6689c9cb1c9 5a56686b47d14b6e8182aebe8ab546bc 1aafab0018d04ba685022ccdc83f6425--5a56686b47d14b6e8182aebe8ab546bc 1f8d9c61fcea4b64a1cc1e927eb8393c X 5a56686b47d14b6e8182aebe8ab546bc--1f8d9c61fcea4b64a1cc1e927eb8393c 1f8d9c61fcea4b64a1cc1e927eb8393c--c35127650b9043dfbf2b467ea71c471e d5fb1c3439304692a0bb66ea3c28a65c 1f8d9c61fcea4b64a1cc1e927eb8393c--d5fb1c3439304692a0bb66ea3c28a65c 9cf0efd937ff48d8b86f9e7c0f4c4262 d5fb1c3439304692a0bb66ea3c28a65c--9cf0efd937ff48d8b86f9e7c0f4c4262 2e77d0f5ae6a4b67b1b362cc20a58604 9cf0efd937ff48d8b86f9e7c0f4c4262--2e77d0f5ae6a4b67b1b362cc20a58604 424561a55e0247089ac3f06fc79f3cb7 2e77d0f5ae6a4b67b1b362cc20a58604--424561a55e0247089ac3f06fc79f3cb7 12f7d64558e34ba2b810ee9ff3193fb9 424561a55e0247089ac3f06fc79f3cb7--12f7d64558e34ba2b810ee9ff3193fb9 ca7943bde08c465e82096bb63661329c X 12f7d64558e34ba2b810ee9ff3193fb9--ca7943bde08c465e82096bb63661329c ca7943bde08c465e82096bb63661329c--75e075646f4f46ca9e2601a4ad696fd9 9c4766ca010540f59ca1ddc80dd30ddd X ca7943bde08c465e82096bb63661329c--9c4766ca010540f59ca1ddc80dd30ddd 9c4766ca010540f59ca1ddc80dd30ddd--11d206c248104cd09d6a7d981d7f7d50 69774bc0aa1c425e8be9589cd9260376 9c4766ca010540f59ca1ddc80dd30ddd--69774bc0aa1c425e8be9589cd9260376 0b31104c5a7c467d9fef9fc9a3abb8c4 69774bc0aa1c425e8be9589cd9260376--0b31104c5a7c467d9fef9fc9a3abb8c4 c722ec3e149a45dd871d676753706c26 0b31104c5a7c467d9fef9fc9a3abb8c4--c722ec3e149a45dd871d676753706c26 f8b8126512864baa9f8d8ad982da21c8 c722ec3e149a45dd871d676753706c26--f8b8126512864baa9f8d8ad982da21c8 546cd415fcee4df3bbf1985567a8525e f8b8126512864baa9f8d8ad982da21c8--546cd415fcee4df3bbf1985567a8525e 407f602f9b5a4fa1ae8b5842de9e7d26 546cd415fcee4df3bbf1985567a8525e--407f602f9b5a4fa1ae8b5842de9e7d26 508d883ae7144af49092ccbce86d8623 407f602f9b5a4fa1ae8b5842de9e7d26--508d883ae7144af49092ccbce86d8623 0fb071da8ae44ca3acdd27605f170ff4 X 508d883ae7144af49092ccbce86d8623--0fb071da8ae44ca3acdd27605f170ff4 0fb071da8ae44ca3acdd27605f170ff4--b4fa2bfd60044939970508c2a974ad67 d03566aac0e4430c98bbdb85eb43d72d 0fb071da8ae44ca3acdd27605f170ff4--d03566aac0e4430c98bbdb85eb43d72d 4165ca7e2659432b926381787c680f01 d03566aac0e4430c98bbdb85eb43d72d--4165ca7e2659432b926381787c680f01 958fc0fb0ce44770989eff1acbe7d77e 4165ca7e2659432b926381787c680f01--958fc0fb0ce44770989eff1acbe7d77e b07707d817204e30857ccb86a5ecee2d 958fc0fb0ce44770989eff1acbe7d77e--b07707d817204e30857ccb86a5ecee2d eac5a92208774929b86d19fc85dd84c7 b07707d817204e30857ccb86a5ecee2d--eac5a92208774929b86d19fc85dd84c7 3f47b7c5d3ff475ab1d510366a05cb06 eac5a92208774929b86d19fc85dd84c7--3f47b7c5d3ff475ab1d510366a05cb06 45096ed70ee140d6938c222ce49e67e6 3f47b7c5d3ff475ab1d510366a05cb06--45096ed70ee140d6938c222ce49e67e6 2d54e756553a41be8b919fc9820edc32 45096ed70ee140d6938c222ce49e67e6--2d54e756553a41be8b919fc9820edc32 a3cab5ba1570419488d617257a3e927f 2d54e756553a41be8b919fc9820edc32--a3cab5ba1570419488d617257a3e927f ae82fe5444b84d6ea0687cbcec7cb51e a3cab5ba1570419488d617257a3e927f--ae82fe5444b84d6ea0687cbcec7cb51e 2b3eaa73cb7a49ad86e783f2a874ffd3 ae82fe5444b84d6ea0687cbcec7cb51e--2b3eaa73cb7a49ad86e783f2a874ffd3 c0c348c7629b4990afe1f71049e5254e 2b3eaa73cb7a49ad86e783f2a874ffd3--c0c348c7629b4990afe1f71049e5254e ba83b78fb1cf4289b137f4ee68ce6e37 c0c348c7629b4990afe1f71049e5254e--ba83b78fb1cf4289b137f4ee68ce6e37 b707ede6d4ac4b08878a6d02ffb7521e ba83b78fb1cf4289b137f4ee68ce6e37--b707ede6d4ac4b08878a6d02ffb7521e c143950313c547009660801244115849 b707ede6d4ac4b08878a6d02ffb7521e--c143950313c547009660801244115849 ef16e98a4712442e9cfaf907786da80e c143950313c547009660801244115849--ef16e98a4712442e9cfaf907786da80e 1c1a2f4434594a3788fc576b30802e74 ef16e98a4712442e9cfaf907786da80e--1c1a2f4434594a3788fc576b30802e74 c792270c2892468c90d0ae5d4b89c240 1c1a2f4434594a3788fc576b30802e74--c792270c2892468c90d0ae5d4b89c240 720a1030a2e141c68601f0f5c6374694 c792270c2892468c90d0ae5d4b89c240--720a1030a2e141c68601f0f5c6374694 d905ba0bff3e4b36b45e3240b659e503 720a1030a2e141c68601f0f5c6374694--d905ba0bff3e4b36b45e3240b659e503 5f79834c81244656a2b21687d2d038c3 d905ba0bff3e4b36b45e3240b659e503--5f79834c81244656a2b21687d2d038c3 e187cccf9d4442718362d0eece7c5725 5f79834c81244656a2b21687d2d038c3--e187cccf9d4442718362d0eece7c5725 89a6dee375204847b8b5eb08e9a1efdb e187cccf9d4442718362d0eece7c5725--89a6dee375204847b8b5eb08e9a1efdb 74220efbca624982b59b23759dd5be42 RX(b13) 89a6dee375204847b8b5eb08e9a1efdb--74220efbca624982b59b23759dd5be42 74220efbca624982b59b23759dd5be42--df64c4ce81ae4a5eae324c785c274474 ec3c3aebd73b4589a81f2dcfbfe969ed dad58529cb954d498f5cbc3a05f77c48 1e5345bb95d44866afe20f71f6d860f9--dad58529cb954d498f5cbc3a05f77c48 761b8a10d46544f1a668ba158da1f358 5 102b7b78996644aa825d444b9a5dafa1 dad58529cb954d498f5cbc3a05f77c48--102b7b78996644aa825d444b9a5dafa1 77a5d115b1ac4fc4a37e343564a5c139 102b7b78996644aa825d444b9a5dafa1--77a5d115b1ac4fc4a37e343564a5c139 212b8e912bd54c269b1295ef6ca7c9aa X 77a5d115b1ac4fc4a37e343564a5c139--212b8e912bd54c269b1295ef6ca7c9aa 212b8e912bd54c269b1295ef6ca7c9aa--cdf779a044414f4e8791406aaf1adf40 38b38c2054124c90b9e6ec64e5f5bb09 212b8e912bd54c269b1295ef6ca7c9aa--38b38c2054124c90b9e6ec64e5f5bb09 d37b388a5a0e47eeaa8ce2d6d4c580b4 38b38c2054124c90b9e6ec64e5f5bb09--d37b388a5a0e47eeaa8ce2d6d4c580b4 1d17249e998a4f95ac99f95cdcd1a435 d37b388a5a0e47eeaa8ce2d6d4c580b4--1d17249e998a4f95ac99f95cdcd1a435 a137d1a2646943eebda78f5e7ea19ff4 1d17249e998a4f95ac99f95cdcd1a435--a137d1a2646943eebda78f5e7ea19ff4 f34faafbb79a4be6b4821754b91ff32f a137d1a2646943eebda78f5e7ea19ff4--f34faafbb79a4be6b4821754b91ff32f 44db31e92e904dcbb9a58fa2c630c4df f34faafbb79a4be6b4821754b91ff32f--44db31e92e904dcbb9a58fa2c630c4df 08263e9ad1c940c4975df2015e46d911 44db31e92e904dcbb9a58fa2c630c4df--08263e9ad1c940c4975df2015e46d911 e501fc5c856548608f426166653c3c66 X 08263e9ad1c940c4975df2015e46d911--e501fc5c856548608f426166653c3c66 e501fc5c856548608f426166653c3c66--295fe3f43b054f3c9a2d9bafff3c64aa 1a87cab1eb7340aea5e1faad337542da e501fc5c856548608f426166653c3c66--1a87cab1eb7340aea5e1faad337542da db0387a96bf34434bd71aacf7c805c5e 1a87cab1eb7340aea5e1faad337542da--db0387a96bf34434bd71aacf7c805c5e 077a7cb8c63647c0b751ed519b696e98 db0387a96bf34434bd71aacf7c805c5e--077a7cb8c63647c0b751ed519b696e98 94cdefdccefa4c079d2a5ef7fd9a57f9 077a7cb8c63647c0b751ed519b696e98--94cdefdccefa4c079d2a5ef7fd9a57f9 d0379bf478784418b2b1cdb8cc148360 94cdefdccefa4c079d2a5ef7fd9a57f9--d0379bf478784418b2b1cdb8cc148360 b387b64d59e8490f86e3af017bec70b7 d0379bf478784418b2b1cdb8cc148360--b387b64d59e8490f86e3af017bec70b7 ec8fc1b347d1423da48903412c46d51b b387b64d59e8490f86e3af017bec70b7--ec8fc1b347d1423da48903412c46d51b b48e01fc04244a8f83ed69c63b4a9c7d ec8fc1b347d1423da48903412c46d51b--b48e01fc04244a8f83ed69c63b4a9c7d 8f952dcc4cc34b3aba2f0767a6326a2a b48e01fc04244a8f83ed69c63b4a9c7d--8f952dcc4cc34b3aba2f0767a6326a2a 851e9bc6e52d4d2aa826f06d831414be X 8f952dcc4cc34b3aba2f0767a6326a2a--851e9bc6e52d4d2aa826f06d831414be 851e9bc6e52d4d2aa826f06d831414be--7918237d77504eea816595ea1b5d19cd 9bf93d64636545f695a0ade392c27add RZ(-1.0*g0) 851e9bc6e52d4d2aa826f06d831414be--9bf93d64636545f695a0ade392c27add 8d7a9ebe6b614fb6b6dd5d9bfd71a52a X 9bf93d64636545f695a0ade392c27add--8d7a9ebe6b614fb6b6dd5d9bfd71a52a 8d7a9ebe6b614fb6b6dd5d9bfd71a52a--aa18416f4e104a76a184cc934c7994df b91134615cce4a808d1c24e77649eba3 8d7a9ebe6b614fb6b6dd5d9bfd71a52a--b91134615cce4a808d1c24e77649eba3 00e1537a0f974bf88b35a3fd9cab4fd7 b91134615cce4a808d1c24e77649eba3--00e1537a0f974bf88b35a3fd9cab4fd7 72ebeb4f0f374179ac0d7088545f8176 00e1537a0f974bf88b35a3fd9cab4fd7--72ebeb4f0f374179ac0d7088545f8176 0c8bb8bae8c743c4b00b59285e7573fb 72ebeb4f0f374179ac0d7088545f8176--0c8bb8bae8c743c4b00b59285e7573fb 83c9102db2d34598b0d953bbe14d0210 0c8bb8bae8c743c4b00b59285e7573fb--83c9102db2d34598b0d953bbe14d0210 33fb64a8824f45679f668729416f3786 83c9102db2d34598b0d953bbe14d0210--33fb64a8824f45679f668729416f3786 cc375e324deb43c6ae9daeb34040933f X 33fb64a8824f45679f668729416f3786--cc375e324deb43c6ae9daeb34040933f cc375e324deb43c6ae9daeb34040933f--1b45e4824df44b4988b9b3077e273763 35f656ed637542bbb205d47500af7ee8 cc375e324deb43c6ae9daeb34040933f--35f656ed637542bbb205d47500af7ee8 5449f392643742fe9eb64217f06ad851 35f656ed637542bbb205d47500af7ee8--5449f392643742fe9eb64217f06ad851 7871deddbdfb43909b578299a7d01297 5449f392643742fe9eb64217f06ad851--7871deddbdfb43909b578299a7d01297 ea8460081e78437eb20c89c52d3255f2 7871deddbdfb43909b578299a7d01297--ea8460081e78437eb20c89c52d3255f2 44b0bbf54b344ec7af281dfa47d5c0ee ea8460081e78437eb20c89c52d3255f2--44b0bbf54b344ec7af281dfa47d5c0ee cf1579085984417eb77c5aa9b0327d3b X 44b0bbf54b344ec7af281dfa47d5c0ee--cf1579085984417eb77c5aa9b0327d3b cf1579085984417eb77c5aa9b0327d3b--7aa5ce61b3be4414be566a5bb1ade563 6043cc8bab68456a916923dd40d7239b cf1579085984417eb77c5aa9b0327d3b--6043cc8bab68456a916923dd40d7239b c76177c8e63543c6ac704b469701bab0 6043cc8bab68456a916923dd40d7239b--c76177c8e63543c6ac704b469701bab0 5c235512fa974fdb99f54043d9a9e612 c76177c8e63543c6ac704b469701bab0--5c235512fa974fdb99f54043d9a9e612 c2a1e40e591046d4ab5428b0803b5036 5c235512fa974fdb99f54043d9a9e612--c2a1e40e591046d4ab5428b0803b5036 6e0b2f0a682f4b5abe19c19302ff4172 c2a1e40e591046d4ab5428b0803b5036--6e0b2f0a682f4b5abe19c19302ff4172 badaaa86b07046aab4aafba497665445 6e0b2f0a682f4b5abe19c19302ff4172--badaaa86b07046aab4aafba497665445 afad071c53bc4799a87d25acba063e82 badaaa86b07046aab4aafba497665445--afad071c53bc4799a87d25acba063e82 a17d7a488d50416f8092b6a58c6afebe afad071c53bc4799a87d25acba063e82--a17d7a488d50416f8092b6a58c6afebe 352163ed9b224406a6070a8208000450 a17d7a488d50416f8092b6a58c6afebe--352163ed9b224406a6070a8208000450 e66c3885c7ee4bb781b29ce1e01f85cf 352163ed9b224406a6070a8208000450--e66c3885c7ee4bb781b29ce1e01f85cf 92cb77e45f844a87ba3e583448fca0bd e66c3885c7ee4bb781b29ce1e01f85cf--92cb77e45f844a87ba3e583448fca0bd 19c469dbbde74c6e836664ce3c5705fb 92cb77e45f844a87ba3e583448fca0bd--19c469dbbde74c6e836664ce3c5705fb b9c2ac3134b4478f9225f2cbf30f7920 19c469dbbde74c6e836664ce3c5705fb--b9c2ac3134b4478f9225f2cbf30f7920 f5f81e180e52426e85b99c8536bcfcc6 X b9c2ac3134b4478f9225f2cbf30f7920--f5f81e180e52426e85b99c8536bcfcc6 f5f81e180e52426e85b99c8536bcfcc6--396af02447d440ff9a3821a4f768e5a8 eb23f79c8622465b955b1bd1a9e7b433 f5f81e180e52426e85b99c8536bcfcc6--eb23f79c8622465b955b1bd1a9e7b433 e321203c178f4d11b1934bca5067cb47 eb23f79c8622465b955b1bd1a9e7b433--e321203c178f4d11b1934bca5067cb47 48cfd2c55f6c4bfe932b392b3b17be6a e321203c178f4d11b1934bca5067cb47--48cfd2c55f6c4bfe932b392b3b17be6a e309a5b2026a46b086952846d5692b4c X 48cfd2c55f6c4bfe932b392b3b17be6a--e309a5b2026a46b086952846d5692b4c e309a5b2026a46b086952846d5692b4c--26ffe34393ca4631ab56366959fabe06 261587bea07148fea3861c831949e1b3 e309a5b2026a46b086952846d5692b4c--261587bea07148fea3861c831949e1b3 b60f95a6fd6a42d1a3d0604e4a413bb8 261587bea07148fea3861c831949e1b3--b60f95a6fd6a42d1a3d0604e4a413bb8 08287ae528514cf4905e88da17183783 b60f95a6fd6a42d1a3d0604e4a413bb8--08287ae528514cf4905e88da17183783 8b60b2bff4cc4201ae86a08a7b1c652f 08287ae528514cf4905e88da17183783--8b60b2bff4cc4201ae86a08a7b1c652f e18527203db54722b01bf9a913326254 X 8b60b2bff4cc4201ae86a08a7b1c652f--e18527203db54722b01bf9a913326254 e18527203db54722b01bf9a913326254--268c801ff08f41709d3472f646716425 86d59ee411f84cb7b1d17454f62f2f1f e18527203db54722b01bf9a913326254--86d59ee411f84cb7b1d17454f62f2f1f b9da786dc73c42b492d08d1d43dc52c2 86d59ee411f84cb7b1d17454f62f2f1f--b9da786dc73c42b492d08d1d43dc52c2 81ac2b364abe40afbe4e52b4ab32d911 b9da786dc73c42b492d08d1d43dc52c2--81ac2b364abe40afbe4e52b4ab32d911 2487bf45a9714f62acee85767d8aac59 81ac2b364abe40afbe4e52b4ab32d911--2487bf45a9714f62acee85767d8aac59 db5c448807fa420cbce837418925bea9 2487bf45a9714f62acee85767d8aac59--db5c448807fa420cbce837418925bea9 339fdd7efbb3447e89b0b2b1457d71e2 db5c448807fa420cbce837418925bea9--339fdd7efbb3447e89b0b2b1457d71e2 d17ac1894b164225b9da52339c7e1841 339fdd7efbb3447e89b0b2b1457d71e2--d17ac1894b164225b9da52339c7e1841 d7c5f6b1c2d5489eafbfeb8afc3ea91e X d17ac1894b164225b9da52339c7e1841--d7c5f6b1c2d5489eafbfeb8afc3ea91e d7c5f6b1c2d5489eafbfeb8afc3ea91e--2c0e86244b0c4aa49e02239a7aef962f 63cf845fbd3949658339250d79b4086c d7c5f6b1c2d5489eafbfeb8afc3ea91e--63cf845fbd3949658339250d79b4086c 60c55b9448534f0f9104459db5bba079 63cf845fbd3949658339250d79b4086c--60c55b9448534f0f9104459db5bba079 7ee3817b465e4c8e8bb34b9a9464acf8 60c55b9448534f0f9104459db5bba079--7ee3817b465e4c8e8bb34b9a9464acf8 4fc4a1ed01af4ef2bc5af2418cf5a5d9 X 7ee3817b465e4c8e8bb34b9a9464acf8--4fc4a1ed01af4ef2bc5af2418cf5a5d9 4fc4a1ed01af4ef2bc5af2418cf5a5d9--37b82e862fca4f30b30ec1e8ba99f2d0 a66adf884bd14514bfa17142472e440c 4fc4a1ed01af4ef2bc5af2418cf5a5d9--a66adf884bd14514bfa17142472e440c ecb9eb1bdf0b44d4a3df18da7e29ca09 a66adf884bd14514bfa17142472e440c--ecb9eb1bdf0b44d4a3df18da7e29ca09 777f95f4f8fa4911877192d2a27a30ef ecb9eb1bdf0b44d4a3df18da7e29ca09--777f95f4f8fa4911877192d2a27a30ef 4d97af6a1a4a46ad87c07b5323519a89 X 777f95f4f8fa4911877192d2a27a30ef--4d97af6a1a4a46ad87c07b5323519a89 4d97af6a1a4a46ad87c07b5323519a89--cc34cdfa23f545178f07d51ea8713314 89a7030064a04e308ade81c979fd6d1e 4d97af6a1a4a46ad87c07b5323519a89--89a7030064a04e308ade81c979fd6d1e bb10336d9c56425a92362d3caeb05369 89a7030064a04e308ade81c979fd6d1e--bb10336d9c56425a92362d3caeb05369 1e1dd6a84ca44ff1b3861ac85ed0eff7 X bb10336d9c56425a92362d3caeb05369--1e1dd6a84ca44ff1b3861ac85ed0eff7 1e1dd6a84ca44ff1b3861ac85ed0eff7--23d7a78cdcdc4569a09f451e828186d6 1f1504925da24ba695cab4a863bf683d 1e1dd6a84ca44ff1b3861ac85ed0eff7--1f1504925da24ba695cab4a863bf683d 03e1fe4f22f448ebbbd662369f58ac47 1f1504925da24ba695cab4a863bf683d--03e1fe4f22f448ebbbd662369f58ac47 d8d743032c624ccdb3b120794f23bd37 03e1fe4f22f448ebbbd662369f58ac47--d8d743032c624ccdb3b120794f23bd37 3ea05905c2804a3597e512b5477c873a d8d743032c624ccdb3b120794f23bd37--3ea05905c2804a3597e512b5477c873a 80545f713e5c4f1a850e7e5172dfed11 3ea05905c2804a3597e512b5477c873a--80545f713e5c4f1a850e7e5172dfed11 f9cc1353ec1344639f15a461d316d7af X 80545f713e5c4f1a850e7e5172dfed11--f9cc1353ec1344639f15a461d316d7af f9cc1353ec1344639f15a461d316d7af--5c99d29b041946d1a984332a654ddef2 06018bf1f8644e2c98c2c253f8ef8e3c f9cc1353ec1344639f15a461d316d7af--06018bf1f8644e2c98c2c253f8ef8e3c b78fd629494f4c0f957ab7fe434f9496 06018bf1f8644e2c98c2c253f8ef8e3c--b78fd629494f4c0f957ab7fe434f9496 549c20e662374b47b0852eddfccf78c4 b78fd629494f4c0f957ab7fe434f9496--549c20e662374b47b0852eddfccf78c4 791013e874ed412c81d98ba4cdfdc124 549c20e662374b47b0852eddfccf78c4--791013e874ed412c81d98ba4cdfdc124 adfe4964b16348e88447f5517ca67b32 791013e874ed412c81d98ba4cdfdc124--adfe4964b16348e88447f5517ca67b32 656b8822901c48329932d2322abcafed adfe4964b16348e88447f5517ca67b32--656b8822901c48329932d2322abcafed 5c7ec90bec834d89aac2222f82d3d94f 656b8822901c48329932d2322abcafed--5c7ec90bec834d89aac2222f82d3d94f 37f891d4dac14536ae564ef713bda155 5c7ec90bec834d89aac2222f82d3d94f--37f891d4dac14536ae564ef713bda155 ad15384fba404ad3a031ae7b85e816ea 37f891d4dac14536ae564ef713bda155--ad15384fba404ad3a031ae7b85e816ea f4d9da96663d4f90aea9fc2cd098a373 ad15384fba404ad3a031ae7b85e816ea--f4d9da96663d4f90aea9fc2cd098a373 dab276a9632446a6a23af49bc9044ab2 f4d9da96663d4f90aea9fc2cd098a373--dab276a9632446a6a23af49bc9044ab2 f7c97db2de534a48b2b896062ae01f2d dab276a9632446a6a23af49bc9044ab2--f7c97db2de534a48b2b896062ae01f2d c44666b23a2741d881260705d9729e52 f7c97db2de534a48b2b896062ae01f2d--c44666b23a2741d881260705d9729e52 55d8d1f6bcd9441e870b967e708727d6 c44666b23a2741d881260705d9729e52--55d8d1f6bcd9441e870b967e708727d6 4f96d40d56cd4758877f59cb2e3d0a4d 55d8d1f6bcd9441e870b967e708727d6--4f96d40d56cd4758877f59cb2e3d0a4d 95e7d96874f84900976e8cd9c48b8511 4f96d40d56cd4758877f59cb2e3d0a4d--95e7d96874f84900976e8cd9c48b8511 25ed982d7f02401d86ebd1a585a36a26 95e7d96874f84900976e8cd9c48b8511--25ed982d7f02401d86ebd1a585a36a26 32a1e6fdd6b443ceb4582ea19ea81aa2 25ed982d7f02401d86ebd1a585a36a26--32a1e6fdd6b443ceb4582ea19ea81aa2 78f987f891a04caa8092d32d4fcba866 32a1e6fdd6b443ceb4582ea19ea81aa2--78f987f891a04caa8092d32d4fcba866 de384b111ac84890b0ce1ca0fd1b040c 78f987f891a04caa8092d32d4fcba866--de384b111ac84890b0ce1ca0fd1b040c 74e7bcc12c2245e1a7cfe8035848b4a1 de384b111ac84890b0ce1ca0fd1b040c--74e7bcc12c2245e1a7cfe8035848b4a1 8ccf1efda5fe482bb029cd533e0c464e 74e7bcc12c2245e1a7cfe8035848b4a1--8ccf1efda5fe482bb029cd533e0c464e 4f1fe27bc0a645498f50147a979beb89 8ccf1efda5fe482bb029cd533e0c464e--4f1fe27bc0a645498f50147a979beb89 edd349c81c6c4be8947265f6909d63fe 4f1fe27bc0a645498f50147a979beb89--edd349c81c6c4be8947265f6909d63fe 7c367aeabb1a4332b8b6f7f5c295622e RX(b04) edd349c81c6c4be8947265f6909d63fe--7c367aeabb1a4332b8b6f7f5c295622e c4483d7d14bd47cba229d0ebc3c78bc2 7c367aeabb1a4332b8b6f7f5c295622e--c4483d7d14bd47cba229d0ebc3c78bc2 a613e16924944163aeab7ae6c8419c13 c4483d7d14bd47cba229d0ebc3c78bc2--a613e16924944163aeab7ae6c8419c13 9b903a6afa834713a59717e8db47be75 a613e16924944163aeab7ae6c8419c13--9b903a6afa834713a59717e8db47be75 b868feaceb2f412fbf79317345187e80 X 9b903a6afa834713a59717e8db47be75--b868feaceb2f412fbf79317345187e80 b868feaceb2f412fbf79317345187e80--d33a68eb08564cd585ffd51b13ad2b00 358688aef44b46e9a43eec6fbf520267 b868feaceb2f412fbf79317345187e80--358688aef44b46e9a43eec6fbf520267 1576bd85c39843ea93e629763b392f1b 358688aef44b46e9a43eec6fbf520267--1576bd85c39843ea93e629763b392f1b fbd53c924cc74b5188e1d8785a061439 1576bd85c39843ea93e629763b392f1b--fbd53c924cc74b5188e1d8785a061439 df4c6fbc06734c118800d60e1eb841b5 fbd53c924cc74b5188e1d8785a061439--df4c6fbc06734c118800d60e1eb841b5 5e2286d376b040a1880102e135b1a59c df4c6fbc06734c118800d60e1eb841b5--5e2286d376b040a1880102e135b1a59c 1cf41178cfb34cceada2ad85297a294f 5e2286d376b040a1880102e135b1a59c--1cf41178cfb34cceada2ad85297a294f 64db57f9cc6f4cdc9797a71c9cd54d3f 1cf41178cfb34cceada2ad85297a294f--64db57f9cc6f4cdc9797a71c9cd54d3f 2a4bed85554a44838ab9d693902837aa X 64db57f9cc6f4cdc9797a71c9cd54d3f--2a4bed85554a44838ab9d693902837aa 2a4bed85554a44838ab9d693902837aa--d73258c7f651483293a357f0b95ea508 a4a1735f18ba440c8e7cf13f786e8fd6 2a4bed85554a44838ab9d693902837aa--a4a1735f18ba440c8e7cf13f786e8fd6 9ca2970806c84489b0470d846ee3d249 a4a1735f18ba440c8e7cf13f786e8fd6--9ca2970806c84489b0470d846ee3d249 377986dfea524855a64ab7e74624cd63 9ca2970806c84489b0470d846ee3d249--377986dfea524855a64ab7e74624cd63 86acf4bce66a405aa90d76cb52c38701 377986dfea524855a64ab7e74624cd63--86acf4bce66a405aa90d76cb52c38701 e738531e6ed8488b870255c1edcc400f 86acf4bce66a405aa90d76cb52c38701--e738531e6ed8488b870255c1edcc400f b3410254f4d4415eb080b235b1c10055 e738531e6ed8488b870255c1edcc400f--b3410254f4d4415eb080b235b1c10055 bfa877003c0f4d30817f2342a9db0b45 b3410254f4d4415eb080b235b1c10055--bfa877003c0f4d30817f2342a9db0b45 7a46249b6af34ae99bbb207db601135c bfa877003c0f4d30817f2342a9db0b45--7a46249b6af34ae99bbb207db601135c cbfd1414107e4402bf6d26b8c314650b 7a46249b6af34ae99bbb207db601135c--cbfd1414107e4402bf6d26b8c314650b 3699844fdaee43b7a2b10c740d282c97 X cbfd1414107e4402bf6d26b8c314650b--3699844fdaee43b7a2b10c740d282c97 3699844fdaee43b7a2b10c740d282c97--d88385511e104f83b29011d4ace9633d a3638015f73546e4aab24f1acbe38e04 RZ(-1.0*g1) 3699844fdaee43b7a2b10c740d282c97--a3638015f73546e4aab24f1acbe38e04 7d2b426b023f4aa2a03d08ae81a83a39 X a3638015f73546e4aab24f1acbe38e04--7d2b426b023f4aa2a03d08ae81a83a39 7d2b426b023f4aa2a03d08ae81a83a39--4191ed3e46da4300b2a9bcf77fddc5ea 26d4af8729fe4fa7be10743aff069b85 7d2b426b023f4aa2a03d08ae81a83a39--26d4af8729fe4fa7be10743aff069b85 b9e773b212f64c2183eb5c2afc0660c9 26d4af8729fe4fa7be10743aff069b85--b9e773b212f64c2183eb5c2afc0660c9 398fb0720c0745c8a720c721aa143a77 b9e773b212f64c2183eb5c2afc0660c9--398fb0720c0745c8a720c721aa143a77 548e24f98af9472091980a86fdddef33 398fb0720c0745c8a720c721aa143a77--548e24f98af9472091980a86fdddef33 3213326ec0d24a08a6955606723dbf24 548e24f98af9472091980a86fdddef33--3213326ec0d24a08a6955606723dbf24 bc7e70a602a4492b813f908e2229aea9 3213326ec0d24a08a6955606723dbf24--bc7e70a602a4492b813f908e2229aea9 04d91a2fd94942dca66db67777186c4c X bc7e70a602a4492b813f908e2229aea9--04d91a2fd94942dca66db67777186c4c 04d91a2fd94942dca66db67777186c4c--0c5e4b6ba60c498d987d36bee7a3af3c 30836dccf60e4e1b8fabfb785ff375ae 04d91a2fd94942dca66db67777186c4c--30836dccf60e4e1b8fabfb785ff375ae 07c5b7d58aaf4fc485ac844a8d94a5d5 30836dccf60e4e1b8fabfb785ff375ae--07c5b7d58aaf4fc485ac844a8d94a5d5 8c162fcbd3354d288a54c646e84c5b10 07c5b7d58aaf4fc485ac844a8d94a5d5--8c162fcbd3354d288a54c646e84c5b10 3576ecfb8f0d4efd8caf33149736fa16 8c162fcbd3354d288a54c646e84c5b10--3576ecfb8f0d4efd8caf33149736fa16 c2c4b6f3b5e64a88af26f44e448abf00 3576ecfb8f0d4efd8caf33149736fa16--c2c4b6f3b5e64a88af26f44e448abf00 84ab3f567ce34afab4c680f86c3347eb X c2c4b6f3b5e64a88af26f44e448abf00--84ab3f567ce34afab4c680f86c3347eb 84ab3f567ce34afab4c680f86c3347eb--d314db85630d44ee993700a7195544a0 e3f9411729594c25a120621ca871ed3b 84ab3f567ce34afab4c680f86c3347eb--e3f9411729594c25a120621ca871ed3b 8cce5f899d8d4d6c9e5080885d4c6d33 e3f9411729594c25a120621ca871ed3b--8cce5f899d8d4d6c9e5080885d4c6d33 4c1d91d505e647c8b09a81289a5c33f9 8cce5f899d8d4d6c9e5080885d4c6d33--4c1d91d505e647c8b09a81289a5c33f9 568c048d877d4dc69f4c6d99071243fa 4c1d91d505e647c8b09a81289a5c33f9--568c048d877d4dc69f4c6d99071243fa d4f4236f15284dd18bc81b699b1ab5dd 568c048d877d4dc69f4c6d99071243fa--d4f4236f15284dd18bc81b699b1ab5dd a8fcbb32754e4b398ebf21b13e5d9c81 d4f4236f15284dd18bc81b699b1ab5dd--a8fcbb32754e4b398ebf21b13e5d9c81 6118833fab1b4f9089d03ff682aa8f8f a8fcbb32754e4b398ebf21b13e5d9c81--6118833fab1b4f9089d03ff682aa8f8f 7a1a0c93924c4b0790989c6c82d646c4 6118833fab1b4f9089d03ff682aa8f8f--7a1a0c93924c4b0790989c6c82d646c4 2b432ad60caf4c03a58ab7b3562ffc3c 7a1a0c93924c4b0790989c6c82d646c4--2b432ad60caf4c03a58ab7b3562ffc3c 6c19f2ec0d704571bf35a25b2aabc703 2b432ad60caf4c03a58ab7b3562ffc3c--6c19f2ec0d704571bf35a25b2aabc703 8996348fc7014a37b6d640bb831f4b6d 6c19f2ec0d704571bf35a25b2aabc703--8996348fc7014a37b6d640bb831f4b6d e7265f0ce77d46da96ecd1977fcd8d83 8996348fc7014a37b6d640bb831f4b6d--e7265f0ce77d46da96ecd1977fcd8d83 2bcb86e85e3d4ebfaadeac4e028c7844 e7265f0ce77d46da96ecd1977fcd8d83--2bcb86e85e3d4ebfaadeac4e028c7844 6a70f04e9f684627a7931ef59cbe37e1 X 2bcb86e85e3d4ebfaadeac4e028c7844--6a70f04e9f684627a7931ef59cbe37e1 6a70f04e9f684627a7931ef59cbe37e1--7a6eb7bb16d2421a8ad66bc62a9e9591 3508e5834c7f4b09bddc5b3736412d2c 6a70f04e9f684627a7931ef59cbe37e1--3508e5834c7f4b09bddc5b3736412d2c dd7846e6129048a98c1c0f45c6e99bf8 3508e5834c7f4b09bddc5b3736412d2c--dd7846e6129048a98c1c0f45c6e99bf8 1c19f7951cd04e43b492b3ddd05c869d dd7846e6129048a98c1c0f45c6e99bf8--1c19f7951cd04e43b492b3ddd05c869d 0d75d6df2662461aac9824c302cade80 X 1c19f7951cd04e43b492b3ddd05c869d--0d75d6df2662461aac9824c302cade80 0d75d6df2662461aac9824c302cade80--050df10e572d4e3881797a4a351e0454 8e15946b76404a2fa3137a6144d58906 0d75d6df2662461aac9824c302cade80--8e15946b76404a2fa3137a6144d58906 4bf0c65b4ace4219be91f56bdabf3af3 8e15946b76404a2fa3137a6144d58906--4bf0c65b4ace4219be91f56bdabf3af3 e37ae2b2b3b04273b31d95a2ebfe8a0f 4bf0c65b4ace4219be91f56bdabf3af3--e37ae2b2b3b04273b31d95a2ebfe8a0f 6bc9c7b3bbbb4a51b9291bf2fb7db6de e37ae2b2b3b04273b31d95a2ebfe8a0f--6bc9c7b3bbbb4a51b9291bf2fb7db6de 6cbf2ff0fac4460da77bcea63633be92 X 6bc9c7b3bbbb4a51b9291bf2fb7db6de--6cbf2ff0fac4460da77bcea63633be92 6cbf2ff0fac4460da77bcea63633be92--2d5921f740b1431990b29be32666bba3 5ff7b01c9280487ab7c07659480b1cd9 6cbf2ff0fac4460da77bcea63633be92--5ff7b01c9280487ab7c07659480b1cd9 f0d5ec34e09c4810937330f10152c32e 5ff7b01c9280487ab7c07659480b1cd9--f0d5ec34e09c4810937330f10152c32e beb475a4e3a74d019a0694dbe386efcb f0d5ec34e09c4810937330f10152c32e--beb475a4e3a74d019a0694dbe386efcb 445ea55834dd46deb9a8ea54dce920c4 beb475a4e3a74d019a0694dbe386efcb--445ea55834dd46deb9a8ea54dce920c4 f621a07c4fcf42aa85243ec0ec9e1a55 445ea55834dd46deb9a8ea54dce920c4--f621a07c4fcf42aa85243ec0ec9e1a55 cf8a57718be74ba082625d4a4d70bd86 f621a07c4fcf42aa85243ec0ec9e1a55--cf8a57718be74ba082625d4a4d70bd86 39930836d20c42b78a77cecff4f44765 cf8a57718be74ba082625d4a4d70bd86--39930836d20c42b78a77cecff4f44765 2872b695316445d8b177ef2894491b46 X 39930836d20c42b78a77cecff4f44765--2872b695316445d8b177ef2894491b46 2872b695316445d8b177ef2894491b46--ec6b6db6d0c74b04b14c36974aee8770 6db506dc77e44c2aab65ba7f3f282761 2872b695316445d8b177ef2894491b46--6db506dc77e44c2aab65ba7f3f282761 4c039b655f9f48c69458fab64938bd49 6db506dc77e44c2aab65ba7f3f282761--4c039b655f9f48c69458fab64938bd49 add69e78c442484ea518247656198a68 4c039b655f9f48c69458fab64938bd49--add69e78c442484ea518247656198a68 4d6fbcbf28d44976866f328acf9bbfd1 X add69e78c442484ea518247656198a68--4d6fbcbf28d44976866f328acf9bbfd1 4d6fbcbf28d44976866f328acf9bbfd1--d5fb1c3439304692a0bb66ea3c28a65c 091da713616a4129be37eea30eb38746 4d6fbcbf28d44976866f328acf9bbfd1--091da713616a4129be37eea30eb38746 b1a9d2da202149b197952cf3f028645c 091da713616a4129be37eea30eb38746--b1a9d2da202149b197952cf3f028645c 02a1608e0a2e4f568b4da4e29be280ee b1a9d2da202149b197952cf3f028645c--02a1608e0a2e4f568b4da4e29be280ee 704c790ac18d4363a9b82e5d1aa7391d X 02a1608e0a2e4f568b4da4e29be280ee--704c790ac18d4363a9b82e5d1aa7391d 704c790ac18d4363a9b82e5d1aa7391d--12f7d64558e34ba2b810ee9ff3193fb9 3b51d70e485f4f5db6e3612d12e45799 704c790ac18d4363a9b82e5d1aa7391d--3b51d70e485f4f5db6e3612d12e45799 cbdc0a462bc64ed49d126f7ad4594a63 3b51d70e485f4f5db6e3612d12e45799--cbdc0a462bc64ed49d126f7ad4594a63 4f6ff2d242c74ad29a4dc2803535699b X cbdc0a462bc64ed49d126f7ad4594a63--4f6ff2d242c74ad29a4dc2803535699b 4f6ff2d242c74ad29a4dc2803535699b--69774bc0aa1c425e8be9589cd9260376 112ab85fd93c42de877234db4737f3ea 4f6ff2d242c74ad29a4dc2803535699b--112ab85fd93c42de877234db4737f3ea 29796fd0d22b431cb30347374c2b90a1 112ab85fd93c42de877234db4737f3ea--29796fd0d22b431cb30347374c2b90a1 dc5a2ef8fb31425e9fcdbf718c9ff59b 29796fd0d22b431cb30347374c2b90a1--dc5a2ef8fb31425e9fcdbf718c9ff59b bb43b913fa554c4f9d8b53c6af48b9e9 dc5a2ef8fb31425e9fcdbf718c9ff59b--bb43b913fa554c4f9d8b53c6af48b9e9 38d1b629da3c4a88a6df650cda7f983c bb43b913fa554c4f9d8b53c6af48b9e9--38d1b629da3c4a88a6df650cda7f983c 338a7596b43b4aaf98efbac3e323fcb4 X 38d1b629da3c4a88a6df650cda7f983c--338a7596b43b4aaf98efbac3e323fcb4 338a7596b43b4aaf98efbac3e323fcb4--508d883ae7144af49092ccbce86d8623 c2f57911e779432aba7c088e2b72d450 338a7596b43b4aaf98efbac3e323fcb4--c2f57911e779432aba7c088e2b72d450 ccf95a1f97ad47ee92932b2300fd881b c2f57911e779432aba7c088e2b72d450--ccf95a1f97ad47ee92932b2300fd881b 396659f7a5cb471ba508b996b6775ed2 ccf95a1f97ad47ee92932b2300fd881b--396659f7a5cb471ba508b996b6775ed2 45ed79dd98174a31b12ad5fc213e5b03 396659f7a5cb471ba508b996b6775ed2--45ed79dd98174a31b12ad5fc213e5b03 c94d2aec94ef41bca70c430650f012fe 45ed79dd98174a31b12ad5fc213e5b03--c94d2aec94ef41bca70c430650f012fe e876541b796340238cae9dffba65081e c94d2aec94ef41bca70c430650f012fe--e876541b796340238cae9dffba65081e 861700cba95e4846b8a9f515694103b6 e876541b796340238cae9dffba65081e--861700cba95e4846b8a9f515694103b6 b92b0bdf0f50486981598a2c434621e3 861700cba95e4846b8a9f515694103b6--b92b0bdf0f50486981598a2c434621e3 80988e5ded764dfc8699d2bb3f1b0d22 b92b0bdf0f50486981598a2c434621e3--80988e5ded764dfc8699d2bb3f1b0d22 e804f3248ab54c83bebf5275574460d6 80988e5ded764dfc8699d2bb3f1b0d22--e804f3248ab54c83bebf5275574460d6 5be2fb5dc4be48b2b3e4da94827fb695 e804f3248ab54c83bebf5275574460d6--5be2fb5dc4be48b2b3e4da94827fb695 e3bf1e839c2c4e08a1237784ff165ba7 5be2fb5dc4be48b2b3e4da94827fb695--e3bf1e839c2c4e08a1237784ff165ba7 909a332443d145f2b71bfc3677dccd7b e3bf1e839c2c4e08a1237784ff165ba7--909a332443d145f2b71bfc3677dccd7b e55616ce2026491b91b158b857f0dd59 909a332443d145f2b71bfc3677dccd7b--e55616ce2026491b91b158b857f0dd59 61f13c05ca724878b1c2211b9eeb5cb5 e55616ce2026491b91b158b857f0dd59--61f13c05ca724878b1c2211b9eeb5cb5 2a8894ef33384e65ba9f2872002f598e 61f13c05ca724878b1c2211b9eeb5cb5--2a8894ef33384e65ba9f2872002f598e 9da6e33ff2d342bbbda48a4657dced53 2a8894ef33384e65ba9f2872002f598e--9da6e33ff2d342bbbda48a4657dced53 720b52e621bf4fbb9eec6a27a0564313 9da6e33ff2d342bbbda48a4657dced53--720b52e621bf4fbb9eec6a27a0564313 07266d04e79f4c02921c2b1d0012cb7c 720b52e621bf4fbb9eec6a27a0564313--07266d04e79f4c02921c2b1d0012cb7c 78c22b7c57564eb5b969c850eb55755f 07266d04e79f4c02921c2b1d0012cb7c--78c22b7c57564eb5b969c850eb55755f 1d957a92e01a4d3ab956f13bddf56aad 78c22b7c57564eb5b969c850eb55755f--1d957a92e01a4d3ab956f13bddf56aad ffbda74ab7a241d7a7e194e527c4e350 1d957a92e01a4d3ab956f13bddf56aad--ffbda74ab7a241d7a7e194e527c4e350 8216b5bacb7a4d73aedd61dfc5a7c38a ffbda74ab7a241d7a7e194e527c4e350--8216b5bacb7a4d73aedd61dfc5a7c38a 529e1aae8d614d8881e6de3076c1f982 8216b5bacb7a4d73aedd61dfc5a7c38a--529e1aae8d614d8881e6de3076c1f982 84b2717ce5f444d8943133d5d504969b RX(b14) 529e1aae8d614d8881e6de3076c1f982--84b2717ce5f444d8943133d5d504969b 84b2717ce5f444d8943133d5d504969b--ec3c3aebd73b4589a81f2dcfbfe969ed 4b91c2d7d0e640989b7de19e72760d04 df7f138faaed4ec4adca8f717f51f55e 761b8a10d46544f1a668ba158da1f358--df7f138faaed4ec4adca8f717f51f55e 37077d9ca9364818b61496af0669fa2e 6 0ec205772caf418695fc1d9135360280 df7f138faaed4ec4adca8f717f51f55e--0ec205772caf418695fc1d9135360280 bd6a5c68cd2c45e8a03f8b1cccfa10fe 0ec205772caf418695fc1d9135360280--bd6a5c68cd2c45e8a03f8b1cccfa10fe a4d431b783aa48368f896c5e5e8de2dc bd6a5c68cd2c45e8a03f8b1cccfa10fe--a4d431b783aa48368f896c5e5e8de2dc 78b69e664bd647868f7b878767244d97 X a4d431b783aa48368f896c5e5e8de2dc--78b69e664bd647868f7b878767244d97 78b69e664bd647868f7b878767244d97--38b38c2054124c90b9e6ec64e5f5bb09 4ea0a8a38e934d0d94da352d4e527e89 78b69e664bd647868f7b878767244d97--4ea0a8a38e934d0d94da352d4e527e89 bfcd9cd324ca47068351bd6fbe488958 4ea0a8a38e934d0d94da352d4e527e89--bfcd9cd324ca47068351bd6fbe488958 11032a1d1b68406092537e80373017d5 bfcd9cd324ca47068351bd6fbe488958--11032a1d1b68406092537e80373017d5 f142a374ce324b1180d33e6c1cdd4f6e 11032a1d1b68406092537e80373017d5--f142a374ce324b1180d33e6c1cdd4f6e 8ef5978dc64849918792eae268058cea f142a374ce324b1180d33e6c1cdd4f6e--8ef5978dc64849918792eae268058cea c4ce9ac3143849f79d8a1cabcdc576ed X 8ef5978dc64849918792eae268058cea--c4ce9ac3143849f79d8a1cabcdc576ed c4ce9ac3143849f79d8a1cabcdc576ed--08263e9ad1c940c4975df2015e46d911 80721e0361e0440eb78faf6ba35cad76 c4ce9ac3143849f79d8a1cabcdc576ed--80721e0361e0440eb78faf6ba35cad76 247af5bb0dae4e6f91e1a88349c09189 80721e0361e0440eb78faf6ba35cad76--247af5bb0dae4e6f91e1a88349c09189 8281d05c9a09474aacc9ffadf617f8a4 247af5bb0dae4e6f91e1a88349c09189--8281d05c9a09474aacc9ffadf617f8a4 3db0267c1f6f4aeca8ec8cda6eba35d6 8281d05c9a09474aacc9ffadf617f8a4--3db0267c1f6f4aeca8ec8cda6eba35d6 dffcb74713e24c24b557820b51a7fe0a 3db0267c1f6f4aeca8ec8cda6eba35d6--dffcb74713e24c24b557820b51a7fe0a 7335882bb6ff4a91af747479a1af9909 dffcb74713e24c24b557820b51a7fe0a--7335882bb6ff4a91af747479a1af9909 7171d26e6f804ca582f248cf4d2144e4 7335882bb6ff4a91af747479a1af9909--7171d26e6f804ca582f248cf4d2144e4 bb2e53a2b79941c2b96c09c0ea64d209 7171d26e6f804ca582f248cf4d2144e4--bb2e53a2b79941c2b96c09c0ea64d209 ad6a1bdeb403435987029bbf092fbebe bb2e53a2b79941c2b96c09c0ea64d209--ad6a1bdeb403435987029bbf092fbebe 88d14b27b50d40ffacd44cb92e4c23a6 ad6a1bdeb403435987029bbf092fbebe--88d14b27b50d40ffacd44cb92e4c23a6 7df8466ee9d4455d90865e7628d2d8db 88d14b27b50d40ffacd44cb92e4c23a6--7df8466ee9d4455d90865e7628d2d8db 6816b04f9e324c86a3e76aa6b13026c3 7df8466ee9d4455d90865e7628d2d8db--6816b04f9e324c86a3e76aa6b13026c3 9028ba30ed654854bf9b47ccb4b16df9 6816b04f9e324c86a3e76aa6b13026c3--9028ba30ed654854bf9b47ccb4b16df9 a501f658634449a482c8fb423faf8951 9028ba30ed654854bf9b47ccb4b16df9--a501f658634449a482c8fb423faf8951 e5e30e6ecfef47f0af7d60b06a86b1a3 a501f658634449a482c8fb423faf8951--e5e30e6ecfef47f0af7d60b06a86b1a3 76b3218886a646c9a09531ab49f85d37 e5e30e6ecfef47f0af7d60b06a86b1a3--76b3218886a646c9a09531ab49f85d37 9da1f2e7407e46a396a2d7ee6efeba27 76b3218886a646c9a09531ab49f85d37--9da1f2e7407e46a396a2d7ee6efeba27 99548797f7be4acdaa16b28c9bc29712 9da1f2e7407e46a396a2d7ee6efeba27--99548797f7be4acdaa16b28c9bc29712 596b86201a7b43e69b18939ce2b09daa 99548797f7be4acdaa16b28c9bc29712--596b86201a7b43e69b18939ce2b09daa 2af22ea02d5c4371a59e944168bc472b 596b86201a7b43e69b18939ce2b09daa--2af22ea02d5c4371a59e944168bc472b f3a46eb3a1a94a5c94ad42e3282c3b40 X 2af22ea02d5c4371a59e944168bc472b--f3a46eb3a1a94a5c94ad42e3282c3b40 f3a46eb3a1a94a5c94ad42e3282c3b40--35f656ed637542bbb205d47500af7ee8 a06f50b630da4cf3a27102a648d601a6 f3a46eb3a1a94a5c94ad42e3282c3b40--a06f50b630da4cf3a27102a648d601a6 13702f4458d248af8e4f96bf58836dcf a06f50b630da4cf3a27102a648d601a6--13702f4458d248af8e4f96bf58836dcf 4db37c7773684d769de350023ddfd9dd 13702f4458d248af8e4f96bf58836dcf--4db37c7773684d769de350023ddfd9dd 853f0efe2df1493e914e08dff4372577 X 4db37c7773684d769de350023ddfd9dd--853f0efe2df1493e914e08dff4372577 853f0efe2df1493e914e08dff4372577--44b0bbf54b344ec7af281dfa47d5c0ee 9014c0fff8ce417d88680f6f70275c22 853f0efe2df1493e914e08dff4372577--9014c0fff8ce417d88680f6f70275c22 4e3f0215baca4b3797ee1a2e0a71844a 9014c0fff8ce417d88680f6f70275c22--4e3f0215baca4b3797ee1a2e0a71844a 8dc52868bf1d40e6ad688c7541d3ee61 4e3f0215baca4b3797ee1a2e0a71844a--8dc52868bf1d40e6ad688c7541d3ee61 8a13bcf371c9489f87a8c17f207e4115 8dc52868bf1d40e6ad688c7541d3ee61--8a13bcf371c9489f87a8c17f207e4115 59cc92c8b7ea4b929a95dbd13fc86a5c 8a13bcf371c9489f87a8c17f207e4115--59cc92c8b7ea4b929a95dbd13fc86a5c 6ae1635266374bf9aa66ed37a6998516 59cc92c8b7ea4b929a95dbd13fc86a5c--6ae1635266374bf9aa66ed37a6998516 eb6f3fa4aecc4be380d1974e5639e18b 6ae1635266374bf9aa66ed37a6998516--eb6f3fa4aecc4be380d1974e5639e18b 49b25d2c755b42c686684e78b59df291 eb6f3fa4aecc4be380d1974e5639e18b--49b25d2c755b42c686684e78b59df291 da2674eed6a24eb3bbe26f09b1eb985c 49b25d2c755b42c686684e78b59df291--da2674eed6a24eb3bbe26f09b1eb985c 2d7ed0e8cae34640bcdae221f587c818 da2674eed6a24eb3bbe26f09b1eb985c--2d7ed0e8cae34640bcdae221f587c818 0ec29bb0a9d4463593a9b00097405084 2d7ed0e8cae34640bcdae221f587c818--0ec29bb0a9d4463593a9b00097405084 1a786843b3a7459dabf15a0277a00a62 0ec29bb0a9d4463593a9b00097405084--1a786843b3a7459dabf15a0277a00a62 5bb49123701745de91bb7dfa70ba6331 1a786843b3a7459dabf15a0277a00a62--5bb49123701745de91bb7dfa70ba6331 c20bb1d07a304881b97d70cc38ac7e3d 5bb49123701745de91bb7dfa70ba6331--c20bb1d07a304881b97d70cc38ac7e3d c26b583c49dd417a993f8b39cb26aee8 c20bb1d07a304881b97d70cc38ac7e3d--c26b583c49dd417a993f8b39cb26aee8 b5c0a4223d7b4948830f9398b6563dca X c26b583c49dd417a993f8b39cb26aee8--b5c0a4223d7b4948830f9398b6563dca b5c0a4223d7b4948830f9398b6563dca--eb23f79c8622465b955b1bd1a9e7b433 d8f446e29a7a42a3a4ece1d113bf85a5 RZ(-1.0*g0) b5c0a4223d7b4948830f9398b6563dca--d8f446e29a7a42a3a4ece1d113bf85a5 4467c4a1c34640c88ff6a46be853b9b5 X d8f446e29a7a42a3a4ece1d113bf85a5--4467c4a1c34640c88ff6a46be853b9b5 4467c4a1c34640c88ff6a46be853b9b5--48cfd2c55f6c4bfe932b392b3b17be6a 3fc602257bbe4e7ab663129f32708f2c 4467c4a1c34640c88ff6a46be853b9b5--3fc602257bbe4e7ab663129f32708f2c 6757f4b53bf34d289ec15187eb4f7ffb 3fc602257bbe4e7ab663129f32708f2c--6757f4b53bf34d289ec15187eb4f7ffb 01e71c4791364546be2facb6fbcc9517 6757f4b53bf34d289ec15187eb4f7ffb--01e71c4791364546be2facb6fbcc9517 df932f1625954a1cb1f594e86dbc3012 01e71c4791364546be2facb6fbcc9517--df932f1625954a1cb1f594e86dbc3012 ec596f9c967b420da951fb1648616096 df932f1625954a1cb1f594e86dbc3012--ec596f9c967b420da951fb1648616096 65c9e6ce984a452a9fa5ed919a24d2f1 ec596f9c967b420da951fb1648616096--65c9e6ce984a452a9fa5ed919a24d2f1 381ce9bb327c47ec82abbf093da50d2e X 65c9e6ce984a452a9fa5ed919a24d2f1--381ce9bb327c47ec82abbf093da50d2e 381ce9bb327c47ec82abbf093da50d2e--86d59ee411f84cb7b1d17454f62f2f1f 9e3dc71a326c44db87b3f06eda54b165 381ce9bb327c47ec82abbf093da50d2e--9e3dc71a326c44db87b3f06eda54b165 cd664f0feada4ddaa5002ebc7024a457 9e3dc71a326c44db87b3f06eda54b165--cd664f0feada4ddaa5002ebc7024a457 4c6747e5a9bc4c8e9cacae4882958b78 cd664f0feada4ddaa5002ebc7024a457--4c6747e5a9bc4c8e9cacae4882958b78 e6793da108c4458eb9e8b66052147690 4c6747e5a9bc4c8e9cacae4882958b78--e6793da108c4458eb9e8b66052147690 220a48663f414a4b8fafd9a81eb65361 e6793da108c4458eb9e8b66052147690--220a48663f414a4b8fafd9a81eb65361 8345497d111c4a35917e06e238fd161e X 220a48663f414a4b8fafd9a81eb65361--8345497d111c4a35917e06e238fd161e 8345497d111c4a35917e06e238fd161e--d17ac1894b164225b9da52339c7e1841 951e7565133344f8a3e3f33ea8053e9f 8345497d111c4a35917e06e238fd161e--951e7565133344f8a3e3f33ea8053e9f 89f41d2eded54edc8e9f3bfdb8493f06 951e7565133344f8a3e3f33ea8053e9f--89f41d2eded54edc8e9f3bfdb8493f06 8c082473f2e04281a8134ee4138806ed 89f41d2eded54edc8e9f3bfdb8493f06--8c082473f2e04281a8134ee4138806ed 0d3e89068bdb4f30a740c7cc2123331b 8c082473f2e04281a8134ee4138806ed--0d3e89068bdb4f30a740c7cc2123331b eabc1fda8cf144c79a1f01c073b49f62 0d3e89068bdb4f30a740c7cc2123331b--eabc1fda8cf144c79a1f01c073b49f62 a47b45464be14271ab94d6444a49ea25 X eabc1fda8cf144c79a1f01c073b49f62--a47b45464be14271ab94d6444a49ea25 a47b45464be14271ab94d6444a49ea25--a66adf884bd14514bfa17142472e440c 0a33fe0d6162489faddc18c5ef670eba RZ(-1.0*g0) a47b45464be14271ab94d6444a49ea25--0a33fe0d6162489faddc18c5ef670eba 55c33bffc81642dabb474136eaec8229 X 0a33fe0d6162489faddc18c5ef670eba--55c33bffc81642dabb474136eaec8229 55c33bffc81642dabb474136eaec8229--777f95f4f8fa4911877192d2a27a30ef c074a66b0cf1403d8cc1a51fe46cd1a6 55c33bffc81642dabb474136eaec8229--c074a66b0cf1403d8cc1a51fe46cd1a6 39d47b3df9214a8dba944cd26639b5e3 c074a66b0cf1403d8cc1a51fe46cd1a6--39d47b3df9214a8dba944cd26639b5e3 b58805e57ffc4e519e255359a5c8b163 39d47b3df9214a8dba944cd26639b5e3--b58805e57ffc4e519e255359a5c8b163 980c0e0e97e548018c135e143b2d0051 b58805e57ffc4e519e255359a5c8b163--980c0e0e97e548018c135e143b2d0051 c02a88c724c64a18aacadd1f0b6c9f5f X 980c0e0e97e548018c135e143b2d0051--c02a88c724c64a18aacadd1f0b6c9f5f c02a88c724c64a18aacadd1f0b6c9f5f--1f1504925da24ba695cab4a863bf683d fedd9a78124f4a89875d3cfa0cfd5e7b c02a88c724c64a18aacadd1f0b6c9f5f--fedd9a78124f4a89875d3cfa0cfd5e7b 716e4373167b46f18d78eff6e8f7f56a fedd9a78124f4a89875d3cfa0cfd5e7b--716e4373167b46f18d78eff6e8f7f56a ea1e9559adf545cfaedaf41822552732 716e4373167b46f18d78eff6e8f7f56a--ea1e9559adf545cfaedaf41822552732 e81e4ab7eb9847b48068fe1be95d7bae X ea1e9559adf545cfaedaf41822552732--e81e4ab7eb9847b48068fe1be95d7bae e81e4ab7eb9847b48068fe1be95d7bae--80545f713e5c4f1a850e7e5172dfed11 e2f7a7b215274832ae16cdb7463555d6 e81e4ab7eb9847b48068fe1be95d7bae--e2f7a7b215274832ae16cdb7463555d6 2f41c31163084e89b4b8ed7c12140fa5 e2f7a7b215274832ae16cdb7463555d6--2f41c31163084e89b4b8ed7c12140fa5 d12a42caf623417ebf609bc3ba5d003d X 2f41c31163084e89b4b8ed7c12140fa5--d12a42caf623417ebf609bc3ba5d003d d12a42caf623417ebf609bc3ba5d003d--b78fd629494f4c0f957ab7fe434f9496 cf1077b93f3f4f828fe39de05c326516 d12a42caf623417ebf609bc3ba5d003d--cf1077b93f3f4f828fe39de05c326516 cef0c84c7b0b4192a98d41f33c632c56 cf1077b93f3f4f828fe39de05c326516--cef0c84c7b0b4192a98d41f33c632c56 6bf42b8738dd4e33b11154c70a449091 cef0c84c7b0b4192a98d41f33c632c56--6bf42b8738dd4e33b11154c70a449091 582f1c3d525e41918c388414181dc6bf X 6bf42b8738dd4e33b11154c70a449091--582f1c3d525e41918c388414181dc6bf 582f1c3d525e41918c388414181dc6bf--656b8822901c48329932d2322abcafed cd277772327b4dc283c68dc2a44a3664 X 582f1c3d525e41918c388414181dc6bf--cd277772327b4dc283c68dc2a44a3664 cd277772327b4dc283c68dc2a44a3664--5c7ec90bec834d89aac2222f82d3d94f 288ab2f5f4e844f09519d4c028ce5b5a cd277772327b4dc283c68dc2a44a3664--288ab2f5f4e844f09519d4c028ce5b5a d5628d9898dc44cd81c4c9b3d54ef27d 288ab2f5f4e844f09519d4c028ce5b5a--d5628d9898dc44cd81c4c9b3d54ef27d 8dfaf00c4e97471480d12b06c297d725 d5628d9898dc44cd81c4c9b3d54ef27d--8dfaf00c4e97471480d12b06c297d725 e66a570dc67e4ba3a4b5257e5368d6b9 8dfaf00c4e97471480d12b06c297d725--e66a570dc67e4ba3a4b5257e5368d6b9 0d737243f0b64170beec1bd97cb2e4a1 e66a570dc67e4ba3a4b5257e5368d6b9--0d737243f0b64170beec1bd97cb2e4a1 5b4ff6868cbf42ff912d2c1f186f0b63 X 0d737243f0b64170beec1bd97cb2e4a1--5b4ff6868cbf42ff912d2c1f186f0b63 5b4ff6868cbf42ff912d2c1f186f0b63--c44666b23a2741d881260705d9729e52 8a7ad1ae61b94c968e9e5f534097f147 5b4ff6868cbf42ff912d2c1f186f0b63--8a7ad1ae61b94c968e9e5f534097f147 b5302f24f6b249ad9d8698c13ebae073 8a7ad1ae61b94c968e9e5f534097f147--b5302f24f6b249ad9d8698c13ebae073 74a24543660d40a4b20963dc1a65cd36 b5302f24f6b249ad9d8698c13ebae073--74a24543660d40a4b20963dc1a65cd36 0728721b25c04f9a9a9f2fe8a7b6d2b6 74a24543660d40a4b20963dc1a65cd36--0728721b25c04f9a9a9f2fe8a7b6d2b6 9da260a345c04d05a60be97af20b079d 0728721b25c04f9a9a9f2fe8a7b6d2b6--9da260a345c04d05a60be97af20b079d ef69d0d834e743b9a8efdc99d1202cbd 9da260a345c04d05a60be97af20b079d--ef69d0d834e743b9a8efdc99d1202cbd c87058a68e914087a784266bf05158a1 ef69d0d834e743b9a8efdc99d1202cbd--c87058a68e914087a784266bf05158a1 019c1078e10c4e0e91b0e23638b95fd7 c87058a68e914087a784266bf05158a1--019c1078e10c4e0e91b0e23638b95fd7 c8185249217040508ea57bac30c25ab0 019c1078e10c4e0e91b0e23638b95fd7--c8185249217040508ea57bac30c25ab0 ae6205bf9d0a46d883a3cc89da87e37c c8185249217040508ea57bac30c25ab0--ae6205bf9d0a46d883a3cc89da87e37c b1c4ba23f0974ab7ad4c9e49b4187dc5 ae6205bf9d0a46d883a3cc89da87e37c--b1c4ba23f0974ab7ad4c9e49b4187dc5 06d10215389442c0951ab6d0129f0b36 RX(b05) b1c4ba23f0974ab7ad4c9e49b4187dc5--06d10215389442c0951ab6d0129f0b36 9e41ba40d3bf45a29ed499cd15b3b546 06d10215389442c0951ab6d0129f0b36--9e41ba40d3bf45a29ed499cd15b3b546 1f4e9c5997e34c13aeac1eaab49e0a2a 9e41ba40d3bf45a29ed499cd15b3b546--1f4e9c5997e34c13aeac1eaab49e0a2a b28e3e5f8fce4236a4faa1fd96f09f7f 1f4e9c5997e34c13aeac1eaab49e0a2a--b28e3e5f8fce4236a4faa1fd96f09f7f 7ea1c4996e6d4d0789656d2f447aa226 b28e3e5f8fce4236a4faa1fd96f09f7f--7ea1c4996e6d4d0789656d2f447aa226 1387a62d80c74a1d8311e80ef1f281fc X 7ea1c4996e6d4d0789656d2f447aa226--1387a62d80c74a1d8311e80ef1f281fc 1387a62d80c74a1d8311e80ef1f281fc--358688aef44b46e9a43eec6fbf520267 4fde3385f24146449b2988da3aee487e 1387a62d80c74a1d8311e80ef1f281fc--4fde3385f24146449b2988da3aee487e 42ded282333a4cd2991a38942cab4923 4fde3385f24146449b2988da3aee487e--42ded282333a4cd2991a38942cab4923 3c9d73739e484f988c9384f4559cb99e 42ded282333a4cd2991a38942cab4923--3c9d73739e484f988c9384f4559cb99e afe663d448794e82b72b4c67a0404e70 3c9d73739e484f988c9384f4559cb99e--afe663d448794e82b72b4c67a0404e70 b98ce6bc3e6b49319fc656f104dcc1ef afe663d448794e82b72b4c67a0404e70--b98ce6bc3e6b49319fc656f104dcc1ef 7211a27f53cb4ac993b240cd77451484 X b98ce6bc3e6b49319fc656f104dcc1ef--7211a27f53cb4ac993b240cd77451484 7211a27f53cb4ac993b240cd77451484--64db57f9cc6f4cdc9797a71c9cd54d3f 83e462f019e14ad4ad02c237ab6c8d87 7211a27f53cb4ac993b240cd77451484--83e462f019e14ad4ad02c237ab6c8d87 6ca1018ea0a74ce3aa548197c3f93050 83e462f019e14ad4ad02c237ab6c8d87--6ca1018ea0a74ce3aa548197c3f93050 1c66c1a0f5d047f2ab49c15f59136fdb 6ca1018ea0a74ce3aa548197c3f93050--1c66c1a0f5d047f2ab49c15f59136fdb 56ef978fa4994d46a3bd01db042f6d4d 1c66c1a0f5d047f2ab49c15f59136fdb--56ef978fa4994d46a3bd01db042f6d4d 07023445daa1490f8781f5fa84e339d5 56ef978fa4994d46a3bd01db042f6d4d--07023445daa1490f8781f5fa84e339d5 93a3b306d3154ef984aefd6c288e8956 07023445daa1490f8781f5fa84e339d5--93a3b306d3154ef984aefd6c288e8956 4e144bc656de43e5a402b6fefb59996b 93a3b306d3154ef984aefd6c288e8956--4e144bc656de43e5a402b6fefb59996b 48bd0773405245209b3df9d76aeebb17 4e144bc656de43e5a402b6fefb59996b--48bd0773405245209b3df9d76aeebb17 168881499bfa4d0b9fa73e7fe832fa32 48bd0773405245209b3df9d76aeebb17--168881499bfa4d0b9fa73e7fe832fa32 860287ef8da94bd78ceb5b0e92c8f529 168881499bfa4d0b9fa73e7fe832fa32--860287ef8da94bd78ceb5b0e92c8f529 bc499ba0611d4f6698b77730a88dddf3 860287ef8da94bd78ceb5b0e92c8f529--bc499ba0611d4f6698b77730a88dddf3 2b18583866784da5977e55ac7e957d12 bc499ba0611d4f6698b77730a88dddf3--2b18583866784da5977e55ac7e957d12 5b2cda1147314143a90fbd5d2a4eaef7 2b18583866784da5977e55ac7e957d12--5b2cda1147314143a90fbd5d2a4eaef7 d9bc4caa00304c21aaec4c18d95a51b3 5b2cda1147314143a90fbd5d2a4eaef7--d9bc4caa00304c21aaec4c18d95a51b3 1dbc71f98a5e48fc95570a5d85ceb152 d9bc4caa00304c21aaec4c18d95a51b3--1dbc71f98a5e48fc95570a5d85ceb152 549f4a13dffa4ef88c2cc0116b3b1d7c 1dbc71f98a5e48fc95570a5d85ceb152--549f4a13dffa4ef88c2cc0116b3b1d7c 6c015e9573ba480fa286f91a8c737339 549f4a13dffa4ef88c2cc0116b3b1d7c--6c015e9573ba480fa286f91a8c737339 6e7cb4ae7ac44b80935409257a8ecf38 6c015e9573ba480fa286f91a8c737339--6e7cb4ae7ac44b80935409257a8ecf38 4e4cd6632d7e4e6d90cf2b7fb422af6d 6e7cb4ae7ac44b80935409257a8ecf38--4e4cd6632d7e4e6d90cf2b7fb422af6d 46336fcf23e34b6c8cfc4eed78963520 4e4cd6632d7e4e6d90cf2b7fb422af6d--46336fcf23e34b6c8cfc4eed78963520 7782ad8ca8aa469d8af61214747c41d6 X 46336fcf23e34b6c8cfc4eed78963520--7782ad8ca8aa469d8af61214747c41d6 7782ad8ca8aa469d8af61214747c41d6--30836dccf60e4e1b8fabfb785ff375ae 6eac9f7db5fd4867aa37f8a773216630 7782ad8ca8aa469d8af61214747c41d6--6eac9f7db5fd4867aa37f8a773216630 884dbf13bb1f4529a290afba0fe645e0 6eac9f7db5fd4867aa37f8a773216630--884dbf13bb1f4529a290afba0fe645e0 c66daf8657084811a85e8a6abac6d4d5 884dbf13bb1f4529a290afba0fe645e0--c66daf8657084811a85e8a6abac6d4d5 e753dd90d925416188b59c798744494a X c66daf8657084811a85e8a6abac6d4d5--e753dd90d925416188b59c798744494a e753dd90d925416188b59c798744494a--c2c4b6f3b5e64a88af26f44e448abf00 8d9474106b084110862c08dacd5b8f39 e753dd90d925416188b59c798744494a--8d9474106b084110862c08dacd5b8f39 bf9bacd4b9c249e390cf510c6eadddc4 8d9474106b084110862c08dacd5b8f39--bf9bacd4b9c249e390cf510c6eadddc4 64a028b3ef35424ba470a5139c4930db bf9bacd4b9c249e390cf510c6eadddc4--64a028b3ef35424ba470a5139c4930db 4ae30b56583842f289f0465c3b6de3a7 64a028b3ef35424ba470a5139c4930db--4ae30b56583842f289f0465c3b6de3a7 e126d16df9a94462b4d11208200f58c5 4ae30b56583842f289f0465c3b6de3a7--e126d16df9a94462b4d11208200f58c5 75efc340bfd843b396cc46d2eff8841e e126d16df9a94462b4d11208200f58c5--75efc340bfd843b396cc46d2eff8841e dc94177e36094a20a905ef725baf5774 75efc340bfd843b396cc46d2eff8841e--dc94177e36094a20a905ef725baf5774 27eee2f0bca54b9eac16d764dba26ab2 dc94177e36094a20a905ef725baf5774--27eee2f0bca54b9eac16d764dba26ab2 dbe1ac2206cd4bea9010857da624546c 27eee2f0bca54b9eac16d764dba26ab2--dbe1ac2206cd4bea9010857da624546c cfa37d77817f4ed2a4f59e977c908dd2 dbe1ac2206cd4bea9010857da624546c--cfa37d77817f4ed2a4f59e977c908dd2 37677f5a63f741d48960c4286bd76db7 cfa37d77817f4ed2a4f59e977c908dd2--37677f5a63f741d48960c4286bd76db7 ab69e164c77a45e1bc3090671ea7dfa7 37677f5a63f741d48960c4286bd76db7--ab69e164c77a45e1bc3090671ea7dfa7 f31dcb17164c4ea69a18488ddf88d6b8 ab69e164c77a45e1bc3090671ea7dfa7--f31dcb17164c4ea69a18488ddf88d6b8 35d47471bbc34051ac0e29ef3e1502df f31dcb17164c4ea69a18488ddf88d6b8--35d47471bbc34051ac0e29ef3e1502df 1d7d78c7c871401dab4d76f5f9766cb7 35d47471bbc34051ac0e29ef3e1502df--1d7d78c7c871401dab4d76f5f9766cb7 482178c1cc4f4a429583aae46890a4e2 X 1d7d78c7c871401dab4d76f5f9766cb7--482178c1cc4f4a429583aae46890a4e2 482178c1cc4f4a429583aae46890a4e2--3508e5834c7f4b09bddc5b3736412d2c 14d32601dcc04ba29d4868f9a39bef16 RZ(-1.0*g1) 482178c1cc4f4a429583aae46890a4e2--14d32601dcc04ba29d4868f9a39bef16 a9d8b1beb9dd4208a76414aaa89f4e08 X 14d32601dcc04ba29d4868f9a39bef16--a9d8b1beb9dd4208a76414aaa89f4e08 a9d8b1beb9dd4208a76414aaa89f4e08--1c19f7951cd04e43b492b3ddd05c869d 7cdf6f85506a482c930fec77c87cb124 a9d8b1beb9dd4208a76414aaa89f4e08--7cdf6f85506a482c930fec77c87cb124 8b46bc273e1d4e738e825a0ab1ddb225 7cdf6f85506a482c930fec77c87cb124--8b46bc273e1d4e738e825a0ab1ddb225 79c71be5ec78476d87d8fb2c63a1ec02 8b46bc273e1d4e738e825a0ab1ddb225--79c71be5ec78476d87d8fb2c63a1ec02 1d45051896b441ca8298a139659024a3 79c71be5ec78476d87d8fb2c63a1ec02--1d45051896b441ca8298a139659024a3 99e4722417ec486aa7163e51c55b1629 1d45051896b441ca8298a139659024a3--99e4722417ec486aa7163e51c55b1629 7c1e6060a8fa477a9632d0403fb17129 99e4722417ec486aa7163e51c55b1629--7c1e6060a8fa477a9632d0403fb17129 78f790bbea2a4027bfefdf6bdf2700ae X 7c1e6060a8fa477a9632d0403fb17129--78f790bbea2a4027bfefdf6bdf2700ae 78f790bbea2a4027bfefdf6bdf2700ae--5ff7b01c9280487ab7c07659480b1cd9 13bf8f9ef5fe4525bc53ac57403d5e40 78f790bbea2a4027bfefdf6bdf2700ae--13bf8f9ef5fe4525bc53ac57403d5e40 cfdf47ef00c14ffe9ee9611edeefbff6 13bf8f9ef5fe4525bc53ac57403d5e40--cfdf47ef00c14ffe9ee9611edeefbff6 0f870f82be4a4b259d4f47f291efc5e1 cfdf47ef00c14ffe9ee9611edeefbff6--0f870f82be4a4b259d4f47f291efc5e1 87e6d2b92d964fda9fa532d4edd79e9b 0f870f82be4a4b259d4f47f291efc5e1--87e6d2b92d964fda9fa532d4edd79e9b 4b02418c5e5c452a80b43331162421a7 87e6d2b92d964fda9fa532d4edd79e9b--4b02418c5e5c452a80b43331162421a7 09aadcdeb2014310b8fa90d1d1d8c12c X 4b02418c5e5c452a80b43331162421a7--09aadcdeb2014310b8fa90d1d1d8c12c 09aadcdeb2014310b8fa90d1d1d8c12c--39930836d20c42b78a77cecff4f44765 3323706ce1c3437ab1b9243568e35bae 09aadcdeb2014310b8fa90d1d1d8c12c--3323706ce1c3437ab1b9243568e35bae a0a6b04680b4420580cbe76bc98843b6 3323706ce1c3437ab1b9243568e35bae--a0a6b04680b4420580cbe76bc98843b6 45529e482c97433cb437d156e919c067 a0a6b04680b4420580cbe76bc98843b6--45529e482c97433cb437d156e919c067 38bf7ab116644c23920c83c44f006ab2 45529e482c97433cb437d156e919c067--38bf7ab116644c23920c83c44f006ab2 4d631f075e53465cb6b923f0cc59adcb 38bf7ab116644c23920c83c44f006ab2--4d631f075e53465cb6b923f0cc59adcb 69b18ed062244f9ba93ee8448ed6ea50 X 4d631f075e53465cb6b923f0cc59adcb--69b18ed062244f9ba93ee8448ed6ea50 69b18ed062244f9ba93ee8448ed6ea50--091da713616a4129be37eea30eb38746 53888639c91b471f9c2131ccbc08bf2e RZ(-1.0*g1) 69b18ed062244f9ba93ee8448ed6ea50--53888639c91b471f9c2131ccbc08bf2e 4b2fab1b07d94956b04b9632aa41eb8e X 53888639c91b471f9c2131ccbc08bf2e--4b2fab1b07d94956b04b9632aa41eb8e 4b2fab1b07d94956b04b9632aa41eb8e--02a1608e0a2e4f568b4da4e29be280ee 92f43c3c1d3d4f8eb35be1066e47b091 4b2fab1b07d94956b04b9632aa41eb8e--92f43c3c1d3d4f8eb35be1066e47b091 d7a6b449d4fd44fb86c13a91b63097b4 92f43c3c1d3d4f8eb35be1066e47b091--d7a6b449d4fd44fb86c13a91b63097b4 a7c2a9aca07a48bfb5975ac460a6cb72 d7a6b449d4fd44fb86c13a91b63097b4--a7c2a9aca07a48bfb5975ac460a6cb72 06eb696be4a44c8eb14d553172d25fe4 a7c2a9aca07a48bfb5975ac460a6cb72--06eb696be4a44c8eb14d553172d25fe4 ec210f1a4cd9437ab0ea78dd0f5a8a6a X 06eb696be4a44c8eb14d553172d25fe4--ec210f1a4cd9437ab0ea78dd0f5a8a6a ec210f1a4cd9437ab0ea78dd0f5a8a6a--112ab85fd93c42de877234db4737f3ea 60803e0eb9024e22a2b9dfc0b180e116 ec210f1a4cd9437ab0ea78dd0f5a8a6a--60803e0eb9024e22a2b9dfc0b180e116 b8b8b1db0f66423a90c33e740a58756a 60803e0eb9024e22a2b9dfc0b180e116--b8b8b1db0f66423a90c33e740a58756a 4c142f6f2f844b20b30567911e445656 b8b8b1db0f66423a90c33e740a58756a--4c142f6f2f844b20b30567911e445656 a1f29a0421fd48b6a996bce37c4b77b1 X 4c142f6f2f844b20b30567911e445656--a1f29a0421fd48b6a996bce37c4b77b1 a1f29a0421fd48b6a996bce37c4b77b1--38d1b629da3c4a88a6df650cda7f983c 9967fb2df73147e48fde6e379400eab8 a1f29a0421fd48b6a996bce37c4b77b1--9967fb2df73147e48fde6e379400eab8 10356220ea084684809f5e0f6c812515 9967fb2df73147e48fde6e379400eab8--10356220ea084684809f5e0f6c812515 b45b09e77c5b4ac4b4fca24e826ff0f7 X 10356220ea084684809f5e0f6c812515--b45b09e77c5b4ac4b4fca24e826ff0f7 b45b09e77c5b4ac4b4fca24e826ff0f7--ccf95a1f97ad47ee92932b2300fd881b ec93f7d72bd1453ea1d04e9153415af1 b45b09e77c5b4ac4b4fca24e826ff0f7--ec93f7d72bd1453ea1d04e9153415af1 4306dfb5b6bc402bb276b58e5d2c3bb8 ec93f7d72bd1453ea1d04e9153415af1--4306dfb5b6bc402bb276b58e5d2c3bb8 0cb28add39534dfc82fc190295f6d222 4306dfb5b6bc402bb276b58e5d2c3bb8--0cb28add39534dfc82fc190295f6d222 f0ea3111de4441d7bebedbd361a6b23d X 0cb28add39534dfc82fc190295f6d222--f0ea3111de4441d7bebedbd361a6b23d f0ea3111de4441d7bebedbd361a6b23d--e876541b796340238cae9dffba65081e 9c5383fe73974002a85d3ea9a195c7c5 X f0ea3111de4441d7bebedbd361a6b23d--9c5383fe73974002a85d3ea9a195c7c5 9c5383fe73974002a85d3ea9a195c7c5--861700cba95e4846b8a9f515694103b6 6350e57c39c2461aa131d56f5a3624ff 9c5383fe73974002a85d3ea9a195c7c5--6350e57c39c2461aa131d56f5a3624ff 2cb03b9659004f2a802334a603390244 6350e57c39c2461aa131d56f5a3624ff--2cb03b9659004f2a802334a603390244 e976f2cf1452489c98c20e149785d708 2cb03b9659004f2a802334a603390244--e976f2cf1452489c98c20e149785d708 e5b830e42b71461c93869dfabe2ee809 e976f2cf1452489c98c20e149785d708--e5b830e42b71461c93869dfabe2ee809 99947337698a49508f93105ba3dece79 e5b830e42b71461c93869dfabe2ee809--99947337698a49508f93105ba3dece79 3bf3197d84c44ceca23fb4bba836e0b0 X 99947337698a49508f93105ba3dece79--3bf3197d84c44ceca23fb4bba836e0b0 3bf3197d84c44ceca23fb4bba836e0b0--909a332443d145f2b71bfc3677dccd7b b6b2a80606b24460acb84c8a4db43c0c 3bf3197d84c44ceca23fb4bba836e0b0--b6b2a80606b24460acb84c8a4db43c0c b3652586f1e14898a412489d8df24cf8 b6b2a80606b24460acb84c8a4db43c0c--b3652586f1e14898a412489d8df24cf8 98c31180fb1f409799536dab18c51720 b3652586f1e14898a412489d8df24cf8--98c31180fb1f409799536dab18c51720 0d17334daefe4dbaa4ed9df126e07ad9 98c31180fb1f409799536dab18c51720--0d17334daefe4dbaa4ed9df126e07ad9 d106716f7c5c4c7b864004bed3b4a1f5 0d17334daefe4dbaa4ed9df126e07ad9--d106716f7c5c4c7b864004bed3b4a1f5 1d7a1b245e3945ac9e5092cd922b77e5 d106716f7c5c4c7b864004bed3b4a1f5--1d7a1b245e3945ac9e5092cd922b77e5 a0a6cd463fd349faa5fc5cb7724520d9 1d7a1b245e3945ac9e5092cd922b77e5--a0a6cd463fd349faa5fc5cb7724520d9 f6fee5e0f84f4b5ba4159e58627453df a0a6cd463fd349faa5fc5cb7724520d9--f6fee5e0f84f4b5ba4159e58627453df 9a4a486b1b034597a9b3c781492ff4ab f6fee5e0f84f4b5ba4159e58627453df--9a4a486b1b034597a9b3c781492ff4ab 3c401e9dae4a45b7b576014115e373ef 9a4a486b1b034597a9b3c781492ff4ab--3c401e9dae4a45b7b576014115e373ef 1d999ea24f324f2b96ba7a7b8e983ab6 3c401e9dae4a45b7b576014115e373ef--1d999ea24f324f2b96ba7a7b8e983ab6 8e9e4c7bf03840f29bd8e977de1ba713 RX(b15) 1d999ea24f324f2b96ba7a7b8e983ab6--8e9e4c7bf03840f29bd8e977de1ba713 8e9e4c7bf03840f29bd8e977de1ba713--4b91c2d7d0e640989b7de19e72760d04 b128ba36d86a48dea592240049aabf09 a2bfc02497f34855acc273ad599a1fa4 37077d9ca9364818b61496af0669fa2e--a2bfc02497f34855acc273ad599a1fa4 3c38a5df3cda408b9dfa6a1a9748c63d 7 f9827ae4b6824b55b34ba6bb12fa89d5 a2bfc02497f34855acc273ad599a1fa4--f9827ae4b6824b55b34ba6bb12fa89d5 0b0599b39e9d48cea04c8349a58f1c8c f9827ae4b6824b55b34ba6bb12fa89d5--0b0599b39e9d48cea04c8349a58f1c8c 154895a4eebd44fb8c92327abac22a62 0b0599b39e9d48cea04c8349a58f1c8c--154895a4eebd44fb8c92327abac22a62 de6297916cee4550ab5d3c5f55396f48 154895a4eebd44fb8c92327abac22a62--de6297916cee4550ab5d3c5f55396f48 79c440826a45402fbb240799183602f2 X de6297916cee4550ab5d3c5f55396f48--79c440826a45402fbb240799183602f2 79c440826a45402fbb240799183602f2--4ea0a8a38e934d0d94da352d4e527e89 ca1ff1ccbcb5453089e49d538e9b535f 79c440826a45402fbb240799183602f2--ca1ff1ccbcb5453089e49d538e9b535f d865b46fd61049d9aff3c0186494cfaf ca1ff1ccbcb5453089e49d538e9b535f--d865b46fd61049d9aff3c0186494cfaf b39ed69cd5724073b6f1f24173a6e791 d865b46fd61049d9aff3c0186494cfaf--b39ed69cd5724073b6f1f24173a6e791 d04dbaf3c9ba4fb39cecab2a5f4eef0d X b39ed69cd5724073b6f1f24173a6e791--d04dbaf3c9ba4fb39cecab2a5f4eef0d d04dbaf3c9ba4fb39cecab2a5f4eef0d--8ef5978dc64849918792eae268058cea 774187922c5349ff9eb0ca895c78aa9f d04dbaf3c9ba4fb39cecab2a5f4eef0d--774187922c5349ff9eb0ca895c78aa9f fa55e4e48ce74abdba4e8f50716e205b 774187922c5349ff9eb0ca895c78aa9f--fa55e4e48ce74abdba4e8f50716e205b 3fd3fa364a9843d58cf58e39abf97f32 fa55e4e48ce74abdba4e8f50716e205b--3fd3fa364a9843d58cf58e39abf97f32 70e4e2d1cdf64cf1a2a43dcf442f374e 3fd3fa364a9843d58cf58e39abf97f32--70e4e2d1cdf64cf1a2a43dcf442f374e 892e5792d83f4315ad5b2d0b15f43477 70e4e2d1cdf64cf1a2a43dcf442f374e--892e5792d83f4315ad5b2d0b15f43477 117f48764af84ce9b4e3dbc2e61c2650 892e5792d83f4315ad5b2d0b15f43477--117f48764af84ce9b4e3dbc2e61c2650 074fce2e97d44a3fa87a069573166da6 117f48764af84ce9b4e3dbc2e61c2650--074fce2e97d44a3fa87a069573166da6 36507e506c2b4842a328873d2cd399be 074fce2e97d44a3fa87a069573166da6--36507e506c2b4842a328873d2cd399be ffcf3e805ec94c7e9849469cf5b345bb 36507e506c2b4842a328873d2cd399be--ffcf3e805ec94c7e9849469cf5b345bb 87c89425dc9944e8b0b510624799fadc ffcf3e805ec94c7e9849469cf5b345bb--87c89425dc9944e8b0b510624799fadc 50fb6950f7884e129a7d4fc0064d618a 87c89425dc9944e8b0b510624799fadc--50fb6950f7884e129a7d4fc0064d618a 937ff6a9300b4a7ca34bf9b62f2ab68e 50fb6950f7884e129a7d4fc0064d618a--937ff6a9300b4a7ca34bf9b62f2ab68e d604ce3d3bd44bb3b7912ace9c390e34 937ff6a9300b4a7ca34bf9b62f2ab68e--d604ce3d3bd44bb3b7912ace9c390e34 e01e75e560154d95a8670b1ff8e3b6a8 d604ce3d3bd44bb3b7912ace9c390e34--e01e75e560154d95a8670b1ff8e3b6a8 ff51d62226c54b5aa71cbd1e4fc71930 e01e75e560154d95a8670b1ff8e3b6a8--ff51d62226c54b5aa71cbd1e4fc71930 86953e792e0944748e1e4872cffb7e2d ff51d62226c54b5aa71cbd1e4fc71930--86953e792e0944748e1e4872cffb7e2d a7f273d4bcf94e71a3524a0a782a04dc 86953e792e0944748e1e4872cffb7e2d--a7f273d4bcf94e71a3524a0a782a04dc 540356e7b7d94909a549cc0ab8648869 a7f273d4bcf94e71a3524a0a782a04dc--540356e7b7d94909a549cc0ab8648869 e292d6457a6541f3ad6c18e450f62f78 540356e7b7d94909a549cc0ab8648869--e292d6457a6541f3ad6c18e450f62f78 85fb23e568984b108e812c6c1026b272 e292d6457a6541f3ad6c18e450f62f78--85fb23e568984b108e812c6c1026b272 d78e2603cc794f089dd69782ac1209cf 85fb23e568984b108e812c6c1026b272--d78e2603cc794f089dd69782ac1209cf 098e89bf8f574b7fad28b32902c5a2f6 d78e2603cc794f089dd69782ac1209cf--098e89bf8f574b7fad28b32902c5a2f6 3c35aab7d6ca4fe1826c65beb4566e1b X 098e89bf8f574b7fad28b32902c5a2f6--3c35aab7d6ca4fe1826c65beb4566e1b 3c35aab7d6ca4fe1826c65beb4566e1b--a06f50b630da4cf3a27102a648d601a6 a724912811334f72a24d4612157dd405 RZ(-1.0*g0) 3c35aab7d6ca4fe1826c65beb4566e1b--a724912811334f72a24d4612157dd405 16b7070ae1f5461fa258ca373350d08b X a724912811334f72a24d4612157dd405--16b7070ae1f5461fa258ca373350d08b 16b7070ae1f5461fa258ca373350d08b--4db37c7773684d769de350023ddfd9dd 0f545f1f8a834641984e0d930493c0d3 16b7070ae1f5461fa258ca373350d08b--0f545f1f8a834641984e0d930493c0d3 a982f04dac254fb98c458828fafee6db 0f545f1f8a834641984e0d930493c0d3--a982f04dac254fb98c458828fafee6db 0932707cdcb7403a9061fd01e6f721ce a982f04dac254fb98c458828fafee6db--0932707cdcb7403a9061fd01e6f721ce c978fa2e58344cd1b9647d18a8abeaea 0932707cdcb7403a9061fd01e6f721ce--c978fa2e58344cd1b9647d18a8abeaea 41afbbf8e9934654b61b52d04200a531 c978fa2e58344cd1b9647d18a8abeaea--41afbbf8e9934654b61b52d04200a531 13745edd6b834b32bf815873a6795a50 41afbbf8e9934654b61b52d04200a531--13745edd6b834b32bf815873a6795a50 2b0cb168398d4d49a14aefc3a4386c3d 13745edd6b834b32bf815873a6795a50--2b0cb168398d4d49a14aefc3a4386c3d 14ab92857b6348d6afe3678c8bac1e00 2b0cb168398d4d49a14aefc3a4386c3d--14ab92857b6348d6afe3678c8bac1e00 d74ebac2a33e43e69baedd87e237ba7a 14ab92857b6348d6afe3678c8bac1e00--d74ebac2a33e43e69baedd87e237ba7a d247b1be74254f5f8bbddc66944713e4 d74ebac2a33e43e69baedd87e237ba7a--d247b1be74254f5f8bbddc66944713e4 0673909dbdb744fe9650c91fa326eac9 d247b1be74254f5f8bbddc66944713e4--0673909dbdb744fe9650c91fa326eac9 23cb27f27a424cb3aa9e7b45a2e0da8b 0673909dbdb744fe9650c91fa326eac9--23cb27f27a424cb3aa9e7b45a2e0da8b 8b6005dc5070412e8847a93cb8333e8a 23cb27f27a424cb3aa9e7b45a2e0da8b--8b6005dc5070412e8847a93cb8333e8a 24cf83e67fc247f0b999a9b235c2f42b 8b6005dc5070412e8847a93cb8333e8a--24cf83e67fc247f0b999a9b235c2f42b 5e86c7fa3cf74b7ea983a92f2f1908ce 24cf83e67fc247f0b999a9b235c2f42b--5e86c7fa3cf74b7ea983a92f2f1908ce 47ecf4c734c74663888d0b6479159e3e 5e86c7fa3cf74b7ea983a92f2f1908ce--47ecf4c734c74663888d0b6479159e3e 4a61db96fa11437180fc2ddd23840aaa 47ecf4c734c74663888d0b6479159e3e--4a61db96fa11437180fc2ddd23840aaa 925997da65514e269deb3ffcdf9071fe 4a61db96fa11437180fc2ddd23840aaa--925997da65514e269deb3ffcdf9071fe 52dac751332e4621a6fc893d7ed7ea51 925997da65514e269deb3ffcdf9071fe--52dac751332e4621a6fc893d7ed7ea51 8eb5c3171c1448449ca6f01761c383f7 52dac751332e4621a6fc893d7ed7ea51--8eb5c3171c1448449ca6f01761c383f7 912ad635a656488b9b5e67b347945e80 8eb5c3171c1448449ca6f01761c383f7--912ad635a656488b9b5e67b347945e80 ce6a49f2ca1643259444461db51f6214 912ad635a656488b9b5e67b347945e80--ce6a49f2ca1643259444461db51f6214 6e4f314a4b434d3199713bfe182ecdd0 ce6a49f2ca1643259444461db51f6214--6e4f314a4b434d3199713bfe182ecdd0 dd3e0c1989044f499535aafee018cfc6 6e4f314a4b434d3199713bfe182ecdd0--dd3e0c1989044f499535aafee018cfc6 060fe907bad1474a853433f803deb447 dd3e0c1989044f499535aafee018cfc6--060fe907bad1474a853433f803deb447 b776707993b14598b9754e87e6bb0329 060fe907bad1474a853433f803deb447--b776707993b14598b9754e87e6bb0329 6fa0624ca3a449ac95b758f10e5f2b56 X b776707993b14598b9754e87e6bb0329--6fa0624ca3a449ac95b758f10e5f2b56 6fa0624ca3a449ac95b758f10e5f2b56--9e3dc71a326c44db87b3f06eda54b165 d9c05f93553d4132bf111740004961f2 6fa0624ca3a449ac95b758f10e5f2b56--d9c05f93553d4132bf111740004961f2 22ceb138e71541febe8eed1354c4db2c d9c05f93553d4132bf111740004961f2--22ceb138e71541febe8eed1354c4db2c 77d3bdd98000493585230a3fdd93d21a 22ceb138e71541febe8eed1354c4db2c--77d3bdd98000493585230a3fdd93d21a 0e305fefabd340b3a00d3bbfd1ca0146 X 77d3bdd98000493585230a3fdd93d21a--0e305fefabd340b3a00d3bbfd1ca0146 0e305fefabd340b3a00d3bbfd1ca0146--220a48663f414a4b8fafd9a81eb65361 279f43fc9c8841aab8f358253f5e1fd1 0e305fefabd340b3a00d3bbfd1ca0146--279f43fc9c8841aab8f358253f5e1fd1 f06aeec9e0304064a33d11e556899a0b 279f43fc9c8841aab8f358253f5e1fd1--f06aeec9e0304064a33d11e556899a0b 5d503bc62f4e44bfb52923d0950bf12c f06aeec9e0304064a33d11e556899a0b--5d503bc62f4e44bfb52923d0950bf12c aa829432819849de908901b8bba64c25 5d503bc62f4e44bfb52923d0950bf12c--aa829432819849de908901b8bba64c25 bce5ed3144124368958725b407d54a5d aa829432819849de908901b8bba64c25--bce5ed3144124368958725b407d54a5d 3b20057957ba4d8d9db903616650c35c bce5ed3144124368958725b407d54a5d--3b20057957ba4d8d9db903616650c35c f534b009bc1644f09502dfda1e0fcc9c 3b20057957ba4d8d9db903616650c35c--f534b009bc1644f09502dfda1e0fcc9c a2c5e8a045c14ed497719545b22e7f0f f534b009bc1644f09502dfda1e0fcc9c--a2c5e8a045c14ed497719545b22e7f0f e3c89789560544fe8d695fab620c6cfa a2c5e8a045c14ed497719545b22e7f0f--e3c89789560544fe8d695fab620c6cfa a7dd484ea01143878ac84505889299d5 e3c89789560544fe8d695fab620c6cfa--a7dd484ea01143878ac84505889299d5 ab158bf3b4104436b0edb1cc1ab6f704 a7dd484ea01143878ac84505889299d5--ab158bf3b4104436b0edb1cc1ab6f704 eb58f40fb49a4955a4e86731c413ac4f ab158bf3b4104436b0edb1cc1ab6f704--eb58f40fb49a4955a4e86731c413ac4f 10bf9bf8c38b436c992e5d832d02d9f5 eb58f40fb49a4955a4e86731c413ac4f--10bf9bf8c38b436c992e5d832d02d9f5 0cabb5dd492a4f2eb98ac2a0235e4dda 10bf9bf8c38b436c992e5d832d02d9f5--0cabb5dd492a4f2eb98ac2a0235e4dda 4ba7d5b5e42648fab1767237a4e6ab9f X 0cabb5dd492a4f2eb98ac2a0235e4dda--4ba7d5b5e42648fab1767237a4e6ab9f 4ba7d5b5e42648fab1767237a4e6ab9f--fedd9a78124f4a89875d3cfa0cfd5e7b 15dafed762e54683b4e778e241728d26 RZ(-1.0*g0) 4ba7d5b5e42648fab1767237a4e6ab9f--15dafed762e54683b4e778e241728d26 f0b0ac2b5190445cb7f8fe7515464c9a X 15dafed762e54683b4e778e241728d26--f0b0ac2b5190445cb7f8fe7515464c9a f0b0ac2b5190445cb7f8fe7515464c9a--ea1e9559adf545cfaedaf41822552732 c7a971e3240b4915a1e858861f5c27a4 f0b0ac2b5190445cb7f8fe7515464c9a--c7a971e3240b4915a1e858861f5c27a4 3a4931ee41f64837a841843e6cbb49e5 c7a971e3240b4915a1e858861f5c27a4--3a4931ee41f64837a841843e6cbb49e5 5ede5469b6884a9baab6b50f2503af36 3a4931ee41f64837a841843e6cbb49e5--5ede5469b6884a9baab6b50f2503af36 49ce66b25495416e8ba1030f7d71d717 5ede5469b6884a9baab6b50f2503af36--49ce66b25495416e8ba1030f7d71d717 c156f04cfaab45fd8e58377fa08aee37 X 49ce66b25495416e8ba1030f7d71d717--c156f04cfaab45fd8e58377fa08aee37 c156f04cfaab45fd8e58377fa08aee37--cf1077b93f3f4f828fe39de05c326516 54908d78e1b0420eb940b1c0ae7538be RZ(-1.0*g0) c156f04cfaab45fd8e58377fa08aee37--54908d78e1b0420eb940b1c0ae7538be d48ee81e5b56452f835345242fd6d35c X 54908d78e1b0420eb940b1c0ae7538be--d48ee81e5b56452f835345242fd6d35c d48ee81e5b56452f835345242fd6d35c--6bf42b8738dd4e33b11154c70a449091 aca986362b834f9ea6985614345aff19 d48ee81e5b56452f835345242fd6d35c--aca986362b834f9ea6985614345aff19 cb650d9f9c52460aaedf5f6504b45afb aca986362b834f9ea6985614345aff19--cb650d9f9c52460aaedf5f6504b45afb c316250a735e40f7a0ea8f8dac09b1b1 X cb650d9f9c52460aaedf5f6504b45afb--c316250a735e40f7a0ea8f8dac09b1b1 c316250a735e40f7a0ea8f8dac09b1b1--288ab2f5f4e844f09519d4c028ce5b5a 32ebd7645b064c32a8b51dc2dd141ec4 c316250a735e40f7a0ea8f8dac09b1b1--32ebd7645b064c32a8b51dc2dd141ec4 abf437cefd2a4421a330b68c4595f17a 32ebd7645b064c32a8b51dc2dd141ec4--abf437cefd2a4421a330b68c4595f17a bcb9aa5cae944a8db894f7667c065ee5 abf437cefd2a4421a330b68c4595f17a--bcb9aa5cae944a8db894f7667c065ee5 506a86ea996648bab60df08d2590b2aa X bcb9aa5cae944a8db894f7667c065ee5--506a86ea996648bab60df08d2590b2aa 506a86ea996648bab60df08d2590b2aa--0d737243f0b64170beec1bd97cb2e4a1 cc88af9d761a4c00bb0d93bb29f2ac5d 506a86ea996648bab60df08d2590b2aa--cc88af9d761a4c00bb0d93bb29f2ac5d f9ec4e8ab7ce48178fda53a83efb8e8e X cc88af9d761a4c00bb0d93bb29f2ac5d--f9ec4e8ab7ce48178fda53a83efb8e8e f9ec4e8ab7ce48178fda53a83efb8e8e--8a7ad1ae61b94c968e9e5f534097f147 6c9fd041cad04a048f1fc579ee2076e9 RZ(-1.0*g0) f9ec4e8ab7ce48178fda53a83efb8e8e--6c9fd041cad04a048f1fc579ee2076e9 0964395862094b7e82a641d171f611eb X 6c9fd041cad04a048f1fc579ee2076e9--0964395862094b7e82a641d171f611eb 0964395862094b7e82a641d171f611eb--74a24543660d40a4b20963dc1a65cd36 199971de666c4a7e9ab7e0cf4932dee6 X 0964395862094b7e82a641d171f611eb--199971de666c4a7e9ab7e0cf4932dee6 199971de666c4a7e9ab7e0cf4932dee6--0728721b25c04f9a9a9f2fe8a7b6d2b6 ec72e3bc1e1c4daab3092d2b971d8a2f 199971de666c4a7e9ab7e0cf4932dee6--ec72e3bc1e1c4daab3092d2b971d8a2f 04376a2c8d61483c816e3c3f98339389 ec72e3bc1e1c4daab3092d2b971d8a2f--04376a2c8d61483c816e3c3f98339389 7b24403d5d3e4ba685ff8df8ae303274 04376a2c8d61483c816e3c3f98339389--7b24403d5d3e4ba685ff8df8ae303274 39b24a786f5d48859c3ded0b9617cbe2 X 7b24403d5d3e4ba685ff8df8ae303274--39b24a786f5d48859c3ded0b9617cbe2 39b24a786f5d48859c3ded0b9617cbe2--019c1078e10c4e0e91b0e23638b95fd7 6546cd029f0545dda9973b12b54d92fa 39b24a786f5d48859c3ded0b9617cbe2--6546cd029f0545dda9973b12b54d92fa 5088c5819b6743958d9f952b0d793cff 6546cd029f0545dda9973b12b54d92fa--5088c5819b6743958d9f952b0d793cff 0fb52634f96547038d7808f27d75527f 5088c5819b6743958d9f952b0d793cff--0fb52634f96547038d7808f27d75527f 1d157d6c6c3c4273b338c970746b785b RX(b06) 0fb52634f96547038d7808f27d75527f--1d157d6c6c3c4273b338c970746b785b 75a784f891f547c5b72f461650277c21 1d157d6c6c3c4273b338c970746b785b--75a784f891f547c5b72f461650277c21 7481c6c1af0945ba832c46c98befe9a2 75a784f891f547c5b72f461650277c21--7481c6c1af0945ba832c46c98befe9a2 804e997ffaa74a6c91d22edfae5eb7f3 7481c6c1af0945ba832c46c98befe9a2--804e997ffaa74a6c91d22edfae5eb7f3 6a8afcf75c2b47eb9b0da17367eaf4a9 804e997ffaa74a6c91d22edfae5eb7f3--6a8afcf75c2b47eb9b0da17367eaf4a9 4a5a78aaeecc433c93a56ff1b288ed1c 6a8afcf75c2b47eb9b0da17367eaf4a9--4a5a78aaeecc433c93a56ff1b288ed1c 79cc0d240cf74f0aa5e976752bb4a71f X 4a5a78aaeecc433c93a56ff1b288ed1c--79cc0d240cf74f0aa5e976752bb4a71f 79cc0d240cf74f0aa5e976752bb4a71f--4fde3385f24146449b2988da3aee487e 5f31fc8ed6d047e684aa289cc341282e 79cc0d240cf74f0aa5e976752bb4a71f--5f31fc8ed6d047e684aa289cc341282e 0eb552679437432197db28ef271d5a06 5f31fc8ed6d047e684aa289cc341282e--0eb552679437432197db28ef271d5a06 507423215a3746a1842a77f39f7a08af 0eb552679437432197db28ef271d5a06--507423215a3746a1842a77f39f7a08af e0d8ce02e58d4ae8aadbd1c70114b16e X 507423215a3746a1842a77f39f7a08af--e0d8ce02e58d4ae8aadbd1c70114b16e e0d8ce02e58d4ae8aadbd1c70114b16e--b98ce6bc3e6b49319fc656f104dcc1ef 79c404ddf9624581855ddea5127fa9d0 e0d8ce02e58d4ae8aadbd1c70114b16e--79c404ddf9624581855ddea5127fa9d0 d201f77933d04688b4a6e5f1352ef475 79c404ddf9624581855ddea5127fa9d0--d201f77933d04688b4a6e5f1352ef475 f6de8f2edf7f4445b7374b0ce440d5de d201f77933d04688b4a6e5f1352ef475--f6de8f2edf7f4445b7374b0ce440d5de 98bfb1a297e144a888bf37dad9ed0464 f6de8f2edf7f4445b7374b0ce440d5de--98bfb1a297e144a888bf37dad9ed0464 e1e2eb81087f4b1facec2b7766acd2eb 98bfb1a297e144a888bf37dad9ed0464--e1e2eb81087f4b1facec2b7766acd2eb 729143c06c744735ad16160c7f357e58 e1e2eb81087f4b1facec2b7766acd2eb--729143c06c744735ad16160c7f357e58 e95e92bc5c6c41b0905e02d5d55eb30d 729143c06c744735ad16160c7f357e58--e95e92bc5c6c41b0905e02d5d55eb30d aefd192ed3d14e749cf0954b44075927 e95e92bc5c6c41b0905e02d5d55eb30d--aefd192ed3d14e749cf0954b44075927 962d1e7c0c7446489c5ac57d719ad357 aefd192ed3d14e749cf0954b44075927--962d1e7c0c7446489c5ac57d719ad357 9c91cfbf7faa48a29a700b8494a89c32 962d1e7c0c7446489c5ac57d719ad357--9c91cfbf7faa48a29a700b8494a89c32 0f0caddc1b97434ea5c31910a54ae7c6 9c91cfbf7faa48a29a700b8494a89c32--0f0caddc1b97434ea5c31910a54ae7c6 aa26f10db910452589af2abd05e00a00 0f0caddc1b97434ea5c31910a54ae7c6--aa26f10db910452589af2abd05e00a00 101b16ce46b245b4ba93fbaf20297100 aa26f10db910452589af2abd05e00a00--101b16ce46b245b4ba93fbaf20297100 be1f3c988c8240ab8c934da2290087de 101b16ce46b245b4ba93fbaf20297100--be1f3c988c8240ab8c934da2290087de 58515d86968349318ed8a2bad2846773 be1f3c988c8240ab8c934da2290087de--58515d86968349318ed8a2bad2846773 80d148cf8f29427c81ed5c0374cec9c9 58515d86968349318ed8a2bad2846773--80d148cf8f29427c81ed5c0374cec9c9 736ab95fa8614840a1a3130b8c1df3e5 80d148cf8f29427c81ed5c0374cec9c9--736ab95fa8614840a1a3130b8c1df3e5 4a3588a064c64116bd042f5a3663d460 736ab95fa8614840a1a3130b8c1df3e5--4a3588a064c64116bd042f5a3663d460 290db21f1f5c4140b1f6f172265d4ec7 4a3588a064c64116bd042f5a3663d460--290db21f1f5c4140b1f6f172265d4ec7 7127fc7e768d46a8b47d1729ce647013 290db21f1f5c4140b1f6f172265d4ec7--7127fc7e768d46a8b47d1729ce647013 5540ca2a7e72485e8b5614ade40cdb58 7127fc7e768d46a8b47d1729ce647013--5540ca2a7e72485e8b5614ade40cdb58 9c443a61ede04224bb7a1fad61df3c95 5540ca2a7e72485e8b5614ade40cdb58--9c443a61ede04224bb7a1fad61df3c95 3739ee83483e48a68ec902465dd40905 X 9c443a61ede04224bb7a1fad61df3c95--3739ee83483e48a68ec902465dd40905 3739ee83483e48a68ec902465dd40905--6eac9f7db5fd4867aa37f8a773216630 99fffbbf384e4d0294d8fa9b442661a0 RZ(-1.0*g1) 3739ee83483e48a68ec902465dd40905--99fffbbf384e4d0294d8fa9b442661a0 c8de64de4d384935a497f32d11697824 X 99fffbbf384e4d0294d8fa9b442661a0--c8de64de4d384935a497f32d11697824 c8de64de4d384935a497f32d11697824--c66daf8657084811a85e8a6abac6d4d5 e794b71f15e34f78bddf6ce93317ca37 c8de64de4d384935a497f32d11697824--e794b71f15e34f78bddf6ce93317ca37 3bed35b8f0ee45bea9970df4282cf72e e794b71f15e34f78bddf6ce93317ca37--3bed35b8f0ee45bea9970df4282cf72e 4cd2a2e6ca0a4eb994d0a134d4be336b 3bed35b8f0ee45bea9970df4282cf72e--4cd2a2e6ca0a4eb994d0a134d4be336b 7a69e1e0e0fe4b7c90586c63a0d3fc13 4cd2a2e6ca0a4eb994d0a134d4be336b--7a69e1e0e0fe4b7c90586c63a0d3fc13 89129ef9da8e421fabe54bdb7cb9f821 7a69e1e0e0fe4b7c90586c63a0d3fc13--89129ef9da8e421fabe54bdb7cb9f821 883105a2362c4879ab83cd316d0fc4c4 89129ef9da8e421fabe54bdb7cb9f821--883105a2362c4879ab83cd316d0fc4c4 0d473d8667944dc0ae150c91a05a1c7a 883105a2362c4879ab83cd316d0fc4c4--0d473d8667944dc0ae150c91a05a1c7a 417cb886f8bd4356ad38d8f4342589b2 0d473d8667944dc0ae150c91a05a1c7a--417cb886f8bd4356ad38d8f4342589b2 0476460f5ee34d108b24df0752b056ae 417cb886f8bd4356ad38d8f4342589b2--0476460f5ee34d108b24df0752b056ae 875a5969916a4365aac0780b15e38fb9 0476460f5ee34d108b24df0752b056ae--875a5969916a4365aac0780b15e38fb9 767ed405d4664471ba9c2a6eb5908023 875a5969916a4365aac0780b15e38fb9--767ed405d4664471ba9c2a6eb5908023 0dc3631832eb4a41bc4f31a490af235b 767ed405d4664471ba9c2a6eb5908023--0dc3631832eb4a41bc4f31a490af235b a2e844f69d414a3ea6128ce53c332c68 0dc3631832eb4a41bc4f31a490af235b--a2e844f69d414a3ea6128ce53c332c68 1a38125e2eb34fe48d78f30949adffac a2e844f69d414a3ea6128ce53c332c68--1a38125e2eb34fe48d78f30949adffac 5fd80150a4054e2092498235f6e3105d 1a38125e2eb34fe48d78f30949adffac--5fd80150a4054e2092498235f6e3105d 9f046ea96ab94bcaaba2216ff50a4c8f 5fd80150a4054e2092498235f6e3105d--9f046ea96ab94bcaaba2216ff50a4c8f af22214b638e43279f67f14a2c9e591c 9f046ea96ab94bcaaba2216ff50a4c8f--af22214b638e43279f67f14a2c9e591c 5db53c871d5244c4af1e73efb5591548 af22214b638e43279f67f14a2c9e591c--5db53c871d5244c4af1e73efb5591548 ba328077429f454f86cfc0e9a39df058 5db53c871d5244c4af1e73efb5591548--ba328077429f454f86cfc0e9a39df058 4dfc0064fd5c44d7adbb1cec158b5938 ba328077429f454f86cfc0e9a39df058--4dfc0064fd5c44d7adbb1cec158b5938 3240276495dc4a64a5c691544bcedc7d 4dfc0064fd5c44d7adbb1cec158b5938--3240276495dc4a64a5c691544bcedc7d ae6158073fd94fcaa4e611023a22ff91 3240276495dc4a64a5c691544bcedc7d--ae6158073fd94fcaa4e611023a22ff91 7da2d668cab74352a317e62b719c10e5 ae6158073fd94fcaa4e611023a22ff91--7da2d668cab74352a317e62b719c10e5 4a09a4f840c54e4fac93ec1a6a062545 7da2d668cab74352a317e62b719c10e5--4a09a4f840c54e4fac93ec1a6a062545 aea580aec3f14959b3f193b0a40ca4de 4a09a4f840c54e4fac93ec1a6a062545--aea580aec3f14959b3f193b0a40ca4de 8db7877eb9e04b6a989c49971bfa8f48 aea580aec3f14959b3f193b0a40ca4de--8db7877eb9e04b6a989c49971bfa8f48 b49805261320401ca24c3667c4778960 X 8db7877eb9e04b6a989c49971bfa8f48--b49805261320401ca24c3667c4778960 b49805261320401ca24c3667c4778960--13bf8f9ef5fe4525bc53ac57403d5e40 8fda540eecfb422a8918c80775d5099c b49805261320401ca24c3667c4778960--8fda540eecfb422a8918c80775d5099c 6d8962a5e32e4982b0705de2e9f21178 8fda540eecfb422a8918c80775d5099c--6d8962a5e32e4982b0705de2e9f21178 403343e7bb5d450fa59dd6c6d7fbc9f1 6d8962a5e32e4982b0705de2e9f21178--403343e7bb5d450fa59dd6c6d7fbc9f1 edf5b522ea344a96ab7cf2da18b87140 X 403343e7bb5d450fa59dd6c6d7fbc9f1--edf5b522ea344a96ab7cf2da18b87140 edf5b522ea344a96ab7cf2da18b87140--4b02418c5e5c452a80b43331162421a7 418d8478a2664c049c7bf0cb6a864a12 edf5b522ea344a96ab7cf2da18b87140--418d8478a2664c049c7bf0cb6a864a12 e067a509bed84c03b9ff4e5e89b42ce7 418d8478a2664c049c7bf0cb6a864a12--e067a509bed84c03b9ff4e5e89b42ce7 16d311aa7211489dbefdd92e734a5a08 e067a509bed84c03b9ff4e5e89b42ce7--16d311aa7211489dbefdd92e734a5a08 0b59f6e14fde4ff88bfeb89c6b83f108 16d311aa7211489dbefdd92e734a5a08--0b59f6e14fde4ff88bfeb89c6b83f108 93f0237006d642928dbad0d75ae28c8b 0b59f6e14fde4ff88bfeb89c6b83f108--93f0237006d642928dbad0d75ae28c8b 534ebcb3fb304252bda8cd2f1d3709a7 93f0237006d642928dbad0d75ae28c8b--534ebcb3fb304252bda8cd2f1d3709a7 853e1e90de80467382b44648391c75d2 534ebcb3fb304252bda8cd2f1d3709a7--853e1e90de80467382b44648391c75d2 830b2b21e466493185357d5d40fa4675 853e1e90de80467382b44648391c75d2--830b2b21e466493185357d5d40fa4675 1243ddb82b09460da0ee016de023bbe9 830b2b21e466493185357d5d40fa4675--1243ddb82b09460da0ee016de023bbe9 7214e3e000774dde82c60aaddbcfcd89 1243ddb82b09460da0ee016de023bbe9--7214e3e000774dde82c60aaddbcfcd89 fed7450388364399a6974a74e29f8a42 7214e3e000774dde82c60aaddbcfcd89--fed7450388364399a6974a74e29f8a42 58e80791374844c09337f8cdf4aeefea fed7450388364399a6974a74e29f8a42--58e80791374844c09337f8cdf4aeefea d47be8b33ec243eb89a8b8d557600c3c 58e80791374844c09337f8cdf4aeefea--d47be8b33ec243eb89a8b8d557600c3c 3a6a36a3b4ed44cab8e02301a5ee92f7 d47be8b33ec243eb89a8b8d557600c3c--3a6a36a3b4ed44cab8e02301a5ee92f7 f06a0bbf443b485baca9e3ba423096f8 X 3a6a36a3b4ed44cab8e02301a5ee92f7--f06a0bbf443b485baca9e3ba423096f8 f06a0bbf443b485baca9e3ba423096f8--60803e0eb9024e22a2b9dfc0b180e116 db250bd0d328497d856bd5d57fc3ed41 RZ(-1.0*g1) f06a0bbf443b485baca9e3ba423096f8--db250bd0d328497d856bd5d57fc3ed41 e166ab8df09549948852207fa1378e5f X db250bd0d328497d856bd5d57fc3ed41--e166ab8df09549948852207fa1378e5f e166ab8df09549948852207fa1378e5f--4c142f6f2f844b20b30567911e445656 fb5cc7f610dc40789b0567cb1bb57917 e166ab8df09549948852207fa1378e5f--fb5cc7f610dc40789b0567cb1bb57917 92029fcbb2cb4ce58f00eaf715fdc2f4 fb5cc7f610dc40789b0567cb1bb57917--92029fcbb2cb4ce58f00eaf715fdc2f4 8f13fd325f4c4dd19d74d7dc9c062273 92029fcbb2cb4ce58f00eaf715fdc2f4--8f13fd325f4c4dd19d74d7dc9c062273 7863264c6d9e4e43aaa1b706f1c86c4c 8f13fd325f4c4dd19d74d7dc9c062273--7863264c6d9e4e43aaa1b706f1c86c4c d8687d49fd3043b3a21a4b502c4f0068 X 7863264c6d9e4e43aaa1b706f1c86c4c--d8687d49fd3043b3a21a4b502c4f0068 d8687d49fd3043b3a21a4b502c4f0068--ec93f7d72bd1453ea1d04e9153415af1 a7f3c4a66e9b4413a110a99a00675bec RZ(-1.0*g1) d8687d49fd3043b3a21a4b502c4f0068--a7f3c4a66e9b4413a110a99a00675bec 71394ece6f2f47cab4962c2a8bb9052f X a7f3c4a66e9b4413a110a99a00675bec--71394ece6f2f47cab4962c2a8bb9052f 71394ece6f2f47cab4962c2a8bb9052f--0cb28add39534dfc82fc190295f6d222 ca6e7dfe102a482997c5636a854fb927 71394ece6f2f47cab4962c2a8bb9052f--ca6e7dfe102a482997c5636a854fb927 4cf8d87255aa45f5bbb8780d07b81f11 ca6e7dfe102a482997c5636a854fb927--4cf8d87255aa45f5bbb8780d07b81f11 64466345236543518cfea466b36571d7 X 4cf8d87255aa45f5bbb8780d07b81f11--64466345236543518cfea466b36571d7 64466345236543518cfea466b36571d7--6350e57c39c2461aa131d56f5a3624ff 8beff87709344929872740ca1c177072 64466345236543518cfea466b36571d7--8beff87709344929872740ca1c177072 e9d938c98bb44d38a275e68da7d851ac 8beff87709344929872740ca1c177072--e9d938c98bb44d38a275e68da7d851ac bdf05dd316d142cca028d40f998470cd e9d938c98bb44d38a275e68da7d851ac--bdf05dd316d142cca028d40f998470cd d6180e6b82594e66b05c7abdb6a8731f X bdf05dd316d142cca028d40f998470cd--d6180e6b82594e66b05c7abdb6a8731f d6180e6b82594e66b05c7abdb6a8731f--99947337698a49508f93105ba3dece79 c12f10bbcbe34b96a628f1dc5d705254 d6180e6b82594e66b05c7abdb6a8731f--c12f10bbcbe34b96a628f1dc5d705254 3bdf849ccedc451aaddca69fa6d72b49 X c12f10bbcbe34b96a628f1dc5d705254--3bdf849ccedc451aaddca69fa6d72b49 3bdf849ccedc451aaddca69fa6d72b49--b6b2a80606b24460acb84c8a4db43c0c 82b7f165a1114640b85c1e7546fcb376 RZ(-1.0*g1) 3bdf849ccedc451aaddca69fa6d72b49--82b7f165a1114640b85c1e7546fcb376 365d41943f3f46739997144d4f0d3dac X 82b7f165a1114640b85c1e7546fcb376--365d41943f3f46739997144d4f0d3dac 365d41943f3f46739997144d4f0d3dac--98c31180fb1f409799536dab18c51720 cacb066648194632a58f519302a478ee X 365d41943f3f46739997144d4f0d3dac--cacb066648194632a58f519302a478ee cacb066648194632a58f519302a478ee--0d17334daefe4dbaa4ed9df126e07ad9 f6614459e68f459f8e16001ee2a6ab21 cacb066648194632a58f519302a478ee--f6614459e68f459f8e16001ee2a6ab21 275882035ba540958d0aca2bb197b01d f6614459e68f459f8e16001ee2a6ab21--275882035ba540958d0aca2bb197b01d e615a26f4140428a9dd66adcd568c377 275882035ba540958d0aca2bb197b01d--e615a26f4140428a9dd66adcd568c377 54da878948b544f3b3821b716985b0aa X e615a26f4140428a9dd66adcd568c377--54da878948b544f3b3821b716985b0aa 54da878948b544f3b3821b716985b0aa--f6fee5e0f84f4b5ba4159e58627453df c6d28f24eacc46dc841561566e5faf7c 54da878948b544f3b3821b716985b0aa--c6d28f24eacc46dc841561566e5faf7c d9a5b323f27f4d32b29ad2ef64a510da c6d28f24eacc46dc841561566e5faf7c--d9a5b323f27f4d32b29ad2ef64a510da ab7f9780a70448708c6e3c4012bce831 d9a5b323f27f4d32b29ad2ef64a510da--ab7f9780a70448708c6e3c4012bce831 fa87c533afb64154b4b6df9dc9713c5b RX(b16) ab7f9780a70448708c6e3c4012bce831--fa87c533afb64154b4b6df9dc9713c5b fa87c533afb64154b4b6df9dc9713c5b--b128ba36d86a48dea592240049aabf09 6f683a4f4eb441cd91938d725000b741 d22c2195d51340b289510e4346ab52aa 3c38a5df3cda408b9dfa6a1a9748c63d--d22c2195d51340b289510e4346ab52aa 571021ac46ca4e06a6df01cb1865aa13 d22c2195d51340b289510e4346ab52aa--571021ac46ca4e06a6df01cb1865aa13 660cfa5e03c346b98fbcd426bceadaea 571021ac46ca4e06a6df01cb1865aa13--660cfa5e03c346b98fbcd426bceadaea 87d332d42bf84b1bbc32fe4e66addcd5 660cfa5e03c346b98fbcd426bceadaea--87d332d42bf84b1bbc32fe4e66addcd5 e501ca8848294bc4b93d43d97a63dab7 87d332d42bf84b1bbc32fe4e66addcd5--e501ca8848294bc4b93d43d97a63dab7 1e3fb253012841fa83fb30de8d76115b e501ca8848294bc4b93d43d97a63dab7--1e3fb253012841fa83fb30de8d76115b d4c330ecd5a54e328a1a183ae1bc3566 X 1e3fb253012841fa83fb30de8d76115b--d4c330ecd5a54e328a1a183ae1bc3566 d4c330ecd5a54e328a1a183ae1bc3566--ca1ff1ccbcb5453089e49d538e9b535f 3636fe1994104a8b88f36c80a7ec91af RZ(1.0*g0) d4c330ecd5a54e328a1a183ae1bc3566--3636fe1994104a8b88f36c80a7ec91af 411923c72f4b44849cb15d3d0cef0a72 X 3636fe1994104a8b88f36c80a7ec91af--411923c72f4b44849cb15d3d0cef0a72 411923c72f4b44849cb15d3d0cef0a72--b39ed69cd5724073b6f1f24173a6e791 8baf15f0273f4dc0ae8442a22924d29e 411923c72f4b44849cb15d3d0cef0a72--8baf15f0273f4dc0ae8442a22924d29e 197676cfec774f1a87e8851444917a92 8baf15f0273f4dc0ae8442a22924d29e--197676cfec774f1a87e8851444917a92 374ac69d78214e168512dca6eb433a8e 197676cfec774f1a87e8851444917a92--374ac69d78214e168512dca6eb433a8e 74d37e467b2d443f9934d757176bc033 374ac69d78214e168512dca6eb433a8e--74d37e467b2d443f9934d757176bc033 a380e0ca558848548282bbbf150f6fad 74d37e467b2d443f9934d757176bc033--a380e0ca558848548282bbbf150f6fad d8b61b579d644e1d878209d281119985 a380e0ca558848548282bbbf150f6fad--d8b61b579d644e1d878209d281119985 7897da5b52e643f689af813b64f6ffa3 d8b61b579d644e1d878209d281119985--7897da5b52e643f689af813b64f6ffa3 f97026ebe6bd4878894589163588f4b6 7897da5b52e643f689af813b64f6ffa3--f97026ebe6bd4878894589163588f4b6 ba45046ee3714cfa9e90885e81877cb9 f97026ebe6bd4878894589163588f4b6--ba45046ee3714cfa9e90885e81877cb9 9184d31721824b4bbd3156a8aab71601 ba45046ee3714cfa9e90885e81877cb9--9184d31721824b4bbd3156a8aab71601 6ff1f2d9d02f42469eda27c3579ccfe3 9184d31721824b4bbd3156a8aab71601--6ff1f2d9d02f42469eda27c3579ccfe3 6389d49b4e814465b14be6513d139938 6ff1f2d9d02f42469eda27c3579ccfe3--6389d49b4e814465b14be6513d139938 3c689ee4f9ca4edfb59c008e301239f6 6389d49b4e814465b14be6513d139938--3c689ee4f9ca4edfb59c008e301239f6 ecf226b9ee004d5f9b872db29f3eef22 3c689ee4f9ca4edfb59c008e301239f6--ecf226b9ee004d5f9b872db29f3eef22 b292160ea923472090a71cdcd1d386d4 ecf226b9ee004d5f9b872db29f3eef22--b292160ea923472090a71cdcd1d386d4 e039afdef6cf4cf6ac2dc4d459e73e85 b292160ea923472090a71cdcd1d386d4--e039afdef6cf4cf6ac2dc4d459e73e85 6d8fd64e094c4c978e629189e3af2aee e039afdef6cf4cf6ac2dc4d459e73e85--6d8fd64e094c4c978e629189e3af2aee ff460b3513db4ffb8ff96aede8869139 6d8fd64e094c4c978e629189e3af2aee--ff460b3513db4ffb8ff96aede8869139 ba662ceb4de54a23ab0d8b149c5af97d ff460b3513db4ffb8ff96aede8869139--ba662ceb4de54a23ab0d8b149c5af97d 0fe0abb4bc6a4e779c63693ea67d7b70 ba662ceb4de54a23ab0d8b149c5af97d--0fe0abb4bc6a4e779c63693ea67d7b70 276a329f97974f7dbda3c562b4a9375f 0fe0abb4bc6a4e779c63693ea67d7b70--276a329f97974f7dbda3c562b4a9375f d9e663d720264f46b1eb527f65b7bbe4 276a329f97974f7dbda3c562b4a9375f--d9e663d720264f46b1eb527f65b7bbe4 09e1223f5e0c4d8ba90b60b83794a8d8 d9e663d720264f46b1eb527f65b7bbe4--09e1223f5e0c4d8ba90b60b83794a8d8 2649f39652c441638af833046b005d83 09e1223f5e0c4d8ba90b60b83794a8d8--2649f39652c441638af833046b005d83 1120482d517f4201896fddd442918ce7 2649f39652c441638af833046b005d83--1120482d517f4201896fddd442918ce7 98f09c397a0d4435929f093882de4ec5 1120482d517f4201896fddd442918ce7--98f09c397a0d4435929f093882de4ec5 045fca3f15f24fff9a7567f137d6e7df 98f09c397a0d4435929f093882de4ec5--045fca3f15f24fff9a7567f137d6e7df 08067cc40e674bee866db3b85c1b3079 045fca3f15f24fff9a7567f137d6e7df--08067cc40e674bee866db3b85c1b3079 7ea00a49b9f94ea9849d5fc59b3fd5a8 08067cc40e674bee866db3b85c1b3079--7ea00a49b9f94ea9849d5fc59b3fd5a8 70aff836c1a64e29b4b2d3f8502f19e3 7ea00a49b9f94ea9849d5fc59b3fd5a8--70aff836c1a64e29b4b2d3f8502f19e3 3fabf54fa0444a64877b506ca0566ca6 70aff836c1a64e29b4b2d3f8502f19e3--3fabf54fa0444a64877b506ca0566ca6 d48010574ea24ab19ca4f176cf935c96 3fabf54fa0444a64877b506ca0566ca6--d48010574ea24ab19ca4f176cf935c96 5ade87aa1af94befb7bb12c95dfad8f6 d48010574ea24ab19ca4f176cf935c96--5ade87aa1af94befb7bb12c95dfad8f6 cbfdf7b7c0904d69ab69d6ae4be7b8b9 5ade87aa1af94befb7bb12c95dfad8f6--cbfdf7b7c0904d69ab69d6ae4be7b8b9 e21da2cb700b4754a98c351a7feced1b cbfdf7b7c0904d69ab69d6ae4be7b8b9--e21da2cb700b4754a98c351a7feced1b 217a2c4911034673ab18d6e94e668f2d e21da2cb700b4754a98c351a7feced1b--217a2c4911034673ab18d6e94e668f2d 8abd4972b901443c8f18e7e19394f852 217a2c4911034673ab18d6e94e668f2d--8abd4972b901443c8f18e7e19394f852 9b9eb531ea5d49f7a4dde6ed4b2a782b 8abd4972b901443c8f18e7e19394f852--9b9eb531ea5d49f7a4dde6ed4b2a782b 14ab7b6f9fa84817b9de084b52e71153 9b9eb531ea5d49f7a4dde6ed4b2a782b--14ab7b6f9fa84817b9de084b52e71153 96bea5f59d804c77a312ecf4b8c48f63 14ab7b6f9fa84817b9de084b52e71153--96bea5f59d804c77a312ecf4b8c48f63 7aca4484318446cb837a0f48e4954ddc 96bea5f59d804c77a312ecf4b8c48f63--7aca4484318446cb837a0f48e4954ddc a56d0bc2e4b440919158b51a635e74d8 7aca4484318446cb837a0f48e4954ddc--a56d0bc2e4b440919158b51a635e74d8 f47c085c3e4e4706808ed7d17018a8b6 a56d0bc2e4b440919158b51a635e74d8--f47c085c3e4e4706808ed7d17018a8b6 2eb316c0dbfe4f0a8af0d96f34d79b1d f47c085c3e4e4706808ed7d17018a8b6--2eb316c0dbfe4f0a8af0d96f34d79b1d c2b6ede4fa0244d08ba5017b612e3deb 2eb316c0dbfe4f0a8af0d96f34d79b1d--c2b6ede4fa0244d08ba5017b612e3deb 6f78bba9ca6143a084f07fe02a407fbf c2b6ede4fa0244d08ba5017b612e3deb--6f78bba9ca6143a084f07fe02a407fbf 540cc499445b4b3bb7f5f0be3f7ad8c8 6f78bba9ca6143a084f07fe02a407fbf--540cc499445b4b3bb7f5f0be3f7ad8c8 52d6c3ab8da64ddabd220f7d08baa0a7 540cc499445b4b3bb7f5f0be3f7ad8c8--52d6c3ab8da64ddabd220f7d08baa0a7 b8d7a465be11464fad3019016bb15f29 52d6c3ab8da64ddabd220f7d08baa0a7--b8d7a465be11464fad3019016bb15f29 700623b32e9c4d72ba5f7eded373f470 b8d7a465be11464fad3019016bb15f29--700623b32e9c4d72ba5f7eded373f470 c296b2775f744d94a352a802d1f965e6 700623b32e9c4d72ba5f7eded373f470--c296b2775f744d94a352a802d1f965e6 5ee7ae6c97394e21914a185db9386e13 c296b2775f744d94a352a802d1f965e6--5ee7ae6c97394e21914a185db9386e13 981bb27fa6a5452b9ad23431cd1404fe 5ee7ae6c97394e21914a185db9386e13--981bb27fa6a5452b9ad23431cd1404fe 330ead8fd907426faae053a1b5cb209d X 981bb27fa6a5452b9ad23431cd1404fe--330ead8fd907426faae053a1b5cb209d 330ead8fd907426faae053a1b5cb209d--d9c05f93553d4132bf111740004961f2 44f11b825097488d9089007e2c683e21 RZ(-1.0*g0) 330ead8fd907426faae053a1b5cb209d--44f11b825097488d9089007e2c683e21 9bc29666551f4013bb564031215c8f07 X 44f11b825097488d9089007e2c683e21--9bc29666551f4013bb564031215c8f07 9bc29666551f4013bb564031215c8f07--77d3bdd98000493585230a3fdd93d21a b9a7a57d789c43e3823298284969e275 9bc29666551f4013bb564031215c8f07--b9a7a57d789c43e3823298284969e275 1e9b9f798e0b460eb3247818532395dd b9a7a57d789c43e3823298284969e275--1e9b9f798e0b460eb3247818532395dd b8f1689ac0d64462932335356cab9cac 1e9b9f798e0b460eb3247818532395dd--b8f1689ac0d64462932335356cab9cac b821fa8bacc3456fae4f988a8da9cf06 b8f1689ac0d64462932335356cab9cac--b821fa8bacc3456fae4f988a8da9cf06 da06aef097394e5bb01785a11d1e74aa b821fa8bacc3456fae4f988a8da9cf06--da06aef097394e5bb01785a11d1e74aa 6014e21340194f07bd2e055731632faf da06aef097394e5bb01785a11d1e74aa--6014e21340194f07bd2e055731632faf 687cdfb77d5049e2bb1efb334189e58d 6014e21340194f07bd2e055731632faf--687cdfb77d5049e2bb1efb334189e58d 74411009cc6a4fa8b7be8de071d4e431 687cdfb77d5049e2bb1efb334189e58d--74411009cc6a4fa8b7be8de071d4e431 ea3527c2ed164f55a525bc5bcc6dc572 74411009cc6a4fa8b7be8de071d4e431--ea3527c2ed164f55a525bc5bcc6dc572 54bc1ad804d14b69af78fd435574092f ea3527c2ed164f55a525bc5bcc6dc572--54bc1ad804d14b69af78fd435574092f fa4c2427ab2b49ec8caf17475eba40df 54bc1ad804d14b69af78fd435574092f--fa4c2427ab2b49ec8caf17475eba40df e0037632d36d4d1da5b8c20c20d47a8b fa4c2427ab2b49ec8caf17475eba40df--e0037632d36d4d1da5b8c20c20d47a8b 763d2efc2b624975b7771b1e064fc354 e0037632d36d4d1da5b8c20c20d47a8b--763d2efc2b624975b7771b1e064fc354 c2a2819b2757458eabe8b17926276f50 763d2efc2b624975b7771b1e064fc354--c2a2819b2757458eabe8b17926276f50 72f6f198eccf4dcf881792005eb918bc c2a2819b2757458eabe8b17926276f50--72f6f198eccf4dcf881792005eb918bc 928da67091074a098ce856dede3aca50 72f6f198eccf4dcf881792005eb918bc--928da67091074a098ce856dede3aca50 ed771dcdd5414954939a61060dce40e1 928da67091074a098ce856dede3aca50--ed771dcdd5414954939a61060dce40e1 e58535c965c84af6b56e028f094c7845 ed771dcdd5414954939a61060dce40e1--e58535c965c84af6b56e028f094c7845 6dee4b655e3448e6afc28e7da638af3d e58535c965c84af6b56e028f094c7845--6dee4b655e3448e6afc28e7da638af3d 1a2c094f177d4022bcb3903449f6955c 6dee4b655e3448e6afc28e7da638af3d--1a2c094f177d4022bcb3903449f6955c f1bdbb7c748e4bdd92e8902307e01515 1a2c094f177d4022bcb3903449f6955c--f1bdbb7c748e4bdd92e8902307e01515 31c4d7eb711745b0aaf49fdfbb9abb7b f1bdbb7c748e4bdd92e8902307e01515--31c4d7eb711745b0aaf49fdfbb9abb7b 3bc6880477104524ae3b77ae4543162f 31c4d7eb711745b0aaf49fdfbb9abb7b--3bc6880477104524ae3b77ae4543162f efe50bb2a3ce440c8be587be9eaef351 3bc6880477104524ae3b77ae4543162f--efe50bb2a3ce440c8be587be9eaef351 c4262d7e4adc41c18b51d6c76c46c4fe efe50bb2a3ce440c8be587be9eaef351--c4262d7e4adc41c18b51d6c76c46c4fe 75b05e2917a54111892589640d1adf8c c4262d7e4adc41c18b51d6c76c46c4fe--75b05e2917a54111892589640d1adf8c ebc02472452d4d1aa527f56cec7156a7 75b05e2917a54111892589640d1adf8c--ebc02472452d4d1aa527f56cec7156a7 ba63e14bcbcd4aa28ba18ec5741411cb ebc02472452d4d1aa527f56cec7156a7--ba63e14bcbcd4aa28ba18ec5741411cb 6cb57582c545497abfbb95b9c3c69810 X ba63e14bcbcd4aa28ba18ec5741411cb--6cb57582c545497abfbb95b9c3c69810 6cb57582c545497abfbb95b9c3c69810--32ebd7645b064c32a8b51dc2dd141ec4 f1fb9f4f2c614cb1a2e93ad3a993b59a RZ(-1.0*g0) 6cb57582c545497abfbb95b9c3c69810--f1fb9f4f2c614cb1a2e93ad3a993b59a 47f2fc0b8d844050836f1420f83505a1 X f1fb9f4f2c614cb1a2e93ad3a993b59a--47f2fc0b8d844050836f1420f83505a1 47f2fc0b8d844050836f1420f83505a1--bcb9aa5cae944a8db894f7667c065ee5 13b1cc7ade384abbb803b78b58364ad1 47f2fc0b8d844050836f1420f83505a1--13b1cc7ade384abbb803b78b58364ad1 250f9ad1fc444e8999444a8397b29921 13b1cc7ade384abbb803b78b58364ad1--250f9ad1fc444e8999444a8397b29921 ddec0fe8a6034f6ba18604fe9ca659b4 250f9ad1fc444e8999444a8397b29921--ddec0fe8a6034f6ba18604fe9ca659b4 619a1d94d8614a92bc11d5e98d72f113 ddec0fe8a6034f6ba18604fe9ca659b4--619a1d94d8614a92bc11d5e98d72f113 f4eea6c9f8f347559a9876f81a4c40d2 619a1d94d8614a92bc11d5e98d72f113--f4eea6c9f8f347559a9876f81a4c40d2 8df21d4cee914e58bcfe1c89839b95dc f4eea6c9f8f347559a9876f81a4c40d2--8df21d4cee914e58bcfe1c89839b95dc b01631ab2d314575a520c601a58c3cc3 X 8df21d4cee914e58bcfe1c89839b95dc--b01631ab2d314575a520c601a58c3cc3 b01631ab2d314575a520c601a58c3cc3--ec72e3bc1e1c4daab3092d2b971d8a2f 4a7d48c6e09c4aeea4260c76f8dc99bd RZ(-1.0*g0) b01631ab2d314575a520c601a58c3cc3--4a7d48c6e09c4aeea4260c76f8dc99bd 982423951c514147813997dddb10c08f X 4a7d48c6e09c4aeea4260c76f8dc99bd--982423951c514147813997dddb10c08f 982423951c514147813997dddb10c08f--7b24403d5d3e4ba685ff8df8ae303274 ca993acccc8847fc96c07ea747b8d308 982423951c514147813997dddb10c08f--ca993acccc8847fc96c07ea747b8d308 7a6f2ac1e3c84706b9ba19750c849c8d X ca993acccc8847fc96c07ea747b8d308--7a6f2ac1e3c84706b9ba19750c849c8d 7a6f2ac1e3c84706b9ba19750c849c8d--6546cd029f0545dda9973b12b54d92fa 8e5d0f365ddd48a28b5c1c61da3d7d12 RZ(-1.0*g0) 7a6f2ac1e3c84706b9ba19750c849c8d--8e5d0f365ddd48a28b5c1c61da3d7d12 e732f02b1133471db89f79a7a0705619 X 8e5d0f365ddd48a28b5c1c61da3d7d12--e732f02b1133471db89f79a7a0705619 e732f02b1133471db89f79a7a0705619--0fb52634f96547038d7808f27d75527f d4302d7a80b34fd4ac1cedbe183f2637 RX(b07) e732f02b1133471db89f79a7a0705619--d4302d7a80b34fd4ac1cedbe183f2637 06a0aedd5db54e3aa6777d3377b781d7 d4302d7a80b34fd4ac1cedbe183f2637--06a0aedd5db54e3aa6777d3377b781d7 01a5356d9509480c98532ed2d3e296dd 06a0aedd5db54e3aa6777d3377b781d7--01a5356d9509480c98532ed2d3e296dd d8a21950390747759adb260c7f6a5d65 01a5356d9509480c98532ed2d3e296dd--d8a21950390747759adb260c7f6a5d65 416ff63f0e394b0eb4487d4a64c973c4 d8a21950390747759adb260c7f6a5d65--416ff63f0e394b0eb4487d4a64c973c4 4cd5149fc44b4aa59c8e0f3f4b53a3bf 416ff63f0e394b0eb4487d4a64c973c4--4cd5149fc44b4aa59c8e0f3f4b53a3bf a639b01f5b384bc8aa52579f126f6741 4cd5149fc44b4aa59c8e0f3f4b53a3bf--a639b01f5b384bc8aa52579f126f6741 6d1352105f1f4d5fb834768ef6216e69 X a639b01f5b384bc8aa52579f126f6741--6d1352105f1f4d5fb834768ef6216e69 6d1352105f1f4d5fb834768ef6216e69--5f31fc8ed6d047e684aa289cc341282e a6f53e168b0d4716b3c0021bbbaae26b RZ(1.0*g1) 6d1352105f1f4d5fb834768ef6216e69--a6f53e168b0d4716b3c0021bbbaae26b 990a201d53194ebc956a02ff9dc0d0a4 X a6f53e168b0d4716b3c0021bbbaae26b--990a201d53194ebc956a02ff9dc0d0a4 990a201d53194ebc956a02ff9dc0d0a4--507423215a3746a1842a77f39f7a08af 8a4176c7a44b4537b23ccb9b8e668aa4 990a201d53194ebc956a02ff9dc0d0a4--8a4176c7a44b4537b23ccb9b8e668aa4 60c31efc4d164d098f9341f2262ad9c0 8a4176c7a44b4537b23ccb9b8e668aa4--60c31efc4d164d098f9341f2262ad9c0 3a466de03ba14f3ca15f1d30511edec3 60c31efc4d164d098f9341f2262ad9c0--3a466de03ba14f3ca15f1d30511edec3 b2132668835e4f92b89fe682ac754421 3a466de03ba14f3ca15f1d30511edec3--b2132668835e4f92b89fe682ac754421 b7d704adc708477594bfb73426a2d61c b2132668835e4f92b89fe682ac754421--b7d704adc708477594bfb73426a2d61c 295d860e7efe4f64b79f83173a086518 b7d704adc708477594bfb73426a2d61c--295d860e7efe4f64b79f83173a086518 8c7a8579a83e437cb432216f3b9f9de4 295d860e7efe4f64b79f83173a086518--8c7a8579a83e437cb432216f3b9f9de4 e828aa31bb574ed3bab0d626aa798f95 8c7a8579a83e437cb432216f3b9f9de4--e828aa31bb574ed3bab0d626aa798f95 d5895579b4d445fda0196f1e57997063 e828aa31bb574ed3bab0d626aa798f95--d5895579b4d445fda0196f1e57997063 fc26b406803446b385f5ed6ee4e4a7f9 d5895579b4d445fda0196f1e57997063--fc26b406803446b385f5ed6ee4e4a7f9 f8731833543440c8bb82a02a70e2b557 fc26b406803446b385f5ed6ee4e4a7f9--f8731833543440c8bb82a02a70e2b557 1aeb1f68adce4ffab79add6fa079d068 f8731833543440c8bb82a02a70e2b557--1aeb1f68adce4ffab79add6fa079d068 c3d0348259214a48932d89432a372697 1aeb1f68adce4ffab79add6fa079d068--c3d0348259214a48932d89432a372697 3625749ab21d4eb8a93d8d572e8648b3 c3d0348259214a48932d89432a372697--3625749ab21d4eb8a93d8d572e8648b3 04cbb0cb860145b4b0c556f4ffbe7047 3625749ab21d4eb8a93d8d572e8648b3--04cbb0cb860145b4b0c556f4ffbe7047 1de8d234414f43ab96e8f85e9268c85d 04cbb0cb860145b4b0c556f4ffbe7047--1de8d234414f43ab96e8f85e9268c85d 96baf19af13147debe6f3262798d159f 1de8d234414f43ab96e8f85e9268c85d--96baf19af13147debe6f3262798d159f f73c068705e24ec599c02ad0b3156490 96baf19af13147debe6f3262798d159f--f73c068705e24ec599c02ad0b3156490 82dc6b230a57471f8791c9989870f4c3 f73c068705e24ec599c02ad0b3156490--82dc6b230a57471f8791c9989870f4c3 311b696ad26342a990f7e5f84b61e975 82dc6b230a57471f8791c9989870f4c3--311b696ad26342a990f7e5f84b61e975 7776195eb4274065bccfbcb0d5e2a73c 311b696ad26342a990f7e5f84b61e975--7776195eb4274065bccfbcb0d5e2a73c 654116c7c0e0456c9c0021a9529df29c 7776195eb4274065bccfbcb0d5e2a73c--654116c7c0e0456c9c0021a9529df29c 8818f797b4624ae492d5b6baff223877 654116c7c0e0456c9c0021a9529df29c--8818f797b4624ae492d5b6baff223877 06843a3e41914c7db50d2f795bd22284 8818f797b4624ae492d5b6baff223877--06843a3e41914c7db50d2f795bd22284 b126f7da20d845cb810a26066b6c393f 06843a3e41914c7db50d2f795bd22284--b126f7da20d845cb810a26066b6c393f 2050e128287b462e9ef44f2bc5eedda5 b126f7da20d845cb810a26066b6c393f--2050e128287b462e9ef44f2bc5eedda5 82effb7e50194bc9b1c16ae90f455a9e 2050e128287b462e9ef44f2bc5eedda5--82effb7e50194bc9b1c16ae90f455a9e 0fca770526f8469b999e8f47f40879c6 82effb7e50194bc9b1c16ae90f455a9e--0fca770526f8469b999e8f47f40879c6 63b4794818a245b48b3e737b5935cbd4 0fca770526f8469b999e8f47f40879c6--63b4794818a245b48b3e737b5935cbd4 4ad50566537d40999427712ae07ac93f 63b4794818a245b48b3e737b5935cbd4--4ad50566537d40999427712ae07ac93f 5e8ba01b18564b2d8bd7181b5dab5854 4ad50566537d40999427712ae07ac93f--5e8ba01b18564b2d8bd7181b5dab5854 fed7b752f5b942f89708f4f52b3713bf 5e8ba01b18564b2d8bd7181b5dab5854--fed7b752f5b942f89708f4f52b3713bf 3aafe0258db84b76a5108d3ff7b77314 fed7b752f5b942f89708f4f52b3713bf--3aafe0258db84b76a5108d3ff7b77314 bff7247025e3457082fa98a7d360a867 3aafe0258db84b76a5108d3ff7b77314--bff7247025e3457082fa98a7d360a867 e4bc80f3d3874e4699b49b0a8fb0ada9 bff7247025e3457082fa98a7d360a867--e4bc80f3d3874e4699b49b0a8fb0ada9 d94bcafc76ab40bc993c8a41e595faea e4bc80f3d3874e4699b49b0a8fb0ada9--d94bcafc76ab40bc993c8a41e595faea 2c3f92fb39d64e2d9e2af55de6b5204c d94bcafc76ab40bc993c8a41e595faea--2c3f92fb39d64e2d9e2af55de6b5204c 13b7746e63594b4bae882bf3d7597993 2c3f92fb39d64e2d9e2af55de6b5204c--13b7746e63594b4bae882bf3d7597993 a35e1cdfe18d429e855b2a123079e2a0 13b7746e63594b4bae882bf3d7597993--a35e1cdfe18d429e855b2a123079e2a0 731c4745f23d4bb1a66dd279a94d3cd2 a35e1cdfe18d429e855b2a123079e2a0--731c4745f23d4bb1a66dd279a94d3cd2 8f6ae7d1048646c49059da16ef0e5162 731c4745f23d4bb1a66dd279a94d3cd2--8f6ae7d1048646c49059da16ef0e5162 f220d4b967e94464b7611ffe9cfc2729 8f6ae7d1048646c49059da16ef0e5162--f220d4b967e94464b7611ffe9cfc2729 1cd6b19072ac410491ac2b2ac74decc4 f220d4b967e94464b7611ffe9cfc2729--1cd6b19072ac410491ac2b2ac74decc4 94f84f2812584dacb087d4f3820d2e27 1cd6b19072ac410491ac2b2ac74decc4--94f84f2812584dacb087d4f3820d2e27 5071a90b9f3c485e9419ffa2dab15de2 94f84f2812584dacb087d4f3820d2e27--5071a90b9f3c485e9419ffa2dab15de2 6e2aa5793309490cae713bc6acba4e4a 5071a90b9f3c485e9419ffa2dab15de2--6e2aa5793309490cae713bc6acba4e4a 6d9b3702a3d043cbb7a34e4b568f052f 6e2aa5793309490cae713bc6acba4e4a--6d9b3702a3d043cbb7a34e4b568f052f 89b5a11337be43568a29e230334b7b19 6d9b3702a3d043cbb7a34e4b568f052f--89b5a11337be43568a29e230334b7b19 10bf38a663774cd7b1efb42548a5c597 89b5a11337be43568a29e230334b7b19--10bf38a663774cd7b1efb42548a5c597 7adb660f7d1242dbb9bea935ebd93d89 10bf38a663774cd7b1efb42548a5c597--7adb660f7d1242dbb9bea935ebd93d89 05a9d2441fa649088cf0fffba79ae740 7adb660f7d1242dbb9bea935ebd93d89--05a9d2441fa649088cf0fffba79ae740 d78ed74dafa34bcdbf31db5d75a87d66 05a9d2441fa649088cf0fffba79ae740--d78ed74dafa34bcdbf31db5d75a87d66 d539508e077e4aeaa4f59e7bfa6595cc d78ed74dafa34bcdbf31db5d75a87d66--d539508e077e4aeaa4f59e7bfa6595cc 5d63f731e3ad460db23fa6aef4c826e3 X d539508e077e4aeaa4f59e7bfa6595cc--5d63f731e3ad460db23fa6aef4c826e3 5d63f731e3ad460db23fa6aef4c826e3--8fda540eecfb422a8918c80775d5099c ad18f4e0b5514189b24dfeb28c75af41 RZ(-1.0*g1) 5d63f731e3ad460db23fa6aef4c826e3--ad18f4e0b5514189b24dfeb28c75af41 da183d25f6264a269d1b10d7b00a9981 X ad18f4e0b5514189b24dfeb28c75af41--da183d25f6264a269d1b10d7b00a9981 da183d25f6264a269d1b10d7b00a9981--403343e7bb5d450fa59dd6c6d7fbc9f1 6f6e2253c26e47d0bc870ec582227a46 da183d25f6264a269d1b10d7b00a9981--6f6e2253c26e47d0bc870ec582227a46 36fd92d26b6640209bb85fbed3e280b8 6f6e2253c26e47d0bc870ec582227a46--36fd92d26b6640209bb85fbed3e280b8 88048f53f93a45b3a9c933f6f4b5cf54 36fd92d26b6640209bb85fbed3e280b8--88048f53f93a45b3a9c933f6f4b5cf54 48ca36b36858484ab809862cfc868cca 88048f53f93a45b3a9c933f6f4b5cf54--48ca36b36858484ab809862cfc868cca 160b9f0167de4c70b23c4e19d2940647 48ca36b36858484ab809862cfc868cca--160b9f0167de4c70b23c4e19d2940647 91a217c2bac1484faa00afca3033df00 160b9f0167de4c70b23c4e19d2940647--91a217c2bac1484faa00afca3033df00 55ab8efe21e34c18801f7b862f03ce94 91a217c2bac1484faa00afca3033df00--55ab8efe21e34c18801f7b862f03ce94 2fb044846eea4f44b8a58d29db0bbc1a 55ab8efe21e34c18801f7b862f03ce94--2fb044846eea4f44b8a58d29db0bbc1a 274660b4a712493e8d7749f99c8a2b43 2fb044846eea4f44b8a58d29db0bbc1a--274660b4a712493e8d7749f99c8a2b43 d851d2c9c8fa4e3c9579326862dfee3a 274660b4a712493e8d7749f99c8a2b43--d851d2c9c8fa4e3c9579326862dfee3a e139d99e717e4aa2ad439f7c94976767 d851d2c9c8fa4e3c9579326862dfee3a--e139d99e717e4aa2ad439f7c94976767 dcc1ec513ecd4d8e955da2c696bf1084 e139d99e717e4aa2ad439f7c94976767--dcc1ec513ecd4d8e955da2c696bf1084 056316bbc3964255aa51f9d42200fedf dcc1ec513ecd4d8e955da2c696bf1084--056316bbc3964255aa51f9d42200fedf be79b8990faa456f8158b9394ff38209 056316bbc3964255aa51f9d42200fedf--be79b8990faa456f8158b9394ff38209 a05da5d312dc4cef9f9964235ad6fe1d be79b8990faa456f8158b9394ff38209--a05da5d312dc4cef9f9964235ad6fe1d 499b273bb6cf4a4fa4d5a3b4e9a4f692 a05da5d312dc4cef9f9964235ad6fe1d--499b273bb6cf4a4fa4d5a3b4e9a4f692 e514ab212ac8453b8edabc4897f8ea2f 499b273bb6cf4a4fa4d5a3b4e9a4f692--e514ab212ac8453b8edabc4897f8ea2f 7c6b872b4b1d49daaadf4691630c23b0 e514ab212ac8453b8edabc4897f8ea2f--7c6b872b4b1d49daaadf4691630c23b0 e8ce110144e2434b921fe95189d5692a 7c6b872b4b1d49daaadf4691630c23b0--e8ce110144e2434b921fe95189d5692a 7e2ba021a3bb49f995eeeb8c92575a39 e8ce110144e2434b921fe95189d5692a--7e2ba021a3bb49f995eeeb8c92575a39 02b39659cd4246c6ace720ae0347b25b 7e2ba021a3bb49f995eeeb8c92575a39--02b39659cd4246c6ace720ae0347b25b 62221f9a1c4849d5a5828addaae2d034 02b39659cd4246c6ace720ae0347b25b--62221f9a1c4849d5a5828addaae2d034 94215cae065741bcae6346b999d37e62 62221f9a1c4849d5a5828addaae2d034--94215cae065741bcae6346b999d37e62 5d311e2bb48347f38205f73a569f3cc2 94215cae065741bcae6346b999d37e62--5d311e2bb48347f38205f73a569f3cc2 4395f93e9bcf4fd0b571d7cc0229a833 5d311e2bb48347f38205f73a569f3cc2--4395f93e9bcf4fd0b571d7cc0229a833 d055af8ec70247dbab8d8275e62aa021 4395f93e9bcf4fd0b571d7cc0229a833--d055af8ec70247dbab8d8275e62aa021 bfe2909e641f45ccb0d3969bd4059092 d055af8ec70247dbab8d8275e62aa021--bfe2909e641f45ccb0d3969bd4059092 5ebebc91f81a40e888c834690c3ecd94 bfe2909e641f45ccb0d3969bd4059092--5ebebc91f81a40e888c834690c3ecd94 8c5924a5ec444f119b60abb25f5892e2 X 5ebebc91f81a40e888c834690c3ecd94--8c5924a5ec444f119b60abb25f5892e2 8c5924a5ec444f119b60abb25f5892e2--8beff87709344929872740ca1c177072 0690aef8c72f46a0b69ad0dd73db5b4c RZ(-1.0*g1) 8c5924a5ec444f119b60abb25f5892e2--0690aef8c72f46a0b69ad0dd73db5b4c c497992a8bf04e9085e1c7ac6a49d8ff X 0690aef8c72f46a0b69ad0dd73db5b4c--c497992a8bf04e9085e1c7ac6a49d8ff c497992a8bf04e9085e1c7ac6a49d8ff--bdf05dd316d142cca028d40f998470cd 97514dca70dc402f88f2787d6d30f1f3 c497992a8bf04e9085e1c7ac6a49d8ff--97514dca70dc402f88f2787d6d30f1f3 1f59ed7c3abd426ab2b46efe2a38d2d9 97514dca70dc402f88f2787d6d30f1f3--1f59ed7c3abd426ab2b46efe2a38d2d9 a02cf07bcf5241808dcd01b523b96f81 1f59ed7c3abd426ab2b46efe2a38d2d9--a02cf07bcf5241808dcd01b523b96f81 6514d29f29434641bcbf5c57e44bb6de a02cf07bcf5241808dcd01b523b96f81--6514d29f29434641bcbf5c57e44bb6de 7aa3a2ab12334bc7b88b7fef1a05afe9 6514d29f29434641bcbf5c57e44bb6de--7aa3a2ab12334bc7b88b7fef1a05afe9 444a19aade8a4e14ab13f668ea542baa 7aa3a2ab12334bc7b88b7fef1a05afe9--444a19aade8a4e14ab13f668ea542baa c718c3a04b874964b96728dcbc5742a7 X 444a19aade8a4e14ab13f668ea542baa--c718c3a04b874964b96728dcbc5742a7 c718c3a04b874964b96728dcbc5742a7--f6614459e68f459f8e16001ee2a6ab21 e2e3e99ebd2a4b83b5e9aad3a0b30f8e RZ(-1.0*g1) c718c3a04b874964b96728dcbc5742a7--e2e3e99ebd2a4b83b5e9aad3a0b30f8e e9635e8d84a94ba698933f804aa31998 X e2e3e99ebd2a4b83b5e9aad3a0b30f8e--e9635e8d84a94ba698933f804aa31998 e9635e8d84a94ba698933f804aa31998--e615a26f4140428a9dd66adcd568c377 b28913b20c294072901e0384bc44f9b3 e9635e8d84a94ba698933f804aa31998--b28913b20c294072901e0384bc44f9b3 7dae82e6698f4260a9610503f69f5289 X b28913b20c294072901e0384bc44f9b3--7dae82e6698f4260a9610503f69f5289 7dae82e6698f4260a9610503f69f5289--c6d28f24eacc46dc841561566e5faf7c 3b1c51c92ec247319b0240b638d6818e RZ(-1.0*g1) 7dae82e6698f4260a9610503f69f5289--3b1c51c92ec247319b0240b638d6818e 9fc13bef63e14345bc22e28f74e4253d X 3b1c51c92ec247319b0240b638d6818e--9fc13bef63e14345bc22e28f74e4253d 9fc13bef63e14345bc22e28f74e4253d--ab7f9780a70448708c6e3c4012bce831 56537a10620e4a56a1d6c86eb5d772c2 RX(b17) 9fc13bef63e14345bc22e28f74e4253d--56537a10620e4a56a1d6c86eb5d772c2 56537a10620e4a56a1d6c86eb5d772c2--6f683a4f4eb441cd91938d725000b741"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.19856830397157\nMaxCut cost at iteration 10: 10.399582041712243\nMaxCut cost at iteration 20: 10.995489174121609\nMaxCut cost at iteration 30: 10.999981483707666\nMaxCut cost at iteration 40: 10.999999826908594\nMaxCut cost at iteration 50: 10.999999998179536\nMaxCut cost at iteration 60: 10.999999999978671\nMaxCut cost at iteration 70: 10.999999999999726\nMaxCut cost at iteration 80: 10.999999999999993\nMaxCut cost at iteration 90: 10.999999999999995\nMaxCut cost at iteration 100: 11.0\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01001110  2023-10-16T10:48:04.628087 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.006756732932883128\nEpoch 40 - Loss: 0.0013178262682414356\nEpoch 60 - Loss: 0.00024411275385789364\nEpoch 80 - Loss: 1.810927009147257e-05\nEpoch 100 - Loss: 3.344354751233859e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-10-16T10:48:12.776859 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_tools/","title":"Tools for quantum machine learning","text":"<p>Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning</li> <li>a set of tools for optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/qml_tools/#quantum-machine-learning-constructors","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_tools/#feature-maps","title":"Feature maps","text":"<p>A few feature maps are directly available for loading classical data into quantum circuits by encoding them into gate rotation angles.</p> <pre><code>from qadence import feature_map\nn_qubits = 3\nfm = feature_map(n_qubits, fm_type=\"fourier\")\nfm = feature_map(n_qubits, fm_type=\"chebyshev\")\nfm = feature_map(n_qubits, fm_type=\"tower\")\n</code></pre> <pre><code>Fourier = KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nChebyshev KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['2*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['2*acos(phi)']]\nTower KronBlock(0,1,2) [tag: FM]\n\u251c\u2500\u2500 RX(0) [params: ['2*acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['4*acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['6*acos(phi)']]\n</code></pre>"},{"location":"qml/qml_tools/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> %3 ab212bbe66c5496a89b6ec69089e8743 0 c76212edf6e744f6a61a82beb2bedccd RX(theta\u2080) ab212bbe66c5496a89b6ec69089e8743--c76212edf6e744f6a61a82beb2bedccd ac4bcdc8b81c40fea860210948b56854 1 11462ed70d604d52a4ceae29aab58502 RY(theta\u2083) c76212edf6e744f6a61a82beb2bedccd--11462ed70d604d52a4ceae29aab58502 f908254d72a64979bcb507091fa8c0bf RX(theta\u2086) 11462ed70d604d52a4ceae29aab58502--f908254d72a64979bcb507091fa8c0bf f6116136caa84f00be2bafb84d57ea8b f908254d72a64979bcb507091fa8c0bf--f6116136caa84f00be2bafb84d57ea8b ce2ec87144234f68a4f9d9f1124d9e64 f6116136caa84f00be2bafb84d57ea8b--ce2ec87144234f68a4f9d9f1124d9e64 33efbbb24a3c4021ab76755379a29518 RX(theta\u2089) ce2ec87144234f68a4f9d9f1124d9e64--33efbbb24a3c4021ab76755379a29518 0c2c8cca352e42da8f9832b43bd54ac4 RY(theta\u2081\u2082) 33efbbb24a3c4021ab76755379a29518--0c2c8cca352e42da8f9832b43bd54ac4 075444630ced4233a8383b1da31400a1 RX(theta\u2081\u2085) 0c2c8cca352e42da8f9832b43bd54ac4--075444630ced4233a8383b1da31400a1 e9e526a01d644480b2e0ed26ef584898 075444630ced4233a8383b1da31400a1--e9e526a01d644480b2e0ed26ef584898 c6fb2d50fcf04ddf8f358c20b93df38e e9e526a01d644480b2e0ed26ef584898--c6fb2d50fcf04ddf8f358c20b93df38e f51b2da560194fec9dc1af24a784e6a7 c6fb2d50fcf04ddf8f358c20b93df38e--f51b2da560194fec9dc1af24a784e6a7 5d19a4ca98a64ecaa572b9777883e29a 4eaa0c5b20e64031b7a347e8ade7a946 RX(theta\u2081) ac4bcdc8b81c40fea860210948b56854--4eaa0c5b20e64031b7a347e8ade7a946 d10608251afd495b801bd275bafbe352 2 eebdece6b7b54d3d9fc1910f18279db4 RY(theta\u2084) 4eaa0c5b20e64031b7a347e8ade7a946--eebdece6b7b54d3d9fc1910f18279db4 e5b1b368df664003b5327a7105841b1c RX(theta\u2087) eebdece6b7b54d3d9fc1910f18279db4--e5b1b368df664003b5327a7105841b1c f2154e5aae8641a2ae2900f66d0392d7 X e5b1b368df664003b5327a7105841b1c--f2154e5aae8641a2ae2900f66d0392d7 f2154e5aae8641a2ae2900f66d0392d7--f6116136caa84f00be2bafb84d57ea8b e98a56e2486342669652aaba5e0a0d19 f2154e5aae8641a2ae2900f66d0392d7--e98a56e2486342669652aaba5e0a0d19 900fd5d938a94ba9a57642a009b7eac4 RX(theta\u2081\u2080) e98a56e2486342669652aaba5e0a0d19--900fd5d938a94ba9a57642a009b7eac4 ca4525062dbd4447b615a2490819b031 RY(theta\u2081\u2083) 900fd5d938a94ba9a57642a009b7eac4--ca4525062dbd4447b615a2490819b031 ef1f318da11e42aeaa38eb1d6e5d6310 RX(theta\u2081\u2086) ca4525062dbd4447b615a2490819b031--ef1f318da11e42aeaa38eb1d6e5d6310 350af8362e464c5f93e9e671c20fb461 X ef1f318da11e42aeaa38eb1d6e5d6310--350af8362e464c5f93e9e671c20fb461 350af8362e464c5f93e9e671c20fb461--e9e526a01d644480b2e0ed26ef584898 0e832f10990d4782922b83f3bd506192 350af8362e464c5f93e9e671c20fb461--0e832f10990d4782922b83f3bd506192 0e832f10990d4782922b83f3bd506192--5d19a4ca98a64ecaa572b9777883e29a b0e45286a45043129997679e787d4d62 823a9d1c5d2c43958fd71231a38de585 RX(theta\u2082) d10608251afd495b801bd275bafbe352--823a9d1c5d2c43958fd71231a38de585 c29d7125df8a4407bc7fe892516b16df RY(theta\u2085) 823a9d1c5d2c43958fd71231a38de585--c29d7125df8a4407bc7fe892516b16df 39e85594520644eb986781a9d0bdf8cb RX(theta\u2088) c29d7125df8a4407bc7fe892516b16df--39e85594520644eb986781a9d0bdf8cb e563d00029ec4659a5eb7b3b5056d33c 39e85594520644eb986781a9d0bdf8cb--e563d00029ec4659a5eb7b3b5056d33c 75989de3a63c4c90885b3dde0a49689d X e563d00029ec4659a5eb7b3b5056d33c--75989de3a63c4c90885b3dde0a49689d 75989de3a63c4c90885b3dde0a49689d--e98a56e2486342669652aaba5e0a0d19 0f63d25d9bfe4218848331b4cd74f6ca RX(theta\u2081\u2081) 75989de3a63c4c90885b3dde0a49689d--0f63d25d9bfe4218848331b4cd74f6ca 5c5dde0555d04f22b6c3b19560265653 RY(theta\u2081\u2084) 0f63d25d9bfe4218848331b4cd74f6ca--5c5dde0555d04f22b6c3b19560265653 8d468c8deb29460bb3557187764279dd RX(theta\u2081\u2087) 5c5dde0555d04f22b6c3b19560265653--8d468c8deb29460bb3557187764279dd 872dcc9ab60c4bebaae8b05792cd8fb5 8d468c8deb29460bb3557187764279dd--872dcc9ab60c4bebaae8b05792cd8fb5 50312d932e74478a9b0429e680c83699 X 872dcc9ab60c4bebaae8b05792cd8fb5--50312d932e74478a9b0429e680c83699 50312d932e74478a9b0429e680c83699--0e832f10990d4782922b83f3bd506192 50312d932e74478a9b0429e680c83699--b0e45286a45043129997679e787d4d62 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> %3 306c21214ee64b07a42dba2627157744 0 dad57b9240b34c169b08f183b4cb7523 RX(phi\u2080) 306c21214ee64b07a42dba2627157744--dad57b9240b34c169b08f183b4cb7523 1e33b948e4364ff3b6a344cbe3c9ddcb 1 40c64665d3b74779b510f89427ad3f1b RY(phi\u2083) dad57b9240b34c169b08f183b4cb7523--40c64665d3b74779b510f89427ad3f1b c7355b5687654d8d82dbdc45dbbd1b2e RX(phi\u2086) 40c64665d3b74779b510f89427ad3f1b--c7355b5687654d8d82dbdc45dbbd1b2e 9074afe0480e465d8f23638add1c511c c7355b5687654d8d82dbdc45dbbd1b2e--9074afe0480e465d8f23638add1c511c 8076a502ee994bd39ffc826f39cb50ba 9074afe0480e465d8f23638add1c511c--8076a502ee994bd39ffc826f39cb50ba 14881938217a49c5aefadedc62c98bde RX(phi\u2089) 8076a502ee994bd39ffc826f39cb50ba--14881938217a49c5aefadedc62c98bde d56a35561ae241bf8cb8f92adfbcb75a RY(phi\u2081\u2082) 14881938217a49c5aefadedc62c98bde--d56a35561ae241bf8cb8f92adfbcb75a d20eb9dada96452caa40fcc96aa8a437 RX(phi\u2081\u2085) d56a35561ae241bf8cb8f92adfbcb75a--d20eb9dada96452caa40fcc96aa8a437 0c98f6f0b52e4fb69c1c41ad5e517e19 d20eb9dada96452caa40fcc96aa8a437--0c98f6f0b52e4fb69c1c41ad5e517e19 0f0fdb19cec746719aee5b8e3e862b0a 0c98f6f0b52e4fb69c1c41ad5e517e19--0f0fdb19cec746719aee5b8e3e862b0a 4a55d08de7b7484593324873c641a3c3 0f0fdb19cec746719aee5b8e3e862b0a--4a55d08de7b7484593324873c641a3c3 e04454aa627e40d9b213766d3d7c0aee da32217817e94362808798bafa57a270 RX(phi\u2081) 1e33b948e4364ff3b6a344cbe3c9ddcb--da32217817e94362808798bafa57a270 384d27cf1e764e29968ff7bd5201c5bb 2 df201a06299240d3b644acb4184b33ec RY(phi\u2084) da32217817e94362808798bafa57a270--df201a06299240d3b644acb4184b33ec 53aa391c72fc4cba8bb93b10580f68f2 RX(phi\u2087) df201a06299240d3b644acb4184b33ec--53aa391c72fc4cba8bb93b10580f68f2 3e9546c342f848aaa93f95eb3480d8f8 PHASE(phi_ent\u2080) 53aa391c72fc4cba8bb93b10580f68f2--3e9546c342f848aaa93f95eb3480d8f8 3e9546c342f848aaa93f95eb3480d8f8--9074afe0480e465d8f23638add1c511c e2eb1d8e363c4dc383352162a15467c8 3e9546c342f848aaa93f95eb3480d8f8--e2eb1d8e363c4dc383352162a15467c8 96f47c99d298470391510f4ded534794 RX(phi\u2081\u2080) e2eb1d8e363c4dc383352162a15467c8--96f47c99d298470391510f4ded534794 b8b08c7e8aa7477cabfc1da99f7b5556 RY(phi\u2081\u2083) 96f47c99d298470391510f4ded534794--b8b08c7e8aa7477cabfc1da99f7b5556 f887015439f545c38f08d7393df9234d RX(phi\u2081\u2086) b8b08c7e8aa7477cabfc1da99f7b5556--f887015439f545c38f08d7393df9234d 9ccb203add524981bc796d6cf52dc337 PHASE(phi_ent\u2082) f887015439f545c38f08d7393df9234d--9ccb203add524981bc796d6cf52dc337 9ccb203add524981bc796d6cf52dc337--0c98f6f0b52e4fb69c1c41ad5e517e19 3ba3bd9aefa641caa20e40235852ad09 9ccb203add524981bc796d6cf52dc337--3ba3bd9aefa641caa20e40235852ad09 3ba3bd9aefa641caa20e40235852ad09--e04454aa627e40d9b213766d3d7c0aee 6b37347f213946d59cf68c4d3bdb20b6 64f33bac5a25469e8319fa86d7e221d6 RX(phi\u2082) 384d27cf1e764e29968ff7bd5201c5bb--64f33bac5a25469e8319fa86d7e221d6 cb09199f1ab04577a314386f05dbd128 RY(phi\u2085) 64f33bac5a25469e8319fa86d7e221d6--cb09199f1ab04577a314386f05dbd128 229bca2c271c40f887ede5da3aaf3f5d RX(phi\u2088) cb09199f1ab04577a314386f05dbd128--229bca2c271c40f887ede5da3aaf3f5d 2d9b2f678dfb4399a6be4ff972fb1ce5 229bca2c271c40f887ede5da3aaf3f5d--2d9b2f678dfb4399a6be4ff972fb1ce5 d21f794e572745bebf1c673b62d45964 PHASE(phi_ent\u2081) 2d9b2f678dfb4399a6be4ff972fb1ce5--d21f794e572745bebf1c673b62d45964 d21f794e572745bebf1c673b62d45964--e2eb1d8e363c4dc383352162a15467c8 b52b0664e9ba4666931cf80c2e4ef07e RX(phi\u2081\u2081) d21f794e572745bebf1c673b62d45964--b52b0664e9ba4666931cf80c2e4ef07e f81763853b2e4e7eb17d006ba5d1c992 RY(phi\u2081\u2084) b52b0664e9ba4666931cf80c2e4ef07e--f81763853b2e4e7eb17d006ba5d1c992 6ba680e68eb6421da973feb0092412fd RX(phi\u2081\u2087) f81763853b2e4e7eb17d006ba5d1c992--6ba680e68eb6421da973feb0092412fd d84959db815149e780a2517a4d0eddaf 6ba680e68eb6421da973feb0092412fd--d84959db815149e780a2517a4d0eddaf f432532b49c345afbe461fafaaf5e486 PHASE(phi_ent\u2083) d84959db815149e780a2517a4d0eddaf--f432532b49c345afbe461fafaaf5e486 f432532b49c345afbe461fafaaf5e486--3ba3bd9aefa641caa20e40235852ad09 f432532b49c345afbe461fafaaf5e486--6b37347f213946d59cf68c4d3bdb20b6 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like NN interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_e72062c5637a4565b4c35b50f6fd43d9 cluster_9bbdc57b1f0e4af8b4d08d53b485b3fb 7203da22c628462981a7238818972a87 0 0274ace90e254886b26e27cf7607bbdf RX(theta\u2080) 7203da22c628462981a7238818972a87--0274ace90e254886b26e27cf7607bbdf 313007bd5a9b485f98f468f1292f164e 1 5eded80510ca4278a49a0da28ccc3693 RY(theta\u2083) 0274ace90e254886b26e27cf7607bbdf--5eded80510ca4278a49a0da28ccc3693 4605dfe7feda47fea3fe301afb582b21 RX(theta\u2086) 5eded80510ca4278a49a0da28ccc3693--4605dfe7feda47fea3fe301afb582b21 aacea5e26ac1409ab6b863606e587efc HamEvo 4605dfe7feda47fea3fe301afb582b21--aacea5e26ac1409ab6b863606e587efc 598d69981a1c4d9889a76993dc144674 RX(theta\u2089) aacea5e26ac1409ab6b863606e587efc--598d69981a1c4d9889a76993dc144674 46d0ffc705214b4e971a5115b8e78e95 RY(theta\u2081\u2082) 598d69981a1c4d9889a76993dc144674--46d0ffc705214b4e971a5115b8e78e95 67ab2b3c45e04a2eab5644887d66992d RX(theta\u2081\u2085) 46d0ffc705214b4e971a5115b8e78e95--67ab2b3c45e04a2eab5644887d66992d 44874d6596d344d98faefd9fd6e24283 HamEvo 67ab2b3c45e04a2eab5644887d66992d--44874d6596d344d98faefd9fd6e24283 2034f11193744f099d2566131ac2bed5 44874d6596d344d98faefd9fd6e24283--2034f11193744f099d2566131ac2bed5 1090612b56d247f1acc498ad0283b596 b503cacc3aa14563bf6eaceeebb655bd RX(theta\u2081) 313007bd5a9b485f98f468f1292f164e--b503cacc3aa14563bf6eaceeebb655bd b139f1d573504b56988a5c9b9fbd34ed 2 69dd63a4136d47adaef38e2dd87f3508 RY(theta\u2084) b503cacc3aa14563bf6eaceeebb655bd--69dd63a4136d47adaef38e2dd87f3508 839354b6ecd144379e3db7164092f808 RX(theta\u2087) 69dd63a4136d47adaef38e2dd87f3508--839354b6ecd144379e3db7164092f808 f8bd2c6599c6438ca00bbc6873c9aef4 t = theta_t\u2080 839354b6ecd144379e3db7164092f808--f8bd2c6599c6438ca00bbc6873c9aef4 c13760ca8e2b47369770ae1eef5bb881 RX(theta\u2081\u2080) f8bd2c6599c6438ca00bbc6873c9aef4--c13760ca8e2b47369770ae1eef5bb881 9e4c08d60e7d48a1b0041e90ce409885 RY(theta\u2081\u2083) c13760ca8e2b47369770ae1eef5bb881--9e4c08d60e7d48a1b0041e90ce409885 262a70e1e36849f183f3ea43471350e9 RX(theta\u2081\u2086) 9e4c08d60e7d48a1b0041e90ce409885--262a70e1e36849f183f3ea43471350e9 9e4d910214d54d57ba6c5aa16b409d68 t = theta_t\u2081 262a70e1e36849f183f3ea43471350e9--9e4d910214d54d57ba6c5aa16b409d68 9e4d910214d54d57ba6c5aa16b409d68--1090612b56d247f1acc498ad0283b596 cfcd39bc8f4e437f8452b1ccbed499e3 c9897211c43a4096899f87a24a432866 RX(theta\u2082) b139f1d573504b56988a5c9b9fbd34ed--c9897211c43a4096899f87a24a432866 99de726ba0a9434daf3751b9526da0fe RY(theta\u2085) c9897211c43a4096899f87a24a432866--99de726ba0a9434daf3751b9526da0fe 94befc6dff5e48f98d6a4ba89f8ae949 RX(theta\u2088) 99de726ba0a9434daf3751b9526da0fe--94befc6dff5e48f98d6a4ba89f8ae949 a3072ea6f8a349e8a865edc0b0c25893 94befc6dff5e48f98d6a4ba89f8ae949--a3072ea6f8a349e8a865edc0b0c25893 04615824935444de87d2b547963bd5ff RX(theta\u2081\u2081) a3072ea6f8a349e8a865edc0b0c25893--04615824935444de87d2b547963bd5ff 0dfec7327a124d55808645ca98aade08 RY(theta\u2081\u2084) 04615824935444de87d2b547963bd5ff--0dfec7327a124d55808645ca98aade08 f70cac7e7b3d491b8fe6ede4ae963b1f RX(theta\u2081\u2087) 0dfec7327a124d55808645ca98aade08--f70cac7e7b3d491b8fe6ede4ae963b1f 517f968716964e29b87d267429a5fd40 f70cac7e7b3d491b8fe6ede4ae963b1f--517f968716964e29b87d267429a5fd40 517f968716964e29b87d267429a5fd40--cfcd39bc8f4e437f8452b1ccbed499e3 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_c2272142efb442d2b5c07882454ce616 cluster_bda7f2a7136c4dce9e0171104bc0ceae 4eb555e8c1af49e09a45ca76a883f2ee 0 c86f9707be254adfbc0ba9f5fb9d2c5f RX(theta\u2080) 4eb555e8c1af49e09a45ca76a883f2ee--c86f9707be254adfbc0ba9f5fb9d2c5f b01b11066a0443998bcfad4be465dd60 1 54cc2603dbf24611b9c1289130644a9a RY(theta\u2086) c86f9707be254adfbc0ba9f5fb9d2c5f--54cc2603dbf24611b9c1289130644a9a 68ad7dfac7cb4cfbb4030d92113db73a RX(theta\u2081\u2082) 54cc2603dbf24611b9c1289130644a9a--68ad7dfac7cb4cfbb4030d92113db73a 454e71049af24781b9ac862f3aeadd0e 68ad7dfac7cb4cfbb4030d92113db73a--454e71049af24781b9ac862f3aeadd0e ceb61506e9ad48dcb82e6bb75c6d0ee5 RX(theta\u2081\u2088) 454e71049af24781b9ac862f3aeadd0e--ceb61506e9ad48dcb82e6bb75c6d0ee5 18ce4b2e77f04dd8bc0456b7aeec2ff8 RY(theta\u2082\u2084) ceb61506e9ad48dcb82e6bb75c6d0ee5--18ce4b2e77f04dd8bc0456b7aeec2ff8 940ec6ab785d46e49b60c9f42ecb7e3a RX(theta\u2083\u2080) 18ce4b2e77f04dd8bc0456b7aeec2ff8--940ec6ab785d46e49b60c9f42ecb7e3a 0ecbd384bca9452dbecdd4d3037b802e 940ec6ab785d46e49b60c9f42ecb7e3a--0ecbd384bca9452dbecdd4d3037b802e fc1c3151c92848838d9f31a017063961 0ecbd384bca9452dbecdd4d3037b802e--fc1c3151c92848838d9f31a017063961 a005db1de02e4d51b8c35beec2778e13 c00db7f50d1442d6815b74d554d6f8bb RX(theta\u2081) b01b11066a0443998bcfad4be465dd60--c00db7f50d1442d6815b74d554d6f8bb 7979a71b163e49eb91a85b7ef719825c 2 457dc7953a434e97a88f7d1223e3e0cd RY(theta\u2087) c00db7f50d1442d6815b74d554d6f8bb--457dc7953a434e97a88f7d1223e3e0cd 910884e0d67e4a8b994310692e40c85f RX(theta\u2081\u2083) 457dc7953a434e97a88f7d1223e3e0cd--910884e0d67e4a8b994310692e40c85f fdee00c378c948de8517ad88423c61e6 910884e0d67e4a8b994310692e40c85f--fdee00c378c948de8517ad88423c61e6 00176f9fd5544ab1af8034a9e43612b5 RX(theta\u2081\u2089) fdee00c378c948de8517ad88423c61e6--00176f9fd5544ab1af8034a9e43612b5 bc8145a1318a4fdc9665635f766f0363 RY(theta\u2082\u2085) 00176f9fd5544ab1af8034a9e43612b5--bc8145a1318a4fdc9665635f766f0363 b0e16c4c76154618be8307eb8498acca RX(theta\u2083\u2081) bc8145a1318a4fdc9665635f766f0363--b0e16c4c76154618be8307eb8498acca f45fac4d25b14f798f97456355581e11 b0e16c4c76154618be8307eb8498acca--f45fac4d25b14f798f97456355581e11 f45fac4d25b14f798f97456355581e11--a005db1de02e4d51b8c35beec2778e13 5c1b0a2ee53b4727a479b7e4919017e1 871e89516952466eaf88c1901fba7175 RX(theta\u2082) 7979a71b163e49eb91a85b7ef719825c--871e89516952466eaf88c1901fba7175 b62ddc97487e4dfc8815edc302f00798 3 4fe5df7a348c4b62803a8e0476ba8f0b RY(theta\u2088) 871e89516952466eaf88c1901fba7175--4fe5df7a348c4b62803a8e0476ba8f0b c0346adce5244a83bcaa3540ca96e604 RX(theta\u2081\u2084) 4fe5df7a348c4b62803a8e0476ba8f0b--c0346adce5244a83bcaa3540ca96e604 1700fd0a8f524aae8933b69914b72e8e HamEvo c0346adce5244a83bcaa3540ca96e604--1700fd0a8f524aae8933b69914b72e8e cd7f991d0e9b416f8fb36567ed4cc405 RX(theta\u2082\u2080) 1700fd0a8f524aae8933b69914b72e8e--cd7f991d0e9b416f8fb36567ed4cc405 f005f2cc8b454664a822344eb4ae5992 RY(theta\u2082\u2086) cd7f991d0e9b416f8fb36567ed4cc405--f005f2cc8b454664a822344eb4ae5992 88401623d3af4478b3bfbd38fbbd3ce2 RX(theta\u2083\u2082) f005f2cc8b454664a822344eb4ae5992--88401623d3af4478b3bfbd38fbbd3ce2 e6e8306918784d9b88bcdcb98e583d96 HamEvo 88401623d3af4478b3bfbd38fbbd3ce2--e6e8306918784d9b88bcdcb98e583d96 e6e8306918784d9b88bcdcb98e583d96--5c1b0a2ee53b4727a479b7e4919017e1 63f4a5d79f204fd4a56154dff7894de5 2ef3d497e6d04ed59ce9b6f51ca8fe7a RX(theta\u2083) b62ddc97487e4dfc8815edc302f00798--2ef3d497e6d04ed59ce9b6f51ca8fe7a 4ef7fa18b3c54f96b43b6a42583c50b6 4 8556f59ab0994d1f8e5b2f95b986e6c7 RY(theta\u2089) 2ef3d497e6d04ed59ce9b6f51ca8fe7a--8556f59ab0994d1f8e5b2f95b986e6c7 41aa4c649f0047ffbc179c1c6e35310c RX(theta\u2081\u2085) 8556f59ab0994d1f8e5b2f95b986e6c7--41aa4c649f0047ffbc179c1c6e35310c ba14c0f2142c4853832e75e7c2e07c2c t = theta_t\u2080 41aa4c649f0047ffbc179c1c6e35310c--ba14c0f2142c4853832e75e7c2e07c2c a001fcda0db5403eb7cbfc1bf9805592 RX(theta\u2082\u2081) ba14c0f2142c4853832e75e7c2e07c2c--a001fcda0db5403eb7cbfc1bf9805592 473eca38fc044fe78cf6b3f54eebf938 RY(theta\u2082\u2087) a001fcda0db5403eb7cbfc1bf9805592--473eca38fc044fe78cf6b3f54eebf938 81280d571076483bab99bbe3504df362 RX(theta\u2083\u2083) 473eca38fc044fe78cf6b3f54eebf938--81280d571076483bab99bbe3504df362 0134b41145f6450a97a793d2491424a3 t = theta_t\u2081 81280d571076483bab99bbe3504df362--0134b41145f6450a97a793d2491424a3 0134b41145f6450a97a793d2491424a3--63f4a5d79f204fd4a56154dff7894de5 24da83f8589d44d1b1172068cbede22e a16e1ad777f6495197f50e8e6d623f5c RX(theta\u2084) 4ef7fa18b3c54f96b43b6a42583c50b6--a16e1ad777f6495197f50e8e6d623f5c a1b158f9cc2b4f95b39116a6924f8e1d 5 54dd1b5b73534525a1b5a2d61d3c86d9 RY(theta\u2081\u2080) a16e1ad777f6495197f50e8e6d623f5c--54dd1b5b73534525a1b5a2d61d3c86d9 14bcc0e9abde4919b9deb0d105126973 RX(theta\u2081\u2086) 54dd1b5b73534525a1b5a2d61d3c86d9--14bcc0e9abde4919b9deb0d105126973 1807c24596ef44a3be0b8b51e5acc03c 14bcc0e9abde4919b9deb0d105126973--1807c24596ef44a3be0b8b51e5acc03c c01dc0a2473447c99c185fca29487042 RX(theta\u2082\u2082) 1807c24596ef44a3be0b8b51e5acc03c--c01dc0a2473447c99c185fca29487042 ce868eb71d454ee39d89cc1cfda8647a RY(theta\u2082\u2088) c01dc0a2473447c99c185fca29487042--ce868eb71d454ee39d89cc1cfda8647a 12e2703eae6542009a87353cdb6d8b1f RX(theta\u2083\u2084) ce868eb71d454ee39d89cc1cfda8647a--12e2703eae6542009a87353cdb6d8b1f 10ce85356a2947c08cb4ee7fe11e88c7 12e2703eae6542009a87353cdb6d8b1f--10ce85356a2947c08cb4ee7fe11e88c7 10ce85356a2947c08cb4ee7fe11e88c7--24da83f8589d44d1b1172068cbede22e 7d091538f97d4d10b03e14421b223e9e c1027a2d93b44d6fa495f434083c4b3d RX(theta\u2085) a1b158f9cc2b4f95b39116a6924f8e1d--c1027a2d93b44d6fa495f434083c4b3d 6a1ce7f039ad4c9abbaa8479c31c549c RY(theta\u2081\u2081) c1027a2d93b44d6fa495f434083c4b3d--6a1ce7f039ad4c9abbaa8479c31c549c 8ea696b3f16f40748c14d47fdfc247a6 RX(theta\u2081\u2087) 6a1ce7f039ad4c9abbaa8479c31c549c--8ea696b3f16f40748c14d47fdfc247a6 366635066bcf43b5b2da329a52b8d8d1 8ea696b3f16f40748c14d47fdfc247a6--366635066bcf43b5b2da329a52b8d8d1 44d70d8c637643b090f0a20b6ef04c97 RX(theta\u2082\u2083) 366635066bcf43b5b2da329a52b8d8d1--44d70d8c637643b090f0a20b6ef04c97 3493b36ae8e4457087c1f58c8e79506d RY(theta\u2082\u2089) 44d70d8c637643b090f0a20b6ef04c97--3493b36ae8e4457087c1f58c8e79506d f17c977004a444778135a8181ee0175b RX(theta\u2083\u2085) 3493b36ae8e4457087c1f58c8e79506d--f17c977004a444778135a8181ee0175b ffc36b91f8da4d0584f0548768bda570 f17c977004a444778135a8181ee0175b--ffc36b91f8da4d0584f0548768bda570 ffc36b91f8da4d0584f0548768bda570--7d091538f97d4d10b03e14421b223e9e"},{"location":"qml/qml_tools/#machine-learning-tools","title":"Machine Learning Tools","text":""},{"location":"qml/qml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using <code>qadence</code>, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader\ndef dataloader() -&gt; DataLoader:\nbatch_size = 5\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\nreturn DataLoader(dataset, batch_size=batch_size)\ndef dictdataloader() -&gt; DictDataLoader:\nbatch_size = 5\nkeys = [\"y1\", \"y2\"]\ndls = {}\nfor k in keys:\nx = torch.rand(batch_size, 1)\ny = torch.sin(x)\ndataset = TensorDataset(x, y)\ndataloader = DataLoader(dataset, batch_size=batch_size)\ndls[k] = dataloader\nreturn DictDataLoader(dls)\nn_epochs = 2\n# iterate standard DataLoader\ndl = dataloader()\nfor i in range(n_epochs):\ndata = next(iter(dl))\n# iterate DictDataLoader\nddl = dictdataloader()\nfor i in range(n_epochs):\ndata = next(iter(ddl))\n</code></pre> <pre><code>\n</code></pre>"},{"location":"qml/qml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, <code>qadence</code> also offers a few out-of-the-box routines for optimizing differentiable models like <code>QNN</code>s and <code>QuantumModel</code>s containing either trainable and/or non-trainable parameters (you can refer to this for a refresh about different parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <pre><code>\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <pre><code>\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/qml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nimport matplotlib.pyplot as plt\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ntrain_with_grad(model, (x, y), optimizer, config, loss_fn=loss_fn)\nplt.plot(y.numpy())\nplt.plot(model(input_values).detach().numpy())\n</code></pre> <pre><code>\n</code></pre> <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/qml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1,2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': edfbe17a-fd6d-425d-917b-92fe08ae31e2, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 8c7c4017-8d3c-4512-95f9-a5a04a700a36, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': e4f02177-a4da-4396-8116-2db090db2e39, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b78b7968-56f2-406b-a652-d0e975ee1629, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ffaa2550-11cf-40ac-b3ff-5ddc0bbc388f, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 58c3c97c-4980-4f3f-ac1b-609fdc40c466, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 3502e317-6543-4479-bbc5-9a0a9c44239a, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 6b942a9c-fdbb-42fb-8048-43226e868fd2, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 94136f23-a818-4a48-9725-1e71aefd7527, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': bd7fbd28-b2fc-42a3-afdc-17ef04a09c99, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 8aaa7f08-8091-49e4-aaa2-c100812e39dc, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_6: tensor([0.5825], requires_grad=True)\ntheta_3: tensor([0.4370], requires_grad=True)\ntheta_0: tensor([0.7224], requires_grad=True)\ntheta_8: tensor([0.1922], requires_grad=True)\ntheta_2: tensor([0.8681], requires_grad=True)\ntheta_4: tensor([0.0779], requires_grad=True)\ntheta_7: tensor([0.8215], requires_grad=True)\ntheta_1: tensor([0.9099], requires_grad=True)\ntheta_5: tensor([0.3829], requires_grad=True)\n}\nembedded = {\nedfbe17a-fd6d-425d-917b-92fe08ae31e2: tensor([3., 3.])\n8c7c4017-8d3c-4512-95f9-a5a04a700a36: tensor([2., 2.])\ne4f02177-a4da-4396-8116-2db090db2e39: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\nb78b7968-56f2-406b-a652-d0e975ee1629: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\nffaa2550-11cf-40ac-b3ff-5ddc0bbc388f: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\n58c3c97c-4980-4f3f-ac1b-609fdc40c466: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\n3502e317-6543-4479-bbc5-9a0a9c44239a: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\n6b942a9c-fdbb-42fb-8048-43226e868fd2: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\n94136f23-a818-4a48-9725-1e71aefd7527: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\nbd7fbd28-b2fc-42a3-afdc-17ef04a09c99: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\n8aaa7f08-8091-49e4-aaa2-c100812e39dc: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ny: tensor([2., 2.])\ntheta_6: tensor([0.5825], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.4370], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.7224], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.1922], grad_fn=&lt;ViewBackward0&gt;)\ntheta_2: tensor([0.8681], grad_fn=&lt;ViewBackward0&gt;)\ntheta_4: tensor([0.0779], grad_fn=&lt;ViewBackward0&gt;)\ntheta_7: tensor([0.8215], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.])\ntheta_1: tensor([0.9099], grad_fn=&lt;ViewBackward0&gt;)\ntheta_5: tensor([0.3829], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j],\n[ 0.4139+0.0748j,  0.1140-0.2352j,  0.1632+0.1274j, -0.1267+0.3081j,\n-0.3707-0.2339j, -0.2020+0.1828j,  0.1915+0.2378j, -0.2855+0.3998j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 175, '011': 143, '100': 142, '111': 123, '010': 118, '001': 106, '101': 98, '110': 95})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(edfbe17a-fd6d-425d-917b-92fe08ae31e2)-C----------------------------------------Rx(e4f02177-a4da-4396-8116-2db090db2e39)-Ry(58c3c97c-4980-4f3f-ac1b-609fdc40c466)-Rx(94136f23-a818-4a48-9725-1e71aefd7527)-C---\n|                                                                                                                                                                   |   q1 : -Rz(8c7c4017-8d3c-4512-95f9-a5a04a700a36)-X----------------------------------------Rx(b78b7968-56f2-406b-a652-d0e975ee1629)-Ry(3502e317-6543-4479-bbc5-9a0a9c44239a)-Rx(bd7fbd28-b2fc-42a3-afdc-17ef04a09c99)-X-C-\n| q2 : -Rx(ffaa2550-11cf-40ac-b3ff-5ddc0bbc388f)-Ry(6b942a9c-fdbb-42fb-8048-43226e868fd2)-Rx(8aaa7f08-8091-49e4-aaa2-c100812e39dc)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [3502e317-6543-4479-bbc5-9a0a9c44239a, 58c3c97c-4980-4f3f-ac1b-609fdc40c466, 6b942a9c-fdbb-42fb-8048-43226e868fd2, 8aaa7f08-8091-49e4-aaa2-c100812e39dc, 8c7c4017-8d3c-4512-95f9-a5a04a700a36, 94136f23-a818-4a48-9725-1e71aefd7527, b78b7968-56f2-406b-a652-d0e975ee1629, bd7fbd28-b2fc-42a3-afdc-17ef04a09c99, e4f02177-a4da-4396-8116-2db090db2e39, edfbe17a-fd6d-425d-917b-92fe08ae31e2, ffaa2550-11cf-40ac-b3ff-5ddc0bbc388f].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(0.73)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.72)-DEPO(0.1)-Ry(0.44)-DEPO(0.1)-Rx(0.58)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.96)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.91)-DEPO(0.1)-Ry(0.08)-DEPO(0.1)-Rx(0.82)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.87)-DEPO(0.1)-Ry(0.38)-DEPO(0.1)-Rx(0.19)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 e904f34b47c94cdb8e37207c8cdd50fe 0 2066a8b6b42e4050962e168192f9d47f X e904f34b47c94cdb8e37207c8cdd50fe--2066a8b6b42e4050962e168192f9d47f 6356c4380a5c4bfa857afdde09a59d4b 1 ac048006206840bbac5aa8d279ae543d 2066a8b6b42e4050962e168192f9d47f--ac048006206840bbac5aa8d279ae543d 9cdc2092980b4db1a102d27cb2471243 62d9e75b3acb4bb9a2befa6a197c0c8d Y 6356c4380a5c4bfa857afdde09a59d4b--62d9e75b3acb4bb9a2befa6a197c0c8d 62d9e75b3acb4bb9a2befa6a197c0c8d--9cdc2092980b4db1a102d27cb2471243 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 4d076105e0af42e6a8fe5bbc6ff6a8a8 0 9e097c3800a44cf0901a7bcf3547f18d RX(0.5) 4d076105e0af42e6a8fe5bbc6ff6a8a8--9e097c3800a44cf0901a7bcf3547f18d e143ba87599e4a6bab79825ce4125e39 9e097c3800a44cf0901a7bcf3547f18d--e143ba87599e4a6bab79825ce4125e39 <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 3ae337be86044d9b9f42786545f9d1bb 0 d3982ed9e33541b0a3dce42538b8de5a 3ae337be86044d9b9f42786545f9d1bb--d3982ed9e33541b0a3dce42538b8de5a 356b2e525e7147a48eae84af912d67e8 1 e57ef937aa834d0fb999aaad0ad2559c d3982ed9e33541b0a3dce42538b8de5a--e57ef937aa834d0fb999aaad0ad2559c 102b9840e6624951837826fbeb2bf9a3 c978e9cae05d476dae85947c92fa673e X 356b2e525e7147a48eae84af912d67e8--c978e9cae05d476dae85947c92fa673e c978e9cae05d476dae85947c92fa673e--d3982ed9e33541b0a3dce42538b8de5a c978e9cae05d476dae85947c92fa673e--102b9840e6624951837826fbeb2bf9a3 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 006d167de96f45a8a7ce13276d2eb2f5 0 ad26c60849aa4b2e98000ec36e4d5c92 X 006d167de96f45a8a7ce13276d2eb2f5--ad26c60849aa4b2e98000ec36e4d5c92 c0dc710645a74482872d369876f1f00d X ad26c60849aa4b2e98000ec36e4d5c92--c0dc710645a74482872d369876f1f00d 43314f7ab8ce458c85bdd50865e6c917 c0dc710645a74482872d369876f1f00d--43314f7ab8ce458c85bdd50865e6c917 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 e6aba2e5fa9d4e69974c4930b4ed511a 0 972e00f2a7e84555aa12ef91ff53cdf6 X e6aba2e5fa9d4e69974c4930b4ed511a--972e00f2a7e84555aa12ef91ff53cdf6 0f69bf8858fa41f6929a78d853a4a3fd 1 205229e6addf46f0ad3f2ee62560b4de 972e00f2a7e84555aa12ef91ff53cdf6--205229e6addf46f0ad3f2ee62560b4de 50c6e79fccf24b65b7bab74b98cf2707 205229e6addf46f0ad3f2ee62560b4de--50c6e79fccf24b65b7bab74b98cf2707 21c52f28ad9a48358924f093b557dbac 693921b432fc4d54965b7cbf0236cb45 0f69bf8858fa41f6929a78d853a4a3fd--693921b432fc4d54965b7cbf0236cb45 29c7eee43b6b409ab5c8bab2cb04a71d X 693921b432fc4d54965b7cbf0236cb45--29c7eee43b6b409ab5c8bab2cb04a71d 29c7eee43b6b409ab5c8bab2cb04a71d--21c52f28ad9a48358924f093b557dbac </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 8980df0b498045bb99b0ca66cd7f4002 0 a2e60880c89049d89d215f888c5e9a93 X 8980df0b498045bb99b0ca66cd7f4002--a2e60880c89049d89d215f888c5e9a93 d94e74c6d45548ecb6ccdeea55b66488 1 ab6b9ca7097f445d964ad53466c23689 a2e60880c89049d89d215f888c5e9a93--ab6b9ca7097f445d964ad53466c23689 49bedcaa3bd443ba919b35a26ff6820f 96e6eb15f9be4826a64d3eb119bc414f X d94e74c6d45548ecb6ccdeea55b66488--96e6eb15f9be4826a64d3eb119bc414f 96e6eb15f9be4826a64d3eb119bc414f--49bedcaa3bd443ba919b35a26ff6820f <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_7706ee121d2442898deab84ee014a404 subblock cluster_84be3eda2b154ebd97d4d5f26764874d subblock 88c71414db0e46639dfcecdf7c0c5030 0 3abadc018edb4e559543a4fd798db6bb X 88c71414db0e46639dfcecdf7c0c5030--3abadc018edb4e559543a4fd798db6bb 8f1add4deb6549119849ef4eb99a3cfd 1 affa898d10a5438b92de71a49b366681 X 3abadc018edb4e559543a4fd798db6bb--affa898d10a5438b92de71a49b366681 098de964ae0947468e3d84208823b75c affa898d10a5438b92de71a49b366681--098de964ae0947468e3d84208823b75c 45590d11f4b5420ebd03da6fe51fe005 f410add6c7824966817b2abede942224 Y 8f1add4deb6549119849ef4eb99a3cfd--f410add6c7824966817b2abede942224 0017cfe05cc1485daa051ecd8ffa0e26 2 c7d0a9f47ec84671acd2966798101ab6 Y f410add6c7824966817b2abede942224--c7d0a9f47ec84671acd2966798101ab6 c7d0a9f47ec84671acd2966798101ab6--45590d11f4b5420ebd03da6fe51fe005 73aa4f176181447cbc60c7281ccb907f fc9dc6ea125f437d83ed757ea5dc0002 0017cfe05cc1485daa051ecd8ffa0e26--fc9dc6ea125f437d83ed757ea5dc0002 758c46f9889744eaaa7b6a737eec5d4c 3 adaa50d5fc63417bbc6b62390384b441 fc9dc6ea125f437d83ed757ea5dc0002--adaa50d5fc63417bbc6b62390384b441 adaa50d5fc63417bbc6b62390384b441--73aa4f176181447cbc60c7281ccb907f 900b4972e58e4f87bba6306b322efc41 1aa307fafa8c43ea812c4573011d1baf 758c46f9889744eaaa7b6a737eec5d4c--1aa307fafa8c43ea812c4573011d1baf 750fd3e199fd47cca0fdb691525b3896 4 f9ede64b2a2e4c2abea7446841a896bc 1aa307fafa8c43ea812c4573011d1baf--f9ede64b2a2e4c2abea7446841a896bc f9ede64b2a2e4c2abea7446841a896bc--900b4972e58e4f87bba6306b322efc41 1ff4800629d04e92bde76929f26a59ce 8f8f8da598e843438b74ba2f50b675dc X 750fd3e199fd47cca0fdb691525b3896--8f8f8da598e843438b74ba2f50b675dc 8f8f8da598e843438b74ba2f50b675dc--1aa307fafa8c43ea812c4573011d1baf 4ac85d542cea4b929743bd26f8404781 X 8f8f8da598e843438b74ba2f50b675dc--4ac85d542cea4b929743bd26f8404781 4ac85d542cea4b929743bd26f8404781--f9ede64b2a2e4c2abea7446841a896bc 4ac85d542cea4b929743bd26f8404781--1ff4800629d04e92bde76929f26a59ce"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'00': 271, '10': 252, '01': 247, '11': 230})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '000': 27, '010': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be indentical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(list(range(n_qubits)), n_qubits, replace=True)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[2.5000e-01, 4.4409e-16],\n[4.4409e-16, 4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2540, -0.0092],\n[-0.0006, -0.0004]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9868+0.0000j, 0.0000-0.1621j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8778+0.0000j, 0.0000-0.4791j],\n[0.9593+0.0000j, 0.0000-0.2825j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5086+0.0000j, 0.6844+0.0000j, 0.0000-0.3116j, 0.0000-0.4194j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_24a8a73fd1254f359f87df9331298a4f [* 2] cluster_a26fd5ccb79844e7a6922f9bbfbb6005 Rotations ac9bf9d4ee51415389f22602bd28f9d0 0 d18c849062e0418385e3b24a043bfdc4 RX(phi/theta) ac9bf9d4ee51415389f22602bd28f9d0--d18c849062e0418385e3b24a043bfdc4 032b4d12d9534b21b6ad68fe4e8745a0 1 6ab126a6658f4474b1c916535aa70858 RX(phi) d18c849062e0418385e3b24a043bfdc4--6ab126a6658f4474b1c916535aa70858 96e7145cf7754bbaae03d83489a71658 RX(phi) 6ab126a6658f4474b1c916535aa70858--96e7145cf7754bbaae03d83489a71658 04ce7193ec17422ea8c6d88048a2ad47 RX(phi + theta) 96e7145cf7754bbaae03d83489a71658--04ce7193ec17422ea8c6d88048a2ad47 1e80c9bbd7ff42e4a2c7e2c31870f579 04ce7193ec17422ea8c6d88048a2ad47--1e80c9bbd7ff42e4a2c7e2c31870f579 4a85dac156134236b0c22794c241441d 1e80c9bbd7ff42e4a2c7e2c31870f579--4a85dac156134236b0c22794c241441d 3b51aef0c41846179bd8218ea876aef2 Z 4a85dac156134236b0c22794c241441d--3b51aef0c41846179bd8218ea876aef2 bb4107a4202e44029436410783c51d44 3b51aef0c41846179bd8218ea876aef2--bb4107a4202e44029436410783c51d44 e2e7e401cf3a45b5988c46adbfcedc88 f3c56caefbab4699a22a56a7e1036549 RY(2*theta) 032b4d12d9534b21b6ad68fe4e8745a0--f3c56caefbab4699a22a56a7e1036549 0eb7415425a54c22885e0684fc1f0a7c 2 8b745f1a11b44d788453f7cf85873c00 RY(theta) f3c56caefbab4699a22a56a7e1036549--8b745f1a11b44d788453f7cf85873c00 249de08cd6574e9498c806f183b075b0 RY(theta) 8b745f1a11b44d788453f7cf85873c00--249de08cd6574e9498c806f183b075b0 62ec7a29f4c7405ebee1ff1738a3634d RY(theta**2) 249de08cd6574e9498c806f183b075b0--62ec7a29f4c7405ebee1ff1738a3634d d95d4ec87c2a450e8b93027220b096d5 X 62ec7a29f4c7405ebee1ff1738a3634d--d95d4ec87c2a450e8b93027220b096d5 d95d4ec87c2a450e8b93027220b096d5--1e80c9bbd7ff42e4a2c7e2c31870f579 484c03eee7b8423f9333bdcdbc003ae6 d95d4ec87c2a450e8b93027220b096d5--484c03eee7b8423f9333bdcdbc003ae6 1ff7a173de6045feb134209c42ca1b16 Z 484c03eee7b8423f9333bdcdbc003ae6--1ff7a173de6045feb134209c42ca1b16 1ff7a173de6045feb134209c42ca1b16--e2e7e401cf3a45b5988c46adbfcedc88 c77e3ad3427f4e349bcbf0cde677228f 2fbdd83770394769954ea1818e98c1e6 RZ(cos(phi)) 0eb7415425a54c22885e0684fc1f0a7c--2fbdd83770394769954ea1818e98c1e6 f204a586eaa744d39ff5df3d8d9e16a1 RZ(phi) 2fbdd83770394769954ea1818e98c1e6--f204a586eaa744d39ff5df3d8d9e16a1 ec8a2654a1bb4ababcd3616f136cfe4b RZ(phi) f204a586eaa744d39ff5df3d8d9e16a1--ec8a2654a1bb4ababcd3616f136cfe4b 594dde5b353842db9ea6716a0e5c783d RZ(cos(phi)) ec8a2654a1bb4ababcd3616f136cfe4b--594dde5b353842db9ea6716a0e5c783d f5577ade330f4616acec0594cad2b2d6 594dde5b353842db9ea6716a0e5c783d--f5577ade330f4616acec0594cad2b2d6 ecc1fdc01350418a9763a88815208738 X f5577ade330f4616acec0594cad2b2d6--ecc1fdc01350418a9763a88815208738 ecc1fdc01350418a9763a88815208738--484c03eee7b8423f9333bdcdbc003ae6 7f2e75d9cfdc4ae6b35909485006d93a Z ecc1fdc01350418a9763a88815208738--7f2e75d9cfdc4ae6b35909485006d93a 7f2e75d9cfdc4ae6b35909485006d93a--c77e3ad3427f4e349bcbf0cde677228f <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6171]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.5703+0.0000j, 0.4950+0.0000j, 0.0000-0.4950j, 0.0000-0.4297j],\n[0.8421+0.0000j, 0.3647+0.0000j, 0.0000-0.3647j, 0.0000-0.1579j],\n[0.8410+0.0000j, 0.3656+0.0000j, 0.0000-0.3656j, 0.0000-0.1590j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 f599bca1dec74e92953cf1a79e398592 0 18d6ddb71872499e82faf5bbb8b1830f RX(theta\u2080) f599bca1dec74e92953cf1a79e398592--18d6ddb71872499e82faf5bbb8b1830f c7943c7b128f4fec8a68a9df01652673 1 2ad6e99ff9324eef928e4e617c01d153 RY(theta\u2084) 18d6ddb71872499e82faf5bbb8b1830f--2ad6e99ff9324eef928e4e617c01d153 fe018d3a048344238fdc36199d20f1b8 RX(theta\u2088) 2ad6e99ff9324eef928e4e617c01d153--fe018d3a048344238fdc36199d20f1b8 e9bc62686a964d21a3e1bb8415d0415e fe018d3a048344238fdc36199d20f1b8--e9bc62686a964d21a3e1bb8415d0415e a2ea7ecf50c14aa18bbbf25f4dcdd51f e9bc62686a964d21a3e1bb8415d0415e--a2ea7ecf50c14aa18bbbf25f4dcdd51f 1dd158934bc84616ab4e9d8010df35b0 RX(theta\u2081\u2082) a2ea7ecf50c14aa18bbbf25f4dcdd51f--1dd158934bc84616ab4e9d8010df35b0 8a17c63084a84ee88f37155c45ff796a RY(theta\u2081\u2086) 1dd158934bc84616ab4e9d8010df35b0--8a17c63084a84ee88f37155c45ff796a 47590b8580374a6cb338a094dc91e91a RX(theta\u2082\u2080) 8a17c63084a84ee88f37155c45ff796a--47590b8580374a6cb338a094dc91e91a 25384ff6a88f4e02b9043bb84fa2377f 47590b8580374a6cb338a094dc91e91a--25384ff6a88f4e02b9043bb84fa2377f f3af273d11f4468ba59296a547e48494 25384ff6a88f4e02b9043bb84fa2377f--f3af273d11f4468ba59296a547e48494 336480c8f8be46ddb4f1d8abcc3653e0 f3af273d11f4468ba59296a547e48494--336480c8f8be46ddb4f1d8abcc3653e0 db5881afaba84834bcc004049adc12a8 38b89efa6800437e8210489eaacf391b RX(theta\u2081) c7943c7b128f4fec8a68a9df01652673--38b89efa6800437e8210489eaacf391b 9a1262220d204f8a81704dd049eaa222 2 338c4c1c687944309529eea1cd0e3a5b RY(theta\u2085) 38b89efa6800437e8210489eaacf391b--338c4c1c687944309529eea1cd0e3a5b 2ed7dec5f22747e690853960e3e4d7d1 RX(theta\u2089) 338c4c1c687944309529eea1cd0e3a5b--2ed7dec5f22747e690853960e3e4d7d1 395916bfd6164528bb336a06cf936e97 X 2ed7dec5f22747e690853960e3e4d7d1--395916bfd6164528bb336a06cf936e97 395916bfd6164528bb336a06cf936e97--e9bc62686a964d21a3e1bb8415d0415e bc5c47ec87884933b5e2c27dc9698322 395916bfd6164528bb336a06cf936e97--bc5c47ec87884933b5e2c27dc9698322 999c9a37bfa64df1bd56661af408ec84 RX(theta\u2081\u2083) bc5c47ec87884933b5e2c27dc9698322--999c9a37bfa64df1bd56661af408ec84 0a40e05062864ba5a12013683e555f60 RY(theta\u2081\u2087) 999c9a37bfa64df1bd56661af408ec84--0a40e05062864ba5a12013683e555f60 36002a0c0da842fe9dedc8b6206b5307 RX(theta\u2082\u2081) 0a40e05062864ba5a12013683e555f60--36002a0c0da842fe9dedc8b6206b5307 2f7cbc48de4d491daf6dd7861c56f063 X 36002a0c0da842fe9dedc8b6206b5307--2f7cbc48de4d491daf6dd7861c56f063 2f7cbc48de4d491daf6dd7861c56f063--25384ff6a88f4e02b9043bb84fa2377f c5a6fe7aa2fe4d8e95114628ca84f844 2f7cbc48de4d491daf6dd7861c56f063--c5a6fe7aa2fe4d8e95114628ca84f844 c5a6fe7aa2fe4d8e95114628ca84f844--db5881afaba84834bcc004049adc12a8 da1e5114c0dd45e592e649cf81b547cc cb0f8127965e4faeb92868c055880059 RX(theta\u2082) 9a1262220d204f8a81704dd049eaa222--cb0f8127965e4faeb92868c055880059 aaad5e9d0eaa42ccb58296ffd5c532cd 3 0b597770f7b44b84ba20247a199c2388 RY(theta\u2086) cb0f8127965e4faeb92868c055880059--0b597770f7b44b84ba20247a199c2388 fe624c78d2e941df8328c49c0022926f RX(theta\u2081\u2080) 0b597770f7b44b84ba20247a199c2388--fe624c78d2e941df8328c49c0022926f da563c01a42e408493c2a74965d65a75 fe624c78d2e941df8328c49c0022926f--da563c01a42e408493c2a74965d65a75 28ddb849501b4767b61ed86314adaf18 X da563c01a42e408493c2a74965d65a75--28ddb849501b4767b61ed86314adaf18 28ddb849501b4767b61ed86314adaf18--bc5c47ec87884933b5e2c27dc9698322 1f911b3c70e545038aa5e03ab8f32d4a RX(theta\u2081\u2084) 28ddb849501b4767b61ed86314adaf18--1f911b3c70e545038aa5e03ab8f32d4a e6c7daefdbd84841a6a9dd483e855ac0 RY(theta\u2081\u2088) 1f911b3c70e545038aa5e03ab8f32d4a--e6c7daefdbd84841a6a9dd483e855ac0 3a3442f5bb53470aa64a13c1071227a1 RX(theta\u2082\u2082) e6c7daefdbd84841a6a9dd483e855ac0--3a3442f5bb53470aa64a13c1071227a1 32423df56f434afca40fb0c8830950b5 3a3442f5bb53470aa64a13c1071227a1--32423df56f434afca40fb0c8830950b5 d4022386521c4d20ba0d98969980518d X 32423df56f434afca40fb0c8830950b5--d4022386521c4d20ba0d98969980518d d4022386521c4d20ba0d98969980518d--c5a6fe7aa2fe4d8e95114628ca84f844 d4022386521c4d20ba0d98969980518d--da1e5114c0dd45e592e649cf81b547cc 469b091caf934db9a225b40025cfa0d7 9a6bb50b7b434629aecdd3f30480ef13 RX(theta\u2083) aaad5e9d0eaa42ccb58296ffd5c532cd--9a6bb50b7b434629aecdd3f30480ef13 a8465a3712c14ebf8e556353f00d4ce8 RY(theta\u2087) 9a6bb50b7b434629aecdd3f30480ef13--a8465a3712c14ebf8e556353f00d4ce8 9f5fddaed15649f7851ccd9c6ac6295a RX(theta\u2081\u2081) a8465a3712c14ebf8e556353f00d4ce8--9f5fddaed15649f7851ccd9c6ac6295a 6cb169b6cb674675935a8953443cb2b5 X 9f5fddaed15649f7851ccd9c6ac6295a--6cb169b6cb674675935a8953443cb2b5 6cb169b6cb674675935a8953443cb2b5--da563c01a42e408493c2a74965d65a75 dff72beb7c204c88acac6b2107ef346b 6cb169b6cb674675935a8953443cb2b5--dff72beb7c204c88acac6b2107ef346b a918d475972442268b859400bced5e30 RX(theta\u2081\u2085) dff72beb7c204c88acac6b2107ef346b--a918d475972442268b859400bced5e30 a02803aab0d54cddbff270bff430be69 RY(theta\u2081\u2089) a918d475972442268b859400bced5e30--a02803aab0d54cddbff270bff430be69 ce7522041c6842a380f820564e0faa5a RX(theta\u2082\u2083) a02803aab0d54cddbff270bff430be69--ce7522041c6842a380f820564e0faa5a 714a3e6b7de8420bba553d8a0734651e X ce7522041c6842a380f820564e0faa5a--714a3e6b7de8420bba553d8a0734651e 714a3e6b7de8420bba553d8a0734651e--32423df56f434afca40fb0c8830950b5 46a66520827f4591a56dad3fc33f24fd 714a3e6b7de8420bba553d8a0734651e--46a66520827f4591a56dad3fc33f24fd 46a66520827f4591a56dad3fc33f24fd--469b091caf934db9a225b40025cfa0d7 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_814fc74c187e47b5a24a6450315750d0 HEA cluster_50e66c59b2c24029bc5f34741be66ae3 HEA eafa5ef985a74c5a99606222a043659e 0 a310144670f644fd84c15bf4d37315bd RX(theta\u2080) eafa5ef985a74c5a99606222a043659e--a310144670f644fd84c15bf4d37315bd 479e63d5f42045ef8d4dfb29a4db025f 1 4b130c49950a401981a4e06014d5a07c RY(theta\u2084) a310144670f644fd84c15bf4d37315bd--4b130c49950a401981a4e06014d5a07c ca3918880525483eb375920c047c91e6 RX(theta\u2088) 4b130c49950a401981a4e06014d5a07c--ca3918880525483eb375920c047c91e6 110f1a528d964ace9e51dc17e41c26c3 ca3918880525483eb375920c047c91e6--110f1a528d964ace9e51dc17e41c26c3 514b461d4b77479585fd405acc4e20f5 110f1a528d964ace9e51dc17e41c26c3--514b461d4b77479585fd405acc4e20f5 78092d3889fe4da48235882fc4080f98 RX(theta\u2081\u2082) 514b461d4b77479585fd405acc4e20f5--78092d3889fe4da48235882fc4080f98 8bdcc502b0954e05bfffc166f9148c6a RY(theta\u2081\u2086) 78092d3889fe4da48235882fc4080f98--8bdcc502b0954e05bfffc166f9148c6a 4e12656812d8496b8b4baa16430a2d8f RX(theta\u2082\u2080) 8bdcc502b0954e05bfffc166f9148c6a--4e12656812d8496b8b4baa16430a2d8f fba4717ba4864b629ef3738a9e1b8b9a 4e12656812d8496b8b4baa16430a2d8f--fba4717ba4864b629ef3738a9e1b8b9a f509ed4988e7400ba516cf10de6ca696 fba4717ba4864b629ef3738a9e1b8b9a--f509ed4988e7400ba516cf10de6ca696 4aa8e26fcd8d455282f1727ed97e1b5d RX(theta\u2080) f509ed4988e7400ba516cf10de6ca696--4aa8e26fcd8d455282f1727ed97e1b5d bbef581f71f244f7a96caa7b3a2045cf RY(theta\u2084) 4aa8e26fcd8d455282f1727ed97e1b5d--bbef581f71f244f7a96caa7b3a2045cf da9f136f97c646dbb054e64174fc4d37 RX(theta\u2088) bbef581f71f244f7a96caa7b3a2045cf--da9f136f97c646dbb054e64174fc4d37 96a83e3bbfc244a681ea4adba1653196 da9f136f97c646dbb054e64174fc4d37--96a83e3bbfc244a681ea4adba1653196 46894997a6064f829952e28fd87057fe 96a83e3bbfc244a681ea4adba1653196--46894997a6064f829952e28fd87057fe 443387fb30ed44b9b45434e405c81429 RX(theta\u2081\u2082) 46894997a6064f829952e28fd87057fe--443387fb30ed44b9b45434e405c81429 f27156185f7e44eba8af8ecf2865a1dc RY(theta\u2081\u2086) 443387fb30ed44b9b45434e405c81429--f27156185f7e44eba8af8ecf2865a1dc bc1025eb4c484877a7fd1b7b0f762c7c RX(theta\u2082\u2080) f27156185f7e44eba8af8ecf2865a1dc--bc1025eb4c484877a7fd1b7b0f762c7c d19fb4c2df7f433f8a712454909d1e01 bc1025eb4c484877a7fd1b7b0f762c7c--d19fb4c2df7f433f8a712454909d1e01 338a14a12629423b946014865c97dc50 d19fb4c2df7f433f8a712454909d1e01--338a14a12629423b946014865c97dc50 8190a466f49e4a7ca23c2e8b1acb214a 338a14a12629423b946014865c97dc50--8190a466f49e4a7ca23c2e8b1acb214a 41cfbc849cf5448e871976f36f3f9fbf a2a0d325b6514cf49ab902e555a819c8 RX(theta\u2081) 479e63d5f42045ef8d4dfb29a4db025f--a2a0d325b6514cf49ab902e555a819c8 100736fcb081460fb18219e56aef55ed 2 25f3eb0b3bb54bc5b6c593f90771a4ad RY(theta\u2085) a2a0d325b6514cf49ab902e555a819c8--25f3eb0b3bb54bc5b6c593f90771a4ad e015337811364904a1ac4e9aa19d9489 RX(theta\u2089) 25f3eb0b3bb54bc5b6c593f90771a4ad--e015337811364904a1ac4e9aa19d9489 9a4c222822a64376b469703a2bdfa8fd X e015337811364904a1ac4e9aa19d9489--9a4c222822a64376b469703a2bdfa8fd 9a4c222822a64376b469703a2bdfa8fd--110f1a528d964ace9e51dc17e41c26c3 73102c7e54484ba5bd57dc53cb450377 9a4c222822a64376b469703a2bdfa8fd--73102c7e54484ba5bd57dc53cb450377 4bf9331db5384b8f835edce4c99a9195 RX(theta\u2081\u2083) 73102c7e54484ba5bd57dc53cb450377--4bf9331db5384b8f835edce4c99a9195 b99b070a6c784954af765f564bf07732 RY(theta\u2081\u2087) 4bf9331db5384b8f835edce4c99a9195--b99b070a6c784954af765f564bf07732 9122cf3e80974499bce55dbbc44c2902 RX(theta\u2082\u2081) b99b070a6c784954af765f564bf07732--9122cf3e80974499bce55dbbc44c2902 094f544e7daf4b538871c45db2e1a99f X 9122cf3e80974499bce55dbbc44c2902--094f544e7daf4b538871c45db2e1a99f 094f544e7daf4b538871c45db2e1a99f--fba4717ba4864b629ef3738a9e1b8b9a e149f24588ce4835a781bc42107ead39 094f544e7daf4b538871c45db2e1a99f--e149f24588ce4835a781bc42107ead39 281026c37f5f42c8a87b5b86aaeb2d2f RX(theta\u2081) e149f24588ce4835a781bc42107ead39--281026c37f5f42c8a87b5b86aaeb2d2f ff853b6d58f240d2971fda409a531ede RY(theta\u2085) 281026c37f5f42c8a87b5b86aaeb2d2f--ff853b6d58f240d2971fda409a531ede d353018a86ae40daa9755159653624dd RX(theta\u2089) ff853b6d58f240d2971fda409a531ede--d353018a86ae40daa9755159653624dd f9d21c3d9af745e5bc22c0689dedd391 X d353018a86ae40daa9755159653624dd--f9d21c3d9af745e5bc22c0689dedd391 f9d21c3d9af745e5bc22c0689dedd391--96a83e3bbfc244a681ea4adba1653196 adf9b4f72cd644ff81dfa8ff711c9ac9 f9d21c3d9af745e5bc22c0689dedd391--adf9b4f72cd644ff81dfa8ff711c9ac9 3343c6acbe3c46a9959372023fea2410 RX(theta\u2081\u2083) adf9b4f72cd644ff81dfa8ff711c9ac9--3343c6acbe3c46a9959372023fea2410 d326cb195e2f4653bbf3096a763df2df RY(theta\u2081\u2087) 3343c6acbe3c46a9959372023fea2410--d326cb195e2f4653bbf3096a763df2df 7a7ff92dc208464c93083e45481fff7d RX(theta\u2082\u2081) d326cb195e2f4653bbf3096a763df2df--7a7ff92dc208464c93083e45481fff7d 2619dc1d63a748dc8907a34d85bbb883 X 7a7ff92dc208464c93083e45481fff7d--2619dc1d63a748dc8907a34d85bbb883 2619dc1d63a748dc8907a34d85bbb883--d19fb4c2df7f433f8a712454909d1e01 bd1148018cd94b47979d780a25e34b1a 2619dc1d63a748dc8907a34d85bbb883--bd1148018cd94b47979d780a25e34b1a bd1148018cd94b47979d780a25e34b1a--41cfbc849cf5448e871976f36f3f9fbf 8acf959eb7b145aab6b5713f981bf22a 550f61ee0a29479d886bdd360b45a8c5 RX(theta\u2082) 100736fcb081460fb18219e56aef55ed--550f61ee0a29479d886bdd360b45a8c5 4a212f34914a48c2968c5590e9bb32ca 3 ea2a3b48eb7c4e3eb04b1b070eab1eb0 RY(theta\u2086) 550f61ee0a29479d886bdd360b45a8c5--ea2a3b48eb7c4e3eb04b1b070eab1eb0 19b32de04c334d78804b5ba66da2d008 RX(theta\u2081\u2080) ea2a3b48eb7c4e3eb04b1b070eab1eb0--19b32de04c334d78804b5ba66da2d008 6885c156d56f4e51944561bebfafc515 19b32de04c334d78804b5ba66da2d008--6885c156d56f4e51944561bebfafc515 8c95b50107b54fde91f7609089f4c53a X 6885c156d56f4e51944561bebfafc515--8c95b50107b54fde91f7609089f4c53a 8c95b50107b54fde91f7609089f4c53a--73102c7e54484ba5bd57dc53cb450377 1219cd38b7d34be796757aa77eca7d5e RX(theta\u2081\u2084) 8c95b50107b54fde91f7609089f4c53a--1219cd38b7d34be796757aa77eca7d5e 6720a8dedc1a44ca915c94866ed009bc RY(theta\u2081\u2088) 1219cd38b7d34be796757aa77eca7d5e--6720a8dedc1a44ca915c94866ed009bc dfd18c69125a464f870b155940efd9dc RX(theta\u2082\u2082) 6720a8dedc1a44ca915c94866ed009bc--dfd18c69125a464f870b155940efd9dc 999c1283abd44cb98a1fbe6d072125dd dfd18c69125a464f870b155940efd9dc--999c1283abd44cb98a1fbe6d072125dd f7a6ef5b4d2f42948f54179ed8862a6f X 999c1283abd44cb98a1fbe6d072125dd--f7a6ef5b4d2f42948f54179ed8862a6f f7a6ef5b4d2f42948f54179ed8862a6f--e149f24588ce4835a781bc42107ead39 d4e45871b69e4938bccf74767034d99f RX(theta\u2082) f7a6ef5b4d2f42948f54179ed8862a6f--d4e45871b69e4938bccf74767034d99f c14077eecee042209eeab61c3dfb5329 RY(theta\u2086) d4e45871b69e4938bccf74767034d99f--c14077eecee042209eeab61c3dfb5329 bb13ccf54cf745be8c04afa1e15dddb7 RX(theta\u2081\u2080) c14077eecee042209eeab61c3dfb5329--bb13ccf54cf745be8c04afa1e15dddb7 222516eaaa3246f8b217d07046f3f367 bb13ccf54cf745be8c04afa1e15dddb7--222516eaaa3246f8b217d07046f3f367 161bd327e0f04cc38ecdae6c5aa3bfc6 X 222516eaaa3246f8b217d07046f3f367--161bd327e0f04cc38ecdae6c5aa3bfc6 161bd327e0f04cc38ecdae6c5aa3bfc6--adf9b4f72cd644ff81dfa8ff711c9ac9 9f5343d25ef3433b9be1d94fb436494d RX(theta\u2081\u2084) 161bd327e0f04cc38ecdae6c5aa3bfc6--9f5343d25ef3433b9be1d94fb436494d 22da4d2226734ff080d7353adbec1dad RY(theta\u2081\u2088) 9f5343d25ef3433b9be1d94fb436494d--22da4d2226734ff080d7353adbec1dad 4ab1e319a4e24f0e9bb3aea4317631d9 RX(theta\u2082\u2082) 22da4d2226734ff080d7353adbec1dad--4ab1e319a4e24f0e9bb3aea4317631d9 e2e343ab58a747479c26da876b016db5 4ab1e319a4e24f0e9bb3aea4317631d9--e2e343ab58a747479c26da876b016db5 25e9775af6bd4b91a78a5fc34def8b16 X e2e343ab58a747479c26da876b016db5--25e9775af6bd4b91a78a5fc34def8b16 25e9775af6bd4b91a78a5fc34def8b16--bd1148018cd94b47979d780a25e34b1a 25e9775af6bd4b91a78a5fc34def8b16--8acf959eb7b145aab6b5713f981bf22a d30a3334f9ed4bc68df1d65e5c26b140 9a636c7f8112498296aa363d61db5a2a RX(theta\u2083) 4a212f34914a48c2968c5590e9bb32ca--9a636c7f8112498296aa363d61db5a2a f63c5c43107a43da832beba58db39b4f RY(theta\u2087) 9a636c7f8112498296aa363d61db5a2a--f63c5c43107a43da832beba58db39b4f f1aa777f59c1407c895542a620dcce86 RX(theta\u2081\u2081) f63c5c43107a43da832beba58db39b4f--f1aa777f59c1407c895542a620dcce86 07d01afb0d7a4438a39dd3dbbbeab3c0 X f1aa777f59c1407c895542a620dcce86--07d01afb0d7a4438a39dd3dbbbeab3c0 07d01afb0d7a4438a39dd3dbbbeab3c0--6885c156d56f4e51944561bebfafc515 e24e9da5267d4a41a101e229d458a9cc 07d01afb0d7a4438a39dd3dbbbeab3c0--e24e9da5267d4a41a101e229d458a9cc a9c1998821c9465b9036cd6912900fec RX(theta\u2081\u2085) e24e9da5267d4a41a101e229d458a9cc--a9c1998821c9465b9036cd6912900fec aee2841f97e0484f93ddab0595e3ac9a RY(theta\u2081\u2089) a9c1998821c9465b9036cd6912900fec--aee2841f97e0484f93ddab0595e3ac9a 4555da41ffab4222b8789cb4db36f588 RX(theta\u2082\u2083) aee2841f97e0484f93ddab0595e3ac9a--4555da41ffab4222b8789cb4db36f588 fc1f7a9c079e487fbea211d6b54c7d1f X 4555da41ffab4222b8789cb4db36f588--fc1f7a9c079e487fbea211d6b54c7d1f fc1f7a9c079e487fbea211d6b54c7d1f--999c1283abd44cb98a1fbe6d072125dd aad8aaa46b6b4bccb53bd758ecfd1620 fc1f7a9c079e487fbea211d6b54c7d1f--aad8aaa46b6b4bccb53bd758ecfd1620 dad811ede2204017846db118c1c8581e RX(theta\u2083) aad8aaa46b6b4bccb53bd758ecfd1620--dad811ede2204017846db118c1c8581e 24dd11231e9c4b00971ba78c1d2c4836 RY(theta\u2087) dad811ede2204017846db118c1c8581e--24dd11231e9c4b00971ba78c1d2c4836 3e73ce61e0f64e43b547d400a2bb4284 RX(theta\u2081\u2081) 24dd11231e9c4b00971ba78c1d2c4836--3e73ce61e0f64e43b547d400a2bb4284 8d5cd08e4fa2416595fbbb16d0797412 X 3e73ce61e0f64e43b547d400a2bb4284--8d5cd08e4fa2416595fbbb16d0797412 8d5cd08e4fa2416595fbbb16d0797412--222516eaaa3246f8b217d07046f3f367 18312d29f3644d4cb97981964137b628 8d5cd08e4fa2416595fbbb16d0797412--18312d29f3644d4cb97981964137b628 472a57285307404f919b35e03bb177c6 RX(theta\u2081\u2085) 18312d29f3644d4cb97981964137b628--472a57285307404f919b35e03bb177c6 8cbb99f75f374e11b32e51a34fe3912e RY(theta\u2081\u2089) 472a57285307404f919b35e03bb177c6--8cbb99f75f374e11b32e51a34fe3912e fffb070e55ee49a69472f13f5cd520ce RX(theta\u2082\u2083) 8cbb99f75f374e11b32e51a34fe3912e--fffb070e55ee49a69472f13f5cd520ce 09c39b7a18404447a28edd30dd27eda6 X fffb070e55ee49a69472f13f5cd520ce--09c39b7a18404447a28edd30dd27eda6 09c39b7a18404447a28edd30dd27eda6--e2e343ab58a747479c26da876b016db5 b5826f61a93b4432b6c40acead4ba444 09c39b7a18404447a28edd30dd27eda6--b5826f61a93b4432b6c40acead4ba444 b5826f61a93b4432b6c40acead4ba444--d30a3334f9ed4bc68df1d65e5c26b140 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_308d3e074ea94104b7daba8b69e256a6 HEA cluster_0f77ad4b3a154aa092dd74cf3eb1a1f5 HEA a1d6afd96756405a93ccd4bffcb9b337 0 1ca6a82f665b40469010efe1161fdb5d RX(p1\u2080) a1d6afd96756405a93ccd4bffcb9b337--1ca6a82f665b40469010efe1161fdb5d 05592b3051bc453780ea99a9adccde52 1 31fbf20efe624e718554216804a201f7 RY(p1\u2084) 1ca6a82f665b40469010efe1161fdb5d--31fbf20efe624e718554216804a201f7 12026a057f3d4c3199564c706fcbabe4 RX(p1\u2088) 31fbf20efe624e718554216804a201f7--12026a057f3d4c3199564c706fcbabe4 4d5744372ea34ab1902036b3b25b2524 12026a057f3d4c3199564c706fcbabe4--4d5744372ea34ab1902036b3b25b2524 c78c2a6efb424b82b438a49cb716d648 4d5744372ea34ab1902036b3b25b2524--c78c2a6efb424b82b438a49cb716d648 d55a74080f66485e817401b0974f01ac RX(p1\u2081\u2082) c78c2a6efb424b82b438a49cb716d648--d55a74080f66485e817401b0974f01ac 44277f8f1bb34cd5a57e458a7c842b40 RY(p1\u2081\u2086) d55a74080f66485e817401b0974f01ac--44277f8f1bb34cd5a57e458a7c842b40 de4c31ee396d4b9f948cc7a64834c11c RX(p1\u2082\u2080) 44277f8f1bb34cd5a57e458a7c842b40--de4c31ee396d4b9f948cc7a64834c11c d029f5faa9d846ebb7cf36f5f50c4ee2 de4c31ee396d4b9f948cc7a64834c11c--d029f5faa9d846ebb7cf36f5f50c4ee2 86dec645eced4002bd6b02514f6dfec6 d029f5faa9d846ebb7cf36f5f50c4ee2--86dec645eced4002bd6b02514f6dfec6 72dc8f12b7ea4e9383c4f06aeed3a467 RX(p2\u2080) 86dec645eced4002bd6b02514f6dfec6--72dc8f12b7ea4e9383c4f06aeed3a467 22edc1a957a1406191ed3463bc1e93e8 RY(p2\u2084) 72dc8f12b7ea4e9383c4f06aeed3a467--22edc1a957a1406191ed3463bc1e93e8 72c1da5d28a249efaabca215be2fca9d RX(p2\u2088) 22edc1a957a1406191ed3463bc1e93e8--72c1da5d28a249efaabca215be2fca9d 885d494eab10458082dd9467f494eff0 72c1da5d28a249efaabca215be2fca9d--885d494eab10458082dd9467f494eff0 1a3ad91250284622b36a66e4d540eff8 885d494eab10458082dd9467f494eff0--1a3ad91250284622b36a66e4d540eff8 22b423b6f022442a98fcbe782476e762 RX(p2\u2081\u2082) 1a3ad91250284622b36a66e4d540eff8--22b423b6f022442a98fcbe782476e762 0278198f27c44321aa695cf0a44ad226 RY(p2\u2081\u2086) 22b423b6f022442a98fcbe782476e762--0278198f27c44321aa695cf0a44ad226 ca07864bfdf04fb5a93dc2e352dfaf13 RX(p2\u2082\u2080) 0278198f27c44321aa695cf0a44ad226--ca07864bfdf04fb5a93dc2e352dfaf13 91ba093cdf6148d2ae79e571cb9bc55e ca07864bfdf04fb5a93dc2e352dfaf13--91ba093cdf6148d2ae79e571cb9bc55e ce233f657fef4d578aef6d786dea2301 91ba093cdf6148d2ae79e571cb9bc55e--ce233f657fef4d578aef6d786dea2301 55c9de78e12b44289f1e5ef45972d2a5 ce233f657fef4d578aef6d786dea2301--55c9de78e12b44289f1e5ef45972d2a5 1d6048606a494c4ba9b5383c640a0ddb b4f4995364054343b41c11ad4f34a7bb RX(p1\u2081) 05592b3051bc453780ea99a9adccde52--b4f4995364054343b41c11ad4f34a7bb 16e9711018894a48a7e6eeefd48f1dde 2 ba183904b56c4ad88c25ccdec37d71de RY(p1\u2085) b4f4995364054343b41c11ad4f34a7bb--ba183904b56c4ad88c25ccdec37d71de 5d103178343f405d8ba0ea0bded6d127 RX(p1\u2089) ba183904b56c4ad88c25ccdec37d71de--5d103178343f405d8ba0ea0bded6d127 4c1def6629824d30b43779e936f1b07f X 5d103178343f405d8ba0ea0bded6d127--4c1def6629824d30b43779e936f1b07f 4c1def6629824d30b43779e936f1b07f--4d5744372ea34ab1902036b3b25b2524 635a1c4ae5d14ff8ba86390acd8e63c7 4c1def6629824d30b43779e936f1b07f--635a1c4ae5d14ff8ba86390acd8e63c7 49014362c06d48a6ac1ae55edf3f282c RX(p1\u2081\u2083) 635a1c4ae5d14ff8ba86390acd8e63c7--49014362c06d48a6ac1ae55edf3f282c 1108dfe2ad314a2e9b9aade7f5161b24 RY(p1\u2081\u2087) 49014362c06d48a6ac1ae55edf3f282c--1108dfe2ad314a2e9b9aade7f5161b24 cb511d8fa1f847019737c42645b81507 RX(p1\u2082\u2081) 1108dfe2ad314a2e9b9aade7f5161b24--cb511d8fa1f847019737c42645b81507 d89705d4d8bd48cbb95dd5874427ce76 X cb511d8fa1f847019737c42645b81507--d89705d4d8bd48cbb95dd5874427ce76 d89705d4d8bd48cbb95dd5874427ce76--d029f5faa9d846ebb7cf36f5f50c4ee2 8c4d0789c7ae43bc9c7e14c48602f0a4 d89705d4d8bd48cbb95dd5874427ce76--8c4d0789c7ae43bc9c7e14c48602f0a4 62f7eb4f4c2e4689b9557d665dacd6ae RX(p2\u2081) 8c4d0789c7ae43bc9c7e14c48602f0a4--62f7eb4f4c2e4689b9557d665dacd6ae 5f3f309e514c4a62887e5a56f0d34580 RY(p2\u2085) 62f7eb4f4c2e4689b9557d665dacd6ae--5f3f309e514c4a62887e5a56f0d34580 a55bd4ec43cd4ef3a9b68e1b953cf0ff RX(p2\u2089) 5f3f309e514c4a62887e5a56f0d34580--a55bd4ec43cd4ef3a9b68e1b953cf0ff a2acbc61842541f8ba1b7242774b5665 X a55bd4ec43cd4ef3a9b68e1b953cf0ff--a2acbc61842541f8ba1b7242774b5665 a2acbc61842541f8ba1b7242774b5665--885d494eab10458082dd9467f494eff0 2d53e95efc5348cfbbd82b89b66198c4 a2acbc61842541f8ba1b7242774b5665--2d53e95efc5348cfbbd82b89b66198c4 2d8f36f0c3aa4fa38ad55d2d8841cb9d RX(p2\u2081\u2083) 2d53e95efc5348cfbbd82b89b66198c4--2d8f36f0c3aa4fa38ad55d2d8841cb9d de17a69acc1b4aa396bbdc63dacf3b63 RY(p2\u2081\u2087) 2d8f36f0c3aa4fa38ad55d2d8841cb9d--de17a69acc1b4aa396bbdc63dacf3b63 ef188f868af545b693acdb32bf5dab46 RX(p2\u2082\u2081) de17a69acc1b4aa396bbdc63dacf3b63--ef188f868af545b693acdb32bf5dab46 b7a098325a26477cad3d9821043af6d1 X ef188f868af545b693acdb32bf5dab46--b7a098325a26477cad3d9821043af6d1 b7a098325a26477cad3d9821043af6d1--91ba093cdf6148d2ae79e571cb9bc55e f39982b34f61440d8a98d3829f0e4e9c b7a098325a26477cad3d9821043af6d1--f39982b34f61440d8a98d3829f0e4e9c f39982b34f61440d8a98d3829f0e4e9c--1d6048606a494c4ba9b5383c640a0ddb 3053b60dc857417d9a581ad5de99337a b496f1f4e2ad4f4b82aa07a50d281b69 RX(p1\u2082) 16e9711018894a48a7e6eeefd48f1dde--b496f1f4e2ad4f4b82aa07a50d281b69 5d3a3d0d17d84c159f09081617b6ccf1 3 bfc4770cbfec4502989b1fcabde41697 RY(p1\u2086) b496f1f4e2ad4f4b82aa07a50d281b69--bfc4770cbfec4502989b1fcabde41697 2ebc1c7096f94df190b9e0fc11374682 RX(p1\u2081\u2080) bfc4770cbfec4502989b1fcabde41697--2ebc1c7096f94df190b9e0fc11374682 4431e51c49f04f689aa00c8b60c866f8 2ebc1c7096f94df190b9e0fc11374682--4431e51c49f04f689aa00c8b60c866f8 24bedc7fab3d42569f811c8ffb1b1e28 X 4431e51c49f04f689aa00c8b60c866f8--24bedc7fab3d42569f811c8ffb1b1e28 24bedc7fab3d42569f811c8ffb1b1e28--635a1c4ae5d14ff8ba86390acd8e63c7 6de86e2fe40749c1a14a217d3ec70797 RX(p1\u2081\u2084) 24bedc7fab3d42569f811c8ffb1b1e28--6de86e2fe40749c1a14a217d3ec70797 d4902ebc95744bfcaf1bcb0cff580b5f RY(p1\u2081\u2088) 6de86e2fe40749c1a14a217d3ec70797--d4902ebc95744bfcaf1bcb0cff580b5f 827c4e80d9544de78ea09ee343df04c0 RX(p1\u2082\u2082) d4902ebc95744bfcaf1bcb0cff580b5f--827c4e80d9544de78ea09ee343df04c0 c956e4f477c546488d42b160a51e4a84 827c4e80d9544de78ea09ee343df04c0--c956e4f477c546488d42b160a51e4a84 0a019fb53fe64cc4ba231e13c58dcdc1 X c956e4f477c546488d42b160a51e4a84--0a019fb53fe64cc4ba231e13c58dcdc1 0a019fb53fe64cc4ba231e13c58dcdc1--8c4d0789c7ae43bc9c7e14c48602f0a4 4e4b0d6ad8004d9aa775a8cbe49a1e95 RX(p2\u2082) 0a019fb53fe64cc4ba231e13c58dcdc1--4e4b0d6ad8004d9aa775a8cbe49a1e95 827769d429344549b16cdabec8b95bfe RY(p2\u2086) 4e4b0d6ad8004d9aa775a8cbe49a1e95--827769d429344549b16cdabec8b95bfe 390681a5d8f9402fb4e16929fe670249 RX(p2\u2081\u2080) 827769d429344549b16cdabec8b95bfe--390681a5d8f9402fb4e16929fe670249 a9237ff0ccee406f90db7d348de149c6 390681a5d8f9402fb4e16929fe670249--a9237ff0ccee406f90db7d348de149c6 9b9cc137940f4bce9f6efc9baf4a3533 X a9237ff0ccee406f90db7d348de149c6--9b9cc137940f4bce9f6efc9baf4a3533 9b9cc137940f4bce9f6efc9baf4a3533--2d53e95efc5348cfbbd82b89b66198c4 09ff55dd40a14e43baa72520097e9cf6 RX(p2\u2081\u2084) 9b9cc137940f4bce9f6efc9baf4a3533--09ff55dd40a14e43baa72520097e9cf6 b1179e7475504cacb2f8271be81721b9 RY(p2\u2081\u2088) 09ff55dd40a14e43baa72520097e9cf6--b1179e7475504cacb2f8271be81721b9 c01a6a38db0148f6a52126e1bcd34387 RX(p2\u2082\u2082) b1179e7475504cacb2f8271be81721b9--c01a6a38db0148f6a52126e1bcd34387 4ac5e9d14f2f4b9db0049a5d7d32297d c01a6a38db0148f6a52126e1bcd34387--4ac5e9d14f2f4b9db0049a5d7d32297d f73d132f861e4a5fb1d08c8124674c70 X 4ac5e9d14f2f4b9db0049a5d7d32297d--f73d132f861e4a5fb1d08c8124674c70 f73d132f861e4a5fb1d08c8124674c70--f39982b34f61440d8a98d3829f0e4e9c f73d132f861e4a5fb1d08c8124674c70--3053b60dc857417d9a581ad5de99337a f344a97f176d4027a06ad550a4679772 552ca1a096bb49e3b9e9312076364cb0 RX(p1\u2083) 5d3a3d0d17d84c159f09081617b6ccf1--552ca1a096bb49e3b9e9312076364cb0 7bc7ea03618c4d5f988e405ac65b59bb RY(p1\u2087) 552ca1a096bb49e3b9e9312076364cb0--7bc7ea03618c4d5f988e405ac65b59bb d1a922bd08994421aa90e712a6ad0292 RX(p1\u2081\u2081) 7bc7ea03618c4d5f988e405ac65b59bb--d1a922bd08994421aa90e712a6ad0292 55456236f0b74ceeab9a1000e2d95b19 X d1a922bd08994421aa90e712a6ad0292--55456236f0b74ceeab9a1000e2d95b19 55456236f0b74ceeab9a1000e2d95b19--4431e51c49f04f689aa00c8b60c866f8 2775aed57b164909b47e105fafd69fd9 55456236f0b74ceeab9a1000e2d95b19--2775aed57b164909b47e105fafd69fd9 b3ab0a2f8879464a93d43def7ab58c4c RX(p1\u2081\u2085) 2775aed57b164909b47e105fafd69fd9--b3ab0a2f8879464a93d43def7ab58c4c f7feba77b5894cc098c10a8daafa7393 RY(p1\u2081\u2089) b3ab0a2f8879464a93d43def7ab58c4c--f7feba77b5894cc098c10a8daafa7393 96a27953cd9d4da6a93018d9baf2de33 RX(p1\u2082\u2083) f7feba77b5894cc098c10a8daafa7393--96a27953cd9d4da6a93018d9baf2de33 17d644ca4e1c402087c4ccbd103ed084 X 96a27953cd9d4da6a93018d9baf2de33--17d644ca4e1c402087c4ccbd103ed084 17d644ca4e1c402087c4ccbd103ed084--c956e4f477c546488d42b160a51e4a84 219fd1b04b7149a691347fadb2fc33c6 17d644ca4e1c402087c4ccbd103ed084--219fd1b04b7149a691347fadb2fc33c6 5cbb950910e148fd8c97ffe819c0a602 RX(p2\u2083) 219fd1b04b7149a691347fadb2fc33c6--5cbb950910e148fd8c97ffe819c0a602 4b1dadaccb5747dc85eec8157ce5d404 RY(p2\u2087) 5cbb950910e148fd8c97ffe819c0a602--4b1dadaccb5747dc85eec8157ce5d404 e659fc5292694570a915414485188159 RX(p2\u2081\u2081) 4b1dadaccb5747dc85eec8157ce5d404--e659fc5292694570a915414485188159 430046275b4d448e87215d6a29b31ee2 X e659fc5292694570a915414485188159--430046275b4d448e87215d6a29b31ee2 430046275b4d448e87215d6a29b31ee2--a9237ff0ccee406f90db7d348de149c6 9038d3f252244a5fb0786abda7755a56 430046275b4d448e87215d6a29b31ee2--9038d3f252244a5fb0786abda7755a56 e6662417322b49f296261377b265ad03 RX(p2\u2081\u2085) 9038d3f252244a5fb0786abda7755a56--e6662417322b49f296261377b265ad03 186f20c215f148faa421a3207448b63e RY(p2\u2081\u2089) e6662417322b49f296261377b265ad03--186f20c215f148faa421a3207448b63e 4b50a59803204678be81374d3e3da22b RX(p2\u2082\u2083) 186f20c215f148faa421a3207448b63e--4b50a59803204678be81374d3e3da22b 73f7970614294d97b0317c8d8bb12b1b X 4b50a59803204678be81374d3e3da22b--73f7970614294d97b0317c8d8bb12b1b 73f7970614294d97b0317c8d8bb12b1b--4ac5e9d14f2f4b9db0049a5d7d32297d ecc52d95cfb64c889c3bd7c3af7d7d0a 73f7970614294d97b0317c8d8bb12b1b--ecc52d95cfb64c889c3bd7c3af7d7d0a ecc52d95cfb64c889c3bd7c3af7d7d0a--f344a97f176d4027a06ad550a4679772 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9406])), ('theta_0', tensor([0.7951])), ('theta_1', tensor([0.3345])), ('theta_10', tensor([0.8927])), ('theta_11', tensor([0.3210])), ('theta_12', tensor([0.3358])), ('theta_13', tensor([0.6445])), ('theta_14', tensor([0.1183])), ('theta_15', tensor([0.8274])), ('theta_16', tensor([0.6881])), ('theta_17', tensor([0.5928])), ('theta_18', tensor([0.2551])), ('theta_19', tensor([0.3500])), ('theta_2', tensor([0.3125])), ('theta_20', tensor([0.5327])), ('theta_21', tensor([0.0981])), ('theta_22', tensor([0.1385])), ('theta_23', tensor([0.6408])), ('theta_3', tensor([0.4979])), ('theta_4', tensor([0.4264])), ('theta_5', tensor([0.5154])), ('theta_6', tensor([0.6589])), ('theta_7', tensor([0.1994])), ('theta_8', tensor([0.9758])), ('theta_9', tensor([0.9689]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9396])), ('theta_0', tensor([0.7941])), ('theta_1', tensor([0.3335])), ('theta_10', tensor([0.8937])), ('theta_11', tensor([0.3200])), ('theta_12', tensor([0.3348])), ('theta_13', tensor([0.6435])), ('theta_14', tensor([0.1193])), ('theta_15', tensor([0.8264])), ('theta_16', tensor([0.6891])), ('theta_17', tensor([0.5918])), ('theta_18', tensor([0.2561])), ('theta_19', tensor([0.3510])), ('theta_2', tensor([0.3135])), ('theta_20', tensor([0.5317])), ('theta_21', tensor([0.0971])), ('theta_22', tensor([0.1395])), ('theta_23', tensor([0.6398])), ('theta_3', tensor([0.4969])), ('theta_4', tensor([0.4254])), ('theta_5', tensor([0.5144])), ('theta_6', tensor([0.6579])), ('theta_7', tensor([0.2004])), ('theta_8', tensor([0.9748])), ('theta_9', tensor([0.9679]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows to compose with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution with non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): ParametricPyQOperation(\n(operation): RX(qubits=(0,), n_qubits=2)\n)\n(1): ParametricPyQOperation(\n(operation): RX(qubits=(1,), n_qubits=2)\n)\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9940+0.0000j,  0.0000-0.0774j,  0.0000-0.0774j, -0.0060+0.0000j],\n[ 0.8271+0.0000j,  0.0000-0.3781j,  0.0000-0.3781j, -0.1729+0.0000j],\n[ 0.9494+0.0000j,  0.0000-0.2191j,  0.0000-0.2191j, -0.0506+0.0000j]])\nxs = [Counter({'00': 98, '01': 1, '10': 1}), Counter({'00': 67, '01': 18, '10': 13, '11': 2}), Counter({'00': 86, '01': 7, '10': 6, '11': 1})]\nex = tensor([[0.9879],\n[0.6543],\n[0.8988]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9879, 0.9879],\n[0.6543, 0.6543],\n[0.8988, 0.8988]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the machine learning tools section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-10-16T10:48:17.578742 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-10-16T10:48:17.986165 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-10-16T10:48:18.093388 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>Qubits coordinates in Qadence are dimensionless but converted to the required unit when executed on a backend. For instance, Pulser uses \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often asssumed in simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interaction must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 58, '00': 42})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 58, '00': 42})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care for automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 87, '01': 13})]\nOn Braket = [Counter({'00': 80, '01': 20})]\nOn Pulser = [Counter({'00': 87, '01': 13})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9223+0.0000j, 0.0000-0.3865j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [ 0.80706428-0.45181738j -0.33170089+0.18569553j  0.        +0.j\n0.        +0.j        ]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_ff6c36150a1f4e0db6df411d643a3d0b Circuit block cluster_e258fad43f1b4ab4adee1b1b413ac276 Prep block b8352c4d25d84f13997518d11d9d3b55 0 bf981f8673c049a0b1d76f12b26ed5d7 b8352c4d25d84f13997518d11d9d3b55--bf981f8673c049a0b1d76f12b26ed5d7 dc646f554e8e4c388fc5e7e078cacd5c 1 8a839fd38ba74293a49ac14819412c03 RX(theta\u2080) bf981f8673c049a0b1d76f12b26ed5d7--8a839fd38ba74293a49ac14819412c03 4f32aecc9c9e4b1b987b371ef8000f4d RY(theta\u2084) 8a839fd38ba74293a49ac14819412c03--4f32aecc9c9e4b1b987b371ef8000f4d 4c9f315e09d048e2b2a54f1071b1829e RX(theta\u2088) 4f32aecc9c9e4b1b987b371ef8000f4d--4c9f315e09d048e2b2a54f1071b1829e c9819849c784487682ecc0da4701c98d 4c9f315e09d048e2b2a54f1071b1829e--c9819849c784487682ecc0da4701c98d 6578812d71b443c8b4b0b2a4339406d0 c9819849c784487682ecc0da4701c98d--6578812d71b443c8b4b0b2a4339406d0 bbbd809019f9497993f5f7773330b2d7 RX(theta\u2081\u2082) 6578812d71b443c8b4b0b2a4339406d0--bbbd809019f9497993f5f7773330b2d7 7ddf1d64d0f24df89b0cfc4c25c45d1f RY(theta\u2081\u2086) bbbd809019f9497993f5f7773330b2d7--7ddf1d64d0f24df89b0cfc4c25c45d1f 6f2ca268d24d419fb19ba20fa4236f1a RX(theta\u2082\u2080) 7ddf1d64d0f24df89b0cfc4c25c45d1f--6f2ca268d24d419fb19ba20fa4236f1a a4d1f8b7d97f4da78489e1844320c02c 6f2ca268d24d419fb19ba20fa4236f1a--a4d1f8b7d97f4da78489e1844320c02c edd75516877e478da4e86448c524e32f a4d1f8b7d97f4da78489e1844320c02c--edd75516877e478da4e86448c524e32f e1d3184dd99f4ab58ddbff2254f77e64 edd75516877e478da4e86448c524e32f--e1d3184dd99f4ab58ddbff2254f77e64 4dd34ffc43a74bcdb624ccb7ed04af93 45e7a22dac41439cb76bb9989b276a52 dc646f554e8e4c388fc5e7e078cacd5c--45e7a22dac41439cb76bb9989b276a52 ed9adb8819f8463897e51182b32e1b50 2 356f07269dc74aa4953c118ead0b1519 RX(theta\u2081) 45e7a22dac41439cb76bb9989b276a52--356f07269dc74aa4953c118ead0b1519 bd73068e142143cdb603480208ed0c7c RY(theta\u2085) 356f07269dc74aa4953c118ead0b1519--bd73068e142143cdb603480208ed0c7c 947bb9972c204a1db252d1f2b5b28aa8 RX(theta\u2089) bd73068e142143cdb603480208ed0c7c--947bb9972c204a1db252d1f2b5b28aa8 caa199cdbd1549f3b35a5fc805d24151 X 947bb9972c204a1db252d1f2b5b28aa8--caa199cdbd1549f3b35a5fc805d24151 caa199cdbd1549f3b35a5fc805d24151--c9819849c784487682ecc0da4701c98d 3ae9fae8eba34a58aaf447746af14a12 caa199cdbd1549f3b35a5fc805d24151--3ae9fae8eba34a58aaf447746af14a12 b204865b9eee4bf6bfab25c9dfe0756a RX(theta\u2081\u2083) 3ae9fae8eba34a58aaf447746af14a12--b204865b9eee4bf6bfab25c9dfe0756a 836ef60c2d7e41e497ff37f588df4add RY(theta\u2081\u2087) b204865b9eee4bf6bfab25c9dfe0756a--836ef60c2d7e41e497ff37f588df4add 394358b9c0ab4942aec563667fed3db0 RX(theta\u2082\u2081) 836ef60c2d7e41e497ff37f588df4add--394358b9c0ab4942aec563667fed3db0 92ab5a96358d4afa9ffb93ee240517c7 X 394358b9c0ab4942aec563667fed3db0--92ab5a96358d4afa9ffb93ee240517c7 92ab5a96358d4afa9ffb93ee240517c7--a4d1f8b7d97f4da78489e1844320c02c 70148f3010994a4680c82717d79170a5 92ab5a96358d4afa9ffb93ee240517c7--70148f3010994a4680c82717d79170a5 70148f3010994a4680c82717d79170a5--4dd34ffc43a74bcdb624ccb7ed04af93 967a8182c9594e3088dcb6e180446bd2 6143e4025115442c933cd394a255e922 ed9adb8819f8463897e51182b32e1b50--6143e4025115442c933cd394a255e922 51d2e1aabb734cc2b0145feb52436e74 3 8d1a136366db4d8a88e5e1e9e35a6be1 RX(theta\u2082) 6143e4025115442c933cd394a255e922--8d1a136366db4d8a88e5e1e9e35a6be1 9f17595e9b214694b0ba280a56d0dedb RY(theta\u2086) 8d1a136366db4d8a88e5e1e9e35a6be1--9f17595e9b214694b0ba280a56d0dedb b7d27e4180ae4a1c833896df908c0f6b RX(theta\u2081\u2080) 9f17595e9b214694b0ba280a56d0dedb--b7d27e4180ae4a1c833896df908c0f6b 39c54bc9ee534bc4aeb7dd7f483950f5 b7d27e4180ae4a1c833896df908c0f6b--39c54bc9ee534bc4aeb7dd7f483950f5 cb3bc5654f9b4b619d5471ada3054789 X 39c54bc9ee534bc4aeb7dd7f483950f5--cb3bc5654f9b4b619d5471ada3054789 cb3bc5654f9b4b619d5471ada3054789--3ae9fae8eba34a58aaf447746af14a12 020a0511d38442acbd0566b9dc754137 RX(theta\u2081\u2084) cb3bc5654f9b4b619d5471ada3054789--020a0511d38442acbd0566b9dc754137 559b12f8ce674aab88f1143c4158b97b RY(theta\u2081\u2088) 020a0511d38442acbd0566b9dc754137--559b12f8ce674aab88f1143c4158b97b e31996204359422b87848c665025cef9 RX(theta\u2082\u2082) 559b12f8ce674aab88f1143c4158b97b--e31996204359422b87848c665025cef9 93c56c145e6f462d8b746af0aeb2db30 e31996204359422b87848c665025cef9--93c56c145e6f462d8b746af0aeb2db30 fad77be774ff48e689f1859879a2dab4 X 93c56c145e6f462d8b746af0aeb2db30--fad77be774ff48e689f1859879a2dab4 fad77be774ff48e689f1859879a2dab4--70148f3010994a4680c82717d79170a5 fad77be774ff48e689f1859879a2dab4--967a8182c9594e3088dcb6e180446bd2 c74553a650b249549f33a0a960b21b80 788676e2123b4e8aa153a47474ef015f X 51d2e1aabb734cc2b0145feb52436e74--788676e2123b4e8aa153a47474ef015f 2af4377be9554253a228eac115c4827e RX(theta\u2083) 788676e2123b4e8aa153a47474ef015f--2af4377be9554253a228eac115c4827e 64130721e6214dfb9927aca659a364e4 RY(theta\u2087) 2af4377be9554253a228eac115c4827e--64130721e6214dfb9927aca659a364e4 4cd9ddbc96a846738825f4c92a5eb26b RX(theta\u2081\u2081) 64130721e6214dfb9927aca659a364e4--4cd9ddbc96a846738825f4c92a5eb26b 2c538d2da1d64aa9af167fbcdd0e08ce X 4cd9ddbc96a846738825f4c92a5eb26b--2c538d2da1d64aa9af167fbcdd0e08ce 2c538d2da1d64aa9af167fbcdd0e08ce--39c54bc9ee534bc4aeb7dd7f483950f5 966cc28d8c3f453f9756d6ae50579260 2c538d2da1d64aa9af167fbcdd0e08ce--966cc28d8c3f453f9756d6ae50579260 f08a04dd034341a180a0b335da08eab9 RX(theta\u2081\u2085) 966cc28d8c3f453f9756d6ae50579260--f08a04dd034341a180a0b335da08eab9 7658e70e4f9049e194a7184dc90949c5 RY(theta\u2081\u2089) f08a04dd034341a180a0b335da08eab9--7658e70e4f9049e194a7184dc90949c5 2039ee5ce3fc4a5b9c4ecba30b330e72 RX(theta\u2082\u2083) 7658e70e4f9049e194a7184dc90949c5--2039ee5ce3fc4a5b9c4ecba30b330e72 d84ff1a14996419d998ebe48448bbc6f X 2039ee5ce3fc4a5b9c4ecba30b330e72--d84ff1a14996419d998ebe48448bbc6f d84ff1a14996419d998ebe48448bbc6f--93c56c145e6f462d8b746af0aeb2db30 3185ae9977d34c108d288116d09d69fb d84ff1a14996419d998ebe48448bbc6f--3185ae9977d34c108d288116d09d69fb 3185ae9977d34c108d288116d09d69fb--c74553a650b249549f33a0a960b21b80  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.4733+0.0588j, -0.3286+0.0288j, -0.0680+0.3754j, -0.3299-0.1679j,\n0.0818+0.2296j, -0.2771-0.2593j, -0.0508+0.0349j,  0.1995-0.3662j],\n[-0.2293+0.0824j, -0.0980-0.0311j, -0.0049-0.1667j,  0.5866+0.3335j,\n0.1787+0.1656j,  0.0792-0.1512j, -0.5753+0.0789j,  0.1434-0.0244j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0,1)\n\u2514\u2500\u2500 CNOT(1,2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}