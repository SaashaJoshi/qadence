{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])  # Dimensionless.\nsamples = sample(register, block)\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 35, '10': 35, '01': 30})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        protocol: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._protocol = protocol\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code></p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, protocol=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>protocol</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nprotocol: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        protocol: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nprotocol=protocol,\nconfiguration=configuration,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif protocol is None:\nprotocol = self._protocol\nreturn self.transform(\nself.expectation(values=values, state=state, protocol=protocol, endianness=endianness)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-11-06T13:38:01.568020 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        endianness: Endianness of the resulting bitstrings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor _field in fields(self):\nif not _field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend. Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend. Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, protocol=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nprotocol: Measurements | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        protocol: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nprotocol=protocol,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, state=None, n_shots=1, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nstate: Tensor | None = None,\nn_shots: int = 1,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>idealized device, least realistic</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>device with realistic specs</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit (and optionally and observable) to their native representation. Additionally this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit (and optionally and observable) to their native\n    representation. Additionally this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction and loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing. Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates. Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: Tuple[int, ...],\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit into a single\n    call to _apply_batch_gate.\"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: torch.Tensor, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> %3 bdca249c35e4476888327740d63ea3ba 0 da88dff4affd4785bd5baaae60c04c98 X bdca249c35e4476888327740d63ea3ba--da88dff4affd4785bd5baaae60c04c98 e820de9261c346b3bf7da40d63974dbf 1 a6baa87289be4394a8a2fcfa5e8fa5f0 da88dff4affd4785bd5baaae60c04c98--a6baa87289be4394a8a2fcfa5e8fa5f0 e6f98c3b9f994757ad729ad502041cbc 19c0b34ca7984568ae966956e5aacbe2 Y e820de9261c346b3bf7da40d63974dbf--19c0b34ca7984568ae966956e5aacbe2 19c0b34ca7984568ae966956e5aacbe2--e6f98c3b9f994757ad729ad502041cbc <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> %3 85b9a3b9ebfd46c195e14097f0149d31 0 b1417a5632d94d6a95204cc757120aca X 85b9a3b9ebfd46c195e14097f0149d31--b1417a5632d94d6a95204cc757120aca 61960d3e47e1430ca570519868e3690e Y b1417a5632d94d6a95204cc757120aca--61960d3e47e1430ca570519868e3690e 9ebe762ef96745aca3635a2599ec3f43 61960d3e47e1430ca570519868e3690e--9ebe762ef96745aca3635a2599ec3f43 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> %3 bec2404a3d74418a927f17b1b01e75f2 0 cc5ed58f48c74bc6a0307e261dec770b X bec2404a3d74418a927f17b1b01e75f2--cc5ed58f48c74bc6a0307e261dec770b e142f072ddc34110ad26531afd3818f3 1 bc709a8d953b4ef69e171408d351709b cc5ed58f48c74bc6a0307e261dec770b--bc709a8d953b4ef69e171408d351709b 0ef62d2f6445424f931e9a2848b548f6 bc709a8d953b4ef69e171408d351709b--0ef62d2f6445424f931e9a2848b548f6 483e21ef199146ed94820e3aa9fc530b 75239e0a160e42cf8eb1ac8217488e84 e142f072ddc34110ad26531afd3818f3--75239e0a160e42cf8eb1ac8217488e84 48b0c05cf5604ad6b559f3af1c34d98e Y 75239e0a160e42cf8eb1ac8217488e84--48b0c05cf5604ad6b559f3af1c34d98e 48b0c05cf5604ad6b559f3af1c34d98e--483e21ef199146ed94820e3aa9fc530b <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_459c2f7836ea4c91b415533c8c2b3c56 f59b2cca0b49481e8e6ea835efa4f54f 0 22a24608e0934633832ecf41c57e06a1 f59b2cca0b49481e8e6ea835efa4f54f--22a24608e0934633832ecf41c57e06a1 0eba7b3b986545e3a17945112d4ccd9e 1 b71be4ed289849f29ec50b393a9e095b 22a24608e0934633832ecf41c57e06a1--b71be4ed289849f29ec50b393a9e095b d3a1005eba554ed08ec3fea40eaf0d22 ca1aa8c6f8fc422ea9a7eb78dd65ec1b AddBlock 0eba7b3b986545e3a17945112d4ccd9e--ca1aa8c6f8fc422ea9a7eb78dd65ec1b 76d05c7138da41c5aab19863c53eb215 2 ca1aa8c6f8fc422ea9a7eb78dd65ec1b--d3a1005eba554ed08ec3fea40eaf0d22 f1a36f9d57354ce0af65b5a82831d95b 719a6878807e47dda174e3d71697a4ab 76d05c7138da41c5aab19863c53eb215--719a6878807e47dda174e3d71697a4ab 719a6878807e47dda174e3d71697a4ab--f1a36f9d57354ce0af65b5a82831d95b <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> %3 cluster_6e999264b8e744d9abfec284a527f37e cluster_139ac1e0a23e41538e6711d6b7c65889 rx ac8d71c61bea40e7a069ea649d498ecd 0 6af9acbfbf4c4c3ab2a79855eaeffbd5 X ac8d71c61bea40e7a069ea649d498ecd--6af9acbfbf4c4c3ab2a79855eaeffbd5 60489dc607b543ad8a8be4102c8c23f6 1 09a84c17edd743e680d62c609d5f2a5d 6af9acbfbf4c4c3ab2a79855eaeffbd5--09a84c17edd743e680d62c609d5f2a5d a8089eef95ac4735a000ddf767d9a0ae 09a84c17edd743e680d62c609d5f2a5d--a8089eef95ac4735a000ddf767d9a0ae 85aa53c3a50c45bcb3798f62d86d4c72 a8089eef95ac4735a000ddf767d9a0ae--85aa53c3a50c45bcb3798f62d86d4c72 b08f631fcfd540c4a35a4351ef4c83c4 3359b74e11744836a4a809fd3a24a46d Y 60489dc607b543ad8a8be4102c8c23f6--3359b74e11744836a4a809fd3a24a46d 5a9e30b797d14fdcb78d6fa569798149 2 34e6087981784242ae91a8106aeb6702 3359b74e11744836a4a809fd3a24a46d--34e6087981784242ae91a8106aeb6702 3abe308b11bc4ba4a34cddd495f56fdc HamEvo 34e6087981784242ae91a8106aeb6702--3abe308b11bc4ba4a34cddd495f56fdc 3abe308b11bc4ba4a34cddd495f56fdc--b08f631fcfd540c4a35a4351ef4c83c4 7b5e64e55e0c4696b99ec2fa984bc9d4 a8dac39b3a9445358dc59c2662868da7 RX(x) 5a9e30b797d14fdcb78d6fa569798149--a8dac39b3a9445358dc59c2662868da7 1fe9722ec85149dd81aff1467767e62f 3 08d7869f08de4e5690b9f1c34e158135 a8dac39b3a9445358dc59c2662868da7--08d7869f08de4e5690b9f1c34e158135 f8b10a64d239404c92ea8b5d0a855a05 t = 10 08d7869f08de4e5690b9f1c34e158135--f8b10a64d239404c92ea8b5d0a855a05 f8b10a64d239404c92ea8b5d0a855a05--7b5e64e55e0c4696b99ec2fa984bc9d4 72839a74f38c48f28245b4cb4cd76073 13cdd529e93d462688ca53d65c8ec695 RX(0.5) 1fe9722ec85149dd81aff1467767e62f--13cdd529e93d462688ca53d65c8ec695 936183611691488db0985a81dc27b5d1 X 13cdd529e93d462688ca53d65c8ec695--936183611691488db0985a81dc27b5d1 936183611691488db0985a81dc27b5d1--08d7869f08de4e5690b9f1c34e158135 01e5dad22de5409abb0ba2a88a849633 936183611691488db0985a81dc27b5d1--01e5dad22de5409abb0ba2a88a849633 01e5dad22de5409abb0ba2a88a849633--72839a74f38c48f28245b4cb4cd76073 <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_0d64cfc53f7143c79c00ede13ef69372 HEA cluster_2ee57dad57b945a5afdb93f01b596919 Tower Fourier FM dfdcdb0253204ca98c6b3b1c2027bc10 0 cb4c410891c947edb27f8c22d4bea36b RX(1.0*phi) dfdcdb0253204ca98c6b3b1c2027bc10--cb4c410891c947edb27f8c22d4bea36b 0c31d311f0bf4959b1ecf4daaab9fe5e 1 879f332169f1478b8403cdf6c0198118 RX(theta\u2080) cb4c410891c947edb27f8c22d4bea36b--879f332169f1478b8403cdf6c0198118 6dcc6926db6c4a99bd265d6414d8ce52 RY(theta\u2084) 879f332169f1478b8403cdf6c0198118--6dcc6926db6c4a99bd265d6414d8ce52 ac211d40cd1344218b718db28ed07b1f RX(theta\u2088) 6dcc6926db6c4a99bd265d6414d8ce52--ac211d40cd1344218b718db28ed07b1f 7e6377ef4ca2488b8eb6bc4182d6eaeb ac211d40cd1344218b718db28ed07b1f--7e6377ef4ca2488b8eb6bc4182d6eaeb e15f812ec35144f1a27bac488d91a3e2 7e6377ef4ca2488b8eb6bc4182d6eaeb--e15f812ec35144f1a27bac488d91a3e2 23b3c53509794f1c83415effcdb80f92 RX(theta\u2081\u2082) e15f812ec35144f1a27bac488d91a3e2--23b3c53509794f1c83415effcdb80f92 181e7286e43b4553bdc1cda45796b8a3 RY(theta\u2081\u2086) 23b3c53509794f1c83415effcdb80f92--181e7286e43b4553bdc1cda45796b8a3 d7120e0781cb435799c22c5d2c3298f3 RX(theta\u2082\u2080) 181e7286e43b4553bdc1cda45796b8a3--d7120e0781cb435799c22c5d2c3298f3 56a69713a9d84823aff0186f697b08a2 d7120e0781cb435799c22c5d2c3298f3--56a69713a9d84823aff0186f697b08a2 f78df2674d714c47abee0fd47a0c7b12 56a69713a9d84823aff0186f697b08a2--f78df2674d714c47abee0fd47a0c7b12 df2ec8256ef241a68cb2ff7aaf7de61e f78df2674d714c47abee0fd47a0c7b12--df2ec8256ef241a68cb2ff7aaf7de61e 08421159a3a145d09b83145092b26305 4e853bd996ff4783b70a3556ef7d1849 RX(2.0*phi) 0c31d311f0bf4959b1ecf4daaab9fe5e--4e853bd996ff4783b70a3556ef7d1849 cd95ba86c31d4cfab24a40f0b83464ee 2 de046c2441c84194a72d711549c8e76a RX(theta\u2081) 4e853bd996ff4783b70a3556ef7d1849--de046c2441c84194a72d711549c8e76a 10f7904dea904074afd9f905ceefb6e8 RY(theta\u2085) de046c2441c84194a72d711549c8e76a--10f7904dea904074afd9f905ceefb6e8 d2df24c4d5a4426ebb6bdb44cac4bd7d RX(theta\u2089) 10f7904dea904074afd9f905ceefb6e8--d2df24c4d5a4426ebb6bdb44cac4bd7d 7f5f64bda01349ea9e131d41c42ddaba X d2df24c4d5a4426ebb6bdb44cac4bd7d--7f5f64bda01349ea9e131d41c42ddaba 7f5f64bda01349ea9e131d41c42ddaba--7e6377ef4ca2488b8eb6bc4182d6eaeb d0950d63b6f74f0e8294684f7e621224 7f5f64bda01349ea9e131d41c42ddaba--d0950d63b6f74f0e8294684f7e621224 984ccfe9c2c548ba866c44734d845a9f RX(theta\u2081\u2083) d0950d63b6f74f0e8294684f7e621224--984ccfe9c2c548ba866c44734d845a9f 0338c58f5f7c477cbd57defee55f7526 RY(theta\u2081\u2087) 984ccfe9c2c548ba866c44734d845a9f--0338c58f5f7c477cbd57defee55f7526 923932bcdaa54bcb8f925ab0175f4eaa RX(theta\u2082\u2081) 0338c58f5f7c477cbd57defee55f7526--923932bcdaa54bcb8f925ab0175f4eaa 09146a759e0a4e8aafa889bb2233d1ad X 923932bcdaa54bcb8f925ab0175f4eaa--09146a759e0a4e8aafa889bb2233d1ad 09146a759e0a4e8aafa889bb2233d1ad--56a69713a9d84823aff0186f697b08a2 18de6557898443b39d2e2e7128823bef 09146a759e0a4e8aafa889bb2233d1ad--18de6557898443b39d2e2e7128823bef 18de6557898443b39d2e2e7128823bef--08421159a3a145d09b83145092b26305 7b1ea5d883cd4b65aa86663bcc8da7eb 5dabc290270f49f28e6286ea58446a99 RX(3.0*phi) cd95ba86c31d4cfab24a40f0b83464ee--5dabc290270f49f28e6286ea58446a99 87128e59278a43a2b6c9bbec8309a75f 3 519f9f3d472a4b0c98ef3b6d60b9fb9f RX(theta\u2082) 5dabc290270f49f28e6286ea58446a99--519f9f3d472a4b0c98ef3b6d60b9fb9f 8211359f66404c048fdb7c355576c5c7 RY(theta\u2086) 519f9f3d472a4b0c98ef3b6d60b9fb9f--8211359f66404c048fdb7c355576c5c7 459c6fe867e94839b810cd4a75b8f29f RX(theta\u2081\u2080) 8211359f66404c048fdb7c355576c5c7--459c6fe867e94839b810cd4a75b8f29f c840a5e81c82413195834ac4b7fe9a27 459c6fe867e94839b810cd4a75b8f29f--c840a5e81c82413195834ac4b7fe9a27 71dae0f080ee4bc08dddb56e4638c8d4 X c840a5e81c82413195834ac4b7fe9a27--71dae0f080ee4bc08dddb56e4638c8d4 71dae0f080ee4bc08dddb56e4638c8d4--d0950d63b6f74f0e8294684f7e621224 870a976326714f4e8c50460b25c20f21 RX(theta\u2081\u2084) 71dae0f080ee4bc08dddb56e4638c8d4--870a976326714f4e8c50460b25c20f21 028b8feb924c4fc3b19924e2b55c33db RY(theta\u2081\u2088) 870a976326714f4e8c50460b25c20f21--028b8feb924c4fc3b19924e2b55c33db a5785eae653f46d4b5de7371e30a9336 RX(theta\u2082\u2082) 028b8feb924c4fc3b19924e2b55c33db--a5785eae653f46d4b5de7371e30a9336 458cc8c9f46e46ff9b1b975cd2372efe a5785eae653f46d4b5de7371e30a9336--458cc8c9f46e46ff9b1b975cd2372efe a5cc3dd670694e0abddef16ea5725045 X 458cc8c9f46e46ff9b1b975cd2372efe--a5cc3dd670694e0abddef16ea5725045 a5cc3dd670694e0abddef16ea5725045--18de6557898443b39d2e2e7128823bef a5cc3dd670694e0abddef16ea5725045--7b1ea5d883cd4b65aa86663bcc8da7eb be8799dc99634658a40841831a257c3d bdb9ac23bb814a879de27325db73ae5a RX(4.0*phi) 87128e59278a43a2b6c9bbec8309a75f--bdb9ac23bb814a879de27325db73ae5a 80bacf3cb60d47fd8f448965b1f9fe53 RX(theta\u2083) bdb9ac23bb814a879de27325db73ae5a--80bacf3cb60d47fd8f448965b1f9fe53 cd642ad80e2d4261a203dcda33dbb625 RY(theta\u2087) 80bacf3cb60d47fd8f448965b1f9fe53--cd642ad80e2d4261a203dcda33dbb625 2114658f7d094a5cbab25ffb8710a36c RX(theta\u2081\u2081) cd642ad80e2d4261a203dcda33dbb625--2114658f7d094a5cbab25ffb8710a36c 588a21d045db45c3bb49b19de767ab5f X 2114658f7d094a5cbab25ffb8710a36c--588a21d045db45c3bb49b19de767ab5f 588a21d045db45c3bb49b19de767ab5f--c840a5e81c82413195834ac4b7fe9a27 d5dd6db0a4e847e1b92f232d14e095a4 588a21d045db45c3bb49b19de767ab5f--d5dd6db0a4e847e1b92f232d14e095a4 b464452b2e364ac0a41a1bd0be65a38d RX(theta\u2081\u2085) d5dd6db0a4e847e1b92f232d14e095a4--b464452b2e364ac0a41a1bd0be65a38d 78284ea4aadc453aac427382ecea05d0 RY(theta\u2081\u2089) b464452b2e364ac0a41a1bd0be65a38d--78284ea4aadc453aac427382ecea05d0 e8693d80a5364a629a8215ce4cd97553 RX(theta\u2082\u2083) 78284ea4aadc453aac427382ecea05d0--e8693d80a5364a629a8215ce4cd97553 344bd04d97e9467cbcd99b06623b8d70 X e8693d80a5364a629a8215ce4cd97553--344bd04d97e9467cbcd99b06623b8d70 344bd04d97e9467cbcd99b06623b8d70--458cc8c9f46e46ff9b1b975cd2372efe 3dc7c11f144447f58330a4c4dbdc48f7 344bd04d97e9467cbcd99b06623b8d70--3dc7c11f144447f58330a4c4dbdc48f7 3dc7c11f144447f58330a4c4dbdc48f7--be8799dc99634658a40841831a257c3d"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/","title":"Digital-Analog Emulation","text":""},{"location":"digital_analog_qc/analog-basics/#from-theory-to-implementation","title":"From theory to implementation","text":"<p>Qadence includes primitives for the construction of Ising-like Hamiltonians to account for custom qubit interaction. This allows to simulate systems close to real quantum computing platforms such as neutral atoms. The general form for time-independent Ising Hamiltonians is</p> \\[ \\mathcal{H} = \\sum_{i} \\frac{\\hbar\\Omega}{2} \\hat\\sigma^x_i - \\sum_{i} \\hbar\\delta \\hat n_i  + \\mathcal{H}_{\\textrm{int}}, \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\hat n = \\frac{1-\\hat\\sigma_z}{2}\\) is the number operator, and \\(\\mathcal{H}_{\\textrm{int}}\\) a pair-wise interaction term. Two central operations implement this Hamiltonian as blocks:</p> <ul> <li><code>WaitBlock</code> by free-evolving \\(\\mathcal{H}_{\\textrm{int}}\\)</li> <li><code>ConstantAnalogRotation</code> by free-evolving \\(\\mathcal{H}\\)</li> </ul> <p>The <code>wait</code> operation can be emulated with an \\(ZZ\\)- (Ising) or an \\(XY\\)-interaction:</p> <pre><code>from qadence import Register, wait, add_interaction, run, Interaction\nblock = wait(duration=3000)\nreg = Register.from_coordinates([(0,0), (0,5)])  # Dimensionless.\nemulated = add_interaction(reg, block, interaction=Interaction.XY)  # or Interaction.ZZ for Ising.\n</code></pre> <pre><code>block = WaitBlock(t=3000.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,)) emulated.generator = AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 29.600] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> <p>The <code>AnalogRot</code> constructor can be used to create a fully customizable <code>ConstantAnalogRotation</code> instances:</p> <pre><code>import torch\nfrom qadence import AnalogRot, AnalogRX\n# Implement a global RX rotation by setting all parameters.\nblock = AnalogRot(\nduration=1000., # [ns]\nomega=torch.pi, # [rad/\u03bcs]\ndelta=0,        # [rad/\u03bcs]\nphase=0,        # [rad]\n)\n# Or use the shortcut.\nblock = AnalogRX(torch.pi)\n</code></pre> <pre><code>AnalogRot = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\nAnalogRX = ConstantAnalogRotation(\u03b1=3.14159265358979, t=1000.00000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=3.14159265358979, \u03b4=0, \u03c6=0)\n</code></pre> <p>Automatic emulation in the PyQTorch backend</p> <p>All analog blocks are automatically translated to their emulated version when running them with the PyQTorch backend:</p> <p><pre><code>import torch\nfrom qadence import Register, AnalogRX, sample\nreg = Register.from_coordinates([(0,0), (0,5)])\nsample = sample(reg, AnalogRX(torch.pi))\n</code></pre> <pre><code>sample = [Counter({'00': 40, '10': 32, '01': 28})]\n</code></pre> </p> <p>To compose analog blocks, the regular <code>chain</code> and <code>kron</code> operations can be used under the following restrictions:</p> <ul> <li>The resulting <code>AnalogChain</code> type can only be constructed from <code>AnalogKron</code> blocks   or globally supported primitive analog blocks.</li> <li>The resulting <code>AnalogKron</code> type can only be constructed from non-global   analog blocks with the same duration.</li> </ul> <pre><code>import torch\nfrom qadence import AnalogRot, kron, chain, wait\n# Only analog blocks with a global qubit support can be composed\n# using chain.\nanalog_chain = chain(wait(duration=200), AnalogRot(duration=300, omega=2.0))\n# Only blocks with the same `duration` can be composed using kron.\nanalog_kron = kron(\nwait(duration=1000, qubit_support=(0,1)),\nAnalogRot(duration=1000, omega=2.0, qubit_support=(2,3))\n)\n</code></pre> <pre><code>Analog Chain block = AnalogChain(t=500.000000000000, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u251c\u2500\u2500 WaitBlock(t=200.0, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=0.600000000000000, t=300, support=(&lt;QubitSupportType.GLOBAL: 'global'&gt;,), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\nAnalog Kron block = AnalogKron(t=1000, support=(0, 1, 2, 3))\n\u251c\u2500\u2500 WaitBlock(t=1000.0, support=(0, 1))\n\u2514\u2500\u2500 ConstantAnalogRotation(\u03b1=2.00000000000000, t=1000, support=(2, 3), \u03a9=2.00000000000000, \u03b4=0, \u03c6=0)\n</code></pre> <p>Composing digital &amp; analog blocks</p> <p>It is possible to compose digital and analog blocks where the additional restrictions for <code>chain</code> and <code>kron</code> only apply to composite blocks which contain analog blocks only. For further details, see <code>AnalogChain</code> and <code>AnalogKron</code>.</p>"},{"location":"digital_analog_qc/analog-basics/#fitting-a-simple-function","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and paramertized ansatze to fit a sine function. First, define an ansatz block and an observable:</p> <pre><code>import torch\nfrom qadence import Register, FeatureParameter, VariationalParameter\nfrom qadence import AnalogRX, AnalogRZ, Z\nfrom qadence import wait, chain, add\npi = torch.pi\n# A two qubit register.\nreg = Register.from_coordinates([(0, 0), (0, 12)])\n# An analog ansatz with an input time parameter.\nt = FeatureParameter(\"t\")\nblock = chain(\nAnalogRX(pi/2.),\nAnalogRZ(t),\nwait(1000 * VariationalParameter(\"theta\", value=0.5)),\nAnalogRX(pi/2),\n)\n# Total magnetization observable.\nobs = add(Z(i) for i in range(reg.n_qubits))\n</code></pre> Plotting functions <code>plot</code> and <code>scatter</code> <p><pre><code>def plot(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.plot(xnp, ynp, **kwargs)\ndef scatter(ax, x, y, **kwargs):\nxnp = x.detach().cpu().numpy().flatten()\nynp = y.detach().cpu().numpy().flatten()\nax.scatter(xnp, ynp, **kwargs)\n</code></pre> </p> <p>Next, define the dataset to train on and plot the initial prediction. The differentiation mode can be set to either <code>DiffMode.AD</code> or <code>DiffMode.GPSR</code>.</p> <pre><code>import matplotlib.pyplot as plt\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\n# Define a quantum model including digital-analog emulation.\ncirc = QuantumCircuit(reg, block)\nmodel = QuantumModel(circ, obs, diff_mode=DiffMode.GPSR)\n# Time support dataset.\nx_train = torch.linspace(0, 6, steps=30)\n# Function to fit.\ny_train = -0.64 * torch.sin(x_train + 0.33) + 0.1\n# Initial prediction.\ny_pred_initial = model.expectation({\"t\": x_train})\n</code></pre> 2023-11-06T13:38:02.786457 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Finally, the classical optimization part is handled by PyTorch:</p> <pre><code># Use PyTorch built-in functionality.\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=5e-2)\n# Define a loss function.\ndef loss_fn(x_train, y_train):\nreturn mse_loss(model.expectation({\"t\": x_train}).squeeze(), y_train)\n# Number of epochs to train over.\nn_epochs = 200\n# Optimization loop.\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n# Get and visualize the final prediction.\ny_pred = model.expectation({\"t\": x_train})\n</code></pre> 2023-11-06T13:38:08.808493 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.transpile.emulate import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_4100727736005*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['39_0388262113427*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_4100727736005*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['39_0388262113427*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 90, '00100': 88, '00001': 74, '00010': 71, '10000': 70, '00101': 19, '11000': 19, '10100': 14, '10001': 13, '10010': 12, '00110': 11, '01001': 11, '00011': 9, '01010': 8, '01100': 6, '01101': 3, '10110': 3, '01011': 2, '01110': 2, '10011': 2, '11010': 2, '00111': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 299, '00011': 187, '01010': 94, '00010': 77, '00101': 62, '01011': 52, '00001': 49, '10010': 44, '00100': 42, '00110': 32, '01001': 15, '01000': 12, '10011': 10, '01111': 7, '10001': 6, '01110': 5, '00000': 3, '01100': 3, '01101': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-11-06T13:38:11.886869 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-basics/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>The DAQC paradigm is typically implemented on quantum computing hardware based on neutral-atoms where both these computations are realizable.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real neutral-atom devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/daqc-basics/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/daqc-basics/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_9e67f8b017834e2191b8b61de9a63531 cluster_4070c5aa614f41439f16d3d50245fe05 cluster_b7150e31e9b94c37bcc87ea59360334f cluster_86d8473c8a264ac4a2b18ef470b5deee cluster_da2d705f6e5f4225be31b650057f5616 cluster_a320f1ff8e21405daa3c7b67031abc45 cluster_7901257aff064e8e90c708f8dbda3f77 353f55c9e8684d18a80569992a2ad7ce 0 2e012bf539df4680bc07b8ec956a478c HamEvo 353f55c9e8684d18a80569992a2ad7ce--2e012bf539df4680bc07b8ec956a478c ac20c19e269f442094828e6ae1703218 1 2273838f65d44eaf86d452ef3cb0819d HamEvo 2e012bf539df4680bc07b8ec956a478c--2273838f65d44eaf86d452ef3cb0819d 004e7143fdcb47348aad1584533cacb4 HamEvo 2273838f65d44eaf86d452ef3cb0819d--004e7143fdcb47348aad1584533cacb4 ac08fe8d59a348719bad4874bb70673d X 004e7143fdcb47348aad1584533cacb4--ac08fe8d59a348719bad4874bb70673d c393b081a10347a6b60921ade15d8ec2 HamEvo ac08fe8d59a348719bad4874bb70673d--c393b081a10347a6b60921ade15d8ec2 df2abb3c6a8149da80e74e343a0cb916 HamEvo c393b081a10347a6b60921ade15d8ec2--df2abb3c6a8149da80e74e343a0cb916 28a8f66a1064415584a41e4c66d273f5 X df2abb3c6a8149da80e74e343a0cb916--28a8f66a1064415584a41e4c66d273f5 4e9e8cf8eb524189aed2a61612bdf21b 28a8f66a1064415584a41e4c66d273f5--4e9e8cf8eb524189aed2a61612bdf21b de2ce493460e490e8474cc36d0bb431b HamEvo 4e9e8cf8eb524189aed2a61612bdf21b--de2ce493460e490e8474cc36d0bb431b 537f3b47c65e4676a0e58a412a2d13cf HamEvo de2ce493460e490e8474cc36d0bb431b--537f3b47c65e4676a0e58a412a2d13cf 5a4866aba9974e6cb763b970b1b81dc6 537f3b47c65e4676a0e58a412a2d13cf--5a4866aba9974e6cb763b970b1b81dc6 85884d948a7641e6b801544e76372590 5a4866aba9974e6cb763b970b1b81dc6--85884d948a7641e6b801544e76372590 0a4525b7e37a46be9ff87f2fd6612af6 a2875309f40f4189a5129bc0ef00394e t = -3.142 ac20c19e269f442094828e6ae1703218--a2875309f40f4189a5129bc0ef00394e fff6f10accb74631a1cef1da20c58a3c 2 3626da1c2bce47f0adc72b6a3c762fb8 t = 3.142 a2875309f40f4189a5129bc0ef00394e--3626da1c2bce47f0adc72b6a3c762fb8 18765dfe1a0040c88301fd8cea35a61e t = -3.142 3626da1c2bce47f0adc72b6a3c762fb8--18765dfe1a0040c88301fd8cea35a61e d14fbd996522435097c43fb353ce6618 18765dfe1a0040c88301fd8cea35a61e--d14fbd996522435097c43fb353ce6618 eaa7c4d7dc674e48b36a1430aa3bddc4 t = 1.571 d14fbd996522435097c43fb353ce6618--eaa7c4d7dc674e48b36a1430aa3bddc4 e1c243bd23ef40d8a9e1d76b9fff5845 t = 1.571 eaa7c4d7dc674e48b36a1430aa3bddc4--e1c243bd23ef40d8a9e1d76b9fff5845 2f84c9c95a3843fca7a8c773a245c518 e1c243bd23ef40d8a9e1d76b9fff5845--2f84c9c95a3843fca7a8c773a245c518 0fbf700b45b4452d8df9349851226d0d X 2f84c9c95a3843fca7a8c773a245c518--0fbf700b45b4452d8df9349851226d0d b2e834bd312d4b188a8c07969c089911 t = 1.571 0fbf700b45b4452d8df9349851226d0d--b2e834bd312d4b188a8c07969c089911 8b595f7a86dd4eac9f443bb167c52783 t = 1.571 b2e834bd312d4b188a8c07969c089911--8b595f7a86dd4eac9f443bb167c52783 a8e221be0bb345c3baff44b4796c0518 X 8b595f7a86dd4eac9f443bb167c52783--a8e221be0bb345c3baff44b4796c0518 a8e221be0bb345c3baff44b4796c0518--0a4525b7e37a46be9ff87f2fd6612af6 b3293868c33f4ae6ad7eba1b5ef1a3d1 f699877f29eb40eb90da35ddb73effed fff6f10accb74631a1cef1da20c58a3c--f699877f29eb40eb90da35ddb73effed 2e08c5475b244f449fc04d18a1a71c73 f699877f29eb40eb90da35ddb73effed--2e08c5475b244f449fc04d18a1a71c73 a1afc89e45024a54b0ecb8a189e89255 2e08c5475b244f449fc04d18a1a71c73--a1afc89e45024a54b0ecb8a189e89255 8fdabc26ecf6485bbbb98a31c254258c X a1afc89e45024a54b0ecb8a189e89255--8fdabc26ecf6485bbbb98a31c254258c 49c924e5564d4bdf9b7b14e8338d09e1 8fdabc26ecf6485bbbb98a31c254258c--49c924e5564d4bdf9b7b14e8338d09e1 3460959fb49041509355d0bd087a81b8 49c924e5564d4bdf9b7b14e8338d09e1--3460959fb49041509355d0bd087a81b8 a6b4b350ee29484b8d287743108e9544 X 3460959fb49041509355d0bd087a81b8--a6b4b350ee29484b8d287743108e9544 42452e54af4a427296f24bbe5a6e47bd X a6b4b350ee29484b8d287743108e9544--42452e54af4a427296f24bbe5a6e47bd 29f80132d1844a9e97c3111e4f75a761 42452e54af4a427296f24bbe5a6e47bd--29f80132d1844a9e97c3111e4f75a761 efef884af49c4dc0a3045260dd41d89c 29f80132d1844a9e97c3111e4f75a761--efef884af49c4dc0a3045260dd41d89c 74f620030324418696980561c97de519 X efef884af49c4dc0a3045260dd41d89c--74f620030324418696980561c97de519 74f620030324418696980561c97de519--b3293868c33f4ae6ad7eba1b5ef1a3d1 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_b03e94ff72b04117a9a4b0ac3273e811 cluster_cee5fb4618554fe98b045c061fead2d8 b7e688a0e5784b9bbf00eb781bf1a2eb 0 86b53009dd3c4c7f8b73baa270c01a75 X b7e688a0e5784b9bbf00eb781bf1a2eb--86b53009dd3c4c7f8b73baa270c01a75 34ecedae48d944709bd23766e2363882 1 f1ddd3d856d142b49b5109fc460b8896 HamEvo 86b53009dd3c4c7f8b73baa270c01a75--f1ddd3d856d142b49b5109fc460b8896 a5ce2bbd2d7e4d30b4f757bd78849f38 X f1ddd3d856d142b49b5109fc460b8896--a5ce2bbd2d7e4d30b4f757bd78849f38 6c4c4211afed4f1283138f144e951caa a5ce2bbd2d7e4d30b4f757bd78849f38--6c4c4211afed4f1283138f144e951caa d17062f23e9a4f5c885963178faef260 HamEvo 6c4c4211afed4f1283138f144e951caa--d17062f23e9a4f5c885963178faef260 05d552183c4348a798dd6ae2793662c3 d17062f23e9a4f5c885963178faef260--05d552183c4348a798dd6ae2793662c3 990e7ab9e20a4b8e9baec2f67182c0ab 05d552183c4348a798dd6ae2793662c3--990e7ab9e20a4b8e9baec2f67182c0ab b85fc0630fe8451784d0f00b1abced96 138a584e538c443fbddced0f18a84da1 34ecedae48d944709bd23766e2363882--138a584e538c443fbddced0f18a84da1 d5cba93910814ec383791e1f8e15ccdb 2 30a3b36b01d24de186d11908b46d5d37 t = -0.500 138a584e538c443fbddced0f18a84da1--30a3b36b01d24de186d11908b46d5d37 b61b36afa6fa432ba34ed063c0672578 30a3b36b01d24de186d11908b46d5d37--b61b36afa6fa432ba34ed063c0672578 984398f142964a9f97cc3824e75f36cc X b61b36afa6fa432ba34ed063c0672578--984398f142964a9f97cc3824e75f36cc dd3755e42b934d6f9189c45409064ebc t = -0.500 984398f142964a9f97cc3824e75f36cc--dd3755e42b934d6f9189c45409064ebc cae886941e2b4064a8d0a108743573e6 X dd3755e42b934d6f9189c45409064ebc--cae886941e2b4064a8d0a108743573e6 cae886941e2b4064a8d0a108743573e6--b85fc0630fe8451784d0f00b1abced96 63f7e2a3ce7a47eaaa1fccb645eb4c46 335673fde159403881453806c12a3960 X d5cba93910814ec383791e1f8e15ccdb--335673fde159403881453806c12a3960 690bb1de1aa14338ae9b83057291da2b 335673fde159403881453806c12a3960--690bb1de1aa14338ae9b83057291da2b 5cd7cbf00ce54f1da9345537e47a9021 X 690bb1de1aa14338ae9b83057291da2b--5cd7cbf00ce54f1da9345537e47a9021 9a18fe355cd5484e89144a6331f28487 X 5cd7cbf00ce54f1da9345537e47a9021--9a18fe355cd5484e89144a6331f28487 3646f68506884230b8496cc2a67e34e8 9a18fe355cd5484e89144a6331f28487--3646f68506884230b8496cc2a67e34e8 e2b5d80c31d243a484270116feeeb14a X 3646f68506884230b8496cc2a67e34e8--e2b5d80c31d243a484270116feeeb14a e2b5d80c31d243a484270116feeeb14a--63f7e2a3ce7a47eaaa1fccb645eb4c46 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_3f52cf8c06784e109b6959baffb1748c cluster_52d6d63d2c9343cc959ffceb5205fce0 49e9bb69692543978c8f912284df8b86 0 ea852a67f5a54ec99e26cef5acf95851 X 49e9bb69692543978c8f912284df8b86--ea852a67f5a54ec99e26cef5acf95851 a1bb85737ac54ca3a474145372edacdc 1 e87d06505c0d48efbe7f0d37c26aaa95 HamEvo ea852a67f5a54ec99e26cef5acf95851--e87d06505c0d48efbe7f0d37c26aaa95 9b3310c2d4894e40980e6a6808538ae3 X e87d06505c0d48efbe7f0d37c26aaa95--9b3310c2d4894e40980e6a6808538ae3 ed961e7526ce4f558524d7e873c6f3bb 9b3310c2d4894e40980e6a6808538ae3--ed961e7526ce4f558524d7e873c6f3bb 2cb80247afc249d8a6b34d18485d5bae HamEvo ed961e7526ce4f558524d7e873c6f3bb--2cb80247afc249d8a6b34d18485d5bae c19a962784a44456863c9fb26c78d1b2 2cb80247afc249d8a6b34d18485d5bae--c19a962784a44456863c9fb26c78d1b2 d75d4b3d35384c139acb2494fd716ec9 c19a962784a44456863c9fb26c78d1b2--d75d4b3d35384c139acb2494fd716ec9 ed95312bf28c432cb773d34358eff2f0 fb4009e9958e468fa58c19af351a7f3d a1bb85737ac54ca3a474145372edacdc--fb4009e9958e468fa58c19af351a7f3d 36f97fed75a54a24a6727044ef388323 2 9680e89d88cd454bab8cb0f6c654c505 t = -500.000000000000 fb4009e9958e468fa58c19af351a7f3d--9680e89d88cd454bab8cb0f6c654c505 99667413cfba4eeab2dcd4adb21aed9a 9680e89d88cd454bab8cb0f6c654c505--99667413cfba4eeab2dcd4adb21aed9a 5662c029837e4f7a804a6213d021482e X 99667413cfba4eeab2dcd4adb21aed9a--5662c029837e4f7a804a6213d021482e 19e7e792003d416485afabd01fc32c6d t = -500.000000000000 5662c029837e4f7a804a6213d021482e--19e7e792003d416485afabd01fc32c6d 7b46c6e484494662969fc5bf43a469af X 19e7e792003d416485afabd01fc32c6d--7b46c6e484494662969fc5bf43a469af 7b46c6e484494662969fc5bf43a469af--ed95312bf28c432cb773d34358eff2f0 91f56ad1f29243db82d6a1dfb5c10633 9bb748cadbcc49548e29fbe9b45e31d5 X 36f97fed75a54a24a6727044ef388323--9bb748cadbcc49548e29fbe9b45e31d5 fe5488ebad524514b6e048e6e2b76f42 9bb748cadbcc49548e29fbe9b45e31d5--fe5488ebad524514b6e048e6e2b76f42 0769d8fbae784e25b5b2770e256731b2 X fe5488ebad524514b6e048e6e2b76f42--0769d8fbae784e25b5b2770e256731b2 6c6ffa6ae57443f192c3e1e1f1f550c2 X 0769d8fbae784e25b5b2770e256731b2--6c6ffa6ae57443f192c3e1e1f1f550c2 57713ec631fa4f8aa93b72f5f3c279df 6c6ffa6ae57443f192c3e1e1f1f550c2--57713ec631fa4f8aa93b72f5f3c279df 18a94e9e24a74da0921c3a7c06551a73 X 57713ec631fa4f8aa93b72f5f3c279df--18a94e9e24a74da0921c3a7c06551a73 18a94e9e24a74da0921c3a7c06551a73--91f56ad1f29243db82d6a1dfb5c10633 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <p><code>python exec=\"off\" source=\"material-block\" html=\"1\" session=\"pulser-basic\" config = {     \"cloud_configuration\": {         \"username\": \"&lt;changeme&gt;\",         \"password\": \"&lt;changeme&gt;\",         \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators         \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`     } }</code></p> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7080-0.0207j,  0.0395+0.3061j,  0.0039-0.0540j,  0.6220-0.1151j]])\nsample = Counter({'00': 27, '11': 18, '01': 5})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-11-06T13:38:12.581419 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-11-06T13:38:12.733081 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 26, '01': 18, '11': 6})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-11-06T13:38:13.403686 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-11-06T13:38:13.611337 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system. A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on. Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations such as single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks. Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks. Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time). Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time). Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian</p> <pre><code>H = \u2211\u1d62(h\u03a9/2 sin(\u03c6)*X\u1d62 - cos(\u03c6)*Y\u1d62 - h\u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits. In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially. On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially. On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically. On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically. On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks. Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially. Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed). Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally. Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.5034+0.1645j, -0.2575-0.4773j, -0.1863-0.2398j, -0.5771+0.0125j],\n[ 0.0301-0.4791j,  0.5561+0.0912j, -0.5891-0.2234j, -0.1547-0.1766j],\n[-0.1238-0.5348j, -0.3862-0.0394j,  0.2656+0.1068j, -0.1997-0.6528j],\n[-0.3733-0.2200j, -0.1777-0.4539j,  0.0268-0.6544j,  0.3337+0.1853j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nsupport = tuple(range(n_qubits)) if support is None else support\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=RZ,\nfm_type=BasisSet.FOURIER,\nreupload_scaling=ReuploadScaling.EXP,\nfeature_range=feature_range,\ntarget_range=(0.0, 2 * pi),\n)\nrlayer.tag = None\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] | None = None,\nparam: Parameter | str = \"phi\",\nop: RotationTypes = RX,\nfm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\nreupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\nfeature_range: tuple[float, float] | None = None,\ntarget_range: tuple[float, float] | None = None,\nmultiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n# Process input\nif support is None:\nsupport = tuple(range(n_qubits))\nelif len(support) != n_qubits:\nraise ValueError(\"Wrong qubit support supplied\")\nif op not in ROTATIONS:\nraise ValueError(\nf\"Operation {op} not supported. \"\nf\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n)\n# Backwards compatibility\nif fm_type in (\"fourier\", \"chebyshev\", \"tower\"):\nlogger.warning(\n\"Selecting `fm_type` as 'fourier', 'chebyshev' or 'tower' is deprecated. \"\n\"Please use the respective enumerations: 'fm_type = BasisSet.FOURIER', \"\n\"'fm_type = BasisSet.CHEBYSHEV' or 'reupload_scaling = ReuploadScaling.TOWER'.\"\n)\nif fm_type == \"fourier\":\nfm_type = BasisSet.FOURIER\nelif fm_type == \"chebyshev\":\nfm_type = BasisSet.CHEBYSHEV\nelif fm_type == \"tower\":\nfm_type = BasisSet.CHEBYSHEV\nreupload_scaling = ReuploadScaling.TOWER\nif isinstance(param, Parameter):\nfparam = param\nfparam.trainable = False\nelse:\nfparam = FeatureParameter(param)\n# Set feature and target range\nfeature_range = _set_range(fm_type) if feature_range is None else feature_range\ntarget_range = _set_range(fm_type) if target_range is None else target_range\n# Rescale the feature parameter\nscaling = (max(target_range) - min(target_range)) / (max(feature_range) - min(feature_range))\nshift = min(target_range) - min(feature_range) * scaling\nif isclose(scaling, 1.0):\n# So we don't get 1.0 factor in visualization\nscaled_fparam = fparam + shift\nelse:\nscaled_fparam = scaling * fparam + shift\n# Transform feature parameter\nif fm_type == BasisSet.FOURIER:\ntransformed_feature = scaled_fparam\nelif fm_type == BasisSet.CHEBYSHEV:\ntransformed_feature = acos(scaled_fparam)\nelif inspect.isclass(fm_type) and issubclass(fm_type, Function):\ntransformed_feature = fm_type(scaled_fparam)\nelse:\nraise NotImplementedError(\nf\"Feature map type {fm_type} not implemented. Choose an item from the BasisSet \"\nf\"enum: {[bs.name for bs in BasisSet]}, or your own sympy.Function to wrap \"\n\"the given feature parameter with.\"\n)\nbasis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n# Set reupload scaling function\nif callable(reupload_scaling):\nrs_func = reupload_scaling\nrs_tag = \"Custom\"\nelse:\nrs_func = RS_FUNC_DICT.get(reupload_scaling, None)  # type: ignore [call-overload]\nif rs_func is None:\nraise NotImplementedError(\nf\"Reupload scaling {reupload_scaling} not implemented; choose an item from \"\nf\"the ReuploadScaling enum: {[rs.name for rs in ReuploadScaling]}, or your own \"\n\"python function with a single int arg as input and int or float output.\"\n)\nif isinstance(reupload_scaling, ReuploadScaling):\nrs_tag = reupload_scaling.value\nelse:\nrs_tag = reupload_scaling\n# Set overall multiplier\nmultiplier = 1 if multiplier is None else multiplier\n# Build feature map\nop_list = []\nfor i, qubit in enumerate(support):\nop_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\nfm = kron(*op_list)\nfm.tag = rs_tag + \" \" + basis_tag + \" FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\nFutureWarning,\n)\nfm = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=op,\nfm_type=BasisSet.CHEBYSHEV,\nreupload_scaling=ReuploadScaling.TOWER,\n)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers using step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers\n    using step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function. Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian with another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian\n    with another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"\n    Converts a spectrum string (e.g., tower or exponential) to the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments (see in the examples).</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments\n    (see in the examples).\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.  This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.  This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function. The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f9c987d6560&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f9c987d57e0&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>. Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: Union[None, DataLoader, DictDataLoader],\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if dataloader is not None else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(model, optimizer, loss_fn, None)\nloss = loss.item()\nelif isinstance(dataloader, (DictDataLoader, DataLoader)):\ndata = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data)\nelse:\nraise NotImplementedError(\nf\"Unsupported dataloader type: {type(dataloader)}. \"\n\"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n)\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if dataloader is not None else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, (DictDataLoader, DataLoader)):\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors. Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.1014, 0.5072]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n\"\"\"Randomly sample points from the first dimension of the given tensors.\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\nself.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.2960, 0.9017, 0.9459, 0.4682, 0.8223]), tensor([0.0929, 0.9649, 0.8553, 0.4821, 0.7216]), tensor([0.1679, 0.2914, 0.0584, 0.0124, 0.3985])]\n[tensor([0.4065, 0.8547, 0.7909, 0.8125, 0.1453]), tensor([0.5520, 0.5128, 0.8844, 0.3853, 0.1138]), tensor([0.7267, 0.4795, 0.8860, 0.1588, 0.1412])]\n[tensor([0.2960, 0.9017, 0.9459, 0.4682, 0.8223]), tensor([0.0929, 0.9649, 0.8553, 0.4821, 0.7216]), tensor([0.1679, 0.2914, 0.0584, 0.0124, 0.3985])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n\"\"\"Convert torch tensors an (infinite) Dataloader.\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\nds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\nreturn DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> A block implementing the Hamiltonian evolution operation H where <p>H = exp(-iG, t)</p> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.4599-8.2746e-17j, -1.0636+6.0285e-17j],\n[ 1.0384-1.7561e-17j, -0.2797+4.7303e-18j]])\ntensor([[ 1.0451-0.3114j, -0.0794-0.6010j],\n[ 1.0370-0.0716j, -0.0031-0.1376j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation. Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation. Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=np.pi / 2)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names. This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['d1c8ff43-584d-48e1-b5bd-60b186e2221a', 'b80c263a-b589-4a19-8ca6-9b8b9e6b340b'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code> to include two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters. Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"PARAMETER  DESCRIPTION <code>name</code> <p>When given a string only, the class constructs a trainable Parameter with a a randomly initialized value.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> </p> <code>**assumptions</code> <p>are passed on to the parent class <code>sympy.Symbol</code>. Two new assumption kwargs are supported by this constructor: <code>trainable: bool</code>, and <code>value: TNumber</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>from qadence import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.17551636621440014\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = torch.rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> <code>values</code> <p>values dict which contains values for the Parameters, if empty, Parameter.value will be used.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>as_torch</code> <p>Whether to retrieve a torch-differentiable expression result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.022775873830503092\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn torch.Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: torch.tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"PARAMETER  DESCRIPTION <code>expr</code> <p>An expression consisting of Parameters.</p> <p> TYPE: <code>Expr</code> </p> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[sympy.N(expr)], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>A QuantumCircuit instance is completely abstract and it needs to be passed to a quantum backend in order to be executed.</p> PARAMETER  DESCRIPTION <code>support</code> <p><code>Register</code> or number of qubits. If an integer is provided, a register is constructed with <code>Register.all_to_all(x)</code></p> <p> TYPE: <code>int | Register</code> </p> <code>*blocks</code> <p>(Possibly multiple) blocks to construct the circuit from.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>()</code> </p> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n\"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\nreturn QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates (needed for e.g. analog computing). The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates (needed for e.g. analog\n    computing). The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5a2bcd9b-33fa-4f66-a99c-a4b6a98056e2', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.018322510672946324'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('cbd1cc2c-41f7-47c2-b9cb-2a382c519e58', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.7463305876414196'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5446bb77-d10a-48ed-ad19-5fa8df7195ff', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.03877776513563347'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('10a8d5f4-c63d-418a-8ea6-ab3f92a8e6ed', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.6066138129044197'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('085d78f1-655d-4ca0-84f1-63ed200fbf5d', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.10912842676989187'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('32032ef0-fcc2-4778-9b1a-81994cad3f07', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.29822982454792'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files. Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('1c0baf4b-41c5-4645-a12e-7a8283404974', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.5810076462149518'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5ff1a521-2b96-414d-8d20-dbf80ad2a2b4', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.8499628572976583'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2559859f-e130-40a1-bcd0-da95fbade61c', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.757617741126467'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4cceea0c-8519-47d5-86d7-49833838cbde', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.964195695561152'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('4347b201-b2c0-481e-949a-e83d295386b3', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.2290437023179559'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f8d27353-a33c-4fc3-9f9a-696a07a892f4', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.8808814304039807'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>00010001\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.backend import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3026-0.2083j,  0.2359+0.1989j, -0.3381+0.5977j, -0.0598-0.5429j]])\ntensor([[ 0.5158-0.3637j,  0.0000+0.0000j, -0.6339+0.4471j,  0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.backend import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = _run_state(_abstract_random_state(n_qubits, batch_size), backend)  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation. Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation. Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\ntry:\nreturn kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks, move the scale all the way down into the leaves of the block tree.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"When given a scaled CompositeBlock consisting of several PrimitiveBlocks,\n    move the scale all the way down into the leaves of the block tree.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks and reassigning qubit locations approriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks and reassigning\n    qubit locations approriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.emulate.add_interaction","title":"<code>add_interaction(x, *args, interaction=Interaction.NN, spacing=1.0)</code>","text":"<p>Turns blocks or circuits into (a chain of) <code>HamEvo</code> blocks including a chosen interaction term.</p> <p>This is a <code>@singledipatch</code>ed function which can be called in three ways:</p> <ul> <li>With a <code>QuantumCircuit</code> which contains all necessary information: <code>add_interaction(circuit)</code></li> <li>With a <code>Register</code> and an <code>AbstractBlock</code>: <code>add_interaction(reg, block)</code></li> <li>With an <code>AbstractBlock</code> only: <code>add_interaction(block)</code></li> </ul> <p>See the section about analog blocks for detailed information about how which types of blocks are translated.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit or block to be emulated. See the examples on which argument combinations are accepted.</p> <p> TYPE: <code>Register | QuantumCircuit | AbstractBlock</code> </p> <code>interaction</code> <p>Type of interaction that is added. Can also be a function that accepts a register and a list of edges that define which qubits interact (see the examples).</p> <p> TYPE: <code>Interaction | Callable</code> DEFAULT: <code>NN</code> </p> <code>spacing</code> <p>All qubit coordinates are multiplied by <code>spacing</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import QuantumCircuit, AnalogRX, add_interaction\nc = QuantumCircuit(2, AnalogRX(2.0))\ne = add_interaction(c)\n</code></pre> <pre><code>[mul: 0.0] \u2514\u2500\u2500 AddBlock(0,1)\n\u251c\u2500\u2500 AddBlock(0,1)\n\u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u251c\u2500\u2500 [mul: 1.571] \u2502       \u2502   \u2514\u2500\u2500 AddBlock(0,1)\n\u2502       \u2502       \u251c\u2500\u2500 AddBlock(0)\n\u2502       \u2502       \u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502       \u2502   \u2502   \u2514\u2500\u2500 X(0)\n\u2502       \u2502       \u2502   \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502       \u2502       \u2514\u2500\u2500 Y(0)\n\u2502       \u2502       \u2514\u2500\u2500 AddBlock(1)\n\u2502       \u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502       \u2502           \u2502   \u2514\u2500\u2500 X(1)\n\u2502       \u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502       \u2502               \u2514\u2500\u2500 Y(1)\n\u2502       \u2514\u2500\u2500 [mul: 0.0] \u2502           \u2514\u2500\u2500 AddBlock(0,1)\n\u2502               \u251c\u2500\u2500 N(0)\n\u2502               \u2514\u2500\u2500 N(1)\n\u2514\u2500\u2500 AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 865723.020] \u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 N(0)\n\u2514\u2500\u2500 N(1)\n</code></pre>  You can also use <code>add_interaction</code> directly on a block, but you have to provide either the <code>Register</code> or define a non-global qubit support. <pre><code>from qadence import AnalogRX, Register, add_interaction\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b)\n# or provide only the block with local qubit support\n# in this case the register is created via `Register(b.n_qubits)`\ne = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\nprint(e.generator)\n</code></pre> <pre><code>[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n[mul: 0.450] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 [mul: 1.571] \u2502   \u2514\u2500\u2500 AddBlock(0)\n\u2502       \u2514\u2500\u2500 AddBlock(0)\n\u2502           \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502           \u2502   \u2514\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 [mul: 0.0] \u2502               \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 [mul: 0.0] \u2514\u2500\u2500 AddBlock(0)\n\u2514\u2500\u2500 N(0)\n</code></pre>  You can specify a custom <code>interaction</code> function which has to accept a <code>Register</code> and a list of <code>edges: list[tuple[int, int]]</code>: <pre><code>from qadence import AnalogRX, Register, add_interaction\nfrom qadence.transpile.emulate import ising_interaction\ndef int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n# do either something completely custom\n# ...\n# or e.g. change the default kwargs to `ising_interaction`\nreturn ising_interaction(r, pairs, rydberg_level=70)\nb = AnalogRX(2.0)\nr = Register(1)\ne = add_interaction(r, b, interaction=int_fn)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/transpile/emulate.py</code> <pre><code>@singledispatch\ndef add_interaction(\nx: Register | QuantumCircuit | AbstractBlock,\n*args: Any,\ninteraction: Interaction | Callable = Interaction.NN,\nspacing: float = 1.0,\n) -&gt; QuantumCircuit | AbstractBlock:\n\"\"\"Turns blocks or circuits into (a chain of) `HamEvo` blocks including a\n    chosen interaction term.\n    This is a `@singledipatch`ed function which can be called in three ways:\n    * With a `QuantumCircuit` which contains all necessary information: `add_interaction(circuit)`\n    * With a `Register` and an `AbstractBlock`: `add_interaction(reg, block)`\n    * With an `AbstractBlock` only: `add_interaction(block)`\n    See the section about [analog blocks](/digital_analog_qc/analog-basics.md) for\n    detailed information about how which types of blocks are translated.\n    Arguments:\n        x: Circuit or block to be emulated. See the examples on which argument\n            combinations are accepted.\n        interaction: Type of interaction that is added. Can also be a function that accepts a\n            register and a list of edges that define which qubits interact (see the examples).\n        spacing: All qubit coordinates are multiplied by `spacing`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import QuantumCircuit, AnalogRX, add_interaction\n    c = QuantumCircuit(2, AnalogRX(2.0))\n    e = add_interaction(c)\n    print(str(e.block.generator)) # markdown-exec: hide\n    ```\n    You can also use `add_interaction` directly on a block, but you have to provide either\n    the `Register` or define a non-global qubit support.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b)\n    print(e.generator) # markdown-exec: hide\n    # or provide only the block with local qubit support\n    # in this case the register is created via `Register(b.n_qubits)`\n    e = add_interaction(AnalogRX(2.0, qubit_support=(0,)))\n    print(e.generator)\n    ```\n    You can specify a custom `interaction` function which has to accept a `Register` and a list\n    of `edges: list[tuple[int, int]]`:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import AnalogRX, Register, add_interaction\n    from qadence.transpile.emulate import ising_interaction\n    def int_fn(r: Register, pairs: list[tuple[int, int]]) -&gt; AbstractBlock:\n        # do either something completely custom\n        # ...\n        # or e.g. change the default kwargs to `ising_interaction`\n        return ising_interaction(r, pairs, rydberg_level=70)\n    b = AnalogRX(2.0)\n    r = Register(1)\n    e = add_interaction(r, b, interaction=int_fn)\n    ```\n    \"\"\"\nraise ValueError(f\"`add_interaction` is not implemented for {type(x)}\")\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, torch.Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[torch.Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, torch.Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in - <code>add_interaction</code>. - <code>hamiltonian_factory</code>.</p>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 20, '0100': 12, '0010': 11, '1000': 11, '0001': 6, '1001': 5, '1100': 5, '1110': 5, '0110': 4, '1010': 4, '1101': 4, '0011': 3, '0101': 3, '1011': 3, '1111': 3, '0111': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: tensor([[0.1259],\n[0.0521],\n[0.1225],\n[0.0558],\n[0.0525],\n[0.1269],\n[0.0203],\n[0.1222],\n[0.1252],\n[0.0679]], grad_fn=&lt;CatBackward0&gt;)\nFirst-order derivative w.r.t. the feature parameter: tensor([ 0.0451,  0.1921,  0.0859,  0.1937,  0.1922, -0.0174,  0.1539,  0.0886,\n0.0571,  0.1955], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: tensor([ 0.0451,  0.1921,  0.0859,  0.1937,  0.1922, -0.0174,  0.1539,  0.0886,\n0.0571,  0.1955], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\nx = torch.linspace(0, 1, data_size).reshape(-1, 1)\ny = torch.sin(x)\nreturn to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\ndls = {}\nfor k in [\"y1\", \"y2\"]:\nx = torch.rand(data_size, 1)\ny = torch.sin(x)\ndls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\nreturn DictDataLoader(dls)\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\nprint(f\"Standard {x = }\")\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n(x, y) = next(dl)\nprint(f\"Infinite {x = }\")\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n[0.2000]])\nStandard x = tensor([[0.4000],\n[0.6000]])\nStandard x = tensor([[0.8000],\n[1.0000]])\nInfinite x = tensor([[0.0000],\n[0.2000]])\nInfinite x = tensor([[0.4000],\n[0.6000]])\nInfinite x = tensor([[0.8000],\n[1.0000]])\nInfinite x = tensor([[0.0000],\n[0.2000]])\nInfinite x = tensor([[0.4000],\n[0.6000]])\ndata = {'y1': [tensor([[0.6412],\n[0.6181],\n[0.6717],\n[0.8965],\n[0.1961]]), tensor([[0.5981],\n[0.5795],\n[0.6223],\n[0.7811],\n[0.1948]])], 'y2': [tensor([[0.5725],\n[0.5203],\n[0.3373],\n[0.3100],\n[0.8869]]), tensor([[0.5417],\n[0.4971],\n[0.3310],\n[0.3051],\n[0.7751]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 50\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-11-06T13:38:17.893821 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-11-06T13:38:19.059762 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_8657c79d8b09419eaf8172a9b161dd5d mixing cluster_60cbd73f748c48809271cefd1b05368f cost cluster_3d643c92213c4dd7a9fdbdd9388cf726 mixing cluster_c7bfff6b0de042b8833d2ab697639eb6 cost b71c33363cba42ecbe387f948e6a566b 0 c53ad343faca4c2b95a1088a8a4ee2bf b71c33363cba42ecbe387f948e6a566b--c53ad343faca4c2b95a1088a8a4ee2bf bb977b2ee6004d19a9d310c7699bcde2 1 367a8e6909fa46c49cfd0095590e9e88 c53ad343faca4c2b95a1088a8a4ee2bf--367a8e6909fa46c49cfd0095590e9e88 168cff642d9749ae99ab99867158973f 367a8e6909fa46c49cfd0095590e9e88--168cff642d9749ae99ab99867158973f d03d3073c9f040de91fd085dceb53262 168cff642d9749ae99ab99867158973f--d03d3073c9f040de91fd085dceb53262 d255cfeab17b479dbe186817050f0855 d03d3073c9f040de91fd085dceb53262--d255cfeab17b479dbe186817050f0855 4d3a8a60413d47bd8e503cd0b097dc1a d255cfeab17b479dbe186817050f0855--4d3a8a60413d47bd8e503cd0b097dc1a 2feb71b5b1b94da390d19480389466f4 4d3a8a60413d47bd8e503cd0b097dc1a--2feb71b5b1b94da390d19480389466f4 6987905ba0ac4d15a62e98a823206835 2feb71b5b1b94da390d19480389466f4--6987905ba0ac4d15a62e98a823206835 a69ee99ef8d243ff98335702516f675b 6987905ba0ac4d15a62e98a823206835--a69ee99ef8d243ff98335702516f675b 1210e7e2eca94d8197cd4f9f8370cf52 a69ee99ef8d243ff98335702516f675b--1210e7e2eca94d8197cd4f9f8370cf52 58df0de673c84f768454e4b51775ec1e 1210e7e2eca94d8197cd4f9f8370cf52--58df0de673c84f768454e4b51775ec1e 1f77a51676494789babde230e0ec5f00 58df0de673c84f768454e4b51775ec1e--1f77a51676494789babde230e0ec5f00 5874b85d9b674d849d3573c93a77d2b3 1f77a51676494789babde230e0ec5f00--5874b85d9b674d849d3573c93a77d2b3 36e89d845660433c8c3b5854a0b414e3 5874b85d9b674d849d3573c93a77d2b3--36e89d845660433c8c3b5854a0b414e3 3a9e79a5793942a6a64ef49b5cf5f6af 36e89d845660433c8c3b5854a0b414e3--3a9e79a5793942a6a64ef49b5cf5f6af a129ef9cd25f410abd326443ea023f1f 3a9e79a5793942a6a64ef49b5cf5f6af--a129ef9cd25f410abd326443ea023f1f 85388edd326d45e6bdbe2530a85783f5 a129ef9cd25f410abd326443ea023f1f--85388edd326d45e6bdbe2530a85783f5 5c8771844181464db79ce8a25e85f1bd 85388edd326d45e6bdbe2530a85783f5--5c8771844181464db79ce8a25e85f1bd cf9b5506701848c3b362562f8ed6cfb3 5c8771844181464db79ce8a25e85f1bd--cf9b5506701848c3b362562f8ed6cfb3 4d716ffc1e47454880feeb325660306a cf9b5506701848c3b362562f8ed6cfb3--4d716ffc1e47454880feeb325660306a a2eedd9729704f90aabe55f9b64ad246 4d716ffc1e47454880feeb325660306a--a2eedd9729704f90aabe55f9b64ad246 00a15a1fffde4791a68bb7559a73313d a2eedd9729704f90aabe55f9b64ad246--00a15a1fffde4791a68bb7559a73313d 6ff413af580447ae8e6ef4c5ae8cde34 00a15a1fffde4791a68bb7559a73313d--6ff413af580447ae8e6ef4c5ae8cde34 4a82b4a6856044a3b8d19777ad71059b 6ff413af580447ae8e6ef4c5ae8cde34--4a82b4a6856044a3b8d19777ad71059b 0911442c20324638892a84b396e3ffd5 4a82b4a6856044a3b8d19777ad71059b--0911442c20324638892a84b396e3ffd5 77cca5a7ee694ff8b8543b94b80fa1fc 0911442c20324638892a84b396e3ffd5--77cca5a7ee694ff8b8543b94b80fa1fc b05400afe73e4ac4b2ff660689d7d9ea 77cca5a7ee694ff8b8543b94b80fa1fc--b05400afe73e4ac4b2ff660689d7d9ea 89a7e903aaa7499a836d3ad6e581a9d2 b05400afe73e4ac4b2ff660689d7d9ea--89a7e903aaa7499a836d3ad6e581a9d2 109ce4b6552c4f8b879bda974bcd337f 89a7e903aaa7499a836d3ad6e581a9d2--109ce4b6552c4f8b879bda974bcd337f 0917b84010354fc3afcfd39a3c9e6d87 109ce4b6552c4f8b879bda974bcd337f--0917b84010354fc3afcfd39a3c9e6d87 132870fc138d4d84b9ac4161f7bc805a 0917b84010354fc3afcfd39a3c9e6d87--132870fc138d4d84b9ac4161f7bc805a f35a062326a8459db333d2ba578ea582 132870fc138d4d84b9ac4161f7bc805a--f35a062326a8459db333d2ba578ea582 c22b09ddf29f4541a6908155d2746ade f35a062326a8459db333d2ba578ea582--c22b09ddf29f4541a6908155d2746ade 223681286d7d41bdbae055bb196f4d03 c22b09ddf29f4541a6908155d2746ade--223681286d7d41bdbae055bb196f4d03 5842843fdeca43219b56a6acea06bb88 223681286d7d41bdbae055bb196f4d03--5842843fdeca43219b56a6acea06bb88 12dbdd38487f47a99eb4ce4c1b71d53c 5842843fdeca43219b56a6acea06bb88--12dbdd38487f47a99eb4ce4c1b71d53c 349a1575addd474b8d496aab9d1398bb 12dbdd38487f47a99eb4ce4c1b71d53c--349a1575addd474b8d496aab9d1398bb f31084d2bf01488b88f614b5990e9a1f 349a1575addd474b8d496aab9d1398bb--f31084d2bf01488b88f614b5990e9a1f 26c42bacef574096a77e7b73770b8866 f31084d2bf01488b88f614b5990e9a1f--26c42bacef574096a77e7b73770b8866 44e3d7f0db804c009cc35ac03cdfc1cc 26c42bacef574096a77e7b73770b8866--44e3d7f0db804c009cc35ac03cdfc1cc 853661efb0d647169c71154c7c7391d7 44e3d7f0db804c009cc35ac03cdfc1cc--853661efb0d647169c71154c7c7391d7 f134d610e6a64dc5a00c291493927304 853661efb0d647169c71154c7c7391d7--f134d610e6a64dc5a00c291493927304 3c64e10fd9b54326b984dd7b78f8c319 f134d610e6a64dc5a00c291493927304--3c64e10fd9b54326b984dd7b78f8c319 bb0d6eb6e90d482194e96fd3b80e579a 3c64e10fd9b54326b984dd7b78f8c319--bb0d6eb6e90d482194e96fd3b80e579a a1c666f22cb54f8387d3172c5b01f688 bb0d6eb6e90d482194e96fd3b80e579a--a1c666f22cb54f8387d3172c5b01f688 c394447333a0463f93ac8578abd95b09 a1c666f22cb54f8387d3172c5b01f688--c394447333a0463f93ac8578abd95b09 0f400b7f67c34ff69a9fed863a9b227a c394447333a0463f93ac8578abd95b09--0f400b7f67c34ff69a9fed863a9b227a c3fc671ec2c14435bc86c16c22216cc7 0f400b7f67c34ff69a9fed863a9b227a--c3fc671ec2c14435bc86c16c22216cc7 d96db0d189fb4d52b47846e2b31ec406 c3fc671ec2c14435bc86c16c22216cc7--d96db0d189fb4d52b47846e2b31ec406 14df3462adb64144a9f0f2ed8aa07cd0 d96db0d189fb4d52b47846e2b31ec406--14df3462adb64144a9f0f2ed8aa07cd0 b39b4d5fc07a4884a37d0b6f5d79d3d8 14df3462adb64144a9f0f2ed8aa07cd0--b39b4d5fc07a4884a37d0b6f5d79d3d8 eec38cf1188b48a2b676c3ca49b98f94 b39b4d5fc07a4884a37d0b6f5d79d3d8--eec38cf1188b48a2b676c3ca49b98f94 f6610b8b055d405bab2b93774ea8e99c eec38cf1188b48a2b676c3ca49b98f94--f6610b8b055d405bab2b93774ea8e99c 951a971a04f34904b1476c22de231117 f6610b8b055d405bab2b93774ea8e99c--951a971a04f34904b1476c22de231117 c152caf10386435dbaa18b27a672c28b 951a971a04f34904b1476c22de231117--c152caf10386435dbaa18b27a672c28b 4b89212b49d64b26a1654656e253fe83 c152caf10386435dbaa18b27a672c28b--4b89212b49d64b26a1654656e253fe83 f4250446f8a14e1c9f737b4fc38a02e9 4b89212b49d64b26a1654656e253fe83--f4250446f8a14e1c9f737b4fc38a02e9 46996bce96fe4863a8bacba641d930bd f4250446f8a14e1c9f737b4fc38a02e9--46996bce96fe4863a8bacba641d930bd 55f73f34d8cb4375b2950f8960a210b7 46996bce96fe4863a8bacba641d930bd--55f73f34d8cb4375b2950f8960a210b7 332312b5292d45e18fdbb0711220c20e 55f73f34d8cb4375b2950f8960a210b7--332312b5292d45e18fdbb0711220c20e cf0d853393a34f9984a3c2317cf4fc21 332312b5292d45e18fdbb0711220c20e--cf0d853393a34f9984a3c2317cf4fc21 1ad9dfdf3b954bf48023fdf8f9ae7f1b cf0d853393a34f9984a3c2317cf4fc21--1ad9dfdf3b954bf48023fdf8f9ae7f1b 85ef5a23790f45118310d56235b66962 1ad9dfdf3b954bf48023fdf8f9ae7f1b--85ef5a23790f45118310d56235b66962 a5ae36a0cd6c40f8885573d5a4527a7f 85ef5a23790f45118310d56235b66962--a5ae36a0cd6c40f8885573d5a4527a7f 746f5259d00e41848824d8ca29361cce a5ae36a0cd6c40f8885573d5a4527a7f--746f5259d00e41848824d8ca29361cce abd16a4da28d4cd0adcee330ebad22a3 746f5259d00e41848824d8ca29361cce--abd16a4da28d4cd0adcee330ebad22a3 f135dfdb1c6b4a83834aa50f251c8e19 abd16a4da28d4cd0adcee330ebad22a3--f135dfdb1c6b4a83834aa50f251c8e19 5e269c642a384b7bb4044c8bf3d839c1 f135dfdb1c6b4a83834aa50f251c8e19--5e269c642a384b7bb4044c8bf3d839c1 5b070c4f38644cf8b00d17f3e8f43ff4 5e269c642a384b7bb4044c8bf3d839c1--5b070c4f38644cf8b00d17f3e8f43ff4 9434b41678e24f0290e481dc0389cf9f 5b070c4f38644cf8b00d17f3e8f43ff4--9434b41678e24f0290e481dc0389cf9f 558d08b36faa4cb2bb33d67955bf875d 9434b41678e24f0290e481dc0389cf9f--558d08b36faa4cb2bb33d67955bf875d da4da93e4bb949d79d3157c0fd35a0bb 558d08b36faa4cb2bb33d67955bf875d--da4da93e4bb949d79d3157c0fd35a0bb c9efdcf6ae214666adca35da721de7ab da4da93e4bb949d79d3157c0fd35a0bb--c9efdcf6ae214666adca35da721de7ab 679b172d80ff4f7f90be2e835814d218 c9efdcf6ae214666adca35da721de7ab--679b172d80ff4f7f90be2e835814d218 251eb01997194bafaa84094438d5fa02 679b172d80ff4f7f90be2e835814d218--251eb01997194bafaa84094438d5fa02 757f0fea77ab42ba875cf7b1c3811615 251eb01997194bafaa84094438d5fa02--757f0fea77ab42ba875cf7b1c3811615 80aefa7e835f4bab820596d0f3b18343 757f0fea77ab42ba875cf7b1c3811615--80aefa7e835f4bab820596d0f3b18343 733420dfdf1848c684fafdff113d27cb 80aefa7e835f4bab820596d0f3b18343--733420dfdf1848c684fafdff113d27cb f7030b8f9f304c1a8a63a59367ea7e16 733420dfdf1848c684fafdff113d27cb--f7030b8f9f304c1a8a63a59367ea7e16 03013afc1b5844fc8ea897ce62dce7d2 f7030b8f9f304c1a8a63a59367ea7e16--03013afc1b5844fc8ea897ce62dce7d2 3bca7ab9423045b496eaf53ab7c98133 03013afc1b5844fc8ea897ce62dce7d2--3bca7ab9423045b496eaf53ab7c98133 c39e800febc444779bb6f1f9d60f06a0 3bca7ab9423045b496eaf53ab7c98133--c39e800febc444779bb6f1f9d60f06a0 5c838bc5636045f593efa4f3b9aff09e c39e800febc444779bb6f1f9d60f06a0--5c838bc5636045f593efa4f3b9aff09e 94f0a266a80c4f53876c22519c5fe556 5c838bc5636045f593efa4f3b9aff09e--94f0a266a80c4f53876c22519c5fe556 942348078c3641398090fad532a95516 94f0a266a80c4f53876c22519c5fe556--942348078c3641398090fad532a95516 f4cd0289303944b6b55c8f0cf5f380c0 942348078c3641398090fad532a95516--f4cd0289303944b6b55c8f0cf5f380c0 7693ac2d9e4c4ea6b1dd7786c4fe3345 f4cd0289303944b6b55c8f0cf5f380c0--7693ac2d9e4c4ea6b1dd7786c4fe3345 4ce0a307be174e45be1041cbe9bdde63 7693ac2d9e4c4ea6b1dd7786c4fe3345--4ce0a307be174e45be1041cbe9bdde63 ce1730eb0b6b4ebe86904d61ed18efd9 4ce0a307be174e45be1041cbe9bdde63--ce1730eb0b6b4ebe86904d61ed18efd9 38103a9cc8f1430e8efb0c2bcc09b28e ce1730eb0b6b4ebe86904d61ed18efd9--38103a9cc8f1430e8efb0c2bcc09b28e dca178e9a09d47eabf54795b756cf5fa 38103a9cc8f1430e8efb0c2bcc09b28e--dca178e9a09d47eabf54795b756cf5fa 0af9e811cf584a488a5e09308a1b1c74 dca178e9a09d47eabf54795b756cf5fa--0af9e811cf584a488a5e09308a1b1c74 afa6e60c28424cf2a2d13f23157c53fd 0af9e811cf584a488a5e09308a1b1c74--afa6e60c28424cf2a2d13f23157c53fd ed52e1fb10964a90b38793d47b5d68b5 afa6e60c28424cf2a2d13f23157c53fd--ed52e1fb10964a90b38793d47b5d68b5 b9ebda5dc97944e585d14b0cc3e9eca7 ed52e1fb10964a90b38793d47b5d68b5--b9ebda5dc97944e585d14b0cc3e9eca7 c245317e376a4ec083c58e762c3a186a b9ebda5dc97944e585d14b0cc3e9eca7--c245317e376a4ec083c58e762c3a186a dab46c1e8f724f9a9fc114b8646b2c05 c245317e376a4ec083c58e762c3a186a--dab46c1e8f724f9a9fc114b8646b2c05 26f36f54e0d64836ab4d7771a7c94fa3 dab46c1e8f724f9a9fc114b8646b2c05--26f36f54e0d64836ab4d7771a7c94fa3 2e4b9c355e8f470da0274d10d79d4321 26f36f54e0d64836ab4d7771a7c94fa3--2e4b9c355e8f470da0274d10d79d4321 122345fd8dfb4df69e915bc20f6e3144 2e4b9c355e8f470da0274d10d79d4321--122345fd8dfb4df69e915bc20f6e3144 c09f077f5e634f76a87734d91897d9b7 122345fd8dfb4df69e915bc20f6e3144--c09f077f5e634f76a87734d91897d9b7 e9913b09f38a46b4a5fd54a46dc5a4eb c09f077f5e634f76a87734d91897d9b7--e9913b09f38a46b4a5fd54a46dc5a4eb 43e62c6a778a4f3ba365891be5673831 e9913b09f38a46b4a5fd54a46dc5a4eb--43e62c6a778a4f3ba365891be5673831 4b5402751d054c70993788ba9f03a08d 43e62c6a778a4f3ba365891be5673831--4b5402751d054c70993788ba9f03a08d 01e66f92b3714db9998195cf027c2344 RX(b00) 4b5402751d054c70993788ba9f03a08d--01e66f92b3714db9998195cf027c2344 eada6ada4def430093f161c44a1db355 01e66f92b3714db9998195cf027c2344--eada6ada4def430093f161c44a1db355 c050fe148c2143caa6f4932e734a8203 eada6ada4def430093f161c44a1db355--c050fe148c2143caa6f4932e734a8203 d1e5a0cfa6ab4fd28c96eb8df7ff5ed0 c050fe148c2143caa6f4932e734a8203--d1e5a0cfa6ab4fd28c96eb8df7ff5ed0 429ba5d642ce400abcfe57ec8063f38e d1e5a0cfa6ab4fd28c96eb8df7ff5ed0--429ba5d642ce400abcfe57ec8063f38e 8621df70bd8442d5a7e0062b4272b67a 429ba5d642ce400abcfe57ec8063f38e--8621df70bd8442d5a7e0062b4272b67a 596965972825465b8fd1dd439dc2bdf1 8621df70bd8442d5a7e0062b4272b67a--596965972825465b8fd1dd439dc2bdf1 2e6f434afebd4557a71c0adc4b259016 596965972825465b8fd1dd439dc2bdf1--2e6f434afebd4557a71c0adc4b259016 fa6942d38174461a8ab7474d2090eae6 2e6f434afebd4557a71c0adc4b259016--fa6942d38174461a8ab7474d2090eae6 31453d809880416bb67a05f43f587f9a fa6942d38174461a8ab7474d2090eae6--31453d809880416bb67a05f43f587f9a 6387fb8b755b4ae381d244a7e6c36f91 31453d809880416bb67a05f43f587f9a--6387fb8b755b4ae381d244a7e6c36f91 1841969f5b6c42c5b25a05d45f383bba 6387fb8b755b4ae381d244a7e6c36f91--1841969f5b6c42c5b25a05d45f383bba bbbeccb4f375476085e432bb67be0280 1841969f5b6c42c5b25a05d45f383bba--bbbeccb4f375476085e432bb67be0280 78ee4bc8b69a41b598b1e4639d78ed7d bbbeccb4f375476085e432bb67be0280--78ee4bc8b69a41b598b1e4639d78ed7d 4ea69e59984c452eb6ccfbc20a99d097 78ee4bc8b69a41b598b1e4639d78ed7d--4ea69e59984c452eb6ccfbc20a99d097 a3a8f5d216e74b43aa069f9fb0f866e5 4ea69e59984c452eb6ccfbc20a99d097--a3a8f5d216e74b43aa069f9fb0f866e5 68741af5c30f4889869e92fa683b8b08 a3a8f5d216e74b43aa069f9fb0f866e5--68741af5c30f4889869e92fa683b8b08 aa4019a730884db9a93f15ec4fa31149 68741af5c30f4889869e92fa683b8b08--aa4019a730884db9a93f15ec4fa31149 8e58a71105144e65be87643ee78c8bd3 aa4019a730884db9a93f15ec4fa31149--8e58a71105144e65be87643ee78c8bd3 0eb7433df49b4a3fbaf53fd29ed46926 8e58a71105144e65be87643ee78c8bd3--0eb7433df49b4a3fbaf53fd29ed46926 d210050577cb4381b4299addab50625c 0eb7433df49b4a3fbaf53fd29ed46926--d210050577cb4381b4299addab50625c f0bef5cce1574ce28d3f85285cb435e5 d210050577cb4381b4299addab50625c--f0bef5cce1574ce28d3f85285cb435e5 2d35e225bff44d1b9dfb5a72cedeb729 f0bef5cce1574ce28d3f85285cb435e5--2d35e225bff44d1b9dfb5a72cedeb729 4c037c0d0d404f92b087b3fb079e6631 2d35e225bff44d1b9dfb5a72cedeb729--4c037c0d0d404f92b087b3fb079e6631 c2eec9f5c6a649309afabf800dfac47d 4c037c0d0d404f92b087b3fb079e6631--c2eec9f5c6a649309afabf800dfac47d 7fbb163448c04ab7b70e99406a1a20d3 c2eec9f5c6a649309afabf800dfac47d--7fbb163448c04ab7b70e99406a1a20d3 d686d90d6cca49f79436d876922d3eba 7fbb163448c04ab7b70e99406a1a20d3--d686d90d6cca49f79436d876922d3eba 0939dc193aab4bb8b5c570b10ca8b2e8 d686d90d6cca49f79436d876922d3eba--0939dc193aab4bb8b5c570b10ca8b2e8 371f8ca3f3864e5c8ca02293b57a72ee 0939dc193aab4bb8b5c570b10ca8b2e8--371f8ca3f3864e5c8ca02293b57a72ee a57abeeb34d94c07ab7b387989ddf200 371f8ca3f3864e5c8ca02293b57a72ee--a57abeeb34d94c07ab7b387989ddf200 b8d47c45f2e94eddaf3d3100d0bde7a1 a57abeeb34d94c07ab7b387989ddf200--b8d47c45f2e94eddaf3d3100d0bde7a1 9c68b243ef924c15a2338f9a76b156f6 b8d47c45f2e94eddaf3d3100d0bde7a1--9c68b243ef924c15a2338f9a76b156f6 e225882c7f89430a8ab86f94bc4587ef 9c68b243ef924c15a2338f9a76b156f6--e225882c7f89430a8ab86f94bc4587ef 982292066cf04917b86633b2b90f0f91 e225882c7f89430a8ab86f94bc4587ef--982292066cf04917b86633b2b90f0f91 341c6dead8364a2098ecc4da6e8f8458 982292066cf04917b86633b2b90f0f91--341c6dead8364a2098ecc4da6e8f8458 ca54365217004c97aa802018056b0803 341c6dead8364a2098ecc4da6e8f8458--ca54365217004c97aa802018056b0803 cf96a9d0dcf643a1bc3af1021839f633 ca54365217004c97aa802018056b0803--cf96a9d0dcf643a1bc3af1021839f633 297b83fec0c24e1186d6eb9d41bf5d92 cf96a9d0dcf643a1bc3af1021839f633--297b83fec0c24e1186d6eb9d41bf5d92 91b8707c224e4d638a39250c981b11cd 297b83fec0c24e1186d6eb9d41bf5d92--91b8707c224e4d638a39250c981b11cd 5eede903ceb2446d9e57c65d93b21e78 91b8707c224e4d638a39250c981b11cd--5eede903ceb2446d9e57c65d93b21e78 5f094a36d0f44c3ab37297317a63a976 5eede903ceb2446d9e57c65d93b21e78--5f094a36d0f44c3ab37297317a63a976 521a90eba7924a88b6a4359ce186aef0 5f094a36d0f44c3ab37297317a63a976--521a90eba7924a88b6a4359ce186aef0 94eb6864832749d09f7eff898f0da207 521a90eba7924a88b6a4359ce186aef0--94eb6864832749d09f7eff898f0da207 18a5aa38814f46e2a943bf636aece16c 94eb6864832749d09f7eff898f0da207--18a5aa38814f46e2a943bf636aece16c 9b93695d69204405949678fb4e306c4f 18a5aa38814f46e2a943bf636aece16c--9b93695d69204405949678fb4e306c4f 8680d5ce5b704c509355d166f232c842 9b93695d69204405949678fb4e306c4f--8680d5ce5b704c509355d166f232c842 b09762184ca641d78840d06a61e6d252 8680d5ce5b704c509355d166f232c842--b09762184ca641d78840d06a61e6d252 1c097861e76b4047822bf9a641d8fb52 b09762184ca641d78840d06a61e6d252--1c097861e76b4047822bf9a641d8fb52 2a95f38ccddd4f56909143030c92f96f 1c097861e76b4047822bf9a641d8fb52--2a95f38ccddd4f56909143030c92f96f 69d40d6c53c94651a5ade84319b10d0f 2a95f38ccddd4f56909143030c92f96f--69d40d6c53c94651a5ade84319b10d0f ea90849a83d248f5b5db8885cbc74da8 69d40d6c53c94651a5ade84319b10d0f--ea90849a83d248f5b5db8885cbc74da8 6dea1f31c9144d27adf4529dbb8c2f35 ea90849a83d248f5b5db8885cbc74da8--6dea1f31c9144d27adf4529dbb8c2f35 89b59640e7774db29268791970cf027d 6dea1f31c9144d27adf4529dbb8c2f35--89b59640e7774db29268791970cf027d 393867d5b8ce4c5c975ba2a3c0f55637 89b59640e7774db29268791970cf027d--393867d5b8ce4c5c975ba2a3c0f55637 f0e7edfa2c6c43e581cb8eb3ff604099 393867d5b8ce4c5c975ba2a3c0f55637--f0e7edfa2c6c43e581cb8eb3ff604099 0361dbf46d9747f1948e1e22de1eebd4 f0e7edfa2c6c43e581cb8eb3ff604099--0361dbf46d9747f1948e1e22de1eebd4 6f5236e97c994f4f98e6708c8e53b6e6 0361dbf46d9747f1948e1e22de1eebd4--6f5236e97c994f4f98e6708c8e53b6e6 0d8ba46e965a4545a697d978e9c1dae1 6f5236e97c994f4f98e6708c8e53b6e6--0d8ba46e965a4545a697d978e9c1dae1 51158ca3823f4a9485eeeadfc639667a 0d8ba46e965a4545a697d978e9c1dae1--51158ca3823f4a9485eeeadfc639667a b3664e73f05847fd8f3e53afaaf37a0b 51158ca3823f4a9485eeeadfc639667a--b3664e73f05847fd8f3e53afaaf37a0b 0d7cbef6d52746ec8f77fe77a4944f40 b3664e73f05847fd8f3e53afaaf37a0b--0d7cbef6d52746ec8f77fe77a4944f40 736c0cb5525b40c08fe671dd00b73021 0d7cbef6d52746ec8f77fe77a4944f40--736c0cb5525b40c08fe671dd00b73021 8c7b45f59a034633a57c64b860442e9c 736c0cb5525b40c08fe671dd00b73021--8c7b45f59a034633a57c64b860442e9c e5397fdeb397469bb1f29604bc3e6e19 8c7b45f59a034633a57c64b860442e9c--e5397fdeb397469bb1f29604bc3e6e19 ef4d1faeaecc4a52a575b7ba4368e7a8 e5397fdeb397469bb1f29604bc3e6e19--ef4d1faeaecc4a52a575b7ba4368e7a8 c0b20c289b824d4481f0898b23de078e ef4d1faeaecc4a52a575b7ba4368e7a8--c0b20c289b824d4481f0898b23de078e b817dc66d9f34612837622e7b03d47c3 c0b20c289b824d4481f0898b23de078e--b817dc66d9f34612837622e7b03d47c3 772222b0b1ff44a2844f850bfccc20f8 b817dc66d9f34612837622e7b03d47c3--772222b0b1ff44a2844f850bfccc20f8 52933b7f8d51450f8d04ea547569ea05 772222b0b1ff44a2844f850bfccc20f8--52933b7f8d51450f8d04ea547569ea05 e473d0268737401482c51aff8ee74015 52933b7f8d51450f8d04ea547569ea05--e473d0268737401482c51aff8ee74015 0290b0ea309e4f1fa8bd910af3993cb4 e473d0268737401482c51aff8ee74015--0290b0ea309e4f1fa8bd910af3993cb4 87751c51ff314b6dad5871d385f57de4 0290b0ea309e4f1fa8bd910af3993cb4--87751c51ff314b6dad5871d385f57de4 be17bd202e9342d5a6963a43982ac2d3 87751c51ff314b6dad5871d385f57de4--be17bd202e9342d5a6963a43982ac2d3 230dfa46b7cc49c994fe034f313b3f07 be17bd202e9342d5a6963a43982ac2d3--230dfa46b7cc49c994fe034f313b3f07 a1a21a4c902d479cb3381138e38ef4b0 230dfa46b7cc49c994fe034f313b3f07--a1a21a4c902d479cb3381138e38ef4b0 dbef006441fe4557a3592c5732c21af4 a1a21a4c902d479cb3381138e38ef4b0--dbef006441fe4557a3592c5732c21af4 0980cf32b1c74251923177c14f9dac69 dbef006441fe4557a3592c5732c21af4--0980cf32b1c74251923177c14f9dac69 527149b0ef9246b3ad49b10e955455e1 0980cf32b1c74251923177c14f9dac69--527149b0ef9246b3ad49b10e955455e1 c2e1aa69ea79491f98211c6e7d017a35 527149b0ef9246b3ad49b10e955455e1--c2e1aa69ea79491f98211c6e7d017a35 2f0b4ff5a769450a9d59a1f3f6186433 c2e1aa69ea79491f98211c6e7d017a35--2f0b4ff5a769450a9d59a1f3f6186433 0d1931eea8f44624b3323bd274e8a74b 2f0b4ff5a769450a9d59a1f3f6186433--0d1931eea8f44624b3323bd274e8a74b 4cefa0639838494a9716480a42c9b7aa 0d1931eea8f44624b3323bd274e8a74b--4cefa0639838494a9716480a42c9b7aa a633ae61c7b2446cab31769cacf7621c 4cefa0639838494a9716480a42c9b7aa--a633ae61c7b2446cab31769cacf7621c 2f519e0f838e4d84904d74c5fb6b95df a633ae61c7b2446cab31769cacf7621c--2f519e0f838e4d84904d74c5fb6b95df 84ae069f834b4f54b156087166e04566 2f519e0f838e4d84904d74c5fb6b95df--84ae069f834b4f54b156087166e04566 71a0b619289b499ebf8c93ee98c8f81e 84ae069f834b4f54b156087166e04566--71a0b619289b499ebf8c93ee98c8f81e 62ec3fc7d4874494925b28c205313a36 71a0b619289b499ebf8c93ee98c8f81e--62ec3fc7d4874494925b28c205313a36 4e674b070a684ef7addafe489de23fff 62ec3fc7d4874494925b28c205313a36--4e674b070a684ef7addafe489de23fff 717f2380cb8f4d91823222a791272b5a 4e674b070a684ef7addafe489de23fff--717f2380cb8f4d91823222a791272b5a 3723f6969a9b4bf0a2b38eea081f88e5 717f2380cb8f4d91823222a791272b5a--3723f6969a9b4bf0a2b38eea081f88e5 62e6cab5b5304c6e8006e6955019cf4b 3723f6969a9b4bf0a2b38eea081f88e5--62e6cab5b5304c6e8006e6955019cf4b f4b31b0c580245088663f3d476927222 62e6cab5b5304c6e8006e6955019cf4b--f4b31b0c580245088663f3d476927222 7f0850318c184a91be073f9ad50c76a1 f4b31b0c580245088663f3d476927222--7f0850318c184a91be073f9ad50c76a1 75fb3505ac764705876961d84a1ebdb4 7f0850318c184a91be073f9ad50c76a1--75fb3505ac764705876961d84a1ebdb4 865d255022174ce889788969e872f017 75fb3505ac764705876961d84a1ebdb4--865d255022174ce889788969e872f017 9f77ca64454f4231b53e104fcd5868db 865d255022174ce889788969e872f017--9f77ca64454f4231b53e104fcd5868db f53c4a1af7a343348024ae18880d0acb 9f77ca64454f4231b53e104fcd5868db--f53c4a1af7a343348024ae18880d0acb 7dcb4e79e08e4523a5122abd37883266 f53c4a1af7a343348024ae18880d0acb--7dcb4e79e08e4523a5122abd37883266 6d34df01b68d4d55941cc09270d90d5d 7dcb4e79e08e4523a5122abd37883266--6d34df01b68d4d55941cc09270d90d5d 9acec24511314622814399d3111da042 6d34df01b68d4d55941cc09270d90d5d--9acec24511314622814399d3111da042 62608d5cb84941aaa294d25d8f57d80c 9acec24511314622814399d3111da042--62608d5cb84941aaa294d25d8f57d80c d911da02e87942ddb26be49b8d9289e4 62608d5cb84941aaa294d25d8f57d80c--d911da02e87942ddb26be49b8d9289e4 c6bcfdc057e6452cb2708c681cf02d0e d911da02e87942ddb26be49b8d9289e4--c6bcfdc057e6452cb2708c681cf02d0e b545da4abfc7480b9fb4ccf4a6adc364 c6bcfdc057e6452cb2708c681cf02d0e--b545da4abfc7480b9fb4ccf4a6adc364 7da9b340c33d4bd482ee54b86e99fa8b b545da4abfc7480b9fb4ccf4a6adc364--7da9b340c33d4bd482ee54b86e99fa8b ce69afd93a2b4e08ac57b1aee55ff646 RX(b10) 7da9b340c33d4bd482ee54b86e99fa8b--ce69afd93a2b4e08ac57b1aee55ff646 18a5299f39084715920c7f327cfe7669 ce69afd93a2b4e08ac57b1aee55ff646--18a5299f39084715920c7f327cfe7669 4b5d69cfbb5449259b88f4cbf1a8d74f e4b9eda0c3b34d909fb0d42d1cf15e6d X bb977b2ee6004d19a9d310c7699bcde2--e4b9eda0c3b34d909fb0d42d1cf15e6d 90ad62f3be714db48b1c93917fd9a6f6 2 e4b9eda0c3b34d909fb0d42d1cf15e6d--c53ad343faca4c2b95a1088a8a4ee2bf f9170e413146475686bd7c73d627fb05 e4b9eda0c3b34d909fb0d42d1cf15e6d--f9170e413146475686bd7c73d627fb05 32c5a6d26aec4aacbea83c120e195ad4 f9170e413146475686bd7c73d627fb05--32c5a6d26aec4aacbea83c120e195ad4 d0fb884d9d0c421d913540565553fd0f 32c5a6d26aec4aacbea83c120e195ad4--d0fb884d9d0c421d913540565553fd0f 2bb17a3ff2a24b5cbd2081d24164beda d0fb884d9d0c421d913540565553fd0f--2bb17a3ff2a24b5cbd2081d24164beda 26deed2c7f134c5ca5151579b962cc7c 2bb17a3ff2a24b5cbd2081d24164beda--26deed2c7f134c5ca5151579b962cc7c acb5224d405048a8b1104d6ac17a45fc 26deed2c7f134c5ca5151579b962cc7c--acb5224d405048a8b1104d6ac17a45fc d176a4fdcc8a4fd9a0e60c966a6f939f acb5224d405048a8b1104d6ac17a45fc--d176a4fdcc8a4fd9a0e60c966a6f939f fcfa535a0b7f481dbab6da4e51958a8c d176a4fdcc8a4fd9a0e60c966a6f939f--fcfa535a0b7f481dbab6da4e51958a8c 1622fe657a344d65b3b5ab15518de38d fcfa535a0b7f481dbab6da4e51958a8c--1622fe657a344d65b3b5ab15518de38d 5041902a2cc14e70aaf9689188ee14b5 1622fe657a344d65b3b5ab15518de38d--5041902a2cc14e70aaf9689188ee14b5 47b747b8a8914f32be7d0d7e0b61982e 5041902a2cc14e70aaf9689188ee14b5--47b747b8a8914f32be7d0d7e0b61982e dd111b5399234c1aa6cc514b24014e11 47b747b8a8914f32be7d0d7e0b61982e--dd111b5399234c1aa6cc514b24014e11 df0b5e8143a94b26911b68150c8e5ee6 dd111b5399234c1aa6cc514b24014e11--df0b5e8143a94b26911b68150c8e5ee6 212921f8b55b4d23a514c21bebe57c31 X df0b5e8143a94b26911b68150c8e5ee6--212921f8b55b4d23a514c21bebe57c31 212921f8b55b4d23a514c21bebe57c31--3a9e79a5793942a6a64ef49b5cf5f6af 3443f40ae5e9403ca52226b70e84c30d X 212921f8b55b4d23a514c21bebe57c31--3443f40ae5e9403ca52226b70e84c30d 3443f40ae5e9403ca52226b70e84c30d--a129ef9cd25f410abd326443ea023f1f d0c567ee48ea4b67a2f5003b8609a75b 3443f40ae5e9403ca52226b70e84c30d--d0c567ee48ea4b67a2f5003b8609a75b ee4aab58f32f4210842205484f5e2779 d0c567ee48ea4b67a2f5003b8609a75b--ee4aab58f32f4210842205484f5e2779 d69b828649244a56a1bd5ceceb03dcda ee4aab58f32f4210842205484f5e2779--d69b828649244a56a1bd5ceceb03dcda 53506be2af7a406b873a6eca422128a7 d69b828649244a56a1bd5ceceb03dcda--53506be2af7a406b873a6eca422128a7 17985a677f2945beb837c01169391d11 53506be2af7a406b873a6eca422128a7--17985a677f2945beb837c01169391d11 b2326ad6673646abba15ff98bdddb263 17985a677f2945beb837c01169391d11--b2326ad6673646abba15ff98bdddb263 843e2695f6f1445683fdf331ea34dae4 b2326ad6673646abba15ff98bdddb263--843e2695f6f1445683fdf331ea34dae4 7279955ea580498bbd3b957fd682e7b5 843e2695f6f1445683fdf331ea34dae4--7279955ea580498bbd3b957fd682e7b5 38718918db204b36bee0cb5f784574dd 7279955ea580498bbd3b957fd682e7b5--38718918db204b36bee0cb5f784574dd 4079f5570bcc4ed9a0a4132b224da2d7 38718918db204b36bee0cb5f784574dd--4079f5570bcc4ed9a0a4132b224da2d7 6d9359d5e2fe49a1bbb91130ee423405 4079f5570bcc4ed9a0a4132b224da2d7--6d9359d5e2fe49a1bbb91130ee423405 ca3376b0461c40afb07e457f2a1490d0 X 6d9359d5e2fe49a1bbb91130ee423405--ca3376b0461c40afb07e457f2a1490d0 ca3376b0461c40afb07e457f2a1490d0--89a7e903aaa7499a836d3ad6e581a9d2 68692c8a4bdd46108c152b79b66e2518 X ca3376b0461c40afb07e457f2a1490d0--68692c8a4bdd46108c152b79b66e2518 68692c8a4bdd46108c152b79b66e2518--109ce4b6552c4f8b879bda974bcd337f 5d8786128f3f4017b5eabdfb19e50ef7 68692c8a4bdd46108c152b79b66e2518--5d8786128f3f4017b5eabdfb19e50ef7 e22ee0b34cd0481d9020415f85a60f2c 5d8786128f3f4017b5eabdfb19e50ef7--e22ee0b34cd0481d9020415f85a60f2c 11c72b7b3af346fc98fbe753e7e8af27 e22ee0b34cd0481d9020415f85a60f2c--11c72b7b3af346fc98fbe753e7e8af27 126133c248364715b9c09890af1ef836 11c72b7b3af346fc98fbe753e7e8af27--126133c248364715b9c09890af1ef836 e0e0b5be4809470991049296f38b496f 126133c248364715b9c09890af1ef836--e0e0b5be4809470991049296f38b496f eb7f7224b7b6489db829ade499d1ae18 e0e0b5be4809470991049296f38b496f--eb7f7224b7b6489db829ade499d1ae18 df277e400d434a96b6f0a49593af475e eb7f7224b7b6489db829ade499d1ae18--df277e400d434a96b6f0a49593af475e 391991d0958644baac51ceb05c3df8e8 df277e400d434a96b6f0a49593af475e--391991d0958644baac51ceb05c3df8e8 564cfb74a6e448319678f82c87fbc886 391991d0958644baac51ceb05c3df8e8--564cfb74a6e448319678f82c87fbc886 d9861ab57e1348a5bdcf24a09bd357b6 564cfb74a6e448319678f82c87fbc886--d9861ab57e1348a5bdcf24a09bd357b6 4707aecc71264b7199bc36bba1579118 d9861ab57e1348a5bdcf24a09bd357b6--4707aecc71264b7199bc36bba1579118 a011193bb04649febcc8998d4ee0d92b 4707aecc71264b7199bc36bba1579118--a011193bb04649febcc8998d4ee0d92b f6ce72caf7dc4cceb34a53d355c87ff0 a011193bb04649febcc8998d4ee0d92b--f6ce72caf7dc4cceb34a53d355c87ff0 dec43128b42c427e94c425586817dab7 X f6ce72caf7dc4cceb34a53d355c87ff0--dec43128b42c427e94c425586817dab7 dec43128b42c427e94c425586817dab7--3c64e10fd9b54326b984dd7b78f8c319 631713ec34fd4f86b670cd6d360e938f dec43128b42c427e94c425586817dab7--631713ec34fd4f86b670cd6d360e938f 61d4fe07ff804ffa900bafb068109b8f 631713ec34fd4f86b670cd6d360e938f--61d4fe07ff804ffa900bafb068109b8f 3993f39f4f8f4216adc9db04fdc5d35f 61d4fe07ff804ffa900bafb068109b8f--3993f39f4f8f4216adc9db04fdc5d35f daaf6d040ad54c4c898fa39442edc463 3993f39f4f8f4216adc9db04fdc5d35f--daaf6d040ad54c4c898fa39442edc463 ea90a6cb67d742b3a4ca4603a324f536 daaf6d040ad54c4c898fa39442edc463--ea90a6cb67d742b3a4ca4603a324f536 18febfc9ba684613a65913a81586ea2a ea90a6cb67d742b3a4ca4603a324f536--18febfc9ba684613a65913a81586ea2a 0cad6d8313dd4429afdf703a943d7874 18febfc9ba684613a65913a81586ea2a--0cad6d8313dd4429afdf703a943d7874 eb69d92ecd874133a89a684ee92e2df4 0cad6d8313dd4429afdf703a943d7874--eb69d92ecd874133a89a684ee92e2df4 52904392e39a46e2a329c70b18c11945 eb69d92ecd874133a89a684ee92e2df4--52904392e39a46e2a329c70b18c11945 22745f20af1344c1a1d345217028d43f 52904392e39a46e2a329c70b18c11945--22745f20af1344c1a1d345217028d43f 8be8ed01797f49bdb22fce749d31ef5b 22745f20af1344c1a1d345217028d43f--8be8ed01797f49bdb22fce749d31ef5b dc273dc2c39a43c1b1f4624c50f56812 8be8ed01797f49bdb22fce749d31ef5b--dc273dc2c39a43c1b1f4624c50f56812 1c8a7f5e942f44fc8b5c23d8982e06f3 dc273dc2c39a43c1b1f4624c50f56812--1c8a7f5e942f44fc8b5c23d8982e06f3 760f3f70ba4d4b27ab56093661111d52 1c8a7f5e942f44fc8b5c23d8982e06f3--760f3f70ba4d4b27ab56093661111d52 8d793997f82841eda30bde6e880d7f8c 760f3f70ba4d4b27ab56093661111d52--8d793997f82841eda30bde6e880d7f8c f28f21ee5087458ca9e838b6980048f3 8d793997f82841eda30bde6e880d7f8c--f28f21ee5087458ca9e838b6980048f3 b15b016e4ac84191afa209c79368121e f28f21ee5087458ca9e838b6980048f3--b15b016e4ac84191afa209c79368121e 677ef8666acf414c9091c4155761e7d5 b15b016e4ac84191afa209c79368121e--677ef8666acf414c9091c4155761e7d5 0958c81dd2614bbdb47bf45ee1c0cedc 677ef8666acf414c9091c4155761e7d5--0958c81dd2614bbdb47bf45ee1c0cedc e6981363caad48f9bc850cd78e127c9c 0958c81dd2614bbdb47bf45ee1c0cedc--e6981363caad48f9bc850cd78e127c9c 2eb361eca8524b1e98723364453c993a e6981363caad48f9bc850cd78e127c9c--2eb361eca8524b1e98723364453c993a 24f5b93b20b546ed8fb5dc6d493c2447 2eb361eca8524b1e98723364453c993a--24f5b93b20b546ed8fb5dc6d493c2447 fd268198c721488b870bd7223cff7114 24f5b93b20b546ed8fb5dc6d493c2447--fd268198c721488b870bd7223cff7114 c4b5486cb3764b719d8a659b22845e9d fd268198c721488b870bd7223cff7114--c4b5486cb3764b719d8a659b22845e9d c60abe1a08f34a7d8d1d6ba29d4c7239 c4b5486cb3764b719d8a659b22845e9d--c60abe1a08f34a7d8d1d6ba29d4c7239 29ab44ed44ee4bbbb132c9982c6680de c60abe1a08f34a7d8d1d6ba29d4c7239--29ab44ed44ee4bbbb132c9982c6680de fcf245938fa944a39663c34f5721c408 29ab44ed44ee4bbbb132c9982c6680de--fcf245938fa944a39663c34f5721c408 5124e68340bb43c5a220eae2237526b2 fcf245938fa944a39663c34f5721c408--5124e68340bb43c5a220eae2237526b2 6c42a1c70d2b40bd8f663a7c31d0eb9c 5124e68340bb43c5a220eae2237526b2--6c42a1c70d2b40bd8f663a7c31d0eb9c fa591389ca454e3884b00826f7288beb 6c42a1c70d2b40bd8f663a7c31d0eb9c--fa591389ca454e3884b00826f7288beb 1dd2112439584428b65554295c1f57f2 fa591389ca454e3884b00826f7288beb--1dd2112439584428b65554295c1f57f2 321807a926e048fda92ddd939d0d2f89 1dd2112439584428b65554295c1f57f2--321807a926e048fda92ddd939d0d2f89 2068d69c26a74b9bb02de3bed29a014f 321807a926e048fda92ddd939d0d2f89--2068d69c26a74b9bb02de3bed29a014f b1e70a4f3d904e93baf0c6040d0b8d7f 2068d69c26a74b9bb02de3bed29a014f--b1e70a4f3d904e93baf0c6040d0b8d7f acc98bef12294e1999f0848587929071 b1e70a4f3d904e93baf0c6040d0b8d7f--acc98bef12294e1999f0848587929071 d44b9401659d4287a4bb98aa4b0c5b07 acc98bef12294e1999f0848587929071--d44b9401659d4287a4bb98aa4b0c5b07 114eddea11c84dea95ba0f0b38ea3635 d44b9401659d4287a4bb98aa4b0c5b07--114eddea11c84dea95ba0f0b38ea3635 43d1dfa83768438fb77d32fcee5de24f 114eddea11c84dea95ba0f0b38ea3635--43d1dfa83768438fb77d32fcee5de24f 3b4313e2139c48bcb4efbb444308f67f 43d1dfa83768438fb77d32fcee5de24f--3b4313e2139c48bcb4efbb444308f67f 983a4742452c481bad3b2afbb06d954b 3b4313e2139c48bcb4efbb444308f67f--983a4742452c481bad3b2afbb06d954b a14f21192778486f95c6b4adbd1572d8 983a4742452c481bad3b2afbb06d954b--a14f21192778486f95c6b4adbd1572d8 fa4542087cf94a8298913dbccca73a38 a14f21192778486f95c6b4adbd1572d8--fa4542087cf94a8298913dbccca73a38 1433dfcc7821468789474fd3bbf92b54 fa4542087cf94a8298913dbccca73a38--1433dfcc7821468789474fd3bbf92b54 ab7608f26c7d4551950adca39de499ac 1433dfcc7821468789474fd3bbf92b54--ab7608f26c7d4551950adca39de499ac 0cac83fb6e6446fdb7b06698cc560458 ab7608f26c7d4551950adca39de499ac--0cac83fb6e6446fdb7b06698cc560458 027fdd7bdd9b441c82518170db8cadef 0cac83fb6e6446fdb7b06698cc560458--027fdd7bdd9b441c82518170db8cadef d8c95af816f74247ab92f66b8cca7a45 027fdd7bdd9b441c82518170db8cadef--d8c95af816f74247ab92f66b8cca7a45 8146aa11ab1d4a9e96417a2eff15a458 d8c95af816f74247ab92f66b8cca7a45--8146aa11ab1d4a9e96417a2eff15a458 893e72a5c10f41e3bb55751b992e3a18 8146aa11ab1d4a9e96417a2eff15a458--893e72a5c10f41e3bb55751b992e3a18 7ae0676806424c859a1d5b8c6711200a 893e72a5c10f41e3bb55751b992e3a18--7ae0676806424c859a1d5b8c6711200a 31a223d42a5d40b5bc9437088f3cd4a6 7ae0676806424c859a1d5b8c6711200a--31a223d42a5d40b5bc9437088f3cd4a6 98cd7cd1e6ae4458818d0ef9bdda04e5 31a223d42a5d40b5bc9437088f3cd4a6--98cd7cd1e6ae4458818d0ef9bdda04e5 ddcffcc878774707b0f111748671b230 98cd7cd1e6ae4458818d0ef9bdda04e5--ddcffcc878774707b0f111748671b230 30230086ba7446f895b0c809b895e0f3 ddcffcc878774707b0f111748671b230--30230086ba7446f895b0c809b895e0f3 fac30e78bb0e4335aa226c5439ba1635 30230086ba7446f895b0c809b895e0f3--fac30e78bb0e4335aa226c5439ba1635 d7ece410f92046d78e6c1585d7449bac fac30e78bb0e4335aa226c5439ba1635--d7ece410f92046d78e6c1585d7449bac d67e4016f9b64edeb48804e876755c92 d7ece410f92046d78e6c1585d7449bac--d67e4016f9b64edeb48804e876755c92 73c721bb46094413ab3db887d9a09b02 d67e4016f9b64edeb48804e876755c92--73c721bb46094413ab3db887d9a09b02 b564787a89bd4ddb82e5f5a5a38613fc 73c721bb46094413ab3db887d9a09b02--b564787a89bd4ddb82e5f5a5a38613fc b4db6c7403144dd687b8ef6115fe8ccf b564787a89bd4ddb82e5f5a5a38613fc--b4db6c7403144dd687b8ef6115fe8ccf bc8c776e3a69456d841ef433f6324bd9 b4db6c7403144dd687b8ef6115fe8ccf--bc8c776e3a69456d841ef433f6324bd9 cfe2f459fcc244a689bc36c4c847606d RX(b01) bc8c776e3a69456d841ef433f6324bd9--cfe2f459fcc244a689bc36c4c847606d 436b3e2ac04f47f89047efc13c4a8675 X cfe2f459fcc244a689bc36c4c847606d--436b3e2ac04f47f89047efc13c4a8675 436b3e2ac04f47f89047efc13c4a8675--eada6ada4def430093f161c44a1db355 70aae49921f24d008edbe61aa38d0eea 436b3e2ac04f47f89047efc13c4a8675--70aae49921f24d008edbe61aa38d0eea 25bbeb90f09245e2a92cb33c1da95c4a 70aae49921f24d008edbe61aa38d0eea--25bbeb90f09245e2a92cb33c1da95c4a 5c155e2524d6441ca69e90276e87de5e 25bbeb90f09245e2a92cb33c1da95c4a--5c155e2524d6441ca69e90276e87de5e abb2c4e6ba4244dfacb3ad55423d5fae 5c155e2524d6441ca69e90276e87de5e--abb2c4e6ba4244dfacb3ad55423d5fae 054a1ac6a80e479a8adefacb1fc52712 abb2c4e6ba4244dfacb3ad55423d5fae--054a1ac6a80e479a8adefacb1fc52712 86dd02bf49be4f0e93bca63d0ffcf655 054a1ac6a80e479a8adefacb1fc52712--86dd02bf49be4f0e93bca63d0ffcf655 8a6e281806ba46af94c177dbd256954f 86dd02bf49be4f0e93bca63d0ffcf655--8a6e281806ba46af94c177dbd256954f c1e41e6390fe47bab88032de0bf937db 8a6e281806ba46af94c177dbd256954f--c1e41e6390fe47bab88032de0bf937db 199187f1a6084f2281dde0510425c216 c1e41e6390fe47bab88032de0bf937db--199187f1a6084f2281dde0510425c216 3cf5a2073b3e497bb19c542b9f70a0f2 199187f1a6084f2281dde0510425c216--3cf5a2073b3e497bb19c542b9f70a0f2 71198f01920e492da5dca949b50483e6 3cf5a2073b3e497bb19c542b9f70a0f2--71198f01920e492da5dca949b50483e6 80426d6a18af4777a70c9ec0910c8f19 71198f01920e492da5dca949b50483e6--80426d6a18af4777a70c9ec0910c8f19 84ec1e4a47b146b1a02601e0cf248294 80426d6a18af4777a70c9ec0910c8f19--84ec1e4a47b146b1a02601e0cf248294 ad1e4898fbaa4d83b131415a2c327bd1 X 84ec1e4a47b146b1a02601e0cf248294--ad1e4898fbaa4d83b131415a2c327bd1 ad1e4898fbaa4d83b131415a2c327bd1--a3a8f5d216e74b43aa069f9fb0f866e5 36c8c1ee2d7d4b438136b67396d5d987 X ad1e4898fbaa4d83b131415a2c327bd1--36c8c1ee2d7d4b438136b67396d5d987 36c8c1ee2d7d4b438136b67396d5d987--68741af5c30f4889869e92fa683b8b08 034026e3f0ff40779482e8241ea3a967 36c8c1ee2d7d4b438136b67396d5d987--034026e3f0ff40779482e8241ea3a967 f8e405d233b94f119ceeaf82ba8e236d 034026e3f0ff40779482e8241ea3a967--f8e405d233b94f119ceeaf82ba8e236d 2ba30e6f915241c1897f6b3e2f020769 f8e405d233b94f119ceeaf82ba8e236d--2ba30e6f915241c1897f6b3e2f020769 825b57e1eda54aceba7d14d97dbcf79e 2ba30e6f915241c1897f6b3e2f020769--825b57e1eda54aceba7d14d97dbcf79e da61d254762b442bab5263532210a335 825b57e1eda54aceba7d14d97dbcf79e--da61d254762b442bab5263532210a335 57a25a0b54bb4a2bbb8e829e1d8c46ea da61d254762b442bab5263532210a335--57a25a0b54bb4a2bbb8e829e1d8c46ea 83bc29a92da0436aa741a721450b0da8 57a25a0b54bb4a2bbb8e829e1d8c46ea--83bc29a92da0436aa741a721450b0da8 4eae71b1e901479fa93956fae7b1735f 83bc29a92da0436aa741a721450b0da8--4eae71b1e901479fa93956fae7b1735f 5c86cabc3a4148ccb45789dd27f33192 4eae71b1e901479fa93956fae7b1735f--5c86cabc3a4148ccb45789dd27f33192 6ae4fbd0199444a9ac016d46958a17e5 5c86cabc3a4148ccb45789dd27f33192--6ae4fbd0199444a9ac016d46958a17e5 bbf61c3d54e142ada168b27194b6f278 6ae4fbd0199444a9ac016d46958a17e5--bbf61c3d54e142ada168b27194b6f278 b88ccfc4716f445dbfc887338a323907 X bbf61c3d54e142ada168b27194b6f278--b88ccfc4716f445dbfc887338a323907 b88ccfc4716f445dbfc887338a323907--371f8ca3f3864e5c8ca02293b57a72ee d2651eca9d75444caa8729a777ee093f X b88ccfc4716f445dbfc887338a323907--d2651eca9d75444caa8729a777ee093f d2651eca9d75444caa8729a777ee093f--a57abeeb34d94c07ab7b387989ddf200 adad04db3d5d45f89ad1a9c359c9286e d2651eca9d75444caa8729a777ee093f--adad04db3d5d45f89ad1a9c359c9286e 03faad439fa64fd385a6bebb34f88b8a adad04db3d5d45f89ad1a9c359c9286e--03faad439fa64fd385a6bebb34f88b8a 537310b5511646b1afe4519bffce8dd0 03faad439fa64fd385a6bebb34f88b8a--537310b5511646b1afe4519bffce8dd0 ebc5ccc87c85472b8c208868354292a8 537310b5511646b1afe4519bffce8dd0--ebc5ccc87c85472b8c208868354292a8 dcea4763e74349009b2854dd40803d4f ebc5ccc87c85472b8c208868354292a8--dcea4763e74349009b2854dd40803d4f 8d086bfca8104238a4246bc1e7a29d1e dcea4763e74349009b2854dd40803d4f--8d086bfca8104238a4246bc1e7a29d1e 5f568601507a4b37b1f49bb0aa0303ab 8d086bfca8104238a4246bc1e7a29d1e--5f568601507a4b37b1f49bb0aa0303ab 5b92ff9508104a52a64e89916fe9f8c8 5f568601507a4b37b1f49bb0aa0303ab--5b92ff9508104a52a64e89916fe9f8c8 26616919527448e98b1a313cceba6c7c 5b92ff9508104a52a64e89916fe9f8c8--26616919527448e98b1a313cceba6c7c 92bd43eb5aaa49da8eb2462c3308c0bd 26616919527448e98b1a313cceba6c7c--92bd43eb5aaa49da8eb2462c3308c0bd f250123434e24f7b94333a1b7c6a9053 92bd43eb5aaa49da8eb2462c3308c0bd--f250123434e24f7b94333a1b7c6a9053 4c825e2c480a4e7d9b88e70155c1c47b f250123434e24f7b94333a1b7c6a9053--4c825e2c480a4e7d9b88e70155c1c47b 55774c6064d943f8b7712c9bdcc85ddc 4c825e2c480a4e7d9b88e70155c1c47b--55774c6064d943f8b7712c9bdcc85ddc 6bf92dc454e24e448c0e7feafc7ab295 X 55774c6064d943f8b7712c9bdcc85ddc--6bf92dc454e24e448c0e7feafc7ab295 6bf92dc454e24e448c0e7feafc7ab295--18a5aa38814f46e2a943bf636aece16c 4bd865c1965b4490b77963b0f95eea72 6bf92dc454e24e448c0e7feafc7ab295--4bd865c1965b4490b77963b0f95eea72 85f032c0b3b44f4c89564512c361a30f 4bd865c1965b4490b77963b0f95eea72--85f032c0b3b44f4c89564512c361a30f c814dbff258942c1b292d8894077a279 85f032c0b3b44f4c89564512c361a30f--c814dbff258942c1b292d8894077a279 af7707a1144f47dabf522e37252389a1 c814dbff258942c1b292d8894077a279--af7707a1144f47dabf522e37252389a1 562b35f14ea6438785ffb1c792b0fdc2 af7707a1144f47dabf522e37252389a1--562b35f14ea6438785ffb1c792b0fdc2 e7af1d6cc5e348adb8facbc404eddd9d 562b35f14ea6438785ffb1c792b0fdc2--e7af1d6cc5e348adb8facbc404eddd9d 2cc0d964cfec460aab592bf5316e8769 e7af1d6cc5e348adb8facbc404eddd9d--2cc0d964cfec460aab592bf5316e8769 2ce3697009994ced9b797a6d25c51129 2cc0d964cfec460aab592bf5316e8769--2ce3697009994ced9b797a6d25c51129 c3a14db2cdc74a18bebc4f8ca0b5a667 2ce3697009994ced9b797a6d25c51129--c3a14db2cdc74a18bebc4f8ca0b5a667 b66ac85bad9c4ef4adb50cf7088f2c5a c3a14db2cdc74a18bebc4f8ca0b5a667--b66ac85bad9c4ef4adb50cf7088f2c5a 6db7f4741cf6420e816bd50008edfe42 b66ac85bad9c4ef4adb50cf7088f2c5a--6db7f4741cf6420e816bd50008edfe42 1d8ec3d20bea4344845b2ad23516c10f 6db7f4741cf6420e816bd50008edfe42--1d8ec3d20bea4344845b2ad23516c10f 33c3a8b81a6443a983f480c23ba7b868 1d8ec3d20bea4344845b2ad23516c10f--33c3a8b81a6443a983f480c23ba7b868 ec04f70d733c4bc990cbb28dc34ee939 33c3a8b81a6443a983f480c23ba7b868--ec04f70d733c4bc990cbb28dc34ee939 7e42b3556e92420db728f1aa1c1e1681 ec04f70d733c4bc990cbb28dc34ee939--7e42b3556e92420db728f1aa1c1e1681 d9462860452745d594d7e1d1435977c8 7e42b3556e92420db728f1aa1c1e1681--d9462860452745d594d7e1d1435977c8 7c0cc3b80da74198a3400b428b804390 d9462860452745d594d7e1d1435977c8--7c0cc3b80da74198a3400b428b804390 a7f8ad9c358243eabcbdfc574df72a25 7c0cc3b80da74198a3400b428b804390--a7f8ad9c358243eabcbdfc574df72a25 984522d766924639a07d3c1b78761f99 a7f8ad9c358243eabcbdfc574df72a25--984522d766924639a07d3c1b78761f99 91772cb3e6014824a965adaaf66b16cd 984522d766924639a07d3c1b78761f99--91772cb3e6014824a965adaaf66b16cd 56890329c8b14c689dda97c704f97b19 91772cb3e6014824a965adaaf66b16cd--56890329c8b14c689dda97c704f97b19 0aab99be06e54d6590dcc11cd6648605 56890329c8b14c689dda97c704f97b19--0aab99be06e54d6590dcc11cd6648605 52e2337b9d384392b02b18d857e3208d 0aab99be06e54d6590dcc11cd6648605--52e2337b9d384392b02b18d857e3208d 421728fd9bb345e3952e2d34dfaef490 52e2337b9d384392b02b18d857e3208d--421728fd9bb345e3952e2d34dfaef490 63e4c816e7c04eb59102eacf0dacbe92 421728fd9bb345e3952e2d34dfaef490--63e4c816e7c04eb59102eacf0dacbe92 cde35f5a616045808bc9317c2875538c 63e4c816e7c04eb59102eacf0dacbe92--cde35f5a616045808bc9317c2875538c f297c323950a4bc3a1f902caccc7f7f1 cde35f5a616045808bc9317c2875538c--f297c323950a4bc3a1f902caccc7f7f1 ee4c2b56dc0a48ddb113ed499bf1054d f297c323950a4bc3a1f902caccc7f7f1--ee4c2b56dc0a48ddb113ed499bf1054d 924a5e27dde7486aa2918d7761b145c8 ee4c2b56dc0a48ddb113ed499bf1054d--924a5e27dde7486aa2918d7761b145c8 cc4d01f0234f4363875267f2ec62b42f 924a5e27dde7486aa2918d7761b145c8--cc4d01f0234f4363875267f2ec62b42f 8b0e38483c374a2485593f4360b75b4d cc4d01f0234f4363875267f2ec62b42f--8b0e38483c374a2485593f4360b75b4d e0c2dc0d6d7d456593fe360c660e9329 8b0e38483c374a2485593f4360b75b4d--e0c2dc0d6d7d456593fe360c660e9329 473aad9c106d442fa0003543d0cdb424 e0c2dc0d6d7d456593fe360c660e9329--473aad9c106d442fa0003543d0cdb424 b60f08e2c21d4eb4b23579e3ac356734 473aad9c106d442fa0003543d0cdb424--b60f08e2c21d4eb4b23579e3ac356734 cdf1f3c7b0784879bf4940e18d252b24 b60f08e2c21d4eb4b23579e3ac356734--cdf1f3c7b0784879bf4940e18d252b24 8e70df8a9fd04f5ca712dc115d7928d8 cdf1f3c7b0784879bf4940e18d252b24--8e70df8a9fd04f5ca712dc115d7928d8 a968811a891d4efea742efc966ed7541 8e70df8a9fd04f5ca712dc115d7928d8--a968811a891d4efea742efc966ed7541 0a14301f86f74a8c9999717144555684 a968811a891d4efea742efc966ed7541--0a14301f86f74a8c9999717144555684 16aa9a669a1348f7a57b6774798d70ff 0a14301f86f74a8c9999717144555684--16aa9a669a1348f7a57b6774798d70ff fab94c8fa8c447bba82d57729a6338a9 16aa9a669a1348f7a57b6774798d70ff--fab94c8fa8c447bba82d57729a6338a9 0677c116e9d2473483ffd2ba5b0daa1c fab94c8fa8c447bba82d57729a6338a9--0677c116e9d2473483ffd2ba5b0daa1c eaaf5c77c5d94d3393d4c1f801615036 0677c116e9d2473483ffd2ba5b0daa1c--eaaf5c77c5d94d3393d4c1f801615036 0e4f438fe65d4136864071bf77ecf5c3 eaaf5c77c5d94d3393d4c1f801615036--0e4f438fe65d4136864071bf77ecf5c3 0bedf04096884f3c9cb24051c3256e0b 0e4f438fe65d4136864071bf77ecf5c3--0bedf04096884f3c9cb24051c3256e0b cb231506abde4f4e94e480ed51f98977 0bedf04096884f3c9cb24051c3256e0b--cb231506abde4f4e94e480ed51f98977 bc539412c1ed4ba0b21924671a5085ae cb231506abde4f4e94e480ed51f98977--bc539412c1ed4ba0b21924671a5085ae cef5ab1fb7664c3aa6571d716a5a941d bc539412c1ed4ba0b21924671a5085ae--cef5ab1fb7664c3aa6571d716a5a941d ee0f4077287948f6962f6c9b2364ddc7 cef5ab1fb7664c3aa6571d716a5a941d--ee0f4077287948f6962f6c9b2364ddc7 a1cc3dbf4e4a4988b5826a396562100f ee0f4077287948f6962f6c9b2364ddc7--a1cc3dbf4e4a4988b5826a396562100f b8508dd9a87d476d861f2559465a59dd a1cc3dbf4e4a4988b5826a396562100f--b8508dd9a87d476d861f2559465a59dd fd35666c659f445daae57474d1f1ad5b b8508dd9a87d476d861f2559465a59dd--fd35666c659f445daae57474d1f1ad5b 8fa7fff2ab52440489bf10ba46cb6b60 fd35666c659f445daae57474d1f1ad5b--8fa7fff2ab52440489bf10ba46cb6b60 a6a5ab87784f48c0af04120f780c5d9a 8fa7fff2ab52440489bf10ba46cb6b60--a6a5ab87784f48c0af04120f780c5d9a 20ddc3fd6fb043b38cf5d67d11caa124 a6a5ab87784f48c0af04120f780c5d9a--20ddc3fd6fb043b38cf5d67d11caa124 ccc64fab8ec94231a4a41f6b53bc110f 20ddc3fd6fb043b38cf5d67d11caa124--ccc64fab8ec94231a4a41f6b53bc110f 09bd0b8b16ad42dfb96fa65e182f372c ccc64fab8ec94231a4a41f6b53bc110f--09bd0b8b16ad42dfb96fa65e182f372c 2b98d23b89294d508fe8444b0a533913 09bd0b8b16ad42dfb96fa65e182f372c--2b98d23b89294d508fe8444b0a533913 f5b98e01b08c461c985face68889c07d 2b98d23b89294d508fe8444b0a533913--f5b98e01b08c461c985face68889c07d af39ba5eaa6043b7a648f7a85c55ca08 f5b98e01b08c461c985face68889c07d--af39ba5eaa6043b7a648f7a85c55ca08 63187553c1f84aa9b0987b6442a3a8f0 af39ba5eaa6043b7a648f7a85c55ca08--63187553c1f84aa9b0987b6442a3a8f0 30a3b29b8854421f9462b5663a6d13bf 63187553c1f84aa9b0987b6442a3a8f0--30a3b29b8854421f9462b5663a6d13bf f95a2a02e9724222b61e49e6393bfd46 RX(b11) 30a3b29b8854421f9462b5663a6d13bf--f95a2a02e9724222b61e49e6393bfd46 f95a2a02e9724222b61e49e6393bfd46--4b5d69cfbb5449259b88f4cbf1a8d74f a560ebc6003e4f93b9931a700e91fe0a d07d09287b154b559ff953ca5fbc811e 90ad62f3be714db48b1c93917fd9a6f6--d07d09287b154b559ff953ca5fbc811e 05941205bce0431e88df7c10c5bbec58 3 f44efcc2292849709f621a8f4f04d7a5 X d07d09287b154b559ff953ca5fbc811e--f44efcc2292849709f621a8f4f04d7a5 f44efcc2292849709f621a8f4f04d7a5--f9170e413146475686bd7c73d627fb05 90e88f844821414a8cb06c5b67dd0af4 f44efcc2292849709f621a8f4f04d7a5--90e88f844821414a8cb06c5b67dd0af4 d158b2fff1c1413c8577e25c8f1ca940 90e88f844821414a8cb06c5b67dd0af4--d158b2fff1c1413c8577e25c8f1ca940 35ab8188e81645f989fc8c2f2107b664 d158b2fff1c1413c8577e25c8f1ca940--35ab8188e81645f989fc8c2f2107b664 4e2862a4dc0a468d95ba5489f2597f83 35ab8188e81645f989fc8c2f2107b664--4e2862a4dc0a468d95ba5489f2597f83 0916e0eb479e413ea2411ebf634ca3b6 4e2862a4dc0a468d95ba5489f2597f83--0916e0eb479e413ea2411ebf634ca3b6 655ba7d8cb5a4386abb9b1233a976d31 0916e0eb479e413ea2411ebf634ca3b6--655ba7d8cb5a4386abb9b1233a976d31 d6e6ff159a67429691dc336c0c62d895 655ba7d8cb5a4386abb9b1233a976d31--d6e6ff159a67429691dc336c0c62d895 e41c17a2e09341288669e8c45fa5e42f d6e6ff159a67429691dc336c0c62d895--e41c17a2e09341288669e8c45fa5e42f 3dcc2ebff313487f9aef8244a0da6291 e41c17a2e09341288669e8c45fa5e42f--3dcc2ebff313487f9aef8244a0da6291 7a5bd40cea824217af9220b2aca30957 3dcc2ebff313487f9aef8244a0da6291--7a5bd40cea824217af9220b2aca30957 f0063652361d43d0b880f4738ec82933 7a5bd40cea824217af9220b2aca30957--f0063652361d43d0b880f4738ec82933 2591677d3095474ba3ce721b2336f7d0 X f0063652361d43d0b880f4738ec82933--2591677d3095474ba3ce721b2336f7d0 2591677d3095474ba3ce721b2336f7d0--df0b5e8143a94b26911b68150c8e5ee6 3170ac43f436422885cfb85045f55cff 2591677d3095474ba3ce721b2336f7d0--3170ac43f436422885cfb85045f55cff 9f76d3a54cee4d0ca0223e5abf291c99 3170ac43f436422885cfb85045f55cff--9f76d3a54cee4d0ca0223e5abf291c99 876e23d4f70e4ea2b044dfaa8625d40d X 9f76d3a54cee4d0ca0223e5abf291c99--876e23d4f70e4ea2b044dfaa8625d40d 876e23d4f70e4ea2b044dfaa8625d40d--d0c567ee48ea4b67a2f5003b8609a75b 3fc6ec7c1a01435f8798bf64c8371d50 876e23d4f70e4ea2b044dfaa8625d40d--3fc6ec7c1a01435f8798bf64c8371d50 412cbcfe540f4ec2975a3b5756adc816 3fc6ec7c1a01435f8798bf64c8371d50--412cbcfe540f4ec2975a3b5756adc816 955a4dc1f33d4018805aa52f390fabcc 412cbcfe540f4ec2975a3b5756adc816--955a4dc1f33d4018805aa52f390fabcc 9d9a9d546b614a3aa959bdae220a4e2b 955a4dc1f33d4018805aa52f390fabcc--9d9a9d546b614a3aa959bdae220a4e2b 544eb1f8d1c94782b27b3ab929e63fc1 9d9a9d546b614a3aa959bdae220a4e2b--544eb1f8d1c94782b27b3ab929e63fc1 b2df2e424dfa4805b8355d5a18f45b58 544eb1f8d1c94782b27b3ab929e63fc1--b2df2e424dfa4805b8355d5a18f45b58 4647609847b9482d8352d848c56b2d84 b2df2e424dfa4805b8355d5a18f45b58--4647609847b9482d8352d848c56b2d84 2f4c72d964244f3ebab2ef9235e060d0 4647609847b9482d8352d848c56b2d84--2f4c72d964244f3ebab2ef9235e060d0 22de30bb8fe44dd6b9b9103c4711b358 2f4c72d964244f3ebab2ef9235e060d0--22de30bb8fe44dd6b9b9103c4711b358 ca4690102e5241649fc02cb242e0f6fc X 22de30bb8fe44dd6b9b9103c4711b358--ca4690102e5241649fc02cb242e0f6fc ca4690102e5241649fc02cb242e0f6fc--6d9359d5e2fe49a1bbb91130ee423405 9c9e7a6c3af34223b6529a4614c185d0 ca4690102e5241649fc02cb242e0f6fc--9c9e7a6c3af34223b6529a4614c185d0 2bd4e43f221f48eaab7fca10da0700bb 9c9e7a6c3af34223b6529a4614c185d0--2bd4e43f221f48eaab7fca10da0700bb 6da6ed8f24e74cd3ab9ff4da65e1ef6e X 2bd4e43f221f48eaab7fca10da0700bb--6da6ed8f24e74cd3ab9ff4da65e1ef6e 6da6ed8f24e74cd3ab9ff4da65e1ef6e--5d8786128f3f4017b5eabdfb19e50ef7 9d083b24ba4c40a8930d7dcb77fcaec5 6da6ed8f24e74cd3ab9ff4da65e1ef6e--9d083b24ba4c40a8930d7dcb77fcaec5 91efb9160122420ab9836dd3023ca395 9d083b24ba4c40a8930d7dcb77fcaec5--91efb9160122420ab9836dd3023ca395 2aaacb6688bc445f9b18006ee92bb941 91efb9160122420ab9836dd3023ca395--2aaacb6688bc445f9b18006ee92bb941 6019fbb060a54956ba29bb2a0ca10d6e 2aaacb6688bc445f9b18006ee92bb941--6019fbb060a54956ba29bb2a0ca10d6e 0b181bbbcefb4a9a8b2484a1ceecf0fc 6019fbb060a54956ba29bb2a0ca10d6e--0b181bbbcefb4a9a8b2484a1ceecf0fc 142d750b653c44699d2bc1fb8bd1c5c9 0b181bbbcefb4a9a8b2484a1ceecf0fc--142d750b653c44699d2bc1fb8bd1c5c9 be83b646504048b6898b5e93387854bf 142d750b653c44699d2bc1fb8bd1c5c9--be83b646504048b6898b5e93387854bf 4f188eb1b1374abb89a495c842302c3d be83b646504048b6898b5e93387854bf--4f188eb1b1374abb89a495c842302c3d af8e996819014548aa7671bb3b651fbf 4f188eb1b1374abb89a495c842302c3d--af8e996819014548aa7671bb3b651fbf 7ae07bbb88294c25a91a9e82aa8e75e1 af8e996819014548aa7671bb3b651fbf--7ae07bbb88294c25a91a9e82aa8e75e1 a6122e870c474ba88b534e67314db01e 7ae07bbb88294c25a91a9e82aa8e75e1--a6122e870c474ba88b534e67314db01e b0bdaaa9cb8b42848fe90f96ba37478e X a6122e870c474ba88b534e67314db01e--b0bdaaa9cb8b42848fe90f96ba37478e b0bdaaa9cb8b42848fe90f96ba37478e--f6ce72caf7dc4cceb34a53d355c87ff0 cb0600c7d89a42478335636785c1dc92 b0bdaaa9cb8b42848fe90f96ba37478e--cb0600c7d89a42478335636785c1dc92 b2e0d2be221443d7bda0e4628d665dce X cb0600c7d89a42478335636785c1dc92--b2e0d2be221443d7bda0e4628d665dce b2e0d2be221443d7bda0e4628d665dce--631713ec34fd4f86b670cd6d360e938f 9abf9554c58e42dab893102efa92dd1c b2e0d2be221443d7bda0e4628d665dce--9abf9554c58e42dab893102efa92dd1c 7e71d389c0a3430c826cafba93fc0766 9abf9554c58e42dab893102efa92dd1c--7e71d389c0a3430c826cafba93fc0766 8373c70432c34e7d9c802b6d66c250d1 7e71d389c0a3430c826cafba93fc0766--8373c70432c34e7d9c802b6d66c250d1 62eb50b8a0ec46c084f5683d96ea9359 8373c70432c34e7d9c802b6d66c250d1--62eb50b8a0ec46c084f5683d96ea9359 9f140a30d8e14699b3dbf1b1c84abcd7 62eb50b8a0ec46c084f5683d96ea9359--9f140a30d8e14699b3dbf1b1c84abcd7 a8b97f08371945c186649f4640b5319d 9f140a30d8e14699b3dbf1b1c84abcd7--a8b97f08371945c186649f4640b5319d e39f458962e040b7b5eb7293deeafc66 a8b97f08371945c186649f4640b5319d--e39f458962e040b7b5eb7293deeafc66 0dab31c2030e48fcab62db38d033e06c e39f458962e040b7b5eb7293deeafc66--0dab31c2030e48fcab62db38d033e06c 22927642ed75460fba5154fef02e7b68 0dab31c2030e48fcab62db38d033e06c--22927642ed75460fba5154fef02e7b68 f55ebb18344541e2a25cfc24b96941ac X 22927642ed75460fba5154fef02e7b68--f55ebb18344541e2a25cfc24b96941ac f55ebb18344541e2a25cfc24b96941ac--8be8ed01797f49bdb22fce749d31ef5b 6598606c8547446388f051981cbe3b9e X f55ebb18344541e2a25cfc24b96941ac--6598606c8547446388f051981cbe3b9e 6598606c8547446388f051981cbe3b9e--dc273dc2c39a43c1b1f4624c50f56812 de6d110c0341498285ac4cd23474ef80 6598606c8547446388f051981cbe3b9e--de6d110c0341498285ac4cd23474ef80 ee3614857c604ed1aec2bf01745f14a0 de6d110c0341498285ac4cd23474ef80--ee3614857c604ed1aec2bf01745f14a0 e733d9789cbf4831b77a15d5cc4a8468 ee3614857c604ed1aec2bf01745f14a0--e733d9789cbf4831b77a15d5cc4a8468 35c9ebe526cf4b199d915178c8004b0b e733d9789cbf4831b77a15d5cc4a8468--35c9ebe526cf4b199d915178c8004b0b a496a7227d0c4a169b25030531545cb3 35c9ebe526cf4b199d915178c8004b0b--a496a7227d0c4a169b25030531545cb3 69c2471f83b64bf2a9b21b93ed1d564f a496a7227d0c4a169b25030531545cb3--69c2471f83b64bf2a9b21b93ed1d564f 32b3305cbc9f49b9b565b542fbde8604 69c2471f83b64bf2a9b21b93ed1d564f--32b3305cbc9f49b9b565b542fbde8604 6427ea4b39754a0db4ab470980ee8f4f 32b3305cbc9f49b9b565b542fbde8604--6427ea4b39754a0db4ab470980ee8f4f b7b94bea18a04bbf835e3b4767f74ee8 6427ea4b39754a0db4ab470980ee8f4f--b7b94bea18a04bbf835e3b4767f74ee8 8640b13342e84982b6a3fe2062da23a5 b7b94bea18a04bbf835e3b4767f74ee8--8640b13342e84982b6a3fe2062da23a5 c49b434e3aca4e8da6f991fa21bcecf2 8640b13342e84982b6a3fe2062da23a5--c49b434e3aca4e8da6f991fa21bcecf2 81c239874bc74a6b89efbb4bb4cad0f5 X c49b434e3aca4e8da6f991fa21bcecf2--81c239874bc74a6b89efbb4bb4cad0f5 81c239874bc74a6b89efbb4bb4cad0f5--c4b5486cb3764b719d8a659b22845e9d 941448ff4ed44f43ad0e19459f97529a 81c239874bc74a6b89efbb4bb4cad0f5--941448ff4ed44f43ad0e19459f97529a db32b327d8194e20b23ce879d14288a0 941448ff4ed44f43ad0e19459f97529a--db32b327d8194e20b23ce879d14288a0 4e8971b92b5e4eb3954cf7ce9c28509e db32b327d8194e20b23ce879d14288a0--4e8971b92b5e4eb3954cf7ce9c28509e 87e06020a30e4aa6877d1298289ea4af 4e8971b92b5e4eb3954cf7ce9c28509e--87e06020a30e4aa6877d1298289ea4af 271296731bbf435e9418ba46891240f4 87e06020a30e4aa6877d1298289ea4af--271296731bbf435e9418ba46891240f4 90c6857ff05746448520a17b322750f2 271296731bbf435e9418ba46891240f4--90c6857ff05746448520a17b322750f2 41d5a051ae104cd3bc21d5e0289745dc 90c6857ff05746448520a17b322750f2--41d5a051ae104cd3bc21d5e0289745dc 4a128a541e2147e6b101c5b6ef2091f1 41d5a051ae104cd3bc21d5e0289745dc--4a128a541e2147e6b101c5b6ef2091f1 9a1509fe0dcb4c07af23bfd029cca15e 4a128a541e2147e6b101c5b6ef2091f1--9a1509fe0dcb4c07af23bfd029cca15e 98cb77be69f84fefbf58b1e2f986cf58 9a1509fe0dcb4c07af23bfd029cca15e--98cb77be69f84fefbf58b1e2f986cf58 daa926f4e3c94f9991f772d375c72eec 98cb77be69f84fefbf58b1e2f986cf58--daa926f4e3c94f9991f772d375c72eec 6bb449cfcafe406091279c8d28a8c916 daa926f4e3c94f9991f772d375c72eec--6bb449cfcafe406091279c8d28a8c916 b047f42fc7714b67924bfb6bed7a9ec3 6bb449cfcafe406091279c8d28a8c916--b047f42fc7714b67924bfb6bed7a9ec3 a518c2d8a4cc48729809bb86ea7fc8a5 b047f42fc7714b67924bfb6bed7a9ec3--a518c2d8a4cc48729809bb86ea7fc8a5 02ff772e5a094da9947f30181d30eb9a a518c2d8a4cc48729809bb86ea7fc8a5--02ff772e5a094da9947f30181d30eb9a 81f0f8adcaa54ec281f4fb1eebe4ea82 02ff772e5a094da9947f30181d30eb9a--81f0f8adcaa54ec281f4fb1eebe4ea82 cbabbcff47f445c5b8ed77fb2b788ecf 81f0f8adcaa54ec281f4fb1eebe4ea82--cbabbcff47f445c5b8ed77fb2b788ecf e42dd90e61cd43009cf63b9be09390f6 cbabbcff47f445c5b8ed77fb2b788ecf--e42dd90e61cd43009cf63b9be09390f6 d06ee89ca64247af89be7a40e294e753 e42dd90e61cd43009cf63b9be09390f6--d06ee89ca64247af89be7a40e294e753 0044339fa82e470c96e32742ec4ff6f2 d06ee89ca64247af89be7a40e294e753--0044339fa82e470c96e32742ec4ff6f2 6a15bec159c54317886bada13dc99ee8 0044339fa82e470c96e32742ec4ff6f2--6a15bec159c54317886bada13dc99ee8 09e745df8f3547d9b32b5d1137d1cea8 6a15bec159c54317886bada13dc99ee8--09e745df8f3547d9b32b5d1137d1cea8 6191b2149f6d4d749284f5c3aa8b339c 09e745df8f3547d9b32b5d1137d1cea8--6191b2149f6d4d749284f5c3aa8b339c 8adf7df807c242f8bfff8edade18b2a6 6191b2149f6d4d749284f5c3aa8b339c--8adf7df807c242f8bfff8edade18b2a6 70beba0aa6254d6bb4a8a05b2d15af93 8adf7df807c242f8bfff8edade18b2a6--70beba0aa6254d6bb4a8a05b2d15af93 e75a22e7c2d846fca4233ddd928810c8 70beba0aa6254d6bb4a8a05b2d15af93--e75a22e7c2d846fca4233ddd928810c8 682fcb2c0b384c1283ec5e5ce5dfdc61 e75a22e7c2d846fca4233ddd928810c8--682fcb2c0b384c1283ec5e5ce5dfdc61 a2d077f7df764870be275d2725ee9db1 682fcb2c0b384c1283ec5e5ce5dfdc61--a2d077f7df764870be275d2725ee9db1 f761a55dba1748aabd05f4cca76aed51 a2d077f7df764870be275d2725ee9db1--f761a55dba1748aabd05f4cca76aed51 f35a8c1112c141ca80fad47ab163d458 f761a55dba1748aabd05f4cca76aed51--f35a8c1112c141ca80fad47ab163d458 9fbe8d6549b54319839f61c969268eac f35a8c1112c141ca80fad47ab163d458--9fbe8d6549b54319839f61c969268eac 8146485fc3194aa893e638eb7ab7fd78 9fbe8d6549b54319839f61c969268eac--8146485fc3194aa893e638eb7ab7fd78 3685d48ca88b4e0b9f972100e9c5fa2e 8146485fc3194aa893e638eb7ab7fd78--3685d48ca88b4e0b9f972100e9c5fa2e 954bfd97fc5744118a0745627ec4ddbf 3685d48ca88b4e0b9f972100e9c5fa2e--954bfd97fc5744118a0745627ec4ddbf 2dadbecc194144b0a3b9458e3888dda9 954bfd97fc5744118a0745627ec4ddbf--2dadbecc194144b0a3b9458e3888dda9 99b60df5d1c64e198e9b7ee77872130a 2dadbecc194144b0a3b9458e3888dda9--99b60df5d1c64e198e9b7ee77872130a 12cab2dac4d348c3bd51432e9bf1e16b 99b60df5d1c64e198e9b7ee77872130a--12cab2dac4d348c3bd51432e9bf1e16b 7debaed83e08471cbe69bb5d6a6fbed2 RX(b02) 12cab2dac4d348c3bd51432e9bf1e16b--7debaed83e08471cbe69bb5d6a6fbed2 0810e23d73f64ea9bd98558339769378 7debaed83e08471cbe69bb5d6a6fbed2--0810e23d73f64ea9bd98558339769378 fb8ff9b8aa9440bfb5b59287ce3919a9 X 0810e23d73f64ea9bd98558339769378--fb8ff9b8aa9440bfb5b59287ce3919a9 fb8ff9b8aa9440bfb5b59287ce3919a9--70aae49921f24d008edbe61aa38d0eea b05048832fa64e218bf2f01569949e47 fb8ff9b8aa9440bfb5b59287ce3919a9--b05048832fa64e218bf2f01569949e47 44814458551746dda6d77393fed6a914 b05048832fa64e218bf2f01569949e47--44814458551746dda6d77393fed6a914 d1a7a6d47301466586cd82fd26172351 44814458551746dda6d77393fed6a914--d1a7a6d47301466586cd82fd26172351 b4860653297c4da19f0fbc12dd6eedbf d1a7a6d47301466586cd82fd26172351--b4860653297c4da19f0fbc12dd6eedbf 89bd7df9652947cfa3bec309577867eb b4860653297c4da19f0fbc12dd6eedbf--89bd7df9652947cfa3bec309577867eb 720d9981241445ad9353408964e1bd0e 89bd7df9652947cfa3bec309577867eb--720d9981241445ad9353408964e1bd0e f28c49e0982e4c939c5752274149fb42 720d9981241445ad9353408964e1bd0e--f28c49e0982e4c939c5752274149fb42 0b79488d2e96408f8ca8578990043b5a f28c49e0982e4c939c5752274149fb42--0b79488d2e96408f8ca8578990043b5a d4939ed9b7ca40398b3e43cfbdcdcc63 0b79488d2e96408f8ca8578990043b5a--d4939ed9b7ca40398b3e43cfbdcdcc63 488e71d397a04338827fba3c198aeeff d4939ed9b7ca40398b3e43cfbdcdcc63--488e71d397a04338827fba3c198aeeff 17caf6518f1a464bba6642ddd9b1c6a1 488e71d397a04338827fba3c198aeeff--17caf6518f1a464bba6642ddd9b1c6a1 8ea2ae89f31e4d50aee51fe764400f2b X 17caf6518f1a464bba6642ddd9b1c6a1--8ea2ae89f31e4d50aee51fe764400f2b 8ea2ae89f31e4d50aee51fe764400f2b--84ec1e4a47b146b1a02601e0cf248294 52eedf828bef44f3b9513fd8d00a1166 8ea2ae89f31e4d50aee51fe764400f2b--52eedf828bef44f3b9513fd8d00a1166 901807e4cfc84c50912401b413a7eae3 52eedf828bef44f3b9513fd8d00a1166--901807e4cfc84c50912401b413a7eae3 93e0b14cc81a4a69bda6c1abfd583e77 X 901807e4cfc84c50912401b413a7eae3--93e0b14cc81a4a69bda6c1abfd583e77 93e0b14cc81a4a69bda6c1abfd583e77--034026e3f0ff40779482e8241ea3a967 8ea6dbed791f4e64a677ae5eb2232e9a 93e0b14cc81a4a69bda6c1abfd583e77--8ea6dbed791f4e64a677ae5eb2232e9a 249eeaf00f864127b63a4ad8dbec173a 8ea6dbed791f4e64a677ae5eb2232e9a--249eeaf00f864127b63a4ad8dbec173a d57fff00888b4ddd8a65fa7f6673e986 249eeaf00f864127b63a4ad8dbec173a--d57fff00888b4ddd8a65fa7f6673e986 4d4dbf47574e41c3aac4bf9f9f8acf06 d57fff00888b4ddd8a65fa7f6673e986--4d4dbf47574e41c3aac4bf9f9f8acf06 578f668b478f4f75852d8054f6f28f15 4d4dbf47574e41c3aac4bf9f9f8acf06--578f668b478f4f75852d8054f6f28f15 8149f702a582434281894be862eda539 578f668b478f4f75852d8054f6f28f15--8149f702a582434281894be862eda539 8b4da2098f034cc88c9ee3d36aa95253 8149f702a582434281894be862eda539--8b4da2098f034cc88c9ee3d36aa95253 4e8403d2075541c89ac795233faadb6c 8b4da2098f034cc88c9ee3d36aa95253--4e8403d2075541c89ac795233faadb6c 46d2772e9f584d6d82c9db446be456d7 4e8403d2075541c89ac795233faadb6c--46d2772e9f584d6d82c9db446be456d7 b9dd5cec9b7c4a1797994e1af511c1d5 X 46d2772e9f584d6d82c9db446be456d7--b9dd5cec9b7c4a1797994e1af511c1d5 b9dd5cec9b7c4a1797994e1af511c1d5--bbf61c3d54e142ada168b27194b6f278 ce0b1fe85cd145e0ae6b6f3ccb4abbe6 b9dd5cec9b7c4a1797994e1af511c1d5--ce0b1fe85cd145e0ae6b6f3ccb4abbe6 7b519028099a4278b009097ea83e41e1 ce0b1fe85cd145e0ae6b6f3ccb4abbe6--7b519028099a4278b009097ea83e41e1 abacd267fe8f4061945c3a9b9923eade X 7b519028099a4278b009097ea83e41e1--abacd267fe8f4061945c3a9b9923eade abacd267fe8f4061945c3a9b9923eade--adad04db3d5d45f89ad1a9c359c9286e a629a3c17a224ffda28cb3e3b11dfde4 abacd267fe8f4061945c3a9b9923eade--a629a3c17a224ffda28cb3e3b11dfde4 d2e4e3cb2290423cbe11390c569d285f a629a3c17a224ffda28cb3e3b11dfde4--d2e4e3cb2290423cbe11390c569d285f 99bbc49e350e4f41ba1ecf61ea655e14 d2e4e3cb2290423cbe11390c569d285f--99bbc49e350e4f41ba1ecf61ea655e14 071e193846954b56a7dedab26d74dc85 99bbc49e350e4f41ba1ecf61ea655e14--071e193846954b56a7dedab26d74dc85 a427d4ee788b47f5b49b602d073a30cd 071e193846954b56a7dedab26d74dc85--a427d4ee788b47f5b49b602d073a30cd 2612c09b395b4e188ee881fcfcd1c416 a427d4ee788b47f5b49b602d073a30cd--2612c09b395b4e188ee881fcfcd1c416 df3b3da8e6a047219627620e0922ac9b 2612c09b395b4e188ee881fcfcd1c416--df3b3da8e6a047219627620e0922ac9b 67dc546623e9488eb0bb8ef27df155e1 df3b3da8e6a047219627620e0922ac9b--67dc546623e9488eb0bb8ef27df155e1 d80535e3d311465d869ff1d8d910a5c4 67dc546623e9488eb0bb8ef27df155e1--d80535e3d311465d869ff1d8d910a5c4 b0794322a6b84c6798ee407bc023d9ff d80535e3d311465d869ff1d8d910a5c4--b0794322a6b84c6798ee407bc023d9ff b7d508ace1eb48c9ace263f693c65fab b0794322a6b84c6798ee407bc023d9ff--b7d508ace1eb48c9ace263f693c65fab 25b1f69ccc14429f98268ca2ca446e0e X b7d508ace1eb48c9ace263f693c65fab--25b1f69ccc14429f98268ca2ca446e0e 25b1f69ccc14429f98268ca2ca446e0e--55774c6064d943f8b7712c9bdcc85ddc 943fb13a44f44a76994c3a95ed46a779 25b1f69ccc14429f98268ca2ca446e0e--943fb13a44f44a76994c3a95ed46a779 4d673e781597451ab5745aed053a1f6e X 943fb13a44f44a76994c3a95ed46a779--4d673e781597451ab5745aed053a1f6e 4d673e781597451ab5745aed053a1f6e--4bd865c1965b4490b77963b0f95eea72 113f5578183b4303bd0eb664b51f4c64 4d673e781597451ab5745aed053a1f6e--113f5578183b4303bd0eb664b51f4c64 0860e57c570041a9b7b1ef25e6b12e7c 113f5578183b4303bd0eb664b51f4c64--0860e57c570041a9b7b1ef25e6b12e7c c017bb98c6d2433f994bfcc7352ae33a 0860e57c570041a9b7b1ef25e6b12e7c--c017bb98c6d2433f994bfcc7352ae33a 093476b54cab4692a8ab2d868879b45a c017bb98c6d2433f994bfcc7352ae33a--093476b54cab4692a8ab2d868879b45a 666c23df74004b478be15a2f70efe4ea 093476b54cab4692a8ab2d868879b45a--666c23df74004b478be15a2f70efe4ea 906c35a268cc43e7903304ce0fd04347 666c23df74004b478be15a2f70efe4ea--906c35a268cc43e7903304ce0fd04347 620057d817114cb5ac260ddf83e71c36 906c35a268cc43e7903304ce0fd04347--620057d817114cb5ac260ddf83e71c36 acfcfdae3a2e403a9847e7c0923dfa3a 620057d817114cb5ac260ddf83e71c36--acfcfdae3a2e403a9847e7c0923dfa3a 2ad6bcc31bc84508a608286371224da5 acfcfdae3a2e403a9847e7c0923dfa3a--2ad6bcc31bc84508a608286371224da5 13617bfc5eed429aa023fc133a5a1196 X 2ad6bcc31bc84508a608286371224da5--13617bfc5eed429aa023fc133a5a1196 13617bfc5eed429aa023fc133a5a1196--6db7f4741cf6420e816bd50008edfe42 7181313c8ced40e2a6dbad79562ef310 X 13617bfc5eed429aa023fc133a5a1196--7181313c8ced40e2a6dbad79562ef310 7181313c8ced40e2a6dbad79562ef310--1d8ec3d20bea4344845b2ad23516c10f 201f5067675d463b9fa002c06426bd1b 7181313c8ced40e2a6dbad79562ef310--201f5067675d463b9fa002c06426bd1b 09ba796287344983957d0bd7ab082ebd 201f5067675d463b9fa002c06426bd1b--09ba796287344983957d0bd7ab082ebd d42dee0b4e084f798ac7126de514d243 09ba796287344983957d0bd7ab082ebd--d42dee0b4e084f798ac7126de514d243 eec99fc8319e414d9ef9a250a6c8edeb d42dee0b4e084f798ac7126de514d243--eec99fc8319e414d9ef9a250a6c8edeb d5aad635dc434582be9ec3afa08815b9 eec99fc8319e414d9ef9a250a6c8edeb--d5aad635dc434582be9ec3afa08815b9 9d2eb2fa31c2460e90bcaf15bb550b03 d5aad635dc434582be9ec3afa08815b9--9d2eb2fa31c2460e90bcaf15bb550b03 d9d26e54eee748b8a91ee0e9155c62e2 9d2eb2fa31c2460e90bcaf15bb550b03--d9d26e54eee748b8a91ee0e9155c62e2 843526f99c284b1e9f24dc01d1189358 d9d26e54eee748b8a91ee0e9155c62e2--843526f99c284b1e9f24dc01d1189358 673b49cbc514445ea32f5bc05de85a56 843526f99c284b1e9f24dc01d1189358--673b49cbc514445ea32f5bc05de85a56 694170acf5eb492182a0811fdf7f6b57 673b49cbc514445ea32f5bc05de85a56--694170acf5eb492182a0811fdf7f6b57 c75c9288821a4c019523c82583c39806 694170acf5eb492182a0811fdf7f6b57--c75c9288821a4c019523c82583c39806 ca85f4742e424f4fb6775a7b00d6e462 X c75c9288821a4c019523c82583c39806--ca85f4742e424f4fb6775a7b00d6e462 ca85f4742e424f4fb6775a7b00d6e462--421728fd9bb345e3952e2d34dfaef490 a1cd19c7699545f295efd80f433a4e92 ca85f4742e424f4fb6775a7b00d6e462--a1cd19c7699545f295efd80f433a4e92 a9e76579dbbb4f7d9e7f37ce10d43ef9 a1cd19c7699545f295efd80f433a4e92--a9e76579dbbb4f7d9e7f37ce10d43ef9 bbb629cb70b144f39f402b751b36dc9c a9e76579dbbb4f7d9e7f37ce10d43ef9--bbb629cb70b144f39f402b751b36dc9c 670e1b96488745afbbc5937478ff99bc bbb629cb70b144f39f402b751b36dc9c--670e1b96488745afbbc5937478ff99bc f7dd92ba6a774e4fa8d3f2aac922423d 670e1b96488745afbbc5937478ff99bc--f7dd92ba6a774e4fa8d3f2aac922423d a00f87c83b8144d594c7e5ac61df10b9 f7dd92ba6a774e4fa8d3f2aac922423d--a00f87c83b8144d594c7e5ac61df10b9 7757bc4710ee4ff79c5a458f4422edb6 a00f87c83b8144d594c7e5ac61df10b9--7757bc4710ee4ff79c5a458f4422edb6 80b0c422dce148a28f2d535b55b761b1 7757bc4710ee4ff79c5a458f4422edb6--80b0c422dce148a28f2d535b55b761b1 fc022bd93c844eb4b630a7c0f50b1b0a 80b0c422dce148a28f2d535b55b761b1--fc022bd93c844eb4b630a7c0f50b1b0a 9f63b11436304e138726cd7eca7a1b05 fc022bd93c844eb4b630a7c0f50b1b0a--9f63b11436304e138726cd7eca7a1b05 1d465f98117e46999063b4794283abe0 9f63b11436304e138726cd7eca7a1b05--1d465f98117e46999063b4794283abe0 cb219e9332654ddab0b14ff2b67bfade 1d465f98117e46999063b4794283abe0--cb219e9332654ddab0b14ff2b67bfade 63b046eefb224a1eaf555f03123dbea9 cb219e9332654ddab0b14ff2b67bfade--63b046eefb224a1eaf555f03123dbea9 d6ab80800baa4347bfaf5c169e092dbc 63b046eefb224a1eaf555f03123dbea9--d6ab80800baa4347bfaf5c169e092dbc c99bf70592c54ebdb86b383330f8c56b d6ab80800baa4347bfaf5c169e092dbc--c99bf70592c54ebdb86b383330f8c56b f2fe827c535043cfaf59eb4634d2a819 c99bf70592c54ebdb86b383330f8c56b--f2fe827c535043cfaf59eb4634d2a819 decf02da28b44428aa9d4fa6589dc097 f2fe827c535043cfaf59eb4634d2a819--decf02da28b44428aa9d4fa6589dc097 055ddafcb7054849b25ed507be93273e decf02da28b44428aa9d4fa6589dc097--055ddafcb7054849b25ed507be93273e 3ca956087fc447ffa148a23fe6dbd482 055ddafcb7054849b25ed507be93273e--3ca956087fc447ffa148a23fe6dbd482 f0e70c72ad2a4b19872f28418791e9da 3ca956087fc447ffa148a23fe6dbd482--f0e70c72ad2a4b19872f28418791e9da 83f7c2f92d9d49c2b64744efa9da6d0a f0e70c72ad2a4b19872f28418791e9da--83f7c2f92d9d49c2b64744efa9da6d0a 22caf4acb8614ee480bef667640d7b87 83f7c2f92d9d49c2b64744efa9da6d0a--22caf4acb8614ee480bef667640d7b87 12832701be2042d9899d2bc041bb0c3b 22caf4acb8614ee480bef667640d7b87--12832701be2042d9899d2bc041bb0c3b e9efd0d1d6194e50b6d3468b23227c46 12832701be2042d9899d2bc041bb0c3b--e9efd0d1d6194e50b6d3468b23227c46 f92a87f5973e43588b1d9c64e9fe82d4 e9efd0d1d6194e50b6d3468b23227c46--f92a87f5973e43588b1d9c64e9fe82d4 310951a365fd4a789f9bada7cb19cacc f92a87f5973e43588b1d9c64e9fe82d4--310951a365fd4a789f9bada7cb19cacc d753de4e17b64d74a0e4dddda30e0717 310951a365fd4a789f9bada7cb19cacc--d753de4e17b64d74a0e4dddda30e0717 2462ad6dbf3b49e58db8d30386123635 d753de4e17b64d74a0e4dddda30e0717--2462ad6dbf3b49e58db8d30386123635 5d0f8d2ae181450fa8e18ba223811493 2462ad6dbf3b49e58db8d30386123635--5d0f8d2ae181450fa8e18ba223811493 3d6aab00d38c48578b842f6686af21c1 5d0f8d2ae181450fa8e18ba223811493--3d6aab00d38c48578b842f6686af21c1 2371f029ef8d45559bda415f09500d74 3d6aab00d38c48578b842f6686af21c1--2371f029ef8d45559bda415f09500d74 8416539709bc4c5ab73098c471f921df 2371f029ef8d45559bda415f09500d74--8416539709bc4c5ab73098c471f921df f96ccf79d8c24205bfd9a928e219ee98 8416539709bc4c5ab73098c471f921df--f96ccf79d8c24205bfd9a928e219ee98 24b01c6ce132413f879b8a35aeddd1d2 f96ccf79d8c24205bfd9a928e219ee98--24b01c6ce132413f879b8a35aeddd1d2 22b61148ac4a41cb84dc6f9f266174c4 24b01c6ce132413f879b8a35aeddd1d2--22b61148ac4a41cb84dc6f9f266174c4 2a95133fc9b042048dc856a1d86d543a 22b61148ac4a41cb84dc6f9f266174c4--2a95133fc9b042048dc856a1d86d543a adf98f8a4dfd4a46b8f4af7f93f5effe 2a95133fc9b042048dc856a1d86d543a--adf98f8a4dfd4a46b8f4af7f93f5effe 3287e5b7dfde425a88924aa9a3330048 RX(b12) adf98f8a4dfd4a46b8f4af7f93f5effe--3287e5b7dfde425a88924aa9a3330048 3287e5b7dfde425a88924aa9a3330048--a560ebc6003e4f93b9931a700e91fe0a 7b95b7c21b2343b796e2e655e49e8e1d c881902bb64541f68f490a28a2f01944 05941205bce0431e88df7c10c5bbec58--c881902bb64541f68f490a28a2f01944 0c7cd73b5b2344fdb3c9bd1c7cf3ee93 4 b68edc6090644acf97051a0f0b88dfbe c881902bb64541f68f490a28a2f01944--b68edc6090644acf97051a0f0b88dfbe 8af91ed9bec042fd880c54911b6a0136 X b68edc6090644acf97051a0f0b88dfbe--8af91ed9bec042fd880c54911b6a0136 8af91ed9bec042fd880c54911b6a0136--90e88f844821414a8cb06c5b67dd0af4 024db4d69efe44a5948e126ce439b325 8af91ed9bec042fd880c54911b6a0136--024db4d69efe44a5948e126ce439b325 71285c273c0246e893bd95504a9e7b6f 024db4d69efe44a5948e126ce439b325--71285c273c0246e893bd95504a9e7b6f 986ec4685781439184d195c2bc488ffd 71285c273c0246e893bd95504a9e7b6f--986ec4685781439184d195c2bc488ffd 8376e209b520448e874511f508403fca 986ec4685781439184d195c2bc488ffd--8376e209b520448e874511f508403fca 51eca6fbc5554c68b32195691f975275 8376e209b520448e874511f508403fca--51eca6fbc5554c68b32195691f975275 1e50b921b98b463c931f134fa2e92f07 51eca6fbc5554c68b32195691f975275--1e50b921b98b463c931f134fa2e92f07 f049041a486f4467b0d4dd03eb947d93 1e50b921b98b463c931f134fa2e92f07--f049041a486f4467b0d4dd03eb947d93 2e0b5fea984342388f2967d3fbaf811e f049041a486f4467b0d4dd03eb947d93--2e0b5fea984342388f2967d3fbaf811e 144f9cdf216d4341a0506bf60f87fd01 2e0b5fea984342388f2967d3fbaf811e--144f9cdf216d4341a0506bf60f87fd01 b25a32f8d0cf4be882feb602cfce6328 X 144f9cdf216d4341a0506bf60f87fd01--b25a32f8d0cf4be882feb602cfce6328 b25a32f8d0cf4be882feb602cfce6328--f0063652361d43d0b880f4738ec82933 4b9e39625ea34169bc9ad8c9b8d399cc b25a32f8d0cf4be882feb602cfce6328--4b9e39625ea34169bc9ad8c9b8d399cc 964c9fad892e49c7a95be57758d95b11 4b9e39625ea34169bc9ad8c9b8d399cc--964c9fad892e49c7a95be57758d95b11 04860a52b32946e9a06f2692bfb4a443 964c9fad892e49c7a95be57758d95b11--04860a52b32946e9a06f2692bfb4a443 91f278935cc344e191537e3ac9acbe3b 04860a52b32946e9a06f2692bfb4a443--91f278935cc344e191537e3ac9acbe3b ef2eb572f47e46d4984d08321a09d5d8 X 91f278935cc344e191537e3ac9acbe3b--ef2eb572f47e46d4984d08321a09d5d8 ef2eb572f47e46d4984d08321a09d5d8--3fc6ec7c1a01435f8798bf64c8371d50 e5c2484fa01f478c971bbbc6d7189e67 ef2eb572f47e46d4984d08321a09d5d8--e5c2484fa01f478c971bbbc6d7189e67 fdcd18c981b249eeb6acb970e9555ea8 e5c2484fa01f478c971bbbc6d7189e67--fdcd18c981b249eeb6acb970e9555ea8 26d39c23ff50423c8db09322e3f309cf fdcd18c981b249eeb6acb970e9555ea8--26d39c23ff50423c8db09322e3f309cf f51a873c55ec4d649393f07966242334 26d39c23ff50423c8db09322e3f309cf--f51a873c55ec4d649393f07966242334 9b5bfe77d7e74329bc4a45a7afd66b1f f51a873c55ec4d649393f07966242334--9b5bfe77d7e74329bc4a45a7afd66b1f de1d3a079ab4496b9ec60330be8f9574 9b5bfe77d7e74329bc4a45a7afd66b1f--de1d3a079ab4496b9ec60330be8f9574 8f7c7c24caf840198122c1da454e287d de1d3a079ab4496b9ec60330be8f9574--8f7c7c24caf840198122c1da454e287d 4d9818b8effb4cdb8adb2b97f5d8e231 X 8f7c7c24caf840198122c1da454e287d--4d9818b8effb4cdb8adb2b97f5d8e231 4d9818b8effb4cdb8adb2b97f5d8e231--22de30bb8fe44dd6b9b9103c4711b358 2edd8c03d1bc48bc89678aa733986a95 4d9818b8effb4cdb8adb2b97f5d8e231--2edd8c03d1bc48bc89678aa733986a95 5806d7359c7644e6a4e42b8ecae8102a 2edd8c03d1bc48bc89678aa733986a95--5806d7359c7644e6a4e42b8ecae8102a e259aed05f3f4dee9f4576df726bdfa2 5806d7359c7644e6a4e42b8ecae8102a--e259aed05f3f4dee9f4576df726bdfa2 fd1fdb7fbb3e402eb4d59b88daccfe00 e259aed05f3f4dee9f4576df726bdfa2--fd1fdb7fbb3e402eb4d59b88daccfe00 7dbe4b128b67407c8395f21771053593 X fd1fdb7fbb3e402eb4d59b88daccfe00--7dbe4b128b67407c8395f21771053593 7dbe4b128b67407c8395f21771053593--9d083b24ba4c40a8930d7dcb77fcaec5 affc1265220845ffb4f5391409e0fba0 7dbe4b128b67407c8395f21771053593--affc1265220845ffb4f5391409e0fba0 dc6f2fbea3564dd8b0ffd27c23b27516 affc1265220845ffb4f5391409e0fba0--dc6f2fbea3564dd8b0ffd27c23b27516 48e70ac72d914324a1a0d750f722d481 dc6f2fbea3564dd8b0ffd27c23b27516--48e70ac72d914324a1a0d750f722d481 1e6b47f6753f4b418d6bc70765847b01 48e70ac72d914324a1a0d750f722d481--1e6b47f6753f4b418d6bc70765847b01 79a0f99c2f524c86b4af933e3f620939 1e6b47f6753f4b418d6bc70765847b01--79a0f99c2f524c86b4af933e3f620939 bffd6f252a794991bae11ee6f4f75d95 79a0f99c2f524c86b4af933e3f620939--bffd6f252a794991bae11ee6f4f75d95 8db6601448704deeb4c15963cc4f75ef bffd6f252a794991bae11ee6f4f75d95--8db6601448704deeb4c15963cc4f75ef 9f74229fd0734c9881018b2e40f791a3 8db6601448704deeb4c15963cc4f75ef--9f74229fd0734c9881018b2e40f791a3 5ec26975ceb64dd0875e31ffea98a568 9f74229fd0734c9881018b2e40f791a3--5ec26975ceb64dd0875e31ffea98a568 d969129f8161454fa7c3d4deb2af140f X 5ec26975ceb64dd0875e31ffea98a568--d969129f8161454fa7c3d4deb2af140f d969129f8161454fa7c3d4deb2af140f--a6122e870c474ba88b534e67314db01e afa65c44a0284e2eb98d7de2ccee0227 d969129f8161454fa7c3d4deb2af140f--afa65c44a0284e2eb98d7de2ccee0227 4a6576a05f8347acb4252fd63ad81405 afa65c44a0284e2eb98d7de2ccee0227--4a6576a05f8347acb4252fd63ad81405 b04477a362ba4b34bd8d980fb2694de8 4a6576a05f8347acb4252fd63ad81405--b04477a362ba4b34bd8d980fb2694de8 f9f0fce56f6e44b397eed7950408f592 X b04477a362ba4b34bd8d980fb2694de8--f9f0fce56f6e44b397eed7950408f592 f9f0fce56f6e44b397eed7950408f592--9abf9554c58e42dab893102efa92dd1c 9ba3c49ebe8546cdb9954a41dc41fde1 f9f0fce56f6e44b397eed7950408f592--9ba3c49ebe8546cdb9954a41dc41fde1 86e3f9465c5e4f92a117b047ad9fe4ae 9ba3c49ebe8546cdb9954a41dc41fde1--86e3f9465c5e4f92a117b047ad9fe4ae 3c007f1244984d808362ce823dc8d64c 86e3f9465c5e4f92a117b047ad9fe4ae--3c007f1244984d808362ce823dc8d64c 1f57a259514647f9b44e9983f43414eb 3c007f1244984d808362ce823dc8d64c--1f57a259514647f9b44e9983f43414eb 4c9ec64baf04498d8e7dc5d68afcb40d 1f57a259514647f9b44e9983f43414eb--4c9ec64baf04498d8e7dc5d68afcb40d 1aab71776e2b485ea0c1944f710c83d8 4c9ec64baf04498d8e7dc5d68afcb40d--1aab71776e2b485ea0c1944f710c83d8 d1484ad15bac4a7987a56f26d8605434 1aab71776e2b485ea0c1944f710c83d8--d1484ad15bac4a7987a56f26d8605434 6c83c844564f4e0faf7d00ecf75f60dc X d1484ad15bac4a7987a56f26d8605434--6c83c844564f4e0faf7d00ecf75f60dc 6c83c844564f4e0faf7d00ecf75f60dc--22927642ed75460fba5154fef02e7b68 00cbc73643584e43b876936968e444f2 6c83c844564f4e0faf7d00ecf75f60dc--00cbc73643584e43b876936968e444f2 4f1605c55aba4d8b950005af7666447a 00cbc73643584e43b876936968e444f2--4f1605c55aba4d8b950005af7666447a 3d0fc7df70fa471282a06fa0891962d1 X 4f1605c55aba4d8b950005af7666447a--3d0fc7df70fa471282a06fa0891962d1 3d0fc7df70fa471282a06fa0891962d1--de6d110c0341498285ac4cd23474ef80 74ab1de36a4842faaad15f4ed48e36b9 3d0fc7df70fa471282a06fa0891962d1--74ab1de36a4842faaad15f4ed48e36b9 e57827951bb64f55a88c6e2d3c218e5e 74ab1de36a4842faaad15f4ed48e36b9--e57827951bb64f55a88c6e2d3c218e5e 674c0f4cf178421ca64547eb545a761c e57827951bb64f55a88c6e2d3c218e5e--674c0f4cf178421ca64547eb545a761c c193b8419f1c46c391475c1a3c407e14 674c0f4cf178421ca64547eb545a761c--c193b8419f1c46c391475c1a3c407e14 c4a1897fdff145fead68c1e2c11673e2 c193b8419f1c46c391475c1a3c407e14--c4a1897fdff145fead68c1e2c11673e2 980a6901373b48e8bbffb75459d656e9 c4a1897fdff145fead68c1e2c11673e2--980a6901373b48e8bbffb75459d656e9 cf3a7f2621d94db8ba546d7710e3a599 980a6901373b48e8bbffb75459d656e9--cf3a7f2621d94db8ba546d7710e3a599 7218ac8b4eef488f98e43435d19e9189 cf3a7f2621d94db8ba546d7710e3a599--7218ac8b4eef488f98e43435d19e9189 3c90fb83e99b4e999fa2b458687e86f8 7218ac8b4eef488f98e43435d19e9189--3c90fb83e99b4e999fa2b458687e86f8 8db30e450e48410b89fa9a5664e5161e X 3c90fb83e99b4e999fa2b458687e86f8--8db30e450e48410b89fa9a5664e5161e 8db30e450e48410b89fa9a5664e5161e--c49b434e3aca4e8da6f991fa21bcecf2 9aa99f0109f042efbc1f1cf5da2f0bad 8db30e450e48410b89fa9a5664e5161e--9aa99f0109f042efbc1f1cf5da2f0bad 38794eeac47a4740b4b0cfce0b29d32c X 9aa99f0109f042efbc1f1cf5da2f0bad--38794eeac47a4740b4b0cfce0b29d32c 38794eeac47a4740b4b0cfce0b29d32c--941448ff4ed44f43ad0e19459f97529a b2d1b7d34da24d92af492203f8a71ca4 RZ(-1.0*g0) 38794eeac47a4740b4b0cfce0b29d32c--b2d1b7d34da24d92af492203f8a71ca4 21c0fafd904d4fcdaec2a0d7849448dd X b2d1b7d34da24d92af492203f8a71ca4--21c0fafd904d4fcdaec2a0d7849448dd 21c0fafd904d4fcdaec2a0d7849448dd--4e8971b92b5e4eb3954cf7ce9c28509e 69974100b50f4849a2049c08796aa19e X 21c0fafd904d4fcdaec2a0d7849448dd--69974100b50f4849a2049c08796aa19e 69974100b50f4849a2049c08796aa19e--87e06020a30e4aa6877d1298289ea4af 22cb504be50c46e38b1c41d5348d865a 69974100b50f4849a2049c08796aa19e--22cb504be50c46e38b1c41d5348d865a c7053ee1d5a34fffad17c1e85c11ddfe 22cb504be50c46e38b1c41d5348d865a--c7053ee1d5a34fffad17c1e85c11ddfe 25a36088ca274d7d88dfc072091212e2 c7053ee1d5a34fffad17c1e85c11ddfe--25a36088ca274d7d88dfc072091212e2 891ae731ef8d445abd06bdaf0d0c6090 X 25a36088ca274d7d88dfc072091212e2--891ae731ef8d445abd06bdaf0d0c6090 891ae731ef8d445abd06bdaf0d0c6090--4a128a541e2147e6b101c5b6ef2091f1 66c98ea272064085a6d9aa7b46391ee1 X 891ae731ef8d445abd06bdaf0d0c6090--66c98ea272064085a6d9aa7b46391ee1 66c98ea272064085a6d9aa7b46391ee1--9a1509fe0dcb4c07af23bfd029cca15e de6037747e4a48b585fd4587bdc762f0 66c98ea272064085a6d9aa7b46391ee1--de6037747e4a48b585fd4587bdc762f0 5bfcaa046a684383bc375aa83b59c1d7 de6037747e4a48b585fd4587bdc762f0--5bfcaa046a684383bc375aa83b59c1d7 85c30b6aa8c740489ecae517476a68c8 5bfcaa046a684383bc375aa83b59c1d7--85c30b6aa8c740489ecae517476a68c8 347ea84bcd874d139c00d5d3fe20e0ee 85c30b6aa8c740489ecae517476a68c8--347ea84bcd874d139c00d5d3fe20e0ee 201cd16b5bc94424ac816c1428b010bb 347ea84bcd874d139c00d5d3fe20e0ee--201cd16b5bc94424ac816c1428b010bb 4bb00fc739c342888d1ae110c94bf976 201cd16b5bc94424ac816c1428b010bb--4bb00fc739c342888d1ae110c94bf976 5255fe565adf49bd820360bb347f779b 4bb00fc739c342888d1ae110c94bf976--5255fe565adf49bd820360bb347f779b c7f477c82a914ff49d1f928d9c8598f3 X 5255fe565adf49bd820360bb347f779b--c7f477c82a914ff49d1f928d9c8598f3 c7f477c82a914ff49d1f928d9c8598f3--cbabbcff47f445c5b8ed77fb2b788ecf 39dae64b541446be95f6a5ea185be312 c7f477c82a914ff49d1f928d9c8598f3--39dae64b541446be95f6a5ea185be312 2d762ae2eeca43bd8073ce78810c85b4 39dae64b541446be95f6a5ea185be312--2d762ae2eeca43bd8073ce78810c85b4 cd8cec18d1dd465c9689a47b34468791 2d762ae2eeca43bd8073ce78810c85b4--cd8cec18d1dd465c9689a47b34468791 5bf1c9beb89745c1bf22cd9285e6547e cd8cec18d1dd465c9689a47b34468791--5bf1c9beb89745c1bf22cd9285e6547e a233a6be48a143f2a393f9b4cd25e04f 5bf1c9beb89745c1bf22cd9285e6547e--a233a6be48a143f2a393f9b4cd25e04f cc141e6b090d42188957f60580ef269d a233a6be48a143f2a393f9b4cd25e04f--cc141e6b090d42188957f60580ef269d d8276fd44fd342999f9926240188754c cc141e6b090d42188957f60580ef269d--d8276fd44fd342999f9926240188754c a65c8c6763fd4247a35b443642f589bc d8276fd44fd342999f9926240188754c--a65c8c6763fd4247a35b443642f589bc af9506e9246345569aba47ff6d404ef8 a65c8c6763fd4247a35b443642f589bc--af9506e9246345569aba47ff6d404ef8 393d96fc0a34447985904a4bdb38d8bd af9506e9246345569aba47ff6d404ef8--393d96fc0a34447985904a4bdb38d8bd 8d1dce3e79d8499ba93777744b5456c3 393d96fc0a34447985904a4bdb38d8bd--8d1dce3e79d8499ba93777744b5456c3 3a4c32922d2c45bbacf1b54c091c49b0 8d1dce3e79d8499ba93777744b5456c3--3a4c32922d2c45bbacf1b54c091c49b0 49e2cde32b394267bb3a47abcb7ff306 3a4c32922d2c45bbacf1b54c091c49b0--49e2cde32b394267bb3a47abcb7ff306 635cdce5e2394b11a297f41c5cc8e864 49e2cde32b394267bb3a47abcb7ff306--635cdce5e2394b11a297f41c5cc8e864 3fe91d15af2e447f9d7b09dbc3fdaf1d 635cdce5e2394b11a297f41c5cc8e864--3fe91d15af2e447f9d7b09dbc3fdaf1d a2b5d042303040ba8710e31003d4de5b 3fe91d15af2e447f9d7b09dbc3fdaf1d--a2b5d042303040ba8710e31003d4de5b b1ce9d5607aa4163b3d8e275e17d28f1 a2b5d042303040ba8710e31003d4de5b--b1ce9d5607aa4163b3d8e275e17d28f1 ea4eece8f78c458a9fa669b757b161b4 b1ce9d5607aa4163b3d8e275e17d28f1--ea4eece8f78c458a9fa669b757b161b4 484bc294828b4135b8f62d4229b2dc8d ea4eece8f78c458a9fa669b757b161b4--484bc294828b4135b8f62d4229b2dc8d fe735b542664459eb1ecbd96dee95765 484bc294828b4135b8f62d4229b2dc8d--fe735b542664459eb1ecbd96dee95765 7e1f14bc48fc4cb6a6b92d8699450add RX(b03) fe735b542664459eb1ecbd96dee95765--7e1f14bc48fc4cb6a6b92d8699450add 5eee3e5e3c564d44aa086585b9b24a53 7e1f14bc48fc4cb6a6b92d8699450add--5eee3e5e3c564d44aa086585b9b24a53 abbd7795b66648b7b7c5c42ac0ef1f8b 5eee3e5e3c564d44aa086585b9b24a53--abbd7795b66648b7b7c5c42ac0ef1f8b a5d65b4f3dfd4f6ab9b36f079fc80e38 X abbd7795b66648b7b7c5c42ac0ef1f8b--a5d65b4f3dfd4f6ab9b36f079fc80e38 a5d65b4f3dfd4f6ab9b36f079fc80e38--b05048832fa64e218bf2f01569949e47 6551c0236575457bb4a00be974899983 a5d65b4f3dfd4f6ab9b36f079fc80e38--6551c0236575457bb4a00be974899983 31d62061b36f40afb9f6a6c3bc0127ea 6551c0236575457bb4a00be974899983--31d62061b36f40afb9f6a6c3bc0127ea a10f6f4a7df942a6a0b2bf9c9edca908 31d62061b36f40afb9f6a6c3bc0127ea--a10f6f4a7df942a6a0b2bf9c9edca908 331ca3e7d89d48948eb4e013c6ec97bd a10f6f4a7df942a6a0b2bf9c9edca908--331ca3e7d89d48948eb4e013c6ec97bd df6ce6aa9370418687969159771313fb 331ca3e7d89d48948eb4e013c6ec97bd--df6ce6aa9370418687969159771313fb 0e4620ad1f5241cf9d3fbd43ee3f763e df6ce6aa9370418687969159771313fb--0e4620ad1f5241cf9d3fbd43ee3f763e 91f6c15f197749848f3743f0be2199d8 0e4620ad1f5241cf9d3fbd43ee3f763e--91f6c15f197749848f3743f0be2199d8 6198d4dc62d64e56ac368c84f274e4d3 91f6c15f197749848f3743f0be2199d8--6198d4dc62d64e56ac368c84f274e4d3 f3cd0edfba99412fb733a74ecc4a20d8 6198d4dc62d64e56ac368c84f274e4d3--f3cd0edfba99412fb733a74ecc4a20d8 3ae1ed6789024a3b8b419c9e67c35860 X f3cd0edfba99412fb733a74ecc4a20d8--3ae1ed6789024a3b8b419c9e67c35860 3ae1ed6789024a3b8b419c9e67c35860--17caf6518f1a464bba6642ddd9b1c6a1 a7d77628aacf471a9833f634fa790e41 3ae1ed6789024a3b8b419c9e67c35860--a7d77628aacf471a9833f634fa790e41 6cc7cebf3a364d0782f9b2169cbf1e67 a7d77628aacf471a9833f634fa790e41--6cc7cebf3a364d0782f9b2169cbf1e67 e85f13465a8f4a8f9e5d6d78950a9232 6cc7cebf3a364d0782f9b2169cbf1e67--e85f13465a8f4a8f9e5d6d78950a9232 89cd233da2294302965686f238717bdd e85f13465a8f4a8f9e5d6d78950a9232--89cd233da2294302965686f238717bdd 201d175b39164306a353f999258b1804 X 89cd233da2294302965686f238717bdd--201d175b39164306a353f999258b1804 201d175b39164306a353f999258b1804--8ea6dbed791f4e64a677ae5eb2232e9a 3cec93d71b0341f7b430fed844c21c45 201d175b39164306a353f999258b1804--3cec93d71b0341f7b430fed844c21c45 b1d75512adce4461be00ec5052222320 3cec93d71b0341f7b430fed844c21c45--b1d75512adce4461be00ec5052222320 01b1c06fef1946d8ae7476bf41020cc7 b1d75512adce4461be00ec5052222320--01b1c06fef1946d8ae7476bf41020cc7 b6c6b0d0f716441ba6917413d711c1d4 01b1c06fef1946d8ae7476bf41020cc7--b6c6b0d0f716441ba6917413d711c1d4 cbcb4837d4c74ff88a2583338aa77e93 b6c6b0d0f716441ba6917413d711c1d4--cbcb4837d4c74ff88a2583338aa77e93 cd47122a9a7a424c9f345d83c7b4f6db cbcb4837d4c74ff88a2583338aa77e93--cd47122a9a7a424c9f345d83c7b4f6db a7424ae404fb412887e363f18932a893 cd47122a9a7a424c9f345d83c7b4f6db--a7424ae404fb412887e363f18932a893 a9ae74b823aa407ea10bdd116ebb1c1f X a7424ae404fb412887e363f18932a893--a9ae74b823aa407ea10bdd116ebb1c1f a9ae74b823aa407ea10bdd116ebb1c1f--46d2772e9f584d6d82c9db446be456d7 8953bc41bca94793abc234f912e95db9 a9ae74b823aa407ea10bdd116ebb1c1f--8953bc41bca94793abc234f912e95db9 d058918836504ee1bd03664ce1bd7e8d 8953bc41bca94793abc234f912e95db9--d058918836504ee1bd03664ce1bd7e8d 2f9457d8eb2241118459c0afcacd0027 d058918836504ee1bd03664ce1bd7e8d--2f9457d8eb2241118459c0afcacd0027 94954df6214e488783e61a04e31307d3 2f9457d8eb2241118459c0afcacd0027--94954df6214e488783e61a04e31307d3 07b449a8a62346b29ce34d87599c4efe X 94954df6214e488783e61a04e31307d3--07b449a8a62346b29ce34d87599c4efe 07b449a8a62346b29ce34d87599c4efe--a629a3c17a224ffda28cb3e3b11dfde4 205ea3bf304c4b5aad0df572bf9547f3 07b449a8a62346b29ce34d87599c4efe--205ea3bf304c4b5aad0df572bf9547f3 a81437ecf6904abd9336d05755522519 205ea3bf304c4b5aad0df572bf9547f3--a81437ecf6904abd9336d05755522519 970e71e6dbc04216a335eb04c035b6f1 a81437ecf6904abd9336d05755522519--970e71e6dbc04216a335eb04c035b6f1 3b4e0b3e87a243b3b57dc2e98887766e 970e71e6dbc04216a335eb04c035b6f1--3b4e0b3e87a243b3b57dc2e98887766e 57390a33d7e749cfbc05b95483651fa3 3b4e0b3e87a243b3b57dc2e98887766e--57390a33d7e749cfbc05b95483651fa3 c313b3c52eef4d1caabeff91aaeb6e89 57390a33d7e749cfbc05b95483651fa3--c313b3c52eef4d1caabeff91aaeb6e89 92f39f5681684a6e83276669ad49a9a7 c313b3c52eef4d1caabeff91aaeb6e89--92f39f5681684a6e83276669ad49a9a7 996d3e0cba2944e2922e5b0df1141dbc 92f39f5681684a6e83276669ad49a9a7--996d3e0cba2944e2922e5b0df1141dbc 21335b15e1734875be4a3a216ff6aac6 996d3e0cba2944e2922e5b0df1141dbc--21335b15e1734875be4a3a216ff6aac6 36e3dabb923c418c91d4834de0cf83ac X 21335b15e1734875be4a3a216ff6aac6--36e3dabb923c418c91d4834de0cf83ac 36e3dabb923c418c91d4834de0cf83ac--b7d508ace1eb48c9ace263f693c65fab c57f27bfb4e847b886003b1164a561f5 36e3dabb923c418c91d4834de0cf83ac--c57f27bfb4e847b886003b1164a561f5 b22c624c600745b59f58d5926d28e365 c57f27bfb4e847b886003b1164a561f5--b22c624c600745b59f58d5926d28e365 6d81d75b3af3478fa70ec40befd83a04 b22c624c600745b59f58d5926d28e365--6d81d75b3af3478fa70ec40befd83a04 4960d87ca20e4887b8827d46671258ec X 6d81d75b3af3478fa70ec40befd83a04--4960d87ca20e4887b8827d46671258ec 4960d87ca20e4887b8827d46671258ec--113f5578183b4303bd0eb664b51f4c64 958d0dcdd73d491e8d41477f2d070243 4960d87ca20e4887b8827d46671258ec--958d0dcdd73d491e8d41477f2d070243 718160adc3f14e779c77f9afb891c7ea 958d0dcdd73d491e8d41477f2d070243--718160adc3f14e779c77f9afb891c7ea e6ee231433174527ba2600da85d5a4a1 718160adc3f14e779c77f9afb891c7ea--e6ee231433174527ba2600da85d5a4a1 b35f78631c2c4c3295e661bea1083d97 e6ee231433174527ba2600da85d5a4a1--b35f78631c2c4c3295e661bea1083d97 2dfb9d4f8a00455ca6eb494d98d89e7d b35f78631c2c4c3295e661bea1083d97--2dfb9d4f8a00455ca6eb494d98d89e7d df8e89f52aa246f5b4c2f20dd7eb0777 2dfb9d4f8a00455ca6eb494d98d89e7d--df8e89f52aa246f5b4c2f20dd7eb0777 132de757168b4d56b4e74453c8689c4a df8e89f52aa246f5b4c2f20dd7eb0777--132de757168b4d56b4e74453c8689c4a cd64b3c9380c4ba18321a4604f1210c7 X 132de757168b4d56b4e74453c8689c4a--cd64b3c9380c4ba18321a4604f1210c7 cd64b3c9380c4ba18321a4604f1210c7--2ad6bcc31bc84508a608286371224da5 b70872c894724ffe94c57f7abf8a9d2f cd64b3c9380c4ba18321a4604f1210c7--b70872c894724ffe94c57f7abf8a9d2f 74248001d79b4684918ec7e0790e385c b70872c894724ffe94c57f7abf8a9d2f--74248001d79b4684918ec7e0790e385c 2bd33e13603c48c691030c77cab4a99d X 74248001d79b4684918ec7e0790e385c--2bd33e13603c48c691030c77cab4a99d 2bd33e13603c48c691030c77cab4a99d--201f5067675d463b9fa002c06426bd1b 576edeba96324844b8538e5547c7f59a 2bd33e13603c48c691030c77cab4a99d--576edeba96324844b8538e5547c7f59a e2a37726c57843718110f317a4385ead 576edeba96324844b8538e5547c7f59a--e2a37726c57843718110f317a4385ead cf404036b3a9480bb5c177aaddec6007 e2a37726c57843718110f317a4385ead--cf404036b3a9480bb5c177aaddec6007 d1a0681660d040da9dae7cadabb271c4 cf404036b3a9480bb5c177aaddec6007--d1a0681660d040da9dae7cadabb271c4 9116fd9127d948419289cfd2a4d1baee d1a0681660d040da9dae7cadabb271c4--9116fd9127d948419289cfd2a4d1baee 17371d2965c644d2b36a0e16230a3780 9116fd9127d948419289cfd2a4d1baee--17371d2965c644d2b36a0e16230a3780 d79c44813bad4ae7a6716bbc083505ee 17371d2965c644d2b36a0e16230a3780--d79c44813bad4ae7a6716bbc083505ee 9b20c7a3088d4cb39be6d906990ba948 d79c44813bad4ae7a6716bbc083505ee--9b20c7a3088d4cb39be6d906990ba948 b9eae0772d2c402181189b06777737f4 9b20c7a3088d4cb39be6d906990ba948--b9eae0772d2c402181189b06777737f4 5a64820a1d5e4a449edefcfea12ef847 X b9eae0772d2c402181189b06777737f4--5a64820a1d5e4a449edefcfea12ef847 5a64820a1d5e4a449edefcfea12ef847--c75c9288821a4c019523c82583c39806 a2001141e7e84547ae15e7ccec5c1619 5a64820a1d5e4a449edefcfea12ef847--a2001141e7e84547ae15e7ccec5c1619 0fda06cb946d4e3d85b5dfa044de0085 X a2001141e7e84547ae15e7ccec5c1619--0fda06cb946d4e3d85b5dfa044de0085 0fda06cb946d4e3d85b5dfa044de0085--a1cd19c7699545f295efd80f433a4e92 013daa242d704bb9997fcd5ecd813b63 RZ(-1.0*g1) 0fda06cb946d4e3d85b5dfa044de0085--013daa242d704bb9997fcd5ecd813b63 1497292f527a4d5e8d1ca92c66b7e4f0 X 013daa242d704bb9997fcd5ecd813b63--1497292f527a4d5e8d1ca92c66b7e4f0 1497292f527a4d5e8d1ca92c66b7e4f0--bbb629cb70b144f39f402b751b36dc9c d2351fefc94d4d9d8a569954266cfdf1 X 1497292f527a4d5e8d1ca92c66b7e4f0--d2351fefc94d4d9d8a569954266cfdf1 d2351fefc94d4d9d8a569954266cfdf1--670e1b96488745afbbc5937478ff99bc 8fa2d8bbe7d44574916af994bf8fe0a7 d2351fefc94d4d9d8a569954266cfdf1--8fa2d8bbe7d44574916af994bf8fe0a7 c8ac0f55607d4508afab3716fec4d250 8fa2d8bbe7d44574916af994bf8fe0a7--c8ac0f55607d4508afab3716fec4d250 a0f9c46288534921b4c5bbf07ce79b50 c8ac0f55607d4508afab3716fec4d250--a0f9c46288534921b4c5bbf07ce79b50 c77b21c68a534a0f92921e5b6e5dbb92 X a0f9c46288534921b4c5bbf07ce79b50--c77b21c68a534a0f92921e5b6e5dbb92 c77b21c68a534a0f92921e5b6e5dbb92--80b0c422dce148a28f2d535b55b761b1 2304df0b3e744835bceaa70332966917 X c77b21c68a534a0f92921e5b6e5dbb92--2304df0b3e744835bceaa70332966917 2304df0b3e744835bceaa70332966917--fc022bd93c844eb4b630a7c0f50b1b0a 3c5150fdd35a49cc8a5fba96c3a2fcbe 2304df0b3e744835bceaa70332966917--3c5150fdd35a49cc8a5fba96c3a2fcbe 4f34d28c7dc6488cab7fe12ed4e58da1 3c5150fdd35a49cc8a5fba96c3a2fcbe--4f34d28c7dc6488cab7fe12ed4e58da1 7f04c8ca9f544fe0be04d244e69f378f 4f34d28c7dc6488cab7fe12ed4e58da1--7f04c8ca9f544fe0be04d244e69f378f c6b4a309c86849588ed7e21a5127a4d2 7f04c8ca9f544fe0be04d244e69f378f--c6b4a309c86849588ed7e21a5127a4d2 bee2e790eeea4136aa68f765299076d6 c6b4a309c86849588ed7e21a5127a4d2--bee2e790eeea4136aa68f765299076d6 47c1e2ecbf6143c48626c5ed0231d4f1 bee2e790eeea4136aa68f765299076d6--47c1e2ecbf6143c48626c5ed0231d4f1 dc9c1f0f2ae7414fb7a60d73f6b7aabc 47c1e2ecbf6143c48626c5ed0231d4f1--dc9c1f0f2ae7414fb7a60d73f6b7aabc 322bd1ca587d455fb50abe2d2016e463 X dc9c1f0f2ae7414fb7a60d73f6b7aabc--322bd1ca587d455fb50abe2d2016e463 322bd1ca587d455fb50abe2d2016e463--decf02da28b44428aa9d4fa6589dc097 853ca35ab2394e8cb52c9f65ca826949 322bd1ca587d455fb50abe2d2016e463--853ca35ab2394e8cb52c9f65ca826949 5c50dcf7e2a04ab794af5fc1cb9d4b48 853ca35ab2394e8cb52c9f65ca826949--5c50dcf7e2a04ab794af5fc1cb9d4b48 2a1ce93b897e4750a416e93297c84133 5c50dcf7e2a04ab794af5fc1cb9d4b48--2a1ce93b897e4750a416e93297c84133 36e3b25d592c4480a04c7b0b96631670 2a1ce93b897e4750a416e93297c84133--36e3b25d592c4480a04c7b0b96631670 93b0330dadc945f4a03612df323d6b1f 36e3b25d592c4480a04c7b0b96631670--93b0330dadc945f4a03612df323d6b1f df32de2b9825451ea4cfe90897289788 93b0330dadc945f4a03612df323d6b1f--df32de2b9825451ea4cfe90897289788 ab5ecb482bfd46fc8f89393fdf271834 df32de2b9825451ea4cfe90897289788--ab5ecb482bfd46fc8f89393fdf271834 199b4512271f4d7fb57d207acdae3558 ab5ecb482bfd46fc8f89393fdf271834--199b4512271f4d7fb57d207acdae3558 196375c4e7a94b868d4aef7f879b3300 199b4512271f4d7fb57d207acdae3558--196375c4e7a94b868d4aef7f879b3300 7180690d7c704ca7842e56cfd5be35aa 196375c4e7a94b868d4aef7f879b3300--7180690d7c704ca7842e56cfd5be35aa 52cf2a474cf1419f964775e2d5d8b3bb 7180690d7c704ca7842e56cfd5be35aa--52cf2a474cf1419f964775e2d5d8b3bb 82c351a40ed64f75a798f2efa4cd77dc 52cf2a474cf1419f964775e2d5d8b3bb--82c351a40ed64f75a798f2efa4cd77dc 5ffcdabb7f0d4f0bb1aecc8a23c8531f 82c351a40ed64f75a798f2efa4cd77dc--5ffcdabb7f0d4f0bb1aecc8a23c8531f d50b00bb63534bd085b096f07a623344 5ffcdabb7f0d4f0bb1aecc8a23c8531f--d50b00bb63534bd085b096f07a623344 1649baef0b544193a2e4b50fcc2a9eca d50b00bb63534bd085b096f07a623344--1649baef0b544193a2e4b50fcc2a9eca 8b29277980c543139a7c1f1b06d473f0 1649baef0b544193a2e4b50fcc2a9eca--8b29277980c543139a7c1f1b06d473f0 a6628ad6760b4e1f8ba36c70085e08e0 8b29277980c543139a7c1f1b06d473f0--a6628ad6760b4e1f8ba36c70085e08e0 aa3a4e2684624fc98c2b250886ec2fbb a6628ad6760b4e1f8ba36c70085e08e0--aa3a4e2684624fc98c2b250886ec2fbb da189a24d8764c1b8a61ca21943eaeda aa3a4e2684624fc98c2b250886ec2fbb--da189a24d8764c1b8a61ca21943eaeda d6dcffa733384997bae57214c8772e69 da189a24d8764c1b8a61ca21943eaeda--d6dcffa733384997bae57214c8772e69 c48aee9a26ef4c41a0a1126eca6fc236 RX(b13) d6dcffa733384997bae57214c8772e69--c48aee9a26ef4c41a0a1126eca6fc236 c48aee9a26ef4c41a0a1126eca6fc236--7b95b7c21b2343b796e2e655e49e8e1d 6c89098b30ed41e7b27c5e7aaa80c1cf f849e9653cab4745a396a05898030830 0c7cd73b5b2344fdb3c9bd1c7cf3ee93--f849e9653cab4745a396a05898030830 45514ec4298a4dcd8a051c6fca5bc705 5 0c12086ba89a4c858f4e7f20b49d3cad f849e9653cab4745a396a05898030830--0c12086ba89a4c858f4e7f20b49d3cad 36e573ef0ec848859144cfea33273d58 0c12086ba89a4c858f4e7f20b49d3cad--36e573ef0ec848859144cfea33273d58 01e663775041409ca7610c0d22568e4f X 36e573ef0ec848859144cfea33273d58--01e663775041409ca7610c0d22568e4f 01e663775041409ca7610c0d22568e4f--024db4d69efe44a5948e126ce439b325 b49e9b5c526b4446b2204fddb3247a7e 01e663775041409ca7610c0d22568e4f--b49e9b5c526b4446b2204fddb3247a7e c0051b9a4ae14abe84bf30abb88dbe0c b49e9b5c526b4446b2204fddb3247a7e--c0051b9a4ae14abe84bf30abb88dbe0c 63315b2d1163411bb4f402381ebb7109 c0051b9a4ae14abe84bf30abb88dbe0c--63315b2d1163411bb4f402381ebb7109 24c9bc25cdcc4517be0b7326722418c2 63315b2d1163411bb4f402381ebb7109--24c9bc25cdcc4517be0b7326722418c2 49acd053f94a465e9e211abb1d622065 24c9bc25cdcc4517be0b7326722418c2--49acd053f94a465e9e211abb1d622065 340240ba4c1e43d49d51ab4d133eb3c2 49acd053f94a465e9e211abb1d622065--340240ba4c1e43d49d51ab4d133eb3c2 e5432e16cd78412fae62b680e80ea3d8 340240ba4c1e43d49d51ab4d133eb3c2--e5432e16cd78412fae62b680e80ea3d8 e3fd682dfcd4426bb215fbb796d2dcfe X e5432e16cd78412fae62b680e80ea3d8--e3fd682dfcd4426bb215fbb796d2dcfe e3fd682dfcd4426bb215fbb796d2dcfe--144f9cdf216d4341a0506bf60f87fd01 63075f9269de41e1863ba13713b62710 e3fd682dfcd4426bb215fbb796d2dcfe--63075f9269de41e1863ba13713b62710 6a5a4a5525ea439abff789cb3a2d296f 63075f9269de41e1863ba13713b62710--6a5a4a5525ea439abff789cb3a2d296f 0f6195707a984eecac2b96d68c55c2f6 6a5a4a5525ea439abff789cb3a2d296f--0f6195707a984eecac2b96d68c55c2f6 49929a66c62047a18026fc6e53dff820 0f6195707a984eecac2b96d68c55c2f6--49929a66c62047a18026fc6e53dff820 601fe37339984a8eaec26f9deb08b4d4 49929a66c62047a18026fc6e53dff820--601fe37339984a8eaec26f9deb08b4d4 d759099d3d274bffa2e2b3020e25e8ad 601fe37339984a8eaec26f9deb08b4d4--d759099d3d274bffa2e2b3020e25e8ad 47dffd25a32f4e958b629abb3dc51316 X d759099d3d274bffa2e2b3020e25e8ad--47dffd25a32f4e958b629abb3dc51316 47dffd25a32f4e958b629abb3dc51316--e5c2484fa01f478c971bbbc6d7189e67 bfa5a81ec6b84f1096e9e5543a72c078 47dffd25a32f4e958b629abb3dc51316--bfa5a81ec6b84f1096e9e5543a72c078 dccb6daf347740a3afaeef82a0df7232 bfa5a81ec6b84f1096e9e5543a72c078--dccb6daf347740a3afaeef82a0df7232 cf5594b85cfc459eb3cf06c1122118ad dccb6daf347740a3afaeef82a0df7232--cf5594b85cfc459eb3cf06c1122118ad a15f406a4c63496dad49afabf93032ed cf5594b85cfc459eb3cf06c1122118ad--a15f406a4c63496dad49afabf93032ed f31e2416e2e84b7483e0702afdac828b a15f406a4c63496dad49afabf93032ed--f31e2416e2e84b7483e0702afdac828b 4eaca46d5f4e4f3a85aaf9b3495cdd54 X f31e2416e2e84b7483e0702afdac828b--4eaca46d5f4e4f3a85aaf9b3495cdd54 4eaca46d5f4e4f3a85aaf9b3495cdd54--8f7c7c24caf840198122c1da454e287d 717943b9bdb940aba8333ee15e8b412a 4eaca46d5f4e4f3a85aaf9b3495cdd54--717943b9bdb940aba8333ee15e8b412a 2351de01931048378e97a2e187c16910 717943b9bdb940aba8333ee15e8b412a--2351de01931048378e97a2e187c16910 58ab49eb4b3a4ebdb0fc8cb6519902d9 2351de01931048378e97a2e187c16910--58ab49eb4b3a4ebdb0fc8cb6519902d9 fcaeefd535ae43b89ec3977322e92565 58ab49eb4b3a4ebdb0fc8cb6519902d9--fcaeefd535ae43b89ec3977322e92565 21c84ce1c745481b863cf2e47761a886 fcaeefd535ae43b89ec3977322e92565--21c84ce1c745481b863cf2e47761a886 36f1e691e62c4ae9924852b136d1e92e 21c84ce1c745481b863cf2e47761a886--36f1e691e62c4ae9924852b136d1e92e 641ff13c11664a0387e11a2a0965d056 X 36f1e691e62c4ae9924852b136d1e92e--641ff13c11664a0387e11a2a0965d056 641ff13c11664a0387e11a2a0965d056--affc1265220845ffb4f5391409e0fba0 3ba4e3cdbf194d37a18f504c43c65d18 641ff13c11664a0387e11a2a0965d056--3ba4e3cdbf194d37a18f504c43c65d18 de720b492afd4e8898ed4f8d83dfc779 3ba4e3cdbf194d37a18f504c43c65d18--de720b492afd4e8898ed4f8d83dfc779 8ee0ad077a2744448fea02dfbf77a66b de720b492afd4e8898ed4f8d83dfc779--8ee0ad077a2744448fea02dfbf77a66b e2d0f62e3ee44855bbfe2bca1096ea0a 8ee0ad077a2744448fea02dfbf77a66b--e2d0f62e3ee44855bbfe2bca1096ea0a 93672f19a61c4e85ab9bfc58bf477193 e2d0f62e3ee44855bbfe2bca1096ea0a--93672f19a61c4e85ab9bfc58bf477193 ac446929ac684e5893dedc25530e453b 93672f19a61c4e85ab9bfc58bf477193--ac446929ac684e5893dedc25530e453b bc907b644d3a40dabeb908762fdad123 ac446929ac684e5893dedc25530e453b--bc907b644d3a40dabeb908762fdad123 c8c67261c3c7432d9d243133755d9fbe X bc907b644d3a40dabeb908762fdad123--c8c67261c3c7432d9d243133755d9fbe c8c67261c3c7432d9d243133755d9fbe--5ec26975ceb64dd0875e31ffea98a568 bbbc2a4dc01043e497f78f43ff7e0cea c8c67261c3c7432d9d243133755d9fbe--bbbc2a4dc01043e497f78f43ff7e0cea 6e46ff242ba043e1bf532134d0ecd70c bbbc2a4dc01043e497f78f43ff7e0cea--6e46ff242ba043e1bf532134d0ecd70c fe5e3aa48b4d486e8e17430980445fa3 6e46ff242ba043e1bf532134d0ecd70c--fe5e3aa48b4d486e8e17430980445fa3 6c603558771e43afb84754adb8842009 fe5e3aa48b4d486e8e17430980445fa3--6c603558771e43afb84754adb8842009 13b67340b75942b583402cda9073b2a6 6c603558771e43afb84754adb8842009--13b67340b75942b583402cda9073b2a6 799b9ccbbf1a4d80bd9d353f2c1f3115 X 13b67340b75942b583402cda9073b2a6--799b9ccbbf1a4d80bd9d353f2c1f3115 799b9ccbbf1a4d80bd9d353f2c1f3115--9ba3c49ebe8546cdb9954a41dc41fde1 a8e3f343b8da4d57ad3379e68d35db73 799b9ccbbf1a4d80bd9d353f2c1f3115--a8e3f343b8da4d57ad3379e68d35db73 2105c59b42da402ab5ef24277b136f2f a8e3f343b8da4d57ad3379e68d35db73--2105c59b42da402ab5ef24277b136f2f 4f7c89471aa7470d975b4e0ae55059a1 2105c59b42da402ab5ef24277b136f2f--4f7c89471aa7470d975b4e0ae55059a1 68262b9679674f33b41b56fdc88a42e3 4f7c89471aa7470d975b4e0ae55059a1--68262b9679674f33b41b56fdc88a42e3 a4c58b4c3e1f4cc797fd0b85d481ec9b 68262b9679674f33b41b56fdc88a42e3--a4c58b4c3e1f4cc797fd0b85d481ec9b 75695de6b7c94063ae9d4ecec81a78b2 X a4c58b4c3e1f4cc797fd0b85d481ec9b--75695de6b7c94063ae9d4ecec81a78b2 75695de6b7c94063ae9d4ecec81a78b2--d1484ad15bac4a7987a56f26d8605434 10a7bb1ac6e94373bb6a3ec3d8259903 75695de6b7c94063ae9d4ecec81a78b2--10a7bb1ac6e94373bb6a3ec3d8259903 6358d0d28ec64586a67f7ec1d62534cb 10a7bb1ac6e94373bb6a3ec3d8259903--6358d0d28ec64586a67f7ec1d62534cb 4a9786bb45a54ef09c1391f9c83b3699 6358d0d28ec64586a67f7ec1d62534cb--4a9786bb45a54ef09c1391f9c83b3699 64c216de25d148e49f68096911558d89 4a9786bb45a54ef09c1391f9c83b3699--64c216de25d148e49f68096911558d89 83898f6ef1dc47519e136919761534a9 X 64c216de25d148e49f68096911558d89--83898f6ef1dc47519e136919761534a9 83898f6ef1dc47519e136919761534a9--74ab1de36a4842faaad15f4ed48e36b9 b8f415f76a00476c94cd9cef98fa5ae9 83898f6ef1dc47519e136919761534a9--b8f415f76a00476c94cd9cef98fa5ae9 0245fc99ef8f4845ae72d9a21a4a6e7d b8f415f76a00476c94cd9cef98fa5ae9--0245fc99ef8f4845ae72d9a21a4a6e7d 49e8a962904f40a0a9c91a94406d1dff 0245fc99ef8f4845ae72d9a21a4a6e7d--49e8a962904f40a0a9c91a94406d1dff 5a05916b59654244a526086a522802d5 49e8a962904f40a0a9c91a94406d1dff--5a05916b59654244a526086a522802d5 8e99616526844ec884ad8d9fd6d80f8d 5a05916b59654244a526086a522802d5--8e99616526844ec884ad8d9fd6d80f8d 5dcd947102fa41129d1fc79752669e1b 8e99616526844ec884ad8d9fd6d80f8d--5dcd947102fa41129d1fc79752669e1b e89f82812b8143f488ee8ca91b34bd68 5dcd947102fa41129d1fc79752669e1b--e89f82812b8143f488ee8ca91b34bd68 76dc74357b3d4785bb959586b9e93604 X e89f82812b8143f488ee8ca91b34bd68--76dc74357b3d4785bb959586b9e93604 76dc74357b3d4785bb959586b9e93604--3c90fb83e99b4e999fa2b458687e86f8 f89d238fad8d43b7bad2a588ed3f19c2 76dc74357b3d4785bb959586b9e93604--f89d238fad8d43b7bad2a588ed3f19c2 d3939e59114f4072bcaa0c43ce51f8df f89d238fad8d43b7bad2a588ed3f19c2--d3939e59114f4072bcaa0c43ce51f8df b622b18185c94c63b54e59aaa7c76c4c d3939e59114f4072bcaa0c43ce51f8df--b622b18185c94c63b54e59aaa7c76c4c 175dee1aa2414151b9dd657dc8d6d956 b622b18185c94c63b54e59aaa7c76c4c--175dee1aa2414151b9dd657dc8d6d956 77898e22f11c4b64a452087bf665037c 175dee1aa2414151b9dd657dc8d6d956--77898e22f11c4b64a452087bf665037c 3f40768c85f44603b5bbd65c33edbe74 77898e22f11c4b64a452087bf665037c--3f40768c85f44603b5bbd65c33edbe74 2fababb00aec44ef942267cc7a780782 X 3f40768c85f44603b5bbd65c33edbe74--2fababb00aec44ef942267cc7a780782 2fababb00aec44ef942267cc7a780782--22cb504be50c46e38b1c41d5348d865a 5fa62e4b61244274b380f05d47486d64 RZ(-1.0*g0) 2fababb00aec44ef942267cc7a780782--5fa62e4b61244274b380f05d47486d64 7e630110b3b144699d84eeaadc807262 X 5fa62e4b61244274b380f05d47486d64--7e630110b3b144699d84eeaadc807262 7e630110b3b144699d84eeaadc807262--25a36088ca274d7d88dfc072091212e2 a7ba8885007141c1b397d0fc33c59c32 7e630110b3b144699d84eeaadc807262--a7ba8885007141c1b397d0fc33c59c32 a59abc11a0e64c67b5dc1ae650121146 a7ba8885007141c1b397d0fc33c59c32--a59abc11a0e64c67b5dc1ae650121146 c254993e4f0746ee9f61fce92ec097fc X a59abc11a0e64c67b5dc1ae650121146--c254993e4f0746ee9f61fce92ec097fc c254993e4f0746ee9f61fce92ec097fc--de6037747e4a48b585fd4587bdc762f0 2b537112d983400fb8d1f9a81e14e512 c254993e4f0746ee9f61fce92ec097fc--2b537112d983400fb8d1f9a81e14e512 481a58bf610548f899fc15b47c86763e 2b537112d983400fb8d1f9a81e14e512--481a58bf610548f899fc15b47c86763e 00d38cfa186646519fe0d1aedaffdb33 481a58bf610548f899fc15b47c86763e--00d38cfa186646519fe0d1aedaffdb33 09d1de1c60994fd2831bb2eb5784949b 00d38cfa186646519fe0d1aedaffdb33--09d1de1c60994fd2831bb2eb5784949b 0e0da0f717d449ccaea5ceaed568506d 09d1de1c60994fd2831bb2eb5784949b--0e0da0f717d449ccaea5ceaed568506d 9583c655c2984554a7d93505b09c1cd8 X 0e0da0f717d449ccaea5ceaed568506d--9583c655c2984554a7d93505b09c1cd8 9583c655c2984554a7d93505b09c1cd8--5255fe565adf49bd820360bb347f779b bf0d9616318f4a8aa09afb7d98a4249d 9583c655c2984554a7d93505b09c1cd8--bf0d9616318f4a8aa09afb7d98a4249d 5d81f537e3704c759f742c6ccfe21fee X bf0d9616318f4a8aa09afb7d98a4249d--5d81f537e3704c759f742c6ccfe21fee 5d81f537e3704c759f742c6ccfe21fee--39dae64b541446be95f6a5ea185be312 a5a16d0638ae4b17a27b576c1fd65f0b RZ(-1.0*g0) 5d81f537e3704c759f742c6ccfe21fee--a5a16d0638ae4b17a27b576c1fd65f0b 7763c09dc57646289f3304573841629a X a5a16d0638ae4b17a27b576c1fd65f0b--7763c09dc57646289f3304573841629a 7763c09dc57646289f3304573841629a--cd8cec18d1dd465c9689a47b34468791 22f776983e78405ea0565aec4dd895c3 X 7763c09dc57646289f3304573841629a--22f776983e78405ea0565aec4dd895c3 22f776983e78405ea0565aec4dd895c3--5bf1c9beb89745c1bf22cd9285e6547e 173fe8d9a59b4667b42a29839f7ac93a 22f776983e78405ea0565aec4dd895c3--173fe8d9a59b4667b42a29839f7ac93a f85259a6deca44cb886660e6a344a519 173fe8d9a59b4667b42a29839f7ac93a--f85259a6deca44cb886660e6a344a519 98db0def2d014ec982d537290cf4a55e f85259a6deca44cb886660e6a344a519--98db0def2d014ec982d537290cf4a55e 0c807821678d4e3893ec28535db16e76 98db0def2d014ec982d537290cf4a55e--0c807821678d4e3893ec28535db16e76 d4fdb8eb848d42fa9ac3097d8e151956 0c807821678d4e3893ec28535db16e76--d4fdb8eb848d42fa9ac3097d8e151956 0d3319429b4a43f4bd456003f4fd1b79 d4fdb8eb848d42fa9ac3097d8e151956--0d3319429b4a43f4bd456003f4fd1b79 477ab722d52049629c967fb3270566a1 0d3319429b4a43f4bd456003f4fd1b79--477ab722d52049629c967fb3270566a1 49673a46ba7243e390e7a49cf08a3be2 X 477ab722d52049629c967fb3270566a1--49673a46ba7243e390e7a49cf08a3be2 49673a46ba7243e390e7a49cf08a3be2--3a4c32922d2c45bbacf1b54c091c49b0 336bee84942541f39d64de9f29f3cb66 49673a46ba7243e390e7a49cf08a3be2--336bee84942541f39d64de9f29f3cb66 ace5f3b71d1e4a3ca2b6d246a85a2dcd 336bee84942541f39d64de9f29f3cb66--ace5f3b71d1e4a3ca2b6d246a85a2dcd 34a7f4adf4a84b94ab3d14f6e7841bc2 ace5f3b71d1e4a3ca2b6d246a85a2dcd--34a7f4adf4a84b94ab3d14f6e7841bc2 bf576ef7bd7c469f9378c29ea65e8082 34a7f4adf4a84b94ab3d14f6e7841bc2--bf576ef7bd7c469f9378c29ea65e8082 ff5ec41da30147fb8f3381324615408a bf576ef7bd7c469f9378c29ea65e8082--ff5ec41da30147fb8f3381324615408a c02f8ee81f6c407ab4b88ffc46652968 ff5ec41da30147fb8f3381324615408a--c02f8ee81f6c407ab4b88ffc46652968 9c3fae7a50404ab8821f2040fb5f7f78 c02f8ee81f6c407ab4b88ffc46652968--9c3fae7a50404ab8821f2040fb5f7f78 92ee38b71fd6425d84b36965ceb7243e 9c3fae7a50404ab8821f2040fb5f7f78--92ee38b71fd6425d84b36965ceb7243e f961c13e24d64324af5809a8240cbe6a RX(b04) 92ee38b71fd6425d84b36965ceb7243e--f961c13e24d64324af5809a8240cbe6a 6e4d4a62ee7d4991b2f730aa5978e2ab f961c13e24d64324af5809a8240cbe6a--6e4d4a62ee7d4991b2f730aa5978e2ab 52673cc5ae2648439ce562c6f1b1b650 6e4d4a62ee7d4991b2f730aa5978e2ab--52673cc5ae2648439ce562c6f1b1b650 f0f6a1d4ecf2486299ffdcb896f1b190 52673cc5ae2648439ce562c6f1b1b650--f0f6a1d4ecf2486299ffdcb896f1b190 395a89d2dc684e9fbf62c75131eb1ced X f0f6a1d4ecf2486299ffdcb896f1b190--395a89d2dc684e9fbf62c75131eb1ced 395a89d2dc684e9fbf62c75131eb1ced--6551c0236575457bb4a00be974899983 8a34c0fa76d24adab8c5478a6d29f1fe 395a89d2dc684e9fbf62c75131eb1ced--8a34c0fa76d24adab8c5478a6d29f1fe 96be467497bc437e9c27b58b3b18405b 8a34c0fa76d24adab8c5478a6d29f1fe--96be467497bc437e9c27b58b3b18405b c996ff2bdff64b51ba6fc6ef7df173d1 96be467497bc437e9c27b58b3b18405b--c996ff2bdff64b51ba6fc6ef7df173d1 71dca93bcf544332af20a538cb84237d c996ff2bdff64b51ba6fc6ef7df173d1--71dca93bcf544332af20a538cb84237d a02b769afb5d4e71b6266f085231e348 71dca93bcf544332af20a538cb84237d--a02b769afb5d4e71b6266f085231e348 eb541c6991b341078013a818a39fcd87 a02b769afb5d4e71b6266f085231e348--eb541c6991b341078013a818a39fcd87 ba6aa1eb484b4627b54d6b482cd3466b eb541c6991b341078013a818a39fcd87--ba6aa1eb484b4627b54d6b482cd3466b 3129e5bab0c645e0b0bb69cc2e3c32ee X ba6aa1eb484b4627b54d6b482cd3466b--3129e5bab0c645e0b0bb69cc2e3c32ee 3129e5bab0c645e0b0bb69cc2e3c32ee--f3cd0edfba99412fb733a74ecc4a20d8 8da56c2c0feb46e0ba96021b292039e5 3129e5bab0c645e0b0bb69cc2e3c32ee--8da56c2c0feb46e0ba96021b292039e5 28a8e18866ed4721a6e1bdf53faf475b 8da56c2c0feb46e0ba96021b292039e5--28a8e18866ed4721a6e1bdf53faf475b 446145e320f74062871fa390f6c44c4b 28a8e18866ed4721a6e1bdf53faf475b--446145e320f74062871fa390f6c44c4b 79e357fdbb0c48a6a89dd31bb25b8a1a 446145e320f74062871fa390f6c44c4b--79e357fdbb0c48a6a89dd31bb25b8a1a f652ed5eec70413db639f38f72a82926 79e357fdbb0c48a6a89dd31bb25b8a1a--f652ed5eec70413db639f38f72a82926 305be881b75a4b4c93abc46d13b743d1 f652ed5eec70413db639f38f72a82926--305be881b75a4b4c93abc46d13b743d1 deab6da627db40eb86b24134f4270f15 X 305be881b75a4b4c93abc46d13b743d1--deab6da627db40eb86b24134f4270f15 deab6da627db40eb86b24134f4270f15--3cec93d71b0341f7b430fed844c21c45 94ed3459ca7943539649f41d467d7556 deab6da627db40eb86b24134f4270f15--94ed3459ca7943539649f41d467d7556 05f2c3219b854a9f909fbc4f25fbe199 94ed3459ca7943539649f41d467d7556--05f2c3219b854a9f909fbc4f25fbe199 a1bcc74ad3a34f508bfde22aa82a5756 05f2c3219b854a9f909fbc4f25fbe199--a1bcc74ad3a34f508bfde22aa82a5756 917d4011058f48c4b983520315d0744c a1bcc74ad3a34f508bfde22aa82a5756--917d4011058f48c4b983520315d0744c 92d4bac3fb6747578cea24fd03a85b8e 917d4011058f48c4b983520315d0744c--92d4bac3fb6747578cea24fd03a85b8e ff7234d6ee5e4596b8c1cfcffab97505 X 92d4bac3fb6747578cea24fd03a85b8e--ff7234d6ee5e4596b8c1cfcffab97505 ff7234d6ee5e4596b8c1cfcffab97505--a7424ae404fb412887e363f18932a893 2a8ba09c5c40482ba14cb4e312d90f9e ff7234d6ee5e4596b8c1cfcffab97505--2a8ba09c5c40482ba14cb4e312d90f9e b1ae83f72eab488886d8f759bdde2a67 2a8ba09c5c40482ba14cb4e312d90f9e--b1ae83f72eab488886d8f759bdde2a67 4a4a5abe2ae7460b9bdf83b3e3c9c3c5 b1ae83f72eab488886d8f759bdde2a67--4a4a5abe2ae7460b9bdf83b3e3c9c3c5 2d8341b607f4458b8cbf51d6238dcb18 4a4a5abe2ae7460b9bdf83b3e3c9c3c5--2d8341b607f4458b8cbf51d6238dcb18 77d879f0cf67400790d6ae7662381f67 2d8341b607f4458b8cbf51d6238dcb18--77d879f0cf67400790d6ae7662381f67 88fc50d7fb384e1c9e90b5b3516f4e53 77d879f0cf67400790d6ae7662381f67--88fc50d7fb384e1c9e90b5b3516f4e53 3bf8a352eaa044e890f6ea898d6b69cb X 88fc50d7fb384e1c9e90b5b3516f4e53--3bf8a352eaa044e890f6ea898d6b69cb 3bf8a352eaa044e890f6ea898d6b69cb--205ea3bf304c4b5aad0df572bf9547f3 4fa30c49f7a54f9185f47bc439d61f25 3bf8a352eaa044e890f6ea898d6b69cb--4fa30c49f7a54f9185f47bc439d61f25 178f9321e9754898bb560824b8ced8cf 4fa30c49f7a54f9185f47bc439d61f25--178f9321e9754898bb560824b8ced8cf 64d3d796719c4854948aba2d8d0f4ae0 178f9321e9754898bb560824b8ced8cf--64d3d796719c4854948aba2d8d0f4ae0 3bbb91357af24a6caa0d4be31ea4b093 64d3d796719c4854948aba2d8d0f4ae0--3bbb91357af24a6caa0d4be31ea4b093 58777aacdb4f4dea8aa2febb37f716a1 3bbb91357af24a6caa0d4be31ea4b093--58777aacdb4f4dea8aa2febb37f716a1 abc8388b9cf845dca52e97b134e67c14 58777aacdb4f4dea8aa2febb37f716a1--abc8388b9cf845dca52e97b134e67c14 c5c2f77fc56a45ec869118d4e3b975a2 abc8388b9cf845dca52e97b134e67c14--c5c2f77fc56a45ec869118d4e3b975a2 3c6ea19cb0eb498ebdd966d1c60b8ba9 X c5c2f77fc56a45ec869118d4e3b975a2--3c6ea19cb0eb498ebdd966d1c60b8ba9 3c6ea19cb0eb498ebdd966d1c60b8ba9--21335b15e1734875be4a3a216ff6aac6 89fc4af8734b4eacb0549e189e2257e4 3c6ea19cb0eb498ebdd966d1c60b8ba9--89fc4af8734b4eacb0549e189e2257e4 eddd7ad5190f4e9b9af631773f1dd735 89fc4af8734b4eacb0549e189e2257e4--eddd7ad5190f4e9b9af631773f1dd735 0917871bacb14bc68c409c3a0d7c2db7 eddd7ad5190f4e9b9af631773f1dd735--0917871bacb14bc68c409c3a0d7c2db7 347791236f8b494c8adb51d6f4ba3d53 0917871bacb14bc68c409c3a0d7c2db7--347791236f8b494c8adb51d6f4ba3d53 3b21e95ef9b442afa966251ab5ab96bc 347791236f8b494c8adb51d6f4ba3d53--3b21e95ef9b442afa966251ab5ab96bc a911d2b03d2b475b93f25f999ce36288 X 3b21e95ef9b442afa966251ab5ab96bc--a911d2b03d2b475b93f25f999ce36288 a911d2b03d2b475b93f25f999ce36288--958d0dcdd73d491e8d41477f2d070243 4ea39c20964d474f95d8f85ad0694e73 a911d2b03d2b475b93f25f999ce36288--4ea39c20964d474f95d8f85ad0694e73 f7a72785c3d54ae99c04326a5d1e0437 4ea39c20964d474f95d8f85ad0694e73--f7a72785c3d54ae99c04326a5d1e0437 09e7bf3f4f214ff1af4ab5560ef217fc f7a72785c3d54ae99c04326a5d1e0437--09e7bf3f4f214ff1af4ab5560ef217fc bde49774501b4d1094916e2236fbd3ad 09e7bf3f4f214ff1af4ab5560ef217fc--bde49774501b4d1094916e2236fbd3ad 03f3631d16b44ef99ac1803c9a0fa38f bde49774501b4d1094916e2236fbd3ad--03f3631d16b44ef99ac1803c9a0fa38f 4c9697edea954500ab23414b3f1286e0 X 03f3631d16b44ef99ac1803c9a0fa38f--4c9697edea954500ab23414b3f1286e0 4c9697edea954500ab23414b3f1286e0--132de757168b4d56b4e74453c8689c4a ce0e5532e84d42cb92b97a7e94468efe 4c9697edea954500ab23414b3f1286e0--ce0e5532e84d42cb92b97a7e94468efe b3bc9111169c4b34a0c9aa663e22a446 ce0e5532e84d42cb92b97a7e94468efe--b3bc9111169c4b34a0c9aa663e22a446 ec8ddd8bbc574193a559c41792ae4c61 b3bc9111169c4b34a0c9aa663e22a446--ec8ddd8bbc574193a559c41792ae4c61 df16a8ca9f0e40828a9d182642f37000 ec8ddd8bbc574193a559c41792ae4c61--df16a8ca9f0e40828a9d182642f37000 c0572d39bfc946d1ae563a7717807af3 X df16a8ca9f0e40828a9d182642f37000--c0572d39bfc946d1ae563a7717807af3 c0572d39bfc946d1ae563a7717807af3--576edeba96324844b8538e5547c7f59a c44fdb2b904646ee825a10314e76e2c1 c0572d39bfc946d1ae563a7717807af3--c44fdb2b904646ee825a10314e76e2c1 e5c815abf17548ccab8a3bb82f6ee9eb c44fdb2b904646ee825a10314e76e2c1--e5c815abf17548ccab8a3bb82f6ee9eb 12978c2ae9ab457697e5414aa4ae14fd e5c815abf17548ccab8a3bb82f6ee9eb--12978c2ae9ab457697e5414aa4ae14fd 72bda0b605514fd685047c939ca8fcd7 12978c2ae9ab457697e5414aa4ae14fd--72bda0b605514fd685047c939ca8fcd7 52e89b87b1fc4e229b6b7dfe202f6975 72bda0b605514fd685047c939ca8fcd7--52e89b87b1fc4e229b6b7dfe202f6975 04134776060640fbbfa542d6c7daa4e4 52e89b87b1fc4e229b6b7dfe202f6975--04134776060640fbbfa542d6c7daa4e4 e73c0cc23bf24f258db0b449cc8d11b0 04134776060640fbbfa542d6c7daa4e4--e73c0cc23bf24f258db0b449cc8d11b0 8dfb4c86789642709babc3681a7169a7 X e73c0cc23bf24f258db0b449cc8d11b0--8dfb4c86789642709babc3681a7169a7 8dfb4c86789642709babc3681a7169a7--b9eae0772d2c402181189b06777737f4 a7cca3692f574c98a2f6609b8f1d0f6a 8dfb4c86789642709babc3681a7169a7--a7cca3692f574c98a2f6609b8f1d0f6a dbed77f5ec1640788282552b97412dbb a7cca3692f574c98a2f6609b8f1d0f6a--dbed77f5ec1640788282552b97412dbb fea85531532b483596942c6ac06f4db9 dbed77f5ec1640788282552b97412dbb--fea85531532b483596942c6ac06f4db9 e3603c32c2e84d4ab0c06a75da974d05 fea85531532b483596942c6ac06f4db9--e3603c32c2e84d4ab0c06a75da974d05 5cb6758886384a3fb2003f40e2ba2583 e3603c32c2e84d4ab0c06a75da974d05--5cb6758886384a3fb2003f40e2ba2583 79e256ffc921497f93bf554fdc5f1bdd 5cb6758886384a3fb2003f40e2ba2583--79e256ffc921497f93bf554fdc5f1bdd f9ef002567814ae69201bc0ef8471eb3 X 79e256ffc921497f93bf554fdc5f1bdd--f9ef002567814ae69201bc0ef8471eb3 f9ef002567814ae69201bc0ef8471eb3--8fa2d8bbe7d44574916af994bf8fe0a7 fdb03c27a8fb4a9397996dfc2367fa9c RZ(-1.0*g1) f9ef002567814ae69201bc0ef8471eb3--fdb03c27a8fb4a9397996dfc2367fa9c caf7d0cf034f4c79ad9d31e0735970e4 X fdb03c27a8fb4a9397996dfc2367fa9c--caf7d0cf034f4c79ad9d31e0735970e4 caf7d0cf034f4c79ad9d31e0735970e4--a0f9c46288534921b4c5bbf07ce79b50 4e6c065f6c1b41f3855a86369aca0335 caf7d0cf034f4c79ad9d31e0735970e4--4e6c065f6c1b41f3855a86369aca0335 b2598ffb2994472d8285ff2217fb6f6c 4e6c065f6c1b41f3855a86369aca0335--b2598ffb2994472d8285ff2217fb6f6c a10f821797f54083ab367f9aa201372a X b2598ffb2994472d8285ff2217fb6f6c--a10f821797f54083ab367f9aa201372a a10f821797f54083ab367f9aa201372a--3c5150fdd35a49cc8a5fba96c3a2fcbe bc87c30597e24c08a874a8a2d0380fff a10f821797f54083ab367f9aa201372a--bc87c30597e24c08a874a8a2d0380fff 444bafaddd684f5f81b5dc6b1912e8de bc87c30597e24c08a874a8a2d0380fff--444bafaddd684f5f81b5dc6b1912e8de 7189e98a139249fcbf5c641b3ac1b4c6 444bafaddd684f5f81b5dc6b1912e8de--7189e98a139249fcbf5c641b3ac1b4c6 19f94675a90d413ea1082e7494204e46 7189e98a139249fcbf5c641b3ac1b4c6--19f94675a90d413ea1082e7494204e46 092f74f6649c40af86eb525b441b6c40 19f94675a90d413ea1082e7494204e46--092f74f6649c40af86eb525b441b6c40 3b88ebad75774ca8b18b0089febf0077 X 092f74f6649c40af86eb525b441b6c40--3b88ebad75774ca8b18b0089febf0077 3b88ebad75774ca8b18b0089febf0077--dc9c1f0f2ae7414fb7a60d73f6b7aabc 46f66d4d096f4066810427dfbe09c4af 3b88ebad75774ca8b18b0089febf0077--46f66d4d096f4066810427dfbe09c4af 08dbe189e6f248d4a942ef424e372191 X 46f66d4d096f4066810427dfbe09c4af--08dbe189e6f248d4a942ef424e372191 08dbe189e6f248d4a942ef424e372191--853ca35ab2394e8cb52c9f65ca826949 cf964eba8b9b45e3bea0411e92173c49 RZ(-1.0*g1) 08dbe189e6f248d4a942ef424e372191--cf964eba8b9b45e3bea0411e92173c49 addf9f21e73844b29c72148a5d6ceb23 X cf964eba8b9b45e3bea0411e92173c49--addf9f21e73844b29c72148a5d6ceb23 addf9f21e73844b29c72148a5d6ceb23--2a1ce93b897e4750a416e93297c84133 a9d42f6ed2c8402687b74f724f7bfc55 X addf9f21e73844b29c72148a5d6ceb23--a9d42f6ed2c8402687b74f724f7bfc55 a9d42f6ed2c8402687b74f724f7bfc55--36e3b25d592c4480a04c7b0b96631670 77130157bc5c4b63a6c5dfecc6a7a889 a9d42f6ed2c8402687b74f724f7bfc55--77130157bc5c4b63a6c5dfecc6a7a889 b7e4fb7c293c46d7bc3caa378d8f6381 77130157bc5c4b63a6c5dfecc6a7a889--b7e4fb7c293c46d7bc3caa378d8f6381 d38636557a014774a0b5efa6281106ef b7e4fb7c293c46d7bc3caa378d8f6381--d38636557a014774a0b5efa6281106ef 0f99a235b64c47188603879ecf8f3184 d38636557a014774a0b5efa6281106ef--0f99a235b64c47188603879ecf8f3184 de30e976658d48b88d85a2bfe943492f 0f99a235b64c47188603879ecf8f3184--de30e976658d48b88d85a2bfe943492f f084c527b42b462090a5eeff6634c46b de30e976658d48b88d85a2bfe943492f--f084c527b42b462090a5eeff6634c46b 25730495a97b459286fc27e1345fb4ca f084c527b42b462090a5eeff6634c46b--25730495a97b459286fc27e1345fb4ca b0ce49ccbe9e4b19b812ee6cbeb61917 X 25730495a97b459286fc27e1345fb4ca--b0ce49ccbe9e4b19b812ee6cbeb61917 b0ce49ccbe9e4b19b812ee6cbeb61917--82c351a40ed64f75a798f2efa4cd77dc bdc7a030a9d340828c87f7ed3dd31458 b0ce49ccbe9e4b19b812ee6cbeb61917--bdc7a030a9d340828c87f7ed3dd31458 a5ff3912e105415690c05fdaf58d8b2a bdc7a030a9d340828c87f7ed3dd31458--a5ff3912e105415690c05fdaf58d8b2a 1a5d62b61b2e40199e09f9b2f6ca23a0 a5ff3912e105415690c05fdaf58d8b2a--1a5d62b61b2e40199e09f9b2f6ca23a0 0ab8e2a86da14b0d9d1330d37b63bfbc 1a5d62b61b2e40199e09f9b2f6ca23a0--0ab8e2a86da14b0d9d1330d37b63bfbc edf39d429bc143248ec9ed153beadfa5 0ab8e2a86da14b0d9d1330d37b63bfbc--edf39d429bc143248ec9ed153beadfa5 719316306f3645b0ba58f06e4c1f6c97 edf39d429bc143248ec9ed153beadfa5--719316306f3645b0ba58f06e4c1f6c97 06575192f4cc4e96ba59c85a2a7f241b 719316306f3645b0ba58f06e4c1f6c97--06575192f4cc4e96ba59c85a2a7f241b 36e67b73021f4473a5190bf71aa25a01 06575192f4cc4e96ba59c85a2a7f241b--36e67b73021f4473a5190bf71aa25a01 eb4c62c9565c4fc397b020b0c480b23f RX(b14) 36e67b73021f4473a5190bf71aa25a01--eb4c62c9565c4fc397b020b0c480b23f eb4c62c9565c4fc397b020b0c480b23f--6c89098b30ed41e7b27c5e7aaa80c1cf 7d2d42798fef40299a632890448ab020 f4ed0fea9e934daeafa7b08e16e5695e 45514ec4298a4dcd8a051c6fca5bc705--f4ed0fea9e934daeafa7b08e16e5695e 64822dfc42694862a57f1c30b2c0e9b7 6 b70f559b3c2e43d3b3913cd637b5c605 f4ed0fea9e934daeafa7b08e16e5695e--b70f559b3c2e43d3b3913cd637b5c605 3208b76f74264a6cb23072ca7edbfad3 b70f559b3c2e43d3b3913cd637b5c605--3208b76f74264a6cb23072ca7edbfad3 e7e4b32faf384ad8965a485e0c0324c8 3208b76f74264a6cb23072ca7edbfad3--e7e4b32faf384ad8965a485e0c0324c8 13c8f6d9add145dd8b63859d4ae460c3 X e7e4b32faf384ad8965a485e0c0324c8--13c8f6d9add145dd8b63859d4ae460c3 13c8f6d9add145dd8b63859d4ae460c3--b49e9b5c526b4446b2204fddb3247a7e 081c061d5ea5485da9fcee51ca82981f 13c8f6d9add145dd8b63859d4ae460c3--081c061d5ea5485da9fcee51ca82981f 75091435b1f0449fb3bc5e7f081f4863 081c061d5ea5485da9fcee51ca82981f--75091435b1f0449fb3bc5e7f081f4863 fad082931d044fafab97056f9ece9256 75091435b1f0449fb3bc5e7f081f4863--fad082931d044fafab97056f9ece9256 353d615267634196839418d2a096a2c3 fad082931d044fafab97056f9ece9256--353d615267634196839418d2a096a2c3 86778da1c9a2406b8bf57d3036636139 353d615267634196839418d2a096a2c3--86778da1c9a2406b8bf57d3036636139 a295769cfd004eaea85f4d4592e0b01a X 86778da1c9a2406b8bf57d3036636139--a295769cfd004eaea85f4d4592e0b01a a295769cfd004eaea85f4d4592e0b01a--e5432e16cd78412fae62b680e80ea3d8 fd9315edf6214092a7a5e5fa8ed92f7b a295769cfd004eaea85f4d4592e0b01a--fd9315edf6214092a7a5e5fa8ed92f7b 9bfa67da38cc43a69b243fce51e5a706 fd9315edf6214092a7a5e5fa8ed92f7b--9bfa67da38cc43a69b243fce51e5a706 da182bcfb4ca48ad9532c1ad759cf16c 9bfa67da38cc43a69b243fce51e5a706--da182bcfb4ca48ad9532c1ad759cf16c 4c18e8d299014533adbb9bbaaf6c7d91 da182bcfb4ca48ad9532c1ad759cf16c--4c18e8d299014533adbb9bbaaf6c7d91 6a975351076b4585aafc4966b2e6e2d9 4c18e8d299014533adbb9bbaaf6c7d91--6a975351076b4585aafc4966b2e6e2d9 dacd205fef6a4502b7938d2d6c5f800f 6a975351076b4585aafc4966b2e6e2d9--dacd205fef6a4502b7938d2d6c5f800f c70437f606264567b3709eaf05002b2c dacd205fef6a4502b7938d2d6c5f800f--c70437f606264567b3709eaf05002b2c a2ee8b8a0adc4c18a1fe937f9a3abef7 c70437f606264567b3709eaf05002b2c--a2ee8b8a0adc4c18a1fe937f9a3abef7 2ba21e707d3a4990b86f4d97a210c8ad X a2ee8b8a0adc4c18a1fe937f9a3abef7--2ba21e707d3a4990b86f4d97a210c8ad 2ba21e707d3a4990b86f4d97a210c8ad--bfa5a81ec6b84f1096e9e5543a72c078 5e1ff15729ab4221bd08fca945bf8652 2ba21e707d3a4990b86f4d97a210c8ad--5e1ff15729ab4221bd08fca945bf8652 b9768040426a44a0942d002db964c1c5 5e1ff15729ab4221bd08fca945bf8652--b9768040426a44a0942d002db964c1c5 3c2bddc7fc92482bbe99b7643a954506 b9768040426a44a0942d002db964c1c5--3c2bddc7fc92482bbe99b7643a954506 dfe3bbdb7a984ce58092950d0670f78a X 3c2bddc7fc92482bbe99b7643a954506--dfe3bbdb7a984ce58092950d0670f78a dfe3bbdb7a984ce58092950d0670f78a--f31e2416e2e84b7483e0702afdac828b 2517a97315fe48d789d40f807e84fec1 dfe3bbdb7a984ce58092950d0670f78a--2517a97315fe48d789d40f807e84fec1 9870709ed72443278c95973f14875a55 2517a97315fe48d789d40f807e84fec1--9870709ed72443278c95973f14875a55 f78329ab048649c88b9a1dc81c97028e 9870709ed72443278c95973f14875a55--f78329ab048649c88b9a1dc81c97028e 0b5ed4247e3649059c4c25c9bf316ead f78329ab048649c88b9a1dc81c97028e--0b5ed4247e3649059c4c25c9bf316ead 368dbce6d732463689719abe35fd67fc 0b5ed4247e3649059c4c25c9bf316ead--368dbce6d732463689719abe35fd67fc 41e7194514544df9935e276cc43cd67b 368dbce6d732463689719abe35fd67fc--41e7194514544df9935e276cc43cd67b 6a79f39f989e4fafbb54fc9636eab48d 41e7194514544df9935e276cc43cd67b--6a79f39f989e4fafbb54fc9636eab48d 03a02f925b054ddb9716d68e63aa4116 6a79f39f989e4fafbb54fc9636eab48d--03a02f925b054ddb9716d68e63aa4116 97bbecb5b745460c8b8978ccc2610742 X 03a02f925b054ddb9716d68e63aa4116--97bbecb5b745460c8b8978ccc2610742 97bbecb5b745460c8b8978ccc2610742--3ba4e3cdbf194d37a18f504c43c65d18 1ac16bc7f5d84df6b01b595b07fb3bf4 97bbecb5b745460c8b8978ccc2610742--1ac16bc7f5d84df6b01b595b07fb3bf4 7b51f8d5238c4f7fbbef8b81ae2f7c38 1ac16bc7f5d84df6b01b595b07fb3bf4--7b51f8d5238c4f7fbbef8b81ae2f7c38 acd62ccd3ade4caeaafb3edd527fe9a6 7b51f8d5238c4f7fbbef8b81ae2f7c38--acd62ccd3ade4caeaafb3edd527fe9a6 8a12420f0974422c8e929439774a6477 acd62ccd3ade4caeaafb3edd527fe9a6--8a12420f0974422c8e929439774a6477 e4ffc02d16034e21a2971354f16ef758 8a12420f0974422c8e929439774a6477--e4ffc02d16034e21a2971354f16ef758 ecc8184737324659a07e56c19788786d X e4ffc02d16034e21a2971354f16ef758--ecc8184737324659a07e56c19788786d ecc8184737324659a07e56c19788786d--bc907b644d3a40dabeb908762fdad123 7a2de8e2b7a344958e0cc28f070d41eb ecc8184737324659a07e56c19788786d--7a2de8e2b7a344958e0cc28f070d41eb 7c6d4e94e55b45b6afc401f48ac15f18 7a2de8e2b7a344958e0cc28f070d41eb--7c6d4e94e55b45b6afc401f48ac15f18 40ddf2af9f6146049bfe1b8ef79bcc85 7c6d4e94e55b45b6afc401f48ac15f18--40ddf2af9f6146049bfe1b8ef79bcc85 e5414a192fd842cb8cdcbf69d9e1ed16 40ddf2af9f6146049bfe1b8ef79bcc85--e5414a192fd842cb8cdcbf69d9e1ed16 26411f7460ca42c78f6556b428e49735 e5414a192fd842cb8cdcbf69d9e1ed16--26411f7460ca42c78f6556b428e49735 543543a6ace74b3fbd6a9c4c0d17ff74 26411f7460ca42c78f6556b428e49735--543543a6ace74b3fbd6a9c4c0d17ff74 71ebfe9e5f1c4dcba23afeebbde01e1b 543543a6ace74b3fbd6a9c4c0d17ff74--71ebfe9e5f1c4dcba23afeebbde01e1b 5aed7dccc47b47539842850e5646035f X 71ebfe9e5f1c4dcba23afeebbde01e1b--5aed7dccc47b47539842850e5646035f 5aed7dccc47b47539842850e5646035f--a8e3f343b8da4d57ad3379e68d35db73 d13a017d790d46d0a254651fa0266e7b 5aed7dccc47b47539842850e5646035f--d13a017d790d46d0a254651fa0266e7b 60f82af5223e4d8483f10298e5f851e9 d13a017d790d46d0a254651fa0266e7b--60f82af5223e4d8483f10298e5f851e9 ca71bcd39acc4c259c70e5674e1eb36e 60f82af5223e4d8483f10298e5f851e9--ca71bcd39acc4c259c70e5674e1eb36e 4a884152cbe34a6180e3f5b3d2539863 X ca71bcd39acc4c259c70e5674e1eb36e--4a884152cbe34a6180e3f5b3d2539863 4a884152cbe34a6180e3f5b3d2539863--a4c58b4c3e1f4cc797fd0b85d481ec9b 2caa59accfcf4c47ad8da20fd358a9a1 4a884152cbe34a6180e3f5b3d2539863--2caa59accfcf4c47ad8da20fd358a9a1 ba9556c68c8046e3bbedab7f397f8f74 2caa59accfcf4c47ad8da20fd358a9a1--ba9556c68c8046e3bbedab7f397f8f74 355b5472cb9a486f8d641f54c7549afa ba9556c68c8046e3bbedab7f397f8f74--355b5472cb9a486f8d641f54c7549afa 40b387f41c3e47fe83e6f4d87cc6f529 355b5472cb9a486f8d641f54c7549afa--40b387f41c3e47fe83e6f4d87cc6f529 49b5fed1e9744fe68383e42539ac117f 40b387f41c3e47fe83e6f4d87cc6f529--49b5fed1e9744fe68383e42539ac117f 3e42483710124513a59167cf7e3c1934 49b5fed1e9744fe68383e42539ac117f--3e42483710124513a59167cf7e3c1934 b088d96dec55454eb237f156cb66ac4d X 3e42483710124513a59167cf7e3c1934--b088d96dec55454eb237f156cb66ac4d b088d96dec55454eb237f156cb66ac4d--b8f415f76a00476c94cd9cef98fa5ae9 7512aa6d3aff4f80827c6cedbb257da8 b088d96dec55454eb237f156cb66ac4d--7512aa6d3aff4f80827c6cedbb257da8 ed50596708de47d992c5eb1342e2f41a 7512aa6d3aff4f80827c6cedbb257da8--ed50596708de47d992c5eb1342e2f41a fcadd4da92284129ae56d529c3fa092d ed50596708de47d992c5eb1342e2f41a--fcadd4da92284129ae56d529c3fa092d 7d501889b51e4bc383c23d9b5f0d248f fcadd4da92284129ae56d529c3fa092d--7d501889b51e4bc383c23d9b5f0d248f d3c72154d1564109a2331039c2837b55 7d501889b51e4bc383c23d9b5f0d248f--d3c72154d1564109a2331039c2837b55 b47b3dfcb52f44fe8498c96a34aa65c6 X d3c72154d1564109a2331039c2837b55--b47b3dfcb52f44fe8498c96a34aa65c6 b47b3dfcb52f44fe8498c96a34aa65c6--e89f82812b8143f488ee8ca91b34bd68 f800ff0b4cea4f53a1f99356d63da1d4 b47b3dfcb52f44fe8498c96a34aa65c6--f800ff0b4cea4f53a1f99356d63da1d4 0a0f1a5e1d6a483d8dda01b19e58b02a f800ff0b4cea4f53a1f99356d63da1d4--0a0f1a5e1d6a483d8dda01b19e58b02a b53518a045964bd38b32c3106916e41f 0a0f1a5e1d6a483d8dda01b19e58b02a--b53518a045964bd38b32c3106916e41f 9b34ed5868484e56aa35188f24bf411b b53518a045964bd38b32c3106916e41f--9b34ed5868484e56aa35188f24bf411b ffce54e6eb2346d18f1e959fefd1ab7b 9b34ed5868484e56aa35188f24bf411b--ffce54e6eb2346d18f1e959fefd1ab7b 732c83da6a004bc8bfe253d7475cf6d2 ffce54e6eb2346d18f1e959fefd1ab7b--732c83da6a004bc8bfe253d7475cf6d2 20af1098f2aa48418c222d91f6a3a494 732c83da6a004bc8bfe253d7475cf6d2--20af1098f2aa48418c222d91f6a3a494 79539b2f4d354138b378543c964c8961 20af1098f2aa48418c222d91f6a3a494--79539b2f4d354138b378543c964c8961 79dcaa156b8a498fb8fd7f290954cc16 79539b2f4d354138b378543c964c8961--79dcaa156b8a498fb8fd7f290954cc16 949665d44f864667b40eacd6ae0e66ba 79dcaa156b8a498fb8fd7f290954cc16--949665d44f864667b40eacd6ae0e66ba cc1d685707f547f6b837b8ce317f29c7 949665d44f864667b40eacd6ae0e66ba--cc1d685707f547f6b837b8ce317f29c7 61fff5e713384397a39e142368677dd3 cc1d685707f547f6b837b8ce317f29c7--61fff5e713384397a39e142368677dd3 b05bc631df3a4e2d91218066a82956b0 61fff5e713384397a39e142368677dd3--b05bc631df3a4e2d91218066a82956b0 a0d2e0d1a4e5460f88c08da312938938 X b05bc631df3a4e2d91218066a82956b0--a0d2e0d1a4e5460f88c08da312938938 a0d2e0d1a4e5460f88c08da312938938--2b537112d983400fb8d1f9a81e14e512 097c7eabd17c47db9105385ea4090070 a0d2e0d1a4e5460f88c08da312938938--097c7eabd17c47db9105385ea4090070 1514fedd1d164f8ba77e0ac136fe9bc0 097c7eabd17c47db9105385ea4090070--1514fedd1d164f8ba77e0ac136fe9bc0 7bcc5a02499c40298bd6cf99012c5541 1514fedd1d164f8ba77e0ac136fe9bc0--7bcc5a02499c40298bd6cf99012c5541 32dd6c6b839d492ba292bb27b9d4868d X 7bcc5a02499c40298bd6cf99012c5541--32dd6c6b839d492ba292bb27b9d4868d 32dd6c6b839d492ba292bb27b9d4868d--0e0da0f717d449ccaea5ceaed568506d ca7b05ac9fb9458da6e29442e9bfeafd 32dd6c6b839d492ba292bb27b9d4868d--ca7b05ac9fb9458da6e29442e9bfeafd fe5795f9645c4b50be8f3e9a6a729fb1 ca7b05ac9fb9458da6e29442e9bfeafd--fe5795f9645c4b50be8f3e9a6a729fb1 d46f3c579292494ca480be003686381f fe5795f9645c4b50be8f3e9a6a729fb1--d46f3c579292494ca480be003686381f 3e94c172b19142d3a438124cc32361a3 d46f3c579292494ca480be003686381f--3e94c172b19142d3a438124cc32361a3 e0b0de6cc5144559828f09e023944e1a 3e94c172b19142d3a438124cc32361a3--e0b0de6cc5144559828f09e023944e1a 214dcf09bdac47c4afc8692da9392cd6 e0b0de6cc5144559828f09e023944e1a--214dcf09bdac47c4afc8692da9392cd6 a42fc32af5ba469c88a58053f891e9ee X 214dcf09bdac47c4afc8692da9392cd6--a42fc32af5ba469c88a58053f891e9ee a42fc32af5ba469c88a58053f891e9ee--173fe8d9a59b4667b42a29839f7ac93a ce16954d36e4412eac73f7d2b6563445 a42fc32af5ba469c88a58053f891e9ee--ce16954d36e4412eac73f7d2b6563445 aa8b3ff762aa4e028d5404120a8fd14c ce16954d36e4412eac73f7d2b6563445--aa8b3ff762aa4e028d5404120a8fd14c 3eb7dcba91ea4b05a68e0d2e97f67605 aa8b3ff762aa4e028d5404120a8fd14c--3eb7dcba91ea4b05a68e0d2e97f67605 7edd805ccfad4920a9e2e26922003e89 3eb7dcba91ea4b05a68e0d2e97f67605--7edd805ccfad4920a9e2e26922003e89 3959dd56593b47a88a4dc3048076077f 7edd805ccfad4920a9e2e26922003e89--3959dd56593b47a88a4dc3048076077f f34e2ff4bf6345c683a8d782dc5eeff3 X 3959dd56593b47a88a4dc3048076077f--f34e2ff4bf6345c683a8d782dc5eeff3 f34e2ff4bf6345c683a8d782dc5eeff3--477ab722d52049629c967fb3270566a1 313f6eec434141faa3ffab27fa8ebfa5 f34e2ff4bf6345c683a8d782dc5eeff3--313f6eec434141faa3ffab27fa8ebfa5 fada7e090e5d441184f5c581ea7be068 X 313f6eec434141faa3ffab27fa8ebfa5--fada7e090e5d441184f5c581ea7be068 fada7e090e5d441184f5c581ea7be068--336bee84942541f39d64de9f29f3cb66 6957f6d5298f468a876719fd579b0da2 fada7e090e5d441184f5c581ea7be068--6957f6d5298f468a876719fd579b0da2 5542361748b345eda86c105a64988efe 6957f6d5298f468a876719fd579b0da2--5542361748b345eda86c105a64988efe f8743112a74940fb83629335f27549d5 5542361748b345eda86c105a64988efe--f8743112a74940fb83629335f27549d5 9213295f4fb64a9a8189f795493e6bf8 X f8743112a74940fb83629335f27549d5--9213295f4fb64a9a8189f795493e6bf8 9213295f4fb64a9a8189f795493e6bf8--ff5ec41da30147fb8f3381324615408a 83f48d9bd3644695baf8ac70217f9201 9213295f4fb64a9a8189f795493e6bf8--83f48d9bd3644695baf8ac70217f9201 a9bde4ee8bf94cc6a8248c45e6e7a1d3 83f48d9bd3644695baf8ac70217f9201--a9bde4ee8bf94cc6a8248c45e6e7a1d3 eba37815b65a4c3db6d485c98cc0b47c a9bde4ee8bf94cc6a8248c45e6e7a1d3--eba37815b65a4c3db6d485c98cc0b47c 76b1de487b5c480f8cd3c7b374379e69 RX(b05) eba37815b65a4c3db6d485c98cc0b47c--76b1de487b5c480f8cd3c7b374379e69 f2d04442e1d741bd98bd10bbc9360b28 76b1de487b5c480f8cd3c7b374379e69--f2d04442e1d741bd98bd10bbc9360b28 104ecaed62864694a6d7d5573f632bd5 f2d04442e1d741bd98bd10bbc9360b28--104ecaed62864694a6d7d5573f632bd5 adb98318be1548299de5ac37c9242d47 104ecaed62864694a6d7d5573f632bd5--adb98318be1548299de5ac37c9242d47 45c7355147d142dfb3005edaddd0be3b adb98318be1548299de5ac37c9242d47--45c7355147d142dfb3005edaddd0be3b 9f5f9f9ba3734e4d8a8aadc28b6bfbfa X 45c7355147d142dfb3005edaddd0be3b--9f5f9f9ba3734e4d8a8aadc28b6bfbfa 9f5f9f9ba3734e4d8a8aadc28b6bfbfa--8a34c0fa76d24adab8c5478a6d29f1fe 02539484fe284efe949c5e51f6cc05c5 9f5f9f9ba3734e4d8a8aadc28b6bfbfa--02539484fe284efe949c5e51f6cc05c5 66762d4868114a4ea583120f1f00287a 02539484fe284efe949c5e51f6cc05c5--66762d4868114a4ea583120f1f00287a 814eeb2508c748faa62eefc08f86bf2c 66762d4868114a4ea583120f1f00287a--814eeb2508c748faa62eefc08f86bf2c 9021263123964837aad992ebeebaec27 814eeb2508c748faa62eefc08f86bf2c--9021263123964837aad992ebeebaec27 fb51873e70c04d81984e4befc63e0844 9021263123964837aad992ebeebaec27--fb51873e70c04d81984e4befc63e0844 1350da871d0c41e09962c1967dad9071 X fb51873e70c04d81984e4befc63e0844--1350da871d0c41e09962c1967dad9071 1350da871d0c41e09962c1967dad9071--ba6aa1eb484b4627b54d6b482cd3466b 8ec81444997943b2ad18aa16a2805b2f 1350da871d0c41e09962c1967dad9071--8ec81444997943b2ad18aa16a2805b2f d74457bbaecb43c192f57c26556005c6 8ec81444997943b2ad18aa16a2805b2f--d74457bbaecb43c192f57c26556005c6 34390255cafa412fa63b37429ce6c176 d74457bbaecb43c192f57c26556005c6--34390255cafa412fa63b37429ce6c176 87e5bb0cfcfd4984b13e4276b7239c7b 34390255cafa412fa63b37429ce6c176--87e5bb0cfcfd4984b13e4276b7239c7b 3f4c810499084c51a4aa20688f029109 87e5bb0cfcfd4984b13e4276b7239c7b--3f4c810499084c51a4aa20688f029109 59b1e1ebdd244259b05ac84ff206f8fe 3f4c810499084c51a4aa20688f029109--59b1e1ebdd244259b05ac84ff206f8fe 5a58f326536745c6aea03c5d23c8f1df 59b1e1ebdd244259b05ac84ff206f8fe--5a58f326536745c6aea03c5d23c8f1df dfde3690355a40fea214609b3c42b949 5a58f326536745c6aea03c5d23c8f1df--dfde3690355a40fea214609b3c42b949 596915166823471c95d6a6b5684dea32 X dfde3690355a40fea214609b3c42b949--596915166823471c95d6a6b5684dea32 596915166823471c95d6a6b5684dea32--94ed3459ca7943539649f41d467d7556 43a668e2822a4dac8befa3be221d2f4f 596915166823471c95d6a6b5684dea32--43a668e2822a4dac8befa3be221d2f4f bd8739bea7624c7d9ef027d0c1894373 43a668e2822a4dac8befa3be221d2f4f--bd8739bea7624c7d9ef027d0c1894373 122ce862d89642d59c4e23686a2d919a bd8739bea7624c7d9ef027d0c1894373--122ce862d89642d59c4e23686a2d919a 95c1a6ae190f4299a54e4682810bbdd0 X 122ce862d89642d59c4e23686a2d919a--95c1a6ae190f4299a54e4682810bbdd0 95c1a6ae190f4299a54e4682810bbdd0--92d4bac3fb6747578cea24fd03a85b8e 0b97bbaa99c8479786ebbf30ad5a2e46 95c1a6ae190f4299a54e4682810bbdd0--0b97bbaa99c8479786ebbf30ad5a2e46 95be2c68b8cb435b885ef5ac70a1c2b0 0b97bbaa99c8479786ebbf30ad5a2e46--95be2c68b8cb435b885ef5ac70a1c2b0 653a14f902384f61b1cbf8127bca0835 95be2c68b8cb435b885ef5ac70a1c2b0--653a14f902384f61b1cbf8127bca0835 8be5040850a744fea9bbcb1b19d532e2 653a14f902384f61b1cbf8127bca0835--8be5040850a744fea9bbcb1b19d532e2 319bed04510c4330bb719e7d1fda112c 8be5040850a744fea9bbcb1b19d532e2--319bed04510c4330bb719e7d1fda112c fd2c4ccd5f0540389600fa2915f2267d 319bed04510c4330bb719e7d1fda112c--fd2c4ccd5f0540389600fa2915f2267d 5347f1d4627e4e78a45faa1e58eb169d fd2c4ccd5f0540389600fa2915f2267d--5347f1d4627e4e78a45faa1e58eb169d 5353327b5f434650bd036ae32da4ad0d 5347f1d4627e4e78a45faa1e58eb169d--5353327b5f434650bd036ae32da4ad0d 9cad6545449d476c967fcdbd5301d759 X 5353327b5f434650bd036ae32da4ad0d--9cad6545449d476c967fcdbd5301d759 9cad6545449d476c967fcdbd5301d759--4fa30c49f7a54f9185f47bc439d61f25 f602b69eb89e4f66bfc7c0969f6c838e 9cad6545449d476c967fcdbd5301d759--f602b69eb89e4f66bfc7c0969f6c838e 67b8da244b844e368e0be0df184ab47f f602b69eb89e4f66bfc7c0969f6c838e--67b8da244b844e368e0be0df184ab47f c25e63b4b391497a9c319f827511c489 67b8da244b844e368e0be0df184ab47f--c25e63b4b391497a9c319f827511c489 c0a6007fb33a4e9c94abbd1165c79647 c25e63b4b391497a9c319f827511c489--c0a6007fb33a4e9c94abbd1165c79647 eb06f93ca990494fb825416152e10355 c0a6007fb33a4e9c94abbd1165c79647--eb06f93ca990494fb825416152e10355 4dcd8707dace47e8bf10be2f0d71f074 X eb06f93ca990494fb825416152e10355--4dcd8707dace47e8bf10be2f0d71f074 4dcd8707dace47e8bf10be2f0d71f074--c5c2f77fc56a45ec869118d4e3b975a2 c6746ba70f34408dbd06c1dc91fab2e0 4dcd8707dace47e8bf10be2f0d71f074--c6746ba70f34408dbd06c1dc91fab2e0 f30fbe963b854b8a8f0056d403df66ea c6746ba70f34408dbd06c1dc91fab2e0--f30fbe963b854b8a8f0056d403df66ea 40b9cb6bcd6d41a787b7cd8464f9d6ef f30fbe963b854b8a8f0056d403df66ea--40b9cb6bcd6d41a787b7cd8464f9d6ef bf176f2912c04595a492e08e54a8132a 40b9cb6bcd6d41a787b7cd8464f9d6ef--bf176f2912c04595a492e08e54a8132a adf57ea0220546a9959d4892e679001a bf176f2912c04595a492e08e54a8132a--adf57ea0220546a9959d4892e679001a 6c0312b2dc344d2582ec538c22bb5aa7 adf57ea0220546a9959d4892e679001a--6c0312b2dc344d2582ec538c22bb5aa7 6df0ef7cdb8946c9927224631584ed68 6c0312b2dc344d2582ec538c22bb5aa7--6df0ef7cdb8946c9927224631584ed68 4dbc51e7429d4eaa9cf2aa66abb0b9a4 X 6df0ef7cdb8946c9927224631584ed68--4dbc51e7429d4eaa9cf2aa66abb0b9a4 4dbc51e7429d4eaa9cf2aa66abb0b9a4--4ea39c20964d474f95d8f85ad0694e73 248f440887694099b9367beb4edce125 4dbc51e7429d4eaa9cf2aa66abb0b9a4--248f440887694099b9367beb4edce125 3e11cafc1e8f4d958497c85ce32fff51 248f440887694099b9367beb4edce125--3e11cafc1e8f4d958497c85ce32fff51 5c6710fce5634c60a6c263155f4b802f 3e11cafc1e8f4d958497c85ce32fff51--5c6710fce5634c60a6c263155f4b802f 97027f47f6284c5aa5db6101b0545aa7 X 5c6710fce5634c60a6c263155f4b802f--97027f47f6284c5aa5db6101b0545aa7 97027f47f6284c5aa5db6101b0545aa7--03f3631d16b44ef99ac1803c9a0fa38f 164002e1fbe84b65b494ca3c5ccce6d4 97027f47f6284c5aa5db6101b0545aa7--164002e1fbe84b65b494ca3c5ccce6d4 ac5390d4c7f74ac39e3f79ea1f9643ac 164002e1fbe84b65b494ca3c5ccce6d4--ac5390d4c7f74ac39e3f79ea1f9643ac ec47e08bd428487cb1320723a99848d1 ac5390d4c7f74ac39e3f79ea1f9643ac--ec47e08bd428487cb1320723a99848d1 ade584401e0c4e2c8470b3a502c30997 ec47e08bd428487cb1320723a99848d1--ade584401e0c4e2c8470b3a502c30997 84cc1fca40c34d319031f088ec5f8108 ade584401e0c4e2c8470b3a502c30997--84cc1fca40c34d319031f088ec5f8108 55d812b40e97458ca11d5d775b8f47cb 84cc1fca40c34d319031f088ec5f8108--55d812b40e97458ca11d5d775b8f47cb 21719390ed3442c4b47c35760e0d9526 X 55d812b40e97458ca11d5d775b8f47cb--21719390ed3442c4b47c35760e0d9526 21719390ed3442c4b47c35760e0d9526--c44fdb2b904646ee825a10314e76e2c1 5c0516fd860742a9b6f8039c2f8822e0 21719390ed3442c4b47c35760e0d9526--5c0516fd860742a9b6f8039c2f8822e0 e45dcbf6d1094f689b3f4d6873f874d7 5c0516fd860742a9b6f8039c2f8822e0--e45dcbf6d1094f689b3f4d6873f874d7 d427eaf180444021bf56029c292412ef e45dcbf6d1094f689b3f4d6873f874d7--d427eaf180444021bf56029c292412ef c3b67493851d4dc59c4dbe5b840ec3dc d427eaf180444021bf56029c292412ef--c3b67493851d4dc59c4dbe5b840ec3dc c18fed97778f46a293a5f4d69b7e1a22 c3b67493851d4dc59c4dbe5b840ec3dc--c18fed97778f46a293a5f4d69b7e1a22 9f347eee17c840ea83344b54650aef81 X c18fed97778f46a293a5f4d69b7e1a22--9f347eee17c840ea83344b54650aef81 9f347eee17c840ea83344b54650aef81--e73c0cc23bf24f258db0b449cc8d11b0 d82568040ce840d789eed606cbbb9c29 9f347eee17c840ea83344b54650aef81--d82568040ce840d789eed606cbbb9c29 92991713382d49e59464f53f728962ac d82568040ce840d789eed606cbbb9c29--92991713382d49e59464f53f728962ac 1eb5106ea7eb43e3b502e5f4284ab9ed 92991713382d49e59464f53f728962ac--1eb5106ea7eb43e3b502e5f4284ab9ed d32b3303055c4e6fb6861a1b02fa222d 1eb5106ea7eb43e3b502e5f4284ab9ed--d32b3303055c4e6fb6861a1b02fa222d 2d36f84e166347d3bd0bd01fac18a6e0 d32b3303055c4e6fb6861a1b02fa222d--2d36f84e166347d3bd0bd01fac18a6e0 0e147023146f4571852fa420555997ab 2d36f84e166347d3bd0bd01fac18a6e0--0e147023146f4571852fa420555997ab 8a6a53d5c92548ad9ec8ed002cdd9070 0e147023146f4571852fa420555997ab--8a6a53d5c92548ad9ec8ed002cdd9070 6eccff460b3e4d16bfee7fc82a634d5e 8a6a53d5c92548ad9ec8ed002cdd9070--6eccff460b3e4d16bfee7fc82a634d5e b89f550603954b0db3fab32b9f1b17a3 6eccff460b3e4d16bfee7fc82a634d5e--b89f550603954b0db3fab32b9f1b17a3 4eb0035332e04e17bb7b8351981f72eb b89f550603954b0db3fab32b9f1b17a3--4eb0035332e04e17bb7b8351981f72eb 0d5d3a5b508c4ea4b339098df58d83bb 4eb0035332e04e17bb7b8351981f72eb--0d5d3a5b508c4ea4b339098df58d83bb cd8797df064c453bb822fca1d485c241 0d5d3a5b508c4ea4b339098df58d83bb--cd8797df064c453bb822fca1d485c241 4ebb3ef2cc8f427189704d31fd6ba55b cd8797df064c453bb822fca1d485c241--4ebb3ef2cc8f427189704d31fd6ba55b e21564dc7051414390c69a86ac39176d X 4ebb3ef2cc8f427189704d31fd6ba55b--e21564dc7051414390c69a86ac39176d e21564dc7051414390c69a86ac39176d--bc87c30597e24c08a874a8a2d0380fff ff1c62d1469c4d29b136caa61506b7af e21564dc7051414390c69a86ac39176d--ff1c62d1469c4d29b136caa61506b7af dc589a5788434f7baf4df106a6805868 ff1c62d1469c4d29b136caa61506b7af--dc589a5788434f7baf4df106a6805868 5264d417b4ee404b97f09d629489b2fd dc589a5788434f7baf4df106a6805868--5264d417b4ee404b97f09d629489b2fd da35c532c80e4ffab4b827f95664d8f2 X 5264d417b4ee404b97f09d629489b2fd--da35c532c80e4ffab4b827f95664d8f2 da35c532c80e4ffab4b827f95664d8f2--092f74f6649c40af86eb525b441b6c40 4726cff0fb014e80b77313acf9c05fae da35c532c80e4ffab4b827f95664d8f2--4726cff0fb014e80b77313acf9c05fae 75b84b43c7f1482ebf3479d17559c9ed 4726cff0fb014e80b77313acf9c05fae--75b84b43c7f1482ebf3479d17559c9ed 59f0ee03ed144f8c9a85091b5070406f 75b84b43c7f1482ebf3479d17559c9ed--59f0ee03ed144f8c9a85091b5070406f b1f7b0230cdc41f1b796e10ab9dc5f21 59f0ee03ed144f8c9a85091b5070406f--b1f7b0230cdc41f1b796e10ab9dc5f21 25d9a35e324941feb61e3d0a86aedf6e b1f7b0230cdc41f1b796e10ab9dc5f21--25d9a35e324941feb61e3d0a86aedf6e a1e9d5fe0ada451f91dd1d2bacd13344 25d9a35e324941feb61e3d0a86aedf6e--a1e9d5fe0ada451f91dd1d2bacd13344 8298d424235142019d5db87fbe74e469 X a1e9d5fe0ada451f91dd1d2bacd13344--8298d424235142019d5db87fbe74e469 8298d424235142019d5db87fbe74e469--77130157bc5c4b63a6c5dfecc6a7a889 cba36f46b0d84160baa28a73e7698795 8298d424235142019d5db87fbe74e469--cba36f46b0d84160baa28a73e7698795 f1faefd7d6d94846b25d2b54a92df359 cba36f46b0d84160baa28a73e7698795--f1faefd7d6d94846b25d2b54a92df359 08c0309cc3eb432e801a7654e5aaac07 f1faefd7d6d94846b25d2b54a92df359--08c0309cc3eb432e801a7654e5aaac07 e8c211975f614bfab38f9d408410ede2 08c0309cc3eb432e801a7654e5aaac07--e8c211975f614bfab38f9d408410ede2 bbe4d8c228894ede8679f6fbea09c9ef e8c211975f614bfab38f9d408410ede2--bbe4d8c228894ede8679f6fbea09c9ef 5c9fb406e1b64fdf9d3f2530713fca26 X bbe4d8c228894ede8679f6fbea09c9ef--5c9fb406e1b64fdf9d3f2530713fca26 5c9fb406e1b64fdf9d3f2530713fca26--25730495a97b459286fc27e1345fb4ca b4153938fe3d43ddba7c4209c38c5d72 5c9fb406e1b64fdf9d3f2530713fca26--b4153938fe3d43ddba7c4209c38c5d72 6f1bfa517f7a4356806ed8509c00c671 X b4153938fe3d43ddba7c4209c38c5d72--6f1bfa517f7a4356806ed8509c00c671 6f1bfa517f7a4356806ed8509c00c671--bdc7a030a9d340828c87f7ed3dd31458 cb2ce7f832dc414ab01075643a608ad0 6f1bfa517f7a4356806ed8509c00c671--cb2ce7f832dc414ab01075643a608ad0 cea774cc7bfe4ea19876a379bed625ac cb2ce7f832dc414ab01075643a608ad0--cea774cc7bfe4ea19876a379bed625ac f4d8f9eb8564426680049329fc0c96b2 cea774cc7bfe4ea19876a379bed625ac--f4d8f9eb8564426680049329fc0c96b2 08000f29a2724bf29a200bf4b50df661 X f4d8f9eb8564426680049329fc0c96b2--08000f29a2724bf29a200bf4b50df661 08000f29a2724bf29a200bf4b50df661--edf39d429bc143248ec9ed153beadfa5 b3f443b12ac74e9295a15a86a984e07e 08000f29a2724bf29a200bf4b50df661--b3f443b12ac74e9295a15a86a984e07e 95947da58aff4902a6dc44581bade744 b3f443b12ac74e9295a15a86a984e07e--95947da58aff4902a6dc44581bade744 b5d69bffa2dd49bbb1884f0d52a74183 95947da58aff4902a6dc44581bade744--b5d69bffa2dd49bbb1884f0d52a74183 002094c1f3c143a8847fe58ce7e730c4 RX(b15) b5d69bffa2dd49bbb1884f0d52a74183--002094c1f3c143a8847fe58ce7e730c4 002094c1f3c143a8847fe58ce7e730c4--7d2d42798fef40299a632890448ab020 8d3e28941793479daeafdafc5cba6dda c51212a65db8407fb756324eafb6ec14 64822dfc42694862a57f1c30b2c0e9b7--c51212a65db8407fb756324eafb6ec14 4027aeecac7c42dcb2e75bde882e1fdc 7 0c46ee1e735241dbaf96add9e6124dfd c51212a65db8407fb756324eafb6ec14--0c46ee1e735241dbaf96add9e6124dfd a82a9a17ae2a4faba4f51172e9d9ab4e 0c46ee1e735241dbaf96add9e6124dfd--a82a9a17ae2a4faba4f51172e9d9ab4e 7f1e62cae6b840bb9336a4b52b59ccd7 a82a9a17ae2a4faba4f51172e9d9ab4e--7f1e62cae6b840bb9336a4b52b59ccd7 494fd367b6a141fa923cd922364786a6 7f1e62cae6b840bb9336a4b52b59ccd7--494fd367b6a141fa923cd922364786a6 f2183aaee9504c739c840b9a0fc50cf3 X 494fd367b6a141fa923cd922364786a6--f2183aaee9504c739c840b9a0fc50cf3 f2183aaee9504c739c840b9a0fc50cf3--081c061d5ea5485da9fcee51ca82981f 8bb861a93c0841aca7d5f5709597590a f2183aaee9504c739c840b9a0fc50cf3--8bb861a93c0841aca7d5f5709597590a dbf136e4bf614acb8d5ddd0342cab980 8bb861a93c0841aca7d5f5709597590a--dbf136e4bf614acb8d5ddd0342cab980 7708ac328d3141feb1c5a68ccee3aa74 dbf136e4bf614acb8d5ddd0342cab980--7708ac328d3141feb1c5a68ccee3aa74 2d303abd45e94a6195170fe396cf2623 X 7708ac328d3141feb1c5a68ccee3aa74--2d303abd45e94a6195170fe396cf2623 2d303abd45e94a6195170fe396cf2623--86778da1c9a2406b8bf57d3036636139 084b16a8186b4c99a84076a1220a5704 2d303abd45e94a6195170fe396cf2623--084b16a8186b4c99a84076a1220a5704 7d90ad123aa049c19f8294fba4bbce55 084b16a8186b4c99a84076a1220a5704--7d90ad123aa049c19f8294fba4bbce55 976bc034e91b49bf8884f3c212730672 7d90ad123aa049c19f8294fba4bbce55--976bc034e91b49bf8884f3c212730672 39c3bb55b50e4e5390d9302ceb07426b 976bc034e91b49bf8884f3c212730672--39c3bb55b50e4e5390d9302ceb07426b 9e3c7dfcc7a44bdaa71a3811bb340c5e 39c3bb55b50e4e5390d9302ceb07426b--9e3c7dfcc7a44bdaa71a3811bb340c5e 60d21eea919e486db3c52af95e97d88e 9e3c7dfcc7a44bdaa71a3811bb340c5e--60d21eea919e486db3c52af95e97d88e 47cd6f5623ed42ddaa4e9cd07a5a9d95 60d21eea919e486db3c52af95e97d88e--47cd6f5623ed42ddaa4e9cd07a5a9d95 08ab1ceb207c4cbf93f8f1212a569699 47cd6f5623ed42ddaa4e9cd07a5a9d95--08ab1ceb207c4cbf93f8f1212a569699 42cc179f2eb342afb174f31ebc95a60d 08ab1ceb207c4cbf93f8f1212a569699--42cc179f2eb342afb174f31ebc95a60d fad1973aa7fd4f2cae92657c0714aab8 42cc179f2eb342afb174f31ebc95a60d--fad1973aa7fd4f2cae92657c0714aab8 821a4bd244a049248ebda1d4452d7e61 X fad1973aa7fd4f2cae92657c0714aab8--821a4bd244a049248ebda1d4452d7e61 821a4bd244a049248ebda1d4452d7e61--5e1ff15729ab4221bd08fca945bf8652 3bdead2b65da4d9dab1c370723bf8b12 RZ(-1.0*g0) 821a4bd244a049248ebda1d4452d7e61--3bdead2b65da4d9dab1c370723bf8b12 8c846280ab2f4eabb46bb9fb0622812f X 3bdead2b65da4d9dab1c370723bf8b12--8c846280ab2f4eabb46bb9fb0622812f 8c846280ab2f4eabb46bb9fb0622812f--3c2bddc7fc92482bbe99b7643a954506 b191215df7024a3c8a49cb69c893961c 8c846280ab2f4eabb46bb9fb0622812f--b191215df7024a3c8a49cb69c893961c 280cd7b547744e8883171eae2da57860 b191215df7024a3c8a49cb69c893961c--280cd7b547744e8883171eae2da57860 e45d31fca92c4acfb02fdbabf19cce75 280cd7b547744e8883171eae2da57860--e45d31fca92c4acfb02fdbabf19cce75 97482c37533540e98062ef157a6d4363 e45d31fca92c4acfb02fdbabf19cce75--97482c37533540e98062ef157a6d4363 6555b37ed462418ba603539b81417ab5 97482c37533540e98062ef157a6d4363--6555b37ed462418ba603539b81417ab5 a0d9541be1564f5e8f869f2686d2e1c6 6555b37ed462418ba603539b81417ab5--a0d9541be1564f5e8f869f2686d2e1c6 290d680684b94d86bce5a6a94ef92041 a0d9541be1564f5e8f869f2686d2e1c6--290d680684b94d86bce5a6a94ef92041 1631c7e327444065988db70871588183 290d680684b94d86bce5a6a94ef92041--1631c7e327444065988db70871588183 de48cc5f77d44ce8a889c99563b21492 1631c7e327444065988db70871588183--de48cc5f77d44ce8a889c99563b21492 d940f03bd5d547c9a866f9975d40979b de48cc5f77d44ce8a889c99563b21492--d940f03bd5d547c9a866f9975d40979b 114789f0cd9c4a6db68f906f7ab4759f X d940f03bd5d547c9a866f9975d40979b--114789f0cd9c4a6db68f906f7ab4759f 114789f0cd9c4a6db68f906f7ab4759f--1ac16bc7f5d84df6b01b595b07fb3bf4 7d4c1fd11ade4697b209de5c9e0adfd3 114789f0cd9c4a6db68f906f7ab4759f--7d4c1fd11ade4697b209de5c9e0adfd3 31451dedbc5f42d6b9af6269c7609b5f 7d4c1fd11ade4697b209de5c9e0adfd3--31451dedbc5f42d6b9af6269c7609b5f 1f5b5e6ed3b74deb9994cf1e493d8576 31451dedbc5f42d6b9af6269c7609b5f--1f5b5e6ed3b74deb9994cf1e493d8576 f6d07904449343b1a4c7730396d4a5e7 X 1f5b5e6ed3b74deb9994cf1e493d8576--f6d07904449343b1a4c7730396d4a5e7 f6d07904449343b1a4c7730396d4a5e7--e4ffc02d16034e21a2971354f16ef758 ce7b565364f84b62a04bfb3a01f52a97 f6d07904449343b1a4c7730396d4a5e7--ce7b565364f84b62a04bfb3a01f52a97 427867308cfb4f318f8eeb624c43abe8 ce7b565364f84b62a04bfb3a01f52a97--427867308cfb4f318f8eeb624c43abe8 c083e238149f44d69844a2bf38de185d 427867308cfb4f318f8eeb624c43abe8--c083e238149f44d69844a2bf38de185d 553d5e8c408d46fa80d22f5e4d3fae04 c083e238149f44d69844a2bf38de185d--553d5e8c408d46fa80d22f5e4d3fae04 935f060f8f004278b9bc54ad9ca16ce0 553d5e8c408d46fa80d22f5e4d3fae04--935f060f8f004278b9bc54ad9ca16ce0 b06bc82f515b4ffaadfce67beeb57269 935f060f8f004278b9bc54ad9ca16ce0--b06bc82f515b4ffaadfce67beeb57269 8969f8b9f8e14cc9a73d5fa66684975a b06bc82f515b4ffaadfce67beeb57269--8969f8b9f8e14cc9a73d5fa66684975a 140025aa08b3489c8465927ef265b7dd 8969f8b9f8e14cc9a73d5fa66684975a--140025aa08b3489c8465927ef265b7dd 7b132807241a4e56b6f79f61fabcf409 140025aa08b3489c8465927ef265b7dd--7b132807241a4e56b6f79f61fabcf409 3d8e3b0587f642b7b6c4cdecf50f3e4b X 7b132807241a4e56b6f79f61fabcf409--3d8e3b0587f642b7b6c4cdecf50f3e4b 3d8e3b0587f642b7b6c4cdecf50f3e4b--d13a017d790d46d0a254651fa0266e7b 835cb03c3b68476f8acdd57c94ae9ad1 RZ(-1.0*g0) 3d8e3b0587f642b7b6c4cdecf50f3e4b--835cb03c3b68476f8acdd57c94ae9ad1 8acae0093b3d4a159480ea47a2091446 X 835cb03c3b68476f8acdd57c94ae9ad1--8acae0093b3d4a159480ea47a2091446 8acae0093b3d4a159480ea47a2091446--ca71bcd39acc4c259c70e5674e1eb36e d05eb51ae7d0423f8adadfdf5bcbe131 8acae0093b3d4a159480ea47a2091446--d05eb51ae7d0423f8adadfdf5bcbe131 6b081a99b26d4bd5af23027ad90ef5d1 d05eb51ae7d0423f8adadfdf5bcbe131--6b081a99b26d4bd5af23027ad90ef5d1 bdaa8e63210744028e2ac8cb41c0091e 6b081a99b26d4bd5af23027ad90ef5d1--bdaa8e63210744028e2ac8cb41c0091e 3cdf8b9f27304095bf0870d6584ef63b bdaa8e63210744028e2ac8cb41c0091e--3cdf8b9f27304095bf0870d6584ef63b 727f18c522e94b8997ae2f3e2758995b 3cdf8b9f27304095bf0870d6584ef63b--727f18c522e94b8997ae2f3e2758995b 1a9ea9f3b2c74be1ba4f4fe5efc2183e 727f18c522e94b8997ae2f3e2758995b--1a9ea9f3b2c74be1ba4f4fe5efc2183e 74a6f5875906456fac57c2c06ee27177 1a9ea9f3b2c74be1ba4f4fe5efc2183e--74a6f5875906456fac57c2c06ee27177 35e96779fa994366bfb9b47fe06568d1 74a6f5875906456fac57c2c06ee27177--35e96779fa994366bfb9b47fe06568d1 6f5873b857534a549f86d992f836360b X 35e96779fa994366bfb9b47fe06568d1--6f5873b857534a549f86d992f836360b 6f5873b857534a549f86d992f836360b--7512aa6d3aff4f80827c6cedbb257da8 14e88347340e4349a0b274293a20f508 6f5873b857534a549f86d992f836360b--14e88347340e4349a0b274293a20f508 9382ac2b5d2a456ab0883cef10dc6131 14e88347340e4349a0b274293a20f508--9382ac2b5d2a456ab0883cef10dc6131 8c36c921e4dc4d0d86b0a948c77e69ed 9382ac2b5d2a456ab0883cef10dc6131--8c36c921e4dc4d0d86b0a948c77e69ed 11740696d5db479c9f3dfeb4a8285f2c X 8c36c921e4dc4d0d86b0a948c77e69ed--11740696d5db479c9f3dfeb4a8285f2c 11740696d5db479c9f3dfeb4a8285f2c--d3c72154d1564109a2331039c2837b55 05a96b4a8eca4bab8ada11f8bba63658 11740696d5db479c9f3dfeb4a8285f2c--05a96b4a8eca4bab8ada11f8bba63658 3dddabdf5738428caf5e68434156ff91 05a96b4a8eca4bab8ada11f8bba63658--3dddabdf5738428caf5e68434156ff91 6d4b0c19e392495e9b56489bf1c54878 3dddabdf5738428caf5e68434156ff91--6d4b0c19e392495e9b56489bf1c54878 fd632c6ef35542af9a475fb9b197f0f6 6d4b0c19e392495e9b56489bf1c54878--fd632c6ef35542af9a475fb9b197f0f6 d5f079b75056413ea236d41f76dccf18 fd632c6ef35542af9a475fb9b197f0f6--d5f079b75056413ea236d41f76dccf18 31778e347f6945b6a0bb284e0b83e42d d5f079b75056413ea236d41f76dccf18--31778e347f6945b6a0bb284e0b83e42d 0cc9c5a667e64b239de7413c5783f74c 31778e347f6945b6a0bb284e0b83e42d--0cc9c5a667e64b239de7413c5783f74c 3088441014a6468394e0a11b0097d49e 0cc9c5a667e64b239de7413c5783f74c--3088441014a6468394e0a11b0097d49e 9987648584174a1b94829dc32721a3fd 3088441014a6468394e0a11b0097d49e--9987648584174a1b94829dc32721a3fd f2449202b9024e979a7dfa8424c9cddf 9987648584174a1b94829dc32721a3fd--f2449202b9024e979a7dfa8424c9cddf fdddb2d38cf54c6f814c5c5498d84e8b f2449202b9024e979a7dfa8424c9cddf--fdddb2d38cf54c6f814c5c5498d84e8b feecca1071ac49ad949855044de17a91 fdddb2d38cf54c6f814c5c5498d84e8b--feecca1071ac49ad949855044de17a91 8d18aca7b59c4343b49abe86cb3f3cbb feecca1071ac49ad949855044de17a91--8d18aca7b59c4343b49abe86cb3f3cbb c102a3f861234dc293c8823ce73437fb 8d18aca7b59c4343b49abe86cb3f3cbb--c102a3f861234dc293c8823ce73437fb 83a276080cac46ce80092d41df2faf91 c102a3f861234dc293c8823ce73437fb--83a276080cac46ce80092d41df2faf91 db2e6d4ebc6e486ead3ee1547e847396 X 83a276080cac46ce80092d41df2faf91--db2e6d4ebc6e486ead3ee1547e847396 db2e6d4ebc6e486ead3ee1547e847396--097c7eabd17c47db9105385ea4090070 931c8cde2b694c88a7a993cbce922912 RZ(-1.0*g0) db2e6d4ebc6e486ead3ee1547e847396--931c8cde2b694c88a7a993cbce922912 e2470fef599f450a8ac1ac13aab9901e X 931c8cde2b694c88a7a993cbce922912--e2470fef599f450a8ac1ac13aab9901e e2470fef599f450a8ac1ac13aab9901e--7bcc5a02499c40298bd6cf99012c5541 2cf8f1c3240349c0a1263f68e6a2d7d2 e2470fef599f450a8ac1ac13aab9901e--2cf8f1c3240349c0a1263f68e6a2d7d2 d538ccfef6fa4ea4a902f39989703c00 2cf8f1c3240349c0a1263f68e6a2d7d2--d538ccfef6fa4ea4a902f39989703c00 da9603418246457193ce5ee0849d09ac d538ccfef6fa4ea4a902f39989703c00--da9603418246457193ce5ee0849d09ac 38775169b9914aafac3610c7c2cb7b76 da9603418246457193ce5ee0849d09ac--38775169b9914aafac3610c7c2cb7b76 4d0777ad3107424794fac3b85bf4d97e 38775169b9914aafac3610c7c2cb7b76--4d0777ad3107424794fac3b85bf4d97e 37d4de7291f3426e9030c6a338721cfa 4d0777ad3107424794fac3b85bf4d97e--37d4de7291f3426e9030c6a338721cfa 103188f06133454ea9e31b400c3a04fd 37d4de7291f3426e9030c6a338721cfa--103188f06133454ea9e31b400c3a04fd 843ba91405104b6885c5be967e6c8402 103188f06133454ea9e31b400c3a04fd--843ba91405104b6885c5be967e6c8402 9914cb7414494c46b873636fb7ee2610 X 843ba91405104b6885c5be967e6c8402--9914cb7414494c46b873636fb7ee2610 9914cb7414494c46b873636fb7ee2610--ce16954d36e4412eac73f7d2b6563445 fc7223c7a1194fc090444e20d16a38f5 9914cb7414494c46b873636fb7ee2610--fc7223c7a1194fc090444e20d16a38f5 f814b74459964c1db4b834d122dde954 fc7223c7a1194fc090444e20d16a38f5--f814b74459964c1db4b834d122dde954 f9099d7d5c6a422494f2a397ef99d027 f814b74459964c1db4b834d122dde954--f9099d7d5c6a422494f2a397ef99d027 80303629b7354587969ec5df5373eb5b X f9099d7d5c6a422494f2a397ef99d027--80303629b7354587969ec5df5373eb5b 80303629b7354587969ec5df5373eb5b--3959dd56593b47a88a4dc3048076077f cf864d052ba046c28a4fddc0908d18ae 80303629b7354587969ec5df5373eb5b--cf864d052ba046c28a4fddc0908d18ae cd72d55afbd34fc7bc836f13eccc4909 cf864d052ba046c28a4fddc0908d18ae--cd72d55afbd34fc7bc836f13eccc4909 cd638ba3429f474e89ee2ba0f986e463 cd72d55afbd34fc7bc836f13eccc4909--cd638ba3429f474e89ee2ba0f986e463 b8a9c4ad098a43459693d1d2f9887e12 X cd638ba3429f474e89ee2ba0f986e463--b8a9c4ad098a43459693d1d2f9887e12 b8a9c4ad098a43459693d1d2f9887e12--6957f6d5298f468a876719fd579b0da2 73d8b181155344c48c7f1bb444f2d9e9 RZ(-1.0*g0) b8a9c4ad098a43459693d1d2f9887e12--73d8b181155344c48c7f1bb444f2d9e9 749f4cf3fcdf4446af3e22aed1c6140f X 73d8b181155344c48c7f1bb444f2d9e9--749f4cf3fcdf4446af3e22aed1c6140f 749f4cf3fcdf4446af3e22aed1c6140f--f8743112a74940fb83629335f27549d5 a1e3f7ceec024814a9234c41f50d6e60 749f4cf3fcdf4446af3e22aed1c6140f--a1e3f7ceec024814a9234c41f50d6e60 cbdabb47190742919ff102f87599f7ae X a1e3f7ceec024814a9234c41f50d6e60--cbdabb47190742919ff102f87599f7ae cbdabb47190742919ff102f87599f7ae--83f48d9bd3644695baf8ac70217f9201 ffcf6ec02d8040568e7cbde9b557df40 RZ(-1.0*g0) cbdabb47190742919ff102f87599f7ae--ffcf6ec02d8040568e7cbde9b557df40 d001bd3a925b46fd936c03389b1f090f X ffcf6ec02d8040568e7cbde9b557df40--d001bd3a925b46fd936c03389b1f090f d001bd3a925b46fd936c03389b1f090f--eba37815b65a4c3db6d485c98cc0b47c 8b448ba359bb4f19979300b8bbb3c0cc RX(b06) d001bd3a925b46fd936c03389b1f090f--8b448ba359bb4f19979300b8bbb3c0cc c10aa7b0e8b5449abae1ec6c0dfd353d 8b448ba359bb4f19979300b8bbb3c0cc--c10aa7b0e8b5449abae1ec6c0dfd353d d405fd6711904265b2a369cac8edd222 c10aa7b0e8b5449abae1ec6c0dfd353d--d405fd6711904265b2a369cac8edd222 051b4078044041d6b291d88389138c48 d405fd6711904265b2a369cac8edd222--051b4078044041d6b291d88389138c48 0cf071d28947442598ad0b4490f7e2de 051b4078044041d6b291d88389138c48--0cf071d28947442598ad0b4490f7e2de becbeb3e07b749dc8f5710eb08d77db7 0cf071d28947442598ad0b4490f7e2de--becbeb3e07b749dc8f5710eb08d77db7 e01ef14b02554afe9545ab5ba08758fa X becbeb3e07b749dc8f5710eb08d77db7--e01ef14b02554afe9545ab5ba08758fa e01ef14b02554afe9545ab5ba08758fa--02539484fe284efe949c5e51f6cc05c5 ec625e3ea97f40e0bb45e890ca0c1d42 e01ef14b02554afe9545ab5ba08758fa--ec625e3ea97f40e0bb45e890ca0c1d42 492890351c744e2990351d175b4ddcd9 ec625e3ea97f40e0bb45e890ca0c1d42--492890351c744e2990351d175b4ddcd9 5be059dfb7fd4784af1510e6a3516a13 492890351c744e2990351d175b4ddcd9--5be059dfb7fd4784af1510e6a3516a13 0828c5c32fce4f8d8589aebafde73766 X 5be059dfb7fd4784af1510e6a3516a13--0828c5c32fce4f8d8589aebafde73766 0828c5c32fce4f8d8589aebafde73766--fb51873e70c04d81984e4befc63e0844 64548445fbba4bf180f1f1a59f91367c 0828c5c32fce4f8d8589aebafde73766--64548445fbba4bf180f1f1a59f91367c 91a3d7d1f4954aa88d4ec663ec4b7879 64548445fbba4bf180f1f1a59f91367c--91a3d7d1f4954aa88d4ec663ec4b7879 0523d120f60842cdb01ea63f575e3f53 91a3d7d1f4954aa88d4ec663ec4b7879--0523d120f60842cdb01ea63f575e3f53 175481db4c664487bb0753fe70d81324 0523d120f60842cdb01ea63f575e3f53--175481db4c664487bb0753fe70d81324 01ef98d9b1b948e483684f7a90992547 175481db4c664487bb0753fe70d81324--01ef98d9b1b948e483684f7a90992547 b8310112615642b8b85969f28c1d373d 01ef98d9b1b948e483684f7a90992547--b8310112615642b8b85969f28c1d373d 98d43454229e499aa0ac8b9f5e0ac062 b8310112615642b8b85969f28c1d373d--98d43454229e499aa0ac8b9f5e0ac062 b73aee205cfe46dc8f5a368e627c30a7 98d43454229e499aa0ac8b9f5e0ac062--b73aee205cfe46dc8f5a368e627c30a7 8d64cf57943f4b25a4ed10a263499340 b73aee205cfe46dc8f5a368e627c30a7--8d64cf57943f4b25a4ed10a263499340 d821687224cb4306952041e078fec1e1 8d64cf57943f4b25a4ed10a263499340--d821687224cb4306952041e078fec1e1 7374474a89b74f3d8eeae1af29fab4cc X d821687224cb4306952041e078fec1e1--7374474a89b74f3d8eeae1af29fab4cc 7374474a89b74f3d8eeae1af29fab4cc--43a668e2822a4dac8befa3be221d2f4f 88d5fd3727b3440fa5bd1c726fad62f5 RZ(-1.0*g1) 7374474a89b74f3d8eeae1af29fab4cc--88d5fd3727b3440fa5bd1c726fad62f5 f5fec27005414d7aac1ad2fea9ea82be X 88d5fd3727b3440fa5bd1c726fad62f5--f5fec27005414d7aac1ad2fea9ea82be f5fec27005414d7aac1ad2fea9ea82be--122ce862d89642d59c4e23686a2d919a ba7a2ad597094393981af9d596845386 f5fec27005414d7aac1ad2fea9ea82be--ba7a2ad597094393981af9d596845386 0228f974f9de4004a08692b3b549bb72 ba7a2ad597094393981af9d596845386--0228f974f9de4004a08692b3b549bb72 bcde2b0554354472bc6b2718f493a3f5 0228f974f9de4004a08692b3b549bb72--bcde2b0554354472bc6b2718f493a3f5 f830230f66994bec8d7b230438d9d93c bcde2b0554354472bc6b2718f493a3f5--f830230f66994bec8d7b230438d9d93c 42d70dd47ad9438fbb8313831f6dabb6 f830230f66994bec8d7b230438d9d93c--42d70dd47ad9438fbb8313831f6dabb6 c6843819903c4e69a6b8f961672a19c9 42d70dd47ad9438fbb8313831f6dabb6--c6843819903c4e69a6b8f961672a19c9 42a8049c95e948d490751c4aeaf18361 c6843819903c4e69a6b8f961672a19c9--42a8049c95e948d490751c4aeaf18361 0a77db8d4e2e4ed8bf0adf8e7e1f744f 42a8049c95e948d490751c4aeaf18361--0a77db8d4e2e4ed8bf0adf8e7e1f744f e3ef08c1864043d2af328e4c82fcf53c 0a77db8d4e2e4ed8bf0adf8e7e1f744f--e3ef08c1864043d2af328e4c82fcf53c ab0132f2483749a58084456fcb0356cb e3ef08c1864043d2af328e4c82fcf53c--ab0132f2483749a58084456fcb0356cb c9e6b3f2757449f5a4e886138b04a990 X ab0132f2483749a58084456fcb0356cb--c9e6b3f2757449f5a4e886138b04a990 c9e6b3f2757449f5a4e886138b04a990--f602b69eb89e4f66bfc7c0969f6c838e d306887dfdef44798ca8c4dc383fa631 c9e6b3f2757449f5a4e886138b04a990--d306887dfdef44798ca8c4dc383fa631 1e8a8d9dca774bbfa73118c032f8e987 d306887dfdef44798ca8c4dc383fa631--1e8a8d9dca774bbfa73118c032f8e987 f0cd9c63a941463cbb9a4117afdd96cc 1e8a8d9dca774bbfa73118c032f8e987--f0cd9c63a941463cbb9a4117afdd96cc 53d535daf60944d89e562c136764a926 X f0cd9c63a941463cbb9a4117afdd96cc--53d535daf60944d89e562c136764a926 53d535daf60944d89e562c136764a926--eb06f93ca990494fb825416152e10355 847aaa27001246c7880958ca494e3908 53d535daf60944d89e562c136764a926--847aaa27001246c7880958ca494e3908 d2c3eaf47c01416d99446e90990eeba5 847aaa27001246c7880958ca494e3908--d2c3eaf47c01416d99446e90990eeba5 0856a9b1d0374c6aa78cc7549ebf3090 d2c3eaf47c01416d99446e90990eeba5--0856a9b1d0374c6aa78cc7549ebf3090 60a9583643704f6a9b64a1045ee66925 0856a9b1d0374c6aa78cc7549ebf3090--60a9583643704f6a9b64a1045ee66925 aead47f4de3b42fe8c600e93e32356f2 60a9583643704f6a9b64a1045ee66925--aead47f4de3b42fe8c600e93e32356f2 dc473742737549da887cfe99e0fb9cef aead47f4de3b42fe8c600e93e32356f2--dc473742737549da887cfe99e0fb9cef fefaeb35d7c1413e9b67e0f3760a2287 dc473742737549da887cfe99e0fb9cef--fefaeb35d7c1413e9b67e0f3760a2287 32c779621e894d928d42b120a1a585a3 fefaeb35d7c1413e9b67e0f3760a2287--32c779621e894d928d42b120a1a585a3 2b345f7d95e8445ca81295a1245051e4 32c779621e894d928d42b120a1a585a3--2b345f7d95e8445ca81295a1245051e4 3d35c8c1f04142b6b2bfd7fc66c61dce X 2b345f7d95e8445ca81295a1245051e4--3d35c8c1f04142b6b2bfd7fc66c61dce 3d35c8c1f04142b6b2bfd7fc66c61dce--248f440887694099b9367beb4edce125 4aa25248a9ea4bfa84bd6ac05120355c RZ(-1.0*g1) 3d35c8c1f04142b6b2bfd7fc66c61dce--4aa25248a9ea4bfa84bd6ac05120355c 2aec3bd3d8c2458ab5da8356332d89d5 X 4aa25248a9ea4bfa84bd6ac05120355c--2aec3bd3d8c2458ab5da8356332d89d5 2aec3bd3d8c2458ab5da8356332d89d5--5c6710fce5634c60a6c263155f4b802f 7e925541621249b1aed5867802c0a81d 2aec3bd3d8c2458ab5da8356332d89d5--7e925541621249b1aed5867802c0a81d 9563a0a93726408a811324cc6b81f122 7e925541621249b1aed5867802c0a81d--9563a0a93726408a811324cc6b81f122 7069cc152cf3447a9e0136412f8a115c 9563a0a93726408a811324cc6b81f122--7069cc152cf3447a9e0136412f8a115c 9b5c69aaa5584c62b70543140446ce28 7069cc152cf3447a9e0136412f8a115c--9b5c69aaa5584c62b70543140446ce28 a7c9d7b66b21411ab3aaf260319abe7a 9b5c69aaa5584c62b70543140446ce28--a7c9d7b66b21411ab3aaf260319abe7a ee66c61ea3ed42788b3da3760136c734 a7c9d7b66b21411ab3aaf260319abe7a--ee66c61ea3ed42788b3da3760136c734 dfaf336d61204058b7a2a7eef8d0628c ee66c61ea3ed42788b3da3760136c734--dfaf336d61204058b7a2a7eef8d0628c c6b130cf8325456d910c2e62d3e65e7c dfaf336d61204058b7a2a7eef8d0628c--c6b130cf8325456d910c2e62d3e65e7c aa89c84be38542c387087c7276d2c164 X c6b130cf8325456d910c2e62d3e65e7c--aa89c84be38542c387087c7276d2c164 aa89c84be38542c387087c7276d2c164--5c0516fd860742a9b6f8039c2f8822e0 8dcb8fe714ec4a748118be8fc8f430be aa89c84be38542c387087c7276d2c164--8dcb8fe714ec4a748118be8fc8f430be 0f5da0a3496443e79556045d75674475 8dcb8fe714ec4a748118be8fc8f430be--0f5da0a3496443e79556045d75674475 0780ac9dcc924a29b00a6029c580aa29 0f5da0a3496443e79556045d75674475--0780ac9dcc924a29b00a6029c580aa29 db88e39709764bf6bfe6f491c3b917b5 X 0780ac9dcc924a29b00a6029c580aa29--db88e39709764bf6bfe6f491c3b917b5 db88e39709764bf6bfe6f491c3b917b5--c18fed97778f46a293a5f4d69b7e1a22 bec68ec3681e47e1bfd6a814bf8e6b49 db88e39709764bf6bfe6f491c3b917b5--bec68ec3681e47e1bfd6a814bf8e6b49 c1a0fde2a7b94b88a92af6b23525a8f7 bec68ec3681e47e1bfd6a814bf8e6b49--c1a0fde2a7b94b88a92af6b23525a8f7 2a70df21c6754a65a33c6399d6409e1b c1a0fde2a7b94b88a92af6b23525a8f7--2a70df21c6754a65a33c6399d6409e1b da9091decf7a4a568f1afaec6ddf6807 2a70df21c6754a65a33c6399d6409e1b--da9091decf7a4a568f1afaec6ddf6807 146dc6ebe02d44d6a97ef369345ca354 da9091decf7a4a568f1afaec6ddf6807--146dc6ebe02d44d6a97ef369345ca354 97d4bde4ba2647e3913a363581918f12 146dc6ebe02d44d6a97ef369345ca354--97d4bde4ba2647e3913a363581918f12 a566ed718535494799147dc65819337b 97d4bde4ba2647e3913a363581918f12--a566ed718535494799147dc65819337b eb718f7e367b45ac8b5825c9423c0a23 a566ed718535494799147dc65819337b--eb718f7e367b45ac8b5825c9423c0a23 9715ba55ec4f46faaedba5a1aee4ff5c eb718f7e367b45ac8b5825c9423c0a23--9715ba55ec4f46faaedba5a1aee4ff5c 5655fb3223174c41b1609e5dab957f99 9715ba55ec4f46faaedba5a1aee4ff5c--5655fb3223174c41b1609e5dab957f99 2cf3af41784f47e5b193f07966398841 5655fb3223174c41b1609e5dab957f99--2cf3af41784f47e5b193f07966398841 2216fdb19d9a459cb115c109cc69f5bb 2cf3af41784f47e5b193f07966398841--2216fdb19d9a459cb115c109cc69f5bb c5ed80c593f44d6baf27ced0b9cf321b 2216fdb19d9a459cb115c109cc69f5bb--c5ed80c593f44d6baf27ced0b9cf321b 44c241eef25a429d8fa742055d038204 c5ed80c593f44d6baf27ced0b9cf321b--44c241eef25a429d8fa742055d038204 bcfac747777b4e59aaf3ecb2580714a6 44c241eef25a429d8fa742055d038204--bcfac747777b4e59aaf3ecb2580714a6 5d62dfa44f784eb88fa22be7947299c4 X bcfac747777b4e59aaf3ecb2580714a6--5d62dfa44f784eb88fa22be7947299c4 5d62dfa44f784eb88fa22be7947299c4--ff1c62d1469c4d29b136caa61506b7af 2f5ff421a0a54dd280d72ae0306203ea RZ(-1.0*g1) 5d62dfa44f784eb88fa22be7947299c4--2f5ff421a0a54dd280d72ae0306203ea 61cd02063ea44cdf9845e2e064665e8f X 2f5ff421a0a54dd280d72ae0306203ea--61cd02063ea44cdf9845e2e064665e8f 61cd02063ea44cdf9845e2e064665e8f--5264d417b4ee404b97f09d629489b2fd 5f20fa371c004c49848c80a683b9b957 61cd02063ea44cdf9845e2e064665e8f--5f20fa371c004c49848c80a683b9b957 43c77dc132fd45ca873bed20de7edc74 5f20fa371c004c49848c80a683b9b957--43c77dc132fd45ca873bed20de7edc74 beb40297c3de40f58a87a11e5e4225b6 43c77dc132fd45ca873bed20de7edc74--beb40297c3de40f58a87a11e5e4225b6 a19230ff55d9465fb8b2688d56192219 beb40297c3de40f58a87a11e5e4225b6--a19230ff55d9465fb8b2688d56192219 0965b811e1dc4ef2b8d0b101592d7e4b a19230ff55d9465fb8b2688d56192219--0965b811e1dc4ef2b8d0b101592d7e4b a98a99d37d424fd089b453c05a88d0b5 0965b811e1dc4ef2b8d0b101592d7e4b--a98a99d37d424fd089b453c05a88d0b5 505c4ce8256f42e2be3b248bd728eb1d a98a99d37d424fd089b453c05a88d0b5--505c4ce8256f42e2be3b248bd728eb1d 22076ca0e63645bdaccc31db59ac0a54 505c4ce8256f42e2be3b248bd728eb1d--22076ca0e63645bdaccc31db59ac0a54 9aa0a54c9a194867a880313120cc27ee X 22076ca0e63645bdaccc31db59ac0a54--9aa0a54c9a194867a880313120cc27ee 9aa0a54c9a194867a880313120cc27ee--cba36f46b0d84160baa28a73e7698795 5e2459c39930411fbbe0d77f45721bd1 9aa0a54c9a194867a880313120cc27ee--5e2459c39930411fbbe0d77f45721bd1 896d11c4ab984611b9bb9ba423fb372e 5e2459c39930411fbbe0d77f45721bd1--896d11c4ab984611b9bb9ba423fb372e f88deb779c404fac8791f91fd176741c 896d11c4ab984611b9bb9ba423fb372e--f88deb779c404fac8791f91fd176741c c20faed86ebd435b8759ec360de3031e X f88deb779c404fac8791f91fd176741c--c20faed86ebd435b8759ec360de3031e c20faed86ebd435b8759ec360de3031e--bbe4d8c228894ede8679f6fbea09c9ef b99b7795090c4c5d873f0aead929ef44 c20faed86ebd435b8759ec360de3031e--b99b7795090c4c5d873f0aead929ef44 e75bb891fba0410c8eb3261ffa86c5ac b99b7795090c4c5d873f0aead929ef44--e75bb891fba0410c8eb3261ffa86c5ac 0265297ee5964977a329a2ce9261c12e e75bb891fba0410c8eb3261ffa86c5ac--0265297ee5964977a329a2ce9261c12e 582c5b7185ac4da5be8745e5de7383c2 X 0265297ee5964977a329a2ce9261c12e--582c5b7185ac4da5be8745e5de7383c2 582c5b7185ac4da5be8745e5de7383c2--cb2ce7f832dc414ab01075643a608ad0 7701898c4c3c40aea55dffc1fc3fb860 RZ(-1.0*g1) 582c5b7185ac4da5be8745e5de7383c2--7701898c4c3c40aea55dffc1fc3fb860 bf4167bb158445589da086f144060125 X 7701898c4c3c40aea55dffc1fc3fb860--bf4167bb158445589da086f144060125 bf4167bb158445589da086f144060125--f4d8f9eb8564426680049329fc0c96b2 b766045e47a449ea957ba1118ccb7137 bf4167bb158445589da086f144060125--b766045e47a449ea957ba1118ccb7137 c1ea45d3600d456aabac5a069ce67033 X b766045e47a449ea957ba1118ccb7137--c1ea45d3600d456aabac5a069ce67033 c1ea45d3600d456aabac5a069ce67033--b3f443b12ac74e9295a15a86a984e07e 2fe65dbf79ed48dfb4b7e0256fdefcde RZ(-1.0*g1) c1ea45d3600d456aabac5a069ce67033--2fe65dbf79ed48dfb4b7e0256fdefcde 75fc59895af341aeab7dca0dc506a173 X 2fe65dbf79ed48dfb4b7e0256fdefcde--75fc59895af341aeab7dca0dc506a173 75fc59895af341aeab7dca0dc506a173--b5d69bffa2dd49bbb1884f0d52a74183 c326238f40d54713b23de01bfb970c21 RX(b16) 75fc59895af341aeab7dca0dc506a173--c326238f40d54713b23de01bfb970c21 c326238f40d54713b23de01bfb970c21--8d3e28941793479daeafdafc5cba6dda 0ad1e598127441ff827cfe314e709c6c b7e3dc54207d41429addc43a20e1ce43 4027aeecac7c42dcb2e75bde882e1fdc--b7e3dc54207d41429addc43a20e1ce43 59eab79eb6da42eeb8a8a2ac8783f343 b7e3dc54207d41429addc43a20e1ce43--59eab79eb6da42eeb8a8a2ac8783f343 64ad1ca7d90c487891d47cdb9820348c 59eab79eb6da42eeb8a8a2ac8783f343--64ad1ca7d90c487891d47cdb9820348c 033d66447ac849eda7c323ed88e37f79 64ad1ca7d90c487891d47cdb9820348c--033d66447ac849eda7c323ed88e37f79 9bf1d07a85784e909ee6bd09db939b84 033d66447ac849eda7c323ed88e37f79--9bf1d07a85784e909ee6bd09db939b84 5d9b136d05bc44579b88bc014ec964b1 9bf1d07a85784e909ee6bd09db939b84--5d9b136d05bc44579b88bc014ec964b1 b3d57035da454398ae6e91b24e5c244d X 5d9b136d05bc44579b88bc014ec964b1--b3d57035da454398ae6e91b24e5c244d b3d57035da454398ae6e91b24e5c244d--8bb861a93c0841aca7d5f5709597590a 06e6487eb1404ab4961576483f26ed15 RZ(1.0*g0) b3d57035da454398ae6e91b24e5c244d--06e6487eb1404ab4961576483f26ed15 2d6ca80a121c4891ba8e0be215dc55d4 X 06e6487eb1404ab4961576483f26ed15--2d6ca80a121c4891ba8e0be215dc55d4 2d6ca80a121c4891ba8e0be215dc55d4--7708ac328d3141feb1c5a68ccee3aa74 3cf6bfb8e7f144c9b4ab2d62799edcd9 2d6ca80a121c4891ba8e0be215dc55d4--3cf6bfb8e7f144c9b4ab2d62799edcd9 3a6f8edf9516462eba52a6f9048f2cc7 3cf6bfb8e7f144c9b4ab2d62799edcd9--3a6f8edf9516462eba52a6f9048f2cc7 c44d589b1b924d989e53b1eadb1388ea 3a6f8edf9516462eba52a6f9048f2cc7--c44d589b1b924d989e53b1eadb1388ea aa98099cdfe7459e8a15215a307a6496 c44d589b1b924d989e53b1eadb1388ea--aa98099cdfe7459e8a15215a307a6496 0b36dc86d8ca4a7ba409f8eae92b6c77 aa98099cdfe7459e8a15215a307a6496--0b36dc86d8ca4a7ba409f8eae92b6c77 a187637877ca4f7a81190c1b2bc2739f 0b36dc86d8ca4a7ba409f8eae92b6c77--a187637877ca4f7a81190c1b2bc2739f 4a2f20b022cc411d8497349a639c39ec a187637877ca4f7a81190c1b2bc2739f--4a2f20b022cc411d8497349a639c39ec 33a1612e943e4bcfa524838ff8ca333f 4a2f20b022cc411d8497349a639c39ec--33a1612e943e4bcfa524838ff8ca333f da08bb584eb54fb3a5e14919c980b25b 33a1612e943e4bcfa524838ff8ca333f--da08bb584eb54fb3a5e14919c980b25b 3de622bcded049999603e73d9732435f da08bb584eb54fb3a5e14919c980b25b--3de622bcded049999603e73d9732435f 06bdb4d12e27440b9fbc99df984aed7d 3de622bcded049999603e73d9732435f--06bdb4d12e27440b9fbc99df984aed7d e1f565bcd8b649918f0d57c4c1587ff5 06bdb4d12e27440b9fbc99df984aed7d--e1f565bcd8b649918f0d57c4c1587ff5 8ae1a4359e254514b7c18d89382f4f7b e1f565bcd8b649918f0d57c4c1587ff5--8ae1a4359e254514b7c18d89382f4f7b 86bf2e9e68694554b9dbc97fb9bff51d 8ae1a4359e254514b7c18d89382f4f7b--86bf2e9e68694554b9dbc97fb9bff51d 2f49c2de9e6040f68611693b39c82512 86bf2e9e68694554b9dbc97fb9bff51d--2f49c2de9e6040f68611693b39c82512 5d64166e5c0b4714b149f7054878ff2c 2f49c2de9e6040f68611693b39c82512--5d64166e5c0b4714b149f7054878ff2c 4e46f7e5a2c64bbe9d73960978bc2c86 5d64166e5c0b4714b149f7054878ff2c--4e46f7e5a2c64bbe9d73960978bc2c86 8dbed87ea29445c58aa6297f73c56561 4e46f7e5a2c64bbe9d73960978bc2c86--8dbed87ea29445c58aa6297f73c56561 3dacd9adb05c4b62a3ddc2d7c5532095 8dbed87ea29445c58aa6297f73c56561--3dacd9adb05c4b62a3ddc2d7c5532095 c9741df0795c4e7f851166d1126e8c90 3dacd9adb05c4b62a3ddc2d7c5532095--c9741df0795c4e7f851166d1126e8c90 8a0cc9d5fffe4602a051e41305aac2b6 c9741df0795c4e7f851166d1126e8c90--8a0cc9d5fffe4602a051e41305aac2b6 9685ce3ecf0c481c947098d723b90931 8a0cc9d5fffe4602a051e41305aac2b6--9685ce3ecf0c481c947098d723b90931 0cf476ce4e144fc084c509fb430fe718 9685ce3ecf0c481c947098d723b90931--0cf476ce4e144fc084c509fb430fe718 ddb3d63ef38649e4a2e15a87411e0865 0cf476ce4e144fc084c509fb430fe718--ddb3d63ef38649e4a2e15a87411e0865 1df90aacbc2e4d4cb259321e433d0697 ddb3d63ef38649e4a2e15a87411e0865--1df90aacbc2e4d4cb259321e433d0697 c43ad7d0693445d5873b7690e4ed8771 X 1df90aacbc2e4d4cb259321e433d0697--c43ad7d0693445d5873b7690e4ed8771 c43ad7d0693445d5873b7690e4ed8771--7d4c1fd11ade4697b209de5c9e0adfd3 89c7fc3c8464492ba77ec8d77a300f46 RZ(-1.0*g0) c43ad7d0693445d5873b7690e4ed8771--89c7fc3c8464492ba77ec8d77a300f46 cf2ae33e14664121bd1b0166ab0931b8 X 89c7fc3c8464492ba77ec8d77a300f46--cf2ae33e14664121bd1b0166ab0931b8 cf2ae33e14664121bd1b0166ab0931b8--1f5b5e6ed3b74deb9994cf1e493d8576 dafe3381a8b64caca66da6317ab758e3 cf2ae33e14664121bd1b0166ab0931b8--dafe3381a8b64caca66da6317ab758e3 fccfdb146188457bb86a834d99bff938 dafe3381a8b64caca66da6317ab758e3--fccfdb146188457bb86a834d99bff938 edbf3af028f94f4eb805aab5de58cbcd fccfdb146188457bb86a834d99bff938--edbf3af028f94f4eb805aab5de58cbcd 42a52de9838d4ba09deb73f7de96683d edbf3af028f94f4eb805aab5de58cbcd--42a52de9838d4ba09deb73f7de96683d 6bf3f07bb354410a8ff771cd699cea0b 42a52de9838d4ba09deb73f7de96683d--6bf3f07bb354410a8ff771cd699cea0b 59ac969445d64cca89bc3471940003bb 6bf3f07bb354410a8ff771cd699cea0b--59ac969445d64cca89bc3471940003bb 37828d5920424ad5b8240b88aec441c9 59ac969445d64cca89bc3471940003bb--37828d5920424ad5b8240b88aec441c9 f7727bc6837f47efa65e1f8dad3de0ac 37828d5920424ad5b8240b88aec441c9--f7727bc6837f47efa65e1f8dad3de0ac 0a4bfbc85efb470f8f62f54fb04f392e f7727bc6837f47efa65e1f8dad3de0ac--0a4bfbc85efb470f8f62f54fb04f392e 90ef82f6c5bd467f80ac507ed7f5cf65 0a4bfbc85efb470f8f62f54fb04f392e--90ef82f6c5bd467f80ac507ed7f5cf65 7f1bde38cf38464d9e0a12577e784fbe 90ef82f6c5bd467f80ac507ed7f5cf65--7f1bde38cf38464d9e0a12577e784fbe faa6874123ba4923a19faa2efde5ca53 7f1bde38cf38464d9e0a12577e784fbe--faa6874123ba4923a19faa2efde5ca53 19834b1e0a0748658cd85f052ba50f61 faa6874123ba4923a19faa2efde5ca53--19834b1e0a0748658cd85f052ba50f61 5db0c47696594c0a8acc3b4e14794561 19834b1e0a0748658cd85f052ba50f61--5db0c47696594c0a8acc3b4e14794561 6378b112efe3493e8b88fc83a0898de7 5db0c47696594c0a8acc3b4e14794561--6378b112efe3493e8b88fc83a0898de7 ef1d56d4619a4acd8ba50d74dcf0aae9 6378b112efe3493e8b88fc83a0898de7--ef1d56d4619a4acd8ba50d74dcf0aae9 2d856f22c1034fea87de8eebc25d8241 ef1d56d4619a4acd8ba50d74dcf0aae9--2d856f22c1034fea87de8eebc25d8241 55169fde4c98400d932318367e3284a9 2d856f22c1034fea87de8eebc25d8241--55169fde4c98400d932318367e3284a9 7b1f420a36914d04b6221415e7237ed2 55169fde4c98400d932318367e3284a9--7b1f420a36914d04b6221415e7237ed2 8c6c7bee1d004355bd9f88923276ec7b 7b1f420a36914d04b6221415e7237ed2--8c6c7bee1d004355bd9f88923276ec7b f06f63f5a9184389979dee91eadbe74d 8c6c7bee1d004355bd9f88923276ec7b--f06f63f5a9184389979dee91eadbe74d 7d2d5e9853c642f5b555f2c0f5594949 f06f63f5a9184389979dee91eadbe74d--7d2d5e9853c642f5b555f2c0f5594949 74a08962be3e45feba39cf49c54b2ff0 X 7d2d5e9853c642f5b555f2c0f5594949--74a08962be3e45feba39cf49c54b2ff0 74a08962be3e45feba39cf49c54b2ff0--14e88347340e4349a0b274293a20f508 43fb571b95ec4be4b37d437edc98c5f5 RZ(-1.0*g0) 74a08962be3e45feba39cf49c54b2ff0--43fb571b95ec4be4b37d437edc98c5f5 70bc92bffc4a40d4b139cbe7cae9db07 X 43fb571b95ec4be4b37d437edc98c5f5--70bc92bffc4a40d4b139cbe7cae9db07 70bc92bffc4a40d4b139cbe7cae9db07--8c36c921e4dc4d0d86b0a948c77e69ed fda8cc5c9dd040bf82ebd8835523bcb3 70bc92bffc4a40d4b139cbe7cae9db07--fda8cc5c9dd040bf82ebd8835523bcb3 98ec96a9171149bba915d96f652dd2db fda8cc5c9dd040bf82ebd8835523bcb3--98ec96a9171149bba915d96f652dd2db 82d702335b114fd3a401c4007ea36ddb 98ec96a9171149bba915d96f652dd2db--82d702335b114fd3a401c4007ea36ddb baa34275de844df086ac6bdaf87a4435 82d702335b114fd3a401c4007ea36ddb--baa34275de844df086ac6bdaf87a4435 6f84f85dc8064dc0a6ebdfd04495447e baa34275de844df086ac6bdaf87a4435--6f84f85dc8064dc0a6ebdfd04495447e 535fad8cbff444b392839923f02ba052 6f84f85dc8064dc0a6ebdfd04495447e--535fad8cbff444b392839923f02ba052 2f9d960ad73f474b973adf39e8af3a9e 535fad8cbff444b392839923f02ba052--2f9d960ad73f474b973adf39e8af3a9e 8aaa65b2853246aaa6f2705ea937ca37 2f9d960ad73f474b973adf39e8af3a9e--8aaa65b2853246aaa6f2705ea937ca37 85aa98a89ae647b4b2f3fdf44d855e65 8aaa65b2853246aaa6f2705ea937ca37--85aa98a89ae647b4b2f3fdf44d855e65 670782f10cfe4053b9ab39c354734669 85aa98a89ae647b4b2f3fdf44d855e65--670782f10cfe4053b9ab39c354734669 462c0f7252db4769b0d37b0fe440bd3d 670782f10cfe4053b9ab39c354734669--462c0f7252db4769b0d37b0fe440bd3d 10a970e2e71942a58ae1dd4b1e47d165 462c0f7252db4769b0d37b0fe440bd3d--10a970e2e71942a58ae1dd4b1e47d165 52a816abe51b429fb4366ba9800e7b7d 10a970e2e71942a58ae1dd4b1e47d165--52a816abe51b429fb4366ba9800e7b7d ce0c6f2a1af24eec8568f9b1afd269ab 52a816abe51b429fb4366ba9800e7b7d--ce0c6f2a1af24eec8568f9b1afd269ab 8ec2e97f70764d12951ca64ffc63429f ce0c6f2a1af24eec8568f9b1afd269ab--8ec2e97f70764d12951ca64ffc63429f 99c7118722954ebc9333036c1d1841dd 8ec2e97f70764d12951ca64ffc63429f--99c7118722954ebc9333036c1d1841dd e6812235ff9f4e369ce0ffa7bdd4c661 99c7118722954ebc9333036c1d1841dd--e6812235ff9f4e369ce0ffa7bdd4c661 3cb8d17d534a4dcfbd01617b4463f38b e6812235ff9f4e369ce0ffa7bdd4c661--3cb8d17d534a4dcfbd01617b4463f38b 8f9f8665514b4e21800cce02eae441d8 3cb8d17d534a4dcfbd01617b4463f38b--8f9f8665514b4e21800cce02eae441d8 a26badfac37e4abb985d1b03404da75c 8f9f8665514b4e21800cce02eae441d8--a26badfac37e4abb985d1b03404da75c c6fb74c4dfa94e68bc2a6326601853c9 a26badfac37e4abb985d1b03404da75c--c6fb74c4dfa94e68bc2a6326601853c9 82e4dec6beb94879b68d442b4942b557 c6fb74c4dfa94e68bc2a6326601853c9--82e4dec6beb94879b68d442b4942b557 48f85c9fb7eb455db67be728ea15cb3b 82e4dec6beb94879b68d442b4942b557--48f85c9fb7eb455db67be728ea15cb3b 5034cc506101434e9a33e3fc07364550 48f85c9fb7eb455db67be728ea15cb3b--5034cc506101434e9a33e3fc07364550 9a84a81592404d8982481cd13fed4793 5034cc506101434e9a33e3fc07364550--9a84a81592404d8982481cd13fed4793 142c90f061c443a89120b48a6c75a163 9a84a81592404d8982481cd13fed4793--142c90f061c443a89120b48a6c75a163 a427ba0f66734cb891d93282f6b93fcf 142c90f061c443a89120b48a6c75a163--a427ba0f66734cb891d93282f6b93fcf 5503e4d47ffe4674831ffd83620efadd a427ba0f66734cb891d93282f6b93fcf--5503e4d47ffe4674831ffd83620efadd b63f61af00ce415bb44d51f35c04bc4d X 5503e4d47ffe4674831ffd83620efadd--b63f61af00ce415bb44d51f35c04bc4d b63f61af00ce415bb44d51f35c04bc4d--fc7223c7a1194fc090444e20d16a38f5 9bfbbb948801467aaf0d79d0134a645b RZ(-1.0*g0) b63f61af00ce415bb44d51f35c04bc4d--9bfbbb948801467aaf0d79d0134a645b 33df7e15fd7a4685afa3fb4eb7815ddf X 9bfbbb948801467aaf0d79d0134a645b--33df7e15fd7a4685afa3fb4eb7815ddf 33df7e15fd7a4685afa3fb4eb7815ddf--f9099d7d5c6a422494f2a397ef99d027 d15f7ca75611425496f5a9d06c90b908 33df7e15fd7a4685afa3fb4eb7815ddf--d15f7ca75611425496f5a9d06c90b908 5ce4ea4914fe450d8ecd035c6bb8dcdc d15f7ca75611425496f5a9d06c90b908--5ce4ea4914fe450d8ecd035c6bb8dcdc 643ab6f1802345928ac09523dee96d59 5ce4ea4914fe450d8ecd035c6bb8dcdc--643ab6f1802345928ac09523dee96d59 68faffca256844e986a36c4962a96542 643ab6f1802345928ac09523dee96d59--68faffca256844e986a36c4962a96542 a3023bf1c1e345538f9f0513824f3619 68faffca256844e986a36c4962a96542--a3023bf1c1e345538f9f0513824f3619 53b2ac16d15842a38be830f5167f0947 a3023bf1c1e345538f9f0513824f3619--53b2ac16d15842a38be830f5167f0947 45ebbcf625bc4939a8291ca70a8e4124 53b2ac16d15842a38be830f5167f0947--45ebbcf625bc4939a8291ca70a8e4124 4eecdc7c3d494cfeb7c99092fef8134f 45ebbcf625bc4939a8291ca70a8e4124--4eecdc7c3d494cfeb7c99092fef8134f 0558d812ae8443c987a3918e9f413858 4eecdc7c3d494cfeb7c99092fef8134f--0558d812ae8443c987a3918e9f413858 e93dd34fbc704a358308ed96ed0389ac 0558d812ae8443c987a3918e9f413858--e93dd34fbc704a358308ed96ed0389ac 9992b1c761e24d5b9d928b3611ed80a1 e93dd34fbc704a358308ed96ed0389ac--9992b1c761e24d5b9d928b3611ed80a1 015fd0101c36484f850a5d14673d1eeb RX(b07) 9992b1c761e24d5b9d928b3611ed80a1--015fd0101c36484f850a5d14673d1eeb 3f98f7d36382483ba0f5fb6e4039ae0b 015fd0101c36484f850a5d14673d1eeb--3f98f7d36382483ba0f5fb6e4039ae0b ec3cbb26e0b94785a1d6016c361f2869 3f98f7d36382483ba0f5fb6e4039ae0b--ec3cbb26e0b94785a1d6016c361f2869 d7d47eaec0ab479f8e122cd67a2c74ef ec3cbb26e0b94785a1d6016c361f2869--d7d47eaec0ab479f8e122cd67a2c74ef fce74dde8b8e4101ad46b5c15508795d d7d47eaec0ab479f8e122cd67a2c74ef--fce74dde8b8e4101ad46b5c15508795d 2280c6b18e65400d997e4b8ea1338bb4 fce74dde8b8e4101ad46b5c15508795d--2280c6b18e65400d997e4b8ea1338bb4 9e97b7b2374e45f4872b25ab51da8fb7 2280c6b18e65400d997e4b8ea1338bb4--9e97b7b2374e45f4872b25ab51da8fb7 05d42b910c814868bb26dadc56a62c6a X 9e97b7b2374e45f4872b25ab51da8fb7--05d42b910c814868bb26dadc56a62c6a 05d42b910c814868bb26dadc56a62c6a--ec625e3ea97f40e0bb45e890ca0c1d42 96afcd625b11438c8e7159e443e82f3b RZ(1.0*g1) 05d42b910c814868bb26dadc56a62c6a--96afcd625b11438c8e7159e443e82f3b b9bea4783e5f49e8b6fae8a64b08c108 X 96afcd625b11438c8e7159e443e82f3b--b9bea4783e5f49e8b6fae8a64b08c108 b9bea4783e5f49e8b6fae8a64b08c108--5be059dfb7fd4784af1510e6a3516a13 643e23546a21431fb8a3a8880db384b7 b9bea4783e5f49e8b6fae8a64b08c108--643e23546a21431fb8a3a8880db384b7 021cf56620d84d529bb12719b3c1eada 643e23546a21431fb8a3a8880db384b7--021cf56620d84d529bb12719b3c1eada d73ee05c444e4622960ab2dccae31df5 021cf56620d84d529bb12719b3c1eada--d73ee05c444e4622960ab2dccae31df5 5675d99c3aa44a97a340cdbdb9462f1b d73ee05c444e4622960ab2dccae31df5--5675d99c3aa44a97a340cdbdb9462f1b b2e103a12cce4db895806d83f407c5fa 5675d99c3aa44a97a340cdbdb9462f1b--b2e103a12cce4db895806d83f407c5fa e69f563750d344a28b08499cdee8e010 b2e103a12cce4db895806d83f407c5fa--e69f563750d344a28b08499cdee8e010 219ee560241c4474949d3923d1f2724e e69f563750d344a28b08499cdee8e010--219ee560241c4474949d3923d1f2724e cc323b627e894c76b005e454dbd5d662 219ee560241c4474949d3923d1f2724e--cc323b627e894c76b005e454dbd5d662 481186c0da0142de9e7f52a1cca5778a cc323b627e894c76b005e454dbd5d662--481186c0da0142de9e7f52a1cca5778a 87a718d2a9bb4f51a81afb500707e52e 481186c0da0142de9e7f52a1cca5778a--87a718d2a9bb4f51a81afb500707e52e 0f119027dfc2462e9cfd01e9f3e21c3d 87a718d2a9bb4f51a81afb500707e52e--0f119027dfc2462e9cfd01e9f3e21c3d 011eee2b5ad8418ba4f1badf7626aacc 0f119027dfc2462e9cfd01e9f3e21c3d--011eee2b5ad8418ba4f1badf7626aacc 5417ec44d3cc430ebfeae2f9fedc7db7 011eee2b5ad8418ba4f1badf7626aacc--5417ec44d3cc430ebfeae2f9fedc7db7 0b57cd397bab447892a3e14e4bbf9b08 5417ec44d3cc430ebfeae2f9fedc7db7--0b57cd397bab447892a3e14e4bbf9b08 0928eddc5f154ef1bd3b8ec75f92bd93 0b57cd397bab447892a3e14e4bbf9b08--0928eddc5f154ef1bd3b8ec75f92bd93 aa4e452b6b644d81aaf3bf05a243de28 0928eddc5f154ef1bd3b8ec75f92bd93--aa4e452b6b644d81aaf3bf05a243de28 f527090e5c064ea7b35e25cd593c4987 aa4e452b6b644d81aaf3bf05a243de28--f527090e5c064ea7b35e25cd593c4987 b0c8ab7f695642f6a6bcd737403db4f9 f527090e5c064ea7b35e25cd593c4987--b0c8ab7f695642f6a6bcd737403db4f9 510b1c1b05ea444ab2660c7a8bc14045 b0c8ab7f695642f6a6bcd737403db4f9--510b1c1b05ea444ab2660c7a8bc14045 4c350cc93275458393a2fc494403f3ba 510b1c1b05ea444ab2660c7a8bc14045--4c350cc93275458393a2fc494403f3ba 36f15605a64f4c8e901d56948388101e 4c350cc93275458393a2fc494403f3ba--36f15605a64f4c8e901d56948388101e 9a7664e8b9f74524bc9107b0449a2fbb 36f15605a64f4c8e901d56948388101e--9a7664e8b9f74524bc9107b0449a2fbb ac4eb7f0a98d49ffb0ece8ae7182702b 9a7664e8b9f74524bc9107b0449a2fbb--ac4eb7f0a98d49ffb0ece8ae7182702b 5f6c3577b5ad47ff83ca09f9fed394c4 ac4eb7f0a98d49ffb0ece8ae7182702b--5f6c3577b5ad47ff83ca09f9fed394c4 e8d0aa7f62974e0091c732a4f76ea520 5f6c3577b5ad47ff83ca09f9fed394c4--e8d0aa7f62974e0091c732a4f76ea520 d3bccd013b414a03b8b0525f23db67b6 X e8d0aa7f62974e0091c732a4f76ea520--d3bccd013b414a03b8b0525f23db67b6 d3bccd013b414a03b8b0525f23db67b6--d306887dfdef44798ca8c4dc383fa631 7b32018a3c5b43f3b31b01d1fb7efb0e RZ(-1.0*g1) d3bccd013b414a03b8b0525f23db67b6--7b32018a3c5b43f3b31b01d1fb7efb0e e69b65c02161435d8016fcff1631b087 X 7b32018a3c5b43f3b31b01d1fb7efb0e--e69b65c02161435d8016fcff1631b087 e69b65c02161435d8016fcff1631b087--f0cd9c63a941463cbb9a4117afdd96cc 24ed44ba55d1462cac3ea70a1c2328c2 e69b65c02161435d8016fcff1631b087--24ed44ba55d1462cac3ea70a1c2328c2 c340d16decc046e2ad8e3a88dd8de4d5 24ed44ba55d1462cac3ea70a1c2328c2--c340d16decc046e2ad8e3a88dd8de4d5 999fb59ffc7540829abd878e9857907f c340d16decc046e2ad8e3a88dd8de4d5--999fb59ffc7540829abd878e9857907f 14c7c254a6b643ed9dede0b28a44cbd6 999fb59ffc7540829abd878e9857907f--14c7c254a6b643ed9dede0b28a44cbd6 83604b1f864a43a082d2311679d843fd 14c7c254a6b643ed9dede0b28a44cbd6--83604b1f864a43a082d2311679d843fd a07c29fb966747108a3feb494c9fff7a 83604b1f864a43a082d2311679d843fd--a07c29fb966747108a3feb494c9fff7a 23dd24f286da420d83461ccb2f24e9fb a07c29fb966747108a3feb494c9fff7a--23dd24f286da420d83461ccb2f24e9fb b86d0b5b0e22435293c13314afbf20a0 23dd24f286da420d83461ccb2f24e9fb--b86d0b5b0e22435293c13314afbf20a0 f2134659ee8c492d9ebc7a83270cf3be b86d0b5b0e22435293c13314afbf20a0--f2134659ee8c492d9ebc7a83270cf3be 8369434af16f405cb8a04497e6ca270a f2134659ee8c492d9ebc7a83270cf3be--8369434af16f405cb8a04497e6ca270a 55ed7dce718140f7a026b0b1a7bd597e 8369434af16f405cb8a04497e6ca270a--55ed7dce718140f7a026b0b1a7bd597e b020a28a7e9a4490a0a3ce2a52a148f6 55ed7dce718140f7a026b0b1a7bd597e--b020a28a7e9a4490a0a3ce2a52a148f6 655ca6021fab4067b97e2ce3182d1678 b020a28a7e9a4490a0a3ce2a52a148f6--655ca6021fab4067b97e2ce3182d1678 02988e4a3c724e778c0d1f4236611c22 655ca6021fab4067b97e2ce3182d1678--02988e4a3c724e778c0d1f4236611c22 dfa87cd6becd45598a948a0c266249cc 02988e4a3c724e778c0d1f4236611c22--dfa87cd6becd45598a948a0c266249cc 8ecfcd8234814a5c9e9133b6d845820b dfa87cd6becd45598a948a0c266249cc--8ecfcd8234814a5c9e9133b6d845820b 2aebb059a16542d395859639ac99b57d 8ecfcd8234814a5c9e9133b6d845820b--2aebb059a16542d395859639ac99b57d 83763f3192cb4004883be23cc6febd5a 2aebb059a16542d395859639ac99b57d--83763f3192cb4004883be23cc6febd5a 214bc37aa91d4866ba272a1a39cf9df7 83763f3192cb4004883be23cc6febd5a--214bc37aa91d4866ba272a1a39cf9df7 47487e7e35614cf49762689decac231b 214bc37aa91d4866ba272a1a39cf9df7--47487e7e35614cf49762689decac231b b7008f42c4c248f7ad832238e5f79410 47487e7e35614cf49762689decac231b--b7008f42c4c248f7ad832238e5f79410 6d490e90272444e0bf05da5c89da4d5c b7008f42c4c248f7ad832238e5f79410--6d490e90272444e0bf05da5c89da4d5c 0afee8734c08438eb878e7f774ae2595 X 6d490e90272444e0bf05da5c89da4d5c--0afee8734c08438eb878e7f774ae2595 0afee8734c08438eb878e7f774ae2595--8dcb8fe714ec4a748118be8fc8f430be 04528d61d8094308b064311e9ac359b3 RZ(-1.0*g1) 0afee8734c08438eb878e7f774ae2595--04528d61d8094308b064311e9ac359b3 1af2c04726ce466a982274e3edfb2309 X 04528d61d8094308b064311e9ac359b3--1af2c04726ce466a982274e3edfb2309 1af2c04726ce466a982274e3edfb2309--0780ac9dcc924a29b00a6029c580aa29 6cc1a470836346469c4d836c34abfdec 1af2c04726ce466a982274e3edfb2309--6cc1a470836346469c4d836c34abfdec 4df6e5c41c534efda443124cd5df0a52 6cc1a470836346469c4d836c34abfdec--4df6e5c41c534efda443124cd5df0a52 ad5ba303cf5b4bc797dad8153e7a3f18 4df6e5c41c534efda443124cd5df0a52--ad5ba303cf5b4bc797dad8153e7a3f18 ff0fbf9af13440d1a76acd47cac045ec ad5ba303cf5b4bc797dad8153e7a3f18--ff0fbf9af13440d1a76acd47cac045ec 34c6fcc79bb54f28897452f52b4c3d7c ff0fbf9af13440d1a76acd47cac045ec--34c6fcc79bb54f28897452f52b4c3d7c 3d36dcf33e9f43b7aff9927ddcd06927 34c6fcc79bb54f28897452f52b4c3d7c--3d36dcf33e9f43b7aff9927ddcd06927 ddbc082046a045209f4fdd8d5865c86c 3d36dcf33e9f43b7aff9927ddcd06927--ddbc082046a045209f4fdd8d5865c86c d3db874f768e4e29b1ef9326144c93e0 ddbc082046a045209f4fdd8d5865c86c--d3db874f768e4e29b1ef9326144c93e0 013318dee1e745069ee2ffda0c4ba904 d3db874f768e4e29b1ef9326144c93e0--013318dee1e745069ee2ffda0c4ba904 a8084b00421f4c34b9697e929574d282 013318dee1e745069ee2ffda0c4ba904--a8084b00421f4c34b9697e929574d282 712ac16067bb4e8387bae053a1c427bd a8084b00421f4c34b9697e929574d282--712ac16067bb4e8387bae053a1c427bd 7f5208a3ca644d42a78645f8537bdb4c 712ac16067bb4e8387bae053a1c427bd--7f5208a3ca644d42a78645f8537bdb4c a597fabfc2a2412997832187c9731689 7f5208a3ca644d42a78645f8537bdb4c--a597fabfc2a2412997832187c9731689 ac87c0217df3424a9f4996612f865f62 a597fabfc2a2412997832187c9731689--ac87c0217df3424a9f4996612f865f62 c97233ec01b747fe8529665d00e213b4 ac87c0217df3424a9f4996612f865f62--c97233ec01b747fe8529665d00e213b4 173255211ec44d74bfb2c2e072e9ddc6 c97233ec01b747fe8529665d00e213b4--173255211ec44d74bfb2c2e072e9ddc6 39513e01895840c4b346b4b7c963e413 173255211ec44d74bfb2c2e072e9ddc6--39513e01895840c4b346b4b7c963e413 ff7242d7ba74497d8f79f22a6397bc42 39513e01895840c4b346b4b7c963e413--ff7242d7ba74497d8f79f22a6397bc42 c3ae4aae82bf44108a0e56443c4fa24e ff7242d7ba74497d8f79f22a6397bc42--c3ae4aae82bf44108a0e56443c4fa24e 6151d94021cc41b8ac0d6c6b139fd0d3 c3ae4aae82bf44108a0e56443c4fa24e--6151d94021cc41b8ac0d6c6b139fd0d3 3de46bd1977041169c692e84257a2b55 6151d94021cc41b8ac0d6c6b139fd0d3--3de46bd1977041169c692e84257a2b55 bcf0c67b93bf4effb48bf22b24d78102 3de46bd1977041169c692e84257a2b55--bcf0c67b93bf4effb48bf22b24d78102 47b8eaa210a24a66aaa9e99336028af8 bcf0c67b93bf4effb48bf22b24d78102--47b8eaa210a24a66aaa9e99336028af8 1005c146706146798a6f2de2be96072d 47b8eaa210a24a66aaa9e99336028af8--1005c146706146798a6f2de2be96072d 84e278c5acb3420b967e7fc9510439b9 1005c146706146798a6f2de2be96072d--84e278c5acb3420b967e7fc9510439b9 8911e25b8d5645a692bb86b01bc4f105 84e278c5acb3420b967e7fc9510439b9--8911e25b8d5645a692bb86b01bc4f105 8880cd48936a468b8fcb6cff49769be3 8911e25b8d5645a692bb86b01bc4f105--8880cd48936a468b8fcb6cff49769be3 408cb1c225824da8abe16fbfe2889513 8880cd48936a468b8fcb6cff49769be3--408cb1c225824da8abe16fbfe2889513 a392f1bd7cab4a6b99317616f82af761 X 408cb1c225824da8abe16fbfe2889513--a392f1bd7cab4a6b99317616f82af761 a392f1bd7cab4a6b99317616f82af761--5e2459c39930411fbbe0d77f45721bd1 d1be9c56d7054e83971ab5d8c6017e24 RZ(-1.0*g1) a392f1bd7cab4a6b99317616f82af761--d1be9c56d7054e83971ab5d8c6017e24 b883cd3abc314ed3832cae657cd09d2e X d1be9c56d7054e83971ab5d8c6017e24--b883cd3abc314ed3832cae657cd09d2e b883cd3abc314ed3832cae657cd09d2e--f88deb779c404fac8791f91fd176741c 3c14e6f82f284ad6bc15b5d3f118ccba b883cd3abc314ed3832cae657cd09d2e--3c14e6f82f284ad6bc15b5d3f118ccba fd065e22b8ef45709acd2ee8bb6848ce 3c14e6f82f284ad6bc15b5d3f118ccba--fd065e22b8ef45709acd2ee8bb6848ce 40bf4ae6479e4239816d55e2789a7acc fd065e22b8ef45709acd2ee8bb6848ce--40bf4ae6479e4239816d55e2789a7acc ed447e231eb849448855aa019204549d 40bf4ae6479e4239816d55e2789a7acc--ed447e231eb849448855aa019204549d cea94cf3e3174582b1dc8bada97d2187 ed447e231eb849448855aa019204549d--cea94cf3e3174582b1dc8bada97d2187 8b300e2d8e6d4b5fa0d5235658e75ba3 cea94cf3e3174582b1dc8bada97d2187--8b300e2d8e6d4b5fa0d5235658e75ba3 fb156130259a4557a843dfd3f59c0801 8b300e2d8e6d4b5fa0d5235658e75ba3--fb156130259a4557a843dfd3f59c0801 4a89505c74dd494bb69821e8f6d5448d fb156130259a4557a843dfd3f59c0801--4a89505c74dd494bb69821e8f6d5448d 25910e80c34348fe804e44cb41760a30 4a89505c74dd494bb69821e8f6d5448d--25910e80c34348fe804e44cb41760a30 fd0a88cb01c049b3b4bbbe710e29d2f9 25910e80c34348fe804e44cb41760a30--fd0a88cb01c049b3b4bbbe710e29d2f9 57a311e68e2f46b29cdc44a343835963 fd0a88cb01c049b3b4bbbe710e29d2f9--57a311e68e2f46b29cdc44a343835963 fa9f93f9d0b9460b82a70943f7107048 RX(b17) 57a311e68e2f46b29cdc44a343835963--fa9f93f9d0b9460b82a70943f7107048 fa9f93f9d0b9460b82a70943f7107048--0ad1e598127441ff827cfe314e709c6c"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -3.115794453675419\nMaxCut cost at iteration 10: 8.465058124705356\nMaxCut cost at iteration 20: 8.964545421604518\nMaxCut cost at iteration 30: 8.980653911935578\nMaxCut cost at iteration 40: 8.995287928446979\nMaxCut cost at iteration 50: 8.998077804029933\nMaxCut cost at iteration 60: 8.999717160374455\nMaxCut cost at iteration 70: 8.999965418506338\nMaxCut cost at iteration 80: 8.999995869432022\nMaxCut cost at iteration 90: 8.999999507990733\nMaxCut cost at iteration 100: 8.999999941413137\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 00001011  2023-11-06T13:38:29.433948 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.006756732932883181\nEpoch 40 - Loss: 0.0013178262682413972\nEpoch 60 - Loss: 0.0002441127538579178\nEpoch 80 - Loss: 1.8109270091472366e-05\nEpoch 100 - Loss: 3.3443547512339797e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-11-06T13:38:35.449100 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\nn_qubits = 3\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_350ba08ff9cb463089c276cbc2d4c8e6 Constant Chebyshev FM cluster_4317d85f3dce4f6c9b36a26d74d8b985 Constant Fourier FM cc86284a4bea426aabdf5de6cd533e8a 0 ef508573b7264e78aa728453f10f1129 RX(phi) cc86284a4bea426aabdf5de6cd533e8a--ef508573b7264e78aa728453f10f1129 eb1b2fd7a39a4f32ac2bac9199ea53f0 1 a9374494c8dd407184a06c43664da8c8 RX(acos(phi)) ef508573b7264e78aa728453f10f1129--a9374494c8dd407184a06c43664da8c8 8a91cc231e5c4acf9d06c72ece941754 a9374494c8dd407184a06c43664da8c8--8a91cc231e5c4acf9d06c72ece941754 ea10c05ef25a4b4398eb414251d26a94 d84d20d67c1c429c9ffa81a0e9433dd6 RX(phi) eb1b2fd7a39a4f32ac2bac9199ea53f0--d84d20d67c1c429c9ffa81a0e9433dd6 24090c6c08db4109bd587ccbb0ffee28 2 2690e26fe55e496ea145745e9b7cbf3b RX(acos(phi)) d84d20d67c1c429c9ffa81a0e9433dd6--2690e26fe55e496ea145745e9b7cbf3b 2690e26fe55e496ea145745e9b7cbf3b--ea10c05ef25a4b4398eb414251d26a94 4f33af69c87443079217676e059c9268 0f503aa4068f4b6ba956d49590e28e68 RX(phi) 24090c6c08db4109bd587ccbb0ffee28--0f503aa4068f4b6ba956d49590e28e68 2ccde7a0b48a49bbbe145c016c88f777 RX(acos(phi)) 0f503aa4068f4b6ba956d49590e28e68--2ccde7a0b48a49bbbe145c016c88f777 2ccde7a0b48a49bbbe145c016c88f777--4f33af69c87443079217676e059c9268 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\nn_qubits = 3\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n@classmethod\ndef eval(cls, x):\nreturn asin(x) + x**2\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_3be9a431962944a3ade4b130944cf9d4 Constant custom_func FM cluster_4417026a7ed84aa18074b3058d00475f Constant asin FM 289772639c594d5c9c0779604667083a 0 bf3ffb347aff42c58d88978b893324e9 RX(asin(phi)) 289772639c594d5c9c0779604667083a--bf3ffb347aff42c58d88978b893324e9 e4295776a9744f4a96ed8262f0a77e95 1 9f0fd3fcc885421297aed634fbda5fc9 RX(phi**2 + asin(phi)) bf3ffb347aff42c58d88978b893324e9--9f0fd3fcc885421297aed634fbda5fc9 bd4818b0b05042738b038a6f66f73515 9f0fd3fcc885421297aed634fbda5fc9--bd4818b0b05042738b038a6f66f73515 046cc74cfd58431895a2bc32db8540f3 ceca6e6e6c454ab8a44849d290371c90 RX(asin(phi)) e4295776a9744f4a96ed8262f0a77e95--ceca6e6e6c454ab8a44849d290371c90 02f48bc507f343dd8d6c5deb42adc914 2 17e63bc87aa44927a497dca0dc86b889 RX(phi**2 + asin(phi)) ceca6e6e6c454ab8a44849d290371c90--17e63bc87aa44927a497dca0dc86b889 17e63bc87aa44927a497dca0dc86b889--046cc74cfd58431895a2bc32db8540f3 0d57c71a7c774812a63d9cd40c72f6af 5786ce3b132841e2960688c1bd8602d5 RX(asin(phi)) 02f48bc507f343dd8d6c5deb42adc914--5786ce3b132841e2960688c1bd8602d5 cb51103389d74a43849265408b6ee6e1 RX(phi**2 + asin(phi)) 5786ce3b132841e2960688c1bd8602d5--cb51103389d74a43849265408b6ee6e1 cb51103389d74a43849265408b6ee6e1--0d57c71a7c774812a63d9cd40c72f6af <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\nn_qubits = 5\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_4d14f74e52934a468df0d9e16e6be9bf Exponential Fourier FM cluster_3714cddb91a44bf897d184bd9d110e72 Constant Fourier FM cluster_01bcad2d2d824a0790edced052aa5617 Tower Fourier FM 1c4e1860d750435fb1555b9586bcd305 0 b5aa4bb4661446dda153df713fd61361 RX(phi) 1c4e1860d750435fb1555b9586bcd305--b5aa4bb4661446dda153df713fd61361 6816ff0a19d346fab289caf1858d9b10 1 6cb89d71fff246c08461394579dbf3eb RX(1.0*phi) b5aa4bb4661446dda153df713fd61361--6cb89d71fff246c08461394579dbf3eb bfbaa83b091e46ef8e35066fbda58cbd RX(1.0*phi) 6cb89d71fff246c08461394579dbf3eb--bfbaa83b091e46ef8e35066fbda58cbd 7157d5fb158f41a6857e1a4053794ed2 bfbaa83b091e46ef8e35066fbda58cbd--7157d5fb158f41a6857e1a4053794ed2 7c0ad40be63847d0aacc56f1b1da860d 45bddfb0b7b84196b7cd55a7364bb26d RX(phi) 6816ff0a19d346fab289caf1858d9b10--45bddfb0b7b84196b7cd55a7364bb26d 4ff2113dd14c49c88cd9fc4012d27af1 2 93ee3018557242ce8d93160aa2b79950 RX(2.0*phi) 45bddfb0b7b84196b7cd55a7364bb26d--93ee3018557242ce8d93160aa2b79950 5e58391508d14d788329d32165816130 RX(2.0*phi) 93ee3018557242ce8d93160aa2b79950--5e58391508d14d788329d32165816130 5e58391508d14d788329d32165816130--7c0ad40be63847d0aacc56f1b1da860d 9bdcd5803c1f45669c48cb7334587315 7e8851f6399f4233885c351a9ff8cdf8 RX(phi) 4ff2113dd14c49c88cd9fc4012d27af1--7e8851f6399f4233885c351a9ff8cdf8 9b223676c9c549b189edd79a43b526ad 3 c53e55209b6b4686ab0f5b591389c7c5 RX(3.0*phi) 7e8851f6399f4233885c351a9ff8cdf8--c53e55209b6b4686ab0f5b591389c7c5 ff12a9e3aa154b2e89e02a219061d4b3 RX(4.0*phi) c53e55209b6b4686ab0f5b591389c7c5--ff12a9e3aa154b2e89e02a219061d4b3 ff12a9e3aa154b2e89e02a219061d4b3--9bdcd5803c1f45669c48cb7334587315 3376d3958d0d447399de576060d65e9c acd0469ab767498492e9501aa051b905 RX(phi) 9b223676c9c549b189edd79a43b526ad--acd0469ab767498492e9501aa051b905 1081566b43364ee3b919c3f060bb9d22 4 f86cc6f1dff945e8944feba003f14185 RX(4.0*phi) acd0469ab767498492e9501aa051b905--f86cc6f1dff945e8944feba003f14185 38b4d746be784775b6993470e81a7b22 RX(8.0*phi) f86cc6f1dff945e8944feba003f14185--38b4d746be784775b6993470e81a7b22 38b4d746be784775b6993470e81a7b22--3376d3958d0d447399de576060d65e9c e94ba18da4b14fd298fb56d4d41781c8 ae770bf9e26c4253b8fde6566f8be951 RX(phi) 1081566b43364ee3b919c3f060bb9d22--ae770bf9e26c4253b8fde6566f8be951 5624b278bae6400faafbd51467e39dcd RX(5.0*phi) ae770bf9e26c4253b8fde6566f8be951--5624b278bae6400faafbd51467e39dcd 103e2eae10f546eead316669461d7cc0 RX(16.0*phi) 5624b278bae6400faafbd51467e39dcd--103e2eae10f546eead316669461d7cc0 103e2eae10f546eead316669461d7cc0--e94ba18da4b14fd298fb56d4d41781c8 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\ndef custom_scaling(i: int) -&gt; int | float:\n\"\"\"Sqrt(i+1)\"\"\"\nreturn (i+1) ** (0.5)\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 f4ef25442f384ec5b16ea776fce29c0c 0 d3943e35b30c4aabab6d0243fbf65a45 RX(1.0*acos(phi)) f4ef25442f384ec5b16ea776fce29c0c--d3943e35b30c4aabab6d0243fbf65a45 16854b6976a34d918579f1a961f20869 1 178816f24ab34b7a80ff5c04d148b4ca d3943e35b30c4aabab6d0243fbf65a45--178816f24ab34b7a80ff5c04d148b4ca 53a2233dc1ff41e8970766cdcb5d1ad6 0c4f0d3a9f944c68b25f7f4263d84057 RX(1.414*acos(phi)) 16854b6976a34d918579f1a961f20869--0c4f0d3a9f944c68b25f7f4263d84057 a4226da978394c10a112678417104318 2 0c4f0d3a9f944c68b25f7f4263d84057--53a2233dc1ff41e8970766cdcb5d1ad6 e873cd04ab65489c89fc88a1255367a4 2b011deba47447f0afa069519748f040 RX(1.732*acos(phi)) a4226da978394c10a112678417104318--2b011deba47447f0afa069519748f040 1e52e3c3e577466dadd8727c15f00f42 3 2b011deba47447f0afa069519748f040--e873cd04ab65489c89fc88a1255367a4 862db48e390347838cbbbc2c4d795f53 d1445e1daaeb49f98317016cab30f552 RX(2.0*acos(phi)) 1e52e3c3e577466dadd8727c15f00f42--d1445e1daaeb49f98317016cab30f552 b5873664a9ac467ab8105f36e0518d2d 4 d1445e1daaeb49f98317016cab30f552--862db48e390347838cbbbc2c4d795f53 5a5f9244283b405d9b90b922594de2a1 4b333db643aa4c0fbf561ead5f51eccb RX(2.236*acos(phi)) b5873664a9ac467ab8105f36e0518d2d--4b333db643aa4c0fbf561ead5f51eccb 4b333db643aa4c0fbf561ead5f51eccb--5a5f9244283b405d9b90b922594de2a1 <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\nn_qubits = 5\n# Custom scaling function\nfm_full = feature_map(\nn_qubits = n_qubits,\nsupport = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\nparam = \"x\", # Change the name of the parameter\nop = RY, # Change the rotation gate between RX, RY, RZ or PHASE\nfm_type = BasisSet.CHEBYSHEV,\nreupload_scaling = ReuploadScaling.EXP,\nfeature_range = (-1.0, 2.0), # Range from which the input data comes from\ntarget_range = (1.0, 3.0), # Range the encoder assumes as the natural range\nmultiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 b5632aa308f84128bc847859d440f9f4 0 de458fa4ac68465a9463c160fe4d75fb RY(80.0*acos(0.667*x + 1.667)) b5632aa308f84128bc847859d440f9f4--de458fa4ac68465a9463c160fe4d75fb cc11c85e46d84ebe9bf26ac49a94df50 1 f90117d3b912409c921c5c1b6209ca6d de458fa4ac68465a9463c160fe4d75fb--f90117d3b912409c921c5c1b6209ca6d a4c87b10be9c4d62ac51cf9fcaa72e90 7becff7a4ed947dbb0e56191ca5e3339 RY(40.0*acos(0.667*x + 1.667)) cc11c85e46d84ebe9bf26ac49a94df50--7becff7a4ed947dbb0e56191ca5e3339 974d95ff83b84768a5c87c8a060659ed 2 7becff7a4ed947dbb0e56191ca5e3339--a4c87b10be9c4d62ac51cf9fcaa72e90 e4776c60cd6d4b2a81674aa19a9aa370 83c03faf96ae431bb3a82d3fe12d5ca9 RY(20.0*acos(0.667*x + 1.667)) 974d95ff83b84768a5c87c8a060659ed--83c03faf96ae431bb3a82d3fe12d5ca9 d7459a19aa3b4ea694726989366e90d0 3 83c03faf96ae431bb3a82d3fe12d5ca9--e4776c60cd6d4b2a81674aa19a9aa370 28863647b06e47889c46a343172e85a3 0454ff49b6cc454e935c50b66038b2ce RY(10.0*acos(0.667*x + 1.667)) d7459a19aa3b4ea694726989366e90d0--0454ff49b6cc454e935c50b66038b2ce c87a3e3bd93a48bfa8148010f7a5e121 4 0454ff49b6cc454e935c50b66038b2ce--28863647b06e47889c46a343172e85a3 8d3d49cfa5af4229a7c9c4377395d235 4163c577150840cb83fe7b675a283017 RY(5.0*acos(0.667*x + 1.667)) c87a3e3bd93a48bfa8148010f7a5e121--4163c577150840cb83fe7b675a283017 4163c577150840cb83fe7b675a283017--8d3d49cfa5af4229a7c9c4377395d235"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> %3 e21c24fc052542edb6a47053a1c0a4a3 0 439516cc68cc461b9467842b1fd48f0b RX(theta\u2080) e21c24fc052542edb6a47053a1c0a4a3--439516cc68cc461b9467842b1fd48f0b 7e2013782b9449e78729d03838845a95 1 ee837d7db5c544e4b92eca6935c647ed RY(theta\u2083) 439516cc68cc461b9467842b1fd48f0b--ee837d7db5c544e4b92eca6935c647ed 76ccb20cffcc46d2b7cf9da73b2cf0d1 RX(theta\u2086) ee837d7db5c544e4b92eca6935c647ed--76ccb20cffcc46d2b7cf9da73b2cf0d1 89c1a526c6824ceeb58a4021bba46191 76ccb20cffcc46d2b7cf9da73b2cf0d1--89c1a526c6824ceeb58a4021bba46191 8fce1d1889164094ac579186ecc3a051 89c1a526c6824ceeb58a4021bba46191--8fce1d1889164094ac579186ecc3a051 a60ec11d4cec4ae481a0a0d9f3516c96 RX(theta\u2089) 8fce1d1889164094ac579186ecc3a051--a60ec11d4cec4ae481a0a0d9f3516c96 0c0192107ce547c8878f13bbbc5ddf0e RY(theta\u2081\u2082) a60ec11d4cec4ae481a0a0d9f3516c96--0c0192107ce547c8878f13bbbc5ddf0e 3b3c056095ac497a8f7c19ca36ba3c9f RX(theta\u2081\u2085) 0c0192107ce547c8878f13bbbc5ddf0e--3b3c056095ac497a8f7c19ca36ba3c9f 86ab8d8f23b24483b4e7fb6ee02bb775 3b3c056095ac497a8f7c19ca36ba3c9f--86ab8d8f23b24483b4e7fb6ee02bb775 2cb9c961b11749d9ac512fb0c7f7862f 86ab8d8f23b24483b4e7fb6ee02bb775--2cb9c961b11749d9ac512fb0c7f7862f 2b1ebe2ead92452c96b32c6ddbcac6c4 2cb9c961b11749d9ac512fb0c7f7862f--2b1ebe2ead92452c96b32c6ddbcac6c4 c01a4f0f27354085a0c86ad41295c812 105be152b5994071aa12c97745544a14 RX(theta\u2081) 7e2013782b9449e78729d03838845a95--105be152b5994071aa12c97745544a14 ae8bb4471e5d4d1ea06a7ff7abc8518e 2 9f214d09ce5745d193b372cf1d984272 RY(theta\u2084) 105be152b5994071aa12c97745544a14--9f214d09ce5745d193b372cf1d984272 dcbf7200ab514f94bcfa8bf040344936 RX(theta\u2087) 9f214d09ce5745d193b372cf1d984272--dcbf7200ab514f94bcfa8bf040344936 310ff1772d5d4a7185f4303abfdc8990 X dcbf7200ab514f94bcfa8bf040344936--310ff1772d5d4a7185f4303abfdc8990 310ff1772d5d4a7185f4303abfdc8990--89c1a526c6824ceeb58a4021bba46191 718e73c0f2584e5d841f80eb24379666 310ff1772d5d4a7185f4303abfdc8990--718e73c0f2584e5d841f80eb24379666 0f23eab12e4540569bd5018f98fa1140 RX(theta\u2081\u2080) 718e73c0f2584e5d841f80eb24379666--0f23eab12e4540569bd5018f98fa1140 4c7295beec0c4f05966e3488d449cac0 RY(theta\u2081\u2083) 0f23eab12e4540569bd5018f98fa1140--4c7295beec0c4f05966e3488d449cac0 875eaf3284cd484897b41542fc5ea6fd RX(theta\u2081\u2086) 4c7295beec0c4f05966e3488d449cac0--875eaf3284cd484897b41542fc5ea6fd 9f08692120fa452c96c9f49b6888c425 X 875eaf3284cd484897b41542fc5ea6fd--9f08692120fa452c96c9f49b6888c425 9f08692120fa452c96c9f49b6888c425--86ab8d8f23b24483b4e7fb6ee02bb775 92ba5826adc0425794855d89aa530c6f 9f08692120fa452c96c9f49b6888c425--92ba5826adc0425794855d89aa530c6f 92ba5826adc0425794855d89aa530c6f--c01a4f0f27354085a0c86ad41295c812 f820eeadcdb7420d94f6c126645e2a23 cfaa46beabf1489b93207868005ca2e5 RX(theta\u2082) ae8bb4471e5d4d1ea06a7ff7abc8518e--cfaa46beabf1489b93207868005ca2e5 a71f8fb557154eb39e06a609034dfc68 RY(theta\u2085) cfaa46beabf1489b93207868005ca2e5--a71f8fb557154eb39e06a609034dfc68 b1e533493d994de68fde91aa962611c0 RX(theta\u2088) a71f8fb557154eb39e06a609034dfc68--b1e533493d994de68fde91aa962611c0 bc7d6a2580d74aabb82c60fe7fcacd7f b1e533493d994de68fde91aa962611c0--bc7d6a2580d74aabb82c60fe7fcacd7f 5ccb00bcbb2749ada884eec1d750c3b0 X bc7d6a2580d74aabb82c60fe7fcacd7f--5ccb00bcbb2749ada884eec1d750c3b0 5ccb00bcbb2749ada884eec1d750c3b0--718e73c0f2584e5d841f80eb24379666 ceed0891a8a4409682993386089dbedd RX(theta\u2081\u2081) 5ccb00bcbb2749ada884eec1d750c3b0--ceed0891a8a4409682993386089dbedd a016b4ae924b40bf90247bb9398778cf RY(theta\u2081\u2084) ceed0891a8a4409682993386089dbedd--a016b4ae924b40bf90247bb9398778cf c01b8419044e46b99bc70649609da8dc RX(theta\u2081\u2087) a016b4ae924b40bf90247bb9398778cf--c01b8419044e46b99bc70649609da8dc e895f74f9b6f4a9e8b7ee04e2acbb1b6 c01b8419044e46b99bc70649609da8dc--e895f74f9b6f4a9e8b7ee04e2acbb1b6 6b3267617bdf40f792d349f8bd6c635b X e895f74f9b6f4a9e8b7ee04e2acbb1b6--6b3267617bdf40f792d349f8bd6c635b 6b3267617bdf40f792d349f8bd6c635b--92ba5826adc0425794855d89aa530c6f 6b3267617bdf40f792d349f8bd6c635b--f820eeadcdb7420d94f6c126645e2a23 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> %3 791318d59d7843bebc04275ffb0be549 0 b9dd1ba1b324495490ff0000c9ba127f RX(phi\u2080) 791318d59d7843bebc04275ffb0be549--b9dd1ba1b324495490ff0000c9ba127f 9b4f676b5df441ea8d0de4d37f7cdca0 1 9934e30d6d8e4b9fb13df91336f00520 RY(phi\u2083) b9dd1ba1b324495490ff0000c9ba127f--9934e30d6d8e4b9fb13df91336f00520 1ff04adf8f804ea6b55c18c3ac929091 RX(phi\u2086) 9934e30d6d8e4b9fb13df91336f00520--1ff04adf8f804ea6b55c18c3ac929091 335b8f84cac344a9a1db3e8e6a1b607a 1ff04adf8f804ea6b55c18c3ac929091--335b8f84cac344a9a1db3e8e6a1b607a 1e0ddfe2e2de4a92bbadf3d4f3680de7 335b8f84cac344a9a1db3e8e6a1b607a--1e0ddfe2e2de4a92bbadf3d4f3680de7 df2bc4855bca4491b98767573b56eab8 RX(phi\u2089) 1e0ddfe2e2de4a92bbadf3d4f3680de7--df2bc4855bca4491b98767573b56eab8 fa417801d3a5491aafd044883d231b9c RY(phi\u2081\u2082) df2bc4855bca4491b98767573b56eab8--fa417801d3a5491aafd044883d231b9c ab7a82c692bc44b8be4878f412c0536c RX(phi\u2081\u2085) fa417801d3a5491aafd044883d231b9c--ab7a82c692bc44b8be4878f412c0536c 143adf944e2d460ea81d7543e00846e0 ab7a82c692bc44b8be4878f412c0536c--143adf944e2d460ea81d7543e00846e0 48669bd562fb4b979de366ee22582399 143adf944e2d460ea81d7543e00846e0--48669bd562fb4b979de366ee22582399 0e5f844df50046259a0a2dfd9ae1b039 48669bd562fb4b979de366ee22582399--0e5f844df50046259a0a2dfd9ae1b039 b88b70728859409f834bbe38b798d5ce c5e44b9856bd4fc7a92f914927d7f51b RX(phi\u2081) 9b4f676b5df441ea8d0de4d37f7cdca0--c5e44b9856bd4fc7a92f914927d7f51b 91134d634614441a923419111080d0f6 2 2526fd7f7fa447a6a5ac4fe0247ed2e7 RY(phi\u2084) c5e44b9856bd4fc7a92f914927d7f51b--2526fd7f7fa447a6a5ac4fe0247ed2e7 41e23ef2c0b24f08a53de839c1660f48 RX(phi\u2087) 2526fd7f7fa447a6a5ac4fe0247ed2e7--41e23ef2c0b24f08a53de839c1660f48 32a2e692e0df4528886a080bf8a15cfc PHASE(phi_ent\u2080) 41e23ef2c0b24f08a53de839c1660f48--32a2e692e0df4528886a080bf8a15cfc 32a2e692e0df4528886a080bf8a15cfc--335b8f84cac344a9a1db3e8e6a1b607a 61bcd5924af044af840c110f18e185d8 32a2e692e0df4528886a080bf8a15cfc--61bcd5924af044af840c110f18e185d8 13f0ba3e0a014a2799f2f7783248c229 RX(phi\u2081\u2080) 61bcd5924af044af840c110f18e185d8--13f0ba3e0a014a2799f2f7783248c229 a2ec1b1b6a984af5bc22b4d2a4abd0fe RY(phi\u2081\u2083) 13f0ba3e0a014a2799f2f7783248c229--a2ec1b1b6a984af5bc22b4d2a4abd0fe 36c97328e4d94d00b594b6c5f7c3793d RX(phi\u2081\u2086) a2ec1b1b6a984af5bc22b4d2a4abd0fe--36c97328e4d94d00b594b6c5f7c3793d e2f5aa585fed474d9a83abd2addeb7a2 PHASE(phi_ent\u2082) 36c97328e4d94d00b594b6c5f7c3793d--e2f5aa585fed474d9a83abd2addeb7a2 e2f5aa585fed474d9a83abd2addeb7a2--143adf944e2d460ea81d7543e00846e0 777217e22e4940dab7bd052304f12354 e2f5aa585fed474d9a83abd2addeb7a2--777217e22e4940dab7bd052304f12354 777217e22e4940dab7bd052304f12354--b88b70728859409f834bbe38b798d5ce 9477c897bc8e4610861afd4f9ad269aa df2151d5d7a2456792c7004fc05b6936 RX(phi\u2082) 91134d634614441a923419111080d0f6--df2151d5d7a2456792c7004fc05b6936 6103d2ed02fc41c08b827e1d883021eb RY(phi\u2085) df2151d5d7a2456792c7004fc05b6936--6103d2ed02fc41c08b827e1d883021eb 212980bf3c434ceea993f807941ea05d RX(phi\u2088) 6103d2ed02fc41c08b827e1d883021eb--212980bf3c434ceea993f807941ea05d 010afdf9d15447018695ffba56cc2330 212980bf3c434ceea993f807941ea05d--010afdf9d15447018695ffba56cc2330 518353511fff4100ab0a6b6d0cdbac9f PHASE(phi_ent\u2081) 010afdf9d15447018695ffba56cc2330--518353511fff4100ab0a6b6d0cdbac9f 518353511fff4100ab0a6b6d0cdbac9f--61bcd5924af044af840c110f18e185d8 b7c9a7ebf5ff4b2cab55ad55d3dcf62d RX(phi\u2081\u2081) 518353511fff4100ab0a6b6d0cdbac9f--b7c9a7ebf5ff4b2cab55ad55d3dcf62d ae0c0c7c4a3f4f94bd5f3909d87e9a5d RY(phi\u2081\u2084) b7c9a7ebf5ff4b2cab55ad55d3dcf62d--ae0c0c7c4a3f4f94bd5f3909d87e9a5d 4423a8805f71402a8e0f6e1492e384fe RX(phi\u2081\u2087) ae0c0c7c4a3f4f94bd5f3909d87e9a5d--4423a8805f71402a8e0f6e1492e384fe b9bbd31ca28d4219848a6bd955005a4a 4423a8805f71402a8e0f6e1492e384fe--b9bbd31ca28d4219848a6bd955005a4a c1a66cb1a1a641d3ba0f932ffe05f1d7 PHASE(phi_ent\u2083) b9bbd31ca28d4219848a6bd955005a4a--c1a66cb1a1a641d3ba0f932ffe05f1d7 c1a66cb1a1a641d3ba0f932ffe05f1d7--777217e22e4940dab7bd052304f12354 c1a66cb1a1a641d3ba0f932ffe05f1d7--9477c897bc8e4610861afd4f9ad269aa <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_7e38c06b5704433983ba2af127f98753 cluster_6a266c71fd284561905dab103ef41ede 29ce4fb177804ea4aea061529ff80abb 0 03a51299c0ab42a0a49ac52a85542da2 RX(theta\u2080) 29ce4fb177804ea4aea061529ff80abb--03a51299c0ab42a0a49ac52a85542da2 10e746166bab4fa28985f118f8494854 1 89f03928bbe047ddae5500c530026048 RY(theta\u2083) 03a51299c0ab42a0a49ac52a85542da2--89f03928bbe047ddae5500c530026048 1a65e97beff245129543fac743bba909 RX(theta\u2086) 89f03928bbe047ddae5500c530026048--1a65e97beff245129543fac743bba909 e7b46adc3e064e318b7d6b12613e0423 HamEvo 1a65e97beff245129543fac743bba909--e7b46adc3e064e318b7d6b12613e0423 5ad765cdf547425e9a5a832c6b62b3ff RX(theta\u2089) e7b46adc3e064e318b7d6b12613e0423--5ad765cdf547425e9a5a832c6b62b3ff a29401e012bd4a82bd267f7b3e3ff664 RY(theta\u2081\u2082) 5ad765cdf547425e9a5a832c6b62b3ff--a29401e012bd4a82bd267f7b3e3ff664 4e3406534c8f4aa89f31e2d216ac5a0c RX(theta\u2081\u2085) a29401e012bd4a82bd267f7b3e3ff664--4e3406534c8f4aa89f31e2d216ac5a0c bd1c37de9bd946cdbb664782e9520c22 HamEvo 4e3406534c8f4aa89f31e2d216ac5a0c--bd1c37de9bd946cdbb664782e9520c22 d3b304180a064b6f9077ebeb94fafa8e bd1c37de9bd946cdbb664782e9520c22--d3b304180a064b6f9077ebeb94fafa8e 8cab3d5c8f624bcb8530123c15c9ec9b c2411ead2d3846908cbc89c5ebd5cbf9 RX(theta\u2081) 10e746166bab4fa28985f118f8494854--c2411ead2d3846908cbc89c5ebd5cbf9 56f1c01cfbe14f6ba3bab9203977392e 2 9b6c7b3dfdff44399149f9a39d9f545e RY(theta\u2084) c2411ead2d3846908cbc89c5ebd5cbf9--9b6c7b3dfdff44399149f9a39d9f545e 7828d74951d44ec8ab7963c677de1871 RX(theta\u2087) 9b6c7b3dfdff44399149f9a39d9f545e--7828d74951d44ec8ab7963c677de1871 1a7f0b9918ea488dad68953453db6927 t = theta_t\u2080 7828d74951d44ec8ab7963c677de1871--1a7f0b9918ea488dad68953453db6927 d6081427d2994089aa02b79c568c58d0 RX(theta\u2081\u2080) 1a7f0b9918ea488dad68953453db6927--d6081427d2994089aa02b79c568c58d0 d13028e776bf42c9a73d9e29d73b8e0f RY(theta\u2081\u2083) d6081427d2994089aa02b79c568c58d0--d13028e776bf42c9a73d9e29d73b8e0f f18d1c14c3b749e09da6004cd2f7edde RX(theta\u2081\u2086) d13028e776bf42c9a73d9e29d73b8e0f--f18d1c14c3b749e09da6004cd2f7edde 0a9e66c941f3463da097cc0e3efca4f7 t = theta_t\u2081 f18d1c14c3b749e09da6004cd2f7edde--0a9e66c941f3463da097cc0e3efca4f7 0a9e66c941f3463da097cc0e3efca4f7--8cab3d5c8f624bcb8530123c15c9ec9b 4ef60d6b288a4061832080f6226fa217 ad684a67765a4afda76ddba772f375c0 RX(theta\u2082) 56f1c01cfbe14f6ba3bab9203977392e--ad684a67765a4afda76ddba772f375c0 a8e2bfc786a646e4a0392b556be27cd3 RY(theta\u2085) ad684a67765a4afda76ddba772f375c0--a8e2bfc786a646e4a0392b556be27cd3 4499bcbdc77a48398026cdf939150652 RX(theta\u2088) a8e2bfc786a646e4a0392b556be27cd3--4499bcbdc77a48398026cdf939150652 8f93c77a76244fa8ba4154bfbe6cab4e 4499bcbdc77a48398026cdf939150652--8f93c77a76244fa8ba4154bfbe6cab4e 3f06f11dd90a41c695af1cbe2071cd80 RX(theta\u2081\u2081) 8f93c77a76244fa8ba4154bfbe6cab4e--3f06f11dd90a41c695af1cbe2071cd80 898927eb0bf946309053c5b52c77c44b RY(theta\u2081\u2084) 3f06f11dd90a41c695af1cbe2071cd80--898927eb0bf946309053c5b52c77c44b 90d543704d86487f8dedefbf5eb75796 RX(theta\u2081\u2087) 898927eb0bf946309053c5b52c77c44b--90d543704d86487f8dedefbf5eb75796 0f32ba4c97c747a7acc081da0806bfd3 90d543704d86487f8dedefbf5eb75796--0f32ba4c97c747a7acc081da0806bfd3 0f32ba4c97c747a7acc081da0806bfd3--4ef60d6b288a4061832080f6226fa217 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_9c64cc148b34401ba33f4baa36b86bbe cluster_5011e46363b24816ae68afe699663625 96d13bfd58074633af07c4c412480323 0 86a7345681e64b2aa9a368d1602f182e RX(theta\u2080) 96d13bfd58074633af07c4c412480323--86a7345681e64b2aa9a368d1602f182e 5a23eef080c743219e7483c1d16c787e 1 d68b2616a93541429da88d36893ec297 RY(theta\u2086) 86a7345681e64b2aa9a368d1602f182e--d68b2616a93541429da88d36893ec297 7854314425a845969898696b4de5f6bf RX(theta\u2081\u2082) d68b2616a93541429da88d36893ec297--7854314425a845969898696b4de5f6bf 826e7d9db3f74d59b34fdea8c9e246ad 7854314425a845969898696b4de5f6bf--826e7d9db3f74d59b34fdea8c9e246ad bb5fa20209c94c0488b01b68b3323c4c RX(theta\u2081\u2088) 826e7d9db3f74d59b34fdea8c9e246ad--bb5fa20209c94c0488b01b68b3323c4c 4cc3efdac9854e33b5e072b0ce6d6241 RY(theta\u2082\u2084) bb5fa20209c94c0488b01b68b3323c4c--4cc3efdac9854e33b5e072b0ce6d6241 9f2ffb5fa2a743748415ec514e66c6f5 RX(theta\u2083\u2080) 4cc3efdac9854e33b5e072b0ce6d6241--9f2ffb5fa2a743748415ec514e66c6f5 b4fc4f213be84f1380c2bceff949507a 9f2ffb5fa2a743748415ec514e66c6f5--b4fc4f213be84f1380c2bceff949507a 8f22327a9b324253baab39526faa42ad b4fc4f213be84f1380c2bceff949507a--8f22327a9b324253baab39526faa42ad 2099c5e4fb004ff8a0b515fa9d79d973 1dee22ec0eaa47c198434c2d6bf3536e RX(theta\u2081) 5a23eef080c743219e7483c1d16c787e--1dee22ec0eaa47c198434c2d6bf3536e 5c2b278d03724bd69b2552c5a59b498b 2 b58db3ffaccc4f34b3579c07011c6093 RY(theta\u2087) 1dee22ec0eaa47c198434c2d6bf3536e--b58db3ffaccc4f34b3579c07011c6093 064ffb39e10b4423a72cc64ea5f47d51 RX(theta\u2081\u2083) b58db3ffaccc4f34b3579c07011c6093--064ffb39e10b4423a72cc64ea5f47d51 b345ac59a61d48a882c4a9983b9ab898 064ffb39e10b4423a72cc64ea5f47d51--b345ac59a61d48a882c4a9983b9ab898 31297ab1e829497e9d5338e21b02ae63 RX(theta\u2081\u2089) b345ac59a61d48a882c4a9983b9ab898--31297ab1e829497e9d5338e21b02ae63 2cf875847fa64248bf6532eee3ccb172 RY(theta\u2082\u2085) 31297ab1e829497e9d5338e21b02ae63--2cf875847fa64248bf6532eee3ccb172 ab0ca01a0b29411eb6b416b67faaaf1d RX(theta\u2083\u2081) 2cf875847fa64248bf6532eee3ccb172--ab0ca01a0b29411eb6b416b67faaaf1d b0b47c20b666412dbe0ae223fc2245ab ab0ca01a0b29411eb6b416b67faaaf1d--b0b47c20b666412dbe0ae223fc2245ab b0b47c20b666412dbe0ae223fc2245ab--2099c5e4fb004ff8a0b515fa9d79d973 80453911e44f464ab6ceabd536685e4f da0899e3c4864a73b75dab7a6ddb0c15 RX(theta\u2082) 5c2b278d03724bd69b2552c5a59b498b--da0899e3c4864a73b75dab7a6ddb0c15 212ef340f411492285f734425010e366 3 0a402e5c0c704ac18fe36fa4d0d5d192 RY(theta\u2088) da0899e3c4864a73b75dab7a6ddb0c15--0a402e5c0c704ac18fe36fa4d0d5d192 444b9bd160f049babaf8be443b2bca25 RX(theta\u2081\u2084) 0a402e5c0c704ac18fe36fa4d0d5d192--444b9bd160f049babaf8be443b2bca25 c62d7c9a09794872a72fce89b4c3d6d2 HamEvo 444b9bd160f049babaf8be443b2bca25--c62d7c9a09794872a72fce89b4c3d6d2 813abcaae820427dbbc04f5e2215e0c7 RX(theta\u2082\u2080) c62d7c9a09794872a72fce89b4c3d6d2--813abcaae820427dbbc04f5e2215e0c7 62db98820bc640998abc8941a21b636b RY(theta\u2082\u2086) 813abcaae820427dbbc04f5e2215e0c7--62db98820bc640998abc8941a21b636b 19684bebfa934794953152ea86957962 RX(theta\u2083\u2082) 62db98820bc640998abc8941a21b636b--19684bebfa934794953152ea86957962 b7b8d1d39fa84f7180517a8a529f66af HamEvo 19684bebfa934794953152ea86957962--b7b8d1d39fa84f7180517a8a529f66af b7b8d1d39fa84f7180517a8a529f66af--80453911e44f464ab6ceabd536685e4f 258a8c47e7c04324b7127d9e61819fa3 736579a2bd15478591a8dc65ddd85396 RX(theta\u2083) 212ef340f411492285f734425010e366--736579a2bd15478591a8dc65ddd85396 16af0460f8d1448f88f8fc8d00809a4a 4 4dd9465953884122a7e2e6b29a9aa830 RY(theta\u2089) 736579a2bd15478591a8dc65ddd85396--4dd9465953884122a7e2e6b29a9aa830 d56bdc2a615d4b46ad392b9fb10d5560 RX(theta\u2081\u2085) 4dd9465953884122a7e2e6b29a9aa830--d56bdc2a615d4b46ad392b9fb10d5560 75cef0e6aede4130ad24b0f807f0205d t = theta_t\u2080 d56bdc2a615d4b46ad392b9fb10d5560--75cef0e6aede4130ad24b0f807f0205d a1f027e3df2343eebff4f49328106873 RX(theta\u2082\u2081) 75cef0e6aede4130ad24b0f807f0205d--a1f027e3df2343eebff4f49328106873 d430fbc52e4e4a50b8690fc0d4117e22 RY(theta\u2082\u2087) a1f027e3df2343eebff4f49328106873--d430fbc52e4e4a50b8690fc0d4117e22 7007413a51064aac9dca86aefaf9d0e1 RX(theta\u2083\u2083) d430fbc52e4e4a50b8690fc0d4117e22--7007413a51064aac9dca86aefaf9d0e1 56aa4f926fec4aafac7abecf6fa6c0b3 t = theta_t\u2081 7007413a51064aac9dca86aefaf9d0e1--56aa4f926fec4aafac7abecf6fa6c0b3 56aa4f926fec4aafac7abecf6fa6c0b3--258a8c47e7c04324b7127d9e61819fa3 728220e71e414e3f9b2586f3a2b0cef5 53c78ed68a014ed4acd2353fefb4173e RX(theta\u2084) 16af0460f8d1448f88f8fc8d00809a4a--53c78ed68a014ed4acd2353fefb4173e b6870169dc9049e3bc287772ffcc0ed7 5 6b8da369e68b4898a05eb1813ad9ced0 RY(theta\u2081\u2080) 53c78ed68a014ed4acd2353fefb4173e--6b8da369e68b4898a05eb1813ad9ced0 7a957e983b7344728d99a3b0e9bf7cc1 RX(theta\u2081\u2086) 6b8da369e68b4898a05eb1813ad9ced0--7a957e983b7344728d99a3b0e9bf7cc1 7c2065643f4d409099ba680df24300b8 7a957e983b7344728d99a3b0e9bf7cc1--7c2065643f4d409099ba680df24300b8 e90b6d3dbd554d4eb24e04485cda5676 RX(theta\u2082\u2082) 7c2065643f4d409099ba680df24300b8--e90b6d3dbd554d4eb24e04485cda5676 7d49e4eb9b89474995f7a2ab473bb8b4 RY(theta\u2082\u2088) e90b6d3dbd554d4eb24e04485cda5676--7d49e4eb9b89474995f7a2ab473bb8b4 e4937adc0d79441d914e5d3486248d7c RX(theta\u2083\u2084) 7d49e4eb9b89474995f7a2ab473bb8b4--e4937adc0d79441d914e5d3486248d7c bbc97241ead743b5ba1ea500ee9dca0c e4937adc0d79441d914e5d3486248d7c--bbc97241ead743b5ba1ea500ee9dca0c bbc97241ead743b5ba1ea500ee9dca0c--728220e71e414e3f9b2586f3a2b0cef5 67746fe133124bbd854a219e3bdf2e4b 8bf7850b9b36469083889cb257695767 RX(theta\u2085) b6870169dc9049e3bc287772ffcc0ed7--8bf7850b9b36469083889cb257695767 8fc6873656c744f3b282e312b0cdeff9 RY(theta\u2081\u2081) 8bf7850b9b36469083889cb257695767--8fc6873656c744f3b282e312b0cdeff9 3ffa56ca700c49d69b1ee1ded5477090 RX(theta\u2081\u2087) 8fc6873656c744f3b282e312b0cdeff9--3ffa56ca700c49d69b1ee1ded5477090 405c3958090b4a858f3ed1cb6429bbed 3ffa56ca700c49d69b1ee1ded5477090--405c3958090b4a858f3ed1cb6429bbed 17c8a090236a4eeeb2cb3e6a96038358 RX(theta\u2082\u2083) 405c3958090b4a858f3ed1cb6429bbed--17c8a090236a4eeeb2cb3e6a96038358 eb51b4bf16754195be6f4ea96af3ae85 RY(theta\u2082\u2089) 17c8a090236a4eeeb2cb3e6a96038358--eb51b4bf16754195be6f4ea96af3ae85 298f25d1874849e8af578d250db46c20 RX(theta\u2083\u2085) eb51b4bf16754195be6f4ea96af3ae85--298f25d1874849e8af578d250db46c20 917d3b81b23d4c51a7ba9ca00bea73bd 298f25d1874849e8af578d250db46c20--917d3b81b23d4c51a7ba9ca00bea73bd 917d3b81b23d4c51a7ba9ca00bea73bd--67746fe133124bbd854a219e3bdf2e4b"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 3b5c6637-e675-49b3-8492-add0bf68299a, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 71154e39-b1b9-4fa7-9cc5-8a8822143146, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 6ce387c4-b6f4-4d45-9260-a8ae7854b9c5, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': f0b41414-2137-4c7b-8553-5159a3744dac, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 13159eae-fabc-439a-9a63-f6b13f29671f, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 98f5809f-a6ba-4239-b344-459460fc722f, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': afb14031-572f-4e06-ab6c-301d4c2dd23a, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 62c0a05c-3ef6-42ec-a39d-4623df95336d, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 5062cec6-63a3-468e-8b2c-cfe4abab873b, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c8329497-d424-4c96-ade1-22bd1f3f7d45, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': d84df327-0e28-4366-bba6-af49d9918cc5, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_2: tensor([0.0558], requires_grad=True)\ntheta_7: tensor([0.6091], requires_grad=True)\ntheta_6: tensor([0.7306], requires_grad=True)\ntheta_4: tensor([0.9744], requires_grad=True)\ntheta_0: tensor([0.8941], requires_grad=True)\ntheta_1: tensor([0.2035], requires_grad=True)\ntheta_8: tensor([0.2952], requires_grad=True)\ntheta_3: tensor([0.0577], requires_grad=True)\ntheta_5: tensor([0.3965], requires_grad=True)\n}\nembedded = {\n3b5c6637-e675-49b3-8492-add0bf68299a: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n71154e39-b1b9-4fa7-9cc5-8a8822143146: tensor([2., 2.])\n6ce387c4-b6f4-4d45-9260-a8ae7854b9c5: tensor([0.8941], grad_fn=&lt;ViewBackward0&gt;)\nf0b41414-2137-4c7b-8553-5159a3744dac: tensor([0.2035], grad_fn=&lt;ViewBackward0&gt;)\n13159eae-fabc-439a-9a63-f6b13f29671f: tensor([0.0558], grad_fn=&lt;ViewBackward0&gt;)\n98f5809f-a6ba-4239-b344-459460fc722f: tensor([0.0577], grad_fn=&lt;ViewBackward0&gt;)\nafb14031-572f-4e06-ab6c-301d4c2dd23a: tensor([0.9744], grad_fn=&lt;ViewBackward0&gt;)\n62c0a05c-3ef6-42ec-a39d-4623df95336d: tensor([0.3965], grad_fn=&lt;ViewBackward0&gt;)\n5062cec6-63a3-468e-8b2c-cfe4abab873b: tensor([0.7306], grad_fn=&lt;ViewBackward0&gt;)\nc8329497-d424-4c96-ade1-22bd1f3f7d45: tensor([0.6091], grad_fn=&lt;ViewBackward0&gt;)\nd84df327-0e28-4366-bba6-af49d9918cc5: tensor([0.2952], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_2: tensor([0.0558], grad_fn=&lt;ViewBackward0&gt;)\ntheta_7: tensor([0.6091], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_6: tensor([0.7306], grad_fn=&lt;ViewBackward0&gt;)\ntheta_4: tensor([0.9744], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.8941], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.2035], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.2952], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.0577], grad_fn=&lt;ViewBackward0&gt;)\ntheta_5: tensor([0.3965], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.3854-0.1967j,  0.0458-0.1071j,  0.0059+0.1483j, -0.3360+0.4374j,\n-0.4565-0.3294j, -0.1511+0.0105j,  0.0796+0.0516j,  0.1044+0.3365j],\n[ 0.3854-0.1967j,  0.0458-0.1071j,  0.0059+0.1483j, -0.3360+0.4374j,\n-0.4565-0.3294j, -0.1511+0.0105j,  0.0796+0.0516j,  0.1044+0.3365j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'100': 184, '000': 183, '011': 182, '111': 136, '010': 85, '110': 80, '101': 77, '001': 73})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(3b5c6637-e675-49b3-8492-add0bf68299a)-C----------------------------------------Rx(6ce387c4-b6f4-4d45-9260-a8ae7854b9c5)-Ry(98f5809f-a6ba-4239-b344-459460fc722f)-Rx(5062cec6-63a3-468e-8b2c-cfe4abab873b)-C---\n|                                                                                                                                                                   |   q1 : -Rz(71154e39-b1b9-4fa7-9cc5-8a8822143146)-X----------------------------------------Rx(f0b41414-2137-4c7b-8553-5159a3744dac)-Ry(afb14031-572f-4e06-ab6c-301d4c2dd23a)-Rx(c8329497-d424-4c96-ade1-22bd1f3f7d45)-X-C-\n| q2 : -Rx(13159eae-fabc-439a-9a63-f6b13f29671f)-Ry(62c0a05c-3ef6-42ec-a39d-4623df95336d)-Rx(d84df327-0e28-4366-bba6-af49d9918cc5)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [13159eae-fabc-439a-9a63-f6b13f29671f, 3b5c6637-e675-49b3-8492-add0bf68299a, 5062cec6-63a3-468e-8b2c-cfe4abab873b, 62c0a05c-3ef6-42ec-a39d-4623df95336d, 6ce387c4-b6f4-4d45-9260-a8ae7854b9c5, 71154e39-b1b9-4fa7-9cc5-8a8822143146, 98f5809f-a6ba-4239-b344-459460fc722f, afb14031-572f-4e06-ab6c-301d4c2dd23a, c8329497-d424-4c96-ade1-22bd1f3f7d45, d84df327-0e28-4366-bba6-af49d9918cc5, f0b41414-2137-4c7b-8553-5159a3744dac].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(2.81)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.89)-DEPO(0.1)-Ry(0.06)-DEPO(0.1)-Rx(0.73)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.45)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.20)-DEPO(0.1)-Ry(0.97)-DEPO(0.1)-Rx(0.61)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.06)-DEPO(0.1)-Ry(0.40)-DEPO(0.1)-Rx(0.30)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 c56d9683d628438ba288c6975d204c55 0 cb80184ba8f6482584f7ef64c2385407 X c56d9683d628438ba288c6975d204c55--cb80184ba8f6482584f7ef64c2385407 0eb28153fb4e4a9ba324bd1c61bd37b2 1 a91f53a3d8114da38d96147310b59d0f cb80184ba8f6482584f7ef64c2385407--a91f53a3d8114da38d96147310b59d0f 392e8f0c8eef4a4cb7df64618ab6f0c6 2de04065a53442089d6cdaeb2e1b703c Y 0eb28153fb4e4a9ba324bd1c61bd37b2--2de04065a53442089d6cdaeb2e1b703c 2de04065a53442089d6cdaeb2e1b703c--392e8f0c8eef4a4cb7df64618ab6f0c6 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 5144283454c44ba0a92aca80a9dd96d3 0 1e5354f7d4b24bf589f7a88998e7e05f RX(0.5) 5144283454c44ba0a92aca80a9dd96d3--1e5354f7d4b24bf589f7a88998e7e05f 69ff295747f94275bb2b7700337cad8b 1e5354f7d4b24bf589f7a88998e7e05f--69ff295747f94275bb2b7700337cad8b <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 ad02c4b7a7e24a44bdf04ea910685a93 0 adf01890b3de464fa2e2df0f4087acfb ad02c4b7a7e24a44bdf04ea910685a93--adf01890b3de464fa2e2df0f4087acfb 951e7056a8094ec8881ef0d2d0a29a86 1 1fe6a046ad084644b06f1b4b4a9b07db adf01890b3de464fa2e2df0f4087acfb--1fe6a046ad084644b06f1b4b4a9b07db ed6acdb78d9c453a8b4079a1a131a4c9 65a540679969425584211f8cdd0718c9 X 951e7056a8094ec8881ef0d2d0a29a86--65a540679969425584211f8cdd0718c9 65a540679969425584211f8cdd0718c9--adf01890b3de464fa2e2df0f4087acfb 65a540679969425584211f8cdd0718c9--ed6acdb78d9c453a8b4079a1a131a4c9 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 81182d417b4644e896b455ca791d9a2b 0 6ec84a6ca4ca42efb18fb3c84989a616 X 81182d417b4644e896b455ca791d9a2b--6ec84a6ca4ca42efb18fb3c84989a616 08eddfe2979b4bbbadcfcb522ddd5737 X 6ec84a6ca4ca42efb18fb3c84989a616--08eddfe2979b4bbbadcfcb522ddd5737 9b19f2e00f8f43c0b078b5d97a4fa0e3 08eddfe2979b4bbbadcfcb522ddd5737--9b19f2e00f8f43c0b078b5d97a4fa0e3 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 223c10bc8b8a46d8aee208a485eb0acd 0 045979b0fbc24095bd607afa80df962a X 223c10bc8b8a46d8aee208a485eb0acd--045979b0fbc24095bd607afa80df962a c01619582891435589b3f8fb5a4828bf 1 e8c0534af2034874b95b291b87eaa48a 045979b0fbc24095bd607afa80df962a--e8c0534af2034874b95b291b87eaa48a cb922f08fb6046fa9146890aaffd1fa3 e8c0534af2034874b95b291b87eaa48a--cb922f08fb6046fa9146890aaffd1fa3 5f403664609f467fb1c0c6fa865cbc67 950d13180d28471899f3c7fbe62404d9 c01619582891435589b3f8fb5a4828bf--950d13180d28471899f3c7fbe62404d9 7a7880ed28eb468eb41a1c3287b5b2a2 X 950d13180d28471899f3c7fbe62404d9--7a7880ed28eb468eb41a1c3287b5b2a2 7a7880ed28eb468eb41a1c3287b5b2a2--5f403664609f467fb1c0c6fa865cbc67 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 6ed5f82d6d1547beb393d0a503bad09b 0 9d36581264b34dacb1301f7b30ce2b69 X 6ed5f82d6d1547beb393d0a503bad09b--9d36581264b34dacb1301f7b30ce2b69 24e6348568104b458f2f2bb38d54b90d 1 a0c47b0d1a0a4776a5d2173a02a4c953 9d36581264b34dacb1301f7b30ce2b69--a0c47b0d1a0a4776a5d2173a02a4c953 a4b43e2e29a640f78357b820b9ff8df7 b51388d314524a7896aa1ba3a19d36a9 X 24e6348568104b458f2f2bb38d54b90d--b51388d314524a7896aa1ba3a19d36a9 b51388d314524a7896aa1ba3a19d36a9--a4b43e2e29a640f78357b820b9ff8df7 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_edf4af67a9ab40a494c535a5cc01b0f8 subblock cluster_e91cc72d5fc242438210276a1ebb57a2 subblock 345e499570f74b6da2fb2ea01d60975c 0 6f5d53f0469c415db8ff85948977d862 X 345e499570f74b6da2fb2ea01d60975c--6f5d53f0469c415db8ff85948977d862 7282fa0560b94b5aaece0d056889a0cd 1 940050813d2e415e87433bfe6ad0ac94 X 6f5d53f0469c415db8ff85948977d862--940050813d2e415e87433bfe6ad0ac94 2fb35a1db5ed4b34bf5c38be94c9d04f 940050813d2e415e87433bfe6ad0ac94--2fb35a1db5ed4b34bf5c38be94c9d04f 04bf65e82a1c4304bba728b706f84d8c 4e5a70316368421ba8126d3e9e84c48e Y 7282fa0560b94b5aaece0d056889a0cd--4e5a70316368421ba8126d3e9e84c48e 2169804a8982412f98596e2c97271534 2 bcb8586460c549c98f8532674a33a90e Y 4e5a70316368421ba8126d3e9e84c48e--bcb8586460c549c98f8532674a33a90e bcb8586460c549c98f8532674a33a90e--04bf65e82a1c4304bba728b706f84d8c 1b7e225294a44ae2a0705819d9d55541 bb6ccaa98663472baebd13d54f3f4fb5 2169804a8982412f98596e2c97271534--bb6ccaa98663472baebd13d54f3f4fb5 c84d910b254a426d8ddb3294bce897c4 3 f1e4c7a3e0384acdb2bd42f7f342b1c8 bb6ccaa98663472baebd13d54f3f4fb5--f1e4c7a3e0384acdb2bd42f7f342b1c8 f1e4c7a3e0384acdb2bd42f7f342b1c8--1b7e225294a44ae2a0705819d9d55541 8e46d3c675534b2f8ed4fe3bc9f62a41 a01ca36b74bf491abcea3ee2fb37593b c84d910b254a426d8ddb3294bce897c4--a01ca36b74bf491abcea3ee2fb37593b 97169a2cfc464d3e9785817dea87202e 4 bf571afa245f486aa314577c703ac3a6 a01ca36b74bf491abcea3ee2fb37593b--bf571afa245f486aa314577c703ac3a6 bf571afa245f486aa314577c703ac3a6--8e46d3c675534b2f8ed4fe3bc9f62a41 0b714ed55c9e4769a07eab7c22d99bb3 56e2491149f04b9095c03aee18645fd9 X 97169a2cfc464d3e9785817dea87202e--56e2491149f04b9095c03aee18645fd9 56e2491149f04b9095c03aee18645fd9--a01ca36b74bf491abcea3ee2fb37593b c246f9f18dd34dd095b6a9affe1b44a6 X 56e2491149f04b9095c03aee18645fd9--c246f9f18dd34dd095b6a9affe1b44a6 c246f9f18dd34dd095b6a9affe1b44a6--bf571afa245f486aa314577c703ac3a6 c246f9f18dd34dd095b6a9affe1b44a6--0b714ed55c9e4769a07eab7c22d99bb3"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'00': 271, '10': 252, '01': 244, '11': 233})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'100': 30, '110': 25, '000': 24, '010': 21})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[2.5000e-01, 4.4409e-16],\n[4.4409e-16, 4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2524, -0.0104],\n[ 0.0020,  0.0012]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9903+0.0000j, 0.0000-0.1388j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8950+0.0000j, 0.0000-0.4460j],\n[0.9960+0.0000j, 0.0000-0.0893j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.7308+0.0000j, 0.6788+0.0000j, 0.0000-0.0523j, 0.0000-0.0486j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_bcd824d4eae44f04ba399a984dd76d5d [* 2] cluster_704d81a2ce364af9b5d4511d1d4dcab5 Rotations 9d3ecf7611a34ce49c26f204b3537acb 0 13de35bbd4d2449f8c69e77c0ade9759 RX(phi/theta) 9d3ecf7611a34ce49c26f204b3537acb--13de35bbd4d2449f8c69e77c0ade9759 0e27fd282bee4adda4dfc78d3b762529 1 2ead2a6a801e4a38be30cade2bac4b9f RX(phi) 13de35bbd4d2449f8c69e77c0ade9759--2ead2a6a801e4a38be30cade2bac4b9f 2900bec33c2847f1aac9db6b6d6fa904 RX(phi) 2ead2a6a801e4a38be30cade2bac4b9f--2900bec33c2847f1aac9db6b6d6fa904 3d6ff47dcdde4b97847862dae1ff0e94 RX(phi + theta) 2900bec33c2847f1aac9db6b6d6fa904--3d6ff47dcdde4b97847862dae1ff0e94 2875cbf8dcd74760837a7369e57ec815 3d6ff47dcdde4b97847862dae1ff0e94--2875cbf8dcd74760837a7369e57ec815 b72c48c9f7384cd593c813cb6c2ec248 2875cbf8dcd74760837a7369e57ec815--b72c48c9f7384cd593c813cb6c2ec248 4243633ef4cc441aa861a5c073d7446d Z b72c48c9f7384cd593c813cb6c2ec248--4243633ef4cc441aa861a5c073d7446d 25a27c6ca3be4bb4b70e11cb83171beb 4243633ef4cc441aa861a5c073d7446d--25a27c6ca3be4bb4b70e11cb83171beb 6c6c8654885e4873abd7cdb080e6b556 89cbfa439b5d49b898df80f09222899c RY(2*theta) 0e27fd282bee4adda4dfc78d3b762529--89cbfa439b5d49b898df80f09222899c 3ab1fe74f91f445db2ebb2db883e276b 2 61630b5ab3e6441492799efd8a57512e RY(theta) 89cbfa439b5d49b898df80f09222899c--61630b5ab3e6441492799efd8a57512e dc6672a6548948fa8f0b25d200eb9f1d RY(theta) 61630b5ab3e6441492799efd8a57512e--dc6672a6548948fa8f0b25d200eb9f1d a3a2d5f441434b3aa32fb65b1aa55f08 RY(theta**2) dc6672a6548948fa8f0b25d200eb9f1d--a3a2d5f441434b3aa32fb65b1aa55f08 5c7a1fb6fd7c450ba6270ce103bc4d7d X a3a2d5f441434b3aa32fb65b1aa55f08--5c7a1fb6fd7c450ba6270ce103bc4d7d 5c7a1fb6fd7c450ba6270ce103bc4d7d--2875cbf8dcd74760837a7369e57ec815 6a6afbb99f8742dc8c69212f2c14eb9a 5c7a1fb6fd7c450ba6270ce103bc4d7d--6a6afbb99f8742dc8c69212f2c14eb9a 01662068eafb4356b86586fe1ceb69f3 Z 6a6afbb99f8742dc8c69212f2c14eb9a--01662068eafb4356b86586fe1ceb69f3 01662068eafb4356b86586fe1ceb69f3--6c6c8654885e4873abd7cdb080e6b556 2a8a21beb4ae46278e0cc50da327ab3c 43e82b32f01a4404be618f9621d365d1 RZ(cos(phi)) 3ab1fe74f91f445db2ebb2db883e276b--43e82b32f01a4404be618f9621d365d1 e817b59240ca424e9be963742dfbd76a RZ(phi) 43e82b32f01a4404be618f9621d365d1--e817b59240ca424e9be963742dfbd76a 07bdf39d49bc4f0481d1c93bf6224bd0 RZ(phi) e817b59240ca424e9be963742dfbd76a--07bdf39d49bc4f0481d1c93bf6224bd0 02a2d76f11504c0e936b9a5975271c20 RZ(cos(phi)) 07bdf39d49bc4f0481d1c93bf6224bd0--02a2d76f11504c0e936b9a5975271c20 6e101c1c9a4c4f3abb26141400266b1d 02a2d76f11504c0e936b9a5975271c20--6e101c1c9a4c4f3abb26141400266b1d 6a5dbe8d7de3409390768d2d19efcfe0 X 6e101c1c9a4c4f3abb26141400266b1d--6a5dbe8d7de3409390768d2d19efcfe0 6a5dbe8d7de3409390768d2d19efcfe0--6a6afbb99f8742dc8c69212f2c14eb9a a3f2f5af13984480a4e5f39171e4b7a3 Z 6a5dbe8d7de3409390768d2d19efcfe0--a3f2f5af13984480a4e5f39171e4b7a3 a3f2f5af13984480a4e5f39171e4b7a3--2a8a21beb4ae46278e0cc50da327ab3c <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.1479]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9868+0.0000j, 0.1142+0.0000j, 0.0000-0.1142j, 0.0000-0.0132j],\n[0.9047+0.0000j, 0.2937+0.0000j, 0.0000-0.2937j, 0.0000-0.0953j],\n[0.8202+0.0000j, 0.3840+0.0000j, 0.0000-0.3840j, 0.0000-0.1798j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 7b14e3151bb64f988e71cca181aacc32 0 5a7f4d8695f94097b20687d2e2b51fe5 RX(theta\u2080) 7b14e3151bb64f988e71cca181aacc32--5a7f4d8695f94097b20687d2e2b51fe5 b3d3d126e0374606a4d81fcb40786e5c 1 268e1ea081384bc28e51abc06355d387 RY(theta\u2084) 5a7f4d8695f94097b20687d2e2b51fe5--268e1ea081384bc28e51abc06355d387 c8cee8036c154a28b8afb03ed2db3f2e RX(theta\u2088) 268e1ea081384bc28e51abc06355d387--c8cee8036c154a28b8afb03ed2db3f2e 97103b782c054e4ea055098724027381 c8cee8036c154a28b8afb03ed2db3f2e--97103b782c054e4ea055098724027381 85a83fc68cfe406291b74acc897558a5 97103b782c054e4ea055098724027381--85a83fc68cfe406291b74acc897558a5 1fe39255f32e4a818baeb0319cd88078 RX(theta\u2081\u2082) 85a83fc68cfe406291b74acc897558a5--1fe39255f32e4a818baeb0319cd88078 0c0400ed4261427ca865944d3f07bb68 RY(theta\u2081\u2086) 1fe39255f32e4a818baeb0319cd88078--0c0400ed4261427ca865944d3f07bb68 224750f2f5f04e92b7c25170ad6da54f RX(theta\u2082\u2080) 0c0400ed4261427ca865944d3f07bb68--224750f2f5f04e92b7c25170ad6da54f 07366ba379fc450896811669d8dda8bf 224750f2f5f04e92b7c25170ad6da54f--07366ba379fc450896811669d8dda8bf 5e798b89dccc48cdb820dbecde2fe766 07366ba379fc450896811669d8dda8bf--5e798b89dccc48cdb820dbecde2fe766 b4b92dd15606490488bbd91ad148e941 5e798b89dccc48cdb820dbecde2fe766--b4b92dd15606490488bbd91ad148e941 70fcd7cee92b435a9cf1989216ffe193 2c528b2007cc4dfa9f591b2af3265545 RX(theta\u2081) b3d3d126e0374606a4d81fcb40786e5c--2c528b2007cc4dfa9f591b2af3265545 ae667163d6414fda9155e5f62d40625b 2 7fee5d98129048708aa30ba4dd928988 RY(theta\u2085) 2c528b2007cc4dfa9f591b2af3265545--7fee5d98129048708aa30ba4dd928988 34dd97745062441782b7422369936a35 RX(theta\u2089) 7fee5d98129048708aa30ba4dd928988--34dd97745062441782b7422369936a35 a691a6b0a3bc4d24a38e5f91c9cb9cf6 X 34dd97745062441782b7422369936a35--a691a6b0a3bc4d24a38e5f91c9cb9cf6 a691a6b0a3bc4d24a38e5f91c9cb9cf6--97103b782c054e4ea055098724027381 5b3a512be8c24207a14757f25d4f0159 a691a6b0a3bc4d24a38e5f91c9cb9cf6--5b3a512be8c24207a14757f25d4f0159 31d00f47fcfa4aee8dce3a2dde8f951a RX(theta\u2081\u2083) 5b3a512be8c24207a14757f25d4f0159--31d00f47fcfa4aee8dce3a2dde8f951a 637103fa45504e608faaffaf4ea5436d RY(theta\u2081\u2087) 31d00f47fcfa4aee8dce3a2dde8f951a--637103fa45504e608faaffaf4ea5436d d3f7f01952874777a7d874a8454c18dd RX(theta\u2082\u2081) 637103fa45504e608faaffaf4ea5436d--d3f7f01952874777a7d874a8454c18dd 57d3ed0fae6b4dc9a09afabd7e68e30d X d3f7f01952874777a7d874a8454c18dd--57d3ed0fae6b4dc9a09afabd7e68e30d 57d3ed0fae6b4dc9a09afabd7e68e30d--07366ba379fc450896811669d8dda8bf 9cfea8f7b4e8448cae83d4278b94d46a 57d3ed0fae6b4dc9a09afabd7e68e30d--9cfea8f7b4e8448cae83d4278b94d46a 9cfea8f7b4e8448cae83d4278b94d46a--70fcd7cee92b435a9cf1989216ffe193 9a7280390be94aa1a075d83f984ebb55 4bdd1133f5ea4718a5093d9b72db4026 RX(theta\u2082) ae667163d6414fda9155e5f62d40625b--4bdd1133f5ea4718a5093d9b72db4026 b771256a62ab422db550d07dc118c64a 3 c471859043c149ee92bfa618c1160601 RY(theta\u2086) 4bdd1133f5ea4718a5093d9b72db4026--c471859043c149ee92bfa618c1160601 8762c187f2a84158bbbe483f94182b21 RX(theta\u2081\u2080) c471859043c149ee92bfa618c1160601--8762c187f2a84158bbbe483f94182b21 3253500c39f4447b9acea0eff07ac7bc 8762c187f2a84158bbbe483f94182b21--3253500c39f4447b9acea0eff07ac7bc 4a5ddc0888b44d5585984567b5a9e3e9 X 3253500c39f4447b9acea0eff07ac7bc--4a5ddc0888b44d5585984567b5a9e3e9 4a5ddc0888b44d5585984567b5a9e3e9--5b3a512be8c24207a14757f25d4f0159 79b5b23deac743f1ba1dd655e02de515 RX(theta\u2081\u2084) 4a5ddc0888b44d5585984567b5a9e3e9--79b5b23deac743f1ba1dd655e02de515 45d55c1a6d934d089321047e58898489 RY(theta\u2081\u2088) 79b5b23deac743f1ba1dd655e02de515--45d55c1a6d934d089321047e58898489 15eebea954bb4010ba17bf6f9a8d2a60 RX(theta\u2082\u2082) 45d55c1a6d934d089321047e58898489--15eebea954bb4010ba17bf6f9a8d2a60 41afd356b78a48a0aeaf07d586306997 15eebea954bb4010ba17bf6f9a8d2a60--41afd356b78a48a0aeaf07d586306997 b35919f7e9a945519d3c7eedbfae0379 X 41afd356b78a48a0aeaf07d586306997--b35919f7e9a945519d3c7eedbfae0379 b35919f7e9a945519d3c7eedbfae0379--9cfea8f7b4e8448cae83d4278b94d46a b35919f7e9a945519d3c7eedbfae0379--9a7280390be94aa1a075d83f984ebb55 aa16bb5a15a149589aec15f7618d8a71 9ef27749d3da4a9fa5e79c128be5d60f RX(theta\u2083) b771256a62ab422db550d07dc118c64a--9ef27749d3da4a9fa5e79c128be5d60f 79268db3cabc45a88719263b039b9477 RY(theta\u2087) 9ef27749d3da4a9fa5e79c128be5d60f--79268db3cabc45a88719263b039b9477 eeef36896d9e4bdd9fbfc32b628757db RX(theta\u2081\u2081) 79268db3cabc45a88719263b039b9477--eeef36896d9e4bdd9fbfc32b628757db b57f7692fa9a43cea71fb1fb98894a7a X eeef36896d9e4bdd9fbfc32b628757db--b57f7692fa9a43cea71fb1fb98894a7a b57f7692fa9a43cea71fb1fb98894a7a--3253500c39f4447b9acea0eff07ac7bc 442ebae2e106444eab87761e4f88fa5d b57f7692fa9a43cea71fb1fb98894a7a--442ebae2e106444eab87761e4f88fa5d 0d30b9a9c71a480bb157b22f73146313 RX(theta\u2081\u2085) 442ebae2e106444eab87761e4f88fa5d--0d30b9a9c71a480bb157b22f73146313 741b5bd07923451cb0a6618a32b7f16c RY(theta\u2081\u2089) 0d30b9a9c71a480bb157b22f73146313--741b5bd07923451cb0a6618a32b7f16c 58c4aa274c554a3593e39046c4384295 RX(theta\u2082\u2083) 741b5bd07923451cb0a6618a32b7f16c--58c4aa274c554a3593e39046c4384295 b03e96a5c63948cd999e22308467b8e8 X 58c4aa274c554a3593e39046c4384295--b03e96a5c63948cd999e22308467b8e8 b03e96a5c63948cd999e22308467b8e8--41afd356b78a48a0aeaf07d586306997 bc9e367e677f41268d6c3c3ccf3601ce b03e96a5c63948cd999e22308467b8e8--bc9e367e677f41268d6c3c3ccf3601ce bc9e367e677f41268d6c3c3ccf3601ce--aa16bb5a15a149589aec15f7618d8a71 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_8e4ebc24930b4960a82ca0e871032ab3 HEA cluster_7dfde4dfe7884eed8d81ab6a17df3981 HEA 04f1d0c6345449108157284b0ff5df8d 0 3c353799eb5e424e9980ad6f93342104 RX(theta\u2080) 04f1d0c6345449108157284b0ff5df8d--3c353799eb5e424e9980ad6f93342104 98884408cc7647d4bd254635074f58e7 1 829eff0444b14740a6903652b1ea7c42 RY(theta\u2084) 3c353799eb5e424e9980ad6f93342104--829eff0444b14740a6903652b1ea7c42 bcf70e4788794f9fab6ec85811b613af RX(theta\u2088) 829eff0444b14740a6903652b1ea7c42--bcf70e4788794f9fab6ec85811b613af c48555aa38394be990095c936b0832b8 bcf70e4788794f9fab6ec85811b613af--c48555aa38394be990095c936b0832b8 2de46bfb55874d54ae287a5e02c960a5 c48555aa38394be990095c936b0832b8--2de46bfb55874d54ae287a5e02c960a5 3f2365be0f564904a37cbf8c19aabca8 RX(theta\u2081\u2082) 2de46bfb55874d54ae287a5e02c960a5--3f2365be0f564904a37cbf8c19aabca8 2d51054d03b44efebefe3a351f2f5f81 RY(theta\u2081\u2086) 3f2365be0f564904a37cbf8c19aabca8--2d51054d03b44efebefe3a351f2f5f81 b3e21d4159bb404ba57f4362f806c98e RX(theta\u2082\u2080) 2d51054d03b44efebefe3a351f2f5f81--b3e21d4159bb404ba57f4362f806c98e ea13db7fa98341cfa4d7a4fe40e836a1 b3e21d4159bb404ba57f4362f806c98e--ea13db7fa98341cfa4d7a4fe40e836a1 0c2c23d0148d4d0c8acd9e5de8c3be6a ea13db7fa98341cfa4d7a4fe40e836a1--0c2c23d0148d4d0c8acd9e5de8c3be6a 311100d887524b78ad9de16d9eb50be2 RX(theta\u2080) 0c2c23d0148d4d0c8acd9e5de8c3be6a--311100d887524b78ad9de16d9eb50be2 0e8c9609129e4e86a2eeccb99c6ec8f2 RY(theta\u2084) 311100d887524b78ad9de16d9eb50be2--0e8c9609129e4e86a2eeccb99c6ec8f2 24e8ff6773074fe78c4bb554ffa344ef RX(theta\u2088) 0e8c9609129e4e86a2eeccb99c6ec8f2--24e8ff6773074fe78c4bb554ffa344ef e448107c125c4bd39d52bd04b6ccf187 24e8ff6773074fe78c4bb554ffa344ef--e448107c125c4bd39d52bd04b6ccf187 d73249e1bf114ae0afd4631f81b78d4b e448107c125c4bd39d52bd04b6ccf187--d73249e1bf114ae0afd4631f81b78d4b 47ed146da55b45809db1fc65aa36941c RX(theta\u2081\u2082) d73249e1bf114ae0afd4631f81b78d4b--47ed146da55b45809db1fc65aa36941c 7d483279bb2d477aabd80d10946f00d3 RY(theta\u2081\u2086) 47ed146da55b45809db1fc65aa36941c--7d483279bb2d477aabd80d10946f00d3 8133636f1a9f4e59bd9b8f53d7dbd945 RX(theta\u2082\u2080) 7d483279bb2d477aabd80d10946f00d3--8133636f1a9f4e59bd9b8f53d7dbd945 f33065b172c54eeda3f2ff216f71fa6a 8133636f1a9f4e59bd9b8f53d7dbd945--f33065b172c54eeda3f2ff216f71fa6a c538e18f4e6c4c23bd42911b0536ac17 f33065b172c54eeda3f2ff216f71fa6a--c538e18f4e6c4c23bd42911b0536ac17 bc685f5bda5841c49060c76693c41e99 c538e18f4e6c4c23bd42911b0536ac17--bc685f5bda5841c49060c76693c41e99 6e5c4cb5e691451ab93d759beab8c71e 619d1e5eed7248558b8f064af0cc884a RX(theta\u2081) 98884408cc7647d4bd254635074f58e7--619d1e5eed7248558b8f064af0cc884a 063cf47a6e214522805f87f72ec26c44 2 a55e66c0293d4aaf82b34a828e8591fe RY(theta\u2085) 619d1e5eed7248558b8f064af0cc884a--a55e66c0293d4aaf82b34a828e8591fe 308be88ccff2422b94332e826b1aab7c RX(theta\u2089) a55e66c0293d4aaf82b34a828e8591fe--308be88ccff2422b94332e826b1aab7c d46ff18937a24548bbc064fb3ba1b0d1 X 308be88ccff2422b94332e826b1aab7c--d46ff18937a24548bbc064fb3ba1b0d1 d46ff18937a24548bbc064fb3ba1b0d1--c48555aa38394be990095c936b0832b8 eba8c587c647441ab6ac288218c79c6f d46ff18937a24548bbc064fb3ba1b0d1--eba8c587c647441ab6ac288218c79c6f aac134b08fd4468cb5b441e8f7f3c162 RX(theta\u2081\u2083) eba8c587c647441ab6ac288218c79c6f--aac134b08fd4468cb5b441e8f7f3c162 5ed6f7f129cb4737b0fc133eed847281 RY(theta\u2081\u2087) aac134b08fd4468cb5b441e8f7f3c162--5ed6f7f129cb4737b0fc133eed847281 7a9bdd776a8446a096b90ce93672c17c RX(theta\u2082\u2081) 5ed6f7f129cb4737b0fc133eed847281--7a9bdd776a8446a096b90ce93672c17c c17fa995c4f8454aa7ae69f805cb6072 X 7a9bdd776a8446a096b90ce93672c17c--c17fa995c4f8454aa7ae69f805cb6072 c17fa995c4f8454aa7ae69f805cb6072--ea13db7fa98341cfa4d7a4fe40e836a1 a1085552e53c4a4fb8b557d1a1cbc1cb c17fa995c4f8454aa7ae69f805cb6072--a1085552e53c4a4fb8b557d1a1cbc1cb 4f98b9711cdb4e6495163f44f4047dec RX(theta\u2081) a1085552e53c4a4fb8b557d1a1cbc1cb--4f98b9711cdb4e6495163f44f4047dec afa567e79f494415a7fbc0d34ae1479c RY(theta\u2085) 4f98b9711cdb4e6495163f44f4047dec--afa567e79f494415a7fbc0d34ae1479c 31f590afcefc4855aee1fd9b6ef65baa RX(theta\u2089) afa567e79f494415a7fbc0d34ae1479c--31f590afcefc4855aee1fd9b6ef65baa 84d9b4d068f144d49223dfecd556536a X 31f590afcefc4855aee1fd9b6ef65baa--84d9b4d068f144d49223dfecd556536a 84d9b4d068f144d49223dfecd556536a--e448107c125c4bd39d52bd04b6ccf187 f2dd6910e9714ba0aeb0b5bac482c21b 84d9b4d068f144d49223dfecd556536a--f2dd6910e9714ba0aeb0b5bac482c21b 38c5f27d04ae45df9145c08faf8eaa91 RX(theta\u2081\u2083) f2dd6910e9714ba0aeb0b5bac482c21b--38c5f27d04ae45df9145c08faf8eaa91 838c9c8e1bc7475d9ade22681896bd69 RY(theta\u2081\u2087) 38c5f27d04ae45df9145c08faf8eaa91--838c9c8e1bc7475d9ade22681896bd69 ea1b2ede812942298fdde82aad5a8fe5 RX(theta\u2082\u2081) 838c9c8e1bc7475d9ade22681896bd69--ea1b2ede812942298fdde82aad5a8fe5 e1a42206732b4a059e80d6f5dc93428c X ea1b2ede812942298fdde82aad5a8fe5--e1a42206732b4a059e80d6f5dc93428c e1a42206732b4a059e80d6f5dc93428c--f33065b172c54eeda3f2ff216f71fa6a 6c1439ca4528496a99112ce2d8fc2ee4 e1a42206732b4a059e80d6f5dc93428c--6c1439ca4528496a99112ce2d8fc2ee4 6c1439ca4528496a99112ce2d8fc2ee4--6e5c4cb5e691451ab93d759beab8c71e a800e877078e4e4d8d3e6583141df6a0 110528401b4e42ad81cf4f2ac372581b RX(theta\u2082) 063cf47a6e214522805f87f72ec26c44--110528401b4e42ad81cf4f2ac372581b f9b5bc6bcde7480f89dee5d612874902 3 b771ca59bb2d44ae8426cde1bab5a555 RY(theta\u2086) 110528401b4e42ad81cf4f2ac372581b--b771ca59bb2d44ae8426cde1bab5a555 8cb98dee837c48d5b5757eb9509eb6de RX(theta\u2081\u2080) b771ca59bb2d44ae8426cde1bab5a555--8cb98dee837c48d5b5757eb9509eb6de aa7788b8aefa4902a49885751b370c00 8cb98dee837c48d5b5757eb9509eb6de--aa7788b8aefa4902a49885751b370c00 69762494966248d0a36fc3f9ad2fa84f X aa7788b8aefa4902a49885751b370c00--69762494966248d0a36fc3f9ad2fa84f 69762494966248d0a36fc3f9ad2fa84f--eba8c587c647441ab6ac288218c79c6f 3199b216d0c943229d1c27c0963d3469 RX(theta\u2081\u2084) 69762494966248d0a36fc3f9ad2fa84f--3199b216d0c943229d1c27c0963d3469 524f3132deca4af2b82b0fc9fffa6398 RY(theta\u2081\u2088) 3199b216d0c943229d1c27c0963d3469--524f3132deca4af2b82b0fc9fffa6398 f8035fbd5344477c8c6c7e1a4350dde8 RX(theta\u2082\u2082) 524f3132deca4af2b82b0fc9fffa6398--f8035fbd5344477c8c6c7e1a4350dde8 d0908b3245324ef3b80912fca7b42bd3 f8035fbd5344477c8c6c7e1a4350dde8--d0908b3245324ef3b80912fca7b42bd3 83d5cbbfac214c6998696ff2e0190dda X d0908b3245324ef3b80912fca7b42bd3--83d5cbbfac214c6998696ff2e0190dda 83d5cbbfac214c6998696ff2e0190dda--a1085552e53c4a4fb8b557d1a1cbc1cb 188e5ef35c6743e58a83bd1dfb3120bb RX(theta\u2082) 83d5cbbfac214c6998696ff2e0190dda--188e5ef35c6743e58a83bd1dfb3120bb 0e771a5f792847ae91f68a42e71948be RY(theta\u2086) 188e5ef35c6743e58a83bd1dfb3120bb--0e771a5f792847ae91f68a42e71948be 41775eb71fa149e8955cd8f7135a8ce7 RX(theta\u2081\u2080) 0e771a5f792847ae91f68a42e71948be--41775eb71fa149e8955cd8f7135a8ce7 919f6c7cf9d748c89d4adc77b7e251b2 41775eb71fa149e8955cd8f7135a8ce7--919f6c7cf9d748c89d4adc77b7e251b2 09c89d9731b84fc5a7dbb24b7bee56b9 X 919f6c7cf9d748c89d4adc77b7e251b2--09c89d9731b84fc5a7dbb24b7bee56b9 09c89d9731b84fc5a7dbb24b7bee56b9--f2dd6910e9714ba0aeb0b5bac482c21b 8d459b40177346db9b5f3dddfa855d8f RX(theta\u2081\u2084) 09c89d9731b84fc5a7dbb24b7bee56b9--8d459b40177346db9b5f3dddfa855d8f 4bc603764b2e4bd094fbcc4960c53a3e RY(theta\u2081\u2088) 8d459b40177346db9b5f3dddfa855d8f--4bc603764b2e4bd094fbcc4960c53a3e 7be2f8800bef48a78247324fa98d439f RX(theta\u2082\u2082) 4bc603764b2e4bd094fbcc4960c53a3e--7be2f8800bef48a78247324fa98d439f 44751b6ec3894e86be87424f791cb132 7be2f8800bef48a78247324fa98d439f--44751b6ec3894e86be87424f791cb132 96049fcf107e49a49f7d6c8fb8bdd2fc X 44751b6ec3894e86be87424f791cb132--96049fcf107e49a49f7d6c8fb8bdd2fc 96049fcf107e49a49f7d6c8fb8bdd2fc--6c1439ca4528496a99112ce2d8fc2ee4 96049fcf107e49a49f7d6c8fb8bdd2fc--a800e877078e4e4d8d3e6583141df6a0 c11dddcc38444bdb880f191b315d220e f2bb8797a6c14870abf983ae24b6a10a RX(theta\u2083) f9b5bc6bcde7480f89dee5d612874902--f2bb8797a6c14870abf983ae24b6a10a 083f065269414ce5990d09b6d545e28f RY(theta\u2087) f2bb8797a6c14870abf983ae24b6a10a--083f065269414ce5990d09b6d545e28f e8511a000ded4302b2d9fe3a2203c942 RX(theta\u2081\u2081) 083f065269414ce5990d09b6d545e28f--e8511a000ded4302b2d9fe3a2203c942 375b223df0b648a08b8fe72b2a8c9b87 X e8511a000ded4302b2d9fe3a2203c942--375b223df0b648a08b8fe72b2a8c9b87 375b223df0b648a08b8fe72b2a8c9b87--aa7788b8aefa4902a49885751b370c00 98e6014d06e54d019e9a83cabe7c946a 375b223df0b648a08b8fe72b2a8c9b87--98e6014d06e54d019e9a83cabe7c946a 76e0b5dde95b4b10be409aa2fb78a9ec RX(theta\u2081\u2085) 98e6014d06e54d019e9a83cabe7c946a--76e0b5dde95b4b10be409aa2fb78a9ec b3e05ae87bb64ffe868e30b0d0e67d83 RY(theta\u2081\u2089) 76e0b5dde95b4b10be409aa2fb78a9ec--b3e05ae87bb64ffe868e30b0d0e67d83 54a62e1a81fe4056a4a30268a1a8f061 RX(theta\u2082\u2083) b3e05ae87bb64ffe868e30b0d0e67d83--54a62e1a81fe4056a4a30268a1a8f061 31caa895548e4a4ab662b7f48c9066b3 X 54a62e1a81fe4056a4a30268a1a8f061--31caa895548e4a4ab662b7f48c9066b3 31caa895548e4a4ab662b7f48c9066b3--d0908b3245324ef3b80912fca7b42bd3 4bf470fdc8464d069cb9103598f7aa31 31caa895548e4a4ab662b7f48c9066b3--4bf470fdc8464d069cb9103598f7aa31 3e8416ef4b3042368f5e91add361849e RX(theta\u2083) 4bf470fdc8464d069cb9103598f7aa31--3e8416ef4b3042368f5e91add361849e a46f0b1557504b82ab479b8fd6a2a5c2 RY(theta\u2087) 3e8416ef4b3042368f5e91add361849e--a46f0b1557504b82ab479b8fd6a2a5c2 6a55da6fcd7649c89866b3e56a10000a RX(theta\u2081\u2081) a46f0b1557504b82ab479b8fd6a2a5c2--6a55da6fcd7649c89866b3e56a10000a b2e6062a1667431291d0c4d24144f876 X 6a55da6fcd7649c89866b3e56a10000a--b2e6062a1667431291d0c4d24144f876 b2e6062a1667431291d0c4d24144f876--919f6c7cf9d748c89d4adc77b7e251b2 d81d3077f6ea4fa2902c2ddc7c8022a2 b2e6062a1667431291d0c4d24144f876--d81d3077f6ea4fa2902c2ddc7c8022a2 62862c82d4d94e42841a681306aca8a2 RX(theta\u2081\u2085) d81d3077f6ea4fa2902c2ddc7c8022a2--62862c82d4d94e42841a681306aca8a2 c7c3cffc51884f25876f96ac2566f1d4 RY(theta\u2081\u2089) 62862c82d4d94e42841a681306aca8a2--c7c3cffc51884f25876f96ac2566f1d4 bc8c796b2148426bb92fc81c3b1fda18 RX(theta\u2082\u2083) c7c3cffc51884f25876f96ac2566f1d4--bc8c796b2148426bb92fc81c3b1fda18 6bd7ac8af0554944ac06ca60e244feca X bc8c796b2148426bb92fc81c3b1fda18--6bd7ac8af0554944ac06ca60e244feca 6bd7ac8af0554944ac06ca60e244feca--44751b6ec3894e86be87424f791cb132 4cc437f31a3c4242b0b51f2c1b61eab0 6bd7ac8af0554944ac06ca60e244feca--4cc437f31a3c4242b0b51f2c1b61eab0 4cc437f31a3c4242b0b51f2c1b61eab0--c11dddcc38444bdb880f191b315d220e </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_9c44e0cb90c7498f99b89c59d717aa12 HEA cluster_69e1c6ead77a46c9917b3a5083082f4f HEA 3985c40a266d445cb61b810b822cb1af 0 3eb2f464bfe84ebb9f105dd1fb467e86 RX(p1\u2080) 3985c40a266d445cb61b810b822cb1af--3eb2f464bfe84ebb9f105dd1fb467e86 0965ccd0095b4cd6877cbb4f5f787202 1 20bd9a03cb1f447cb9c1f2aa64497b04 RY(p1\u2084) 3eb2f464bfe84ebb9f105dd1fb467e86--20bd9a03cb1f447cb9c1f2aa64497b04 5516e713ce5a4e5d865f0340a8807022 RX(p1\u2088) 20bd9a03cb1f447cb9c1f2aa64497b04--5516e713ce5a4e5d865f0340a8807022 327541fee8324e82afdca1d479e4638d 5516e713ce5a4e5d865f0340a8807022--327541fee8324e82afdca1d479e4638d 631c52de351d4d99bcc0c3ae000ece6f 327541fee8324e82afdca1d479e4638d--631c52de351d4d99bcc0c3ae000ece6f 03da7bc828714be58d65141151371a4e RX(p1\u2081\u2082) 631c52de351d4d99bcc0c3ae000ece6f--03da7bc828714be58d65141151371a4e 27562f6adc5d434691b5c45019d72115 RY(p1\u2081\u2086) 03da7bc828714be58d65141151371a4e--27562f6adc5d434691b5c45019d72115 7c8d4d0bb7874d69a6330cb312828f52 RX(p1\u2082\u2080) 27562f6adc5d434691b5c45019d72115--7c8d4d0bb7874d69a6330cb312828f52 a34c4a1306bd49b7999fab84508c70af 7c8d4d0bb7874d69a6330cb312828f52--a34c4a1306bd49b7999fab84508c70af c8d6410357734b449182c7971bf3829d a34c4a1306bd49b7999fab84508c70af--c8d6410357734b449182c7971bf3829d b18cce13b94e4625aba7b718f18efb6e RX(p2\u2080) c8d6410357734b449182c7971bf3829d--b18cce13b94e4625aba7b718f18efb6e 65301132c95b40ada6abdc854edf01d8 RY(p2\u2084) b18cce13b94e4625aba7b718f18efb6e--65301132c95b40ada6abdc854edf01d8 17b0726282064d859eb43226a30f6ad3 RX(p2\u2088) 65301132c95b40ada6abdc854edf01d8--17b0726282064d859eb43226a30f6ad3 83eac902af544ca6b0f12b5ad6015bad 17b0726282064d859eb43226a30f6ad3--83eac902af544ca6b0f12b5ad6015bad 0337df1ceafa47d4805cad3f76fec09b 83eac902af544ca6b0f12b5ad6015bad--0337df1ceafa47d4805cad3f76fec09b d82db60ebc2349418ffee8cf738ccd44 RX(p2\u2081\u2082) 0337df1ceafa47d4805cad3f76fec09b--d82db60ebc2349418ffee8cf738ccd44 d18189e1a98e4856ab4b6ca0b82e7a7b RY(p2\u2081\u2086) d82db60ebc2349418ffee8cf738ccd44--d18189e1a98e4856ab4b6ca0b82e7a7b 3fded8a6e3f0494ca98ebee57e32df4b RX(p2\u2082\u2080) d18189e1a98e4856ab4b6ca0b82e7a7b--3fded8a6e3f0494ca98ebee57e32df4b 7a36c94c8ca24ac3b793a92747f83b98 3fded8a6e3f0494ca98ebee57e32df4b--7a36c94c8ca24ac3b793a92747f83b98 cf7674addc9444328e624a0adfb57fc9 7a36c94c8ca24ac3b793a92747f83b98--cf7674addc9444328e624a0adfb57fc9 96d93be1764a48929b3737620bcbdd85 cf7674addc9444328e624a0adfb57fc9--96d93be1764a48929b3737620bcbdd85 d2eeef02492a42d9b2a7ab77c29ce50a 91eaa1012b334fed91aee38815cec1f2 RX(p1\u2081) 0965ccd0095b4cd6877cbb4f5f787202--91eaa1012b334fed91aee38815cec1f2 92af7971f19d4691b687ff19791251c4 2 833883ef006b40ffaca027478766befe RY(p1\u2085) 91eaa1012b334fed91aee38815cec1f2--833883ef006b40ffaca027478766befe 9a10969a28634d378294609e5d06ed15 RX(p1\u2089) 833883ef006b40ffaca027478766befe--9a10969a28634d378294609e5d06ed15 2f38799916c14af0964102d90654221b X 9a10969a28634d378294609e5d06ed15--2f38799916c14af0964102d90654221b 2f38799916c14af0964102d90654221b--327541fee8324e82afdca1d479e4638d ba374055e0434c54b2216933f47ca30e 2f38799916c14af0964102d90654221b--ba374055e0434c54b2216933f47ca30e 1931eca5bb244b5f91a9868f5c790f9a RX(p1\u2081\u2083) ba374055e0434c54b2216933f47ca30e--1931eca5bb244b5f91a9868f5c790f9a 659aed4fbe62478fb494e2ff7854892d RY(p1\u2081\u2087) 1931eca5bb244b5f91a9868f5c790f9a--659aed4fbe62478fb494e2ff7854892d 92047d611e044798b7c96305de3cf8ad RX(p1\u2082\u2081) 659aed4fbe62478fb494e2ff7854892d--92047d611e044798b7c96305de3cf8ad fc75cf519a09480f879e5f9ab33ee0ca X 92047d611e044798b7c96305de3cf8ad--fc75cf519a09480f879e5f9ab33ee0ca fc75cf519a09480f879e5f9ab33ee0ca--a34c4a1306bd49b7999fab84508c70af 84b3333f4228445cacba2c6b8dfe3ce0 fc75cf519a09480f879e5f9ab33ee0ca--84b3333f4228445cacba2c6b8dfe3ce0 ba7055bc8dc94f72adbae2a57a9a00ca RX(p2\u2081) 84b3333f4228445cacba2c6b8dfe3ce0--ba7055bc8dc94f72adbae2a57a9a00ca 6bf80815af9b45a4a315d78299f358b6 RY(p2\u2085) ba7055bc8dc94f72adbae2a57a9a00ca--6bf80815af9b45a4a315d78299f358b6 f332baf673e349dea2897c40a3c37dc8 RX(p2\u2089) 6bf80815af9b45a4a315d78299f358b6--f332baf673e349dea2897c40a3c37dc8 c86ab1a42dfa455fb976d1489507b8d7 X f332baf673e349dea2897c40a3c37dc8--c86ab1a42dfa455fb976d1489507b8d7 c86ab1a42dfa455fb976d1489507b8d7--83eac902af544ca6b0f12b5ad6015bad b389c0478e5142508b3169329ad15ae7 c86ab1a42dfa455fb976d1489507b8d7--b389c0478e5142508b3169329ad15ae7 55dc0e7725d047cfb9032f53dd26373f RX(p2\u2081\u2083) b389c0478e5142508b3169329ad15ae7--55dc0e7725d047cfb9032f53dd26373f 2831a48c38e543d2ac0be7964f853c21 RY(p2\u2081\u2087) 55dc0e7725d047cfb9032f53dd26373f--2831a48c38e543d2ac0be7964f853c21 cf7eaefbb9a44434a180b57a0ae334d7 RX(p2\u2082\u2081) 2831a48c38e543d2ac0be7964f853c21--cf7eaefbb9a44434a180b57a0ae334d7 0e8c6acd046945dd9fa3cdde7b592eb0 X cf7eaefbb9a44434a180b57a0ae334d7--0e8c6acd046945dd9fa3cdde7b592eb0 0e8c6acd046945dd9fa3cdde7b592eb0--7a36c94c8ca24ac3b793a92747f83b98 6295c204dac04cbd9b70ff6ea6378ba0 0e8c6acd046945dd9fa3cdde7b592eb0--6295c204dac04cbd9b70ff6ea6378ba0 6295c204dac04cbd9b70ff6ea6378ba0--d2eeef02492a42d9b2a7ab77c29ce50a 53f3780de27e4d35aea8dd6321b664f6 751e5b518e774b66ab34209dd380d7f4 RX(p1\u2082) 92af7971f19d4691b687ff19791251c4--751e5b518e774b66ab34209dd380d7f4 2d18136ef6ad453ab1ddad3b06f5a0dc 3 3febf7776c1545db8e0fe3af5af23fa0 RY(p1\u2086) 751e5b518e774b66ab34209dd380d7f4--3febf7776c1545db8e0fe3af5af23fa0 559dac7658c94b48a92fd10af3c4d782 RX(p1\u2081\u2080) 3febf7776c1545db8e0fe3af5af23fa0--559dac7658c94b48a92fd10af3c4d782 a9ab8490e9d94853a91ce80b81656cc8 559dac7658c94b48a92fd10af3c4d782--a9ab8490e9d94853a91ce80b81656cc8 6e3a7ac8e3d845889875cffe99b4d528 X a9ab8490e9d94853a91ce80b81656cc8--6e3a7ac8e3d845889875cffe99b4d528 6e3a7ac8e3d845889875cffe99b4d528--ba374055e0434c54b2216933f47ca30e 14b5859ee06b4f6fa15aa216134dd711 RX(p1\u2081\u2084) 6e3a7ac8e3d845889875cffe99b4d528--14b5859ee06b4f6fa15aa216134dd711 e79dcca091ac48728810be6b583f05b7 RY(p1\u2081\u2088) 14b5859ee06b4f6fa15aa216134dd711--e79dcca091ac48728810be6b583f05b7 74460a48ddce4123a2bbcac840c98e21 RX(p1\u2082\u2082) e79dcca091ac48728810be6b583f05b7--74460a48ddce4123a2bbcac840c98e21 e6b50624847b4bc3a4c94b180333959e 74460a48ddce4123a2bbcac840c98e21--e6b50624847b4bc3a4c94b180333959e 9d33c4c213f84ef990a602459e6ff521 X e6b50624847b4bc3a4c94b180333959e--9d33c4c213f84ef990a602459e6ff521 9d33c4c213f84ef990a602459e6ff521--84b3333f4228445cacba2c6b8dfe3ce0 6cbec806f04941c6a71273ae0590cb0d RX(p2\u2082) 9d33c4c213f84ef990a602459e6ff521--6cbec806f04941c6a71273ae0590cb0d 582d5a72ffd04af8ac335123d9e7e02d RY(p2\u2086) 6cbec806f04941c6a71273ae0590cb0d--582d5a72ffd04af8ac335123d9e7e02d f073738396db441e8a616fce8dec3685 RX(p2\u2081\u2080) 582d5a72ffd04af8ac335123d9e7e02d--f073738396db441e8a616fce8dec3685 c86519d44ae6480d9aa6980bbbc0e5ad f073738396db441e8a616fce8dec3685--c86519d44ae6480d9aa6980bbbc0e5ad 68467b169ba94c3289322328950e62d1 X c86519d44ae6480d9aa6980bbbc0e5ad--68467b169ba94c3289322328950e62d1 68467b169ba94c3289322328950e62d1--b389c0478e5142508b3169329ad15ae7 49db20ac83734795a24f5a67771d7f09 RX(p2\u2081\u2084) 68467b169ba94c3289322328950e62d1--49db20ac83734795a24f5a67771d7f09 6294d9d9f7e34c8bbecab9c261262147 RY(p2\u2081\u2088) 49db20ac83734795a24f5a67771d7f09--6294d9d9f7e34c8bbecab9c261262147 141fbb09449045eb87a3856cbeae7404 RX(p2\u2082\u2082) 6294d9d9f7e34c8bbecab9c261262147--141fbb09449045eb87a3856cbeae7404 12aaa0df243c4d26a83e1fc65830a828 141fbb09449045eb87a3856cbeae7404--12aaa0df243c4d26a83e1fc65830a828 161ee238f3834a5ea9e313dfeda5fe92 X 12aaa0df243c4d26a83e1fc65830a828--161ee238f3834a5ea9e313dfeda5fe92 161ee238f3834a5ea9e313dfeda5fe92--6295c204dac04cbd9b70ff6ea6378ba0 161ee238f3834a5ea9e313dfeda5fe92--53f3780de27e4d35aea8dd6321b664f6 b7f86c48211b403190808c366d13c0e1 9ed384201bc44d0ca5261fc20e826e71 RX(p1\u2083) 2d18136ef6ad453ab1ddad3b06f5a0dc--9ed384201bc44d0ca5261fc20e826e71 376ddce1cc7940f392d121bb792550e0 RY(p1\u2087) 9ed384201bc44d0ca5261fc20e826e71--376ddce1cc7940f392d121bb792550e0 33744845507b4d3f902823352beab81b RX(p1\u2081\u2081) 376ddce1cc7940f392d121bb792550e0--33744845507b4d3f902823352beab81b 142556fc74cf473190c79973d6f22167 X 33744845507b4d3f902823352beab81b--142556fc74cf473190c79973d6f22167 142556fc74cf473190c79973d6f22167--a9ab8490e9d94853a91ce80b81656cc8 b70a5fb5a3cd4a67b84f7aabfaadf958 142556fc74cf473190c79973d6f22167--b70a5fb5a3cd4a67b84f7aabfaadf958 8a9126c99a264bb8bdb144fe3d1b1caa RX(p1\u2081\u2085) b70a5fb5a3cd4a67b84f7aabfaadf958--8a9126c99a264bb8bdb144fe3d1b1caa 88601752828b4070b0204b6e51e85da1 RY(p1\u2081\u2089) 8a9126c99a264bb8bdb144fe3d1b1caa--88601752828b4070b0204b6e51e85da1 0f6be8f4631e4145a864504e1ae5588f RX(p1\u2082\u2083) 88601752828b4070b0204b6e51e85da1--0f6be8f4631e4145a864504e1ae5588f a142a3007cd24b8e931a75a09d062f7c X 0f6be8f4631e4145a864504e1ae5588f--a142a3007cd24b8e931a75a09d062f7c a142a3007cd24b8e931a75a09d062f7c--e6b50624847b4bc3a4c94b180333959e 3d826b201c16406db214e6db91573fcd a142a3007cd24b8e931a75a09d062f7c--3d826b201c16406db214e6db91573fcd 50bf5bd6ebd449d599d543c16bbdebc3 RX(p2\u2083) 3d826b201c16406db214e6db91573fcd--50bf5bd6ebd449d599d543c16bbdebc3 5857e5c605dd4f4892bb0f70034b5033 RY(p2\u2087) 50bf5bd6ebd449d599d543c16bbdebc3--5857e5c605dd4f4892bb0f70034b5033 79fedd2def1b4bf4b388dc47f61a5cbf RX(p2\u2081\u2081) 5857e5c605dd4f4892bb0f70034b5033--79fedd2def1b4bf4b388dc47f61a5cbf 2c8a2c123b2743438cbd1686f9412fdb X 79fedd2def1b4bf4b388dc47f61a5cbf--2c8a2c123b2743438cbd1686f9412fdb 2c8a2c123b2743438cbd1686f9412fdb--c86519d44ae6480d9aa6980bbbc0e5ad 7b1ff48e55664c96bd8b54b57e46c39a 2c8a2c123b2743438cbd1686f9412fdb--7b1ff48e55664c96bd8b54b57e46c39a 0c30250f5b7b49579c8208bcfda191d0 RX(p2\u2081\u2085) 7b1ff48e55664c96bd8b54b57e46c39a--0c30250f5b7b49579c8208bcfda191d0 23b26f7ed8a144b48055ab5134c0b445 RY(p2\u2081\u2089) 0c30250f5b7b49579c8208bcfda191d0--23b26f7ed8a144b48055ab5134c0b445 2fadc9dd01f14044b9cca7d862b82691 RX(p2\u2082\u2083) 23b26f7ed8a144b48055ab5134c0b445--2fadc9dd01f14044b9cca7d862b82691 74adac043ab14956888312012bf12cfc X 2fadc9dd01f14044b9cca7d862b82691--74adac043ab14956888312012bf12cfc 74adac043ab14956888312012bf12cfc--12aaa0df243c4d26a83e1fc65830a828 a72275fbbd954818b1e6c6e746c80828 74adac043ab14956888312012bf12cfc--a72275fbbd954818b1e6c6e746c80828 a72275fbbd954818b1e6c6e746c80828--b7f86c48211b403190808c366d13c0e1 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6032])), ('theta_0', tensor([0.7060])), ('theta_1', tensor([0.8729])), ('theta_10', tensor([0.5824])), ('theta_11', tensor([0.7651])), ('theta_12', tensor([0.7259])), ('theta_13', tensor([0.8999])), ('theta_14', tensor([0.5249])), ('theta_15', tensor([0.8056])), ('theta_16', tensor([0.8753])), ('theta_17', tensor([0.9508])), ('theta_18', tensor([0.5994])), ('theta_19', tensor([0.5960])), ('theta_2', tensor([0.3586])), ('theta_20', tensor([0.0068])), ('theta_21', tensor([0.4744])), ('theta_22', tensor([0.3152])), ('theta_23', tensor([0.4480])), ('theta_3', tensor([0.7231])), ('theta_4', tensor([0.2878])), ('theta_5', tensor([0.8199])), ('theta_6', tensor([0.4943])), ('theta_7', tensor([0.6892])), ('theta_8', tensor([0.0667])), ('theta_9', tensor([0.9967]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6022])), ('theta_0', tensor([0.7070])), ('theta_1', tensor([0.8719])), ('theta_10', tensor([0.5834])), ('theta_11', tensor([0.7661])), ('theta_12', tensor([0.7269])), ('theta_13', tensor([0.9009])), ('theta_14', tensor([0.5259])), ('theta_15', tensor([0.8066])), ('theta_16', tensor([0.8763])), ('theta_17', tensor([0.9518])), ('theta_18', tensor([0.5984])), ('theta_19', tensor([0.5970])), ('theta_2', tensor([0.3596])), ('theta_20', tensor([0.0078])), ('theta_21', tensor([0.4754])), ('theta_22', tensor([0.3162])), ('theta_23', tensor([0.4490])), ('theta_3', tensor([0.7241])), ('theta_4', tensor([0.2888])), ('theta_5', tensor([0.8209])), ('theta_6', tensor([0.4953])), ('theta_7', tensor([0.6902])), ('theta_8', tensor([0.0677])), ('theta_9', tensor([0.9957]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): RX(qubit_support=(0,))\n(1): RX(qubit_support=(1,))\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9968+0.0000j,  0.0000-0.0567j,  0.0000-0.0567j, -0.0032+0.0000j],\n[ 0.9533+0.0000j,  0.0000-0.2109j,  0.0000-0.2109j, -0.0467+0.0000j],\n[ 0.9707+0.0000j,  0.0000-0.1686j,  0.0000-0.1686j, -0.0293+0.0000j]])\nxs = [Counter({'00': 100}), Counter({'00': 92, '10': 5, '11': 2, '01': 1}), Counter({'00': 95, '01': 4, '10': 1})]\nex = tensor([[0.9936],\n[0.9067],\n[0.9414]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9936, 0.9936],\n[0.9067, 0.9067],\n[0.9414, 0.9414]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-11-06T13:38:37.831720 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-11-06T13:38:38.311473 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-11-06T13:38:38.430317 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>Qubits coordinates in Qadence are dimensionless but converted to the required unit when executed on a backend. For instance, Pulser uses \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interaction must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 53, '01': 47})]\nSample in little endian = [Counter({'10': 60, '00': 40})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 53, '10': 47})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 89, '01': 11})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 88, '01': 12})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9223+0.0000j, 0.0000-0.3865j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [0.92042346+0.3752344j  0.        +0.j         0.04138827-0.10152249j\n0.        +0.j        ]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_4ce0ffa4c4014c75a5013de6b12d6d64 Circuit block cluster_9865317ca55e498fbab90c3d3bba2768 Prep block 5ac13b0f433c438d9d7e906678d2f934 0 8378db0bf9e149059b3e629b320d283a 5ac13b0f433c438d9d7e906678d2f934--8378db0bf9e149059b3e629b320d283a daac939040d645bea53fa94662c16877 1 200fc41532624bf886080c354b281b7d RX(theta\u2080) 8378db0bf9e149059b3e629b320d283a--200fc41532624bf886080c354b281b7d 5cb90460d2b841878cde2c5ee2dc6847 RY(theta\u2084) 200fc41532624bf886080c354b281b7d--5cb90460d2b841878cde2c5ee2dc6847 8f75cda9aefb4523b9094f23a646b9bd RX(theta\u2088) 5cb90460d2b841878cde2c5ee2dc6847--8f75cda9aefb4523b9094f23a646b9bd f833f0090c4546beb255b838762a25c4 8f75cda9aefb4523b9094f23a646b9bd--f833f0090c4546beb255b838762a25c4 dbb671eccb3e4c90bd13062023a089fd f833f0090c4546beb255b838762a25c4--dbb671eccb3e4c90bd13062023a089fd 179ab97d1a1d4fedad0a5243544fd53f RX(theta\u2081\u2082) dbb671eccb3e4c90bd13062023a089fd--179ab97d1a1d4fedad0a5243544fd53f bc0fd4642da34696ba4f9c00c2e67e87 RY(theta\u2081\u2086) 179ab97d1a1d4fedad0a5243544fd53f--bc0fd4642da34696ba4f9c00c2e67e87 148dbc86059846a48e6277d2d518f07e RX(theta\u2082\u2080) bc0fd4642da34696ba4f9c00c2e67e87--148dbc86059846a48e6277d2d518f07e 64404bceffc44f498f3212716a804a4c 148dbc86059846a48e6277d2d518f07e--64404bceffc44f498f3212716a804a4c b3d87d73d500410d8901bc35994c7998 64404bceffc44f498f3212716a804a4c--b3d87d73d500410d8901bc35994c7998 6933d65e8ca24d66bd9929fc549586ab b3d87d73d500410d8901bc35994c7998--6933d65e8ca24d66bd9929fc549586ab 3d35f86a1e5944228652b52fd9faf7ad 799e1baa7972495eb0e36e2d4e4aa534 daac939040d645bea53fa94662c16877--799e1baa7972495eb0e36e2d4e4aa534 6d87e87f642647c9b5b6e2a61874cdef 2 017bc6d239584849b03fb8a556520677 RX(theta\u2081) 799e1baa7972495eb0e36e2d4e4aa534--017bc6d239584849b03fb8a556520677 4e8e81b632ba4b8dac1bb213fe193a0e RY(theta\u2085) 017bc6d239584849b03fb8a556520677--4e8e81b632ba4b8dac1bb213fe193a0e 09518538f27b4709b5a28c6a7d926f5f RX(theta\u2089) 4e8e81b632ba4b8dac1bb213fe193a0e--09518538f27b4709b5a28c6a7d926f5f 462c0a63b286473e9fb7182f5241e6a2 X 09518538f27b4709b5a28c6a7d926f5f--462c0a63b286473e9fb7182f5241e6a2 462c0a63b286473e9fb7182f5241e6a2--f833f0090c4546beb255b838762a25c4 99d33b73a1f1418b918bfe2fb618ecca 462c0a63b286473e9fb7182f5241e6a2--99d33b73a1f1418b918bfe2fb618ecca f06f4e6da5814a11b40a616485ff6c0b RX(theta\u2081\u2083) 99d33b73a1f1418b918bfe2fb618ecca--f06f4e6da5814a11b40a616485ff6c0b 755c7f842aaf472f9dee99f5962edc89 RY(theta\u2081\u2087) f06f4e6da5814a11b40a616485ff6c0b--755c7f842aaf472f9dee99f5962edc89 0a07b56b7456456d80bbd47717209fd8 RX(theta\u2082\u2081) 755c7f842aaf472f9dee99f5962edc89--0a07b56b7456456d80bbd47717209fd8 61bf95e14f2148829075aeb839fe4b42 X 0a07b56b7456456d80bbd47717209fd8--61bf95e14f2148829075aeb839fe4b42 61bf95e14f2148829075aeb839fe4b42--64404bceffc44f498f3212716a804a4c 9b0fb3cee35242c4a8d3d05378919920 61bf95e14f2148829075aeb839fe4b42--9b0fb3cee35242c4a8d3d05378919920 9b0fb3cee35242c4a8d3d05378919920--3d35f86a1e5944228652b52fd9faf7ad a2aa1cb112474c99b546205cb3c34d8c b9d9fc3d19e840d992ef8d2ffcfdc136 6d87e87f642647c9b5b6e2a61874cdef--b9d9fc3d19e840d992ef8d2ffcfdc136 18095005a0414805b00457707842deaa 3 93cbba6bef3348d38b3c5efb63de1b81 RX(theta\u2082) b9d9fc3d19e840d992ef8d2ffcfdc136--93cbba6bef3348d38b3c5efb63de1b81 f3f182fd6fca44fea4d1296184730a25 RY(theta\u2086) 93cbba6bef3348d38b3c5efb63de1b81--f3f182fd6fca44fea4d1296184730a25 03af64b6419746a6a9634f0301b20c85 RX(theta\u2081\u2080) f3f182fd6fca44fea4d1296184730a25--03af64b6419746a6a9634f0301b20c85 893463695d174a03accdaeed50f01280 03af64b6419746a6a9634f0301b20c85--893463695d174a03accdaeed50f01280 0cd41e1877f646cda0af5673a4d49706 X 893463695d174a03accdaeed50f01280--0cd41e1877f646cda0af5673a4d49706 0cd41e1877f646cda0af5673a4d49706--99d33b73a1f1418b918bfe2fb618ecca 9549f6b7c6594a12917d5d327f8ac5fe RX(theta\u2081\u2084) 0cd41e1877f646cda0af5673a4d49706--9549f6b7c6594a12917d5d327f8ac5fe af8c951fbf07496d8dad754d183522b2 RY(theta\u2081\u2088) 9549f6b7c6594a12917d5d327f8ac5fe--af8c951fbf07496d8dad754d183522b2 5f4f1b281425456cb64d38adac536ece RX(theta\u2082\u2082) af8c951fbf07496d8dad754d183522b2--5f4f1b281425456cb64d38adac536ece 47334c3310a54b39ab437161fac26ce7 5f4f1b281425456cb64d38adac536ece--47334c3310a54b39ab437161fac26ce7 b42cb6c38da4499db2669e47de1453e4 X 47334c3310a54b39ab437161fac26ce7--b42cb6c38da4499db2669e47de1453e4 b42cb6c38da4499db2669e47de1453e4--9b0fb3cee35242c4a8d3d05378919920 b42cb6c38da4499db2669e47de1453e4--a2aa1cb112474c99b546205cb3c34d8c 2ae737e7a4d1470cb8ce4db8feaaaf42 01cb8012612248e887f2794104e43335 X 18095005a0414805b00457707842deaa--01cb8012612248e887f2794104e43335 13179a6ddc9547bca093b68633037a83 RX(theta\u2083) 01cb8012612248e887f2794104e43335--13179a6ddc9547bca093b68633037a83 2c61c73f51dc49a7a659152f667b8001 RY(theta\u2087) 13179a6ddc9547bca093b68633037a83--2c61c73f51dc49a7a659152f667b8001 26e10f7305234eb98f37ef93758298b1 RX(theta\u2081\u2081) 2c61c73f51dc49a7a659152f667b8001--26e10f7305234eb98f37ef93758298b1 7bf478e2aaa548d7b8d4c94a263d1de1 X 26e10f7305234eb98f37ef93758298b1--7bf478e2aaa548d7b8d4c94a263d1de1 7bf478e2aaa548d7b8d4c94a263d1de1--893463695d174a03accdaeed50f01280 bf1639986d8043ac9e2a5475a433728d 7bf478e2aaa548d7b8d4c94a263d1de1--bf1639986d8043ac9e2a5475a433728d 8cb727d5542d4538825ac5026c8c1895 RX(theta\u2081\u2085) bf1639986d8043ac9e2a5475a433728d--8cb727d5542d4538825ac5026c8c1895 9078fd91f82a4e98824450c4a57b80da RY(theta\u2081\u2089) 8cb727d5542d4538825ac5026c8c1895--9078fd91f82a4e98824450c4a57b80da 7ed693e5e6e94fc2a3561b7057e3e1b1 RX(theta\u2082\u2083) 9078fd91f82a4e98824450c4a57b80da--7ed693e5e6e94fc2a3561b7057e3e1b1 3bfbd2017efb452f8fbe902ffa0400db X 7ed693e5e6e94fc2a3561b7057e3e1b1--3bfbd2017efb452f8fbe902ffa0400db 3bfbd2017efb452f8fbe902ffa0400db--47334c3310a54b39ab437161fac26ce7 de7f455ca6c14d56b3465633c2924551 3bfbd2017efb452f8fbe902ffa0400db--de7f455ca6c14d56b3465633c2924551 de7f455ca6c14d56b3465633c2924551--2ae737e7a4d1470cb8ce4db8feaaaf42  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[-0.1938-0.0520j, -0.2004+0.3661j, -0.0483-0.0577j, -0.2657-0.3253j,\n0.4508+0.0664j,  0.2878+0.0577j, -0.2979+0.1222j, -0.0662+0.4491j],\n[ 0.2315-0.2451j,  0.2807+0.1053j, -0.3644+0.4587j, -0.0791+0.0530j,\n-0.0125-0.1685j,  0.2731-0.3878j, -0.3455-0.2506j, -0.0893-0.0241j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}