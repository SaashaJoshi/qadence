{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from qadence import X, Y, HamEvo, Register, product_state, sample, add, PI\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = PI / (2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from qadence import Register, AnalogRX, sample, PI\n\n# Global analog RX block.\nblock = AnalogRX(PI)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(PI))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'01': 35, '10': 34, '00': 31})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> or <code>horqrux</code> backends are selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p>Qadence also offers a memory-efficient, non-device compatible alternative to automatic differentation, called 'Adjoint Differentiation' <sup>4</sup> and allows for precisely calculating the gradients of variational parameters in O(P) time and using O(1) state-vectors. Adjoint Differentation is currently only supported by the Torch Engine and allows for first-order derivatives only.</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the differentiation modes can be selected via the <code>diff_mode</code> argument of the QuantumModel class. It either accepts a <code>DiffMode</code>(<code>DiffMode.GSPR</code>, <code>DiffMode.AD</code> or <code>DiffMode.ADJOINT</code>) or a string (<code>\"gpsr\"\"</code>, <code>\"ad\"</code> or <code>\"adjoint\"</code>). The code in the box below shows how to create <code>QuantumModel</code> instances with all available differentiation modes.</p> <pre><code>from qadence import (FeatureParameter, RX, Z, hea, chain,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# Define a symbolic parameter to differentiate with respect to\nx = FeatureParameter(\"x\")\n\nblock = chain(hea(n_qubits, 1), RX(0, x))\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD, ADJOINT and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_adjoint = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.ADJOINT)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# Create concrete values for the parameter we want to differentiate with respect to\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_adjoint = model_adjoint.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_adjoint = torch.autograd.grad(\n    exp_val_adjoint, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD ,ADJOINT and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_adjoint.detach().numpy(),\n           label=\"df/dx ADJOINT\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2024-01-17T18:15:49.363655 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> <li> <p>Tyson et al., Efficient calculation of gradients in classical simulations of variational quantum algorithms \u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, InteractionBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 c93876ec87d94984bafe5ec3cc96a055 0 365c2ef257aa42d08b08b26a8e5d1624 X c93876ec87d94984bafe5ec3cc96a055--365c2ef257aa42d08b08b26a8e5d1624 d7d166d6d5fb4dfab348117a0c563437 1 a379fd271d854e35956a4d4b618d6697 365c2ef257aa42d08b08b26a8e5d1624--a379fd271d854e35956a4d4b618d6697 0ee91ccc3f7c4ebe87e02a7f958e7d56 ccfb78769c7746388245253fbc80747c Y d7d166d6d5fb4dfab348117a0c563437--ccfb78769c7746388245253fbc80747c ccfb78769c7746388245253fbc80747c--0ee91ccc3f7c4ebe87e02a7f958e7d56 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 1858ef711e074dd78d3d2378c8a8e317 0 9817fce134ce4fdc9c0101675c3c9f13 X 1858ef711e074dd78d3d2378c8a8e317--9817fce134ce4fdc9c0101675c3c9f13 91e950ab454941c49978fbf51744a000 Y 9817fce134ce4fdc9c0101675c3c9f13--91e950ab454941c49978fbf51744a000 5d6cb808798248b790a22acb1a6b7a38 91e950ab454941c49978fbf51744a000--5d6cb808798248b790a22acb1a6b7a38 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 4fe856aed9544dcc93d0455eef2317c8 0 8e88a943d4344d7291276c2b70b9d7a6 X 4fe856aed9544dcc93d0455eef2317c8--8e88a943d4344d7291276c2b70b9d7a6 c69911ee8270496fb6520d40010d5521 1 ff745264554f44d383451c6c8bb120af 8e88a943d4344d7291276c2b70b9d7a6--ff745264554f44d383451c6c8bb120af c0d16262a13e46dd9a95145c181bb2c9 ff745264554f44d383451c6c8bb120af--c0d16262a13e46dd9a95145c181bb2c9 cb752dd27471486b8939199932eae047 0b078394371142629bfd2ab3f7bfa721 c69911ee8270496fb6520d40010d5521--0b078394371142629bfd2ab3f7bfa721 9058be523b8c4391ba8a81560ae57e3e Y 0b078394371142629bfd2ab3f7bfa721--9058be523b8c4391ba8a81560ae57e3e 9058be523b8c4391ba8a81560ae57e3e--cb752dd27471486b8939199932eae047 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_d0d4194434a942edbb3d067290157e8e 5185fb40eeb145c8b36c6e6339f2c795 0 27482e6a3e6148dcbbe68d64468550a0 5185fb40eeb145c8b36c6e6339f2c795--27482e6a3e6148dcbbe68d64468550a0 ff0017072a634de5af19f272099039fc 1 7ca29d12e8a24e0781171ec41ac36e5e 27482e6a3e6148dcbbe68d64468550a0--7ca29d12e8a24e0781171ec41ac36e5e a60d3712d4544932ac82aaf6e7ac8f82 40e05fed4d594a8597dbaa3d153c8f5b AddBlock ff0017072a634de5af19f272099039fc--40e05fed4d594a8597dbaa3d153c8f5b 9a24cafa42f941038799426d475f15ef 2 40e05fed4d594a8597dbaa3d153c8f5b--a60d3712d4544932ac82aaf6e7ac8f82 7e3c17859c954de0b091512c573fb6e0 4673bdd52d664d73bddb9b127965ff69 9a24cafa42f941038799426d475f15ef--4673bdd52d664d73bddb9b127965ff69 4673bdd52d664d73bddb9b127965ff69--7e3c17859c954de0b091512c573fb6e0 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_5668308275664d0a8b4c058b5fa583b8 cluster_7b5af4aac89242398ca7f5285bd8710d rx 67da2c7c6f5e4cf1b16ae80446e2b693 0 4c12364902844ade8219c26afd027e39 X 67da2c7c6f5e4cf1b16ae80446e2b693--4c12364902844ade8219c26afd027e39 e04a16c023cc493d80a3cbaefae454d6 1 625dc741bebd42db9f091bc68926fdb5 4c12364902844ade8219c26afd027e39--625dc741bebd42db9f091bc68926fdb5 a47f22afb2154fe3b1b30f954ea1a4c0 625dc741bebd42db9f091bc68926fdb5--a47f22afb2154fe3b1b30f954ea1a4c0 bd7cbf9f206a480d864a519bcda3696f a47f22afb2154fe3b1b30f954ea1a4c0--bd7cbf9f206a480d864a519bcda3696f 1c3e0260fb3e41259aa0997b9ecd564d 1cf088881da64eecbd1758e03c072b55 Y e04a16c023cc493d80a3cbaefae454d6--1cf088881da64eecbd1758e03c072b55 9e75b56b7e044ae3998db941f70228bf 2 47a1f0b32e22447496aa798ae85e9376 1cf088881da64eecbd1758e03c072b55--47a1f0b32e22447496aa798ae85e9376 8ae6019992304a1cb0de32adf97b05d8 HamEvo 47a1f0b32e22447496aa798ae85e9376--8ae6019992304a1cb0de32adf97b05d8 8ae6019992304a1cb0de32adf97b05d8--1c3e0260fb3e41259aa0997b9ecd564d f0ba0fbc011f4ebf9b14a4f871915129 94522cf0f33045338ac8d1b9927d8d3c RX(x) 9e75b56b7e044ae3998db941f70228bf--94522cf0f33045338ac8d1b9927d8d3c 97d3424254834fc7bf22c55243f9dabb 3 62b164a4f9db458da44a61b68de0fb94 94522cf0f33045338ac8d1b9927d8d3c--62b164a4f9db458da44a61b68de0fb94 d314de5583664211b4a2b826c4d5c383 t = 10 62b164a4f9db458da44a61b68de0fb94--d314de5583664211b4a2b826c4d5c383 d314de5583664211b4a2b826c4d5c383--f0ba0fbc011f4ebf9b14a4f871915129 99a29fcbe29a4f1fab39dc1d4bc42c2a 61311dd28ef2411e88776aa27deedca6 RX(0.5) 97d3424254834fc7bf22c55243f9dabb--61311dd28ef2411e88776aa27deedca6 e265300c4e06418cb8afc23cea4b9394 X 61311dd28ef2411e88776aa27deedca6--e265300c4e06418cb8afc23cea4b9394 e265300c4e06418cb8afc23cea4b9394--62b164a4f9db458da44a61b68de0fb94 88c898f865084a5db6e121805247531f e265300c4e06418cb8afc23cea4b9394--88c898f865084a5db6e121805247531f 88c898f865084a5db6e121805247531f--99a29fcbe29a4f1fab39dc1d4bc42c2a <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_4f10dcc079814126b59742f83fdf54e0 HEA cluster_744435f2bde84cc198f38491ef619351 Tower Fourier FM 70368b7320714abbb035666838afbf7d 0 c368053fdaa64906b95a96e9225214de RX(1.0*phi) 70368b7320714abbb035666838afbf7d--c368053fdaa64906b95a96e9225214de 074593fae06343659350dd33d81cdc48 1 93ca467e125c47acba23e44054f5f3ef RX(theta\u2080) c368053fdaa64906b95a96e9225214de--93ca467e125c47acba23e44054f5f3ef 5dc534906e7e4bc5bd8b2b3ae733123b RY(theta\u2084) 93ca467e125c47acba23e44054f5f3ef--5dc534906e7e4bc5bd8b2b3ae733123b 90dc0390cc3944ce899497a7f0c04b9c RX(theta\u2088) 5dc534906e7e4bc5bd8b2b3ae733123b--90dc0390cc3944ce899497a7f0c04b9c 4b1f8e6ca2f444d6bd5d338286279898 90dc0390cc3944ce899497a7f0c04b9c--4b1f8e6ca2f444d6bd5d338286279898 05eb7f671ae34dc6a1f1a3e9dfb31c6b 4b1f8e6ca2f444d6bd5d338286279898--05eb7f671ae34dc6a1f1a3e9dfb31c6b 15df98469f7647778dcdc4d82c6c2981 RX(theta\u2081\u2082) 05eb7f671ae34dc6a1f1a3e9dfb31c6b--15df98469f7647778dcdc4d82c6c2981 0f976439c07c41cf9bb3f29e332ed4fe RY(theta\u2081\u2086) 15df98469f7647778dcdc4d82c6c2981--0f976439c07c41cf9bb3f29e332ed4fe 595ba237eb78413689e50323c65e3cfa RX(theta\u2082\u2080) 0f976439c07c41cf9bb3f29e332ed4fe--595ba237eb78413689e50323c65e3cfa f610da10a7864765bfeb947501fc6185 595ba237eb78413689e50323c65e3cfa--f610da10a7864765bfeb947501fc6185 6e50fdf9d07746f3a300d5a5b6d3e4a0 f610da10a7864765bfeb947501fc6185--6e50fdf9d07746f3a300d5a5b6d3e4a0 85d8e64d438047d39fd3d9d2be7bc78b 6e50fdf9d07746f3a300d5a5b6d3e4a0--85d8e64d438047d39fd3d9d2be7bc78b 39e3b1a2d1334601865ac8aa0c8336f4 582d2bef3a544d168089362a75970b2b RX(2.0*phi) 074593fae06343659350dd33d81cdc48--582d2bef3a544d168089362a75970b2b cc6c1059b980443193f757109f5e4de2 2 bb63c9da719f4ecca31a0eaefc55aaa9 RX(theta\u2081) 582d2bef3a544d168089362a75970b2b--bb63c9da719f4ecca31a0eaefc55aaa9 f1fd0d41917e428dad5be08966f13c89 RY(theta\u2085) bb63c9da719f4ecca31a0eaefc55aaa9--f1fd0d41917e428dad5be08966f13c89 b20ac303c18c4e7da3eff86abe8962b9 RX(theta\u2089) f1fd0d41917e428dad5be08966f13c89--b20ac303c18c4e7da3eff86abe8962b9 cf39a4b11e8f45f8af1d864834dae3ed X b20ac303c18c4e7da3eff86abe8962b9--cf39a4b11e8f45f8af1d864834dae3ed cf39a4b11e8f45f8af1d864834dae3ed--4b1f8e6ca2f444d6bd5d338286279898 d898ac6d77db4d74b130050a2a9a42ba cf39a4b11e8f45f8af1d864834dae3ed--d898ac6d77db4d74b130050a2a9a42ba 276b933af3b1437b81c103ab316878f5 RX(theta\u2081\u2083) d898ac6d77db4d74b130050a2a9a42ba--276b933af3b1437b81c103ab316878f5 3fed8cb00cc747009a00fd42aee4d1ee RY(theta\u2081\u2087) 276b933af3b1437b81c103ab316878f5--3fed8cb00cc747009a00fd42aee4d1ee 806c054d3cb24d9cb22a04899620f97f RX(theta\u2082\u2081) 3fed8cb00cc747009a00fd42aee4d1ee--806c054d3cb24d9cb22a04899620f97f 55a79291603149a992b169de128b3e5a X 806c054d3cb24d9cb22a04899620f97f--55a79291603149a992b169de128b3e5a 55a79291603149a992b169de128b3e5a--f610da10a7864765bfeb947501fc6185 398c7a3ffce1475080f2537e145d1715 55a79291603149a992b169de128b3e5a--398c7a3ffce1475080f2537e145d1715 398c7a3ffce1475080f2537e145d1715--39e3b1a2d1334601865ac8aa0c8336f4 05921120d4a34465af5d77d9ee19dd6b 1aeb8fcc270d4070845f445f11265b6c RX(3.0*phi) cc6c1059b980443193f757109f5e4de2--1aeb8fcc270d4070845f445f11265b6c 9515094370104c3ab476ada819381428 3 8671edbafd3546ff881f9e521512b392 RX(theta\u2082) 1aeb8fcc270d4070845f445f11265b6c--8671edbafd3546ff881f9e521512b392 9ae5cf9abd6c4e51ba07ccbc32d80f08 RY(theta\u2086) 8671edbafd3546ff881f9e521512b392--9ae5cf9abd6c4e51ba07ccbc32d80f08 332ddb509092401fb8165f46ab202d13 RX(theta\u2081\u2080) 9ae5cf9abd6c4e51ba07ccbc32d80f08--332ddb509092401fb8165f46ab202d13 9b780566c9754c63883a615f623dcc88 332ddb509092401fb8165f46ab202d13--9b780566c9754c63883a615f623dcc88 d8eab49fcd6441e2be6bbdf233aca203 X 9b780566c9754c63883a615f623dcc88--d8eab49fcd6441e2be6bbdf233aca203 d8eab49fcd6441e2be6bbdf233aca203--d898ac6d77db4d74b130050a2a9a42ba 958388da51524847b41b85fc8a906ed5 RX(theta\u2081\u2084) d8eab49fcd6441e2be6bbdf233aca203--958388da51524847b41b85fc8a906ed5 f1c39882d9bf4b06a35b2473299a2e0b RY(theta\u2081\u2088) 958388da51524847b41b85fc8a906ed5--f1c39882d9bf4b06a35b2473299a2e0b 5025a4781c74464d897ea5db8d900ea7 RX(theta\u2082\u2082) f1c39882d9bf4b06a35b2473299a2e0b--5025a4781c74464d897ea5db8d900ea7 53a62d4f27b74caabadbe7cf725b8f28 5025a4781c74464d897ea5db8d900ea7--53a62d4f27b74caabadbe7cf725b8f28 fe63cd10dff74ece9b140c21ec1e0ffb X 53a62d4f27b74caabadbe7cf725b8f28--fe63cd10dff74ece9b140c21ec1e0ffb fe63cd10dff74ece9b140c21ec1e0ffb--398c7a3ffce1475080f2537e145d1715 fe63cd10dff74ece9b140c21ec1e0ffb--05921120d4a34465af5d77d9ee19dd6b d78b4affcff94ba694234a489a4fbf16 e3bb7f8a88474e6fba99025c132f40a6 RX(4.0*phi) 9515094370104c3ab476ada819381428--e3bb7f8a88474e6fba99025c132f40a6 bf1baf07714a4658bca376a37967a441 RX(theta\u2083) e3bb7f8a88474e6fba99025c132f40a6--bf1baf07714a4658bca376a37967a441 164a4f11b3154ca6865e281c4485c02b RY(theta\u2087) bf1baf07714a4658bca376a37967a441--164a4f11b3154ca6865e281c4485c02b 5fa4c93a5f5846c192153215e0e39c05 RX(theta\u2081\u2081) 164a4f11b3154ca6865e281c4485c02b--5fa4c93a5f5846c192153215e0e39c05 b5bbd4de06f34661aaf77fee968c719a X 5fa4c93a5f5846c192153215e0e39c05--b5bbd4de06f34661aaf77fee968c719a b5bbd4de06f34661aaf77fee968c719a--9b780566c9754c63883a615f623dcc88 5d3b3564e13042feba9cd4cc1a0bb238 b5bbd4de06f34661aaf77fee968c719a--5d3b3564e13042feba9cd4cc1a0bb238 533bbfd2920e4b1db8d3f344c5d305c9 RX(theta\u2081\u2085) 5d3b3564e13042feba9cd4cc1a0bb238--533bbfd2920e4b1db8d3f344c5d305c9 32d2ca71f7c34fed93900e08c83f826a RY(theta\u2081\u2089) 533bbfd2920e4b1db8d3f344c5d305c9--32d2ca71f7c34fed93900e08c83f826a 16891dcd73e34221b90e05954532ae1b RX(theta\u2082\u2083) 32d2ca71f7c34fed93900e08c83f826a--16891dcd73e34221b90e05954532ae1b ba976ae6cfe54e5b929766a8bcb6aad0 X 16891dcd73e34221b90e05954532ae1b--ba976ae6cfe54e5b929766a8bcb6aad0 ba976ae6cfe54e5b929766a8bcb6aad0--53a62d4f27b74caabadbe7cf725b8f28 17f4a43082c648cc95d42a39dcad017c ba976ae6cfe54e5b929766a8bcb6aad0--17f4a43082c648cc95d42a39dcad017c 17f4a43082c648cc95d42a39dcad017c--d78b4affcff94ba694234a489a4fbf16 <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_55afc44db53d4cb68617418878076766 Obs. cluster_1742bdade07a462fbb463cc40a3bab60 cluster_b22a8292d0dd414890ebf008bda12ab1 HEA e0b6919dbb984c879bb9c8fbae65bba7 0 63a7aaa51b3f4369bc292a306420b7e7 RX(theta\u2080) e0b6919dbb984c879bb9c8fbae65bba7--63a7aaa51b3f4369bc292a306420b7e7 11be69dbe54e43b681f45a393f185172 1 bc08aba2fa144ba4a1a54b2c5c2b9c5b RY(theta\u2083) 63a7aaa51b3f4369bc292a306420b7e7--bc08aba2fa144ba4a1a54b2c5c2b9c5b 0c925e97cffe4139af2d083f9743b1e3 RX(theta\u2086) bc08aba2fa144ba4a1a54b2c5c2b9c5b--0c925e97cffe4139af2d083f9743b1e3 4bdd642f348541fe8900ee52543fc5a9 0c925e97cffe4139af2d083f9743b1e3--4bdd642f348541fe8900ee52543fc5a9 1e751b86f8c74e6e8b4346e3e76884d3 4bdd642f348541fe8900ee52543fc5a9--1e751b86f8c74e6e8b4346e3e76884d3 edd7a55dab234746a01f9313ce44062d RX(theta\u2089) 1e751b86f8c74e6e8b4346e3e76884d3--edd7a55dab234746a01f9313ce44062d 1a65cc988a26407788a317dcff6fd044 RY(theta\u2081\u2082) edd7a55dab234746a01f9313ce44062d--1a65cc988a26407788a317dcff6fd044 84597a7febd143d982507411c1d4ecdf RX(theta\u2081\u2085) 1a65cc988a26407788a317dcff6fd044--84597a7febd143d982507411c1d4ecdf 3f9449ec74324513ba951cf381316d2c 84597a7febd143d982507411c1d4ecdf--3f9449ec74324513ba951cf381316d2c be94a1ff532b4ab7b16925f14b86e7bb 3f9449ec74324513ba951cf381316d2c--be94a1ff532b4ab7b16925f14b86e7bb a07470e54bc143138d53095cd780a5d9 be94a1ff532b4ab7b16925f14b86e7bb--a07470e54bc143138d53095cd780a5d9 32b5130f8ac640e8b17ab6e3c67fbd90 a07470e54bc143138d53095cd780a5d9--32b5130f8ac640e8b17ab6e3c67fbd90 f2e0f549bca14e2096bdce93e264e991 a123bfe69c394b7eb89c8338ace9b131 RX(theta\u2081) 11be69dbe54e43b681f45a393f185172--a123bfe69c394b7eb89c8338ace9b131 4281addfebd54dac8c26404346148265 2 7b7c7364c1594d01a25632174e67ac46 RY(theta\u2084) a123bfe69c394b7eb89c8338ace9b131--7b7c7364c1594d01a25632174e67ac46 16a15e695b4743c3a8212d479302bea7 RX(theta\u2087) 7b7c7364c1594d01a25632174e67ac46--16a15e695b4743c3a8212d479302bea7 b6e259c913264f1e8964ee416e4bb9af X 16a15e695b4743c3a8212d479302bea7--b6e259c913264f1e8964ee416e4bb9af b6e259c913264f1e8964ee416e4bb9af--4bdd642f348541fe8900ee52543fc5a9 519a5ceaa31249f585e9efa08e18a5d2 b6e259c913264f1e8964ee416e4bb9af--519a5ceaa31249f585e9efa08e18a5d2 eb127045773248f3946499920dc3f1be RX(theta\u2081\u2080) 519a5ceaa31249f585e9efa08e18a5d2--eb127045773248f3946499920dc3f1be fbb676dd2bbe47449950c544ca37d85e RY(theta\u2081\u2083) eb127045773248f3946499920dc3f1be--fbb676dd2bbe47449950c544ca37d85e 6a760cb0f5664613bdfbce30bac16b2a RX(theta\u2081\u2086) fbb676dd2bbe47449950c544ca37d85e--6a760cb0f5664613bdfbce30bac16b2a b1e8237a7cd544b5b5e44c57d9b3be4d X 6a760cb0f5664613bdfbce30bac16b2a--b1e8237a7cd544b5b5e44c57d9b3be4d b1e8237a7cd544b5b5e44c57d9b3be4d--3f9449ec74324513ba951cf381316d2c 0789ce1059a84a72a80cdada499c9922 b1e8237a7cd544b5b5e44c57d9b3be4d--0789ce1059a84a72a80cdada499c9922 2f276a0e08b241cabfb126f9d61372e0 AddBlock 0789ce1059a84a72a80cdada499c9922--2f276a0e08b241cabfb126f9d61372e0 2f276a0e08b241cabfb126f9d61372e0--f2e0f549bca14e2096bdce93e264e991 f73bdc39bce54673b284002da557f5ba da1cca91720549d4a5d2928b3279be7b RX(theta\u2082) 4281addfebd54dac8c26404346148265--da1cca91720549d4a5d2928b3279be7b baac607f7bbd41d2982ab92dfe8bb6bb RY(theta\u2085) da1cca91720549d4a5d2928b3279be7b--baac607f7bbd41d2982ab92dfe8bb6bb 0c35e25ef65140f8a548f266252f4279 RX(theta\u2088) baac607f7bbd41d2982ab92dfe8bb6bb--0c35e25ef65140f8a548f266252f4279 336c900eb27549d68e8e99a547c7a8dc 0c35e25ef65140f8a548f266252f4279--336c900eb27549d68e8e99a547c7a8dc 21fb4da97a3b484383a16faa04d57962 X 336c900eb27549d68e8e99a547c7a8dc--21fb4da97a3b484383a16faa04d57962 21fb4da97a3b484383a16faa04d57962--519a5ceaa31249f585e9efa08e18a5d2 9fd330ed9c7d45a3b6536075ebce8489 RX(theta\u2081\u2081) 21fb4da97a3b484383a16faa04d57962--9fd330ed9c7d45a3b6536075ebce8489 3e623cc99f034b069ebbf0d349ebe8af RY(theta\u2081\u2084) 9fd330ed9c7d45a3b6536075ebce8489--3e623cc99f034b069ebbf0d349ebe8af b874d23bacf2416496d7f86fadcb43a1 RX(theta\u2081\u2087) 3e623cc99f034b069ebbf0d349ebe8af--b874d23bacf2416496d7f86fadcb43a1 dd52b74a96be46b69e93fb3df1d051d4 b874d23bacf2416496d7f86fadcb43a1--dd52b74a96be46b69e93fb3df1d051d4 733fa8a29bbd4b2ebe5355421af42fec X dd52b74a96be46b69e93fb3df1d051d4--733fa8a29bbd4b2ebe5355421af42fec 733fa8a29bbd4b2ebe5355421af42fec--0789ce1059a84a72a80cdada499c9922 37424ce9dfba45b2a6111dcab4fba040 733fa8a29bbd4b2ebe5355421af42fec--37424ce9dfba45b2a6111dcab4fba040 37424ce9dfba45b2a6111dcab4fba040--f73bdc39bce54673b284002da557f5ba <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 aefe77f8b20d48ec84ca93ee58d0bc80 0 3d71a28085fc4c03a938357825743203 aefe77f8b20d48ec84ca93ee58d0bc80--3d71a28085fc4c03a938357825743203 134810b174604cfcbcdb044734962717 1 c4f244ea942a4d528d3b45884ed5d8ae 5db7679e641b48d296ec19691cc77c84 3d71a28085fc4c03a938357825743203--5db7679e641b48d296ec19691cc77c84 49fef1acfe1d4b07ac64aaaa53365de0 c4f244ea942a4d528d3b45884ed5d8ae--49fef1acfe1d4b07ac64aaaa53365de0 4b0771c9a67d4ada8054a0b29d3c42df 37e22e19afe34e079a43c3b762d353c0 49fef1acfe1d4b07ac64aaaa53365de0--37e22e19afe34e079a43c3b762d353c0 6db05ecb07f84fcdaf2ea994848d3927 4b0771c9a67d4ada8054a0b29d3c42df--6db05ecb07f84fcdaf2ea994848d3927 0f13609784d041829a60dd9b9b47384f ca570a1f2c3f4da6835e1555ab5942de 134810b174604cfcbcdb044734962717--ca570a1f2c3f4da6835e1555ab5942de 96c1d87255884b549120204c112737f6 2 ca570a1f2c3f4da6835e1555ab5942de--c4f244ea942a4d528d3b45884ed5d8ae 2b68ce2469044d4780e286d5bb54100a 5db7679e641b48d296ec19691cc77c84--2b68ce2469044d4780e286d5bb54100a 4f073491ba6c4337b932d0c387232c11 2b68ce2469044d4780e286d5bb54100a--4f073491ba6c4337b932d0c387232c11 4f073491ba6c4337b932d0c387232c11--0f13609784d041829a60dd9b9b47384f 5ea8c5d18e24440da729bdb5aa1e0acb 12134014d52846d98a35237d08ef6095 96c1d87255884b549120204c112737f6--12134014d52846d98a35237d08ef6095 93c302cc6fb5481aa2d2fc77864213f0 3 c444a6e1cdb4415c883d21b2b466d1db 12134014d52846d98a35237d08ef6095--c444a6e1cdb4415c883d21b2b466d1db 8e1844eecf3646c7b3549406670ddd55 c444a6e1cdb4415c883d21b2b466d1db--8e1844eecf3646c7b3549406670ddd55 d8f1e4ed87cf4e968b3f2ee0e0cd2c46 8e1844eecf3646c7b3549406670ddd55--d8f1e4ed87cf4e968b3f2ee0e0cd2c46 d8f1e4ed87cf4e968b3f2ee0e0cd2c46--5ea8c5d18e24440da729bdb5aa1e0acb 3e58195d61df49dca63a46df7f22af55 bde545d5a25242e9b2081342cec51538 93c302cc6fb5481aa2d2fc77864213f0--bde545d5a25242e9b2081342cec51538 eaaa690134f44b34a94bf69846da5f6e bde545d5a25242e9b2081342cec51538--eaaa690134f44b34a94bf69846da5f6e fd0a2c5c89c64d9aba5df35c912826e5 eaaa690134f44b34a94bf69846da5f6e--fd0a2c5c89c64d9aba5df35c912826e5 fd0a2c5c89c64d9aba5df35c912826e5--4b0771c9a67d4ada8054a0b29d3c42df 37e22e19afe34e079a43c3b762d353c0--3e58195d61df49dca63a46df7f22af55 <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 d62e4dadbe7f400e94553ef7ed4c341a 0 162cb0d7b4d344f483528377ea8f14e5 d62e4dadbe7f400e94553ef7ed4c341a--162cb0d7b4d344f483528377ea8f14e5 c40b313394e74b0c9a71cd0013544c51 1 823ecf7f6bb048039f4022d7a6609319 162cb0d7b4d344f483528377ea8f14e5--823ecf7f6bb048039f4022d7a6609319 68159acccfd44aa8b2ca0a1fff825ee7 823ecf7f6bb048039f4022d7a6609319--68159acccfd44aa8b2ca0a1fff825ee7 cdb01d8e675347a1bb6a3e682f71fa6d 68159acccfd44aa8b2ca0a1fff825ee7--cdb01d8e675347a1bb6a3e682f71fa6d a027042f98624bf4a1f90c106afb4d9b 1786ec8c3d884afbb81e8043ec07b4b3 PHASE(0.5) c40b313394e74b0c9a71cd0013544c51--1786ec8c3d884afbb81e8043ec07b4b3 b6361e62e0fb4d9ab2adf6f4cdda9233 2 1786ec8c3d884afbb81e8043ec07b4b3--162cb0d7b4d344f483528377ea8f14e5 34fb9e7f73964ed1bedac1ffc46ed695 1786ec8c3d884afbb81e8043ec07b4b3--34fb9e7f73964ed1bedac1ffc46ed695 9680b586a1b04d4eae02943861096eb9 34fb9e7f73964ed1bedac1ffc46ed695--9680b586a1b04d4eae02943861096eb9 9680b586a1b04d4eae02943861096eb9--a027042f98624bf4a1f90c106afb4d9b d162396233f241cabc9c1732e60cab01 d46aa1f2ec454e1894c56cc452111b8f b6361e62e0fb4d9ab2adf6f4cdda9233--d46aa1f2ec454e1894c56cc452111b8f b02b6945fde7471fb8f07b4a7c66c38e 3 216e03f766cb4405a91ca80d29c3da83 PHASE(0.5) d46aa1f2ec454e1894c56cc452111b8f--216e03f766cb4405a91ca80d29c3da83 216e03f766cb4405a91ca80d29c3da83--823ecf7f6bb048039f4022d7a6609319 7fbd63ae9142441db82d3add4644534d 216e03f766cb4405a91ca80d29c3da83--7fbd63ae9142441db82d3add4644534d 7fbd63ae9142441db82d3add4644534d--d162396233f241cabc9c1732e60cab01 4bb3f76c492f41109df6ad7c80ae4f3f a3c69e2e50a141f59da8cb72d5075913 b02b6945fde7471fb8f07b4a7c66c38e--a3c69e2e50a141f59da8cb72d5075913 264e33b1a7614fca8e3ac5e29f3a61bf a3c69e2e50a141f59da8cb72d5075913--264e33b1a7614fca8e3ac5e29f3a61bf d7d7e7f835ff4facb68bc4f37184fc12 PHASE(0.5) 264e33b1a7614fca8e3ac5e29f3a61bf--d7d7e7f835ff4facb68bc4f37184fc12 d7d7e7f835ff4facb68bc4f37184fc12--68159acccfd44aa8b2ca0a1fff825ee7 d7d7e7f835ff4facb68bc4f37184fc12--4bb3f76c492f41109df6ad7c80ae4f3f"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from qadence import AnalogRot, PI\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = PI, # [rad/\u03bcs]\n    delta = PI, # [rad/\u03bcs]\n    phase = PI, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run, PI\nfrom qadence.analog.constants import C6_DICT\nfrom math import cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = PI\ndelta = PI\nphase = PI\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run, PI\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = PI\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>AnalogInteraction</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, AnalogInteraction, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = AnalogInteraction(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction, PI\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * PI * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * PI * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice, PI\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = PI)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>AnalogInteraction</code> operation initializes an <code>InteractionBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = QubitSupportType.GLOBAL</code>. However, composing blocks using <code>kron</code> with local qubit supports and different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, AnalogInteraction\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    AnalogInteraction(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    AnalogInteraction(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    AnalogInteraction(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2024-01-17T18:15:53.157845 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook, we solve a quadratic unconstrained binary optimization (QUBO) problem with Qadence. QUBOs are very popular combinatorial optimization problems with a wide range of applications. Here, we solve the problem using the QAOA <sup>1</sup> variational algorithm by embedding the QUBO problem weights onto a register as standard for neutral atom quantum devices.</p> <p>Additional background information on QUBOs can be found here, directly solved using the pulse-level interface Pulser.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: optimal register coordinates for embedding the QUBO problem <p>A basic ingredient for solving a QUBO problem with a neutral atom device is to embed the problem onto the atomic register. In short, embedding algorithms cast the problem onto a graph mapped onto the register by optimally finding atomic coordinates. A discussion on the embedding algorithms is beyond the scope of this tutorial and a simplified version taken from here is added below.</p> <p><pre><code>import numpy as np\nimport numpy.typing as npt\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom qadence import RydbergDevice\n\ndef qubo_register_coords(Q: np.ndarray, device: RydbergDevice) -&gt; list:\n    \"\"\"Compute coordinates for register.\"\"\"\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        interaction_coeff = device.rydberg_level\n        new_Q = squareform(interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <p>With the embedding routine under our belt, let's start by adding the required imports and ensure the reproducibility of this tutorial.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRX, AnalogRZ, chain\nfrom qadence.ml_tools import train_gradient_free, TrainConfig, num_parameters\nimport nevergrad as ng\nimport matplotlib.pyplot as plt\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted edges and a cost function to be optimized. The weighted edges are represented by a real-valued symmetric matrix <code>Q</code> which is used throughout the tutorial.</p> <pre><code># QUBO problem weights (real-value symmetric matrix)\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n\ndef loss(model: QuantumModel, *args) -&gt; tuple[float, dict]:\n    to_arr_fn = lambda bitstring: np.array(list(bitstring), dtype=int)\n    cost_fn = lambda arr: arr.T @ Q @ arr\n    samples = model.sample({}, n_shots=1000)[0]  # extract samples\n    cost_fn = sum(samples[key] * cost_fn(to_arr_fn(key)) for key in samples)\n    return cost_fn / sum(samples.values()), {}  # We return an optional metrics dict\n</code></pre> <p>The QAOA algorithm needs a variational quantum circuit with optimizable parameters. For that purpose, we use a fully analog circuit composed of two global rotations per layer on different axes of the Bloch sphere. The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian <sup>1</sup>. In this setting, the embedding is realized by the appropriate register coordinates and the resulting qubit interaction.</p> Rydberg level <p>The Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in the original tutorial, and set the device specifications with the updated Rydberg level.</p> <pre><code># Device specification and atomic register\ndevice = RydbergDevice(rydberg_level=70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q, device), device_specs=device\n)\n\n# Analog variational quantum circuit\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\ncircuit = QuantumCircuit(reg, block)\n</code></pre> <pre><code>\n</code></pre> <p>By feeding the circuit to a <code>QuantumModel</code> we can check the initial counts where no clear solution can be found:</p> <pre><code>model = QuantumModel(circuit)\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'01000': 197, '00001': 193, '00010': 189, '00100': 174, '10000': 169, '00000': 78})\n</code></pre> <p>Finally, we can proceed with the variational optimization. The cost function defined above is derived from bitstring computations and therefore non differentiable. We use Qadence ML facilities to run gradient-free optimizations using the <code>nevergrad</code> library.</p> <pre><code>config = TrainConfig(max_iter=100)\noptimizer = ng.optimizers.NGOpt(\n    budget=config.max_iter, parametrization=num_parameters(model)\n)\ntrain_gradient_free(model, None, optimizer, config, loss)\n\noptimal_counts = model.sample({}, n_shots=1000)[0]\n</code></pre>   optimal_count = Counter({'00100': 191, '10000': 190, '00001': 183, '01000': 181, '00010': 163, '00000': 92})    <p>Finally, let's plot the solution. The expected bitstrings are marked in red.</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings = [\"01011\", \"00111\"]\n\ndef plot_distribution(C, ax, title):\n    C = dict(sorted(C.items(), key=lambda item: item[1], reverse=True))\n    indexes = solution_bitstrings # QUBO solutions\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in C}\n    ax.set_xlabel(\"bitstrings\")\n    ax.set_ylabel(\"counts\")\n    ax.set_xticks([i for i in range(len(C.keys()))], C.keys(), rotation=90)\n    ax.bar(list(C.keys())[:20], list(C.values())[:20])\n    ax.set_title(title)\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 4))\nplot_distribution(initial_counts, axs[0], \"Initial counts\")\nplot_distribution(optimal_counts, axs[1], \"Optimal counts\")\n</code></pre> 2024-01-17T18:15:54.939937 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/#references","title":"References","text":"<ol> <li> <p>Edward Farhi, Jeffrey Goldstone, Sam Gutmann, A Quantum Approximate Optimization Algorithm, arXiv:1411.4028 (2014) \u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo, PI\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = PI\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=PI,            # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_a9f3f3a5e87f4688a6279f23c8e07afc cluster_c53acfaa35524e43a98cb5f35e95604e cluster_e037ff00a7bc41a9a1c1eca4be55fc78 cluster_c7c0b7aa248b4dc1819870af3ad26715 cluster_5295a5cb25d6428e9f321ee49fd75ec0 cluster_24b2c41399714cd6b2319ffa7775bdf7 cluster_66fd441447b144bdb9e1a133c6cced2e 7767da4e75ba49378390e8aa52cea501 0 70ecc6ba00544c61b4398fccda770e13 HamEvo 7767da4e75ba49378390e8aa52cea501--70ecc6ba00544c61b4398fccda770e13 f2479f1ed3d444ef91df4086eeed1596 1 5762464a975b442bb89b2b83c933a336 HamEvo 70ecc6ba00544c61b4398fccda770e13--5762464a975b442bb89b2b83c933a336 e88452cc057747df825e9e152573b57e HamEvo 5762464a975b442bb89b2b83c933a336--e88452cc057747df825e9e152573b57e b286d5c21eac41dda6415ff044caca5d X e88452cc057747df825e9e152573b57e--b286d5c21eac41dda6415ff044caca5d d5cd4c12e0e84c92977a34125057414d HamEvo b286d5c21eac41dda6415ff044caca5d--d5cd4c12e0e84c92977a34125057414d 773f4ffce88646f39bccfbcfceb9b788 HamEvo d5cd4c12e0e84c92977a34125057414d--773f4ffce88646f39bccfbcfceb9b788 9e01d4e416d24a7ca5c0e5210acc2d08 X 773f4ffce88646f39bccfbcfceb9b788--9e01d4e416d24a7ca5c0e5210acc2d08 cb379b81dac1431397d33626fc64c973 9e01d4e416d24a7ca5c0e5210acc2d08--cb379b81dac1431397d33626fc64c973 9d038401812540c29e1a1017179a39c9 HamEvo cb379b81dac1431397d33626fc64c973--9d038401812540c29e1a1017179a39c9 eebd24168e094e9cb63bb071abfdfa91 HamEvo 9d038401812540c29e1a1017179a39c9--eebd24168e094e9cb63bb071abfdfa91 77db9f2c53e64050ad6120ff878249ea eebd24168e094e9cb63bb071abfdfa91--77db9f2c53e64050ad6120ff878249ea 59188c616b4f4b9caa16980a0b5d9ac4 77db9f2c53e64050ad6120ff878249ea--59188c616b4f4b9caa16980a0b5d9ac4 6cca18e6c58c4ff29ea2166ff8b03a5d 23e3da830d9c4a91a4a440519d648872 t = -3.142 f2479f1ed3d444ef91df4086eeed1596--23e3da830d9c4a91a4a440519d648872 2e45471a915349498c9542d898c018ec 2 4219a7ccf4e846648a22133076c9d8ed t = 3.142 23e3da830d9c4a91a4a440519d648872--4219a7ccf4e846648a22133076c9d8ed 63c139a716e1438a8c916f8386bcdad9 t = -3.142 4219a7ccf4e846648a22133076c9d8ed--63c139a716e1438a8c916f8386bcdad9 a317d3e24fac4935aae3813c95a481c2 63c139a716e1438a8c916f8386bcdad9--a317d3e24fac4935aae3813c95a481c2 f508383fb6cd4ff6a3911e8beda60a8d t = 1.571 a317d3e24fac4935aae3813c95a481c2--f508383fb6cd4ff6a3911e8beda60a8d 71582ea505c042a3ab92883cdfa74e69 t = 1.571 f508383fb6cd4ff6a3911e8beda60a8d--71582ea505c042a3ab92883cdfa74e69 6ae4e68d4b424136bbf70d043744466f 71582ea505c042a3ab92883cdfa74e69--6ae4e68d4b424136bbf70d043744466f 2e4741e04dc34ecfbd5ed5c56c58e068 X 6ae4e68d4b424136bbf70d043744466f--2e4741e04dc34ecfbd5ed5c56c58e068 3120079ed9034d859b77c9549923605a t = 1.571 2e4741e04dc34ecfbd5ed5c56c58e068--3120079ed9034d859b77c9549923605a 72aaf13dff5c4a58b170ee558ff0904d t = 1.571 3120079ed9034d859b77c9549923605a--72aaf13dff5c4a58b170ee558ff0904d 8d54e593b6074034a6f6ef84aa9370c4 X 72aaf13dff5c4a58b170ee558ff0904d--8d54e593b6074034a6f6ef84aa9370c4 8d54e593b6074034a6f6ef84aa9370c4--6cca18e6c58c4ff29ea2166ff8b03a5d 4d7d12a66cd84373bd35e183b9c8ca4c ad96b633ad0a428fb4e2f31e0fcff6c8 2e45471a915349498c9542d898c018ec--ad96b633ad0a428fb4e2f31e0fcff6c8 0f9ba027c6ad4146b507c1029089c9ed ad96b633ad0a428fb4e2f31e0fcff6c8--0f9ba027c6ad4146b507c1029089c9ed 93c9714ec91c4b499697c26f3b5dcd3f 0f9ba027c6ad4146b507c1029089c9ed--93c9714ec91c4b499697c26f3b5dcd3f 325c507d11434a559303eed4cd078ed9 X 93c9714ec91c4b499697c26f3b5dcd3f--325c507d11434a559303eed4cd078ed9 375e09acde81439b97bdf0cff582e6a5 325c507d11434a559303eed4cd078ed9--375e09acde81439b97bdf0cff582e6a5 7c2210f6057b49459cd443c50c12effa 375e09acde81439b97bdf0cff582e6a5--7c2210f6057b49459cd443c50c12effa eac36e0476154aadb533548207863f5e X 7c2210f6057b49459cd443c50c12effa--eac36e0476154aadb533548207863f5e 71b3b0038c724e38a504ef7f53154fc5 X eac36e0476154aadb533548207863f5e--71b3b0038c724e38a504ef7f53154fc5 e42ac9997712492984fe654f746bdd23 71b3b0038c724e38a504ef7f53154fc5--e42ac9997712492984fe654f746bdd23 67b43874cf7242a2a4fe71fb5e10b75e e42ac9997712492984fe654f746bdd23--67b43874cf7242a2a4fe71fb5e10b75e d124723517db4e58b0c208c50429ca11 X 67b43874cf7242a2a4fe71fb5e10b75e--d124723517db4e58b0c208c50429ca11 d124723517db4e58b0c208c50429ca11--4d7d12a66cd84373bd35e183b9c8ca4c <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_93859e33028e458db1c5901434f8b077 cluster_b0d9d91b4cdf4b1b94bccf5950f1b3e9 1a3ed4a609dd4cbba68d28eefab3d62e 0 6429553c8783426aace378c2c1862a54 X 1a3ed4a609dd4cbba68d28eefab3d62e--6429553c8783426aace378c2c1862a54 2e5662c6c625415bb4c06781d4d13ce4 1 3ca9505c2d9444a08ee2a92bfde6081b HamEvo 6429553c8783426aace378c2c1862a54--3ca9505c2d9444a08ee2a92bfde6081b 67c52cdb33364fcf9117f102a27a8500 X 3ca9505c2d9444a08ee2a92bfde6081b--67c52cdb33364fcf9117f102a27a8500 0910dd6804c048ad8ec880e9ea642d45 67c52cdb33364fcf9117f102a27a8500--0910dd6804c048ad8ec880e9ea642d45 35f35be477654f3e9a5b65de329c083a HamEvo 0910dd6804c048ad8ec880e9ea642d45--35f35be477654f3e9a5b65de329c083a 70f95eb0b7f842ad92e3263d132a1965 35f35be477654f3e9a5b65de329c083a--70f95eb0b7f842ad92e3263d132a1965 e15a385e92d14a03a2de36326ac1528f 70f95eb0b7f842ad92e3263d132a1965--e15a385e92d14a03a2de36326ac1528f 3abb91810b8a48adb92e24753f856a7e 5f611637500840fd829443d8a106da2a 2e5662c6c625415bb4c06781d4d13ce4--5f611637500840fd829443d8a106da2a 58728d393b964ae3b16b3aa06bec87b9 2 6ba798b32d264cc289646f0f6e5946b3 t = -0.500 5f611637500840fd829443d8a106da2a--6ba798b32d264cc289646f0f6e5946b3 c47750343d6e49b2a7778bdf1293f1e5 6ba798b32d264cc289646f0f6e5946b3--c47750343d6e49b2a7778bdf1293f1e5 41715ee1368e4ce3b5fd5e3909b35c4c X c47750343d6e49b2a7778bdf1293f1e5--41715ee1368e4ce3b5fd5e3909b35c4c 9e3df3ee5df54b87afcf7706ac5a6049 t = -0.500 41715ee1368e4ce3b5fd5e3909b35c4c--9e3df3ee5df54b87afcf7706ac5a6049 146973bd25984d02bf8a8c16b71ffed5 X 9e3df3ee5df54b87afcf7706ac5a6049--146973bd25984d02bf8a8c16b71ffed5 146973bd25984d02bf8a8c16b71ffed5--3abb91810b8a48adb92e24753f856a7e 73d169ae65a9459f9abd7f61ce2f8202 8faac5354a134ca795bc61437e4f5b96 X 58728d393b964ae3b16b3aa06bec87b9--8faac5354a134ca795bc61437e4f5b96 0e775dfc3a2c41a483cf6b688a95b6b5 8faac5354a134ca795bc61437e4f5b96--0e775dfc3a2c41a483cf6b688a95b6b5 3ba5af293bc345db9c33ef59c3c5412b X 0e775dfc3a2c41a483cf6b688a95b6b5--3ba5af293bc345db9c33ef59c3c5412b 4ffb3ff6b8404042ac258de696560c4a X 3ba5af293bc345db9c33ef59c3c5412b--4ffb3ff6b8404042ac258de696560c4a 5bd9c569ad7a42e6bc9e45ee54393c12 4ffb3ff6b8404042ac258de696560c4a--5bd9c569ad7a42e6bc9e45ee54393c12 8cbc97d747094f679e8655d91b855b82 X 5bd9c569ad7a42e6bc9e45ee54393c12--8cbc97d747094f679e8655d91b855b82 8cbc97d747094f679e8655d91b855b82--73d169ae65a9459f9abd7f61ce2f8202 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_987056f94bce4b3a9b994cc6b37c23b3 cluster_fc4ae28bb898429c9543ff75f36876db f315dc06754c4432a8252bf1c807292a 0 75452384fc00495f9a736d0682a3fc19 X f315dc06754c4432a8252bf1c807292a--75452384fc00495f9a736d0682a3fc19 e5247a08af7640008300c17fd9559097 1 5891660be0a343a884da5d893c870c1f HamEvo 75452384fc00495f9a736d0682a3fc19--5891660be0a343a884da5d893c870c1f 89e198b26e154036bf09132a6b8df7a1 X 5891660be0a343a884da5d893c870c1f--89e198b26e154036bf09132a6b8df7a1 61806d913c0145aab7ca2d70293f3e7b 89e198b26e154036bf09132a6b8df7a1--61806d913c0145aab7ca2d70293f3e7b b3184ae39baa4a4b85f38d7d787cd549 HamEvo 61806d913c0145aab7ca2d70293f3e7b--b3184ae39baa4a4b85f38d7d787cd549 aacc0fceecea40ea922da78ad2b0e0a8 b3184ae39baa4a4b85f38d7d787cd549--aacc0fceecea40ea922da78ad2b0e0a8 d9549c0b3ce34161b05ee476df2a8a2f aacc0fceecea40ea922da78ad2b0e0a8--d9549c0b3ce34161b05ee476df2a8a2f 7fc3a7ba0edb473fab5fedd8a70dd34e 926d4b4c9dc54184b60f9de256817f58 e5247a08af7640008300c17fd9559097--926d4b4c9dc54184b60f9de256817f58 3981f979336e4dbea0038080f6cb5646 2 33387b9c96b34a6ea9cd46ac9d13ddc1 t = -500.000000000000 926d4b4c9dc54184b60f9de256817f58--33387b9c96b34a6ea9cd46ac9d13ddc1 bbfe5a93b81f4b7593ef92640ce7af7d 33387b9c96b34a6ea9cd46ac9d13ddc1--bbfe5a93b81f4b7593ef92640ce7af7d 46b2584857d042518b5cb6e2f0d54244 X bbfe5a93b81f4b7593ef92640ce7af7d--46b2584857d042518b5cb6e2f0d54244 5a7fa3e70e2b4b1bb91fef60ad4dbb00 t = -500.000000000000 46b2584857d042518b5cb6e2f0d54244--5a7fa3e70e2b4b1bb91fef60ad4dbb00 8cb10678f32a4cdb936d66e63187875b X 5a7fa3e70e2b4b1bb91fef60ad4dbb00--8cb10678f32a4cdb936d66e63187875b 8cb10678f32a4cdb936d66e63187875b--7fc3a7ba0edb473fab5fedd8a70dd34e c99d2948273249989c41f9618ed8b54b e1e0eca8d8534127a3694e67b0f33ccc X 3981f979336e4dbea0038080f6cb5646--e1e0eca8d8534127a3694e67b0f33ccc 4c409ac1e796427083f67a4bdae45bc8 e1e0eca8d8534127a3694e67b0f33ccc--4c409ac1e796427083f67a4bdae45bc8 33b1c714d6d945fcb1b248d6037e1f44 X 4c409ac1e796427083f67a4bdae45bc8--33b1c714d6d945fcb1b248d6037e1f44 bb72a5b03d0f4e25b80e02c9b985f9a8 X 33b1c714d6d945fcb1b248d6037e1f44--bb72a5b03d0f4e25b80e02c9b985f9a8 dcecfdb8778943cf8a8893e8a71929ca bb72a5b03d0f4e25b80e02c9b985f9a8--dcecfdb8778943cf8a8893e8a71929ca 170e8e094aae49b09d03c77eebb3cbc3 X dcecfdb8778943cf8a8893e8a71929ca--170e8e094aae49b09d03c77eebb3cbc3 170e8e094aae49b09d03c77eebb3cbc3--c99d2948273249989c41f9618ed8b54b <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>AnalogInteraction</code> An idle block to to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.19153186677421175, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel, PI\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 30, '11': 20})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2024-01-17T18:15:55.468703 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2024-01-17T18:15:55.595405 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 21, '10': 2})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>AnalogInteraction</code> and <code>AnalogRY</code> blocks together with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, AnalogInteraction\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-PI / 2),\n        AnalogInteraction(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([PI / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2024-01-17T18:15:56.324744 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(PI/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2024-01-17T18:15:56.484688 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n    PI\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.0100])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.0106])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(PI)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.6974]) The trained function value:  tensor([[0.6974]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>InteractionBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, AnalogInteraction\n\nb = chain(AnalogInteraction(200), AnalogInteraction(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), AnalogInteraction(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `InteractionBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, AnalogInteraction\n\n    b = chain(AnalogInteraction(200), AnalogInteraction(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), AnalogInteraction(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.InteractionBlock","title":"<code>InteractionBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Free-evolution for the Hamiltonian interaction term of a register of qubits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct, use the <code>AnalogInteraction</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1205+0.2779j, -0.4028-0.5196j, -0.6412+0.0323j, -0.2348-0.0933j],\n         [-0.1532-0.2579j,  0.3364+0.4789j, -0.6311-0.0889j, -0.3710+0.1539j],\n         [-0.2295-0.6436j, -0.0058-0.3170j,  0.1553+0.2692j, -0.3819-0.4360j],\n         [-0.0921-0.5856j, -0.2621-0.2365j, -0.1598-0.2440j,  0.4385+0.4966j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * PI),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        int_fn = INTERACTION_DICT.get(interaction, None)\n        if int_fn is None:\n            raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * PI / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f8159ba8550&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f8159ba8430&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.3026, 0.2765]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n[tensor([0.6595, 0.0538, 0.8660, 0.8650, 0.0394]), tensor([0.2900, 0.3294, 0.6735, 0.3359, 0.2816]), tensor([0.4227, 0.3033, 0.5571, 0.8693, 0.4491])]\n[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run, PI\nimport torch\nhevo = HamEvo(generator=RX(0, PI), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1384-3.6270e-17j, -0.5441+1.7335e-17j],\n        [ 1.2545-5.3697e-17j, -0.7574+3.2421e-17j]])\ntensor([[1.5091-0.7780j, 0.5771-0.9542j],\n        [1.4106-0.5384j, 0.5040-0.6605j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * PI / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * PI / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-PI / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = PI\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogInteraction","title":"<code>AnalogInteraction(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Evolution of the interaction term for a register of qubits.</p> <p>Constructs a <code>InteractionBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to evolve the interaction for in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>InteractionBlock</code> is applied to. Can be either <code>\"global\"</code> to evolve the interaction block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>InteractionBlock</code> <p>a <code>InteractionBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogInteraction(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; InteractionBlock:\n    \"\"\"Evolution of the interaction term for a register of qubits.\n\n    Constructs a [`InteractionBlock`][qadence.blocks.analog.InteractionBlock].\n\n    Arguments:\n        duration: Time to evolve the interaction for in nanoseconds.\n        qubit_support: Qubits the `InteractionBlock` is applied to. Can be either\n            `\"global\"` to evolve the interaction block to all qubits or a tuple of integers.\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        a `InteractionBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return InteractionBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['b2303b8f-fb73-455f-b05d-ef24f45468dc', '107bb3fe-62b6-4d7c-af7b-85b0cf8d72cf'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.9859993654159114\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.6903893734503416\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('69d51f96-2f74-4f38-8fb5-ae25bbc382ef', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.6398639069137206'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('997f290e-d538-49eb-98cb-ff2b1803f4b2', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.4276945815961849'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('017639fc-e1d1-44a3-9a2d-370135349e10', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.8742892845567309'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('758fe1b0-5fbc-4bf8-afc6-cd04f4de3309', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.41919975377010965'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('808707f6-ac21-4f6d-8cb6-4012e614a3df', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6109177287180888'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('576805cc-961f-492c-bb0d-9a7fb36db088', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.37421788716051174'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c2bde00a-ee02-4e3c-8718-16f011982050', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9806087614373826'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7afc9a58-783e-4480-9548-e277644f523c', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1191298453974663'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5dcaa51d-af80-435f-a4a1-bb634c920dfd', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.2908857259376022'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5f2c2f33-4789-445b-82fb-d863145a8261', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.43496561975352277'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('90c9f8f2-e247-4e26-bf63-600b760ffa12', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.13952221070351867'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('d86fd7d5-e24b-42b2-adf0-f21f8a201365', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.230873635340905'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>01001100\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3881-0.1329j,  0.2745-0.3881j, -0.2080+0.2140j,  0.6633-0.2767j]])\ntensor([[0.5510-0.1474j, 0.0000+0.0000j, 0.2123+0.7935j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGINTERACTION","title":"<code>ANALOGINTERACTION = 'AnalogInteraction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog interaction operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANGLE","title":"<code>ENTANGLE = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 78, '1000': 8, '0010': 5, '0100': 4, '0001': 1, '0101': 1, '1010': 1, '1101': 1, '1110': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[-0.0018],\n        [-0.0004],\n        [ 0.0510],\n        [ 0.0049],\n        [ 0.0771],\n        [ 0.0133],\n        [-0.0328],\n        [-0.0192],\n        [ 0.0395],\n        [-0.0323]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4053],\n        [0.9018],\n        [0.9084],\n        [0.2606],\n        [0.9428]]), tensor([[0.3943],\n        [0.7844],\n        [0.7885],\n        [0.2577],\n        [0.8092]])], 'y2': [tensor([[0.4695],\n        [0.1881],\n        [0.6359],\n        [0.7454],\n        [0.2043]]), tensor([[0.4524],\n        [0.1870],\n        [0.5939],\n        [0.6783],\n        [0.2029]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2024-01-17T18:16:18.708115 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2024-01-17T18:16:19.269120 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_c62bdfd6965d44b0bbb982e978cea020 mixing cluster_e8dab0de420d417fa614d3825ad00128 cost cluster_624d241f71f043d3b9435fc980ea07dc mixing cluster_cad9e55217ba4d02b05c1ffaf1484a58 cost 97215f8f9a424a0a8805b42ec3065774 0 d190ef396a564bf6b3d479bfb8ab8970 97215f8f9a424a0a8805b42ec3065774--d190ef396a564bf6b3d479bfb8ab8970 192f514e30e24e119a54c8b3970e1af1 1 804acbec946d43cdbc1a1f89833633df d190ef396a564bf6b3d479bfb8ab8970--804acbec946d43cdbc1a1f89833633df dc12fc00f11343468ed3e0ca7c143ef2 804acbec946d43cdbc1a1f89833633df--dc12fc00f11343468ed3e0ca7c143ef2 5ddddb976e1d46a9b4de66509c6b540b dc12fc00f11343468ed3e0ca7c143ef2--5ddddb976e1d46a9b4de66509c6b540b abedce13587147f5a1d26fff4ca3fa64 5ddddb976e1d46a9b4de66509c6b540b--abedce13587147f5a1d26fff4ca3fa64 f96387755e9c40f5ba38651553012e60 abedce13587147f5a1d26fff4ca3fa64--f96387755e9c40f5ba38651553012e60 fa775988461842a3a844b792c7d0731f f96387755e9c40f5ba38651553012e60--fa775988461842a3a844b792c7d0731f feff2d53c1aa4a4188d57741d6ffadcc fa775988461842a3a844b792c7d0731f--feff2d53c1aa4a4188d57741d6ffadcc d230e9887da64680b4a9f6716689ff5b feff2d53c1aa4a4188d57741d6ffadcc--d230e9887da64680b4a9f6716689ff5b cc14f6c7109242688699e31d09bc9a77 d230e9887da64680b4a9f6716689ff5b--cc14f6c7109242688699e31d09bc9a77 3c0d3c958dc14df4bbfa5002236428f7 cc14f6c7109242688699e31d09bc9a77--3c0d3c958dc14df4bbfa5002236428f7 24a63515a4704e6592b56f4a4e209185 3c0d3c958dc14df4bbfa5002236428f7--24a63515a4704e6592b56f4a4e209185 ff7c0ecf8c9f4bea94932f47cad793b1 24a63515a4704e6592b56f4a4e209185--ff7c0ecf8c9f4bea94932f47cad793b1 b96e506d8aa34e8c8d2c9f30a4cd6a9d ff7c0ecf8c9f4bea94932f47cad793b1--b96e506d8aa34e8c8d2c9f30a4cd6a9d b03d010af558473ba3503cd32dc4d42e b96e506d8aa34e8c8d2c9f30a4cd6a9d--b03d010af558473ba3503cd32dc4d42e eefd996dbf0543069642802dd15cc67a b03d010af558473ba3503cd32dc4d42e--eefd996dbf0543069642802dd15cc67a f3a901e284d34411b1d081ca24dc5e68 eefd996dbf0543069642802dd15cc67a--f3a901e284d34411b1d081ca24dc5e68 d59c9d7c4b154e11bddd04ffd03421a2 f3a901e284d34411b1d081ca24dc5e68--d59c9d7c4b154e11bddd04ffd03421a2 191b628c28d74fb8bd636f0c489e857a d59c9d7c4b154e11bddd04ffd03421a2--191b628c28d74fb8bd636f0c489e857a 8588ce525c014fe98b8513de0820a8d8 191b628c28d74fb8bd636f0c489e857a--8588ce525c014fe98b8513de0820a8d8 8c7778be8cc34ad3abd20b9e97cbec08 8588ce525c014fe98b8513de0820a8d8--8c7778be8cc34ad3abd20b9e97cbec08 496212dab24c48adaafc9c17f0209b13 8c7778be8cc34ad3abd20b9e97cbec08--496212dab24c48adaafc9c17f0209b13 2bdebec5b53a4728a975f82a32c9a072 496212dab24c48adaafc9c17f0209b13--2bdebec5b53a4728a975f82a32c9a072 2b44fb8f71864f288e5dd6c9b1f9f663 2bdebec5b53a4728a975f82a32c9a072--2b44fb8f71864f288e5dd6c9b1f9f663 c4c57e6720024799b9d3c7fd1ccc3a80 2b44fb8f71864f288e5dd6c9b1f9f663--c4c57e6720024799b9d3c7fd1ccc3a80 8e42982402514a4588e736b54453493e c4c57e6720024799b9d3c7fd1ccc3a80--8e42982402514a4588e736b54453493e 0a663aed65e24f1ebfc58ad35978eefb 8e42982402514a4588e736b54453493e--0a663aed65e24f1ebfc58ad35978eefb f6d845c125294ed8adaa39e853b3f5bf 0a663aed65e24f1ebfc58ad35978eefb--f6d845c125294ed8adaa39e853b3f5bf 9499b71f5b3a48d9a0c5767073384dde f6d845c125294ed8adaa39e853b3f5bf--9499b71f5b3a48d9a0c5767073384dde 26cce2d9c4134b5d8c890dc10a0c3b92 9499b71f5b3a48d9a0c5767073384dde--26cce2d9c4134b5d8c890dc10a0c3b92 d066f065a1304f70b127e6fd154d8180 26cce2d9c4134b5d8c890dc10a0c3b92--d066f065a1304f70b127e6fd154d8180 c02de413ce9847d2b2c1ba298f754f26 d066f065a1304f70b127e6fd154d8180--c02de413ce9847d2b2c1ba298f754f26 ebf2e0755efb403196069c5bc6849b41 c02de413ce9847d2b2c1ba298f754f26--ebf2e0755efb403196069c5bc6849b41 76435054111747019d9f521daf7117e1 ebf2e0755efb403196069c5bc6849b41--76435054111747019d9f521daf7117e1 43bb275561394e7fb1158427804e9288 76435054111747019d9f521daf7117e1--43bb275561394e7fb1158427804e9288 948e749a54e74e2fb5ed336ea3ea7e03 43bb275561394e7fb1158427804e9288--948e749a54e74e2fb5ed336ea3ea7e03 80f4185147fe427e9f3e0760a006b809 948e749a54e74e2fb5ed336ea3ea7e03--80f4185147fe427e9f3e0760a006b809 90011a3e081042c4bfb52c873cbf34be 80f4185147fe427e9f3e0760a006b809--90011a3e081042c4bfb52c873cbf34be df552faaf66047a899098ceaf4e24362 90011a3e081042c4bfb52c873cbf34be--df552faaf66047a899098ceaf4e24362 f6007610b2e64e489315b604c1f5af05 df552faaf66047a899098ceaf4e24362--f6007610b2e64e489315b604c1f5af05 88be94ff16304f5a97ab77a8a082e39e f6007610b2e64e489315b604c1f5af05--88be94ff16304f5a97ab77a8a082e39e d13e5e1e0dc144db9f5d30ab5642d32c 88be94ff16304f5a97ab77a8a082e39e--d13e5e1e0dc144db9f5d30ab5642d32c 0fe37cb0e7d44a49a0e2648bf07ffae0 d13e5e1e0dc144db9f5d30ab5642d32c--0fe37cb0e7d44a49a0e2648bf07ffae0 9df17ad7a31648d3adc893962db968d5 0fe37cb0e7d44a49a0e2648bf07ffae0--9df17ad7a31648d3adc893962db968d5 06e77b3b6d0c4cabb56c62eed54fade0 9df17ad7a31648d3adc893962db968d5--06e77b3b6d0c4cabb56c62eed54fade0 f11b40fd70cb4684bb33c658ff0f3c50 06e77b3b6d0c4cabb56c62eed54fade0--f11b40fd70cb4684bb33c658ff0f3c50 7e19b4f52e1846f7ac6a1546af5eff53 f11b40fd70cb4684bb33c658ff0f3c50--7e19b4f52e1846f7ac6a1546af5eff53 70aa727577cf4296a26da3c1ea5a3d75 7e19b4f52e1846f7ac6a1546af5eff53--70aa727577cf4296a26da3c1ea5a3d75 3e15e89ca53d42749b7fd8ef395eae17 70aa727577cf4296a26da3c1ea5a3d75--3e15e89ca53d42749b7fd8ef395eae17 408d67ee466a4728b7d90aaa6e4063d5 3e15e89ca53d42749b7fd8ef395eae17--408d67ee466a4728b7d90aaa6e4063d5 e52c9e08a8304815bdef2bb48e38e494 408d67ee466a4728b7d90aaa6e4063d5--e52c9e08a8304815bdef2bb48e38e494 4ee2c03130c24fd48b5ce9b6f4c669bb e52c9e08a8304815bdef2bb48e38e494--4ee2c03130c24fd48b5ce9b6f4c669bb bad32b3cdd51495cacc2afd9da86a0fe 4ee2c03130c24fd48b5ce9b6f4c669bb--bad32b3cdd51495cacc2afd9da86a0fe e391aa1b37a448bd877c4fc700783e15 bad32b3cdd51495cacc2afd9da86a0fe--e391aa1b37a448bd877c4fc700783e15 4ec07560d0a7422a90a1635ffc9c532f e391aa1b37a448bd877c4fc700783e15--4ec07560d0a7422a90a1635ffc9c532f d70a5ffcebf640829d831b77bf0ea98b 4ec07560d0a7422a90a1635ffc9c532f--d70a5ffcebf640829d831b77bf0ea98b 2d3ea4b0e30a4bdd8d96ea332cab5d52 d70a5ffcebf640829d831b77bf0ea98b--2d3ea4b0e30a4bdd8d96ea332cab5d52 56dc8312c63c44f2a6d63d57807134c6 2d3ea4b0e30a4bdd8d96ea332cab5d52--56dc8312c63c44f2a6d63d57807134c6 eac082eb0f204bc9bebaf6fdda330d09 56dc8312c63c44f2a6d63d57807134c6--eac082eb0f204bc9bebaf6fdda330d09 ad8fda1128c4439b9c490924ffd958e5 eac082eb0f204bc9bebaf6fdda330d09--ad8fda1128c4439b9c490924ffd958e5 966f1ea3b9ec49efaca0195dd4b97a9d ad8fda1128c4439b9c490924ffd958e5--966f1ea3b9ec49efaca0195dd4b97a9d 8346542455584d5abdab0717fdafac02 966f1ea3b9ec49efaca0195dd4b97a9d--8346542455584d5abdab0717fdafac02 ee4116296af84508aa8e861b0efcf119 8346542455584d5abdab0717fdafac02--ee4116296af84508aa8e861b0efcf119 00ec22342b22413c8dfafdd8a398974c ee4116296af84508aa8e861b0efcf119--00ec22342b22413c8dfafdd8a398974c 115d3cd4d7454ade849ecce9d1a40289 00ec22342b22413c8dfafdd8a398974c--115d3cd4d7454ade849ecce9d1a40289 c614c18796e847d5861e7f06a0a9d8b8 115d3cd4d7454ade849ecce9d1a40289--c614c18796e847d5861e7f06a0a9d8b8 8888a3d1508149de8a7277175e05cbed c614c18796e847d5861e7f06a0a9d8b8--8888a3d1508149de8a7277175e05cbed 886c4354781e45378e202d9a74c215ff 8888a3d1508149de8a7277175e05cbed--886c4354781e45378e202d9a74c215ff 37e2b7c5af4a4813a995ba1fd0bbf747 886c4354781e45378e202d9a74c215ff--37e2b7c5af4a4813a995ba1fd0bbf747 6847bba28f2d4f1993adaca9ba324b1e 37e2b7c5af4a4813a995ba1fd0bbf747--6847bba28f2d4f1993adaca9ba324b1e 3a60ca15e5af49f89481273261969b41 6847bba28f2d4f1993adaca9ba324b1e--3a60ca15e5af49f89481273261969b41 98a92f06fa9e45b99f75e4a56d950ef2 3a60ca15e5af49f89481273261969b41--98a92f06fa9e45b99f75e4a56d950ef2 80622b1b0ba24a3f8d40e492823b0746 98a92f06fa9e45b99f75e4a56d950ef2--80622b1b0ba24a3f8d40e492823b0746 cb70a385823448bdb0e839d297ed1068 80622b1b0ba24a3f8d40e492823b0746--cb70a385823448bdb0e839d297ed1068 5b99987eee6d48f19774bc1d226d6b5d cb70a385823448bdb0e839d297ed1068--5b99987eee6d48f19774bc1d226d6b5d f5b8fb7b5a4b4b548df5dd7826711c53 5b99987eee6d48f19774bc1d226d6b5d--f5b8fb7b5a4b4b548df5dd7826711c53 28dfe303a9c64c53b507cec006adea72 f5b8fb7b5a4b4b548df5dd7826711c53--28dfe303a9c64c53b507cec006adea72 aea0270c236740ecb6fd0a2061c8f672 28dfe303a9c64c53b507cec006adea72--aea0270c236740ecb6fd0a2061c8f672 62765558761847ed83885717dac5952f aea0270c236740ecb6fd0a2061c8f672--62765558761847ed83885717dac5952f b92b08dd66ab40df8127e6c875d8ca89 62765558761847ed83885717dac5952f--b92b08dd66ab40df8127e6c875d8ca89 c87ca560cd9e4f03acc270c360da8253 b92b08dd66ab40df8127e6c875d8ca89--c87ca560cd9e4f03acc270c360da8253 e01b705309df4179b2e7077dfbd6fcc6 c87ca560cd9e4f03acc270c360da8253--e01b705309df4179b2e7077dfbd6fcc6 cc5eed8b6ff44cb9924b86289d422145 e01b705309df4179b2e7077dfbd6fcc6--cc5eed8b6ff44cb9924b86289d422145 60c26f3714a24ada88a9457e31f08aa6 cc5eed8b6ff44cb9924b86289d422145--60c26f3714a24ada88a9457e31f08aa6 6406e7489b4c400b81d03ac52cffc601 60c26f3714a24ada88a9457e31f08aa6--6406e7489b4c400b81d03ac52cffc601 dc57449ccdf24806846bb2c6bdd463c3 6406e7489b4c400b81d03ac52cffc601--dc57449ccdf24806846bb2c6bdd463c3 d652429181f9468d8c9d8d771641c37c dc57449ccdf24806846bb2c6bdd463c3--d652429181f9468d8c9d8d771641c37c 666b08ccee8e4fad94771c60b4c4533f d652429181f9468d8c9d8d771641c37c--666b08ccee8e4fad94771c60b4c4533f e6b37ef34ab449f6883a846f3e91f4c4 666b08ccee8e4fad94771c60b4c4533f--e6b37ef34ab449f6883a846f3e91f4c4 205aeb23960e4d23a0db6e10cc11977d e6b37ef34ab449f6883a846f3e91f4c4--205aeb23960e4d23a0db6e10cc11977d fb9a1b05fde54237b642cfde4bcac96f 205aeb23960e4d23a0db6e10cc11977d--fb9a1b05fde54237b642cfde4bcac96f b3a4d518441844e6944edb7a1891c24d fb9a1b05fde54237b642cfde4bcac96f--b3a4d518441844e6944edb7a1891c24d a44d1a73573944a5a813abf414f7f6b4 b3a4d518441844e6944edb7a1891c24d--a44d1a73573944a5a813abf414f7f6b4 9a2fbf468c6d4b2d9a725480e5477354 a44d1a73573944a5a813abf414f7f6b4--9a2fbf468c6d4b2d9a725480e5477354 81cda9aeaa78423b85bce2bc208ac192 9a2fbf468c6d4b2d9a725480e5477354--81cda9aeaa78423b85bce2bc208ac192 29aa8cdb05734d8296c1158ab0af9dd5 81cda9aeaa78423b85bce2bc208ac192--29aa8cdb05734d8296c1158ab0af9dd5 e074b3d71dcf4b9f84528553564516bd 29aa8cdb05734d8296c1158ab0af9dd5--e074b3d71dcf4b9f84528553564516bd 1b1a0a814b1540d481ff238b5bae40e1 e074b3d71dcf4b9f84528553564516bd--1b1a0a814b1540d481ff238b5bae40e1 9169c27db9294b2cb6fabd88efe273d8 1b1a0a814b1540d481ff238b5bae40e1--9169c27db9294b2cb6fabd88efe273d8 1697e777e1d64bb9b4078ac559668cf0 9169c27db9294b2cb6fabd88efe273d8--1697e777e1d64bb9b4078ac559668cf0 8fac7f68ed6646cbb7f47fb0ae40ae61 1697e777e1d64bb9b4078ac559668cf0--8fac7f68ed6646cbb7f47fb0ae40ae61 26763fb1dedc4ed78b6ce4b40ce46f40 8fac7f68ed6646cbb7f47fb0ae40ae61--26763fb1dedc4ed78b6ce4b40ce46f40 ae52aaf8976645acbb7d6fbd062c3d1d 26763fb1dedc4ed78b6ce4b40ce46f40--ae52aaf8976645acbb7d6fbd062c3d1d 0337fab77a4d49d1a6dfbb0659919a7f ae52aaf8976645acbb7d6fbd062c3d1d--0337fab77a4d49d1a6dfbb0659919a7f 5c35f0ccbcfd43cc92566839e1c56a4e 0337fab77a4d49d1a6dfbb0659919a7f--5c35f0ccbcfd43cc92566839e1c56a4e 99a223303a1a403ca542419fc1536bcd 5c35f0ccbcfd43cc92566839e1c56a4e--99a223303a1a403ca542419fc1536bcd a41e776fcc2b4a50a37513fb9bb617b4 99a223303a1a403ca542419fc1536bcd--a41e776fcc2b4a50a37513fb9bb617b4 4b4735feb3f94de0a251d02399d0d79c a41e776fcc2b4a50a37513fb9bb617b4--4b4735feb3f94de0a251d02399d0d79c 38b41005218b4a2faa55ddbfea690e88 4b4735feb3f94de0a251d02399d0d79c--38b41005218b4a2faa55ddbfea690e88 31414a5990c64ddf825f6d733613bc95 38b41005218b4a2faa55ddbfea690e88--31414a5990c64ddf825f6d733613bc95 d1f44f410a6649b79e0ec09374a6253e 31414a5990c64ddf825f6d733613bc95--d1f44f410a6649b79e0ec09374a6253e 46e3adc4d36540f688fccebd0fa6466a d1f44f410a6649b79e0ec09374a6253e--46e3adc4d36540f688fccebd0fa6466a fb17c956959845278d47816e4a95d8a2 46e3adc4d36540f688fccebd0fa6466a--fb17c956959845278d47816e4a95d8a2 1e0c3fa4d27a4f37af202f5417352c78 fb17c956959845278d47816e4a95d8a2--1e0c3fa4d27a4f37af202f5417352c78 afa0920e1c6b478ba84b1b52ee8e99e0 1e0c3fa4d27a4f37af202f5417352c78--afa0920e1c6b478ba84b1b52ee8e99e0 54737e194557459f834074638551f08c afa0920e1c6b478ba84b1b52ee8e99e0--54737e194557459f834074638551f08c 544771fe9bab452b8aec9f8a2c897c80 54737e194557459f834074638551f08c--544771fe9bab452b8aec9f8a2c897c80 01d5f73fb71e41eeb88b1c2763a84c97 544771fe9bab452b8aec9f8a2c897c80--01d5f73fb71e41eeb88b1c2763a84c97 bd046b6198b54e76838fc68e89fd86c7 01d5f73fb71e41eeb88b1c2763a84c97--bd046b6198b54e76838fc68e89fd86c7 a79fa6194c4f4cf6865dc2d5da644d96 bd046b6198b54e76838fc68e89fd86c7--a79fa6194c4f4cf6865dc2d5da644d96 2fbc7e7359104c72bcaefa6192cf7470 a79fa6194c4f4cf6865dc2d5da644d96--2fbc7e7359104c72bcaefa6192cf7470 fd11406e6ea34771b844ecffe5db8c11 2fbc7e7359104c72bcaefa6192cf7470--fd11406e6ea34771b844ecffe5db8c11 2421be9f66b445f2ab383da9445ce102 fd11406e6ea34771b844ecffe5db8c11--2421be9f66b445f2ab383da9445ce102 08e0086d87ac47c18350127dd3c2da9e 2421be9f66b445f2ab383da9445ce102--08e0086d87ac47c18350127dd3c2da9e c8e254d34ef7499e99c45a69dd87dd48 08e0086d87ac47c18350127dd3c2da9e--c8e254d34ef7499e99c45a69dd87dd48 9e658610b10045a183c743ca6f2ee513 c8e254d34ef7499e99c45a69dd87dd48--9e658610b10045a183c743ca6f2ee513 c1484791d78547e1a6f198b3382fd654 9e658610b10045a183c743ca6f2ee513--c1484791d78547e1a6f198b3382fd654 c385a003119e458b9ba4312f065642d2 c1484791d78547e1a6f198b3382fd654--c385a003119e458b9ba4312f065642d2 ecd1f2cfd81542c6bf8f03ad720d9dd8 c385a003119e458b9ba4312f065642d2--ecd1f2cfd81542c6bf8f03ad720d9dd8 14c272f15ab74f538f6bbd6793923eb8 ecd1f2cfd81542c6bf8f03ad720d9dd8--14c272f15ab74f538f6bbd6793923eb8 205e5906faf54abb80eb993679e8f262 14c272f15ab74f538f6bbd6793923eb8--205e5906faf54abb80eb993679e8f262 fce4e4f7f9bb4c6c81d0e8d5a94e78d8 205e5906faf54abb80eb993679e8f262--fce4e4f7f9bb4c6c81d0e8d5a94e78d8 02c6fbf9623b451b8ce0f276254f5de0 fce4e4f7f9bb4c6c81d0e8d5a94e78d8--02c6fbf9623b451b8ce0f276254f5de0 27f4ee4c5fc74858be2e2ed9a683b731 02c6fbf9623b451b8ce0f276254f5de0--27f4ee4c5fc74858be2e2ed9a683b731 554a81eb06004652baa25546e707e662 27f4ee4c5fc74858be2e2ed9a683b731--554a81eb06004652baa25546e707e662 3830ae708f754ee49605093557f7926d 554a81eb06004652baa25546e707e662--3830ae708f754ee49605093557f7926d 42162387573c48519cccc7136af359f4 3830ae708f754ee49605093557f7926d--42162387573c48519cccc7136af359f4 297de3e61b4140e4ab32998fe210e915 42162387573c48519cccc7136af359f4--297de3e61b4140e4ab32998fe210e915 7d6b1c5e968c4b479ea9e1a84dd4b081 297de3e61b4140e4ab32998fe210e915--7d6b1c5e968c4b479ea9e1a84dd4b081 9d40720c85ac4389905bc4cdfc6ea236 7d6b1c5e968c4b479ea9e1a84dd4b081--9d40720c85ac4389905bc4cdfc6ea236 dbe503462ae44d5489647ca9bc0667e7 9d40720c85ac4389905bc4cdfc6ea236--dbe503462ae44d5489647ca9bc0667e7 1c6e721f21484242b8264cc25d35b644 RX(b00) dbe503462ae44d5489647ca9bc0667e7--1c6e721f21484242b8264cc25d35b644 5a9d2e805a514850bfe463ee361df883 1c6e721f21484242b8264cc25d35b644--5a9d2e805a514850bfe463ee361df883 6b71cd1a286c47d0a65babfb2603bda2 5a9d2e805a514850bfe463ee361df883--6b71cd1a286c47d0a65babfb2603bda2 50068910a1bf4e9184e100c655e00470 6b71cd1a286c47d0a65babfb2603bda2--50068910a1bf4e9184e100c655e00470 e7e35c28ec984da1a9fe24ffe8adc90b 50068910a1bf4e9184e100c655e00470--e7e35c28ec984da1a9fe24ffe8adc90b fe5c4a5b97f74e30acda8aa31fe52d15 e7e35c28ec984da1a9fe24ffe8adc90b--fe5c4a5b97f74e30acda8aa31fe52d15 e47df39478d7451e8c4c96fa405f3755 fe5c4a5b97f74e30acda8aa31fe52d15--e47df39478d7451e8c4c96fa405f3755 9d6132d361504318a44b563a130338d5 e47df39478d7451e8c4c96fa405f3755--9d6132d361504318a44b563a130338d5 7d1f26e90cd44ed694cd2ebc7a9c79f0 9d6132d361504318a44b563a130338d5--7d1f26e90cd44ed694cd2ebc7a9c79f0 9e532971d026419c8fc7d0ddb798494e 7d1f26e90cd44ed694cd2ebc7a9c79f0--9e532971d026419c8fc7d0ddb798494e 12bc7007f1be4d78925ad355de3431f1 9e532971d026419c8fc7d0ddb798494e--12bc7007f1be4d78925ad355de3431f1 f83250aa328845d8aa70f670269cb719 12bc7007f1be4d78925ad355de3431f1--f83250aa328845d8aa70f670269cb719 1ce97307bf36409d8c851f425bf3f3dc f83250aa328845d8aa70f670269cb719--1ce97307bf36409d8c851f425bf3f3dc 3451f532c09045f7b7e6ed4149ef9a5f 1ce97307bf36409d8c851f425bf3f3dc--3451f532c09045f7b7e6ed4149ef9a5f 7b08122c087444fba89d44775df717f5 3451f532c09045f7b7e6ed4149ef9a5f--7b08122c087444fba89d44775df717f5 c16fe35f8e744a92aa34d310e25e3ea8 7b08122c087444fba89d44775df717f5--c16fe35f8e744a92aa34d310e25e3ea8 b714025564dd4632a1fc1dee67858d39 c16fe35f8e744a92aa34d310e25e3ea8--b714025564dd4632a1fc1dee67858d39 1e53d4e6ed25490498c27c85deef4fd4 b714025564dd4632a1fc1dee67858d39--1e53d4e6ed25490498c27c85deef4fd4 a0cf5ef05fd24a27a4a232a5ef6fdb47 1e53d4e6ed25490498c27c85deef4fd4--a0cf5ef05fd24a27a4a232a5ef6fdb47 c9d793f9a1ab49fbb61d8f0aaac8d4a8 a0cf5ef05fd24a27a4a232a5ef6fdb47--c9d793f9a1ab49fbb61d8f0aaac8d4a8 8d8bd8290a9c41f587efe94006c7e2da c9d793f9a1ab49fbb61d8f0aaac8d4a8--8d8bd8290a9c41f587efe94006c7e2da 3554681770ad468389943e48c666b6db 8d8bd8290a9c41f587efe94006c7e2da--3554681770ad468389943e48c666b6db 4145899e95b442a3b450ded50bb20c29 3554681770ad468389943e48c666b6db--4145899e95b442a3b450ded50bb20c29 5d131d3d90144bc694f5323cfeeaf48d 4145899e95b442a3b450ded50bb20c29--5d131d3d90144bc694f5323cfeeaf48d c90426a7dc9d499cae7a83a532e2bacc 5d131d3d90144bc694f5323cfeeaf48d--c90426a7dc9d499cae7a83a532e2bacc d2641166cc5540e2a2fbff8289c6cde0 c90426a7dc9d499cae7a83a532e2bacc--d2641166cc5540e2a2fbff8289c6cde0 677ece71ffa44b5d83af44ff34ed2faf d2641166cc5540e2a2fbff8289c6cde0--677ece71ffa44b5d83af44ff34ed2faf 971eab4db90d422faea20f36636ff2bb 677ece71ffa44b5d83af44ff34ed2faf--971eab4db90d422faea20f36636ff2bb b6973b68e0e0432fbf7fbd8aba92a418 971eab4db90d422faea20f36636ff2bb--b6973b68e0e0432fbf7fbd8aba92a418 18e1aaeb2f954742a858f7b62d72d395 b6973b68e0e0432fbf7fbd8aba92a418--18e1aaeb2f954742a858f7b62d72d395 7014a63347b74f0bba7afeefe1330d82 18e1aaeb2f954742a858f7b62d72d395--7014a63347b74f0bba7afeefe1330d82 164e08192b34428ba047845ba22bc44e 7014a63347b74f0bba7afeefe1330d82--164e08192b34428ba047845ba22bc44e 328d732615b84ee6b116a6b174508c5d 164e08192b34428ba047845ba22bc44e--328d732615b84ee6b116a6b174508c5d a7556ccd3335454aa806bb0be61007f4 328d732615b84ee6b116a6b174508c5d--a7556ccd3335454aa806bb0be61007f4 09f0c380bc9945e290b7c4affaa5681e a7556ccd3335454aa806bb0be61007f4--09f0c380bc9945e290b7c4affaa5681e 2176142b5dbd493ca001cfcb90ed0c36 09f0c380bc9945e290b7c4affaa5681e--2176142b5dbd493ca001cfcb90ed0c36 1616f7e7cd1743cba1188b76bc8346aa 2176142b5dbd493ca001cfcb90ed0c36--1616f7e7cd1743cba1188b76bc8346aa 1d8b02460d5e4ee89e6b0ca218f34693 1616f7e7cd1743cba1188b76bc8346aa--1d8b02460d5e4ee89e6b0ca218f34693 9a5994ad02f247f0bbb4a6799301bd81 1d8b02460d5e4ee89e6b0ca218f34693--9a5994ad02f247f0bbb4a6799301bd81 4b1cfdeb5e9347f585bc4e3f37fccef3 9a5994ad02f247f0bbb4a6799301bd81--4b1cfdeb5e9347f585bc4e3f37fccef3 64f60e444b0440e4b755e974587732a8 4b1cfdeb5e9347f585bc4e3f37fccef3--64f60e444b0440e4b755e974587732a8 ddad501a89994355811f895ddc1eb79d 64f60e444b0440e4b755e974587732a8--ddad501a89994355811f895ddc1eb79d ef6b7161bdee4a9b802fcd2f769c1044 ddad501a89994355811f895ddc1eb79d--ef6b7161bdee4a9b802fcd2f769c1044 ba7b1dfadad543069c9e2ec66c250ed9 ef6b7161bdee4a9b802fcd2f769c1044--ba7b1dfadad543069c9e2ec66c250ed9 2a5fab5151ed46a48424d8e14c880b92 ba7b1dfadad543069c9e2ec66c250ed9--2a5fab5151ed46a48424d8e14c880b92 b8790c69582946cea069b721d8d786e8 2a5fab5151ed46a48424d8e14c880b92--b8790c69582946cea069b721d8d786e8 21a6a216268642dba70ba0ba526de611 b8790c69582946cea069b721d8d786e8--21a6a216268642dba70ba0ba526de611 22014b77f48041b99cdba61938f16c58 21a6a216268642dba70ba0ba526de611--22014b77f48041b99cdba61938f16c58 7a0c4936706b4eb39d5051df79c63fc0 22014b77f48041b99cdba61938f16c58--7a0c4936706b4eb39d5051df79c63fc0 3df936b94524493984c6a80bad8847c8 7a0c4936706b4eb39d5051df79c63fc0--3df936b94524493984c6a80bad8847c8 cec99bdccdb1448a94f24e1aca5ddcac 3df936b94524493984c6a80bad8847c8--cec99bdccdb1448a94f24e1aca5ddcac 1e45416363ae4f5ab235089a3a1fbca6 cec99bdccdb1448a94f24e1aca5ddcac--1e45416363ae4f5ab235089a3a1fbca6 c680762b1e6c483a8d25fc4ad2cced48 1e45416363ae4f5ab235089a3a1fbca6--c680762b1e6c483a8d25fc4ad2cced48 e05fa16fddee413f8643791b8ec3c2fd c680762b1e6c483a8d25fc4ad2cced48--e05fa16fddee413f8643791b8ec3c2fd 462b5b4ff6364a479db74a384dd5f0a0 e05fa16fddee413f8643791b8ec3c2fd--462b5b4ff6364a479db74a384dd5f0a0 095dc2cbed634ed38d404e4922523e5e 462b5b4ff6364a479db74a384dd5f0a0--095dc2cbed634ed38d404e4922523e5e 26ca184aae5d4971af473575b7e8f377 095dc2cbed634ed38d404e4922523e5e--26ca184aae5d4971af473575b7e8f377 55da6148086e4a85bcd3b0d98b448eb0 26ca184aae5d4971af473575b7e8f377--55da6148086e4a85bcd3b0d98b448eb0 ef3422c2dfe045559dbccb95d45127ac 55da6148086e4a85bcd3b0d98b448eb0--ef3422c2dfe045559dbccb95d45127ac 3cfa69a4c17e43f4b2e1decb7358647a ef3422c2dfe045559dbccb95d45127ac--3cfa69a4c17e43f4b2e1decb7358647a 6b2e9c19bfd4438eb928287d17f8a2d9 3cfa69a4c17e43f4b2e1decb7358647a--6b2e9c19bfd4438eb928287d17f8a2d9 1c88d9c16b444e758036304ab6be17ac 6b2e9c19bfd4438eb928287d17f8a2d9--1c88d9c16b444e758036304ab6be17ac 4c6f34f4f5aa46ee8ff6b4e1e47755a6 1c88d9c16b444e758036304ab6be17ac--4c6f34f4f5aa46ee8ff6b4e1e47755a6 fe3c98d9c2244bd191d1bc4f3f389bd8 4c6f34f4f5aa46ee8ff6b4e1e47755a6--fe3c98d9c2244bd191d1bc4f3f389bd8 3411cc76cb6542cfb4fd54575825f2a0 fe3c98d9c2244bd191d1bc4f3f389bd8--3411cc76cb6542cfb4fd54575825f2a0 56262d131da1402a95ec130e7e77b37a 3411cc76cb6542cfb4fd54575825f2a0--56262d131da1402a95ec130e7e77b37a e9b8327707c24608a7a4ed94c38da2ba 56262d131da1402a95ec130e7e77b37a--e9b8327707c24608a7a4ed94c38da2ba 9cc82db6fd194f86bae9dc32bc1b6be6 e9b8327707c24608a7a4ed94c38da2ba--9cc82db6fd194f86bae9dc32bc1b6be6 c0c1a964c9f6456b8b052a5388157000 9cc82db6fd194f86bae9dc32bc1b6be6--c0c1a964c9f6456b8b052a5388157000 87f65c5efb884062a5ae088200508b89 c0c1a964c9f6456b8b052a5388157000--87f65c5efb884062a5ae088200508b89 3d633153ce2d468297f62ceb7b88bd5c 87f65c5efb884062a5ae088200508b89--3d633153ce2d468297f62ceb7b88bd5c c4936bbbe47e408aa2da2b88bba3c6d4 3d633153ce2d468297f62ceb7b88bd5c--c4936bbbe47e408aa2da2b88bba3c6d4 1b22f27f9a6e4a57a18a3e61208d5a92 c4936bbbe47e408aa2da2b88bba3c6d4--1b22f27f9a6e4a57a18a3e61208d5a92 61447ec513344ddbb4f7704afa5e91bd 1b22f27f9a6e4a57a18a3e61208d5a92--61447ec513344ddbb4f7704afa5e91bd 42bedfa3cece4a8885f268f70fe2085f 61447ec513344ddbb4f7704afa5e91bd--42bedfa3cece4a8885f268f70fe2085f ec27133fbe1c4048accbecdb6e19b68b 42bedfa3cece4a8885f268f70fe2085f--ec27133fbe1c4048accbecdb6e19b68b 1ffe3ee3f74e44b9866b25fa31b2fc68 ec27133fbe1c4048accbecdb6e19b68b--1ffe3ee3f74e44b9866b25fa31b2fc68 bb8a3cc280994981b2af82d96edc713b 1ffe3ee3f74e44b9866b25fa31b2fc68--bb8a3cc280994981b2af82d96edc713b 3b760f8fb6f34e08b99d4451f5a342e7 bb8a3cc280994981b2af82d96edc713b--3b760f8fb6f34e08b99d4451f5a342e7 cfecb7d0374245ffa0c9078875116a91 3b760f8fb6f34e08b99d4451f5a342e7--cfecb7d0374245ffa0c9078875116a91 d5b87f0ff7fd4eacb1a1530b4200cb71 cfecb7d0374245ffa0c9078875116a91--d5b87f0ff7fd4eacb1a1530b4200cb71 cb60d4a9505a43afb3cacf2fdc0fa2dd d5b87f0ff7fd4eacb1a1530b4200cb71--cb60d4a9505a43afb3cacf2fdc0fa2dd e0961dba15e74f5697230b050e69d9aa cb60d4a9505a43afb3cacf2fdc0fa2dd--e0961dba15e74f5697230b050e69d9aa 2618916dd7174fc491fbe89e5855de2a e0961dba15e74f5697230b050e69d9aa--2618916dd7174fc491fbe89e5855de2a 790167ac14f4474380f382f840a3f4bc 2618916dd7174fc491fbe89e5855de2a--790167ac14f4474380f382f840a3f4bc 537a45c22aca4a14b3c8be9e52e6baca 790167ac14f4474380f382f840a3f4bc--537a45c22aca4a14b3c8be9e52e6baca 2314f97919a544f98c4e6319bd3d3b3d 537a45c22aca4a14b3c8be9e52e6baca--2314f97919a544f98c4e6319bd3d3b3d afd41204dd1c4421aca995eca7adacf2 2314f97919a544f98c4e6319bd3d3b3d--afd41204dd1c4421aca995eca7adacf2 6daca88c4600485eb770bd61557ae02a afd41204dd1c4421aca995eca7adacf2--6daca88c4600485eb770bd61557ae02a 333e5c8c5c4c459d897469faa68fee94 6daca88c4600485eb770bd61557ae02a--333e5c8c5c4c459d897469faa68fee94 2e48a09c53d547548670537cba923df6 333e5c8c5c4c459d897469faa68fee94--2e48a09c53d547548670537cba923df6 3522c106361e4f0483d487b0fdd026fe 2e48a09c53d547548670537cba923df6--3522c106361e4f0483d487b0fdd026fe 75020b07fdd14ebd9a0c977dbab7de64 3522c106361e4f0483d487b0fdd026fe--75020b07fdd14ebd9a0c977dbab7de64 5eeb263dce9c43e29c173947616b249d 75020b07fdd14ebd9a0c977dbab7de64--5eeb263dce9c43e29c173947616b249d b0374432b2f548be9614fdcf9b65f65d 5eeb263dce9c43e29c173947616b249d--b0374432b2f548be9614fdcf9b65f65d f655cef0395441a18591f2bebbf51d73 b0374432b2f548be9614fdcf9b65f65d--f655cef0395441a18591f2bebbf51d73 76fbe383255f41e1bb2bc4f8cf9c997e f655cef0395441a18591f2bebbf51d73--76fbe383255f41e1bb2bc4f8cf9c997e b58a8dbc9cfa4c208549d7f5ecd91f89 76fbe383255f41e1bb2bc4f8cf9c997e--b58a8dbc9cfa4c208549d7f5ecd91f89 6a5181c43abd421880163d5a69c03efa b58a8dbc9cfa4c208549d7f5ecd91f89--6a5181c43abd421880163d5a69c03efa 5bc27eb23dcf420d8a0089200c5c471c 6a5181c43abd421880163d5a69c03efa--5bc27eb23dcf420d8a0089200c5c471c f2b467e472ad42d0896c5a44d71ea48d 5bc27eb23dcf420d8a0089200c5c471c--f2b467e472ad42d0896c5a44d71ea48d 1e1c2c51ae5046ceab55693403162b3d f2b467e472ad42d0896c5a44d71ea48d--1e1c2c51ae5046ceab55693403162b3d 1e37bf2fc8824f0f84565bffc4e132e3 1e1c2c51ae5046ceab55693403162b3d--1e37bf2fc8824f0f84565bffc4e132e3 cb5d95a703e54994be7135fefdb4026b 1e37bf2fc8824f0f84565bffc4e132e3--cb5d95a703e54994be7135fefdb4026b d071c5e899504b6c95a940a11839d8db cb5d95a703e54994be7135fefdb4026b--d071c5e899504b6c95a940a11839d8db 8bf5aca8f18f48a08ffa5491b465a1d6 d071c5e899504b6c95a940a11839d8db--8bf5aca8f18f48a08ffa5491b465a1d6 4a10e77b3fc1424d89df276f1f7af070 8bf5aca8f18f48a08ffa5491b465a1d6--4a10e77b3fc1424d89df276f1f7af070 8643139cc4e84b91aea33a921974385b 4a10e77b3fc1424d89df276f1f7af070--8643139cc4e84b91aea33a921974385b 9fbcebd640724839b3caa30acba4fb42 8643139cc4e84b91aea33a921974385b--9fbcebd640724839b3caa30acba4fb42 46412a72396745b4b1a2e341e662214d 9fbcebd640724839b3caa30acba4fb42--46412a72396745b4b1a2e341e662214d cb4b687ca40f4ed9bfddfaa2440b3b1e 46412a72396745b4b1a2e341e662214d--cb4b687ca40f4ed9bfddfaa2440b3b1e 445d09957b37412fb2cc263cc2a369e3 cb4b687ca40f4ed9bfddfaa2440b3b1e--445d09957b37412fb2cc263cc2a369e3 38cdda2f753c47e398ed65f490bc5f45 445d09957b37412fb2cc263cc2a369e3--38cdda2f753c47e398ed65f490bc5f45 f96ce8dca329450db4085f13e269f650 38cdda2f753c47e398ed65f490bc5f45--f96ce8dca329450db4085f13e269f650 74a117d86abc49a5af2584843054e3d9 f96ce8dca329450db4085f13e269f650--74a117d86abc49a5af2584843054e3d9 92ced374e9b748f1952728e288150d8c 74a117d86abc49a5af2584843054e3d9--92ced374e9b748f1952728e288150d8c 060f3665fc4d4f57a7e500ba13e215f3 92ced374e9b748f1952728e288150d8c--060f3665fc4d4f57a7e500ba13e215f3 cca12abfa420484fbd95d65c5c62238d 060f3665fc4d4f57a7e500ba13e215f3--cca12abfa420484fbd95d65c5c62238d 658ecfb5fcf04fc5b6e63fe24d8ec796 cca12abfa420484fbd95d65c5c62238d--658ecfb5fcf04fc5b6e63fe24d8ec796 596330990c954336a2db348fcc35daae 658ecfb5fcf04fc5b6e63fe24d8ec796--596330990c954336a2db348fcc35daae 6d631e5fb6df478c97a5bb28878eaac7 596330990c954336a2db348fcc35daae--6d631e5fb6df478c97a5bb28878eaac7 a57814a5be754d18b655d246926da26b 6d631e5fb6df478c97a5bb28878eaac7--a57814a5be754d18b655d246926da26b 95fa377d135944878ff8d6a0bf2ac377 a57814a5be754d18b655d246926da26b--95fa377d135944878ff8d6a0bf2ac377 56ead8db75be4cfcab536c4d4be42e88 95fa377d135944878ff8d6a0bf2ac377--56ead8db75be4cfcab536c4d4be42e88 cf8df59028e34d808973a00f5bd9c208 56ead8db75be4cfcab536c4d4be42e88--cf8df59028e34d808973a00f5bd9c208 b32c0ea97b1e410ab495b7aceab3e1b2 cf8df59028e34d808973a00f5bd9c208--b32c0ea97b1e410ab495b7aceab3e1b2 4ed422aaa5fc45af97ed3220fc7e05d6 b32c0ea97b1e410ab495b7aceab3e1b2--4ed422aaa5fc45af97ed3220fc7e05d6 a5807d7aa1714eaa826c7b262b25adce 4ed422aaa5fc45af97ed3220fc7e05d6--a5807d7aa1714eaa826c7b262b25adce d101491e074b44e28e3e93155bcc72bb a5807d7aa1714eaa826c7b262b25adce--d101491e074b44e28e3e93155bcc72bb 9aaba9c60f944539b5820c4da226cb56 d101491e074b44e28e3e93155bcc72bb--9aaba9c60f944539b5820c4da226cb56 6c1ec0c46e4a4a1bbc78a449af6365fa 9aaba9c60f944539b5820c4da226cb56--6c1ec0c46e4a4a1bbc78a449af6365fa f260cea56d48481ea391b08b2e255a38 6c1ec0c46e4a4a1bbc78a449af6365fa--f260cea56d48481ea391b08b2e255a38 3b21ac5db0684a9f82a7ad35bcaa2c2b f260cea56d48481ea391b08b2e255a38--3b21ac5db0684a9f82a7ad35bcaa2c2b 56374c303e564581998847eb1ee0dbc6 3b21ac5db0684a9f82a7ad35bcaa2c2b--56374c303e564581998847eb1ee0dbc6 21befc1c40ff4183a6c6c9dcb70971ff 56374c303e564581998847eb1ee0dbc6--21befc1c40ff4183a6c6c9dcb70971ff c829a634ce6143e58f5e804b5167ebd0 21befc1c40ff4183a6c6c9dcb70971ff--c829a634ce6143e58f5e804b5167ebd0 2946e14850b2493eb69dd4d5ac74823b c829a634ce6143e58f5e804b5167ebd0--2946e14850b2493eb69dd4d5ac74823b 2fd82006b97c47c98018d1c5c9ecaf54 2946e14850b2493eb69dd4d5ac74823b--2fd82006b97c47c98018d1c5c9ecaf54 3cc4704baddf40568f526b1a78ab26e1 2fd82006b97c47c98018d1c5c9ecaf54--3cc4704baddf40568f526b1a78ab26e1 6ec02bc01d10461a86f6dce5857600e7 3cc4704baddf40568f526b1a78ab26e1--6ec02bc01d10461a86f6dce5857600e7 d98f453371284c7faca9166a8f9b7e2b 6ec02bc01d10461a86f6dce5857600e7--d98f453371284c7faca9166a8f9b7e2b c8afc9f7368246ae82bd6baa92acb08f d98f453371284c7faca9166a8f9b7e2b--c8afc9f7368246ae82bd6baa92acb08f c8b81b8681e64be590122b433d788b57 RX(b10) c8afc9f7368246ae82bd6baa92acb08f--c8b81b8681e64be590122b433d788b57 271eff6f59ad496093dab26861e9792f c8b81b8681e64be590122b433d788b57--271eff6f59ad496093dab26861e9792f 435bca5c75ad4d5d99be3987124e4251 5a66f8707b6849c0a4126779a492e4a1 X 192f514e30e24e119a54c8b3970e1af1--5a66f8707b6849c0a4126779a492e4a1 9bd92ef7706741998bb1b7d26b16a171 2 5a66f8707b6849c0a4126779a492e4a1--d190ef396a564bf6b3d479bfb8ab8970 dc00df7cb9604233b4d8a258946c75af 5a66f8707b6849c0a4126779a492e4a1--dc00df7cb9604233b4d8a258946c75af cd386abffe3e4485a3b0e1232a20749a dc00df7cb9604233b4d8a258946c75af--cd386abffe3e4485a3b0e1232a20749a 781aa2556f174227b7c8f8b2c4e4eda5 cd386abffe3e4485a3b0e1232a20749a--781aa2556f174227b7c8f8b2c4e4eda5 be8c501eb7df44878e10e4f06de53ce0 781aa2556f174227b7c8f8b2c4e4eda5--be8c501eb7df44878e10e4f06de53ce0 cc7e8b6288284ec58ed54a261f602309 be8c501eb7df44878e10e4f06de53ce0--cc7e8b6288284ec58ed54a261f602309 cf4335d556544a8e812a10009f53212f cc7e8b6288284ec58ed54a261f602309--cf4335d556544a8e812a10009f53212f c286f84771d8429ebb3f8053442b5160 cf4335d556544a8e812a10009f53212f--c286f84771d8429ebb3f8053442b5160 5292474bce31427e99ccab9ce8ea3132 c286f84771d8429ebb3f8053442b5160--5292474bce31427e99ccab9ce8ea3132 3f7f12787ac54d158c67d8711ee5a9d0 5292474bce31427e99ccab9ce8ea3132--3f7f12787ac54d158c67d8711ee5a9d0 21785cb9ca7a46b29b88f673a1f0cd6f 3f7f12787ac54d158c67d8711ee5a9d0--21785cb9ca7a46b29b88f673a1f0cd6f aa611e751f9045a58e675c4bdbfbab16 21785cb9ca7a46b29b88f673a1f0cd6f--aa611e751f9045a58e675c4bdbfbab16 16581623f8bd4e1b973a56619338109c aa611e751f9045a58e675c4bdbfbab16--16581623f8bd4e1b973a56619338109c 44fa2953cfd0427ab66c7a521c1349fd 16581623f8bd4e1b973a56619338109c--44fa2953cfd0427ab66c7a521c1349fd 755d4812247c42d7824387995e764306 X 44fa2953cfd0427ab66c7a521c1349fd--755d4812247c42d7824387995e764306 755d4812247c42d7824387995e764306--b03d010af558473ba3503cd32dc4d42e b098ec1704c84a75a283918a9106a9f2 X 755d4812247c42d7824387995e764306--b098ec1704c84a75a283918a9106a9f2 b098ec1704c84a75a283918a9106a9f2--eefd996dbf0543069642802dd15cc67a c30942872eb84c428c7bc215fcf13bdd RZ(-1.0*g0) b098ec1704c84a75a283918a9106a9f2--c30942872eb84c428c7bc215fcf13bdd 2d29fd36f8a141bbb6003f602af05a01 X c30942872eb84c428c7bc215fcf13bdd--2d29fd36f8a141bbb6003f602af05a01 2d29fd36f8a141bbb6003f602af05a01--d59c9d7c4b154e11bddd04ffd03421a2 06453b7fd7bc4b49ba7f67a7db0ead4e X 2d29fd36f8a141bbb6003f602af05a01--06453b7fd7bc4b49ba7f67a7db0ead4e 06453b7fd7bc4b49ba7f67a7db0ead4e--191b628c28d74fb8bd636f0c489e857a 571cad967c4347909b28a2547bcf4d59 06453b7fd7bc4b49ba7f67a7db0ead4e--571cad967c4347909b28a2547bcf4d59 11da9e45c4e241daa735af61508ded8b 571cad967c4347909b28a2547bcf4d59--11da9e45c4e241daa735af61508ded8b 1a200d21acc64e9da372446c4316b631 11da9e45c4e241daa735af61508ded8b--1a200d21acc64e9da372446c4316b631 ee0d82ea48fc4c0fbe8feaaed9143ddd 1a200d21acc64e9da372446c4316b631--ee0d82ea48fc4c0fbe8feaaed9143ddd ea5d5d514ffb47dd9eb3ed8c4384cc7c ee0d82ea48fc4c0fbe8feaaed9143ddd--ea5d5d514ffb47dd9eb3ed8c4384cc7c ae3f6ce0d68e4a26a3bc6fb2c06ff765 ea5d5d514ffb47dd9eb3ed8c4384cc7c--ae3f6ce0d68e4a26a3bc6fb2c06ff765 d6bf853e7bea49d0992ac912648b3c02 ae3f6ce0d68e4a26a3bc6fb2c06ff765--d6bf853e7bea49d0992ac912648b3c02 fc4cadd553bd4b8dbc625967981bd4b8 d6bf853e7bea49d0992ac912648b3c02--fc4cadd553bd4b8dbc625967981bd4b8 4bed8342aa844d1d814d79180bf2b267 fc4cadd553bd4b8dbc625967981bd4b8--4bed8342aa844d1d814d79180bf2b267 77d311cf95fa4164b44202fe9ae4c01b X 4bed8342aa844d1d814d79180bf2b267--77d311cf95fa4164b44202fe9ae4c01b 77d311cf95fa4164b44202fe9ae4c01b--9499b71f5b3a48d9a0c5767073384dde 8a5fda073040423e85865c292a85e5ae X 77d311cf95fa4164b44202fe9ae4c01b--8a5fda073040423e85865c292a85e5ae 8a5fda073040423e85865c292a85e5ae--26cce2d9c4134b5d8c890dc10a0c3b92 4ea338a2aafa48db869169e1169160ea 8a5fda073040423e85865c292a85e5ae--4ea338a2aafa48db869169e1169160ea 59031c2b059943a894f550fddee44575 4ea338a2aafa48db869169e1169160ea--59031c2b059943a894f550fddee44575 dc07fe6a56d44803a6a871c718975a88 59031c2b059943a894f550fddee44575--dc07fe6a56d44803a6a871c718975a88 3b8e1aad3f1c44b28d61f4e64134a160 dc07fe6a56d44803a6a871c718975a88--3b8e1aad3f1c44b28d61f4e64134a160 0a897d534e204b1890df8b4ef1054eb6 3b8e1aad3f1c44b28d61f4e64134a160--0a897d534e204b1890df8b4ef1054eb6 ac7a08f5eff94c05800e2c197eb1aad1 0a897d534e204b1890df8b4ef1054eb6--ac7a08f5eff94c05800e2c197eb1aad1 706c4b65bf3142f688a5adc23bd21dc3 ac7a08f5eff94c05800e2c197eb1aad1--706c4b65bf3142f688a5adc23bd21dc3 20c2a078c74b493386a2a42b2c10d30f 706c4b65bf3142f688a5adc23bd21dc3--20c2a078c74b493386a2a42b2c10d30f baf4b5ce04ad4a11821d3b44695034be 20c2a078c74b493386a2a42b2c10d30f--baf4b5ce04ad4a11821d3b44695034be 74463fb728774c7f8b4b20401fd568c8 baf4b5ce04ad4a11821d3b44695034be--74463fb728774c7f8b4b20401fd568c8 f09c1985924847a9a11b0cb8ed16074b 74463fb728774c7f8b4b20401fd568c8--f09c1985924847a9a11b0cb8ed16074b 89037d33ff494c7cac53b7d5c552127f X f09c1985924847a9a11b0cb8ed16074b--89037d33ff494c7cac53b7d5c552127f 89037d33ff494c7cac53b7d5c552127f--d13e5e1e0dc144db9f5d30ab5642d32c 956aa0b6ee5546ffa0758c7c1775767d X 89037d33ff494c7cac53b7d5c552127f--956aa0b6ee5546ffa0758c7c1775767d 956aa0b6ee5546ffa0758c7c1775767d--0fe37cb0e7d44a49a0e2648bf07ffae0 bd5ad556ca1a49efa2d0796bf1031f82 956aa0b6ee5546ffa0758c7c1775767d--bd5ad556ca1a49efa2d0796bf1031f82 eb119a63d035435883abdd7907ed6023 bd5ad556ca1a49efa2d0796bf1031f82--eb119a63d035435883abdd7907ed6023 8c540b2203d7435f844a8c246aaa67d0 eb119a63d035435883abdd7907ed6023--8c540b2203d7435f844a8c246aaa67d0 a60f1226d782438d90364b0a36de7f08 8c540b2203d7435f844a8c246aaa67d0--a60f1226d782438d90364b0a36de7f08 55c4e72605274a148de19ddf3f057d02 a60f1226d782438d90364b0a36de7f08--55c4e72605274a148de19ddf3f057d02 657769b0328d484cb427543049f3ede8 55c4e72605274a148de19ddf3f057d02--657769b0328d484cb427543049f3ede8 e5a260153a6c426ea01f7fcf6f62afbb 657769b0328d484cb427543049f3ede8--e5a260153a6c426ea01f7fcf6f62afbb 825a605b832f418f8fa410f9f9315ad5 e5a260153a6c426ea01f7fcf6f62afbb--825a605b832f418f8fa410f9f9315ad5 e914330d93fa44928076b6855ae2b41d 825a605b832f418f8fa410f9f9315ad5--e914330d93fa44928076b6855ae2b41d 1ccbbe3cf57140b7bca185023f3425f0 e914330d93fa44928076b6855ae2b41d--1ccbbe3cf57140b7bca185023f3425f0 ec58dc5593554185b2703a4c7added1a 1ccbbe3cf57140b7bca185023f3425f0--ec58dc5593554185b2703a4c7added1a f72f67ee02a5430e8bd4a8c534d3bbe7 ec58dc5593554185b2703a4c7added1a--f72f67ee02a5430e8bd4a8c534d3bbe7 2839895ae9ac43ccbc189e14d4af6e96 f72f67ee02a5430e8bd4a8c534d3bbe7--2839895ae9ac43ccbc189e14d4af6e96 33787d85c0424dc78e5e469930e8f4db X 2839895ae9ac43ccbc189e14d4af6e96--33787d85c0424dc78e5e469930e8f4db 33787d85c0424dc78e5e469930e8f4db--2d3ea4b0e30a4bdd8d96ea332cab5d52 67ef723693b04b16a8ba96f12ba09a64 33787d85c0424dc78e5e469930e8f4db--67ef723693b04b16a8ba96f12ba09a64 6bd9002aa54c4970a8326b448716e554 67ef723693b04b16a8ba96f12ba09a64--6bd9002aa54c4970a8326b448716e554 df9293afd5d44433b3b2830c441f7196 6bd9002aa54c4970a8326b448716e554--df9293afd5d44433b3b2830c441f7196 bcfd07d4ec16417c92127160c8caedaf df9293afd5d44433b3b2830c441f7196--bcfd07d4ec16417c92127160c8caedaf f64125b6f8e24d069f011ac06a05d731 bcfd07d4ec16417c92127160c8caedaf--f64125b6f8e24d069f011ac06a05d731 526a447046d1429d93bf5dde2e0fc4c5 f64125b6f8e24d069f011ac06a05d731--526a447046d1429d93bf5dde2e0fc4c5 177094a6d58047428ba4acb73efec0bd 526a447046d1429d93bf5dde2e0fc4c5--177094a6d58047428ba4acb73efec0bd 6e7c53bcf3ee49cca1c231d7687ce206 177094a6d58047428ba4acb73efec0bd--6e7c53bcf3ee49cca1c231d7687ce206 cdbeb8a304714ecfbab16beda9a42f02 6e7c53bcf3ee49cca1c231d7687ce206--cdbeb8a304714ecfbab16beda9a42f02 b0a03e21608e4597a47befe32d30f3fe cdbeb8a304714ecfbab16beda9a42f02--b0a03e21608e4597a47befe32d30f3fe 6262144b02f740698698297105745b54 b0a03e21608e4597a47befe32d30f3fe--6262144b02f740698698297105745b54 c1345f26944d48f89ac7d89f8a31743b 6262144b02f740698698297105745b54--c1345f26944d48f89ac7d89f8a31743b 423b67b762474053875b8fa47b0484f4 c1345f26944d48f89ac7d89f8a31743b--423b67b762474053875b8fa47b0484f4 347c7e31bf44470d801aa324df4df2f9 423b67b762474053875b8fa47b0484f4--347c7e31bf44470d801aa324df4df2f9 794ff13c8e3a40f4a2b493611cfba3b2 347c7e31bf44470d801aa324df4df2f9--794ff13c8e3a40f4a2b493611cfba3b2 72ca119dda284221a0a46f0f3ee1f476 794ff13c8e3a40f4a2b493611cfba3b2--72ca119dda284221a0a46f0f3ee1f476 594086e991444e60b2d866f88af4477c 72ca119dda284221a0a46f0f3ee1f476--594086e991444e60b2d866f88af4477c 1082193c72f547feb3b8cfda00e4652f 594086e991444e60b2d866f88af4477c--1082193c72f547feb3b8cfda00e4652f a9f67f4f80ab434fb3880b3a144c609a 1082193c72f547feb3b8cfda00e4652f--a9f67f4f80ab434fb3880b3a144c609a be09a067a7834142810722f60034f2c7 a9f67f4f80ab434fb3880b3a144c609a--be09a067a7834142810722f60034f2c7 0235c7258484432ebcc03462d49c48e1 be09a067a7834142810722f60034f2c7--0235c7258484432ebcc03462d49c48e1 8d940398603d4622b85c703f12ff03db 0235c7258484432ebcc03462d49c48e1--8d940398603d4622b85c703f12ff03db a1b67867bf9b4bd1bb57076de302b7a3 8d940398603d4622b85c703f12ff03db--a1b67867bf9b4bd1bb57076de302b7a3 f36080a18f6d4e3189562e99325c923b a1b67867bf9b4bd1bb57076de302b7a3--f36080a18f6d4e3189562e99325c923b 202b878d789c4b58bf4c03fc391d0a87 f36080a18f6d4e3189562e99325c923b--202b878d789c4b58bf4c03fc391d0a87 d00783b5d1c4493395e9ba276bf56e39 202b878d789c4b58bf4c03fc391d0a87--d00783b5d1c4493395e9ba276bf56e39 28bce670f4344dc68e1489339e16e25f d00783b5d1c4493395e9ba276bf56e39--28bce670f4344dc68e1489339e16e25f 5966bebc4daa4f7d9a75e25a9a437dca 28bce670f4344dc68e1489339e16e25f--5966bebc4daa4f7d9a75e25a9a437dca eaf62d0e63634ebfbf6c9a7b66de3496 5966bebc4daa4f7d9a75e25a9a437dca--eaf62d0e63634ebfbf6c9a7b66de3496 8bb05d01baa24ea9bdb710b9e9e86a7f eaf62d0e63634ebfbf6c9a7b66de3496--8bb05d01baa24ea9bdb710b9e9e86a7f e8c42296bffe403d84115113fc122f5b 8bb05d01baa24ea9bdb710b9e9e86a7f--e8c42296bffe403d84115113fc122f5b 8a6ae5964851403cbc5180c1a67599ad e8c42296bffe403d84115113fc122f5b--8a6ae5964851403cbc5180c1a67599ad db5ea64c77b146e988d478a88eb7b521 8a6ae5964851403cbc5180c1a67599ad--db5ea64c77b146e988d478a88eb7b521 73840299493045b7a790aff8efb2cce6 db5ea64c77b146e988d478a88eb7b521--73840299493045b7a790aff8efb2cce6 2175e3d220db4d5d97c4c81fbfee1f91 73840299493045b7a790aff8efb2cce6--2175e3d220db4d5d97c4c81fbfee1f91 0a7118dbaec0453988a7194154b21f53 2175e3d220db4d5d97c4c81fbfee1f91--0a7118dbaec0453988a7194154b21f53 0889228e71174b93a2f8bbf3e8901ee8 0a7118dbaec0453988a7194154b21f53--0889228e71174b93a2f8bbf3e8901ee8 525f58511db54745889a766d93921680 0889228e71174b93a2f8bbf3e8901ee8--525f58511db54745889a766d93921680 b589ae7c12bd4929890be5d2f29c3a4b 525f58511db54745889a766d93921680--b589ae7c12bd4929890be5d2f29c3a4b a7a1793cda1b4a708abf62cfca5f0032 b589ae7c12bd4929890be5d2f29c3a4b--a7a1793cda1b4a708abf62cfca5f0032 94d55653c9564c76865fadff80dd590f a7a1793cda1b4a708abf62cfca5f0032--94d55653c9564c76865fadff80dd590f 562001e4a521407eb51508eb2d6333a2 94d55653c9564c76865fadff80dd590f--562001e4a521407eb51508eb2d6333a2 6661fedeb0914977b625cb69e938688f 562001e4a521407eb51508eb2d6333a2--6661fedeb0914977b625cb69e938688f ae6d879f63134044a01c743654f76058 6661fedeb0914977b625cb69e938688f--ae6d879f63134044a01c743654f76058 40f3512dae184969b9bc37cb3ab1f0c0 ae6d879f63134044a01c743654f76058--40f3512dae184969b9bc37cb3ab1f0c0 7a7bc83957dc48918c4be7c50c9f94d0 40f3512dae184969b9bc37cb3ab1f0c0--7a7bc83957dc48918c4be7c50c9f94d0 d7c9e23c8ed0452888f550e49d1a23b0 7a7bc83957dc48918c4be7c50c9f94d0--d7c9e23c8ed0452888f550e49d1a23b0 89feebb7e67e49cbaf1383a27c9a77a3 d7c9e23c8ed0452888f550e49d1a23b0--89feebb7e67e49cbaf1383a27c9a77a3 dc12005a11024a41b208ed6c9e008195 89feebb7e67e49cbaf1383a27c9a77a3--dc12005a11024a41b208ed6c9e008195 56b91cafa05244ec96b31770414948d3 dc12005a11024a41b208ed6c9e008195--56b91cafa05244ec96b31770414948d3 bd5d1e2283bd42a8a202f5511f6b9258 56b91cafa05244ec96b31770414948d3--bd5d1e2283bd42a8a202f5511f6b9258 36d741c1a5574d0c849d8e8e8ecdac8a bd5d1e2283bd42a8a202f5511f6b9258--36d741c1a5574d0c849d8e8e8ecdac8a 5671b66d20d1486294612118dc16373c 36d741c1a5574d0c849d8e8e8ecdac8a--5671b66d20d1486294612118dc16373c 4908dc801fee4d068592090ec3d6c36e 5671b66d20d1486294612118dc16373c--4908dc801fee4d068592090ec3d6c36e e8e9764507754d08b2f9c51f5433f9b7 4908dc801fee4d068592090ec3d6c36e--e8e9764507754d08b2f9c51f5433f9b7 46f5f89811b841289551a95f3fa80325 e8e9764507754d08b2f9c51f5433f9b7--46f5f89811b841289551a95f3fa80325 dc4f2b34c6d74b329cf29fe1870c089d 46f5f89811b841289551a95f3fa80325--dc4f2b34c6d74b329cf29fe1870c089d 46dd0d37a2624624af15b51eb5ca87d6 dc4f2b34c6d74b329cf29fe1870c089d--46dd0d37a2624624af15b51eb5ca87d6 c53a7f9750d640b6b24192770c1e38b4 46dd0d37a2624624af15b51eb5ca87d6--c53a7f9750d640b6b24192770c1e38b4 1223bd4408a14de8bca70ecb7a2f698b c53a7f9750d640b6b24192770c1e38b4--1223bd4408a14de8bca70ecb7a2f698b b797678df0014d939d8846d755864576 1223bd4408a14de8bca70ecb7a2f698b--b797678df0014d939d8846d755864576 a8c1ff5f101740ccbe4f5cba98864001 b797678df0014d939d8846d755864576--a8c1ff5f101740ccbe4f5cba98864001 32e3e0dcb46943cbb7ac94019afbd895 a8c1ff5f101740ccbe4f5cba98864001--32e3e0dcb46943cbb7ac94019afbd895 073feacbce65490ab838037701fc73d1 32e3e0dcb46943cbb7ac94019afbd895--073feacbce65490ab838037701fc73d1 b81b51c5f4a147b3bad00f13f62594d7 073feacbce65490ab838037701fc73d1--b81b51c5f4a147b3bad00f13f62594d7 8da231f89aad4c26842c895c82063bf1 b81b51c5f4a147b3bad00f13f62594d7--8da231f89aad4c26842c895c82063bf1 9046cee7abb0477d8badfa2a8306f8b4 8da231f89aad4c26842c895c82063bf1--9046cee7abb0477d8badfa2a8306f8b4 ec8a6c19586446548266f1d6f2271ce8 9046cee7abb0477d8badfa2a8306f8b4--ec8a6c19586446548266f1d6f2271ce8 63b48617711e46f09cb3c56a3343fa34 ec8a6c19586446548266f1d6f2271ce8--63b48617711e46f09cb3c56a3343fa34 4ebb7d2702ec40058f12f3b565446706 63b48617711e46f09cb3c56a3343fa34--4ebb7d2702ec40058f12f3b565446706 bef1ded51e924413bada44c58f670eec 4ebb7d2702ec40058f12f3b565446706--bef1ded51e924413bada44c58f670eec cb23e89d63d14e80bfc1040e549b8243 bef1ded51e924413bada44c58f670eec--cb23e89d63d14e80bfc1040e549b8243 a9340d3f31f0483aa533b3e79c5ed9f1 cb23e89d63d14e80bfc1040e549b8243--a9340d3f31f0483aa533b3e79c5ed9f1 7ed8cfdf51c3426081aaeb52735b8768 a9340d3f31f0483aa533b3e79c5ed9f1--7ed8cfdf51c3426081aaeb52735b8768 4884f21e7f2f499b9ce8a9a6b8ecc6b9 7ed8cfdf51c3426081aaeb52735b8768--4884f21e7f2f499b9ce8a9a6b8ecc6b9 93286155eb3f4490adc3f463002b5644 4884f21e7f2f499b9ce8a9a6b8ecc6b9--93286155eb3f4490adc3f463002b5644 5d9e76fd96474184b37debfd39528483 93286155eb3f4490adc3f463002b5644--5d9e76fd96474184b37debfd39528483 03ea0a30e8dc4607b3045ee0a4f59070 5d9e76fd96474184b37debfd39528483--03ea0a30e8dc4607b3045ee0a4f59070 b31a2bde226e46e9a76e06a6c2f23550 03ea0a30e8dc4607b3045ee0a4f59070--b31a2bde226e46e9a76e06a6c2f23550 deca8368ba44443499a6721b56d2de43 b31a2bde226e46e9a76e06a6c2f23550--deca8368ba44443499a6721b56d2de43 50172f5f7b7a4635ae236f4ae8434219 deca8368ba44443499a6721b56d2de43--50172f5f7b7a4635ae236f4ae8434219 57c454926f3e408eb663e9a6207c702d 50172f5f7b7a4635ae236f4ae8434219--57c454926f3e408eb663e9a6207c702d 63359592530f44acb6a673d52e0dda4e 57c454926f3e408eb663e9a6207c702d--63359592530f44acb6a673d52e0dda4e 938c192ee0a34d3ebd414deb5bd7ed0f 63359592530f44acb6a673d52e0dda4e--938c192ee0a34d3ebd414deb5bd7ed0f 8ef756a8ebab48c7b01907ee6deac730 RX(b01) 938c192ee0a34d3ebd414deb5bd7ed0f--8ef756a8ebab48c7b01907ee6deac730 6c857113d2d54e1da9fb98bb5ef6a6ce X 8ef756a8ebab48c7b01907ee6deac730--6c857113d2d54e1da9fb98bb5ef6a6ce 6c857113d2d54e1da9fb98bb5ef6a6ce--5a9d2e805a514850bfe463ee361df883 2e60d9ca9ce44a02b2868672dd8c7b97 6c857113d2d54e1da9fb98bb5ef6a6ce--2e60d9ca9ce44a02b2868672dd8c7b97 50c9cb34f7524dfb91327f80b897fcd0 2e60d9ca9ce44a02b2868672dd8c7b97--50c9cb34f7524dfb91327f80b897fcd0 bbfe709d62e94b16a6d3e2571b19233d 50c9cb34f7524dfb91327f80b897fcd0--bbfe709d62e94b16a6d3e2571b19233d d55fa912e4c44530a637b0059ed8fe91 bbfe709d62e94b16a6d3e2571b19233d--d55fa912e4c44530a637b0059ed8fe91 0cd1aecdc2f542c2a595306201b99059 d55fa912e4c44530a637b0059ed8fe91--0cd1aecdc2f542c2a595306201b99059 e7c72c7ca80a41bd839652eed5116dac 0cd1aecdc2f542c2a595306201b99059--e7c72c7ca80a41bd839652eed5116dac f27a7a88ce1e4866b30b6ae9071df811 e7c72c7ca80a41bd839652eed5116dac--f27a7a88ce1e4866b30b6ae9071df811 a213c319d65f4675bbb1bc328321a8ee f27a7a88ce1e4866b30b6ae9071df811--a213c319d65f4675bbb1bc328321a8ee 0c7d5fd0f1274a7bb3b45f2cc2d587cc a213c319d65f4675bbb1bc328321a8ee--0c7d5fd0f1274a7bb3b45f2cc2d587cc aa7a726b5bb7442ca71fc3832602c343 0c7d5fd0f1274a7bb3b45f2cc2d587cc--aa7a726b5bb7442ca71fc3832602c343 0af010fbca644fb485084ddf5c73aa25 aa7a726b5bb7442ca71fc3832602c343--0af010fbca644fb485084ddf5c73aa25 485039afe17f45e495f537ed79ebb963 0af010fbca644fb485084ddf5c73aa25--485039afe17f45e495f537ed79ebb963 992cf3c46b6a4fc18e5f994a8305ebc7 485039afe17f45e495f537ed79ebb963--992cf3c46b6a4fc18e5f994a8305ebc7 dd712ae2764e4fb796607f75ff05fee4 X 992cf3c46b6a4fc18e5f994a8305ebc7--dd712ae2764e4fb796607f75ff05fee4 dd712ae2764e4fb796607f75ff05fee4--c16fe35f8e744a92aa34d310e25e3ea8 b08d8771a4a34c35b1fa4db6974b8a9c X dd712ae2764e4fb796607f75ff05fee4--b08d8771a4a34c35b1fa4db6974b8a9c b08d8771a4a34c35b1fa4db6974b8a9c--b714025564dd4632a1fc1dee67858d39 96c3c19b76db4ce9a6c698fc6da3767e RZ(-1.0*g1) b08d8771a4a34c35b1fa4db6974b8a9c--96c3c19b76db4ce9a6c698fc6da3767e 054f3c545dd140cdb2c21484c126cb20 X 96c3c19b76db4ce9a6c698fc6da3767e--054f3c545dd140cdb2c21484c126cb20 054f3c545dd140cdb2c21484c126cb20--a0cf5ef05fd24a27a4a232a5ef6fdb47 e465530cff4d428281eff95bdd78c654 X 054f3c545dd140cdb2c21484c126cb20--e465530cff4d428281eff95bdd78c654 e465530cff4d428281eff95bdd78c654--c9d793f9a1ab49fbb61d8f0aaac8d4a8 a7842f5eef704f138bd8b377fe752fe5 e465530cff4d428281eff95bdd78c654--a7842f5eef704f138bd8b377fe752fe5 af8ffd5189f344d09bfa94aed5cd9eb3 a7842f5eef704f138bd8b377fe752fe5--af8ffd5189f344d09bfa94aed5cd9eb3 c32dffbdccdf4f19bce4e2361854d018 af8ffd5189f344d09bfa94aed5cd9eb3--c32dffbdccdf4f19bce4e2361854d018 4692872043ca4beb8be22265c22a9a88 c32dffbdccdf4f19bce4e2361854d018--4692872043ca4beb8be22265c22a9a88 6c0ae7ffaa0d4f1286e728001392997a 4692872043ca4beb8be22265c22a9a88--6c0ae7ffaa0d4f1286e728001392997a acce3b5067b946808979a62967b19e57 6c0ae7ffaa0d4f1286e728001392997a--acce3b5067b946808979a62967b19e57 059c36815c924b87b83c73b07b0a5147 acce3b5067b946808979a62967b19e57--059c36815c924b87b83c73b07b0a5147 3b74e9984f5849a0b8c6572210196ea0 059c36815c924b87b83c73b07b0a5147--3b74e9984f5849a0b8c6572210196ea0 b22c6e64516b46a4aef397e25d247bb1 3b74e9984f5849a0b8c6572210196ea0--b22c6e64516b46a4aef397e25d247bb1 a5fec487edba4745a8de9a5e152b1102 X b22c6e64516b46a4aef397e25d247bb1--a5fec487edba4745a8de9a5e152b1102 a5fec487edba4745a8de9a5e152b1102--18e1aaeb2f954742a858f7b62d72d395 5f6e0527297943f089d4c7542b4ccf77 X a5fec487edba4745a8de9a5e152b1102--5f6e0527297943f089d4c7542b4ccf77 5f6e0527297943f089d4c7542b4ccf77--7014a63347b74f0bba7afeefe1330d82 1091de4fada6482da43b6d308efed1b4 5f6e0527297943f089d4c7542b4ccf77--1091de4fada6482da43b6d308efed1b4 ec1160f1590b4e46bf1badbe31910ca9 1091de4fada6482da43b6d308efed1b4--ec1160f1590b4e46bf1badbe31910ca9 d864dd5ceb5b45e9bc87ca4cc14d4d1d ec1160f1590b4e46bf1badbe31910ca9--d864dd5ceb5b45e9bc87ca4cc14d4d1d b2f7a319e49d4d90adf6d07930401eae d864dd5ceb5b45e9bc87ca4cc14d4d1d--b2f7a319e49d4d90adf6d07930401eae abaa6a99b2c540288798787bdb4b391a b2f7a319e49d4d90adf6d07930401eae--abaa6a99b2c540288798787bdb4b391a 981e245141b04403a971998ead57b02e abaa6a99b2c540288798787bdb4b391a--981e245141b04403a971998ead57b02e 24389d3bbb6940ee893699950cda8ef7 981e245141b04403a971998ead57b02e--24389d3bbb6940ee893699950cda8ef7 569ee8281d7c48159985c39fab107175 24389d3bbb6940ee893699950cda8ef7--569ee8281d7c48159985c39fab107175 cbe6e369dbbe4f9da7fe3a0595b11063 569ee8281d7c48159985c39fab107175--cbe6e369dbbe4f9da7fe3a0595b11063 cba59cd06cab4241b304d8f223caff3b cbe6e369dbbe4f9da7fe3a0595b11063--cba59cd06cab4241b304d8f223caff3b ec355cc401534a319a16cae2d45d122c cba59cd06cab4241b304d8f223caff3b--ec355cc401534a319a16cae2d45d122c 03dc4f3039de4ed9bf87e4c209a98fd2 X ec355cc401534a319a16cae2d45d122c--03dc4f3039de4ed9bf87e4c209a98fd2 03dc4f3039de4ed9bf87e4c209a98fd2--ef6b7161bdee4a9b802fcd2f769c1044 706ab961eaf2491b8d1f3c02395f1c39 X 03dc4f3039de4ed9bf87e4c209a98fd2--706ab961eaf2491b8d1f3c02395f1c39 706ab961eaf2491b8d1f3c02395f1c39--ba7b1dfadad543069c9e2ec66c250ed9 f00d1505800e40778a3404ff4eb461c9 706ab961eaf2491b8d1f3c02395f1c39--f00d1505800e40778a3404ff4eb461c9 caa890fdb7694c0585b8e1d39e0bbc9a f00d1505800e40778a3404ff4eb461c9--caa890fdb7694c0585b8e1d39e0bbc9a 8438ae3a5de5482296565830395e1093 caa890fdb7694c0585b8e1d39e0bbc9a--8438ae3a5de5482296565830395e1093 d97c7962558c4be797eb0bf1fddfec63 8438ae3a5de5482296565830395e1093--d97c7962558c4be797eb0bf1fddfec63 1df249518ead47adbe38cbb01b47ca42 d97c7962558c4be797eb0bf1fddfec63--1df249518ead47adbe38cbb01b47ca42 06b6664bb04f47dc8cd8284e37f3189f 1df249518ead47adbe38cbb01b47ca42--06b6664bb04f47dc8cd8284e37f3189f 2ff90b54307245aea75e02f4ae4c4e88 06b6664bb04f47dc8cd8284e37f3189f--2ff90b54307245aea75e02f4ae4c4e88 7471e49c549c42a3a82a7fc795ccd48a 2ff90b54307245aea75e02f4ae4c4e88--7471e49c549c42a3a82a7fc795ccd48a a6c61dfb3a7b46489d5ab2300e0a54f4 7471e49c549c42a3a82a7fc795ccd48a--a6c61dfb3a7b46489d5ab2300e0a54f4 3c50247436a547b48c5fa5b33db6624c a6c61dfb3a7b46489d5ab2300e0a54f4--3c50247436a547b48c5fa5b33db6624c 60eba5c4bc3b41979e1fe7669807ed65 3c50247436a547b48c5fa5b33db6624c--60eba5c4bc3b41979e1fe7669807ed65 7c0fa145855441d3b7e94ad951e58b36 60eba5c4bc3b41979e1fe7669807ed65--7c0fa145855441d3b7e94ad951e58b36 2e48264ff52b4d858d03b2fd3b60429f 7c0fa145855441d3b7e94ad951e58b36--2e48264ff52b4d858d03b2fd3b60429f bac33baf83004252bc903584ea140a88 X 2e48264ff52b4d858d03b2fd3b60429f--bac33baf83004252bc903584ea140a88 bac33baf83004252bc903584ea140a88--55da6148086e4a85bcd3b0d98b448eb0 30e0e9b2bf0f4ddcbbd2c5ad7b8a8075 bac33baf83004252bc903584ea140a88--30e0e9b2bf0f4ddcbbd2c5ad7b8a8075 e398cdb7b60c40aead00bd70f989c6cb 30e0e9b2bf0f4ddcbbd2c5ad7b8a8075--e398cdb7b60c40aead00bd70f989c6cb f1fb46d632494374b6c3a24eb0046aa4 e398cdb7b60c40aead00bd70f989c6cb--f1fb46d632494374b6c3a24eb0046aa4 3c10d7c0a7a84e829ee107b6843e8545 f1fb46d632494374b6c3a24eb0046aa4--3c10d7c0a7a84e829ee107b6843e8545 07178548dddb46b4bb51b267d3569883 3c10d7c0a7a84e829ee107b6843e8545--07178548dddb46b4bb51b267d3569883 1306ac11607f4b0a85ad4490b698742a 07178548dddb46b4bb51b267d3569883--1306ac11607f4b0a85ad4490b698742a 0d9844d9970943c685946ec287befa06 1306ac11607f4b0a85ad4490b698742a--0d9844d9970943c685946ec287befa06 9b4b484d27794b25b2db411a4d12a055 0d9844d9970943c685946ec287befa06--9b4b484d27794b25b2db411a4d12a055 e81f492585e54105b03c79e534026eff 9b4b484d27794b25b2db411a4d12a055--e81f492585e54105b03c79e534026eff fcebb71b8b4d449786bab2bb5766a600 e81f492585e54105b03c79e534026eff--fcebb71b8b4d449786bab2bb5766a600 66212c33effe4b54b2a9fd1438adf0c4 fcebb71b8b4d449786bab2bb5766a600--66212c33effe4b54b2a9fd1438adf0c4 538f19ce7b2445d9b3a40f5458de310b 66212c33effe4b54b2a9fd1438adf0c4--538f19ce7b2445d9b3a40f5458de310b 209571b4cf1149b294406b46717fd891 538f19ce7b2445d9b3a40f5458de310b--209571b4cf1149b294406b46717fd891 b2411010d65b4ccd9b5b1c95478e0118 209571b4cf1149b294406b46717fd891--b2411010d65b4ccd9b5b1c95478e0118 ee6d5a3d9d4a4266a4aabea9365303e5 b2411010d65b4ccd9b5b1c95478e0118--ee6d5a3d9d4a4266a4aabea9365303e5 6774a02d541543a1af24e824ba01416e ee6d5a3d9d4a4266a4aabea9365303e5--6774a02d541543a1af24e824ba01416e 00678448432446009f2630575cfe1faf 6774a02d541543a1af24e824ba01416e--00678448432446009f2630575cfe1faf 38340889c0b047098a60cc19720a30fe 00678448432446009f2630575cfe1faf--38340889c0b047098a60cc19720a30fe 5222404836444fe88946a0da02035a8d 38340889c0b047098a60cc19720a30fe--5222404836444fe88946a0da02035a8d 916e7b52b64940db9c0b0df92cf3a71e 5222404836444fe88946a0da02035a8d--916e7b52b64940db9c0b0df92cf3a71e fe1ed8e0be9f451f9f4ea3aa745b27df 916e7b52b64940db9c0b0df92cf3a71e--fe1ed8e0be9f451f9f4ea3aa745b27df a2ab4307c99e48e9854dd6ff9aad1f6a fe1ed8e0be9f451f9f4ea3aa745b27df--a2ab4307c99e48e9854dd6ff9aad1f6a 86cceefe8b4347d697f11adf7d95e173 a2ab4307c99e48e9854dd6ff9aad1f6a--86cceefe8b4347d697f11adf7d95e173 e4f0608837af4cf08bcdf4ea6772e5ef 86cceefe8b4347d697f11adf7d95e173--e4f0608837af4cf08bcdf4ea6772e5ef b655fa1d0b3840a99bb66222ba0a6d20 e4f0608837af4cf08bcdf4ea6772e5ef--b655fa1d0b3840a99bb66222ba0a6d20 173ab196a9e94c20bdce3966f82fc990 b655fa1d0b3840a99bb66222ba0a6d20--173ab196a9e94c20bdce3966f82fc990 26070cec699743b294bf30c0922f9563 173ab196a9e94c20bdce3966f82fc990--26070cec699743b294bf30c0922f9563 7f04f41da1ba45f2b62c32510b8096c0 26070cec699743b294bf30c0922f9563--7f04f41da1ba45f2b62c32510b8096c0 d2a2b7e130694591a6a36bfffb01bd23 7f04f41da1ba45f2b62c32510b8096c0--d2a2b7e130694591a6a36bfffb01bd23 9bf91e9d295147a0bb7463d3af0b9be2 d2a2b7e130694591a6a36bfffb01bd23--9bf91e9d295147a0bb7463d3af0b9be2 bf373439daf943a6b92617711489890a 9bf91e9d295147a0bb7463d3af0b9be2--bf373439daf943a6b92617711489890a 80d3d62f4ffa41b180f77681abce5550 bf373439daf943a6b92617711489890a--80d3d62f4ffa41b180f77681abce5550 216a2b3a82b24814be96a2ba26606b42 80d3d62f4ffa41b180f77681abce5550--216a2b3a82b24814be96a2ba26606b42 28423fdf3faa40978a861799df6aabc7 216a2b3a82b24814be96a2ba26606b42--28423fdf3faa40978a861799df6aabc7 ed3d10fafebd429c8d7f1f64e6468202 28423fdf3faa40978a861799df6aabc7--ed3d10fafebd429c8d7f1f64e6468202 5185de66e9114c5cb026c71fbe75b769 ed3d10fafebd429c8d7f1f64e6468202--5185de66e9114c5cb026c71fbe75b769 44fb261c11564f31bd3abe568b427004 5185de66e9114c5cb026c71fbe75b769--44fb261c11564f31bd3abe568b427004 7840cc36b6ff4ab096722c138dfda8f2 44fb261c11564f31bd3abe568b427004--7840cc36b6ff4ab096722c138dfda8f2 5eed20143f63452cbdb5f4fa8e58095e 7840cc36b6ff4ab096722c138dfda8f2--5eed20143f63452cbdb5f4fa8e58095e c156812013654e32a1a8c852fccc5ba7 5eed20143f63452cbdb5f4fa8e58095e--c156812013654e32a1a8c852fccc5ba7 67a0151c57b04940afe4bfab57f9c8ea c156812013654e32a1a8c852fccc5ba7--67a0151c57b04940afe4bfab57f9c8ea 15829500a71e4b0bbf02a3832c71e26c 67a0151c57b04940afe4bfab57f9c8ea--15829500a71e4b0bbf02a3832c71e26c 3729f63aa1894e6d8b2e097b96a35aa1 15829500a71e4b0bbf02a3832c71e26c--3729f63aa1894e6d8b2e097b96a35aa1 72752b0ed77a4d35ac6fe77a1342d7ba 3729f63aa1894e6d8b2e097b96a35aa1--72752b0ed77a4d35ac6fe77a1342d7ba 6f56674c34a645e78e8b8e090ebdf727 72752b0ed77a4d35ac6fe77a1342d7ba--6f56674c34a645e78e8b8e090ebdf727 b423c1b0b7b54625a363602bfc3bdcfc 6f56674c34a645e78e8b8e090ebdf727--b423c1b0b7b54625a363602bfc3bdcfc 14f1d7cd9dc8474cb7ee829141b5252d b423c1b0b7b54625a363602bfc3bdcfc--14f1d7cd9dc8474cb7ee829141b5252d 60eba3e9d1644afabd7326ca20e1e99f 14f1d7cd9dc8474cb7ee829141b5252d--60eba3e9d1644afabd7326ca20e1e99f cc8042aed39c402ba78e038819be60f3 60eba3e9d1644afabd7326ca20e1e99f--cc8042aed39c402ba78e038819be60f3 4ce488f8d3b840de9b7d3bda1d360277 cc8042aed39c402ba78e038819be60f3--4ce488f8d3b840de9b7d3bda1d360277 a1318586ba194f9a8b15f4c973bd8d4e 4ce488f8d3b840de9b7d3bda1d360277--a1318586ba194f9a8b15f4c973bd8d4e f5417f5cfb4a4971a0be1c7d43b87afa a1318586ba194f9a8b15f4c973bd8d4e--f5417f5cfb4a4971a0be1c7d43b87afa d5acc3da6e664052a00ef044bee083b0 f5417f5cfb4a4971a0be1c7d43b87afa--d5acc3da6e664052a00ef044bee083b0 da45cff27203446d931abd8e46f5571c d5acc3da6e664052a00ef044bee083b0--da45cff27203446d931abd8e46f5571c a5866d9d65dd423a94720645a6f3b9f1 da45cff27203446d931abd8e46f5571c--a5866d9d65dd423a94720645a6f3b9f1 5876a17fba264e2da1ab0bf6770db4d2 a5866d9d65dd423a94720645a6f3b9f1--5876a17fba264e2da1ab0bf6770db4d2 a0deff1ba0e447ff8f9f50b6d4ea4934 5876a17fba264e2da1ab0bf6770db4d2--a0deff1ba0e447ff8f9f50b6d4ea4934 96de953e3ded47b4831c4d002a1c7419 a0deff1ba0e447ff8f9f50b6d4ea4934--96de953e3ded47b4831c4d002a1c7419 a977fd54401d4d8e9bbd0482e0f8eab7 96de953e3ded47b4831c4d002a1c7419--a977fd54401d4d8e9bbd0482e0f8eab7 75370ce6ff684f09ae2c2b4bb767ab5f a977fd54401d4d8e9bbd0482e0f8eab7--75370ce6ff684f09ae2c2b4bb767ab5f 292f33d3d37b44218cda286af676b959 75370ce6ff684f09ae2c2b4bb767ab5f--292f33d3d37b44218cda286af676b959 8b637eb9a8d846c7aa5f48a844f37b59 292f33d3d37b44218cda286af676b959--8b637eb9a8d846c7aa5f48a844f37b59 f66e80526b84413d9e37cf857292a5d7 8b637eb9a8d846c7aa5f48a844f37b59--f66e80526b84413d9e37cf857292a5d7 6c78ac58455242869a1adddd51fb9264 f66e80526b84413d9e37cf857292a5d7--6c78ac58455242869a1adddd51fb9264 06da8b7034e64b7e9d2e0da3fc5dabd2 6c78ac58455242869a1adddd51fb9264--06da8b7034e64b7e9d2e0da3fc5dabd2 8014bcacb0b44beba2d67b47333c64bb 06da8b7034e64b7e9d2e0da3fc5dabd2--8014bcacb0b44beba2d67b47333c64bb 3fad68af8a544ee3b88c45f03b140612 8014bcacb0b44beba2d67b47333c64bb--3fad68af8a544ee3b88c45f03b140612 eccb7cc5f0224c9d81403180a020b7f5 3fad68af8a544ee3b88c45f03b140612--eccb7cc5f0224c9d81403180a020b7f5 87281e9f82ee4f868af5be234b54ce48 eccb7cc5f0224c9d81403180a020b7f5--87281e9f82ee4f868af5be234b54ce48 de7c85a20a9f4cb8ae5d76c7c78ad047 87281e9f82ee4f868af5be234b54ce48--de7c85a20a9f4cb8ae5d76c7c78ad047 fe4e893e537e409da9d47c7e54ad9a1f de7c85a20a9f4cb8ae5d76c7c78ad047--fe4e893e537e409da9d47c7e54ad9a1f e62954cd98c94642b629022fba506a23 fe4e893e537e409da9d47c7e54ad9a1f--e62954cd98c94642b629022fba506a23 5215eb560cce43aaa9b0ab0ce7ecf7c0 e62954cd98c94642b629022fba506a23--5215eb560cce43aaa9b0ab0ce7ecf7c0 bc5f1c6fdff34c5ea2d2cc58c3c8f255 5215eb560cce43aaa9b0ab0ce7ecf7c0--bc5f1c6fdff34c5ea2d2cc58c3c8f255 7afec5ea76bd4b0bb7ffb20fd2180e3c bc5f1c6fdff34c5ea2d2cc58c3c8f255--7afec5ea76bd4b0bb7ffb20fd2180e3c d4b64adaa70e47b6a5f359283f90dd77 7afec5ea76bd4b0bb7ffb20fd2180e3c--d4b64adaa70e47b6a5f359283f90dd77 3e718a2498fb4163b7eaa60e8ff400f1 d4b64adaa70e47b6a5f359283f90dd77--3e718a2498fb4163b7eaa60e8ff400f1 537ff5c0f02b4f86b01da43e486953e1 3e718a2498fb4163b7eaa60e8ff400f1--537ff5c0f02b4f86b01da43e486953e1 4ba14f4b72b542b4bec481b024a195c7 537ff5c0f02b4f86b01da43e486953e1--4ba14f4b72b542b4bec481b024a195c7 731799dce8994a87ae08e7e6455f816a 4ba14f4b72b542b4bec481b024a195c7--731799dce8994a87ae08e7e6455f816a 2cb72530335f4ba387b7010e046334d2 731799dce8994a87ae08e7e6455f816a--2cb72530335f4ba387b7010e046334d2 5d7231dc15b34c1bbcf4e20e8d3a99c4 2cb72530335f4ba387b7010e046334d2--5d7231dc15b34c1bbcf4e20e8d3a99c4 6f94c1217d2f4fcdac03c578a8560376 5d7231dc15b34c1bbcf4e20e8d3a99c4--6f94c1217d2f4fcdac03c578a8560376 3effbbe6920041a4be8d6e48b0fd9673 6f94c1217d2f4fcdac03c578a8560376--3effbbe6920041a4be8d6e48b0fd9673 b4020b9858554b0da0a8bf60fae3c3aa RX(b11) 3effbbe6920041a4be8d6e48b0fd9673--b4020b9858554b0da0a8bf60fae3c3aa b4020b9858554b0da0a8bf60fae3c3aa--435bca5c75ad4d5d99be3987124e4251 4415a31ba4f04813a54d65b86271c50d 0ae8a44c514b4b1f91e8490b48e261a8 9bd92ef7706741998bb1b7d26b16a171--0ae8a44c514b4b1f91e8490b48e261a8 38afdbf1745342c2bab7db8a11b4e56e 3 b985738f100e4fe5bc03ae8c6f4fa94d X 0ae8a44c514b4b1f91e8490b48e261a8--b985738f100e4fe5bc03ae8c6f4fa94d b985738f100e4fe5bc03ae8c6f4fa94d--dc00df7cb9604233b4d8a258946c75af ca92b414af0c4560bc0e3089b89c7e6f b985738f100e4fe5bc03ae8c6f4fa94d--ca92b414af0c4560bc0e3089b89c7e6f adb515a40dc34069a4d298e0da425198 ca92b414af0c4560bc0e3089b89c7e6f--adb515a40dc34069a4d298e0da425198 93e19a2f58e043dd811ec0911ef8aef2 adb515a40dc34069a4d298e0da425198--93e19a2f58e043dd811ec0911ef8aef2 e7c00463850c4fee90cce6b6ed17e4b2 93e19a2f58e043dd811ec0911ef8aef2--e7c00463850c4fee90cce6b6ed17e4b2 8da81142d50a49b7aa32761196ec16f2 e7c00463850c4fee90cce6b6ed17e4b2--8da81142d50a49b7aa32761196ec16f2 17558fca59af430f8fae149343dd2d53 8da81142d50a49b7aa32761196ec16f2--17558fca59af430f8fae149343dd2d53 fc25b51ab06840119ad5b9d366c3a02e 17558fca59af430f8fae149343dd2d53--fc25b51ab06840119ad5b9d366c3a02e fed7f22d660947b484b1badf1df291ad fc25b51ab06840119ad5b9d366c3a02e--fed7f22d660947b484b1badf1df291ad c4ff12ec31224481b403d2fc84738a51 fed7f22d660947b484b1badf1df291ad--c4ff12ec31224481b403d2fc84738a51 d77e3d7c957d4715bcb4074c99f7b83f c4ff12ec31224481b403d2fc84738a51--d77e3d7c957d4715bcb4074c99f7b83f 35f22ed94b9d4b4b941bf0652a223f95 d77e3d7c957d4715bcb4074c99f7b83f--35f22ed94b9d4b4b941bf0652a223f95 866b704a16cc42f3a127999548c31d3a X 35f22ed94b9d4b4b941bf0652a223f95--866b704a16cc42f3a127999548c31d3a 866b704a16cc42f3a127999548c31d3a--44fa2953cfd0427ab66c7a521c1349fd 5838970c029245bdb0432d23155e39ed 866b704a16cc42f3a127999548c31d3a--5838970c029245bdb0432d23155e39ed b0fd87dbc6c74672b886abf707733a11 5838970c029245bdb0432d23155e39ed--b0fd87dbc6c74672b886abf707733a11 f01e0bb7563642b2827fd81a03aa84ad b0fd87dbc6c74672b886abf707733a11--f01e0bb7563642b2827fd81a03aa84ad c7e60f188f4f4a1f85e3b0cd063f54a8 f01e0bb7563642b2827fd81a03aa84ad--c7e60f188f4f4a1f85e3b0cd063f54a8 af4306cc45df4c70bc759313fdf7e129 c7e60f188f4f4a1f85e3b0cd063f54a8--af4306cc45df4c70bc759313fdf7e129 760109fc9db449f9b72e47bccf5775c6 X af4306cc45df4c70bc759313fdf7e129--760109fc9db449f9b72e47bccf5775c6 760109fc9db449f9b72e47bccf5775c6--571cad967c4347909b28a2547bcf4d59 2d982d70c92b444fbfdb1b594fd6a0c7 760109fc9db449f9b72e47bccf5775c6--2d982d70c92b444fbfdb1b594fd6a0c7 c04afb2df700487a8e94b97f6d1fae8f 2d982d70c92b444fbfdb1b594fd6a0c7--c04afb2df700487a8e94b97f6d1fae8f 321b54ff747141318af835d7bd084fec c04afb2df700487a8e94b97f6d1fae8f--321b54ff747141318af835d7bd084fec 62826c73712d4daf9bf1309487a2562d 321b54ff747141318af835d7bd084fec--62826c73712d4daf9bf1309487a2562d e1ba5e79274846488ece9a9dd65243c1 62826c73712d4daf9bf1309487a2562d--e1ba5e79274846488ece9a9dd65243c1 311e8b7b2c384d6ab189d909460568e4 e1ba5e79274846488ece9a9dd65243c1--311e8b7b2c384d6ab189d909460568e4 1381ea1e16444965895eb4f3a07af515 311e8b7b2c384d6ab189d909460568e4--1381ea1e16444965895eb4f3a07af515 e310833ae1ec4e01beaff53828b7858c X 1381ea1e16444965895eb4f3a07af515--e310833ae1ec4e01beaff53828b7858c e310833ae1ec4e01beaff53828b7858c--4bed8342aa844d1d814d79180bf2b267 7c6bef699aaa42efbeb83f2bb03c744a e310833ae1ec4e01beaff53828b7858c--7c6bef699aaa42efbeb83f2bb03c744a 1fe8de237c874cb79171eb8d99ce3587 7c6bef699aaa42efbeb83f2bb03c744a--1fe8de237c874cb79171eb8d99ce3587 54ae626ca1844ad5aa1b366edbcf41e7 X 1fe8de237c874cb79171eb8d99ce3587--54ae626ca1844ad5aa1b366edbcf41e7 54ae626ca1844ad5aa1b366edbcf41e7--4ea338a2aafa48db869169e1169160ea eed1296dbd5c4d21ae8715b39271876f 54ae626ca1844ad5aa1b366edbcf41e7--eed1296dbd5c4d21ae8715b39271876f 0409f9e3cc3540e2b1403e666929b9ef eed1296dbd5c4d21ae8715b39271876f--0409f9e3cc3540e2b1403e666929b9ef c2fa9d8ed88f419db4a0475b1d8656dc 0409f9e3cc3540e2b1403e666929b9ef--c2fa9d8ed88f419db4a0475b1d8656dc 4ebcf3082a934ae39d2b6d4b6fd71375 c2fa9d8ed88f419db4a0475b1d8656dc--4ebcf3082a934ae39d2b6d4b6fd71375 630fa83b79174521842b5949fa0c21f1 4ebcf3082a934ae39d2b6d4b6fd71375--630fa83b79174521842b5949fa0c21f1 eaf712604dfa4def8c4f3f939cfb322e 630fa83b79174521842b5949fa0c21f1--eaf712604dfa4def8c4f3f939cfb322e e603f665bb654ff2af837bad29dabd35 eaf712604dfa4def8c4f3f939cfb322e--e603f665bb654ff2af837bad29dabd35 0c5795f79582441ebd7b4154eb14fc30 e603f665bb654ff2af837bad29dabd35--0c5795f79582441ebd7b4154eb14fc30 f87e88c8c50e492e80a89cea886612ac 0c5795f79582441ebd7b4154eb14fc30--f87e88c8c50e492e80a89cea886612ac eefe0e36a04f4bfdb83e2b87c4696f5e X f87e88c8c50e492e80a89cea886612ac--eefe0e36a04f4bfdb83e2b87c4696f5e eefe0e36a04f4bfdb83e2b87c4696f5e--f09c1985924847a9a11b0cb8ed16074b 434c6501a1a14f6f88cc8afd409ceaf7 eefe0e36a04f4bfdb83e2b87c4696f5e--434c6501a1a14f6f88cc8afd409ceaf7 70fae7be686d4e1ca45ed63bcb58d87b 434c6501a1a14f6f88cc8afd409ceaf7--70fae7be686d4e1ca45ed63bcb58d87b 85120fb4cc484293b6683bb337b47577 X 70fae7be686d4e1ca45ed63bcb58d87b--85120fb4cc484293b6683bb337b47577 85120fb4cc484293b6683bb337b47577--bd5ad556ca1a49efa2d0796bf1031f82 7c37f76467d9446183a936a2d4b3a76e 85120fb4cc484293b6683bb337b47577--7c37f76467d9446183a936a2d4b3a76e 49508117e5e64769a2cfdbb09f68c482 7c37f76467d9446183a936a2d4b3a76e--49508117e5e64769a2cfdbb09f68c482 5b23772f55094b7695baafce42f5f0a7 49508117e5e64769a2cfdbb09f68c482--5b23772f55094b7695baafce42f5f0a7 5f0ba712420449fbaa9462f5f4d462f8 5b23772f55094b7695baafce42f5f0a7--5f0ba712420449fbaa9462f5f4d462f8 a84b6f0cbabe4a02aa9c13e5e4ab5601 5f0ba712420449fbaa9462f5f4d462f8--a84b6f0cbabe4a02aa9c13e5e4ab5601 b6dc2b9378c04d4ba68cbd5c8fe8d137 a84b6f0cbabe4a02aa9c13e5e4ab5601--b6dc2b9378c04d4ba68cbd5c8fe8d137 a796062382354147b90ed032895693dd b6dc2b9378c04d4ba68cbd5c8fe8d137--a796062382354147b90ed032895693dd 2487f1e21310400e9bfb052622704e2d a796062382354147b90ed032895693dd--2487f1e21310400e9bfb052622704e2d 48927240c4d94972a8cc36ea3071a134 2487f1e21310400e9bfb052622704e2d--48927240c4d94972a8cc36ea3071a134 e9d6e32715cd4b56a606d34e1508798d 48927240c4d94972a8cc36ea3071a134--e9d6e32715cd4b56a606d34e1508798d b70acae1886644d8a88024e67e6211f4 e9d6e32715cd4b56a606d34e1508798d--b70acae1886644d8a88024e67e6211f4 558de9b24c7842e08857e4144a86c2df X b70acae1886644d8a88024e67e6211f4--558de9b24c7842e08857e4144a86c2df 558de9b24c7842e08857e4144a86c2df--2839895ae9ac43ccbc189e14d4af6e96 b58de3f5b9204fae81900ed403ab245b 558de9b24c7842e08857e4144a86c2df--b58de3f5b9204fae81900ed403ab245b 984d3ec6778c452983ebc1cb4dcaa04f X b58de3f5b9204fae81900ed403ab245b--984d3ec6778c452983ebc1cb4dcaa04f 984d3ec6778c452983ebc1cb4dcaa04f--67ef723693b04b16a8ba96f12ba09a64 705c6f94cefe4452b5c8419659950500 RZ(-1.0*g0) 984d3ec6778c452983ebc1cb4dcaa04f--705c6f94cefe4452b5c8419659950500 93d5b0d7e7a846ab914a5a52b31bee15 X 705c6f94cefe4452b5c8419659950500--93d5b0d7e7a846ab914a5a52b31bee15 93d5b0d7e7a846ab914a5a52b31bee15--df9293afd5d44433b3b2830c441f7196 a1b9b3411caa4e8984084cc0db8e8e56 X 93d5b0d7e7a846ab914a5a52b31bee15--a1b9b3411caa4e8984084cc0db8e8e56 a1b9b3411caa4e8984084cc0db8e8e56--bcfd07d4ec16417c92127160c8caedaf 65df572af5b94ccda8964b5ee771380e a1b9b3411caa4e8984084cc0db8e8e56--65df572af5b94ccda8964b5ee771380e 29928bc912e94476a0f855e343fbb6ba 65df572af5b94ccda8964b5ee771380e--29928bc912e94476a0f855e343fbb6ba 09e2e03b087641809a12b08f3fdc3eb8 29928bc912e94476a0f855e343fbb6ba--09e2e03b087641809a12b08f3fdc3eb8 023336e384c746fa9e13e899f0edd464 09e2e03b087641809a12b08f3fdc3eb8--023336e384c746fa9e13e899f0edd464 66e07147d7184d309f2f4408b26448c6 023336e384c746fa9e13e899f0edd464--66e07147d7184d309f2f4408b26448c6 8f3843c6b98545f8850a6f879a3802fe 66e07147d7184d309f2f4408b26448c6--8f3843c6b98545f8850a6f879a3802fe 032745da27e64564a0d3ca2d593b3050 8f3843c6b98545f8850a6f879a3802fe--032745da27e64564a0d3ca2d593b3050 c86921c8ae97472089856fd773df50ff X 032745da27e64564a0d3ca2d593b3050--c86921c8ae97472089856fd773df50ff c86921c8ae97472089856fd773df50ff--c1345f26944d48f89ac7d89f8a31743b 3054f170257142ff8720e0dda9372331 X c86921c8ae97472089856fd773df50ff--3054f170257142ff8720e0dda9372331 3054f170257142ff8720e0dda9372331--423b67b762474053875b8fa47b0484f4 24d824efed73439b9a80b34d95750685 3054f170257142ff8720e0dda9372331--24d824efed73439b9a80b34d95750685 d07c248c9cb04885a552c04fa68315b5 24d824efed73439b9a80b34d95750685--d07c248c9cb04885a552c04fa68315b5 3a04f15675f6459daab1585d8174e9ef d07c248c9cb04885a552c04fa68315b5--3a04f15675f6459daab1585d8174e9ef dbf3eb4efd9949cf99c1a87d51237df3 3a04f15675f6459daab1585d8174e9ef--dbf3eb4efd9949cf99c1a87d51237df3 9f9b5d014709458586aebad0483b417f dbf3eb4efd9949cf99c1a87d51237df3--9f9b5d014709458586aebad0483b417f 027ba0114ce04d34b722351427ba5206 9f9b5d014709458586aebad0483b417f--027ba0114ce04d34b722351427ba5206 d0a4d814b8084e479606add06ac1aa89 027ba0114ce04d34b722351427ba5206--d0a4d814b8084e479606add06ac1aa89 647e5fe812a44de78b9985c712e62e56 d0a4d814b8084e479606add06ac1aa89--647e5fe812a44de78b9985c712e62e56 2db03c030c5f41908af3c14025b0f503 647e5fe812a44de78b9985c712e62e56--2db03c030c5f41908af3c14025b0f503 a6a23604889940a39f4cc72916199124 X 2db03c030c5f41908af3c14025b0f503--a6a23604889940a39f4cc72916199124 a6a23604889940a39f4cc72916199124--a1b67867bf9b4bd1bb57076de302b7a3 113e34fd15f849c7ac88b51f30b39246 a6a23604889940a39f4cc72916199124--113e34fd15f849c7ac88b51f30b39246 143af0e60a094e82abaf0e97b678faeb 113e34fd15f849c7ac88b51f30b39246--143af0e60a094e82abaf0e97b678faeb 1babfa2e2b0e4f04a0f371a07378fba2 143af0e60a094e82abaf0e97b678faeb--1babfa2e2b0e4f04a0f371a07378fba2 4c64a438b4034db58786a46157b73303 1babfa2e2b0e4f04a0f371a07378fba2--4c64a438b4034db58786a46157b73303 fa74c04a91214aedb3e86fb0951a2be7 4c64a438b4034db58786a46157b73303--fa74c04a91214aedb3e86fb0951a2be7 b089172520dd47ca9283f1f75abc512a fa74c04a91214aedb3e86fb0951a2be7--b089172520dd47ca9283f1f75abc512a e8809f973e4a48f7b0ccdde4d7ab8476 b089172520dd47ca9283f1f75abc512a--e8809f973e4a48f7b0ccdde4d7ab8476 6ebe4cb240e146aab2d87c557f590b20 e8809f973e4a48f7b0ccdde4d7ab8476--6ebe4cb240e146aab2d87c557f590b20 bb69ac540ffa4223aa3739d23f50f1b0 6ebe4cb240e146aab2d87c557f590b20--bb69ac540ffa4223aa3739d23f50f1b0 eacbf779fd134cdb988f675783c411a7 bb69ac540ffa4223aa3739d23f50f1b0--eacbf779fd134cdb988f675783c411a7 0b459953f3a849f49d3472925dcb92a2 eacbf779fd134cdb988f675783c411a7--0b459953f3a849f49d3472925dcb92a2 31face08776a413891b1ad1a02696ed4 0b459953f3a849f49d3472925dcb92a2--31face08776a413891b1ad1a02696ed4 eb1f0d86fc2c4a9abfd55be6fdd99c3b 31face08776a413891b1ad1a02696ed4--eb1f0d86fc2c4a9abfd55be6fdd99c3b 4d862168a111461182ff3eb92a82085a eb1f0d86fc2c4a9abfd55be6fdd99c3b--4d862168a111461182ff3eb92a82085a 88dd30a71d3849d9984d40a116d19d51 4d862168a111461182ff3eb92a82085a--88dd30a71d3849d9984d40a116d19d51 94e19728c75842eda962ae2ab7eb1437 88dd30a71d3849d9984d40a116d19d51--94e19728c75842eda962ae2ab7eb1437 9bfa21c73c8e4ceabe14bab8c055f248 94e19728c75842eda962ae2ab7eb1437--9bfa21c73c8e4ceabe14bab8c055f248 2c44a0d3926b4f37824390456bb9129c 9bfa21c73c8e4ceabe14bab8c055f248--2c44a0d3926b4f37824390456bb9129c 38954fdb0d3d434bb55697cc585097c9 2c44a0d3926b4f37824390456bb9129c--38954fdb0d3d434bb55697cc585097c9 3bd05cdbdf86471182927067862eeb37 38954fdb0d3d434bb55697cc585097c9--3bd05cdbdf86471182927067862eeb37 b8c7b90559b7419896127e112beb5277 3bd05cdbdf86471182927067862eeb37--b8c7b90559b7419896127e112beb5277 484fd7449a6b4b8c8c77349752ccf789 b8c7b90559b7419896127e112beb5277--484fd7449a6b4b8c8c77349752ccf789 2e2cadd1fef04cadb2699030e50d9a3f 484fd7449a6b4b8c8c77349752ccf789--2e2cadd1fef04cadb2699030e50d9a3f d129c0b86aa24d96889c7dd6a9abe4fc 2e2cadd1fef04cadb2699030e50d9a3f--d129c0b86aa24d96889c7dd6a9abe4fc 9c9e983eaf244bf894d60e6ddeefa65c d129c0b86aa24d96889c7dd6a9abe4fc--9c9e983eaf244bf894d60e6ddeefa65c 555f97bbfd1f464e8f4df53ea3c776f8 9c9e983eaf244bf894d60e6ddeefa65c--555f97bbfd1f464e8f4df53ea3c776f8 1fbb0914b96d40769eb4b49369935b46 555f97bbfd1f464e8f4df53ea3c776f8--1fbb0914b96d40769eb4b49369935b46 b8e65d80ad0140dc9e3ecb1139d32f58 1fbb0914b96d40769eb4b49369935b46--b8e65d80ad0140dc9e3ecb1139d32f58 c3619ff2845f46ceab52cfd6e3e2d52a b8e65d80ad0140dc9e3ecb1139d32f58--c3619ff2845f46ceab52cfd6e3e2d52a 4c6ffb7c1a0e4b7095a004ca44cd170d c3619ff2845f46ceab52cfd6e3e2d52a--4c6ffb7c1a0e4b7095a004ca44cd170d 987a7c70c7ab41c78b77bfa5d64caab6 4c6ffb7c1a0e4b7095a004ca44cd170d--987a7c70c7ab41c78b77bfa5d64caab6 50d6a1453bb9472dbd7c9fed13bb5c8b 987a7c70c7ab41c78b77bfa5d64caab6--50d6a1453bb9472dbd7c9fed13bb5c8b 1da634a5941a40dabcdfd2e4bff3d508 50d6a1453bb9472dbd7c9fed13bb5c8b--1da634a5941a40dabcdfd2e4bff3d508 ced08bda0ffe472bb056830714033883 1da634a5941a40dabcdfd2e4bff3d508--ced08bda0ffe472bb056830714033883 59de8ee9d128449f80107f38264427b7 ced08bda0ffe472bb056830714033883--59de8ee9d128449f80107f38264427b7 c0ac7342c2464d17a7e247e84a82f9e1 59de8ee9d128449f80107f38264427b7--c0ac7342c2464d17a7e247e84a82f9e1 f7fc102985fe4a66b6f182f6a72e214f c0ac7342c2464d17a7e247e84a82f9e1--f7fc102985fe4a66b6f182f6a72e214f 17eb8ce5334b446f878ec3aa288bc0c8 f7fc102985fe4a66b6f182f6a72e214f--17eb8ce5334b446f878ec3aa288bc0c8 3ff193f4c00643809604f45a6e0f4206 17eb8ce5334b446f878ec3aa288bc0c8--3ff193f4c00643809604f45a6e0f4206 c187bf9771e44e70961661994485ff83 3ff193f4c00643809604f45a6e0f4206--c187bf9771e44e70961661994485ff83 7b7f5811e81b402ba28195c36cce7d43 c187bf9771e44e70961661994485ff83--7b7f5811e81b402ba28195c36cce7d43 ce2085dd908f45979b92e5af157f15e1 7b7f5811e81b402ba28195c36cce7d43--ce2085dd908f45979b92e5af157f15e1 f6ddd06fae94408bb6a56ef6b96ac480 ce2085dd908f45979b92e5af157f15e1--f6ddd06fae94408bb6a56ef6b96ac480 ad6994332df24c44a360a268827abb86 f6ddd06fae94408bb6a56ef6b96ac480--ad6994332df24c44a360a268827abb86 e5f977397a5743a4b41a3d16bcb03859 ad6994332df24c44a360a268827abb86--e5f977397a5743a4b41a3d16bcb03859 7461bf1e3277416c805880a0634554bd e5f977397a5743a4b41a3d16bcb03859--7461bf1e3277416c805880a0634554bd bb6969a03fdf4be69a2b5150693f6ea0 7461bf1e3277416c805880a0634554bd--bb6969a03fdf4be69a2b5150693f6ea0 f1e10faed361439799a8c9ecd8d169a2 bb6969a03fdf4be69a2b5150693f6ea0--f1e10faed361439799a8c9ecd8d169a2 1ec4d816829c417fa0cb89475fc81644 f1e10faed361439799a8c9ecd8d169a2--1ec4d816829c417fa0cb89475fc81644 d1ab2ed6b46249768bfb611d4a409024 1ec4d816829c417fa0cb89475fc81644--d1ab2ed6b46249768bfb611d4a409024 54cdfff4a90a429a8e6c743f8dfa34f9 d1ab2ed6b46249768bfb611d4a409024--54cdfff4a90a429a8e6c743f8dfa34f9 2db713351b9c48abb75cdadb24647e8d 54cdfff4a90a429a8e6c743f8dfa34f9--2db713351b9c48abb75cdadb24647e8d 488599668820470688542e2fe3cce725 2db713351b9c48abb75cdadb24647e8d--488599668820470688542e2fe3cce725 76c2ca5adc544a44bd00e8e5387b2b94 488599668820470688542e2fe3cce725--76c2ca5adc544a44bd00e8e5387b2b94 f65167d3f7be4125885861d6e4bf7bfa 76c2ca5adc544a44bd00e8e5387b2b94--f65167d3f7be4125885861d6e4bf7bfa 49aab561502542579fd3025ac3fd3c23 f65167d3f7be4125885861d6e4bf7bfa--49aab561502542579fd3025ac3fd3c23 9a2a21af9b074bfd860530cc1336b234 49aab561502542579fd3025ac3fd3c23--9a2a21af9b074bfd860530cc1336b234 e1898f82f12a48a19c51e2979c8082c4 9a2a21af9b074bfd860530cc1336b234--e1898f82f12a48a19c51e2979c8082c4 01ffd153340843c5846af7df3e0963ca e1898f82f12a48a19c51e2979c8082c4--01ffd153340843c5846af7df3e0963ca 22ae924cba834eaa95902dcc714b20ac 01ffd153340843c5846af7df3e0963ca--22ae924cba834eaa95902dcc714b20ac 302f9be5890c445e91daaf200dd28f97 22ae924cba834eaa95902dcc714b20ac--302f9be5890c445e91daaf200dd28f97 b4be4ce12af34bcba085f6d453bfae2e RX(b02) 302f9be5890c445e91daaf200dd28f97--b4be4ce12af34bcba085f6d453bfae2e 7bdaf709c98344799f6c143318fbed31 b4be4ce12af34bcba085f6d453bfae2e--7bdaf709c98344799f6c143318fbed31 18c7901d345d413aa8c056c02992802e X 7bdaf709c98344799f6c143318fbed31--18c7901d345d413aa8c056c02992802e 18c7901d345d413aa8c056c02992802e--2e60d9ca9ce44a02b2868672dd8c7b97 ed934728eb65429fb3321c08d3b23f78 18c7901d345d413aa8c056c02992802e--ed934728eb65429fb3321c08d3b23f78 63ad64fc6fec4b6e96325ba0fefc0d52 ed934728eb65429fb3321c08d3b23f78--63ad64fc6fec4b6e96325ba0fefc0d52 cae7dc007e29408cb402bc45c1806b13 63ad64fc6fec4b6e96325ba0fefc0d52--cae7dc007e29408cb402bc45c1806b13 0d04b766e19349bbabd7f95103ff3f64 cae7dc007e29408cb402bc45c1806b13--0d04b766e19349bbabd7f95103ff3f64 e4fcf91ce6f94f2eb537c22f19b0aba7 0d04b766e19349bbabd7f95103ff3f64--e4fcf91ce6f94f2eb537c22f19b0aba7 e1f9e64aec6c4844b22e2096b9ffc760 e4fcf91ce6f94f2eb537c22f19b0aba7--e1f9e64aec6c4844b22e2096b9ffc760 1449b65f4b274058b16ac75972386aa4 e1f9e64aec6c4844b22e2096b9ffc760--1449b65f4b274058b16ac75972386aa4 6752c760de2142ac883033bfa67635cd 1449b65f4b274058b16ac75972386aa4--6752c760de2142ac883033bfa67635cd 80a39fd4c1d64bacbfe4d6bb2b666a7f 6752c760de2142ac883033bfa67635cd--80a39fd4c1d64bacbfe4d6bb2b666a7f d2812f98a1504013b665d12c94b5626d 80a39fd4c1d64bacbfe4d6bb2b666a7f--d2812f98a1504013b665d12c94b5626d fd3514d276924f9383f2f714c20bd7d0 d2812f98a1504013b665d12c94b5626d--fd3514d276924f9383f2f714c20bd7d0 18a73561e19746d696e4ae860d9aa6c0 X fd3514d276924f9383f2f714c20bd7d0--18a73561e19746d696e4ae860d9aa6c0 18a73561e19746d696e4ae860d9aa6c0--992cf3c46b6a4fc18e5f994a8305ebc7 28be5ffaf9e24e6b92b2a76e4163170a 18a73561e19746d696e4ae860d9aa6c0--28be5ffaf9e24e6b92b2a76e4163170a 4da19dc8d45047f3bbfa126978f21288 28be5ffaf9e24e6b92b2a76e4163170a--4da19dc8d45047f3bbfa126978f21288 d86cc8dcf7d84601b85a93a316231c2a 4da19dc8d45047f3bbfa126978f21288--d86cc8dcf7d84601b85a93a316231c2a 8d802c1a67eb41c0b03bc36321fd626d d86cc8dcf7d84601b85a93a316231c2a--8d802c1a67eb41c0b03bc36321fd626d 8f2c518c1456439681c979bc55053e12 8d802c1a67eb41c0b03bc36321fd626d--8f2c518c1456439681c979bc55053e12 b70eb25f28b24166860eff1f12b432b5 X 8f2c518c1456439681c979bc55053e12--b70eb25f28b24166860eff1f12b432b5 b70eb25f28b24166860eff1f12b432b5--a7842f5eef704f138bd8b377fe752fe5 089fa4f56a604f688f301824455f233a b70eb25f28b24166860eff1f12b432b5--089fa4f56a604f688f301824455f233a 5c17607a951a4a0ca694465419f12bd5 089fa4f56a604f688f301824455f233a--5c17607a951a4a0ca694465419f12bd5 e8fe7cf3457d493db1feb756957b1ab8 5c17607a951a4a0ca694465419f12bd5--e8fe7cf3457d493db1feb756957b1ab8 4f1637763f914f67964eff2263825cbb e8fe7cf3457d493db1feb756957b1ab8--4f1637763f914f67964eff2263825cbb dd96d49d060c4f9c9c0c7cfb0f558bdc 4f1637763f914f67964eff2263825cbb--dd96d49d060c4f9c9c0c7cfb0f558bdc cb349099d8b049f7b25df710199387a0 dd96d49d060c4f9c9c0c7cfb0f558bdc--cb349099d8b049f7b25df710199387a0 031cbab8590944db9bb50f8be114b0d4 cb349099d8b049f7b25df710199387a0--031cbab8590944db9bb50f8be114b0d4 d78e4ccbf82b406bac54263255a2a42a X 031cbab8590944db9bb50f8be114b0d4--d78e4ccbf82b406bac54263255a2a42a d78e4ccbf82b406bac54263255a2a42a--b22c6e64516b46a4aef397e25d247bb1 8993d8759dfd42a28d0a12abbaa52e36 d78e4ccbf82b406bac54263255a2a42a--8993d8759dfd42a28d0a12abbaa52e36 ff409811990d4fdcaa5791a4e91e8300 8993d8759dfd42a28d0a12abbaa52e36--ff409811990d4fdcaa5791a4e91e8300 3d1c923478904bc79681ffb5976a0922 X ff409811990d4fdcaa5791a4e91e8300--3d1c923478904bc79681ffb5976a0922 3d1c923478904bc79681ffb5976a0922--1091de4fada6482da43b6d308efed1b4 1badf6897a944ccbbecd01fe1791ee71 3d1c923478904bc79681ffb5976a0922--1badf6897a944ccbbecd01fe1791ee71 ccbc545588d0438c94edcdcbc7b84026 1badf6897a944ccbbecd01fe1791ee71--ccbc545588d0438c94edcdcbc7b84026 5ed3d2f59f6848d1944459426011739c ccbc545588d0438c94edcdcbc7b84026--5ed3d2f59f6848d1944459426011739c 899f922fe1eb4b99a76b6e75b69f08a3 5ed3d2f59f6848d1944459426011739c--899f922fe1eb4b99a76b6e75b69f08a3 5410137c46974906a717908195695a15 899f922fe1eb4b99a76b6e75b69f08a3--5410137c46974906a717908195695a15 d033bbef0f38467abdf8dca21cb00676 5410137c46974906a717908195695a15--d033bbef0f38467abdf8dca21cb00676 f2e35a15ace24904988bf0d605048b49 d033bbef0f38467abdf8dca21cb00676--f2e35a15ace24904988bf0d605048b49 c2a13f8a512b47a18506d345599fc5cb f2e35a15ace24904988bf0d605048b49--c2a13f8a512b47a18506d345599fc5cb fa83cdd6a26c4090b45244dbc6dbd6c7 c2a13f8a512b47a18506d345599fc5cb--fa83cdd6a26c4090b45244dbc6dbd6c7 6ac8fd6fc7744630b5e3401062ba4738 X fa83cdd6a26c4090b45244dbc6dbd6c7--6ac8fd6fc7744630b5e3401062ba4738 6ac8fd6fc7744630b5e3401062ba4738--ec355cc401534a319a16cae2d45d122c cda06ef5994f40a8aa671bcea9668db7 6ac8fd6fc7744630b5e3401062ba4738--cda06ef5994f40a8aa671bcea9668db7 efa9c49a145c433ca0cc33f6b59857f6 cda06ef5994f40a8aa671bcea9668db7--efa9c49a145c433ca0cc33f6b59857f6 aa51fd06c457415db5047c7f027dc079 X efa9c49a145c433ca0cc33f6b59857f6--aa51fd06c457415db5047c7f027dc079 aa51fd06c457415db5047c7f027dc079--f00d1505800e40778a3404ff4eb461c9 4c5133f8a5e940d89e5f566044f11dfa aa51fd06c457415db5047c7f027dc079--4c5133f8a5e940d89e5f566044f11dfa 9595ee77e6f34114944c8d767647e645 4c5133f8a5e940d89e5f566044f11dfa--9595ee77e6f34114944c8d767647e645 6feead7b16824a66979ffc63d0bea395 9595ee77e6f34114944c8d767647e645--6feead7b16824a66979ffc63d0bea395 50180b8cbc7e43b8a945998d3f83e9c2 6feead7b16824a66979ffc63d0bea395--50180b8cbc7e43b8a945998d3f83e9c2 ea185a3cfa8449de9cec759a93e0ad9d 50180b8cbc7e43b8a945998d3f83e9c2--ea185a3cfa8449de9cec759a93e0ad9d 72bc83dd66bc4f90ba045b3d7a2dbd6f ea185a3cfa8449de9cec759a93e0ad9d--72bc83dd66bc4f90ba045b3d7a2dbd6f d0eec01b48a44f05bf9f4c50ce88942f 72bc83dd66bc4f90ba045b3d7a2dbd6f--d0eec01b48a44f05bf9f4c50ce88942f eac6a85690e44569a80f171706fbba1d d0eec01b48a44f05bf9f4c50ce88942f--eac6a85690e44569a80f171706fbba1d cc4f9afe5ada475387750ba97b4e96a6 eac6a85690e44569a80f171706fbba1d--cc4f9afe5ada475387750ba97b4e96a6 bfae9c82d23a4f81999443504ca7c68b cc4f9afe5ada475387750ba97b4e96a6--bfae9c82d23a4f81999443504ca7c68b 8d85c3fe06cf4a51b5b96b0c66633cbb bfae9c82d23a4f81999443504ca7c68b--8d85c3fe06cf4a51b5b96b0c66633cbb a48ffdf24e6b4bbc8c6f46d3fb5fe464 X 8d85c3fe06cf4a51b5b96b0c66633cbb--a48ffdf24e6b4bbc8c6f46d3fb5fe464 a48ffdf24e6b4bbc8c6f46d3fb5fe464--2e48264ff52b4d858d03b2fd3b60429f aea6d5c434854828bcea3ff9bd8a88f7 a48ffdf24e6b4bbc8c6f46d3fb5fe464--aea6d5c434854828bcea3ff9bd8a88f7 fb143f96156544bc89804ed20ba0ee9d X aea6d5c434854828bcea3ff9bd8a88f7--fb143f96156544bc89804ed20ba0ee9d fb143f96156544bc89804ed20ba0ee9d--30e0e9b2bf0f4ddcbbd2c5ad7b8a8075 4ee2bdbbccc54280a8c33fb2cfe3a41e RZ(-1.0*g1) fb143f96156544bc89804ed20ba0ee9d--4ee2bdbbccc54280a8c33fb2cfe3a41e f1d1946b05ce494087d1005126070d64 X 4ee2bdbbccc54280a8c33fb2cfe3a41e--f1d1946b05ce494087d1005126070d64 f1d1946b05ce494087d1005126070d64--f1fb46d632494374b6c3a24eb0046aa4 ed2d7825933345fb984a136795069455 X f1d1946b05ce494087d1005126070d64--ed2d7825933345fb984a136795069455 ed2d7825933345fb984a136795069455--3c10d7c0a7a84e829ee107b6843e8545 1716e9d76db4439a8e0d2f24aebf9afc ed2d7825933345fb984a136795069455--1716e9d76db4439a8e0d2f24aebf9afc 10b6ceb1145d4b6393d6f1b5b9854090 1716e9d76db4439a8e0d2f24aebf9afc--10b6ceb1145d4b6393d6f1b5b9854090 ac32ef9b390e405bac8425b72fe68aa8 10b6ceb1145d4b6393d6f1b5b9854090--ac32ef9b390e405bac8425b72fe68aa8 292fe8be98234fa68550751fa5921484 ac32ef9b390e405bac8425b72fe68aa8--292fe8be98234fa68550751fa5921484 06ea9578129745f289db08c369f68790 292fe8be98234fa68550751fa5921484--06ea9578129745f289db08c369f68790 78cc73cefe23490da70552552591b941 06ea9578129745f289db08c369f68790--78cc73cefe23490da70552552591b941 4b83cac6fa2b40a9a68fc61ddea42e20 78cc73cefe23490da70552552591b941--4b83cac6fa2b40a9a68fc61ddea42e20 b4c0ee3bc8b2446d924568f19a47b644 X 4b83cac6fa2b40a9a68fc61ddea42e20--b4c0ee3bc8b2446d924568f19a47b644 b4c0ee3bc8b2446d924568f19a47b644--538f19ce7b2445d9b3a40f5458de310b 886993c112dd41c5a945d9e49704fb19 X b4c0ee3bc8b2446d924568f19a47b644--886993c112dd41c5a945d9e49704fb19 886993c112dd41c5a945d9e49704fb19--209571b4cf1149b294406b46717fd891 451d5457d4814425a0a9d11dbbf693e6 886993c112dd41c5a945d9e49704fb19--451d5457d4814425a0a9d11dbbf693e6 30d7ff03d9134277b8de1b95ef8d5cb7 451d5457d4814425a0a9d11dbbf693e6--30d7ff03d9134277b8de1b95ef8d5cb7 45a5d3ba99c541d19d2dd5255b2a4bd2 30d7ff03d9134277b8de1b95ef8d5cb7--45a5d3ba99c541d19d2dd5255b2a4bd2 c78ba1bb9bcc4133b7bf3240533ef52e 45a5d3ba99c541d19d2dd5255b2a4bd2--c78ba1bb9bcc4133b7bf3240533ef52e 343a68d3aa5a4d4f85de86e6bf71b118 c78ba1bb9bcc4133b7bf3240533ef52e--343a68d3aa5a4d4f85de86e6bf71b118 edcdefd0740c48c0abba9969c6ef4b5d 343a68d3aa5a4d4f85de86e6bf71b118--edcdefd0740c48c0abba9969c6ef4b5d 374aa99d7826490c8bc6153535663414 edcdefd0740c48c0abba9969c6ef4b5d--374aa99d7826490c8bc6153535663414 b53de991649f4c7d93914bbef90895ca 374aa99d7826490c8bc6153535663414--b53de991649f4c7d93914bbef90895ca 298b8043e2364f8ea77980677c9bcb52 b53de991649f4c7d93914bbef90895ca--298b8043e2364f8ea77980677c9bcb52 842f4bec92004fdeb3005b44a3727979 X 298b8043e2364f8ea77980677c9bcb52--842f4bec92004fdeb3005b44a3727979 842f4bec92004fdeb3005b44a3727979--86cceefe8b4347d697f11adf7d95e173 dda68ec617334a1db0e8f61eaaacb4b2 842f4bec92004fdeb3005b44a3727979--dda68ec617334a1db0e8f61eaaacb4b2 0792a2f7c0624e5a9a69bf21ec6e255f dda68ec617334a1db0e8f61eaaacb4b2--0792a2f7c0624e5a9a69bf21ec6e255f 92dac1315bdc4fc3a4e4b722faa318a1 0792a2f7c0624e5a9a69bf21ec6e255f--92dac1315bdc4fc3a4e4b722faa318a1 543dd0592ea44042b29dfb9b9251c8eb 92dac1315bdc4fc3a4e4b722faa318a1--543dd0592ea44042b29dfb9b9251c8eb 0de75b88411243c5952c44e5d044508b 543dd0592ea44042b29dfb9b9251c8eb--0de75b88411243c5952c44e5d044508b a0219e07ba024d7ba063e12cf5aee4ee 0de75b88411243c5952c44e5d044508b--a0219e07ba024d7ba063e12cf5aee4ee ad7bdcec382441a3a7c89801fa90c901 a0219e07ba024d7ba063e12cf5aee4ee--ad7bdcec382441a3a7c89801fa90c901 28043b194d8840dea5db73913d97225c ad7bdcec382441a3a7c89801fa90c901--28043b194d8840dea5db73913d97225c 9657153ab8bd411599fb6e971b42e3d2 28043b194d8840dea5db73913d97225c--9657153ab8bd411599fb6e971b42e3d2 459f608420db487ab78da85944f6313b 9657153ab8bd411599fb6e971b42e3d2--459f608420db487ab78da85944f6313b 682e23ca3e68420c8c777be2a1fce7d0 459f608420db487ab78da85944f6313b--682e23ca3e68420c8c777be2a1fce7d0 a3b9090485a94562bf64c008500bcb26 682e23ca3e68420c8c777be2a1fce7d0--a3b9090485a94562bf64c008500bcb26 25c6b5fec72b43f09dd7adf22f797735 a3b9090485a94562bf64c008500bcb26--25c6b5fec72b43f09dd7adf22f797735 5e55091ccdbe42ad991fd616978f83ba 25c6b5fec72b43f09dd7adf22f797735--5e55091ccdbe42ad991fd616978f83ba 40cc2dbdc1f6404cab39987c69364096 5e55091ccdbe42ad991fd616978f83ba--40cc2dbdc1f6404cab39987c69364096 a32bccdac48945e0b02d39d849d6fd3d 40cc2dbdc1f6404cab39987c69364096--a32bccdac48945e0b02d39d849d6fd3d f6752dd956254b33952c053415aac31f a32bccdac48945e0b02d39d849d6fd3d--f6752dd956254b33952c053415aac31f 81c1becd0974405aadaf51b69719110a f6752dd956254b33952c053415aac31f--81c1becd0974405aadaf51b69719110a 11dcd17ad3a24804a5f5efaa99fc7a99 81c1becd0974405aadaf51b69719110a--11dcd17ad3a24804a5f5efaa99fc7a99 a1ca08f1442b42cba6b42c7cd6508cb6 11dcd17ad3a24804a5f5efaa99fc7a99--a1ca08f1442b42cba6b42c7cd6508cb6 d630f987a6564beeb69873645aa9ef88 a1ca08f1442b42cba6b42c7cd6508cb6--d630f987a6564beeb69873645aa9ef88 cad1939c5d464e6395ead83070b2c857 d630f987a6564beeb69873645aa9ef88--cad1939c5d464e6395ead83070b2c857 bf2d8557c9fb4b0484e13b33e62338ff cad1939c5d464e6395ead83070b2c857--bf2d8557c9fb4b0484e13b33e62338ff 6dfb190ffe6c4fb992029cd0d7679601 bf2d8557c9fb4b0484e13b33e62338ff--6dfb190ffe6c4fb992029cd0d7679601 a3446d361f4844db9e7ede2d13d33b18 6dfb190ffe6c4fb992029cd0d7679601--a3446d361f4844db9e7ede2d13d33b18 0dea794177a440248dd83fa17a37572c a3446d361f4844db9e7ede2d13d33b18--0dea794177a440248dd83fa17a37572c 7c271091c6394ddca39927989bd51008 0dea794177a440248dd83fa17a37572c--7c271091c6394ddca39927989bd51008 0952760f51384cc2ad4dd677d0cd3a42 7c271091c6394ddca39927989bd51008--0952760f51384cc2ad4dd677d0cd3a42 21a22988a30645509ca4b152577e79a1 0952760f51384cc2ad4dd677d0cd3a42--21a22988a30645509ca4b152577e79a1 d501b97c61a547bda13122dafac4e766 21a22988a30645509ca4b152577e79a1--d501b97c61a547bda13122dafac4e766 3b30f2741dc54eb884a6e54f0f0f54df d501b97c61a547bda13122dafac4e766--3b30f2741dc54eb884a6e54f0f0f54df 0b31fe2bbd9e4524863cdce65ddb288f 3b30f2741dc54eb884a6e54f0f0f54df--0b31fe2bbd9e4524863cdce65ddb288f 5da43272069a49ac956b08972575d06d 0b31fe2bbd9e4524863cdce65ddb288f--5da43272069a49ac956b08972575d06d acb619fa33814bb78e351c9f71ee9e7b 5da43272069a49ac956b08972575d06d--acb619fa33814bb78e351c9f71ee9e7b c5cf5de36b5e40ca9e813d0e8eeb8e98 acb619fa33814bb78e351c9f71ee9e7b--c5cf5de36b5e40ca9e813d0e8eeb8e98 e8567a28bd674dcc89d08c18f74f1bdb c5cf5de36b5e40ca9e813d0e8eeb8e98--e8567a28bd674dcc89d08c18f74f1bdb 3afdb4dfaaa041419208d46ac7762806 e8567a28bd674dcc89d08c18f74f1bdb--3afdb4dfaaa041419208d46ac7762806 ba237f770c874a62aab059f944c7e0bd 3afdb4dfaaa041419208d46ac7762806--ba237f770c874a62aab059f944c7e0bd 62113620a9044250bab5b02993acbbbe ba237f770c874a62aab059f944c7e0bd--62113620a9044250bab5b02993acbbbe a6d0f60cde5d4ddfb15830a7ade22359 62113620a9044250bab5b02993acbbbe--a6d0f60cde5d4ddfb15830a7ade22359 422cfec2f597489680f5701505413dc0 a6d0f60cde5d4ddfb15830a7ade22359--422cfec2f597489680f5701505413dc0 ae4b2b70fb2140019e13add57e95ba63 422cfec2f597489680f5701505413dc0--ae4b2b70fb2140019e13add57e95ba63 99c4f9989adb450bb151c4be1aae767d ae4b2b70fb2140019e13add57e95ba63--99c4f9989adb450bb151c4be1aae767d d3de48d900e24fb0ad4290bbc11d0109 99c4f9989adb450bb151c4be1aae767d--d3de48d900e24fb0ad4290bbc11d0109 4b044b6a48b04bdc9c680b2e7a666522 d3de48d900e24fb0ad4290bbc11d0109--4b044b6a48b04bdc9c680b2e7a666522 53b4c8e3ccf64929851b5b019c6ace34 4b044b6a48b04bdc9c680b2e7a666522--53b4c8e3ccf64929851b5b019c6ace34 496498989e94474bb8c1c63a4474e4e4 53b4c8e3ccf64929851b5b019c6ace34--496498989e94474bb8c1c63a4474e4e4 82ab9bdfcfb440d791153c4c4f6f97bc 496498989e94474bb8c1c63a4474e4e4--82ab9bdfcfb440d791153c4c4f6f97bc 85a409f0787e49b8976dd3724fd84c6d 82ab9bdfcfb440d791153c4c4f6f97bc--85a409f0787e49b8976dd3724fd84c6d e8791ef92d4e407bb09df1d5ff53bcc7 85a409f0787e49b8976dd3724fd84c6d--e8791ef92d4e407bb09df1d5ff53bcc7 bdfbb309f7d54b3f8ef53295968a2164 e8791ef92d4e407bb09df1d5ff53bcc7--bdfbb309f7d54b3f8ef53295968a2164 9dd01e69ae2d42de966effa209972a39 bdfbb309f7d54b3f8ef53295968a2164--9dd01e69ae2d42de966effa209972a39 a9c4aa1a29104de894c8e34f6ea4dfa2 9dd01e69ae2d42de966effa209972a39--a9c4aa1a29104de894c8e34f6ea4dfa2 89bbf94f23ac476598f215c40e81a830 a9c4aa1a29104de894c8e34f6ea4dfa2--89bbf94f23ac476598f215c40e81a830 f584d4b83af64671be26c620e4952287 89bbf94f23ac476598f215c40e81a830--f584d4b83af64671be26c620e4952287 27780caa04a74796805d2e0e15d7e5b2 f584d4b83af64671be26c620e4952287--27780caa04a74796805d2e0e15d7e5b2 a8160b1978a142a1a2d6f37d9530925d 27780caa04a74796805d2e0e15d7e5b2--a8160b1978a142a1a2d6f37d9530925d e0711c2c8105415db2b6f0789a1d9c95 a8160b1978a142a1a2d6f37d9530925d--e0711c2c8105415db2b6f0789a1d9c95 9d2504bb196d4b3a84827eb9a31fce7a e0711c2c8105415db2b6f0789a1d9c95--9d2504bb196d4b3a84827eb9a31fce7a 5e2fe75b30ce4d3faa4eeb5702c36572 9d2504bb196d4b3a84827eb9a31fce7a--5e2fe75b30ce4d3faa4eeb5702c36572 6616375c77f945c694eb0f89a0ce0165 5e2fe75b30ce4d3faa4eeb5702c36572--6616375c77f945c694eb0f89a0ce0165 83d1677931a948aca3065c7efd4153a5 RX(b12) 6616375c77f945c694eb0f89a0ce0165--83d1677931a948aca3065c7efd4153a5 83d1677931a948aca3065c7efd4153a5--4415a31ba4f04813a54d65b86271c50d 738e712cb32d4f2e959750cd5ec7d8e3 4518c9812e1545e59438e2a9b7d71629 38afdbf1745342c2bab7db8a11b4e56e--4518c9812e1545e59438e2a9b7d71629 e619be1c2afc4041a08328c32952f527 4 6e7b09ae5ed74fa5a83d0a8f9aaaf6ee 4518c9812e1545e59438e2a9b7d71629--6e7b09ae5ed74fa5a83d0a8f9aaaf6ee ef490f9c8d8f43a48c58ad0ad0f4db5f X 6e7b09ae5ed74fa5a83d0a8f9aaaf6ee--ef490f9c8d8f43a48c58ad0ad0f4db5f ef490f9c8d8f43a48c58ad0ad0f4db5f--ca92b414af0c4560bc0e3089b89c7e6f 33cc21f6979c416489ec1084ce83649d ef490f9c8d8f43a48c58ad0ad0f4db5f--33cc21f6979c416489ec1084ce83649d 57d9d8098eb4467387e35c1b94315c95 33cc21f6979c416489ec1084ce83649d--57d9d8098eb4467387e35c1b94315c95 3320dc26345d4835ade6c625c99de011 57d9d8098eb4467387e35c1b94315c95--3320dc26345d4835ade6c625c99de011 8eb9a2fe8f8243bfbc3ad43f321d5a65 3320dc26345d4835ade6c625c99de011--8eb9a2fe8f8243bfbc3ad43f321d5a65 12bcd37098974e778fb67fa10acf0f58 8eb9a2fe8f8243bfbc3ad43f321d5a65--12bcd37098974e778fb67fa10acf0f58 5369e7549585431a908dd3d7fc221954 12bcd37098974e778fb67fa10acf0f58--5369e7549585431a908dd3d7fc221954 a896d52ae20f48db912d329ecf4c2385 5369e7549585431a908dd3d7fc221954--a896d52ae20f48db912d329ecf4c2385 7dba3e85a4c84114a75f9b194e5d0b55 a896d52ae20f48db912d329ecf4c2385--7dba3e85a4c84114a75f9b194e5d0b55 0e6554937b11424fb4e0f0606e1c786a 7dba3e85a4c84114a75f9b194e5d0b55--0e6554937b11424fb4e0f0606e1c786a 80c0979c3fb14933ad640442248ac274 X 0e6554937b11424fb4e0f0606e1c786a--80c0979c3fb14933ad640442248ac274 80c0979c3fb14933ad640442248ac274--35f22ed94b9d4b4b941bf0652a223f95 044bce75e0014cdcb14fdf0003d6d28b 80c0979c3fb14933ad640442248ac274--044bce75e0014cdcb14fdf0003d6d28b d727fbfc7f3a447aac2e85ea16be5463 044bce75e0014cdcb14fdf0003d6d28b--d727fbfc7f3a447aac2e85ea16be5463 f255d8b67100429db922548aa3a08d5f d727fbfc7f3a447aac2e85ea16be5463--f255d8b67100429db922548aa3a08d5f 5e0b35def43543aa983cf4f12b1f9814 f255d8b67100429db922548aa3a08d5f--5e0b35def43543aa983cf4f12b1f9814 a8c09f23709d4d5eb9594b2cdc41e752 5e0b35def43543aa983cf4f12b1f9814--a8c09f23709d4d5eb9594b2cdc41e752 c0f276fd0cfc4dccae69d20256707402 a8c09f23709d4d5eb9594b2cdc41e752--c0f276fd0cfc4dccae69d20256707402 5ba86f3241bf482c8c0bd7148774161b c0f276fd0cfc4dccae69d20256707402--5ba86f3241bf482c8c0bd7148774161b d367d8f976c54c8da54adeed0a6c96e1 X 5ba86f3241bf482c8c0bd7148774161b--d367d8f976c54c8da54adeed0a6c96e1 d367d8f976c54c8da54adeed0a6c96e1--2d982d70c92b444fbfdb1b594fd6a0c7 0e1e71e45d8e492598647e91dd680849 d367d8f976c54c8da54adeed0a6c96e1--0e1e71e45d8e492598647e91dd680849 04a6150f03a543279651998fceb4ebab 0e1e71e45d8e492598647e91dd680849--04a6150f03a543279651998fceb4ebab 32c62a38f6c4457f8fe0b511969b012d 04a6150f03a543279651998fceb4ebab--32c62a38f6c4457f8fe0b511969b012d f47c40da9af7416dafa38b9f78b63c3d 32c62a38f6c4457f8fe0b511969b012d--f47c40da9af7416dafa38b9f78b63c3d 1bc5a86c2fd44b8281d9eae7a4fc4bb9 f47c40da9af7416dafa38b9f78b63c3d--1bc5a86c2fd44b8281d9eae7a4fc4bb9 316acae875d54c07a59224b311b0f018 X 1bc5a86c2fd44b8281d9eae7a4fc4bb9--316acae875d54c07a59224b311b0f018 316acae875d54c07a59224b311b0f018--1381ea1e16444965895eb4f3a07af515 701d02c8642442958e79c79f546580fb 316acae875d54c07a59224b311b0f018--701d02c8642442958e79c79f546580fb 4ef04ead4dea4a4d814bbb0aca178e81 701d02c8642442958e79c79f546580fb--4ef04ead4dea4a4d814bbb0aca178e81 b9af6f60c4d74139a21357967778ff00 4ef04ead4dea4a4d814bbb0aca178e81--b9af6f60c4d74139a21357967778ff00 26d7334026bd4539afc1f73017c6d314 b9af6f60c4d74139a21357967778ff00--26d7334026bd4539afc1f73017c6d314 a442458f26e34dacaf2861ca02db1538 X 26d7334026bd4539afc1f73017c6d314--a442458f26e34dacaf2861ca02db1538 a442458f26e34dacaf2861ca02db1538--eed1296dbd5c4d21ae8715b39271876f 44b99b5691574aa287e84dc1d83c96cc a442458f26e34dacaf2861ca02db1538--44b99b5691574aa287e84dc1d83c96cc 882ffc4dee124e3982164d7eb89ff6d3 44b99b5691574aa287e84dc1d83c96cc--882ffc4dee124e3982164d7eb89ff6d3 63ed5e64f42c4b828e9fbf8bd7061ff7 882ffc4dee124e3982164d7eb89ff6d3--63ed5e64f42c4b828e9fbf8bd7061ff7 278569b852374b8e9defa2c6d278ae03 63ed5e64f42c4b828e9fbf8bd7061ff7--278569b852374b8e9defa2c6d278ae03 4f5580ce08334096b356f224a41118a8 278569b852374b8e9defa2c6d278ae03--4f5580ce08334096b356f224a41118a8 4c18617c904d4dc3b4d47dd777ff5cc0 4f5580ce08334096b356f224a41118a8--4c18617c904d4dc3b4d47dd777ff5cc0 5abf3000602e460db9d6312a4987331a 4c18617c904d4dc3b4d47dd777ff5cc0--5abf3000602e460db9d6312a4987331a 8651a99efa8647f0aad7cae1679e39aa X 5abf3000602e460db9d6312a4987331a--8651a99efa8647f0aad7cae1679e39aa 8651a99efa8647f0aad7cae1679e39aa--f87e88c8c50e492e80a89cea886612ac 69b5b4763dc84e328b04a5816f1d28b9 8651a99efa8647f0aad7cae1679e39aa--69b5b4763dc84e328b04a5816f1d28b9 47f0819c199b4ca582517ea986d7b347 69b5b4763dc84e328b04a5816f1d28b9--47f0819c199b4ca582517ea986d7b347 a9253f43d4b040a9b9d459a6087fb361 47f0819c199b4ca582517ea986d7b347--a9253f43d4b040a9b9d459a6087fb361 a85b9e07900045b4a26760fee0ff290f a9253f43d4b040a9b9d459a6087fb361--a85b9e07900045b4a26760fee0ff290f 8e6e5c40fd414250a5a8801875feb0c2 X a85b9e07900045b4a26760fee0ff290f--8e6e5c40fd414250a5a8801875feb0c2 8e6e5c40fd414250a5a8801875feb0c2--7c37f76467d9446183a936a2d4b3a76e d47a04505bd44599a1251083c5c32029 8e6e5c40fd414250a5a8801875feb0c2--d47a04505bd44599a1251083c5c32029 09d101ba2d194fc3861b7297ca8f49f6 d47a04505bd44599a1251083c5c32029--09d101ba2d194fc3861b7297ca8f49f6 d510f7666d3f4fcc88f01a672fa6f03d 09d101ba2d194fc3861b7297ca8f49f6--d510f7666d3f4fcc88f01a672fa6f03d e67b1b5c608f42ff81b27d2247d711cf d510f7666d3f4fcc88f01a672fa6f03d--e67b1b5c608f42ff81b27d2247d711cf a6c14b263f924192b70f55929878a6e0 e67b1b5c608f42ff81b27d2247d711cf--a6c14b263f924192b70f55929878a6e0 7db81cf79a8048d99566b5e5fc9f39cf a6c14b263f924192b70f55929878a6e0--7db81cf79a8048d99566b5e5fc9f39cf 0700d49aa8ae4ea8986972ab9d0635cc 7db81cf79a8048d99566b5e5fc9f39cf--0700d49aa8ae4ea8986972ab9d0635cc 884e41b877704d55b61f812f2e45dee5 0700d49aa8ae4ea8986972ab9d0635cc--884e41b877704d55b61f812f2e45dee5 505ed529e72649349ef4dc2b4e311a62 884e41b877704d55b61f812f2e45dee5--505ed529e72649349ef4dc2b4e311a62 73efbb39517742c8a641c69b45f9384c X 505ed529e72649349ef4dc2b4e311a62--73efbb39517742c8a641c69b45f9384c 73efbb39517742c8a641c69b45f9384c--b70acae1886644d8a88024e67e6211f4 462100c4ca0a4015a03ba6759598aa91 73efbb39517742c8a641c69b45f9384c--462100c4ca0a4015a03ba6759598aa91 10d3b09865454ea1aece7759ba073bb3 462100c4ca0a4015a03ba6759598aa91--10d3b09865454ea1aece7759ba073bb3 5700b07d259c4f87a72024a5d39e75b3 10d3b09865454ea1aece7759ba073bb3--5700b07d259c4f87a72024a5d39e75b3 020e3ee8609a4471a5f2428c06f97f74 5700b07d259c4f87a72024a5d39e75b3--020e3ee8609a4471a5f2428c06f97f74 3866116072684448afe654b46d3b5c1d 020e3ee8609a4471a5f2428c06f97f74--3866116072684448afe654b46d3b5c1d 863a49fbb38e4eff91cc35542f593b7a 3866116072684448afe654b46d3b5c1d--863a49fbb38e4eff91cc35542f593b7a 95da2795b198481e94d46b5960643cc3 X 863a49fbb38e4eff91cc35542f593b7a--95da2795b198481e94d46b5960643cc3 95da2795b198481e94d46b5960643cc3--65df572af5b94ccda8964b5ee771380e 03de00815ab142de938a10cd207bb0e2 95da2795b198481e94d46b5960643cc3--03de00815ab142de938a10cd207bb0e2 d7669cad019344ebac0188afdc06e260 03de00815ab142de938a10cd207bb0e2--d7669cad019344ebac0188afdc06e260 09ae9027cc5941b093a671cefed1abf3 d7669cad019344ebac0188afdc06e260--09ae9027cc5941b093a671cefed1abf3 23f5da7082384a4996ef33e109cf1bc0 09ae9027cc5941b093a671cefed1abf3--23f5da7082384a4996ef33e109cf1bc0 be64646d85bf48c2b3258d1e29704af7 23f5da7082384a4996ef33e109cf1bc0--be64646d85bf48c2b3258d1e29704af7 7a9a57a86020442194ff21f1001c7814 X be64646d85bf48c2b3258d1e29704af7--7a9a57a86020442194ff21f1001c7814 7a9a57a86020442194ff21f1001c7814--032745da27e64564a0d3ca2d593b3050 11dd79c524a84eddbcf1808c578c0635 7a9a57a86020442194ff21f1001c7814--11dd79c524a84eddbcf1808c578c0635 ee0187210d374ef8acc1bd0f06696a90 11dd79c524a84eddbcf1808c578c0635--ee0187210d374ef8acc1bd0f06696a90 3d2b162107614aa9b5cd75219dd6bff1 X ee0187210d374ef8acc1bd0f06696a90--3d2b162107614aa9b5cd75219dd6bff1 3d2b162107614aa9b5cd75219dd6bff1--24d824efed73439b9a80b34d95750685 a6002b7d7f2b4b31ad034702bfd61904 3d2b162107614aa9b5cd75219dd6bff1--a6002b7d7f2b4b31ad034702bfd61904 80d5e46017074a4ba85e12c9b8e74545 a6002b7d7f2b4b31ad034702bfd61904--80d5e46017074a4ba85e12c9b8e74545 5280d95732284907826aeba5208439d9 80d5e46017074a4ba85e12c9b8e74545--5280d95732284907826aeba5208439d9 b9ba8f2f1b49442fa799967b9b705578 5280d95732284907826aeba5208439d9--b9ba8f2f1b49442fa799967b9b705578 6326dd05eb404138bcdcb05889a2b6ec b9ba8f2f1b49442fa799967b9b705578--6326dd05eb404138bcdcb05889a2b6ec 3a48b20f87974cb18e0a48e49a1b27a0 6326dd05eb404138bcdcb05889a2b6ec--3a48b20f87974cb18e0a48e49a1b27a0 ed058084888a4589a4f14d8aa08ea70c 3a48b20f87974cb18e0a48e49a1b27a0--ed058084888a4589a4f14d8aa08ea70c 06532b1271854dc5af1757e49051efe6 X ed058084888a4589a4f14d8aa08ea70c--06532b1271854dc5af1757e49051efe6 06532b1271854dc5af1757e49051efe6--2db03c030c5f41908af3c14025b0f503 aab3636d3f0a4ec9a1f81696244e5e9b 06532b1271854dc5af1757e49051efe6--aab3636d3f0a4ec9a1f81696244e5e9b 558a34865072453285c955494bdc9819 X aab3636d3f0a4ec9a1f81696244e5e9b--558a34865072453285c955494bdc9819 558a34865072453285c955494bdc9819--113e34fd15f849c7ac88b51f30b39246 5bc829dec03e41d7961cad89ba5fb38d RZ(-1.0*g0) 558a34865072453285c955494bdc9819--5bc829dec03e41d7961cad89ba5fb38d c6d696383a7948f4b95b3418c4a8749a X 5bc829dec03e41d7961cad89ba5fb38d--c6d696383a7948f4b95b3418c4a8749a c6d696383a7948f4b95b3418c4a8749a--1babfa2e2b0e4f04a0f371a07378fba2 754066a912ac446d947e2905ff9cf9c5 X c6d696383a7948f4b95b3418c4a8749a--754066a912ac446d947e2905ff9cf9c5 754066a912ac446d947e2905ff9cf9c5--4c64a438b4034db58786a46157b73303 0796438bf8df4bca914b6cfe252ee0f4 754066a912ac446d947e2905ff9cf9c5--0796438bf8df4bca914b6cfe252ee0f4 4a7391272f934d96a545c7b2906f80bf 0796438bf8df4bca914b6cfe252ee0f4--4a7391272f934d96a545c7b2906f80bf 564e0cd8e1314b9f9d31aa7372c11cf2 4a7391272f934d96a545c7b2906f80bf--564e0cd8e1314b9f9d31aa7372c11cf2 5344ef3ed2484deabcf88e9b35277fd4 X 564e0cd8e1314b9f9d31aa7372c11cf2--5344ef3ed2484deabcf88e9b35277fd4 5344ef3ed2484deabcf88e9b35277fd4--6ebe4cb240e146aab2d87c557f590b20 864140e62f91437fa7e4cdc63615c32c X 5344ef3ed2484deabcf88e9b35277fd4--864140e62f91437fa7e4cdc63615c32c 864140e62f91437fa7e4cdc63615c32c--bb69ac540ffa4223aa3739d23f50f1b0 16d7a467474e4980839d097d701b8ff2 864140e62f91437fa7e4cdc63615c32c--16d7a467474e4980839d097d701b8ff2 84e1fcaa421842438d8a1547e24e9cc6 16d7a467474e4980839d097d701b8ff2--84e1fcaa421842438d8a1547e24e9cc6 829aa8405c094022ac4213452e1fc086 84e1fcaa421842438d8a1547e24e9cc6--829aa8405c094022ac4213452e1fc086 ee74f7be4c114326966354a3b2b611de 829aa8405c094022ac4213452e1fc086--ee74f7be4c114326966354a3b2b611de e1c410ff2e5c465a9eccaf02d8a7c50e ee74f7be4c114326966354a3b2b611de--e1c410ff2e5c465a9eccaf02d8a7c50e acb1fd50d75e4afe93b3e6f5dd018cad X e1c410ff2e5c465a9eccaf02d8a7c50e--acb1fd50d75e4afe93b3e6f5dd018cad acb1fd50d75e4afe93b3e6f5dd018cad--88dd30a71d3849d9984d40a116d19d51 4e00d0fd61714450ac438599f0b5c998 X acb1fd50d75e4afe93b3e6f5dd018cad--4e00d0fd61714450ac438599f0b5c998 4e00d0fd61714450ac438599f0b5c998--94e19728c75842eda962ae2ab7eb1437 ce34b721b5964fd1978151fcb323cba9 4e00d0fd61714450ac438599f0b5c998--ce34b721b5964fd1978151fcb323cba9 40ac1f59538c4b288137f3c70e507f3f ce34b721b5964fd1978151fcb323cba9--40ac1f59538c4b288137f3c70e507f3f aac7697660024132969f918e3a69e903 40ac1f59538c4b288137f3c70e507f3f--aac7697660024132969f918e3a69e903 352abd7403334a03b3a35749afd23a1a aac7697660024132969f918e3a69e903--352abd7403334a03b3a35749afd23a1a 7f0f1e87184c4a8e9491a1621404a9bf 352abd7403334a03b3a35749afd23a1a--7f0f1e87184c4a8e9491a1621404a9bf bff59c4f83ba413899d862543e840d56 7f0f1e87184c4a8e9491a1621404a9bf--bff59c4f83ba413899d862543e840d56 056a02e74f774457b261d134746e6af7 bff59c4f83ba413899d862543e840d56--056a02e74f774457b261d134746e6af7 4dc9ee39ccfc48029202e1baf01f1ab3 X 056a02e74f774457b261d134746e6af7--4dc9ee39ccfc48029202e1baf01f1ab3 4dc9ee39ccfc48029202e1baf01f1ab3--d129c0b86aa24d96889c7dd6a9abe4fc 99be695a7d44426e884d62c9a5fd1ac6 X 4dc9ee39ccfc48029202e1baf01f1ab3--99be695a7d44426e884d62c9a5fd1ac6 99be695a7d44426e884d62c9a5fd1ac6--9c9e983eaf244bf894d60e6ddeefa65c 3644ff3d225441d48c8485733011cde1 99be695a7d44426e884d62c9a5fd1ac6--3644ff3d225441d48c8485733011cde1 92416b8c1e5940ba828628bb42ed52fb 3644ff3d225441d48c8485733011cde1--92416b8c1e5940ba828628bb42ed52fb dafed286988643fd897c95bd243aefc0 92416b8c1e5940ba828628bb42ed52fb--dafed286988643fd897c95bd243aefc0 571dd28ed23547c4ad0e1d0474bc812e dafed286988643fd897c95bd243aefc0--571dd28ed23547c4ad0e1d0474bc812e e7b9e47e31634bf9b7944f35c54aec45 571dd28ed23547c4ad0e1d0474bc812e--e7b9e47e31634bf9b7944f35c54aec45 b6ab9e8315d44f1a934ea6b6e4cc6c2a e7b9e47e31634bf9b7944f35c54aec45--b6ab9e8315d44f1a934ea6b6e4cc6c2a 6c9efa3d94bd4e97bc807ae3e335448a b6ab9e8315d44f1a934ea6b6e4cc6c2a--6c9efa3d94bd4e97bc807ae3e335448a 150b7755d0ac46d0b9606a133b33d656 6c9efa3d94bd4e97bc807ae3e335448a--150b7755d0ac46d0b9606a133b33d656 869502ddfa3e4a3fab4c517e9849c64a 150b7755d0ac46d0b9606a133b33d656--869502ddfa3e4a3fab4c517e9849c64a b93987f573ab41c4848be1c649555f1e X 869502ddfa3e4a3fab4c517e9849c64a--b93987f573ab41c4848be1c649555f1e b93987f573ab41c4848be1c649555f1e--59de8ee9d128449f80107f38264427b7 cc0f55f3441a467aa90eb64063747523 b93987f573ab41c4848be1c649555f1e--cc0f55f3441a467aa90eb64063747523 1f79056b0f6c40d5875be1702c47a29e cc0f55f3441a467aa90eb64063747523--1f79056b0f6c40d5875be1702c47a29e 1330b828e0ae4296a6b65ab1d8ea4c85 1f79056b0f6c40d5875be1702c47a29e--1330b828e0ae4296a6b65ab1d8ea4c85 28de02c8883b42888fc2065856d95e52 1330b828e0ae4296a6b65ab1d8ea4c85--28de02c8883b42888fc2065856d95e52 d82f2dace866458b88a5b9e6d977d431 28de02c8883b42888fc2065856d95e52--d82f2dace866458b88a5b9e6d977d431 41d9d09d7a0b4e0f9dd43456e60084c1 d82f2dace866458b88a5b9e6d977d431--41d9d09d7a0b4e0f9dd43456e60084c1 478077da907942d5b61f59dcc1c46b9f 41d9d09d7a0b4e0f9dd43456e60084c1--478077da907942d5b61f59dcc1c46b9f 3673c5f6d6134dfe9974c32d794d4489 478077da907942d5b61f59dcc1c46b9f--3673c5f6d6134dfe9974c32d794d4489 4ceb10b52f4a4450bf8c52f99d5c7a82 3673c5f6d6134dfe9974c32d794d4489--4ceb10b52f4a4450bf8c52f99d5c7a82 7e31ae39221347a18909036c14ba19f1 4ceb10b52f4a4450bf8c52f99d5c7a82--7e31ae39221347a18909036c14ba19f1 17bde9996808428dbb61fa11ccd9a10f 7e31ae39221347a18909036c14ba19f1--17bde9996808428dbb61fa11ccd9a10f aa42900f6c6347df9bca6b020b301fcc 17bde9996808428dbb61fa11ccd9a10f--aa42900f6c6347df9bca6b020b301fcc 57775186c2f64578a0feaec2423ec0f4 aa42900f6c6347df9bca6b020b301fcc--57775186c2f64578a0feaec2423ec0f4 f037a9ff9a254bc091a81b0083ca6a69 57775186c2f64578a0feaec2423ec0f4--f037a9ff9a254bc091a81b0083ca6a69 44af5da0e2d94388b2fdf521d6fcafcb f037a9ff9a254bc091a81b0083ca6a69--44af5da0e2d94388b2fdf521d6fcafcb d1cf9723d5534f83a175a1fe2c5ef9a4 44af5da0e2d94388b2fdf521d6fcafcb--d1cf9723d5534f83a175a1fe2c5ef9a4 dadecdaf2cbd4fada434446c37295274 d1cf9723d5534f83a175a1fe2c5ef9a4--dadecdaf2cbd4fada434446c37295274 f8e2514f959d446faec99261e2dbbdb1 dadecdaf2cbd4fada434446c37295274--f8e2514f959d446faec99261e2dbbdb1 9bbb2ab591be4e3aba0f2a87d60e4dab f8e2514f959d446faec99261e2dbbdb1--9bbb2ab591be4e3aba0f2a87d60e4dab a3d923087c1440519e36f840ff1e957d 9bbb2ab591be4e3aba0f2a87d60e4dab--a3d923087c1440519e36f840ff1e957d 1187ff3e3e3c432c9ef16341464df32a a3d923087c1440519e36f840ff1e957d--1187ff3e3e3c432c9ef16341464df32a 5ee422d602a740319eb238cc164cad2c 1187ff3e3e3c432c9ef16341464df32a--5ee422d602a740319eb238cc164cad2c 1d5352e057ab42eb88d53ac28a362b0c 5ee422d602a740319eb238cc164cad2c--1d5352e057ab42eb88d53ac28a362b0c 0dfa77018cc445ca8ff1b637d0d8a7ce 1d5352e057ab42eb88d53ac28a362b0c--0dfa77018cc445ca8ff1b637d0d8a7ce 7199fce5ee174eb2a89e0b952665742e 0dfa77018cc445ca8ff1b637d0d8a7ce--7199fce5ee174eb2a89e0b952665742e 734b04878ac74863abc8a012759acdc5 7199fce5ee174eb2a89e0b952665742e--734b04878ac74863abc8a012759acdc5 3d8f14eacec34e3fa59cfbe4310cb4ce RX(b03) 734b04878ac74863abc8a012759acdc5--3d8f14eacec34e3fa59cfbe4310cb4ce 7f3aa4ec4cd24b4a9641f579b8c064fa 3d8f14eacec34e3fa59cfbe4310cb4ce--7f3aa4ec4cd24b4a9641f579b8c064fa f8ff90228bff41e08ba8c7f0a9537896 7f3aa4ec4cd24b4a9641f579b8c064fa--f8ff90228bff41e08ba8c7f0a9537896 8130a3330ee7432bb10860d06add98af X f8ff90228bff41e08ba8c7f0a9537896--8130a3330ee7432bb10860d06add98af 8130a3330ee7432bb10860d06add98af--ed934728eb65429fb3321c08d3b23f78 0d98789dc4964d55884ed1b900025b3a 8130a3330ee7432bb10860d06add98af--0d98789dc4964d55884ed1b900025b3a 8554aa0e4ee54fa7b383183cc74eec42 0d98789dc4964d55884ed1b900025b3a--8554aa0e4ee54fa7b383183cc74eec42 bdd1848f5b834b5782f013c4bb220116 8554aa0e4ee54fa7b383183cc74eec42--bdd1848f5b834b5782f013c4bb220116 f744f15abedb48979506a3d29ecfe5a0 bdd1848f5b834b5782f013c4bb220116--f744f15abedb48979506a3d29ecfe5a0 aafb3bc213ed42d6bcb5a803d60cca97 f744f15abedb48979506a3d29ecfe5a0--aafb3bc213ed42d6bcb5a803d60cca97 27ef9e79542e423aa156b25b1e245b11 aafb3bc213ed42d6bcb5a803d60cca97--27ef9e79542e423aa156b25b1e245b11 b8c69f71f410442c8cb3640df263a843 27ef9e79542e423aa156b25b1e245b11--b8c69f71f410442c8cb3640df263a843 c7367f5175b84cb5a06528488252c294 b8c69f71f410442c8cb3640df263a843--c7367f5175b84cb5a06528488252c294 735d9567b3c0495dacdd043117b94798 c7367f5175b84cb5a06528488252c294--735d9567b3c0495dacdd043117b94798 936e8648817c403582ad8a120f5f6c68 X 735d9567b3c0495dacdd043117b94798--936e8648817c403582ad8a120f5f6c68 936e8648817c403582ad8a120f5f6c68--fd3514d276924f9383f2f714c20bd7d0 4132819d370249d0a3921027feb88829 936e8648817c403582ad8a120f5f6c68--4132819d370249d0a3921027feb88829 4f00073f61234c8390e2682f6bde97cf 4132819d370249d0a3921027feb88829--4f00073f61234c8390e2682f6bde97cf ca40f9c698f94d3bb67354c7b5ee940e 4f00073f61234c8390e2682f6bde97cf--ca40f9c698f94d3bb67354c7b5ee940e e29c5830e13a448ba247a5e33f4206e8 ca40f9c698f94d3bb67354c7b5ee940e--e29c5830e13a448ba247a5e33f4206e8 394688ad741543ac94e63c0b93377faa e29c5830e13a448ba247a5e33f4206e8--394688ad741543ac94e63c0b93377faa fd85d245efde4123826ce8ed83b6e91c 394688ad741543ac94e63c0b93377faa--fd85d245efde4123826ce8ed83b6e91c 5258985280604c5c9678036210addaa5 fd85d245efde4123826ce8ed83b6e91c--5258985280604c5c9678036210addaa5 6386c99cb38a4ed3ab0a788e26a3f702 X 5258985280604c5c9678036210addaa5--6386c99cb38a4ed3ab0a788e26a3f702 6386c99cb38a4ed3ab0a788e26a3f702--089fa4f56a604f688f301824455f233a 2898510d745b40ee8c87b88720209b7c 6386c99cb38a4ed3ab0a788e26a3f702--2898510d745b40ee8c87b88720209b7c 2cb3cc7c5fe14d54ab88fa1daff7682b 2898510d745b40ee8c87b88720209b7c--2cb3cc7c5fe14d54ab88fa1daff7682b d9b2c42c79ac4c30ab481b1735d20c9e 2cb3cc7c5fe14d54ab88fa1daff7682b--d9b2c42c79ac4c30ab481b1735d20c9e 165bb47cda324816bd9ef02a594c4808 d9b2c42c79ac4c30ab481b1735d20c9e--165bb47cda324816bd9ef02a594c4808 7bf284d97ced4d408c01ee7b82909f06 165bb47cda324816bd9ef02a594c4808--7bf284d97ced4d408c01ee7b82909f06 4bce014012b6439c922eb4cc982d2847 X 7bf284d97ced4d408c01ee7b82909f06--4bce014012b6439c922eb4cc982d2847 4bce014012b6439c922eb4cc982d2847--031cbab8590944db9bb50f8be114b0d4 17b0ffa93f7546f190081817c1565463 4bce014012b6439c922eb4cc982d2847--17b0ffa93f7546f190081817c1565463 3dfbf84099dc4c7282f0ad7166db25d2 17b0ffa93f7546f190081817c1565463--3dfbf84099dc4c7282f0ad7166db25d2 938b8a2f18d142d1aab1a8b2e4855dd7 3dfbf84099dc4c7282f0ad7166db25d2--938b8a2f18d142d1aab1a8b2e4855dd7 f19145644e3c4bb48ba4b3e9b37386cd 938b8a2f18d142d1aab1a8b2e4855dd7--f19145644e3c4bb48ba4b3e9b37386cd f801f8fc0ed947d7acfb9d382c4fd305 X f19145644e3c4bb48ba4b3e9b37386cd--f801f8fc0ed947d7acfb9d382c4fd305 f801f8fc0ed947d7acfb9d382c4fd305--1badf6897a944ccbbecd01fe1791ee71 6f4b5c5f066e4dc9bddf5b72917645ef f801f8fc0ed947d7acfb9d382c4fd305--6f4b5c5f066e4dc9bddf5b72917645ef d1ad171508674c6a98b49215c3d5c9cd 6f4b5c5f066e4dc9bddf5b72917645ef--d1ad171508674c6a98b49215c3d5c9cd 62fb5c69ccf64ed69c060057d4b5f8c1 d1ad171508674c6a98b49215c3d5c9cd--62fb5c69ccf64ed69c060057d4b5f8c1 4aa1a19ca7984078a2e4634e39fe6405 62fb5c69ccf64ed69c060057d4b5f8c1--4aa1a19ca7984078a2e4634e39fe6405 5fc79106cd3f42a59f0337ecb48844f8 4aa1a19ca7984078a2e4634e39fe6405--5fc79106cd3f42a59f0337ecb48844f8 d60463fd505540ce9a727bba18b4c4b9 5fc79106cd3f42a59f0337ecb48844f8--d60463fd505540ce9a727bba18b4c4b9 550e20aff7cb478292aee540be593bac d60463fd505540ce9a727bba18b4c4b9--550e20aff7cb478292aee540be593bac e5e15a761ffa4a3285c6967f9dc0ce40 X 550e20aff7cb478292aee540be593bac--e5e15a761ffa4a3285c6967f9dc0ce40 e5e15a761ffa4a3285c6967f9dc0ce40--fa83cdd6a26c4090b45244dbc6dbd6c7 1a662bd8fb394df9ace99f58da770866 e5e15a761ffa4a3285c6967f9dc0ce40--1a662bd8fb394df9ace99f58da770866 ab156bdc856b4e7cafd4d79c9b35f558 1a662bd8fb394df9ace99f58da770866--ab156bdc856b4e7cafd4d79c9b35f558 d333dc54b9cf4cc599f8cb028bc8c194 ab156bdc856b4e7cafd4d79c9b35f558--d333dc54b9cf4cc599f8cb028bc8c194 59e051e7b81f4c7285f1a1c9c48a90b2 d333dc54b9cf4cc599f8cb028bc8c194--59e051e7b81f4c7285f1a1c9c48a90b2 348c6a3ab58649f5921170b5b1259814 X 59e051e7b81f4c7285f1a1c9c48a90b2--348c6a3ab58649f5921170b5b1259814 348c6a3ab58649f5921170b5b1259814--4c5133f8a5e940d89e5f566044f11dfa 021016c750b84ac0bd495970f9e0c674 348c6a3ab58649f5921170b5b1259814--021016c750b84ac0bd495970f9e0c674 98a5d99bc9a14760ae8d5f4872c206b5 021016c750b84ac0bd495970f9e0c674--98a5d99bc9a14760ae8d5f4872c206b5 778cccc197144ebd83b76a882a7988d8 98a5d99bc9a14760ae8d5f4872c206b5--778cccc197144ebd83b76a882a7988d8 6c8f7bb31957481796e459a40968c21e 778cccc197144ebd83b76a882a7988d8--6c8f7bb31957481796e459a40968c21e 3459ee5fac164e549cea7d66e51bc00b 6c8f7bb31957481796e459a40968c21e--3459ee5fac164e549cea7d66e51bc00b bfe19ad2ab9a48c8a2414edc5a143d77 3459ee5fac164e549cea7d66e51bc00b--bfe19ad2ab9a48c8a2414edc5a143d77 1967547535fc4353a211074c96c66f85 bfe19ad2ab9a48c8a2414edc5a143d77--1967547535fc4353a211074c96c66f85 364c6eda5f944f0a9c9d23b82e7a56cb 1967547535fc4353a211074c96c66f85--364c6eda5f944f0a9c9d23b82e7a56cb cccd157acf47423d96fe99ae097fb9e5 364c6eda5f944f0a9c9d23b82e7a56cb--cccd157acf47423d96fe99ae097fb9e5 91d2c894b78a408097058e5d04dfab52 X cccd157acf47423d96fe99ae097fb9e5--91d2c894b78a408097058e5d04dfab52 91d2c894b78a408097058e5d04dfab52--8d85c3fe06cf4a51b5b96b0c66633cbb b973b3feab69495386c9de34bcdab9fd 91d2c894b78a408097058e5d04dfab52--b973b3feab69495386c9de34bcdab9fd ea52c501bce243298ea1ab47cc9a9903 b973b3feab69495386c9de34bcdab9fd--ea52c501bce243298ea1ab47cc9a9903 f242b2bbf59341ce9293b4d57a7a4c66 ea52c501bce243298ea1ab47cc9a9903--f242b2bbf59341ce9293b4d57a7a4c66 f88de57263f04f21a750a62fd455e5dd f242b2bbf59341ce9293b4d57a7a4c66--f88de57263f04f21a750a62fd455e5dd d1f03e9410c743c88d0d5ca3e5ceeb55 f88de57263f04f21a750a62fd455e5dd--d1f03e9410c743c88d0d5ca3e5ceeb55 9e567e9e182a4c738fd1b719b81714da d1f03e9410c743c88d0d5ca3e5ceeb55--9e567e9e182a4c738fd1b719b81714da bf20a51fe14a4c12a2cead90156b9e50 X 9e567e9e182a4c738fd1b719b81714da--bf20a51fe14a4c12a2cead90156b9e50 bf20a51fe14a4c12a2cead90156b9e50--1716e9d76db4439a8e0d2f24aebf9afc 7d0660e0e0b8487793cb8ad4a1f6b757 bf20a51fe14a4c12a2cead90156b9e50--7d0660e0e0b8487793cb8ad4a1f6b757 52fc1e91b70b4f8e9032a3899113f48f 7d0660e0e0b8487793cb8ad4a1f6b757--52fc1e91b70b4f8e9032a3899113f48f 93ae3d54b9e14ae9af6533b9b62e10a3 52fc1e91b70b4f8e9032a3899113f48f--93ae3d54b9e14ae9af6533b9b62e10a3 1659e036e7714639b8a622515a624663 93ae3d54b9e14ae9af6533b9b62e10a3--1659e036e7714639b8a622515a624663 82603569cecb4a1c8c10ff003bd1b8e6 1659e036e7714639b8a622515a624663--82603569cecb4a1c8c10ff003bd1b8e6 a46958c4f87f42d3b60df1a7c0b5a663 X 82603569cecb4a1c8c10ff003bd1b8e6--a46958c4f87f42d3b60df1a7c0b5a663 a46958c4f87f42d3b60df1a7c0b5a663--4b83cac6fa2b40a9a68fc61ddea42e20 6da3dd9fcb444c95a8b75b1b66051da4 a46958c4f87f42d3b60df1a7c0b5a663--6da3dd9fcb444c95a8b75b1b66051da4 c36ecd043ae74947b1a21d316c3b4a98 6da3dd9fcb444c95a8b75b1b66051da4--c36ecd043ae74947b1a21d316c3b4a98 34d0ddc8154e44f0b9b3b9d72472e3a9 X c36ecd043ae74947b1a21d316c3b4a98--34d0ddc8154e44f0b9b3b9d72472e3a9 34d0ddc8154e44f0b9b3b9d72472e3a9--451d5457d4814425a0a9d11dbbf693e6 6afe26e029204cf3a8105798afc348e2 34d0ddc8154e44f0b9b3b9d72472e3a9--6afe26e029204cf3a8105798afc348e2 9353024101b646eb882703e293ab4474 6afe26e029204cf3a8105798afc348e2--9353024101b646eb882703e293ab4474 f12eb4a1aec14aeb9ebd2e537bf6e449 9353024101b646eb882703e293ab4474--f12eb4a1aec14aeb9ebd2e537bf6e449 e085387acac54a4bb8cca0aff192eced f12eb4a1aec14aeb9ebd2e537bf6e449--e085387acac54a4bb8cca0aff192eced 9e7e03b53b504e33b23f1e2139accebd e085387acac54a4bb8cca0aff192eced--9e7e03b53b504e33b23f1e2139accebd 08597670f9424978b772eb50fc1e34b5 9e7e03b53b504e33b23f1e2139accebd--08597670f9424978b772eb50fc1e34b5 cd1583e33f984dd69656c1850e105f23 08597670f9424978b772eb50fc1e34b5--cd1583e33f984dd69656c1850e105f23 bb67092bb4c44d789348a29e50387dfe X cd1583e33f984dd69656c1850e105f23--bb67092bb4c44d789348a29e50387dfe bb67092bb4c44d789348a29e50387dfe--298b8043e2364f8ea77980677c9bcb52 868a94f2aab348318e8c2c349b8b321c bb67092bb4c44d789348a29e50387dfe--868a94f2aab348318e8c2c349b8b321c 954587a30c0444aab4eeb0f90d5bc8d5 X 868a94f2aab348318e8c2c349b8b321c--954587a30c0444aab4eeb0f90d5bc8d5 954587a30c0444aab4eeb0f90d5bc8d5--dda68ec617334a1db0e8f61eaaacb4b2 f96f060d6ad94585b9d229fef51c2991 RZ(-1.0*g1) 954587a30c0444aab4eeb0f90d5bc8d5--f96f060d6ad94585b9d229fef51c2991 03d7de9765db4af98f2eb6bf99f5e90d X f96f060d6ad94585b9d229fef51c2991--03d7de9765db4af98f2eb6bf99f5e90d 03d7de9765db4af98f2eb6bf99f5e90d--92dac1315bdc4fc3a4e4b722faa318a1 6a5021269a964c128ab41bb6cd3c182e X 03d7de9765db4af98f2eb6bf99f5e90d--6a5021269a964c128ab41bb6cd3c182e 6a5021269a964c128ab41bb6cd3c182e--543dd0592ea44042b29dfb9b9251c8eb 63fcc71c816a4bf78bb8c5caebec56bc 6a5021269a964c128ab41bb6cd3c182e--63fcc71c816a4bf78bb8c5caebec56bc b3d119e04fab49d88f143720a7b8aabc 63fcc71c816a4bf78bb8c5caebec56bc--b3d119e04fab49d88f143720a7b8aabc 706e2aae32294f9e885f52915fb219ec b3d119e04fab49d88f143720a7b8aabc--706e2aae32294f9e885f52915fb219ec c4de0ac659ba4cd89bdae1ea116caaa6 X 706e2aae32294f9e885f52915fb219ec--c4de0ac659ba4cd89bdae1ea116caaa6 c4de0ac659ba4cd89bdae1ea116caaa6--28043b194d8840dea5db73913d97225c dc128793d4ba424ca821256d0bddce7c X c4de0ac659ba4cd89bdae1ea116caaa6--dc128793d4ba424ca821256d0bddce7c dc128793d4ba424ca821256d0bddce7c--9657153ab8bd411599fb6e971b42e3d2 1d5874d004b14df989ab99739ca540d7 dc128793d4ba424ca821256d0bddce7c--1d5874d004b14df989ab99739ca540d7 487c7f92ffe141ee8b986174b2cd7fe6 1d5874d004b14df989ab99739ca540d7--487c7f92ffe141ee8b986174b2cd7fe6 c979d53a180545828469c85058d37438 487c7f92ffe141ee8b986174b2cd7fe6--c979d53a180545828469c85058d37438 84ecf9a51d4f4a6d99d111a30b8fedb0 c979d53a180545828469c85058d37438--84ecf9a51d4f4a6d99d111a30b8fedb0 bde203e86930482b9c080b47dd7272d0 84ecf9a51d4f4a6d99d111a30b8fedb0--bde203e86930482b9c080b47dd7272d0 5f7fd6f650fd4425b77b8c0aa462e243 X bde203e86930482b9c080b47dd7272d0--5f7fd6f650fd4425b77b8c0aa462e243 5f7fd6f650fd4425b77b8c0aa462e243--40cc2dbdc1f6404cab39987c69364096 14528f2ebb334b2e996fa4463324cb77 X 5f7fd6f650fd4425b77b8c0aa462e243--14528f2ebb334b2e996fa4463324cb77 14528f2ebb334b2e996fa4463324cb77--a32bccdac48945e0b02d39d849d6fd3d 61d261c73ac74c65a326650ad221997d 14528f2ebb334b2e996fa4463324cb77--61d261c73ac74c65a326650ad221997d 53d9d5d983eb48fcb3c3b81491737f82 61d261c73ac74c65a326650ad221997d--53d9d5d983eb48fcb3c3b81491737f82 bda4c3d66c3f4946869f4236cb44ab54 53d9d5d983eb48fcb3c3b81491737f82--bda4c3d66c3f4946869f4236cb44ab54 3d4ff7b020c6480aba63bcf0fb130ffa bda4c3d66c3f4946869f4236cb44ab54--3d4ff7b020c6480aba63bcf0fb130ffa 7ce0a8182439451697e0f41799eb6b3d 3d4ff7b020c6480aba63bcf0fb130ffa--7ce0a8182439451697e0f41799eb6b3d 18d2ee551c134b6e8ad5840a29c2b875 7ce0a8182439451697e0f41799eb6b3d--18d2ee551c134b6e8ad5840a29c2b875 664319ae5a404cf99f26cf1622009888 18d2ee551c134b6e8ad5840a29c2b875--664319ae5a404cf99f26cf1622009888 b760ecebc65b4cfab66b35d9a67ee83c X 664319ae5a404cf99f26cf1622009888--b760ecebc65b4cfab66b35d9a67ee83c b760ecebc65b4cfab66b35d9a67ee83c--6dfb190ffe6c4fb992029cd0d7679601 c1d6938ebf404adc80e36b0b1419bf86 X b760ecebc65b4cfab66b35d9a67ee83c--c1d6938ebf404adc80e36b0b1419bf86 c1d6938ebf404adc80e36b0b1419bf86--a3446d361f4844db9e7ede2d13d33b18 094859a710d740939082cf748422921a c1d6938ebf404adc80e36b0b1419bf86--094859a710d740939082cf748422921a b52b2a2b2cb24bd0a22e58d87f24b61b 094859a710d740939082cf748422921a--b52b2a2b2cb24bd0a22e58d87f24b61b 311f5258c90c4aeca458e8a5f0a59bd2 b52b2a2b2cb24bd0a22e58d87f24b61b--311f5258c90c4aeca458e8a5f0a59bd2 9cec3bbf2a8447e1a9c604ec689b911b 311f5258c90c4aeca458e8a5f0a59bd2--9cec3bbf2a8447e1a9c604ec689b911b c2d8d563d6ac4159b42cf822015913c2 9cec3bbf2a8447e1a9c604ec689b911b--c2d8d563d6ac4159b42cf822015913c2 0ecff8f0b2eb4a5cb16d424b1e10b348 c2d8d563d6ac4159b42cf822015913c2--0ecff8f0b2eb4a5cb16d424b1e10b348 528fde1b31844848b3ab369b0c36471e 0ecff8f0b2eb4a5cb16d424b1e10b348--528fde1b31844848b3ab369b0c36471e 03d7e30740064636a6736f6b29cda7e9 528fde1b31844848b3ab369b0c36471e--03d7e30740064636a6736f6b29cda7e9 79b5a60f56e14d40b989e5e7c5fe1ee1 03d7e30740064636a6736f6b29cda7e9--79b5a60f56e14d40b989e5e7c5fe1ee1 13a45fc7502a46ab9b615031288cc737 X 79b5a60f56e14d40b989e5e7c5fe1ee1--13a45fc7502a46ab9b615031288cc737 13a45fc7502a46ab9b615031288cc737--c5cf5de36b5e40ca9e813d0e8eeb8e98 dd1d3c5d3e0b4842bbe993c92f87b13f 13a45fc7502a46ab9b615031288cc737--dd1d3c5d3e0b4842bbe993c92f87b13f 6f42a5c3515145c5812b7753175057fd dd1d3c5d3e0b4842bbe993c92f87b13f--6f42a5c3515145c5812b7753175057fd 1dade4581caa441d93b707ef120b0f98 6f42a5c3515145c5812b7753175057fd--1dade4581caa441d93b707ef120b0f98 7a25a4f1463d497b827e8c73cce0ee0f 1dade4581caa441d93b707ef120b0f98--7a25a4f1463d497b827e8c73cce0ee0f 301ad4135da54d65b72e928ff5e5ccb3 7a25a4f1463d497b827e8c73cce0ee0f--301ad4135da54d65b72e928ff5e5ccb3 e777396bd39f451a854e29e7cd80b9a2 301ad4135da54d65b72e928ff5e5ccb3--e777396bd39f451a854e29e7cd80b9a2 c65bebe656494d36b185067d4ca547df e777396bd39f451a854e29e7cd80b9a2--c65bebe656494d36b185067d4ca547df 88a5484fb2a3405a87f0920a936e5d7e c65bebe656494d36b185067d4ca547df--88a5484fb2a3405a87f0920a936e5d7e e58788f6afa64e71879e2e64684304bc 88a5484fb2a3405a87f0920a936e5d7e--e58788f6afa64e71879e2e64684304bc 159da493ae9d4bfc97135f8be9b575f6 e58788f6afa64e71879e2e64684304bc--159da493ae9d4bfc97135f8be9b575f6 73b9b12084454c5db1d1e63ffcaee311 159da493ae9d4bfc97135f8be9b575f6--73b9b12084454c5db1d1e63ffcaee311 de74ab185ac74dfa830004546333cb12 73b9b12084454c5db1d1e63ffcaee311--de74ab185ac74dfa830004546333cb12 4319d35b92b24853b8979bae3b0ff5b2 de74ab185ac74dfa830004546333cb12--4319d35b92b24853b8979bae3b0ff5b2 7caafec849b644b19eacf47b0e5f0509 4319d35b92b24853b8979bae3b0ff5b2--7caafec849b644b19eacf47b0e5f0509 88d92b768f054386a489b0cb513b26ad 7caafec849b644b19eacf47b0e5f0509--88d92b768f054386a489b0cb513b26ad 661cc2ea0fc4425e88f558fdea4f5c13 88d92b768f054386a489b0cb513b26ad--661cc2ea0fc4425e88f558fdea4f5c13 17be155a92f2420aab4e8068fec0bba6 661cc2ea0fc4425e88f558fdea4f5c13--17be155a92f2420aab4e8068fec0bba6 6a5b829140234d64b8b3416753fc7b80 17be155a92f2420aab4e8068fec0bba6--6a5b829140234d64b8b3416753fc7b80 f19b0e83c22d4485bcd5a66d33b1f254 6a5b829140234d64b8b3416753fc7b80--f19b0e83c22d4485bcd5a66d33b1f254 40dd2380afbf48cb8a16941138d10e86 f19b0e83c22d4485bcd5a66d33b1f254--40dd2380afbf48cb8a16941138d10e86 070ddeb33e624dc48574238778a083eb 40dd2380afbf48cb8a16941138d10e86--070ddeb33e624dc48574238778a083eb 095282c605f442ec9f0fbc65d3889880 070ddeb33e624dc48574238778a083eb--095282c605f442ec9f0fbc65d3889880 1cd89fd6d393458db8aa07c5a88b00bc 095282c605f442ec9f0fbc65d3889880--1cd89fd6d393458db8aa07c5a88b00bc 13a7de8bd9cd48809e2cc0634258b2c3 1cd89fd6d393458db8aa07c5a88b00bc--13a7de8bd9cd48809e2cc0634258b2c3 a4bdeea55ea944dd8a40dabc55adf9d9 13a7de8bd9cd48809e2cc0634258b2c3--a4bdeea55ea944dd8a40dabc55adf9d9 c7f48895745f40c88d9030d273a8b1e6 a4bdeea55ea944dd8a40dabc55adf9d9--c7f48895745f40c88d9030d273a8b1e6 229d9ffc37e14bb4b5f127a158ba27b9 RX(b13) c7f48895745f40c88d9030d273a8b1e6--229d9ffc37e14bb4b5f127a158ba27b9 229d9ffc37e14bb4b5f127a158ba27b9--738e712cb32d4f2e959750cd5ec7d8e3 2c556bf5d98c4b7cb189ddcbe7d6849b e5feb56c2a2749a68475e7a3e949dada e619be1c2afc4041a08328c32952f527--e5feb56c2a2749a68475e7a3e949dada d7bae073b4124f33af531c37aed7a00d 5 b3d045a72e2f435bbc004a473cd58e57 e5feb56c2a2749a68475e7a3e949dada--b3d045a72e2f435bbc004a473cd58e57 ad57007e4c01415082437f81b55c7b5a b3d045a72e2f435bbc004a473cd58e57--ad57007e4c01415082437f81b55c7b5a 478513a17c6a447ba3569b66a057aa48 X ad57007e4c01415082437f81b55c7b5a--478513a17c6a447ba3569b66a057aa48 478513a17c6a447ba3569b66a057aa48--33cc21f6979c416489ec1084ce83649d 08ee240b87c64c8e94f9a6f779d4738c 478513a17c6a447ba3569b66a057aa48--08ee240b87c64c8e94f9a6f779d4738c 0bb7b93796364dee95d111e6cd0932e4 08ee240b87c64c8e94f9a6f779d4738c--0bb7b93796364dee95d111e6cd0932e4 3c6a589faacd498997eed1e1cd5c65f7 0bb7b93796364dee95d111e6cd0932e4--3c6a589faacd498997eed1e1cd5c65f7 6f2b7f67586b468cbfbb314ddd9c610c 3c6a589faacd498997eed1e1cd5c65f7--6f2b7f67586b468cbfbb314ddd9c610c 450a4ccc41e740deb467b8ad51390589 6f2b7f67586b468cbfbb314ddd9c610c--450a4ccc41e740deb467b8ad51390589 ad9735e02bfc4e77837c01a2b1b6c2aa 450a4ccc41e740deb467b8ad51390589--ad9735e02bfc4e77837c01a2b1b6c2aa a0a179c0d49b497d9b3ed71af2270f1f ad9735e02bfc4e77837c01a2b1b6c2aa--a0a179c0d49b497d9b3ed71af2270f1f 2e9b2c134b104fcf90d9ba904dfa79ba X a0a179c0d49b497d9b3ed71af2270f1f--2e9b2c134b104fcf90d9ba904dfa79ba 2e9b2c134b104fcf90d9ba904dfa79ba--0e6554937b11424fb4e0f0606e1c786a bb1ffa8e8aa34e4fa6569aceb0ccd7b9 2e9b2c134b104fcf90d9ba904dfa79ba--bb1ffa8e8aa34e4fa6569aceb0ccd7b9 8a984b1f32a44b8b81669c18dc4aa5f8 bb1ffa8e8aa34e4fa6569aceb0ccd7b9--8a984b1f32a44b8b81669c18dc4aa5f8 c26d3924aa0a4db8b2315181949d14c5 8a984b1f32a44b8b81669c18dc4aa5f8--c26d3924aa0a4db8b2315181949d14c5 5f7d765dfccf4231aaeed367d7351302 c26d3924aa0a4db8b2315181949d14c5--5f7d765dfccf4231aaeed367d7351302 8853cbe712b644c4891cafbe0d405684 5f7d765dfccf4231aaeed367d7351302--8853cbe712b644c4891cafbe0d405684 b808ffc19a284d0ca167db9302e7c650 8853cbe712b644c4891cafbe0d405684--b808ffc19a284d0ca167db9302e7c650 bb1953f1096e48829e49801554323a03 b808ffc19a284d0ca167db9302e7c650--bb1953f1096e48829e49801554323a03 f2c6967929f4430c94a726eced8cbe83 bb1953f1096e48829e49801554323a03--f2c6967929f4430c94a726eced8cbe83 db3929c85376488085962c7ac2d1d97d f2c6967929f4430c94a726eced8cbe83--db3929c85376488085962c7ac2d1d97d 00e650e8da62467eaefe4455b08cc1d7 X db3929c85376488085962c7ac2d1d97d--00e650e8da62467eaefe4455b08cc1d7 00e650e8da62467eaefe4455b08cc1d7--0e1e71e45d8e492598647e91dd680849 6bb6bf45a626452aa79ad1ce6c7fd7cf 00e650e8da62467eaefe4455b08cc1d7--6bb6bf45a626452aa79ad1ce6c7fd7cf d36e69c8d0fe46919ef6a1c74a3b7c88 6bb6bf45a626452aa79ad1ce6c7fd7cf--d36e69c8d0fe46919ef6a1c74a3b7c88 b025a86c4850487b95e49b626ccee423 d36e69c8d0fe46919ef6a1c74a3b7c88--b025a86c4850487b95e49b626ccee423 c80dbd2902764b7b83db94cc29b4c3e6 X b025a86c4850487b95e49b626ccee423--c80dbd2902764b7b83db94cc29b4c3e6 c80dbd2902764b7b83db94cc29b4c3e6--1bc5a86c2fd44b8281d9eae7a4fc4bb9 e4a6f98d3f524ba0b1a8cc54e2089960 c80dbd2902764b7b83db94cc29b4c3e6--e4a6f98d3f524ba0b1a8cc54e2089960 97d493257561469aa382e3ab44090b4a e4a6f98d3f524ba0b1a8cc54e2089960--97d493257561469aa382e3ab44090b4a efbac37e41574170aa1f63cbb6dc8e60 97d493257561469aa382e3ab44090b4a--efbac37e41574170aa1f63cbb6dc8e60 3996b6791896460ab12188693292cf87 efbac37e41574170aa1f63cbb6dc8e60--3996b6791896460ab12188693292cf87 2521143965bd4feb8b217bf8610c12ed 3996b6791896460ab12188693292cf87--2521143965bd4feb8b217bf8610c12ed 2425eeaa0f114d3898b47324be243e02 2521143965bd4feb8b217bf8610c12ed--2425eeaa0f114d3898b47324be243e02 29f6cd2e24ac45899d3c05228812e4e1 X 2425eeaa0f114d3898b47324be243e02--29f6cd2e24ac45899d3c05228812e4e1 29f6cd2e24ac45899d3c05228812e4e1--44b99b5691574aa287e84dc1d83c96cc f6e6009633674eb1aa0729ca43d87315 29f6cd2e24ac45899d3c05228812e4e1--f6e6009633674eb1aa0729ca43d87315 38dec4327e8c43c6a65cc53ac387b05d f6e6009633674eb1aa0729ca43d87315--38dec4327e8c43c6a65cc53ac387b05d 3484e0820bca4795a82f48441ed75c87 38dec4327e8c43c6a65cc53ac387b05d--3484e0820bca4795a82f48441ed75c87 9abfa898e9b34c82a83a0210d4a950cf 3484e0820bca4795a82f48441ed75c87--9abfa898e9b34c82a83a0210d4a950cf cbb313e42e1841559c550a4d1da81616 9abfa898e9b34c82a83a0210d4a950cf--cbb313e42e1841559c550a4d1da81616 4ae1d151ff904940b718f90608268951 X cbb313e42e1841559c550a4d1da81616--4ae1d151ff904940b718f90608268951 4ae1d151ff904940b718f90608268951--5abf3000602e460db9d6312a4987331a 019c7d99fa0241a293efe59ae99d5ffd 4ae1d151ff904940b718f90608268951--019c7d99fa0241a293efe59ae99d5ffd cac4f4f481b64f539360bec02e7687d9 019c7d99fa0241a293efe59ae99d5ffd--cac4f4f481b64f539360bec02e7687d9 d9b790653bd54b5ab57e14c9d40ae1e7 cac4f4f481b64f539360bec02e7687d9--d9b790653bd54b5ab57e14c9d40ae1e7 8df85a2a559d4d6d91d2474f1fe54edc d9b790653bd54b5ab57e14c9d40ae1e7--8df85a2a559d4d6d91d2474f1fe54edc f13e25923ea34189bec4c5040ae46065 8df85a2a559d4d6d91d2474f1fe54edc--f13e25923ea34189bec4c5040ae46065 762eee3fb53145fdb08901232927d9d1 f13e25923ea34189bec4c5040ae46065--762eee3fb53145fdb08901232927d9d1 3c046067c2224bd7821bd9957703252d X 762eee3fb53145fdb08901232927d9d1--3c046067c2224bd7821bd9957703252d 3c046067c2224bd7821bd9957703252d--d47a04505bd44599a1251083c5c32029 fd5dc23f17184d2e8e98ca4bbba3146e 3c046067c2224bd7821bd9957703252d--fd5dc23f17184d2e8e98ca4bbba3146e 691ed7d6507443fcb3e0f7c52d65d569 fd5dc23f17184d2e8e98ca4bbba3146e--691ed7d6507443fcb3e0f7c52d65d569 79872cd7e0324faa99f2bd1859a727f7 691ed7d6507443fcb3e0f7c52d65d569--79872cd7e0324faa99f2bd1859a727f7 66f088f6e10d434cb43338b014bc0447 79872cd7e0324faa99f2bd1859a727f7--66f088f6e10d434cb43338b014bc0447 469fc9ea6f8d482d910725a4b7431113 66f088f6e10d434cb43338b014bc0447--469fc9ea6f8d482d910725a4b7431113 6204a77a97c84cf1a62633746a2f03e1 469fc9ea6f8d482d910725a4b7431113--6204a77a97c84cf1a62633746a2f03e1 242121d32af346909fe1fe1076fa9c44 6204a77a97c84cf1a62633746a2f03e1--242121d32af346909fe1fe1076fa9c44 acf7355c71ff441589c1c20dca548a84 X 242121d32af346909fe1fe1076fa9c44--acf7355c71ff441589c1c20dca548a84 acf7355c71ff441589c1c20dca548a84--505ed529e72649349ef4dc2b4e311a62 441934dfc07843ce81e8756f81353bd4 acf7355c71ff441589c1c20dca548a84--441934dfc07843ce81e8756f81353bd4 2ba0ad46d4a24e5a877e92c49121e3c0 441934dfc07843ce81e8756f81353bd4--2ba0ad46d4a24e5a877e92c49121e3c0 4c1347a7ca064607ac51c97c472e726a 2ba0ad46d4a24e5a877e92c49121e3c0--4c1347a7ca064607ac51c97c472e726a 79f783e402e74107ab270416487033e6 4c1347a7ca064607ac51c97c472e726a--79f783e402e74107ab270416487033e6 4ba259d5f945442f85086acf3d3a47c2 79f783e402e74107ab270416487033e6--4ba259d5f945442f85086acf3d3a47c2 9e56ea6af5ea4f04b3de2fa3e20d1336 4ba259d5f945442f85086acf3d3a47c2--9e56ea6af5ea4f04b3de2fa3e20d1336 2390b8bdd5b2414185e2775c4181227d 9e56ea6af5ea4f04b3de2fa3e20d1336--2390b8bdd5b2414185e2775c4181227d 6a5a7f7be5b941f38fc71ca7ba070d2b 2390b8bdd5b2414185e2775c4181227d--6a5a7f7be5b941f38fc71ca7ba070d2b 3c0e0d9ac10347ca8347fbd14a895192 X 6a5a7f7be5b941f38fc71ca7ba070d2b--3c0e0d9ac10347ca8347fbd14a895192 3c0e0d9ac10347ca8347fbd14a895192--03de00815ab142de938a10cd207bb0e2 7200f32c6c684b10820bb266879303dc 3c0e0d9ac10347ca8347fbd14a895192--7200f32c6c684b10820bb266879303dc 60e03b37981944cfa2b6b4c6212d9849 7200f32c6c684b10820bb266879303dc--60e03b37981944cfa2b6b4c6212d9849 73d83c888e3e4c998826bd0428e33c82 60e03b37981944cfa2b6b4c6212d9849--73d83c888e3e4c998826bd0428e33c82 623c390f5ea9473d827a50ca4784dd2c X 73d83c888e3e4c998826bd0428e33c82--623c390f5ea9473d827a50ca4784dd2c 623c390f5ea9473d827a50ca4784dd2c--be64646d85bf48c2b3258d1e29704af7 62a41cc9e9f5466092aaefc98c13b8a7 623c390f5ea9473d827a50ca4784dd2c--62a41cc9e9f5466092aaefc98c13b8a7 a46d557c23654b57b72e1ae60a352086 62a41cc9e9f5466092aaefc98c13b8a7--a46d557c23654b57b72e1ae60a352086 ead5c6d8d6aa4ef0b8b5a2ba46eb7f82 a46d557c23654b57b72e1ae60a352086--ead5c6d8d6aa4ef0b8b5a2ba46eb7f82 56c8b518344c404cbea5e45d55806f55 ead5c6d8d6aa4ef0b8b5a2ba46eb7f82--56c8b518344c404cbea5e45d55806f55 3e2c65ab390d4d1eb7d6f8620e3a7663 X 56c8b518344c404cbea5e45d55806f55--3e2c65ab390d4d1eb7d6f8620e3a7663 3e2c65ab390d4d1eb7d6f8620e3a7663--a6002b7d7f2b4b31ad034702bfd61904 c496749421aa4f0795b775d64cee0322 3e2c65ab390d4d1eb7d6f8620e3a7663--c496749421aa4f0795b775d64cee0322 cd376943c41f439eade8cf1b3d1df484 c496749421aa4f0795b775d64cee0322--cd376943c41f439eade8cf1b3d1df484 b69bc8cf17224390beaaa44266b21773 cd376943c41f439eade8cf1b3d1df484--b69bc8cf17224390beaaa44266b21773 52fface80042418e94d04623245d4857 b69bc8cf17224390beaaa44266b21773--52fface80042418e94d04623245d4857 7e24475887854180b8db830130f5bf93 52fface80042418e94d04623245d4857--7e24475887854180b8db830130f5bf93 a0ae22450c4240f093185b59c6a58a71 X 7e24475887854180b8db830130f5bf93--a0ae22450c4240f093185b59c6a58a71 a0ae22450c4240f093185b59c6a58a71--ed058084888a4589a4f14d8aa08ea70c e61adb13b6ca48809ec2f77da99d230b a0ae22450c4240f093185b59c6a58a71--e61adb13b6ca48809ec2f77da99d230b 2028b2cfdac4406e96be6410e73c975f e61adb13b6ca48809ec2f77da99d230b--2028b2cfdac4406e96be6410e73c975f ddb3aaafa5e946a1ae7b11ccf4026c6c 2028b2cfdac4406e96be6410e73c975f--ddb3aaafa5e946a1ae7b11ccf4026c6c 56ef7d32a2864540a54930cbe7f95f38 ddb3aaafa5e946a1ae7b11ccf4026c6c--56ef7d32a2864540a54930cbe7f95f38 b60215eaa86749afb600d51de2a2de95 56ef7d32a2864540a54930cbe7f95f38--b60215eaa86749afb600d51de2a2de95 f9c2c90f5c784c3ab7b50da39a2d599f b60215eaa86749afb600d51de2a2de95--f9c2c90f5c784c3ab7b50da39a2d599f 2183ff27c2094ef0a3009b5281436cc0 X f9c2c90f5c784c3ab7b50da39a2d599f--2183ff27c2094ef0a3009b5281436cc0 2183ff27c2094ef0a3009b5281436cc0--0796438bf8df4bca914b6cfe252ee0f4 1ca9c55268f440fd97e6e1d553027903 RZ(-1.0*g0) 2183ff27c2094ef0a3009b5281436cc0--1ca9c55268f440fd97e6e1d553027903 2a70225b07b742c7a8f4853e82f69eb4 X 1ca9c55268f440fd97e6e1d553027903--2a70225b07b742c7a8f4853e82f69eb4 2a70225b07b742c7a8f4853e82f69eb4--564e0cd8e1314b9f9d31aa7372c11cf2 7810a7f311294046aeb20d3d21c37b4b 2a70225b07b742c7a8f4853e82f69eb4--7810a7f311294046aeb20d3d21c37b4b 2a6c0db54e5f43108e31bf753f91f6e7 7810a7f311294046aeb20d3d21c37b4b--2a6c0db54e5f43108e31bf753f91f6e7 6e502a5b120340e69f4e6f83f2487bbc X 2a6c0db54e5f43108e31bf753f91f6e7--6e502a5b120340e69f4e6f83f2487bbc 6e502a5b120340e69f4e6f83f2487bbc--16d7a467474e4980839d097d701b8ff2 cb607ba260584882bb1817da2f24daad 6e502a5b120340e69f4e6f83f2487bbc--cb607ba260584882bb1817da2f24daad 052e03f7bb61464f87511b887e1e66a3 cb607ba260584882bb1817da2f24daad--052e03f7bb61464f87511b887e1e66a3 a4346c0dc47146b5834cb2af391556f3 052e03f7bb61464f87511b887e1e66a3--a4346c0dc47146b5834cb2af391556f3 d0a9fc7aca7247509118974563098ef6 X a4346c0dc47146b5834cb2af391556f3--d0a9fc7aca7247509118974563098ef6 d0a9fc7aca7247509118974563098ef6--e1c410ff2e5c465a9eccaf02d8a7c50e 558c7c6c1a37401ca4c34d1f11e184f8 d0a9fc7aca7247509118974563098ef6--558c7c6c1a37401ca4c34d1f11e184f8 dfe693cabfc942a682530843efbfaf3d 558c7c6c1a37401ca4c34d1f11e184f8--dfe693cabfc942a682530843efbfaf3d 3951719b07934ba483bcacb52a7d28fb X dfe693cabfc942a682530843efbfaf3d--3951719b07934ba483bcacb52a7d28fb 3951719b07934ba483bcacb52a7d28fb--ce34b721b5964fd1978151fcb323cba9 8a2581cac2354749994579b4b33f39a3 3951719b07934ba483bcacb52a7d28fb--8a2581cac2354749994579b4b33f39a3 c076f382ba5a44beb00afd43888f3266 8a2581cac2354749994579b4b33f39a3--c076f382ba5a44beb00afd43888f3266 1c630eccc39a477094f1cebad5f50f8c c076f382ba5a44beb00afd43888f3266--1c630eccc39a477094f1cebad5f50f8c 1c786edac466406c83368c577c44695b 1c630eccc39a477094f1cebad5f50f8c--1c786edac466406c83368c577c44695b 55004907a6ab45c7b66d4508443bd9f5 1c786edac466406c83368c577c44695b--55004907a6ab45c7b66d4508443bd9f5 19ef904c53cb43109f407b725ffd8ed4 X 55004907a6ab45c7b66d4508443bd9f5--19ef904c53cb43109f407b725ffd8ed4 19ef904c53cb43109f407b725ffd8ed4--056a02e74f774457b261d134746e6af7 f7a88ad42d574d1ea48fb3492327b91c 19ef904c53cb43109f407b725ffd8ed4--f7a88ad42d574d1ea48fb3492327b91c 3fd34b09d1d64ace9d798b8e94d77d0e f7a88ad42d574d1ea48fb3492327b91c--3fd34b09d1d64ace9d798b8e94d77d0e 1fecfda786414bb6be0a31223464abca X 3fd34b09d1d64ace9d798b8e94d77d0e--1fecfda786414bb6be0a31223464abca 1fecfda786414bb6be0a31223464abca--3644ff3d225441d48c8485733011cde1 34888d1fe19749ebb506ca7d342bae4c 1fecfda786414bb6be0a31223464abca--34888d1fe19749ebb506ca7d342bae4c 48c374421cb74b1ba0ccfc83d0b87dfb 34888d1fe19749ebb506ca7d342bae4c--48c374421cb74b1ba0ccfc83d0b87dfb e0c6ab8f4deb4ceca8a7bdf52671ee92 48c374421cb74b1ba0ccfc83d0b87dfb--e0c6ab8f4deb4ceca8a7bdf52671ee92 3282c618741a46c9a53582618274c8f5 e0c6ab8f4deb4ceca8a7bdf52671ee92--3282c618741a46c9a53582618274c8f5 db0ab25f716943b18b9908be837a5b79 3282c618741a46c9a53582618274c8f5--db0ab25f716943b18b9908be837a5b79 b3dd45ae77684602a97d7730f65ab3ec db0ab25f716943b18b9908be837a5b79--b3dd45ae77684602a97d7730f65ab3ec 8dc97403b12449859ac7d5924c3a9888 b3dd45ae77684602a97d7730f65ab3ec--8dc97403b12449859ac7d5924c3a9888 ebd8871f86da45b99621388e318a5b83 X 8dc97403b12449859ac7d5924c3a9888--ebd8871f86da45b99621388e318a5b83 ebd8871f86da45b99621388e318a5b83--869502ddfa3e4a3fab4c517e9849c64a d5171289e8464a1a9f2e595376fb002c ebd8871f86da45b99621388e318a5b83--d5171289e8464a1a9f2e595376fb002c ae9323cfc87c400b86307755cfa3b2cc X d5171289e8464a1a9f2e595376fb002c--ae9323cfc87c400b86307755cfa3b2cc ae9323cfc87c400b86307755cfa3b2cc--cc0f55f3441a467aa90eb64063747523 1c85e9bfc7de49a0b6064e25f4ae22aa RZ(-1.0*g0) ae9323cfc87c400b86307755cfa3b2cc--1c85e9bfc7de49a0b6064e25f4ae22aa 4f7487194577415e923af1645b30524c X 1c85e9bfc7de49a0b6064e25f4ae22aa--4f7487194577415e923af1645b30524c 4f7487194577415e923af1645b30524c--1330b828e0ae4296a6b65ab1d8ea4c85 26240fdd1e9a4a8c98539a67ca5ad024 X 4f7487194577415e923af1645b30524c--26240fdd1e9a4a8c98539a67ca5ad024 26240fdd1e9a4a8c98539a67ca5ad024--28de02c8883b42888fc2065856d95e52 94f3fe072af34cae970d28aa72e290fb 26240fdd1e9a4a8c98539a67ca5ad024--94f3fe072af34cae970d28aa72e290fb e824d83b4d66407a8fb38313f5ca166b 94f3fe072af34cae970d28aa72e290fb--e824d83b4d66407a8fb38313f5ca166b 4f6641e71f0848479dfd0e444c26bd83 e824d83b4d66407a8fb38313f5ca166b--4f6641e71f0848479dfd0e444c26bd83 222c8ee9b5144a84a93458961573e98a 4f6641e71f0848479dfd0e444c26bd83--222c8ee9b5144a84a93458961573e98a 7b74e6a906894aadaf70d219d5f03162 222c8ee9b5144a84a93458961573e98a--7b74e6a906894aadaf70d219d5f03162 c4f4948eac894bf99d3fb11735df1014 X 7b74e6a906894aadaf70d219d5f03162--c4f4948eac894bf99d3fb11735df1014 c4f4948eac894bf99d3fb11735df1014--7e31ae39221347a18909036c14ba19f1 88ad8f4a5a544dd587426e3b04cf2656 c4f4948eac894bf99d3fb11735df1014--88ad8f4a5a544dd587426e3b04cf2656 aa0f283025ff4e9d8c2df8703b7ce411 88ad8f4a5a544dd587426e3b04cf2656--aa0f283025ff4e9d8c2df8703b7ce411 ad7920cc59c54c358becfbacd98433db aa0f283025ff4e9d8c2df8703b7ce411--ad7920cc59c54c358becfbacd98433db f3c26b664bd143478b9403c0138b8b42 ad7920cc59c54c358becfbacd98433db--f3c26b664bd143478b9403c0138b8b42 4a375000e53b43dea0734550f64dc03a f3c26b664bd143478b9403c0138b8b42--4a375000e53b43dea0734550f64dc03a ff0a509f581a4306ac88832bf1d9b41d 4a375000e53b43dea0734550f64dc03a--ff0a509f581a4306ac88832bf1d9b41d ec6aa7de3883458fb4cdd22ff2245836 ff0a509f581a4306ac88832bf1d9b41d--ec6aa7de3883458fb4cdd22ff2245836 f17ed3abe1e24172ab4cc13e9006783b ec6aa7de3883458fb4cdd22ff2245836--f17ed3abe1e24172ab4cc13e9006783b 1d45450cfdf741f0abd9462a8c4ab78b f17ed3abe1e24172ab4cc13e9006783b--1d45450cfdf741f0abd9462a8c4ab78b e1789046aa0c4178b80e8a04e4d05f80 1d45450cfdf741f0abd9462a8c4ab78b--e1789046aa0c4178b80e8a04e4d05f80 dbf3d773fa5c471b8c0418afdead32fb e1789046aa0c4178b80e8a04e4d05f80--dbf3d773fa5c471b8c0418afdead32fb 0a43e528517d4dc882e3196000cb692a dbf3d773fa5c471b8c0418afdead32fb--0a43e528517d4dc882e3196000cb692a ddd3bf7a926242b6a0ac80dac1de681f 0a43e528517d4dc882e3196000cb692a--ddd3bf7a926242b6a0ac80dac1de681f 4e2bcc5491804be485328660565d3598 ddd3bf7a926242b6a0ac80dac1de681f--4e2bcc5491804be485328660565d3598 f7f25ad3794e402f9bf94219cf7cfbc2 4e2bcc5491804be485328660565d3598--f7f25ad3794e402f9bf94219cf7cfbc2 324f703fb0f446f1b175a14b6d681b6f f7f25ad3794e402f9bf94219cf7cfbc2--324f703fb0f446f1b175a14b6d681b6f 06d9393a0c0b45699c08231c38fd11ba RX(b04) 324f703fb0f446f1b175a14b6d681b6f--06d9393a0c0b45699c08231c38fd11ba cbeb672d1f0f4cbd8c9c15532a79a23c 06d9393a0c0b45699c08231c38fd11ba--cbeb672d1f0f4cbd8c9c15532a79a23c 4dcf84779fd34e5a8d6e243527b3c5db cbeb672d1f0f4cbd8c9c15532a79a23c--4dcf84779fd34e5a8d6e243527b3c5db 9c793f2e33bf4c63869238537ce41aab 4dcf84779fd34e5a8d6e243527b3c5db--9c793f2e33bf4c63869238537ce41aab b935fd92e86942569c155900bfdf722d X 9c793f2e33bf4c63869238537ce41aab--b935fd92e86942569c155900bfdf722d b935fd92e86942569c155900bfdf722d--0d98789dc4964d55884ed1b900025b3a f1970de4925f47b391f669582ecf1082 b935fd92e86942569c155900bfdf722d--f1970de4925f47b391f669582ecf1082 c2f881487a9340579781331ec0724e85 f1970de4925f47b391f669582ecf1082--c2f881487a9340579781331ec0724e85 ab739fd1e40a4cf58f6bd2c1310ddd9e c2f881487a9340579781331ec0724e85--ab739fd1e40a4cf58f6bd2c1310ddd9e 81890b6258844cdfb34a9d6b5120f1e1 ab739fd1e40a4cf58f6bd2c1310ddd9e--81890b6258844cdfb34a9d6b5120f1e1 ab7cbf45a3d84bb383d2f279006d1e7f 81890b6258844cdfb34a9d6b5120f1e1--ab7cbf45a3d84bb383d2f279006d1e7f 59113a2959074e88858f58faf2929e40 ab7cbf45a3d84bb383d2f279006d1e7f--59113a2959074e88858f58faf2929e40 ffbfbe52bac14c05826f03327b2ae4af 59113a2959074e88858f58faf2929e40--ffbfbe52bac14c05826f03327b2ae4af 0c3f5c1b385149e4bd47194b3de1a8df X ffbfbe52bac14c05826f03327b2ae4af--0c3f5c1b385149e4bd47194b3de1a8df 0c3f5c1b385149e4bd47194b3de1a8df--735d9567b3c0495dacdd043117b94798 849f15e668964e18a6fd3d949e565f7a 0c3f5c1b385149e4bd47194b3de1a8df--849f15e668964e18a6fd3d949e565f7a 3b2ca688a57541c6b4a228e36e119aaa 849f15e668964e18a6fd3d949e565f7a--3b2ca688a57541c6b4a228e36e119aaa 11fbb351049641b689dc7c9012e0ccb0 3b2ca688a57541c6b4a228e36e119aaa--11fbb351049641b689dc7c9012e0ccb0 d6b03af4d6c14bc2b6af2573c36c591f 11fbb351049641b689dc7c9012e0ccb0--d6b03af4d6c14bc2b6af2573c36c591f ee13193b799f4b75881721df28532aaf d6b03af4d6c14bc2b6af2573c36c591f--ee13193b799f4b75881721df28532aaf 5ec4f5ec7ddf459e82df71b013072a10 ee13193b799f4b75881721df28532aaf--5ec4f5ec7ddf459e82df71b013072a10 20531e0d1084445c922d1b7cae591469 5ec4f5ec7ddf459e82df71b013072a10--20531e0d1084445c922d1b7cae591469 699a39548e2b400bbaaa8b7f3194446a 20531e0d1084445c922d1b7cae591469--699a39548e2b400bbaaa8b7f3194446a 86050997e62f4931b3cc9995461f87fb 699a39548e2b400bbaaa8b7f3194446a--86050997e62f4931b3cc9995461f87fb 7a506a7008e040629f7a26a1759387c5 X 86050997e62f4931b3cc9995461f87fb--7a506a7008e040629f7a26a1759387c5 7a506a7008e040629f7a26a1759387c5--2898510d745b40ee8c87b88720209b7c 2c1120be3dbe47b89fa0d76020b89b20 7a506a7008e040629f7a26a1759387c5--2c1120be3dbe47b89fa0d76020b89b20 5083ad24b4e54d37b899e76e5bc77949 2c1120be3dbe47b89fa0d76020b89b20--5083ad24b4e54d37b899e76e5bc77949 e05cbce57eb74f0ca3678d6a949655ff 5083ad24b4e54d37b899e76e5bc77949--e05cbce57eb74f0ca3678d6a949655ff dcc985ee683d4db28901ba888a44f3b8 X e05cbce57eb74f0ca3678d6a949655ff--dcc985ee683d4db28901ba888a44f3b8 dcc985ee683d4db28901ba888a44f3b8--7bf284d97ced4d408c01ee7b82909f06 4058b4948d7e40c387bd578c1613e1b5 dcc985ee683d4db28901ba888a44f3b8--4058b4948d7e40c387bd578c1613e1b5 48f66471f90a4bb19004676c9b914fa9 4058b4948d7e40c387bd578c1613e1b5--48f66471f90a4bb19004676c9b914fa9 922197a728dc428d8378c1f71cf3d9be 48f66471f90a4bb19004676c9b914fa9--922197a728dc428d8378c1f71cf3d9be 28818797c4c84ab4b97ab61dde001adf 922197a728dc428d8378c1f71cf3d9be--28818797c4c84ab4b97ab61dde001adf 7d11dc9ca8a040bda22a1c6505b62581 28818797c4c84ab4b97ab61dde001adf--7d11dc9ca8a040bda22a1c6505b62581 4cfdf405e0934ff584b15c983beb625b 7d11dc9ca8a040bda22a1c6505b62581--4cfdf405e0934ff584b15c983beb625b 3ccd7f28ed8e4e52bc7635ac03ae5f84 X 4cfdf405e0934ff584b15c983beb625b--3ccd7f28ed8e4e52bc7635ac03ae5f84 3ccd7f28ed8e4e52bc7635ac03ae5f84--6f4b5c5f066e4dc9bddf5b72917645ef 4ee2b5a2753d4371bcdb8e509ad20b58 3ccd7f28ed8e4e52bc7635ac03ae5f84--4ee2b5a2753d4371bcdb8e509ad20b58 47d1f775f9334d15a2a6f74c0eadb161 4ee2b5a2753d4371bcdb8e509ad20b58--47d1f775f9334d15a2a6f74c0eadb161 6348d066428f43f881388bd59bc15f60 47d1f775f9334d15a2a6f74c0eadb161--6348d066428f43f881388bd59bc15f60 92a0e95bbc044f569d909404d2fab773 6348d066428f43f881388bd59bc15f60--92a0e95bbc044f569d909404d2fab773 edeb160877654f68910f7c04832e1645 92a0e95bbc044f569d909404d2fab773--edeb160877654f68910f7c04832e1645 2041146ba7b944698492109e5e220408 X edeb160877654f68910f7c04832e1645--2041146ba7b944698492109e5e220408 2041146ba7b944698492109e5e220408--550e20aff7cb478292aee540be593bac 7468f2e723f04d9eb9fd66868cc3abb8 2041146ba7b944698492109e5e220408--7468f2e723f04d9eb9fd66868cc3abb8 bef31bafde634b278f644513a49513b7 7468f2e723f04d9eb9fd66868cc3abb8--bef31bafde634b278f644513a49513b7 589596cf39dd41ed85efeecb9805ab3b bef31bafde634b278f644513a49513b7--589596cf39dd41ed85efeecb9805ab3b f7d88d12cfd640728c8b83a9498576a3 589596cf39dd41ed85efeecb9805ab3b--f7d88d12cfd640728c8b83a9498576a3 00f6424051c749a9aa69b57253c81dc4 f7d88d12cfd640728c8b83a9498576a3--00f6424051c749a9aa69b57253c81dc4 4c54ee3793814540b08cd474a86d0ad5 00f6424051c749a9aa69b57253c81dc4--4c54ee3793814540b08cd474a86d0ad5 a8b7dd8b9df84b5bb5fc16dcd19b94fc X 4c54ee3793814540b08cd474a86d0ad5--a8b7dd8b9df84b5bb5fc16dcd19b94fc a8b7dd8b9df84b5bb5fc16dcd19b94fc--021016c750b84ac0bd495970f9e0c674 6fce664b42d64f92aa7f71930c870232 a8b7dd8b9df84b5bb5fc16dcd19b94fc--6fce664b42d64f92aa7f71930c870232 08281e38da7843aba0f2d5ccfbbadd69 6fce664b42d64f92aa7f71930c870232--08281e38da7843aba0f2d5ccfbbadd69 6e11856fd1c5420ea1c1b2cab46ffb9b 08281e38da7843aba0f2d5ccfbbadd69--6e11856fd1c5420ea1c1b2cab46ffb9b 6a77aff7fb514ca7b5956147f2f41a6d 6e11856fd1c5420ea1c1b2cab46ffb9b--6a77aff7fb514ca7b5956147f2f41a6d b854c9d48a9a407ba3c94d3df6426bb1 6a77aff7fb514ca7b5956147f2f41a6d--b854c9d48a9a407ba3c94d3df6426bb1 156e12252cc94f3aa891a957f4af3d01 b854c9d48a9a407ba3c94d3df6426bb1--156e12252cc94f3aa891a957f4af3d01 b340a97c0a5644a69d475a5565e608be 156e12252cc94f3aa891a957f4af3d01--b340a97c0a5644a69d475a5565e608be df76e07d62d74cc3b604aed15c289999 X b340a97c0a5644a69d475a5565e608be--df76e07d62d74cc3b604aed15c289999 df76e07d62d74cc3b604aed15c289999--cccd157acf47423d96fe99ae097fb9e5 36f55f6dabd344bebbbd8bb16252f0e2 df76e07d62d74cc3b604aed15c289999--36f55f6dabd344bebbbd8bb16252f0e2 3e2d1bdd91c24a99875f746ee650827c 36f55f6dabd344bebbbd8bb16252f0e2--3e2d1bdd91c24a99875f746ee650827c 94cfd8213cab47d09fb36de1f49487da 3e2d1bdd91c24a99875f746ee650827c--94cfd8213cab47d09fb36de1f49487da beecfa8a86834d2eb8d33f283a7b693a 94cfd8213cab47d09fb36de1f49487da--beecfa8a86834d2eb8d33f283a7b693a 0850e620cf1b4f55a9cf392e5c4371d0 beecfa8a86834d2eb8d33f283a7b693a--0850e620cf1b4f55a9cf392e5c4371d0 7bb78a041a8e4749bd316a7d05bd2e04 0850e620cf1b4f55a9cf392e5c4371d0--7bb78a041a8e4749bd316a7d05bd2e04 4fdbb9517de745818f531ac03e47666b 7bb78a041a8e4749bd316a7d05bd2e04--4fdbb9517de745818f531ac03e47666b 0fd8dd8a5fc84db795b5e1ce62d04a8d 4fdbb9517de745818f531ac03e47666b--0fd8dd8a5fc84db795b5e1ce62d04a8d b871e3e1b4dc4db494b4089bcfda44c5 X 0fd8dd8a5fc84db795b5e1ce62d04a8d--b871e3e1b4dc4db494b4089bcfda44c5 b871e3e1b4dc4db494b4089bcfda44c5--7d0660e0e0b8487793cb8ad4a1f6b757 1229a5d249e6452791703dfddf0757d2 b871e3e1b4dc4db494b4089bcfda44c5--1229a5d249e6452791703dfddf0757d2 15d110bac11e4ee681a0955dbe979ac8 1229a5d249e6452791703dfddf0757d2--15d110bac11e4ee681a0955dbe979ac8 454bc40527724992b5049d5ccf4a3000 15d110bac11e4ee681a0955dbe979ac8--454bc40527724992b5049d5ccf4a3000 6dbc1e0659074dfd867c0fc85dc285e1 X 454bc40527724992b5049d5ccf4a3000--6dbc1e0659074dfd867c0fc85dc285e1 6dbc1e0659074dfd867c0fc85dc285e1--82603569cecb4a1c8c10ff003bd1b8e6 eb249e254a994c75a0d2a66d952f10be 6dbc1e0659074dfd867c0fc85dc285e1--eb249e254a994c75a0d2a66d952f10be b17d153da32a4002a08758293f8e572d eb249e254a994c75a0d2a66d952f10be--b17d153da32a4002a08758293f8e572d d20458cbb25f40b7aa4f00801b28ad34 b17d153da32a4002a08758293f8e572d--d20458cbb25f40b7aa4f00801b28ad34 3a83738934d44f548eca69516e4881e0 d20458cbb25f40b7aa4f00801b28ad34--3a83738934d44f548eca69516e4881e0 5e13cbe7e19f43d18d90071a7c42af78 X 3a83738934d44f548eca69516e4881e0--5e13cbe7e19f43d18d90071a7c42af78 5e13cbe7e19f43d18d90071a7c42af78--6afe26e029204cf3a8105798afc348e2 5d64f7866ef442f6b129c730ff13c2ee 5e13cbe7e19f43d18d90071a7c42af78--5d64f7866ef442f6b129c730ff13c2ee 6b9fdf9e67354049810beef66c645553 5d64f7866ef442f6b129c730ff13c2ee--6b9fdf9e67354049810beef66c645553 9b30df2132604cd0ba29b6a14c84b281 6b9fdf9e67354049810beef66c645553--9b30df2132604cd0ba29b6a14c84b281 378651fc44704f149cb38985e60efc41 9b30df2132604cd0ba29b6a14c84b281--378651fc44704f149cb38985e60efc41 d2479253e730451bad73633c824f6b5a 378651fc44704f149cb38985e60efc41--d2479253e730451bad73633c824f6b5a 1a0e1783d4964df99488a56dafdc4c74 X d2479253e730451bad73633c824f6b5a--1a0e1783d4964df99488a56dafdc4c74 1a0e1783d4964df99488a56dafdc4c74--cd1583e33f984dd69656c1850e105f23 fa064f559531458f997e630c4be65494 1a0e1783d4964df99488a56dafdc4c74--fa064f559531458f997e630c4be65494 24f8fcf7727f464ea6ebd6c20b7b90fd fa064f559531458f997e630c4be65494--24f8fcf7727f464ea6ebd6c20b7b90fd fda8273a381149dc87b0276ba237fc1b 24f8fcf7727f464ea6ebd6c20b7b90fd--fda8273a381149dc87b0276ba237fc1b c4fd729e78c644519304d783e5302bfc fda8273a381149dc87b0276ba237fc1b--c4fd729e78c644519304d783e5302bfc cdaefa17bd7747e7946289eb15de04cf c4fd729e78c644519304d783e5302bfc--cdaefa17bd7747e7946289eb15de04cf 2d1ef22198f44bbe9b5534e6f5350bb9 cdaefa17bd7747e7946289eb15de04cf--2d1ef22198f44bbe9b5534e6f5350bb9 e0526cc99ec9439dbd64ec42ad14bc3c X 2d1ef22198f44bbe9b5534e6f5350bb9--e0526cc99ec9439dbd64ec42ad14bc3c e0526cc99ec9439dbd64ec42ad14bc3c--63fcc71c816a4bf78bb8c5caebec56bc ce3c30496b18441794695d59570f4051 RZ(-1.0*g1) e0526cc99ec9439dbd64ec42ad14bc3c--ce3c30496b18441794695d59570f4051 f835f134ff44499ab91c6d7bcebf1d55 X ce3c30496b18441794695d59570f4051--f835f134ff44499ab91c6d7bcebf1d55 f835f134ff44499ab91c6d7bcebf1d55--706e2aae32294f9e885f52915fb219ec 797b1ec593204a36bafa069c74a0351f f835f134ff44499ab91c6d7bcebf1d55--797b1ec593204a36bafa069c74a0351f d12c284c62f24707b301c75ac7cd9718 797b1ec593204a36bafa069c74a0351f--d12c284c62f24707b301c75ac7cd9718 461bdd54b5df4c78a90bce92b3dd40fa X d12c284c62f24707b301c75ac7cd9718--461bdd54b5df4c78a90bce92b3dd40fa 461bdd54b5df4c78a90bce92b3dd40fa--1d5874d004b14df989ab99739ca540d7 a5f06fecd7d040ba95b3c8d2844912e4 461bdd54b5df4c78a90bce92b3dd40fa--a5f06fecd7d040ba95b3c8d2844912e4 8c51dd857b344241bb16570ed1add6c4 a5f06fecd7d040ba95b3c8d2844912e4--8c51dd857b344241bb16570ed1add6c4 6be9c58a854e413680cb39f4fe62f126 8c51dd857b344241bb16570ed1add6c4--6be9c58a854e413680cb39f4fe62f126 8616606141c44cc286f279ba45d5a422 X 6be9c58a854e413680cb39f4fe62f126--8616606141c44cc286f279ba45d5a422 8616606141c44cc286f279ba45d5a422--bde203e86930482b9c080b47dd7272d0 a41f35e4400643feb47afd54a3879222 8616606141c44cc286f279ba45d5a422--a41f35e4400643feb47afd54a3879222 9fde54d45dd94f8cb9554c28e0481717 a41f35e4400643feb47afd54a3879222--9fde54d45dd94f8cb9554c28e0481717 1a182d9f63ff41818d323eccea6fe2c8 X 9fde54d45dd94f8cb9554c28e0481717--1a182d9f63ff41818d323eccea6fe2c8 1a182d9f63ff41818d323eccea6fe2c8--61d261c73ac74c65a326650ad221997d bd6ae71a648b4cf5b7ae89189f027577 1a182d9f63ff41818d323eccea6fe2c8--bd6ae71a648b4cf5b7ae89189f027577 76c6368ef0914ec7bc0a084f5b17c6a7 bd6ae71a648b4cf5b7ae89189f027577--76c6368ef0914ec7bc0a084f5b17c6a7 c0b1b93c0cd64445b9e8f8cd8e06ac4b 76c6368ef0914ec7bc0a084f5b17c6a7--c0b1b93c0cd64445b9e8f8cd8e06ac4b 95af4873d9f643d9afd43496639246ad c0b1b93c0cd64445b9e8f8cd8e06ac4b--95af4873d9f643d9afd43496639246ad a695f361a52c437f95e6c66baa02d392 95af4873d9f643d9afd43496639246ad--a695f361a52c437f95e6c66baa02d392 52d588b3115345059fe011c209bf9353 X a695f361a52c437f95e6c66baa02d392--52d588b3115345059fe011c209bf9353 52d588b3115345059fe011c209bf9353--664319ae5a404cf99f26cf1622009888 9c2af1ba49144ddd887bd306ad3b2f53 52d588b3115345059fe011c209bf9353--9c2af1ba49144ddd887bd306ad3b2f53 db96008a308646e3bd64fb3c88258122 9c2af1ba49144ddd887bd306ad3b2f53--db96008a308646e3bd64fb3c88258122 33e2e0fb516f421198efb5b7cb47a194 X db96008a308646e3bd64fb3c88258122--33e2e0fb516f421198efb5b7cb47a194 33e2e0fb516f421198efb5b7cb47a194--094859a710d740939082cf748422921a 5116822b171b4870b0815068615a3b6d 33e2e0fb516f421198efb5b7cb47a194--5116822b171b4870b0815068615a3b6d 25171bae3caa4f6784009c0e69b83ed1 5116822b171b4870b0815068615a3b6d--25171bae3caa4f6784009c0e69b83ed1 a7192d20d63b4b2994ec9da7100b52b0 25171bae3caa4f6784009c0e69b83ed1--a7192d20d63b4b2994ec9da7100b52b0 00ac5bccb22c4a269efaeb76cdf6f1d3 a7192d20d63b4b2994ec9da7100b52b0--00ac5bccb22c4a269efaeb76cdf6f1d3 f0b74eff51cc46abadc84c756a6dc956 00ac5bccb22c4a269efaeb76cdf6f1d3--f0b74eff51cc46abadc84c756a6dc956 036ec7836a644dddb60cc00e5c19d914 f0b74eff51cc46abadc84c756a6dc956--036ec7836a644dddb60cc00e5c19d914 1fc41e23f34e4005ba5b2d8bd1af142c 036ec7836a644dddb60cc00e5c19d914--1fc41e23f34e4005ba5b2d8bd1af142c ff95f54c8ff24cf3a5feed1994a658b8 X 1fc41e23f34e4005ba5b2d8bd1af142c--ff95f54c8ff24cf3a5feed1994a658b8 ff95f54c8ff24cf3a5feed1994a658b8--79b5a60f56e14d40b989e5e7c5fe1ee1 d788aae6860e4275bb008d7af707259f ff95f54c8ff24cf3a5feed1994a658b8--d788aae6860e4275bb008d7af707259f 0e7f7834b3ea47fd994524af2a024b4d X d788aae6860e4275bb008d7af707259f--0e7f7834b3ea47fd994524af2a024b4d 0e7f7834b3ea47fd994524af2a024b4d--dd1d3c5d3e0b4842bbe993c92f87b13f 8a9ef5b723944f198c2e3bac54ecd0fb RZ(-1.0*g1) 0e7f7834b3ea47fd994524af2a024b4d--8a9ef5b723944f198c2e3bac54ecd0fb 3f970b0154cb404e93509b482f5c4815 X 8a9ef5b723944f198c2e3bac54ecd0fb--3f970b0154cb404e93509b482f5c4815 3f970b0154cb404e93509b482f5c4815--1dade4581caa441d93b707ef120b0f98 4dd682829f48483d809c542a37b923bc X 3f970b0154cb404e93509b482f5c4815--4dd682829f48483d809c542a37b923bc 4dd682829f48483d809c542a37b923bc--7a25a4f1463d497b827e8c73cce0ee0f d222c157462649aa9929187aa99d217a 4dd682829f48483d809c542a37b923bc--d222c157462649aa9929187aa99d217a bc5ec649da524af2a46fb88bdd724a48 d222c157462649aa9929187aa99d217a--bc5ec649da524af2a46fb88bdd724a48 2700fff433814e1eb4e3f97c5fc26360 bc5ec649da524af2a46fb88bdd724a48--2700fff433814e1eb4e3f97c5fc26360 14419d9503ee4a00a2dc1ee2e0636f57 2700fff433814e1eb4e3f97c5fc26360--14419d9503ee4a00a2dc1ee2e0636f57 bcd2b5748b0541769889a8e133b2c98e 14419d9503ee4a00a2dc1ee2e0636f57--bcd2b5748b0541769889a8e133b2c98e 410a586d0ac3489295ef5f8be70e7ef6 X bcd2b5748b0541769889a8e133b2c98e--410a586d0ac3489295ef5f8be70e7ef6 410a586d0ac3489295ef5f8be70e7ef6--159da493ae9d4bfc97135f8be9b575f6 b94e4bad1e864c5fae54e5585a71581f 410a586d0ac3489295ef5f8be70e7ef6--b94e4bad1e864c5fae54e5585a71581f d0fb7907938240d1a3467a0d8c894a59 b94e4bad1e864c5fae54e5585a71581f--d0fb7907938240d1a3467a0d8c894a59 5aa1bdb631a24afdbd165182e5cf8f7e d0fb7907938240d1a3467a0d8c894a59--5aa1bdb631a24afdbd165182e5cf8f7e 89a6934c80004a37b168139fcaef3210 5aa1bdb631a24afdbd165182e5cf8f7e--89a6934c80004a37b168139fcaef3210 d253eb2b4fdb419b85bbc8ae80ca22d3 89a6934c80004a37b168139fcaef3210--d253eb2b4fdb419b85bbc8ae80ca22d3 6539450fb19040bc971c75686a37b64a d253eb2b4fdb419b85bbc8ae80ca22d3--6539450fb19040bc971c75686a37b64a 625caaf0c4b54dbbb3da686424bcd021 6539450fb19040bc971c75686a37b64a--625caaf0c4b54dbbb3da686424bcd021 4d61e035aa884cedb1574b7e83a97ae3 625caaf0c4b54dbbb3da686424bcd021--4d61e035aa884cedb1574b7e83a97ae3 a9c5e7dc1d0c4a8aa071547726d3072e 4d61e035aa884cedb1574b7e83a97ae3--a9c5e7dc1d0c4a8aa071547726d3072e 2a17f998af4d49c8a8d313894eac302a a9c5e7dc1d0c4a8aa071547726d3072e--2a17f998af4d49c8a8d313894eac302a 928355a61f0d4c5a81f8313d35adbfcf 2a17f998af4d49c8a8d313894eac302a--928355a61f0d4c5a81f8313d35adbfcf 7df9148e92f7452b99f624bdb9c03b59 928355a61f0d4c5a81f8313d35adbfcf--7df9148e92f7452b99f624bdb9c03b59 63e47a35d80047b5ad38e725d60b726d 7df9148e92f7452b99f624bdb9c03b59--63e47a35d80047b5ad38e725d60b726d 084f13699b514101bd2e5eda13303cd8 63e47a35d80047b5ad38e725d60b726d--084f13699b514101bd2e5eda13303cd8 80489c096eb04a4ea65e0f62a689da76 084f13699b514101bd2e5eda13303cd8--80489c096eb04a4ea65e0f62a689da76 70d43ec156084d18a0ea723a2ba73606 80489c096eb04a4ea65e0f62a689da76--70d43ec156084d18a0ea723a2ba73606 a9ff81251a6641ac8a736521a8bddc2c RX(b14) 70d43ec156084d18a0ea723a2ba73606--a9ff81251a6641ac8a736521a8bddc2c a9ff81251a6641ac8a736521a8bddc2c--2c556bf5d98c4b7cb189ddcbe7d6849b cef40535bcab4a9cb535aa136dc35112 9df2b2c5754841fe8d4ceb7ca5588ced d7bae073b4124f33af531c37aed7a00d--9df2b2c5754841fe8d4ceb7ca5588ced c5fc55a9aa54403191e9ef36172b4133 6 5a8d5115e30c47d99c1f8a569bedad47 9df2b2c5754841fe8d4ceb7ca5588ced--5a8d5115e30c47d99c1f8a569bedad47 7806dc8197a84cb2930c35f759382b27 5a8d5115e30c47d99c1f8a569bedad47--7806dc8197a84cb2930c35f759382b27 5e2a7fdcc538403da67e5e6e66628613 7806dc8197a84cb2930c35f759382b27--5e2a7fdcc538403da67e5e6e66628613 03396dfffd6a43408a2f3f7f30dfc90c X 5e2a7fdcc538403da67e5e6e66628613--03396dfffd6a43408a2f3f7f30dfc90c 03396dfffd6a43408a2f3f7f30dfc90c--08ee240b87c64c8e94f9a6f779d4738c aa705c8fec7941bd8b45d0feffca44b9 03396dfffd6a43408a2f3f7f30dfc90c--aa705c8fec7941bd8b45d0feffca44b9 4417dd7343f54cd6af98999a89820aee aa705c8fec7941bd8b45d0feffca44b9--4417dd7343f54cd6af98999a89820aee 17cd98ece3a44945bc5effedb4d2fb1b 4417dd7343f54cd6af98999a89820aee--17cd98ece3a44945bc5effedb4d2fb1b 18d0deef5ed14a3eac620e9222da5a1f 17cd98ece3a44945bc5effedb4d2fb1b--18d0deef5ed14a3eac620e9222da5a1f 51cc3d8692ef4ff188ac51f2f0bc398d 18d0deef5ed14a3eac620e9222da5a1f--51cc3d8692ef4ff188ac51f2f0bc398d f52834a853bd466e9e606d3aad18ee2f X 51cc3d8692ef4ff188ac51f2f0bc398d--f52834a853bd466e9e606d3aad18ee2f f52834a853bd466e9e606d3aad18ee2f--a0a179c0d49b497d9b3ed71af2270f1f 36e91890cd534b119f5d696ee2fb9686 f52834a853bd466e9e606d3aad18ee2f--36e91890cd534b119f5d696ee2fb9686 da902c01d29c43d79339449b86e48589 36e91890cd534b119f5d696ee2fb9686--da902c01d29c43d79339449b86e48589 c20d02a5c5994ccc926807d35ddc5ce9 da902c01d29c43d79339449b86e48589--c20d02a5c5994ccc926807d35ddc5ce9 7f0ac9a080004c3c856fb0f845dce1d9 c20d02a5c5994ccc926807d35ddc5ce9--7f0ac9a080004c3c856fb0f845dce1d9 d9c491c8b1d541debab1e93dcbbc6948 7f0ac9a080004c3c856fb0f845dce1d9--d9c491c8b1d541debab1e93dcbbc6948 4bec71bd92884b86957f41916a696982 d9c491c8b1d541debab1e93dcbbc6948--4bec71bd92884b86957f41916a696982 036585630e3549e1926979d8794616e2 4bec71bd92884b86957f41916a696982--036585630e3549e1926979d8794616e2 886619872e404d11a7e326dc358ef8da 036585630e3549e1926979d8794616e2--886619872e404d11a7e326dc358ef8da ff416951cc7041d6bc63dea8a460873e 886619872e404d11a7e326dc358ef8da--ff416951cc7041d6bc63dea8a460873e cd2e717710e34890849b6bf4cc4cb543 ff416951cc7041d6bc63dea8a460873e--cd2e717710e34890849b6bf4cc4cb543 5ec1a85d5ce5499885e3c8585b4772a1 cd2e717710e34890849b6bf4cc4cb543--5ec1a85d5ce5499885e3c8585b4772a1 c725d531b0c44cd3ba0f169a86132432 X 5ec1a85d5ce5499885e3c8585b4772a1--c725d531b0c44cd3ba0f169a86132432 c725d531b0c44cd3ba0f169a86132432--6bb6bf45a626452aa79ad1ce6c7fd7cf a11768146c89437eb17280b55f9deb3b RZ(-1.0*g0) c725d531b0c44cd3ba0f169a86132432--a11768146c89437eb17280b55f9deb3b f981875d77074e18ad09bea14eadbe30 X a11768146c89437eb17280b55f9deb3b--f981875d77074e18ad09bea14eadbe30 f981875d77074e18ad09bea14eadbe30--b025a86c4850487b95e49b626ccee423 8a6887bc6e174eac8d5ce17cbed33c35 f981875d77074e18ad09bea14eadbe30--8a6887bc6e174eac8d5ce17cbed33c35 c912a8a87a41489c990805a862f75216 8a6887bc6e174eac8d5ce17cbed33c35--c912a8a87a41489c990805a862f75216 9c2d9350b3194a6e8ab95edd8155af3d c912a8a87a41489c990805a862f75216--9c2d9350b3194a6e8ab95edd8155af3d 591106de1fc946ceb5d17a46b79418b3 9c2d9350b3194a6e8ab95edd8155af3d--591106de1fc946ceb5d17a46b79418b3 93d8774c70a742d19d36479725d01d96 591106de1fc946ceb5d17a46b79418b3--93d8774c70a742d19d36479725d01d96 61edc38b4d484d00ab0cf6815e82e8a6 93d8774c70a742d19d36479725d01d96--61edc38b4d484d00ab0cf6815e82e8a6 80084272cb744703b5446cde118a5567 61edc38b4d484d00ab0cf6815e82e8a6--80084272cb744703b5446cde118a5567 d4ec23d648304191a5b0a0b844d1f4a0 80084272cb744703b5446cde118a5567--d4ec23d648304191a5b0a0b844d1f4a0 c81f9357faa046068342f83682e07c08 X d4ec23d648304191a5b0a0b844d1f4a0--c81f9357faa046068342f83682e07c08 c81f9357faa046068342f83682e07c08--f6e6009633674eb1aa0729ca43d87315 7d9240baade340f8a136acd4e0d3ebaa c81f9357faa046068342f83682e07c08--7d9240baade340f8a136acd4e0d3ebaa 42b223d0a5484ea09e49d9971b9098d7 7d9240baade340f8a136acd4e0d3ebaa--42b223d0a5484ea09e49d9971b9098d7 a36f04699a14423f962c684a67397617 42b223d0a5484ea09e49d9971b9098d7--a36f04699a14423f962c684a67397617 46b66d28d2a6468f820a520f17fe0e90 X a36f04699a14423f962c684a67397617--46b66d28d2a6468f820a520f17fe0e90 46b66d28d2a6468f820a520f17fe0e90--cbb313e42e1841559c550a4d1da81616 552a53a5b58d47f69d39713cf5f21256 46b66d28d2a6468f820a520f17fe0e90--552a53a5b58d47f69d39713cf5f21256 a843a96a82064b78b5bc759a65c0daa1 552a53a5b58d47f69d39713cf5f21256--a843a96a82064b78b5bc759a65c0daa1 a3a80eb8150a477787507726b516e214 a843a96a82064b78b5bc759a65c0daa1--a3a80eb8150a477787507726b516e214 92a386b12c1a4dedbd0ba3506c1be1c6 a3a80eb8150a477787507726b516e214--92a386b12c1a4dedbd0ba3506c1be1c6 c52d81b2739a436e942cf36bb6e19c2b 92a386b12c1a4dedbd0ba3506c1be1c6--c52d81b2739a436e942cf36bb6e19c2b ba99816a5cfe4da9aec515ec4a750c14 c52d81b2739a436e942cf36bb6e19c2b--ba99816a5cfe4da9aec515ec4a750c14 332fca01807a467bb3629f87aa21885b ba99816a5cfe4da9aec515ec4a750c14--332fca01807a467bb3629f87aa21885b bc192e6db9f44215bd073152830325c4 332fca01807a467bb3629f87aa21885b--bc192e6db9f44215bd073152830325c4 9d8e51a36e4f4eb1a3dd90362eb8e3b2 X bc192e6db9f44215bd073152830325c4--9d8e51a36e4f4eb1a3dd90362eb8e3b2 9d8e51a36e4f4eb1a3dd90362eb8e3b2--fd5dc23f17184d2e8e98ca4bbba3146e 03909a2b96974d57a5bbafa3f61456ed 9d8e51a36e4f4eb1a3dd90362eb8e3b2--03909a2b96974d57a5bbafa3f61456ed 1e929391787d4378bd74940e9726bef2 03909a2b96974d57a5bbafa3f61456ed--1e929391787d4378bd74940e9726bef2 628142a92dbb40f28014fb77aaaec9ff 1e929391787d4378bd74940e9726bef2--628142a92dbb40f28014fb77aaaec9ff ae61e3d1e76a4f499b6bdb8c6fbb4f8c 628142a92dbb40f28014fb77aaaec9ff--ae61e3d1e76a4f499b6bdb8c6fbb4f8c 1edce9a1035440549b275528deccc297 ae61e3d1e76a4f499b6bdb8c6fbb4f8c--1edce9a1035440549b275528deccc297 e585bd5645084b21853568efa3ba59b1 X 1edce9a1035440549b275528deccc297--e585bd5645084b21853568efa3ba59b1 e585bd5645084b21853568efa3ba59b1--242121d32af346909fe1fe1076fa9c44 b4d96c46b7784786b17d488129eea713 e585bd5645084b21853568efa3ba59b1--b4d96c46b7784786b17d488129eea713 d3bedd885db44bcc88f83bf34b225f93 b4d96c46b7784786b17d488129eea713--d3bedd885db44bcc88f83bf34b225f93 5245c857ff7d4d408664d93b506c87fa d3bedd885db44bcc88f83bf34b225f93--5245c857ff7d4d408664d93b506c87fa 4e4ef7e01a93488ab116b3835b29f3d5 5245c857ff7d4d408664d93b506c87fa--4e4ef7e01a93488ab116b3835b29f3d5 507d554acb3e43558a4eb11305dd9142 4e4ef7e01a93488ab116b3835b29f3d5--507d554acb3e43558a4eb11305dd9142 f479bcfcc9924c49ae2c5cd3b94b62dc 507d554acb3e43558a4eb11305dd9142--f479bcfcc9924c49ae2c5cd3b94b62dc b4d25a4190fe4a53a47cbb3046483892 f479bcfcc9924c49ae2c5cd3b94b62dc--b4d25a4190fe4a53a47cbb3046483892 535d72e6f849421d8b823f817c6a849f b4d25a4190fe4a53a47cbb3046483892--535d72e6f849421d8b823f817c6a849f c8cd402af1d14061bdf02418dde36990 535d72e6f849421d8b823f817c6a849f--c8cd402af1d14061bdf02418dde36990 780fbf70c3634770bd4688f314c743e0 c8cd402af1d14061bdf02418dde36990--780fbf70c3634770bd4688f314c743e0 7e0e0e0130884ee2a403103193456a06 X 780fbf70c3634770bd4688f314c743e0--7e0e0e0130884ee2a403103193456a06 7e0e0e0130884ee2a403103193456a06--7200f32c6c684b10820bb266879303dc a71d9d5c2d914c82ad042a52d0a8fbdc RZ(-1.0*g0) 7e0e0e0130884ee2a403103193456a06--a71d9d5c2d914c82ad042a52d0a8fbdc 559f2b0e60db4d2eb200187f69914162 X a71d9d5c2d914c82ad042a52d0a8fbdc--559f2b0e60db4d2eb200187f69914162 559f2b0e60db4d2eb200187f69914162--73d83c888e3e4c998826bd0428e33c82 071a4a8b068943ef9ffa45025981037d 559f2b0e60db4d2eb200187f69914162--071a4a8b068943ef9ffa45025981037d 8f365286632441feb720a5d03c609f63 071a4a8b068943ef9ffa45025981037d--8f365286632441feb720a5d03c609f63 807bb37858ea40338fe4069013c78916 8f365286632441feb720a5d03c609f63--807bb37858ea40338fe4069013c78916 06fa2a5a87f84980b290e26fed4bf6d9 807bb37858ea40338fe4069013c78916--06fa2a5a87f84980b290e26fed4bf6d9 2247a43519174846b847fceacf259059 06fa2a5a87f84980b290e26fed4bf6d9--2247a43519174846b847fceacf259059 2ffb1b31d9d54a54ad79ae9d3c4e6444 2247a43519174846b847fceacf259059--2ffb1b31d9d54a54ad79ae9d3c4e6444 450e8c359e2e4119b4bdae97fb871d36 X 2ffb1b31d9d54a54ad79ae9d3c4e6444--450e8c359e2e4119b4bdae97fb871d36 450e8c359e2e4119b4bdae97fb871d36--c496749421aa4f0795b775d64cee0322 f76df2008b8f4ba79e49fd544f56a05a 450e8c359e2e4119b4bdae97fb871d36--f76df2008b8f4ba79e49fd544f56a05a 96208e7c6de2495aa942255444480540 f76df2008b8f4ba79e49fd544f56a05a--96208e7c6de2495aa942255444480540 c2103b36b69f488a9abc6097f6ad742a 96208e7c6de2495aa942255444480540--c2103b36b69f488a9abc6097f6ad742a a500a034488244d0aa9c09a0fdbeccef X c2103b36b69f488a9abc6097f6ad742a--a500a034488244d0aa9c09a0fdbeccef a500a034488244d0aa9c09a0fdbeccef--7e24475887854180b8db830130f5bf93 936384847d4a445d998783a6c383fea7 a500a034488244d0aa9c09a0fdbeccef--936384847d4a445d998783a6c383fea7 9e055823adb241a9bf52da1fa445cdf9 936384847d4a445d998783a6c383fea7--9e055823adb241a9bf52da1fa445cdf9 af67c875099a49da9e82c609059f606a 9e055823adb241a9bf52da1fa445cdf9--af67c875099a49da9e82c609059f606a 140a619c0ee74336a2ebae85e0eb8d06 af67c875099a49da9e82c609059f606a--140a619c0ee74336a2ebae85e0eb8d06 3f7a3982050b4ba89fbcdecf70786578 140a619c0ee74336a2ebae85e0eb8d06--3f7a3982050b4ba89fbcdecf70786578 f4ad375643a9407ea6cf4464c73204d1 3f7a3982050b4ba89fbcdecf70786578--f4ad375643a9407ea6cf4464c73204d1 ffbf5bd0ea234971b876642bf3917c93 f4ad375643a9407ea6cf4464c73204d1--ffbf5bd0ea234971b876642bf3917c93 e6bea18e3ef94048a9bc99989607b926 ffbf5bd0ea234971b876642bf3917c93--e6bea18e3ef94048a9bc99989607b926 e5e408007cbd499d9262e237591a6ce9 e6bea18e3ef94048a9bc99989607b926--e5e408007cbd499d9262e237591a6ce9 6f6f962fdfb34aa7a1c792949ae0c560 e5e408007cbd499d9262e237591a6ce9--6f6f962fdfb34aa7a1c792949ae0c560 7489fe8ccbc94593abff1901e6e3e93f 6f6f962fdfb34aa7a1c792949ae0c560--7489fe8ccbc94593abff1901e6e3e93f 74a82545be524a97b07987ce7c9751c2 7489fe8ccbc94593abff1901e6e3e93f--74a82545be524a97b07987ce7c9751c2 3c880d8614384b03bf1bd8cf7a54b636 74a82545be524a97b07987ce7c9751c2--3c880d8614384b03bf1bd8cf7a54b636 954bf78f148f44cc95c9ebfcbe57f135 X 3c880d8614384b03bf1bd8cf7a54b636--954bf78f148f44cc95c9ebfcbe57f135 954bf78f148f44cc95c9ebfcbe57f135--cb607ba260584882bb1817da2f24daad 7e2d5034998b437881e4375f6f94cc3f RZ(-1.0*g0) 954bf78f148f44cc95c9ebfcbe57f135--7e2d5034998b437881e4375f6f94cc3f 0042fe71c7034b5dbd51481daf0f048f X 7e2d5034998b437881e4375f6f94cc3f--0042fe71c7034b5dbd51481daf0f048f 0042fe71c7034b5dbd51481daf0f048f--a4346c0dc47146b5834cb2af391556f3 8fb9eaecd44e4881b825cc98cbd69a16 0042fe71c7034b5dbd51481daf0f048f--8fb9eaecd44e4881b825cc98cbd69a16 1de72eb8b8894609b7fa9422eda6dd4b 8fb9eaecd44e4881b825cc98cbd69a16--1de72eb8b8894609b7fa9422eda6dd4b 79d86462742e49438e688c761e2c2f00 1de72eb8b8894609b7fa9422eda6dd4b--79d86462742e49438e688c761e2c2f00 f0eb5a2d62924f44a6f756ca47750114 79d86462742e49438e688c761e2c2f00--f0eb5a2d62924f44a6f756ca47750114 49144d0cbdc141198287d405159d3c21 X f0eb5a2d62924f44a6f756ca47750114--49144d0cbdc141198287d405159d3c21 49144d0cbdc141198287d405159d3c21--8a2581cac2354749994579b4b33f39a3 8cc4252bf2354f5abcf5bf2417f20003 49144d0cbdc141198287d405159d3c21--8cc4252bf2354f5abcf5bf2417f20003 3eb5cf703ea045d0bfe70bec13fdbfb7 8cc4252bf2354f5abcf5bf2417f20003--3eb5cf703ea045d0bfe70bec13fdbfb7 5c05daa96f3f4c8dace9cf4c35378579 3eb5cf703ea045d0bfe70bec13fdbfb7--5c05daa96f3f4c8dace9cf4c35378579 23fb7e9594904b3eb6b4de31e86b07d6 X 5c05daa96f3f4c8dace9cf4c35378579--23fb7e9594904b3eb6b4de31e86b07d6 23fb7e9594904b3eb6b4de31e86b07d6--55004907a6ab45c7b66d4508443bd9f5 5d9b112a1110422699180a7493a5152e 23fb7e9594904b3eb6b4de31e86b07d6--5d9b112a1110422699180a7493a5152e 7a0de8ec01e649d989877d826897bc73 5d9b112a1110422699180a7493a5152e--7a0de8ec01e649d989877d826897bc73 a82cb97cc95445ceaef6e18b938579ff 7a0de8ec01e649d989877d826897bc73--a82cb97cc95445ceaef6e18b938579ff f18b40b3576b466f9f1cde936f226d2b a82cb97cc95445ceaef6e18b938579ff--f18b40b3576b466f9f1cde936f226d2b f67cf337f3fe4a308e50e238ad968110 X f18b40b3576b466f9f1cde936f226d2b--f67cf337f3fe4a308e50e238ad968110 f67cf337f3fe4a308e50e238ad968110--34888d1fe19749ebb506ca7d342bae4c 2c75c146b81a49d2ac9c320919a52f34 f67cf337f3fe4a308e50e238ad968110--2c75c146b81a49d2ac9c320919a52f34 73fd0652b11845e0a51c6b2014b7a6ae 2c75c146b81a49d2ac9c320919a52f34--73fd0652b11845e0a51c6b2014b7a6ae e637a5b96f1f45df9740a9d67c166a52 73fd0652b11845e0a51c6b2014b7a6ae--e637a5b96f1f45df9740a9d67c166a52 b11d46a94e6d498090e2380b1480b69c e637a5b96f1f45df9740a9d67c166a52--b11d46a94e6d498090e2380b1480b69c 71e2846d52b14124ac9e8274a1ea96bd b11d46a94e6d498090e2380b1480b69c--71e2846d52b14124ac9e8274a1ea96bd 5824f2417a8e4d258819a49f91af7686 X 71e2846d52b14124ac9e8274a1ea96bd--5824f2417a8e4d258819a49f91af7686 5824f2417a8e4d258819a49f91af7686--8dc97403b12449859ac7d5924c3a9888 e2ae618cd2274a128f7d837d590784a2 5824f2417a8e4d258819a49f91af7686--e2ae618cd2274a128f7d837d590784a2 ec78df46a10348c8b3a8b7fcfe9287cf e2ae618cd2274a128f7d837d590784a2--ec78df46a10348c8b3a8b7fcfe9287cf 4cd227cb7f164519870e006cac350a4a ec78df46a10348c8b3a8b7fcfe9287cf--4cd227cb7f164519870e006cac350a4a dd8e1d479efc4d4fb9bc2ad07ae67f00 4cd227cb7f164519870e006cac350a4a--dd8e1d479efc4d4fb9bc2ad07ae67f00 fc83d1925a914185b7be2c4f722dafae dd8e1d479efc4d4fb9bc2ad07ae67f00--fc83d1925a914185b7be2c4f722dafae 0ce6d54346de444f821b7a6c0f9c7bf7 fc83d1925a914185b7be2c4f722dafae--0ce6d54346de444f821b7a6c0f9c7bf7 ac4fff1ec28245a9b4f63b9d51a8a972 X 0ce6d54346de444f821b7a6c0f9c7bf7--ac4fff1ec28245a9b4f63b9d51a8a972 ac4fff1ec28245a9b4f63b9d51a8a972--94f3fe072af34cae970d28aa72e290fb 7e35ab49441a48439b93fa03e2e2c54a ac4fff1ec28245a9b4f63b9d51a8a972--7e35ab49441a48439b93fa03e2e2c54a 626f5e60300d405496318469cfb0332f 7e35ab49441a48439b93fa03e2e2c54a--626f5e60300d405496318469cfb0332f d84e2b1b7eb24bd8b9ecec24c042878f 626f5e60300d405496318469cfb0332f--d84e2b1b7eb24bd8b9ecec24c042878f 6d50481004fc441f9de5b94477a6922a X d84e2b1b7eb24bd8b9ecec24c042878f--6d50481004fc441f9de5b94477a6922a 6d50481004fc441f9de5b94477a6922a--7b74e6a906894aadaf70d219d5f03162 ed181d20c30643cc86f9d42805bef3fa 6d50481004fc441f9de5b94477a6922a--ed181d20c30643cc86f9d42805bef3fa c4b79795079d4a5fa74cc2767a74a728 X ed181d20c30643cc86f9d42805bef3fa--c4b79795079d4a5fa74cc2767a74a728 c4b79795079d4a5fa74cc2767a74a728--88ad8f4a5a544dd587426e3b04cf2656 5bee903473b649fcae05e12d529318b3 RZ(-1.0*g0) c4b79795079d4a5fa74cc2767a74a728--5bee903473b649fcae05e12d529318b3 807262530b554f34ba1988a6b997c416 X 5bee903473b649fcae05e12d529318b3--807262530b554f34ba1988a6b997c416 807262530b554f34ba1988a6b997c416--ad7920cc59c54c358becfbacd98433db 0246ea8376054d94a432d5a0fae64292 X 807262530b554f34ba1988a6b997c416--0246ea8376054d94a432d5a0fae64292 0246ea8376054d94a432d5a0fae64292--f3c26b664bd143478b9403c0138b8b42 35503bb9e3c940aeb1f9ab465560849f 0246ea8376054d94a432d5a0fae64292--35503bb9e3c940aeb1f9ab465560849f 52a99f2e15da44d6a9cbc8d83a024a30 35503bb9e3c940aeb1f9ab465560849f--52a99f2e15da44d6a9cbc8d83a024a30 74f03ea7719a4bbf97533dd900cfbef1 52a99f2e15da44d6a9cbc8d83a024a30--74f03ea7719a4bbf97533dd900cfbef1 5b3d1d7d059746bfb759d0345f695161 X 74f03ea7719a4bbf97533dd900cfbef1--5b3d1d7d059746bfb759d0345f695161 5b3d1d7d059746bfb759d0345f695161--f17ed3abe1e24172ab4cc13e9006783b dd685f52dec741279552277a1b7e4e98 5b3d1d7d059746bfb759d0345f695161--dd685f52dec741279552277a1b7e4e98 d47cac411de0494eb29b2481404c1a14 dd685f52dec741279552277a1b7e4e98--d47cac411de0494eb29b2481404c1a14 f25f32b240d34c8c8cf9368017aeea51 d47cac411de0494eb29b2481404c1a14--f25f32b240d34c8c8cf9368017aeea51 d775d53133144de0ba06c30ce18def97 f25f32b240d34c8c8cf9368017aeea51--d775d53133144de0ba06c30ce18def97 3b9cd7d6ab7d4a388e5e198ad8139928 d775d53133144de0ba06c30ce18def97--3b9cd7d6ab7d4a388e5e198ad8139928 94a63d13e7d04453a8888f5cec82fd96 3b9cd7d6ab7d4a388e5e198ad8139928--94a63d13e7d04453a8888f5cec82fd96 3ab7c34250974ebe92d138f53b1bcddd 94a63d13e7d04453a8888f5cec82fd96--3ab7c34250974ebe92d138f53b1bcddd 8618468bf212456e85c9f5047c897be3 3ab7c34250974ebe92d138f53b1bcddd--8618468bf212456e85c9f5047c897be3 526bdc5ceeb94d45b5ca34c9cf007f33 RX(b05) 8618468bf212456e85c9f5047c897be3--526bdc5ceeb94d45b5ca34c9cf007f33 f733334d9bf74c86b4c16882f5b4487f 526bdc5ceeb94d45b5ca34c9cf007f33--f733334d9bf74c86b4c16882f5b4487f f9d7152eb70d411db806abd6263de0ac f733334d9bf74c86b4c16882f5b4487f--f9d7152eb70d411db806abd6263de0ac c5074d2ac8754ba398b6848f5ebafd58 f9d7152eb70d411db806abd6263de0ac--c5074d2ac8754ba398b6848f5ebafd58 e47b85f592604cc2a293464534927368 c5074d2ac8754ba398b6848f5ebafd58--e47b85f592604cc2a293464534927368 a659d0c7c35a4a54bf5d173839152c60 X e47b85f592604cc2a293464534927368--a659d0c7c35a4a54bf5d173839152c60 a659d0c7c35a4a54bf5d173839152c60--f1970de4925f47b391f669582ecf1082 5aaffc15a6554547afc83157a4ffccde a659d0c7c35a4a54bf5d173839152c60--5aaffc15a6554547afc83157a4ffccde 5cbb731a91dd4db3b2c0825249fda723 5aaffc15a6554547afc83157a4ffccde--5cbb731a91dd4db3b2c0825249fda723 3460a036f0524f9485dc984b63b2e974 5cbb731a91dd4db3b2c0825249fda723--3460a036f0524f9485dc984b63b2e974 100e8133daf64c6d8a18d3caf96653aa 3460a036f0524f9485dc984b63b2e974--100e8133daf64c6d8a18d3caf96653aa 3c64a640d6774e7588c2bca1f0033daa 100e8133daf64c6d8a18d3caf96653aa--3c64a640d6774e7588c2bca1f0033daa bdee77d015824a40beef03c96f029434 X 3c64a640d6774e7588c2bca1f0033daa--bdee77d015824a40beef03c96f029434 bdee77d015824a40beef03c96f029434--ffbfbe52bac14c05826f03327b2ae4af 79ae737a9dde4f86b0bd316e98da5203 bdee77d015824a40beef03c96f029434--79ae737a9dde4f86b0bd316e98da5203 258466c73d444f9aa4eea9e1daf3cab5 79ae737a9dde4f86b0bd316e98da5203--258466c73d444f9aa4eea9e1daf3cab5 cb39a6e4b2114941a5caae3336ed79c1 258466c73d444f9aa4eea9e1daf3cab5--cb39a6e4b2114941a5caae3336ed79c1 5e3ebaa810374bb0892f2b934cd98cc6 cb39a6e4b2114941a5caae3336ed79c1--5e3ebaa810374bb0892f2b934cd98cc6 a5dbbd8701a441ba9910ed3011ea55a7 5e3ebaa810374bb0892f2b934cd98cc6--a5dbbd8701a441ba9910ed3011ea55a7 c47c7ede70ad4190bf90010a11110ef2 a5dbbd8701a441ba9910ed3011ea55a7--c47c7ede70ad4190bf90010a11110ef2 f393568e84e84672bf77fc1198253469 c47c7ede70ad4190bf90010a11110ef2--f393568e84e84672bf77fc1198253469 29af7fa6869548f78be21e36b8fb4f91 f393568e84e84672bf77fc1198253469--29af7fa6869548f78be21e36b8fb4f91 b22c80e71d7d46cf943b363904b7f15a 29af7fa6869548f78be21e36b8fb4f91--b22c80e71d7d46cf943b363904b7f15a 83e0ac6b8dd649bea92115f2ba87932b b22c80e71d7d46cf943b363904b7f15a--83e0ac6b8dd649bea92115f2ba87932b 710562b549574668b4bd60e85c3ab4a8 83e0ac6b8dd649bea92115f2ba87932b--710562b549574668b4bd60e85c3ab4a8 bd08c83d8a9a4e8d81a65e381d465c82 X 710562b549574668b4bd60e85c3ab4a8--bd08c83d8a9a4e8d81a65e381d465c82 bd08c83d8a9a4e8d81a65e381d465c82--2c1120be3dbe47b89fa0d76020b89b20 1903041d951c4ce5bd0ef575e5397eda RZ(-1.0*g1) bd08c83d8a9a4e8d81a65e381d465c82--1903041d951c4ce5bd0ef575e5397eda 001c2b2251044e53b2e7cce99b405f3d X 1903041d951c4ce5bd0ef575e5397eda--001c2b2251044e53b2e7cce99b405f3d 001c2b2251044e53b2e7cce99b405f3d--e05cbce57eb74f0ca3678d6a949655ff 5753b476960e4c0cae0b20ccb0a53806 001c2b2251044e53b2e7cce99b405f3d--5753b476960e4c0cae0b20ccb0a53806 1c9ec4465b484018979f9ca58c5fc8ac 5753b476960e4c0cae0b20ccb0a53806--1c9ec4465b484018979f9ca58c5fc8ac e0629794c1ae44a7903f2f0d9197f094 1c9ec4465b484018979f9ca58c5fc8ac--e0629794c1ae44a7903f2f0d9197f094 e80ff9731fa34072af31f06a37b3335d e0629794c1ae44a7903f2f0d9197f094--e80ff9731fa34072af31f06a37b3335d dd71ac539da242009a176e0218c43f95 e80ff9731fa34072af31f06a37b3335d--dd71ac539da242009a176e0218c43f95 ac9b5dae5c6f4b448bb3d4aaad00439a dd71ac539da242009a176e0218c43f95--ac9b5dae5c6f4b448bb3d4aaad00439a ee4298503c4a4e468cd2d8d2a9b90156 ac9b5dae5c6f4b448bb3d4aaad00439a--ee4298503c4a4e468cd2d8d2a9b90156 80298008584341309c7b15dd8902f0ab ee4298503c4a4e468cd2d8d2a9b90156--80298008584341309c7b15dd8902f0ab 72230996a00c421c9de499aa94629426 X 80298008584341309c7b15dd8902f0ab--72230996a00c421c9de499aa94629426 72230996a00c421c9de499aa94629426--4ee2b5a2753d4371bcdb8e509ad20b58 3308c6f398c2488c93b6a094b8de6e84 72230996a00c421c9de499aa94629426--3308c6f398c2488c93b6a094b8de6e84 08ca94fd33814d2faa22ae4866861696 3308c6f398c2488c93b6a094b8de6e84--08ca94fd33814d2faa22ae4866861696 f30bf038c531473d9dec94c15c01e8cd 08ca94fd33814d2faa22ae4866861696--f30bf038c531473d9dec94c15c01e8cd 9eccffb8094c407792968fcf92fac692 X f30bf038c531473d9dec94c15c01e8cd--9eccffb8094c407792968fcf92fac692 9eccffb8094c407792968fcf92fac692--edeb160877654f68910f7c04832e1645 46818344d3dc4e598b514e819ceca5e3 9eccffb8094c407792968fcf92fac692--46818344d3dc4e598b514e819ceca5e3 3591c0265d3d4d73939808f5f194c2a9 46818344d3dc4e598b514e819ceca5e3--3591c0265d3d4d73939808f5f194c2a9 519abcbdb8fe4952bc5c010a13dac043 3591c0265d3d4d73939808f5f194c2a9--519abcbdb8fe4952bc5c010a13dac043 3064d4468b844bcd8aba70df7be5231a 519abcbdb8fe4952bc5c010a13dac043--3064d4468b844bcd8aba70df7be5231a 521d1e3101e44f33b4d971f1aef6f684 3064d4468b844bcd8aba70df7be5231a--521d1e3101e44f33b4d971f1aef6f684 1b75c73d569641d4b6c8124ec7e6160c 521d1e3101e44f33b4d971f1aef6f684--1b75c73d569641d4b6c8124ec7e6160c 33a73598943544449850a0664e599075 1b75c73d569641d4b6c8124ec7e6160c--33a73598943544449850a0664e599075 284db1f0e03047088bb2c263a514bea3 33a73598943544449850a0664e599075--284db1f0e03047088bb2c263a514bea3 7cfafba951b843bd9d2736613c7f00c9 X 284db1f0e03047088bb2c263a514bea3--7cfafba951b843bd9d2736613c7f00c9 7cfafba951b843bd9d2736613c7f00c9--6fce664b42d64f92aa7f71930c870232 c606c898c7be47c08762dd056be0d9ce 7cfafba951b843bd9d2736613c7f00c9--c606c898c7be47c08762dd056be0d9ce 840917aa048641fb82624ae4fb0db18b c606c898c7be47c08762dd056be0d9ce--840917aa048641fb82624ae4fb0db18b b7858f55ac2243e2a0b535e06863f2bb 840917aa048641fb82624ae4fb0db18b--b7858f55ac2243e2a0b535e06863f2bb f0f12a800eb047059cf744175464b9d0 b7858f55ac2243e2a0b535e06863f2bb--f0f12a800eb047059cf744175464b9d0 4f843b1e0ad446709b5d763ecd4ced36 f0f12a800eb047059cf744175464b9d0--4f843b1e0ad446709b5d763ecd4ced36 0aad5ad8318a4112bbe8608d4cab3197 X 4f843b1e0ad446709b5d763ecd4ced36--0aad5ad8318a4112bbe8608d4cab3197 0aad5ad8318a4112bbe8608d4cab3197--b340a97c0a5644a69d475a5565e608be 2a2411a314614c71a239e58d2d130e7c 0aad5ad8318a4112bbe8608d4cab3197--2a2411a314614c71a239e58d2d130e7c 29f649bb61d64722a2f3f34153dd923b 2a2411a314614c71a239e58d2d130e7c--29f649bb61d64722a2f3f34153dd923b 5726621d6ede4e16b256cad7ecd801ab 29f649bb61d64722a2f3f34153dd923b--5726621d6ede4e16b256cad7ecd801ab 4a51d9adb56248f7a955e136147b732a 5726621d6ede4e16b256cad7ecd801ab--4a51d9adb56248f7a955e136147b732a bd5f9d9377b0453f95d57171ffd2141b 4a51d9adb56248f7a955e136147b732a--bd5f9d9377b0453f95d57171ffd2141b 7abc0e10fe754835b6677efd52a21660 bd5f9d9377b0453f95d57171ffd2141b--7abc0e10fe754835b6677efd52a21660 ebbea39d555f4de184b17bf8bbb16993 7abc0e10fe754835b6677efd52a21660--ebbea39d555f4de184b17bf8bbb16993 4b9aeb3c7b25475d9f7ee3b981f7f85d ebbea39d555f4de184b17bf8bbb16993--4b9aeb3c7b25475d9f7ee3b981f7f85d b030636662244fdabe94fad29032d944 4b9aeb3c7b25475d9f7ee3b981f7f85d--b030636662244fdabe94fad29032d944 4d8a47d3f2de45c98ca0b1ce483a48d4 b030636662244fdabe94fad29032d944--4d8a47d3f2de45c98ca0b1ce483a48d4 ae32457737ef49c5a8d059d6d27fa342 X 4d8a47d3f2de45c98ca0b1ce483a48d4--ae32457737ef49c5a8d059d6d27fa342 ae32457737ef49c5a8d059d6d27fa342--1229a5d249e6452791703dfddf0757d2 bac75cce9157452caeea950e4f192429 RZ(-1.0*g1) ae32457737ef49c5a8d059d6d27fa342--bac75cce9157452caeea950e4f192429 722564e5983f458a8efab0aee6399b35 X bac75cce9157452caeea950e4f192429--722564e5983f458a8efab0aee6399b35 722564e5983f458a8efab0aee6399b35--454bc40527724992b5049d5ccf4a3000 866e824994814f03b8607797375fb627 722564e5983f458a8efab0aee6399b35--866e824994814f03b8607797375fb627 3da15c2512fa4f938e2fb27495fd84e9 866e824994814f03b8607797375fb627--3da15c2512fa4f938e2fb27495fd84e9 c8032a5497c142f892769ea73b067621 3da15c2512fa4f938e2fb27495fd84e9--c8032a5497c142f892769ea73b067621 3357cc3c24cd46c1bb923263e0c12151 c8032a5497c142f892769ea73b067621--3357cc3c24cd46c1bb923263e0c12151 22d6b2b64a9849b19a03aed3c6b78f6e 3357cc3c24cd46c1bb923263e0c12151--22d6b2b64a9849b19a03aed3c6b78f6e 72bd0cf9413d48ef9bcae390f36f96d7 22d6b2b64a9849b19a03aed3c6b78f6e--72bd0cf9413d48ef9bcae390f36f96d7 ee39b097cfe04568bf484b7654abdbc1 X 72bd0cf9413d48ef9bcae390f36f96d7--ee39b097cfe04568bf484b7654abdbc1 ee39b097cfe04568bf484b7654abdbc1--5d64f7866ef442f6b129c730ff13c2ee 3bc20757db6e4e058e08efe6a34ebced ee39b097cfe04568bf484b7654abdbc1--3bc20757db6e4e058e08efe6a34ebced 5b0da68b85dd4dbd952ccf6063f38cf1 3bc20757db6e4e058e08efe6a34ebced--5b0da68b85dd4dbd952ccf6063f38cf1 920e42123930494d8efddcf59fa3c761 5b0da68b85dd4dbd952ccf6063f38cf1--920e42123930494d8efddcf59fa3c761 69591ad705ac443ea9be053ce7fe34e8 X 920e42123930494d8efddcf59fa3c761--69591ad705ac443ea9be053ce7fe34e8 69591ad705ac443ea9be053ce7fe34e8--d2479253e730451bad73633c824f6b5a e1edfa7f43f64105b36832d632fb77bb 69591ad705ac443ea9be053ce7fe34e8--e1edfa7f43f64105b36832d632fb77bb 2bb4ea975aa642b9a14dee511ee86bb4 e1edfa7f43f64105b36832d632fb77bb--2bb4ea975aa642b9a14dee511ee86bb4 2baa75b3b4774b86b9c80d11aa5bb676 2bb4ea975aa642b9a14dee511ee86bb4--2baa75b3b4774b86b9c80d11aa5bb676 2af4e7df6f78487cb990353302466382 2baa75b3b4774b86b9c80d11aa5bb676--2af4e7df6f78487cb990353302466382 4652378472224a3cb61bec3487e03dff 2af4e7df6f78487cb990353302466382--4652378472224a3cb61bec3487e03dff e27bdb7d2d4a4084a47eba09a1e59631 4652378472224a3cb61bec3487e03dff--e27bdb7d2d4a4084a47eba09a1e59631 55dc77df0d53433a8b982076ec3b5f28 e27bdb7d2d4a4084a47eba09a1e59631--55dc77df0d53433a8b982076ec3b5f28 e4612d7de085478191d07b84909a8b23 55dc77df0d53433a8b982076ec3b5f28--e4612d7de085478191d07b84909a8b23 fdf761a8d7084c5d830fc529e40612eb e4612d7de085478191d07b84909a8b23--fdf761a8d7084c5d830fc529e40612eb a0d35a7627534a8e83d8824d57a78ed3 fdf761a8d7084c5d830fc529e40612eb--a0d35a7627534a8e83d8824d57a78ed3 63f5b2d1b4d34595a5e53a5b3a78084f a0d35a7627534a8e83d8824d57a78ed3--63f5b2d1b4d34595a5e53a5b3a78084f 4c4b5ac163434b7a82dc80ec73342b9a 63f5b2d1b4d34595a5e53a5b3a78084f--4c4b5ac163434b7a82dc80ec73342b9a 92cfa7680c194f7d9ea4e4eb87b798b7 4c4b5ac163434b7a82dc80ec73342b9a--92cfa7680c194f7d9ea4e4eb87b798b7 c335cb65600247e28f6e7743c78f59e4 X 92cfa7680c194f7d9ea4e4eb87b798b7--c335cb65600247e28f6e7743c78f59e4 c335cb65600247e28f6e7743c78f59e4--a5f06fecd7d040ba95b3c8d2844912e4 5650a469a06a4c17b350848aa6418a1f RZ(-1.0*g1) c335cb65600247e28f6e7743c78f59e4--5650a469a06a4c17b350848aa6418a1f 34183eddfd0940f6bfc5f73af271f4c3 X 5650a469a06a4c17b350848aa6418a1f--34183eddfd0940f6bfc5f73af271f4c3 34183eddfd0940f6bfc5f73af271f4c3--6be9c58a854e413680cb39f4fe62f126 bbcf1a8b6f27406a8cc55527db64fde2 34183eddfd0940f6bfc5f73af271f4c3--bbcf1a8b6f27406a8cc55527db64fde2 6d1886c45fa04e32aa1e73e63d20ecac bbcf1a8b6f27406a8cc55527db64fde2--6d1886c45fa04e32aa1e73e63d20ecac b761217b5c1045578feee4bb85f69689 6d1886c45fa04e32aa1e73e63d20ecac--b761217b5c1045578feee4bb85f69689 e53ae20b0a2a49a7acb548b92c7fb114 b761217b5c1045578feee4bb85f69689--e53ae20b0a2a49a7acb548b92c7fb114 82f3619bc47c40148d91674621f92229 X e53ae20b0a2a49a7acb548b92c7fb114--82f3619bc47c40148d91674621f92229 82f3619bc47c40148d91674621f92229--bd6ae71a648b4cf5b7ae89189f027577 e17d1652e5b84dc58c1d39325ef498c2 82f3619bc47c40148d91674621f92229--e17d1652e5b84dc58c1d39325ef498c2 9c7f9042aafc43f4990a067e4226c7d4 e17d1652e5b84dc58c1d39325ef498c2--9c7f9042aafc43f4990a067e4226c7d4 a1ebccb84207462a897487f5b5766bb2 9c7f9042aafc43f4990a067e4226c7d4--a1ebccb84207462a897487f5b5766bb2 209d2eed475446368bcd22a89d52e783 X a1ebccb84207462a897487f5b5766bb2--209d2eed475446368bcd22a89d52e783 209d2eed475446368bcd22a89d52e783--a695f361a52c437f95e6c66baa02d392 e7c3dd0b67c449b9998132eba79a0e1f 209d2eed475446368bcd22a89d52e783--e7c3dd0b67c449b9998132eba79a0e1f e61ce92583bd4d18a6849760d3138135 e7c3dd0b67c449b9998132eba79a0e1f--e61ce92583bd4d18a6849760d3138135 cf9a6871569a427f8880855f5dc94199 e61ce92583bd4d18a6849760d3138135--cf9a6871569a427f8880855f5dc94199 900459cd974947ffa6cf7a08089a46a8 cf9a6871569a427f8880855f5dc94199--900459cd974947ffa6cf7a08089a46a8 48fd0619ee194faeb1a6af37866f260f X 900459cd974947ffa6cf7a08089a46a8--48fd0619ee194faeb1a6af37866f260f 48fd0619ee194faeb1a6af37866f260f--5116822b171b4870b0815068615a3b6d d54161b33f0644d6af76bc891186aeb9 48fd0619ee194faeb1a6af37866f260f--d54161b33f0644d6af76bc891186aeb9 af9b01a81e9448509833f57f7357b8c9 d54161b33f0644d6af76bc891186aeb9--af9b01a81e9448509833f57f7357b8c9 5e86362250aa4e4d8960208c2f48acba af9b01a81e9448509833f57f7357b8c9--5e86362250aa4e4d8960208c2f48acba 3344e6e2f7bc41c88c4f04a26de60c10 5e86362250aa4e4d8960208c2f48acba--3344e6e2f7bc41c88c4f04a26de60c10 0cbfa34327ec465482739b874afaa6e4 3344e6e2f7bc41c88c4f04a26de60c10--0cbfa34327ec465482739b874afaa6e4 6492c7c10b27485683a076795e8799b5 X 0cbfa34327ec465482739b874afaa6e4--6492c7c10b27485683a076795e8799b5 6492c7c10b27485683a076795e8799b5--1fc41e23f34e4005ba5b2d8bd1af142c 6e7a770837d543b4b1264d7f7716c2c7 6492c7c10b27485683a076795e8799b5--6e7a770837d543b4b1264d7f7716c2c7 0b0919536eeb46e488a3e7ef90744378 6e7a770837d543b4b1264d7f7716c2c7--0b0919536eeb46e488a3e7ef90744378 be1575dd2b0343b6b2fcfd46e4cf5399 0b0919536eeb46e488a3e7ef90744378--be1575dd2b0343b6b2fcfd46e4cf5399 366d2657caf94d119ae087a1e782cdbd be1575dd2b0343b6b2fcfd46e4cf5399--366d2657caf94d119ae087a1e782cdbd 1e14703cbbe8456d9148d14690ba9b31 366d2657caf94d119ae087a1e782cdbd--1e14703cbbe8456d9148d14690ba9b31 dd50de60404c40da91f7b3cb2715f1d7 1e14703cbbe8456d9148d14690ba9b31--dd50de60404c40da91f7b3cb2715f1d7 8bffa9e65f9a4e0fb4765073f3a273a5 X dd50de60404c40da91f7b3cb2715f1d7--8bffa9e65f9a4e0fb4765073f3a273a5 8bffa9e65f9a4e0fb4765073f3a273a5--d222c157462649aa9929187aa99d217a bb5207ad272b4326a182f46d02c08a40 8bffa9e65f9a4e0fb4765073f3a273a5--bb5207ad272b4326a182f46d02c08a40 70e16a0ee4a24a8aac7b2ac04a92efbe bb5207ad272b4326a182f46d02c08a40--70e16a0ee4a24a8aac7b2ac04a92efbe 05afac0a89c44baf95e6b9a1872c8b41 70e16a0ee4a24a8aac7b2ac04a92efbe--05afac0a89c44baf95e6b9a1872c8b41 ebacc401cda14867961c2a615364801e X 05afac0a89c44baf95e6b9a1872c8b41--ebacc401cda14867961c2a615364801e ebacc401cda14867961c2a615364801e--bcd2b5748b0541769889a8e133b2c98e bf22d1b404d047a9a16c41d405a6dee0 ebacc401cda14867961c2a615364801e--bf22d1b404d047a9a16c41d405a6dee0 5c1a163768cd49a3ab5347e9ecc2bd76 X bf22d1b404d047a9a16c41d405a6dee0--5c1a163768cd49a3ab5347e9ecc2bd76 5c1a163768cd49a3ab5347e9ecc2bd76--b94e4bad1e864c5fae54e5585a71581f 3465535bbec2494480b10877a4deda6e RZ(-1.0*g1) 5c1a163768cd49a3ab5347e9ecc2bd76--3465535bbec2494480b10877a4deda6e 13c34e0635054bef95651332da4953bb X 3465535bbec2494480b10877a4deda6e--13c34e0635054bef95651332da4953bb 13c34e0635054bef95651332da4953bb--5aa1bdb631a24afdbd165182e5cf8f7e af1cbd6077e74582b5b0086604c6e274 X 13c34e0635054bef95651332da4953bb--af1cbd6077e74582b5b0086604c6e274 af1cbd6077e74582b5b0086604c6e274--89a6934c80004a37b168139fcaef3210 a0c8d999aa2644078dc0d0695a83a207 af1cbd6077e74582b5b0086604c6e274--a0c8d999aa2644078dc0d0695a83a207 5d050d3bc3b3437ba528ec642f4678e5 a0c8d999aa2644078dc0d0695a83a207--5d050d3bc3b3437ba528ec642f4678e5 3a78a4adae2b4a0b9741890d1c138c98 5d050d3bc3b3437ba528ec642f4678e5--3a78a4adae2b4a0b9741890d1c138c98 79407c9a9b01478e810b4e6b899c073c X 3a78a4adae2b4a0b9741890d1c138c98--79407c9a9b01478e810b4e6b899c073c 79407c9a9b01478e810b4e6b899c073c--4d61e035aa884cedb1574b7e83a97ae3 76ff6ebb63c04243a5da42081573cab1 79407c9a9b01478e810b4e6b899c073c--76ff6ebb63c04243a5da42081573cab1 0b8e909aee7b4d8db71444d8eaf90cb2 76ff6ebb63c04243a5da42081573cab1--0b8e909aee7b4d8db71444d8eaf90cb2 5df04bf7d9334e9ba697b3171f9e3c7e 0b8e909aee7b4d8db71444d8eaf90cb2--5df04bf7d9334e9ba697b3171f9e3c7e 60de056d5bd34440bd004f1b4ec7b11c 5df04bf7d9334e9ba697b3171f9e3c7e--60de056d5bd34440bd004f1b4ec7b11c 2c273538e62040388ad1c9d2b7ec0522 60de056d5bd34440bd004f1b4ec7b11c--2c273538e62040388ad1c9d2b7ec0522 ce2534e2ad344b87b3540cfe6c10d35c 2c273538e62040388ad1c9d2b7ec0522--ce2534e2ad344b87b3540cfe6c10d35c 93b2f8e536254016b81a29774b7dbf11 ce2534e2ad344b87b3540cfe6c10d35c--93b2f8e536254016b81a29774b7dbf11 fd050c76d17d4be0867b87cd4cc2908a 93b2f8e536254016b81a29774b7dbf11--fd050c76d17d4be0867b87cd4cc2908a b5e3a2d859824196b45145ea993ef19f RX(b15) fd050c76d17d4be0867b87cd4cc2908a--b5e3a2d859824196b45145ea993ef19f b5e3a2d859824196b45145ea993ef19f--cef40535bcab4a9cb535aa136dc35112 07fad1d41dc94e3eaa1ca34dc2755ec0 9cdbf9e234f24ed08b6e4574b93d6d26 c5fc55a9aa54403191e9ef36172b4133--9cdbf9e234f24ed08b6e4574b93d6d26 e75f7f6431c545c89e7ac7191a5a798c 7 67e367b1bc7547e0b7c3bf6c824b5448 9cdbf9e234f24ed08b6e4574b93d6d26--67e367b1bc7547e0b7c3bf6c824b5448 c4790b66c3914c2aad291a88a3704d47 67e367b1bc7547e0b7c3bf6c824b5448--c4790b66c3914c2aad291a88a3704d47 af62b9e1385a457fbf3c4c423076a6db c4790b66c3914c2aad291a88a3704d47--af62b9e1385a457fbf3c4c423076a6db 7a7fffd2322d48049a8f2e84c7423dbd af62b9e1385a457fbf3c4c423076a6db--7a7fffd2322d48049a8f2e84c7423dbd c2ac1c7ba0294ab2b028944763e7ba83 X 7a7fffd2322d48049a8f2e84c7423dbd--c2ac1c7ba0294ab2b028944763e7ba83 c2ac1c7ba0294ab2b028944763e7ba83--aa705c8fec7941bd8b45d0feffca44b9 82471788c89f4db28f35744c933fd3b4 c2ac1c7ba0294ab2b028944763e7ba83--82471788c89f4db28f35744c933fd3b4 af5052795d494ecc9b856b9a701fb5f3 82471788c89f4db28f35744c933fd3b4--af5052795d494ecc9b856b9a701fb5f3 f26d42dd5562417191319ebc95a4082e af5052795d494ecc9b856b9a701fb5f3--f26d42dd5562417191319ebc95a4082e bd7c959d21be4bd79b2f3560c3c3c233 X f26d42dd5562417191319ebc95a4082e--bd7c959d21be4bd79b2f3560c3c3c233 bd7c959d21be4bd79b2f3560c3c3c233--51cc3d8692ef4ff188ac51f2f0bc398d d475bfbb391b4783bba47b3d431bfbf5 bd7c959d21be4bd79b2f3560c3c3c233--d475bfbb391b4783bba47b3d431bfbf5 49002f7a0295401b8223248c6347cac0 d475bfbb391b4783bba47b3d431bfbf5--49002f7a0295401b8223248c6347cac0 81361f3475f745d298ba05dfe3527680 49002f7a0295401b8223248c6347cac0--81361f3475f745d298ba05dfe3527680 74172dc711354d0c92aa6ee684ef7bb2 81361f3475f745d298ba05dfe3527680--74172dc711354d0c92aa6ee684ef7bb2 95377f0dbe6e40c299de7894fa00c380 74172dc711354d0c92aa6ee684ef7bb2--95377f0dbe6e40c299de7894fa00c380 3f10a23a51a849ecae406480fa3a9642 95377f0dbe6e40c299de7894fa00c380--3f10a23a51a849ecae406480fa3a9642 f0931a5f8c2b4ef28d5e8b6a1b7dd739 3f10a23a51a849ecae406480fa3a9642--f0931a5f8c2b4ef28d5e8b6a1b7dd739 9018fcb8367b4b01b1f08904e5fcffe2 f0931a5f8c2b4ef28d5e8b6a1b7dd739--9018fcb8367b4b01b1f08904e5fcffe2 df633b4daede4dc79f89a0f6291bcdd2 9018fcb8367b4b01b1f08904e5fcffe2--df633b4daede4dc79f89a0f6291bcdd2 75e9b9f7fd7a47d482c54c28572d2690 df633b4daede4dc79f89a0f6291bcdd2--75e9b9f7fd7a47d482c54c28572d2690 ecacf9b5df464003b44d03522af84cec 75e9b9f7fd7a47d482c54c28572d2690--ecacf9b5df464003b44d03522af84cec cc20efbed46243e9adbde7ffc0af605e ecacf9b5df464003b44d03522af84cec--cc20efbed46243e9adbde7ffc0af605e 946a0b4174084d249f1867fc5134643f cc20efbed46243e9adbde7ffc0af605e--946a0b4174084d249f1867fc5134643f d3752969d4f44bf58fa4a9337ce7d339 946a0b4174084d249f1867fc5134643f--d3752969d4f44bf58fa4a9337ce7d339 ecb1a83a34fe46cdbadb3aa167e31c0c d3752969d4f44bf58fa4a9337ce7d339--ecb1a83a34fe46cdbadb3aa167e31c0c 6279741826c04a2fa3192647a426e11a ecb1a83a34fe46cdbadb3aa167e31c0c--6279741826c04a2fa3192647a426e11a b3fa6f81a16648a2adaa969937cecc8b 6279741826c04a2fa3192647a426e11a--b3fa6f81a16648a2adaa969937cecc8b 0520c14e3b474bf794de496ef51f7469 b3fa6f81a16648a2adaa969937cecc8b--0520c14e3b474bf794de496ef51f7469 235870ac86374ba79b48961397dc5bd3 0520c14e3b474bf794de496ef51f7469--235870ac86374ba79b48961397dc5bd3 6ce5f3757cb84e6289dd5106f976ea8a 235870ac86374ba79b48961397dc5bd3--6ce5f3757cb84e6289dd5106f976ea8a dad7bc4c95f2403bb66f03abffa54e60 6ce5f3757cb84e6289dd5106f976ea8a--dad7bc4c95f2403bb66f03abffa54e60 3bd7b46e1ba84c6ba8a65ff6809b5de8 dad7bc4c95f2403bb66f03abffa54e60--3bd7b46e1ba84c6ba8a65ff6809b5de8 2ed656fc4ce0455598116be594cb916b 3bd7b46e1ba84c6ba8a65ff6809b5de8--2ed656fc4ce0455598116be594cb916b 230004af98734ad59a7cf4e96845ffef 2ed656fc4ce0455598116be594cb916b--230004af98734ad59a7cf4e96845ffef ac124a58d9394b6cba421020e905e699 X 230004af98734ad59a7cf4e96845ffef--ac124a58d9394b6cba421020e905e699 ac124a58d9394b6cba421020e905e699--7d9240baade340f8a136acd4e0d3ebaa 3b0271cf72ba49259db6374d86303d0f RZ(-1.0*g0) ac124a58d9394b6cba421020e905e699--3b0271cf72ba49259db6374d86303d0f d46e254d25444077a6a1a2c0c55d15da X 3b0271cf72ba49259db6374d86303d0f--d46e254d25444077a6a1a2c0c55d15da d46e254d25444077a6a1a2c0c55d15da--a36f04699a14423f962c684a67397617 61849cb22a294c8ca6e329ec6786ed4f d46e254d25444077a6a1a2c0c55d15da--61849cb22a294c8ca6e329ec6786ed4f 14bbc1afbcbe4da6a3b9c59f9a8b420a 61849cb22a294c8ca6e329ec6786ed4f--14bbc1afbcbe4da6a3b9c59f9a8b420a 5fa92a6e98a34d959f5fb2e16aab9144 14bbc1afbcbe4da6a3b9c59f9a8b420a--5fa92a6e98a34d959f5fb2e16aab9144 4f9343a1edcd463384906b6b0395c371 5fa92a6e98a34d959f5fb2e16aab9144--4f9343a1edcd463384906b6b0395c371 693ae25dd7774a608aa06f49abb89b24 4f9343a1edcd463384906b6b0395c371--693ae25dd7774a608aa06f49abb89b24 20459cde4b1c4655b4e46d0ad9ccf843 693ae25dd7774a608aa06f49abb89b24--20459cde4b1c4655b4e46d0ad9ccf843 72c3f9b0d7d9495b8c31abbbebb7cff0 20459cde4b1c4655b4e46d0ad9ccf843--72c3f9b0d7d9495b8c31abbbebb7cff0 249450b6e8684a58a955545d6b324c17 72c3f9b0d7d9495b8c31abbbebb7cff0--249450b6e8684a58a955545d6b324c17 9e2071dda9d64ccb934f1972baa60f36 249450b6e8684a58a955545d6b324c17--9e2071dda9d64ccb934f1972baa60f36 e47524db87d94b21b5d4183356d098e7 9e2071dda9d64ccb934f1972baa60f36--e47524db87d94b21b5d4183356d098e7 b5f1a158c69d487bb5e55391a98be2cc X e47524db87d94b21b5d4183356d098e7--b5f1a158c69d487bb5e55391a98be2cc b5f1a158c69d487bb5e55391a98be2cc--03909a2b96974d57a5bbafa3f61456ed d96589807d31452abe2c8e6900b80fc9 b5f1a158c69d487bb5e55391a98be2cc--d96589807d31452abe2c8e6900b80fc9 84fabaf01e40443f90e378ca8aae76a5 d96589807d31452abe2c8e6900b80fc9--84fabaf01e40443f90e378ca8aae76a5 476019047e6a42f98b3f37c282f440a1 84fabaf01e40443f90e378ca8aae76a5--476019047e6a42f98b3f37c282f440a1 25dabc2907da4906bfd222ba4ddb0f37 X 476019047e6a42f98b3f37c282f440a1--25dabc2907da4906bfd222ba4ddb0f37 25dabc2907da4906bfd222ba4ddb0f37--1edce9a1035440549b275528deccc297 2d313e0e1bdb464fb1eacc9b18b894dd 25dabc2907da4906bfd222ba4ddb0f37--2d313e0e1bdb464fb1eacc9b18b894dd 96063554a91a4db4a51dcd60df8e385e 2d313e0e1bdb464fb1eacc9b18b894dd--96063554a91a4db4a51dcd60df8e385e b703e3988da94774bec78d6fb69f7645 96063554a91a4db4a51dcd60df8e385e--b703e3988da94774bec78d6fb69f7645 ac179410281a420082aa4ec970ecc1c7 b703e3988da94774bec78d6fb69f7645--ac179410281a420082aa4ec970ecc1c7 5c385588d58f4a14aea2aa66c36cc5ba ac179410281a420082aa4ec970ecc1c7--5c385588d58f4a14aea2aa66c36cc5ba c3ade6bf72df40a4916a3bef4bc52728 5c385588d58f4a14aea2aa66c36cc5ba--c3ade6bf72df40a4916a3bef4bc52728 8f43087ed81748969ef7c9b93d21d28a c3ade6bf72df40a4916a3bef4bc52728--8f43087ed81748969ef7c9b93d21d28a 8ea40e94b54b4ace97ff4d4eb6360e26 8f43087ed81748969ef7c9b93d21d28a--8ea40e94b54b4ace97ff4d4eb6360e26 6763e2567d8748b382e1d5c6404c71b2 8ea40e94b54b4ace97ff4d4eb6360e26--6763e2567d8748b382e1d5c6404c71b2 4cb2fcf1decc4b7b999be1afca09d54a 6763e2567d8748b382e1d5c6404c71b2--4cb2fcf1decc4b7b999be1afca09d54a 3d88e09bce034dbeb533d508052b6cfb 4cb2fcf1decc4b7b999be1afca09d54a--3d88e09bce034dbeb533d508052b6cfb 62807f163e93463b893f817b889e3154 3d88e09bce034dbeb533d508052b6cfb--62807f163e93463b893f817b889e3154 1f98f20b59374c3ea8ef00ef5ba1e863 62807f163e93463b893f817b889e3154--1f98f20b59374c3ea8ef00ef5ba1e863 6188f67bfaf242f59ab8831e6f8e83c6 1f98f20b59374c3ea8ef00ef5ba1e863--6188f67bfaf242f59ab8831e6f8e83c6 904d965c02b34ce39d463133244007df 6188f67bfaf242f59ab8831e6f8e83c6--904d965c02b34ce39d463133244007df d8140f91f2d34ceb9b77de0c4147a5a1 904d965c02b34ce39d463133244007df--d8140f91f2d34ceb9b77de0c4147a5a1 9d1376fe935a43f6b74f2d6cfd57875f d8140f91f2d34ceb9b77de0c4147a5a1--9d1376fe935a43f6b74f2d6cfd57875f 23555eea156d4c3fa7e48a13f056e8de 9d1376fe935a43f6b74f2d6cfd57875f--23555eea156d4c3fa7e48a13f056e8de 6835f25dcf9e463dac393dd047b4b824 23555eea156d4c3fa7e48a13f056e8de--6835f25dcf9e463dac393dd047b4b824 b167f63ec065432b89890d2fe50c6b0d 6835f25dcf9e463dac393dd047b4b824--b167f63ec065432b89890d2fe50c6b0d a488024e1da446dfb0edc3e92089d98f b167f63ec065432b89890d2fe50c6b0d--a488024e1da446dfb0edc3e92089d98f 79b7eb07a7c7400795970ef68ae516c0 X a488024e1da446dfb0edc3e92089d98f--79b7eb07a7c7400795970ef68ae516c0 79b7eb07a7c7400795970ef68ae516c0--f76df2008b8f4ba79e49fd544f56a05a ce7a8a1deb4b4c68aae2135e04f2e199 RZ(-1.0*g0) 79b7eb07a7c7400795970ef68ae516c0--ce7a8a1deb4b4c68aae2135e04f2e199 88a613971680410694ce2d6628901f27 X ce7a8a1deb4b4c68aae2135e04f2e199--88a613971680410694ce2d6628901f27 88a613971680410694ce2d6628901f27--c2103b36b69f488a9abc6097f6ad742a 0d304af966e448ac9844eca229854219 88a613971680410694ce2d6628901f27--0d304af966e448ac9844eca229854219 1e95a6bd34674f619d92706d447b0f7a 0d304af966e448ac9844eca229854219--1e95a6bd34674f619d92706d447b0f7a 49ef4a291fee4c85b87892f1af27e351 1e95a6bd34674f619d92706d447b0f7a--49ef4a291fee4c85b87892f1af27e351 5e2b08d89caf4713ac292459c84179e5 49ef4a291fee4c85b87892f1af27e351--5e2b08d89caf4713ac292459c84179e5 071dfbdac4b74819a3574a0ea0a3a4c2 5e2b08d89caf4713ac292459c84179e5--071dfbdac4b74819a3574a0ea0a3a4c2 e23aa69d3f2d42adacca7c4e3ca31407 071dfbdac4b74819a3574a0ea0a3a4c2--e23aa69d3f2d42adacca7c4e3ca31407 a13481bff13e49549291eb1c55dc6333 e23aa69d3f2d42adacca7c4e3ca31407--a13481bff13e49549291eb1c55dc6333 e945e654b5e74e46903e5d69b66671cc a13481bff13e49549291eb1c55dc6333--e945e654b5e74e46903e5d69b66671cc f6e880c585df413c80156716612b4c33 e945e654b5e74e46903e5d69b66671cc--f6e880c585df413c80156716612b4c33 b861d9e7f63041bbabba58b1fe39d464 f6e880c585df413c80156716612b4c33--b861d9e7f63041bbabba58b1fe39d464 626fa0a7119f459d8878777f4e7e5523 b861d9e7f63041bbabba58b1fe39d464--626fa0a7119f459d8878777f4e7e5523 ce01c11316474b0e8ff6eb2e75969b81 626fa0a7119f459d8878777f4e7e5523--ce01c11316474b0e8ff6eb2e75969b81 094f09a212ec42478758767d567d8c90 ce01c11316474b0e8ff6eb2e75969b81--094f09a212ec42478758767d567d8c90 558292824d9f46ddbf5255812dc1d2f0 094f09a212ec42478758767d567d8c90--558292824d9f46ddbf5255812dc1d2f0 9a109ddd47cd48bd9a4166bcce96b3dc 558292824d9f46ddbf5255812dc1d2f0--9a109ddd47cd48bd9a4166bcce96b3dc f17ccab2ed64431ab68266eab915077e 9a109ddd47cd48bd9a4166bcce96b3dc--f17ccab2ed64431ab68266eab915077e 7b407b9eff2742d28d732a959de628bf f17ccab2ed64431ab68266eab915077e--7b407b9eff2742d28d732a959de628bf f97fa328fdf149e18e2b211d9d6ae7ec 7b407b9eff2742d28d732a959de628bf--f97fa328fdf149e18e2b211d9d6ae7ec 663a33637a8b476b9b937dfc4dbdebe3 f97fa328fdf149e18e2b211d9d6ae7ec--663a33637a8b476b9b937dfc4dbdebe3 26de9f13a9a24035a3d6c7636b421635 663a33637a8b476b9b937dfc4dbdebe3--26de9f13a9a24035a3d6c7636b421635 f651a6bc28474fbbb163fbf566b9dead 26de9f13a9a24035a3d6c7636b421635--f651a6bc28474fbbb163fbf566b9dead f17cc8944de24e2ab78f4e0709786ac8 f651a6bc28474fbbb163fbf566b9dead--f17cc8944de24e2ab78f4e0709786ac8 67e52abbd53e497ca112af5d284f455d X f17cc8944de24e2ab78f4e0709786ac8--67e52abbd53e497ca112af5d284f455d 67e52abbd53e497ca112af5d284f455d--8cc4252bf2354f5abcf5bf2417f20003 14cfd25a1194437a8b7ac72fcd4781b4 RZ(-1.0*g0) 67e52abbd53e497ca112af5d284f455d--14cfd25a1194437a8b7ac72fcd4781b4 65512aeb45214158830d0fd3df6da11c X 14cfd25a1194437a8b7ac72fcd4781b4--65512aeb45214158830d0fd3df6da11c 65512aeb45214158830d0fd3df6da11c--5c05daa96f3f4c8dace9cf4c35378579 8560112fa9ca4488829be0e2b2e1f3b5 65512aeb45214158830d0fd3df6da11c--8560112fa9ca4488829be0e2b2e1f3b5 1372e3ca4c9e4da98fbe89e3be7b14aa 8560112fa9ca4488829be0e2b2e1f3b5--1372e3ca4c9e4da98fbe89e3be7b14aa 7c314a087d8e41dca48e08652dae4173 1372e3ca4c9e4da98fbe89e3be7b14aa--7c314a087d8e41dca48e08652dae4173 6c9be2d0c28a437d8c1dd7a91333d561 7c314a087d8e41dca48e08652dae4173--6c9be2d0c28a437d8c1dd7a91333d561 bc79d0e3499547358376eb6307bf69b6 6c9be2d0c28a437d8c1dd7a91333d561--bc79d0e3499547358376eb6307bf69b6 f4872eb17acb41f78a192f1cf6a44fcc bc79d0e3499547358376eb6307bf69b6--f4872eb17acb41f78a192f1cf6a44fcc 457db5fb7ac2461cb1f11d6334f74029 X f4872eb17acb41f78a192f1cf6a44fcc--457db5fb7ac2461cb1f11d6334f74029 457db5fb7ac2461cb1f11d6334f74029--2c75c146b81a49d2ac9c320919a52f34 e5e8d25806e54288b6a8783762289308 457db5fb7ac2461cb1f11d6334f74029--e5e8d25806e54288b6a8783762289308 2662e94962bc44169f25dfa3427f3c9f e5e8d25806e54288b6a8783762289308--2662e94962bc44169f25dfa3427f3c9f a5f3fcb866e349fa84fa18a068be5ae1 2662e94962bc44169f25dfa3427f3c9f--a5f3fcb866e349fa84fa18a068be5ae1 ebc9d4b3f7404ca194b50ae696bc8794 X a5f3fcb866e349fa84fa18a068be5ae1--ebc9d4b3f7404ca194b50ae696bc8794 ebc9d4b3f7404ca194b50ae696bc8794--71e2846d52b14124ac9e8274a1ea96bd d1daf0678b714d63a46c7ed87adfede2 ebc9d4b3f7404ca194b50ae696bc8794--d1daf0678b714d63a46c7ed87adfede2 12f55d1f99a8433fb1e99ca11ce08173 d1daf0678b714d63a46c7ed87adfede2--12f55d1f99a8433fb1e99ca11ce08173 479eebaf5aad4bcaaf6e7d5f889bd820 12f55d1f99a8433fb1e99ca11ce08173--479eebaf5aad4bcaaf6e7d5f889bd820 d28d99fff91e4f62818e52f52a736c3e 479eebaf5aad4bcaaf6e7d5f889bd820--d28d99fff91e4f62818e52f52a736c3e 04115cd9e1ea416d8a1f6401c3549d03 d28d99fff91e4f62818e52f52a736c3e--04115cd9e1ea416d8a1f6401c3549d03 310ba1f774c64d089cae9796dda0b425 04115cd9e1ea416d8a1f6401c3549d03--310ba1f774c64d089cae9796dda0b425 26e7c8ec0c3c4c83b26915f7a6259570 310ba1f774c64d089cae9796dda0b425--26e7c8ec0c3c4c83b26915f7a6259570 d8defb004a2548b895ca9d06291690ae 26e7c8ec0c3c4c83b26915f7a6259570--d8defb004a2548b895ca9d06291690ae 3c5dd7019df049819acf7f9b8fc46f15 X d8defb004a2548b895ca9d06291690ae--3c5dd7019df049819acf7f9b8fc46f15 3c5dd7019df049819acf7f9b8fc46f15--7e35ab49441a48439b93fa03e2e2c54a f19d006c63744d39a9e900f6392d4869 RZ(-1.0*g0) 3c5dd7019df049819acf7f9b8fc46f15--f19d006c63744d39a9e900f6392d4869 9287580b17354053a2868ead79319a7d X f19d006c63744d39a9e900f6392d4869--9287580b17354053a2868ead79319a7d 9287580b17354053a2868ead79319a7d--d84e2b1b7eb24bd8b9ecec24c042878f 4dd081660ee14f11853feda7ec4a14b4 9287580b17354053a2868ead79319a7d--4dd081660ee14f11853feda7ec4a14b4 13045964a70c45e9a3a654ed666c9b64 4dd081660ee14f11853feda7ec4a14b4--13045964a70c45e9a3a654ed666c9b64 04e515bb52554fab9b69b5a72b756b74 13045964a70c45e9a3a654ed666c9b64--04e515bb52554fab9b69b5a72b756b74 206687837ca34e3eb2fe69769ecbbf73 04e515bb52554fab9b69b5a72b756b74--206687837ca34e3eb2fe69769ecbbf73 273063cb3267427d9c40d89e22fffb2b 206687837ca34e3eb2fe69769ecbbf73--273063cb3267427d9c40d89e22fffb2b c389e4f497ac4ebab67c6d96d4e04170 273063cb3267427d9c40d89e22fffb2b--c389e4f497ac4ebab67c6d96d4e04170 28aba160f3ec46beab4a710bc6493202 X c389e4f497ac4ebab67c6d96d4e04170--28aba160f3ec46beab4a710bc6493202 28aba160f3ec46beab4a710bc6493202--35503bb9e3c940aeb1f9ab465560849f b5433b16c0594e6797580ddde707ea56 RZ(-1.0*g0) 28aba160f3ec46beab4a710bc6493202--b5433b16c0594e6797580ddde707ea56 9fc24607242047de8a618fa49186eb65 X b5433b16c0594e6797580ddde707ea56--9fc24607242047de8a618fa49186eb65 9fc24607242047de8a618fa49186eb65--74f03ea7719a4bbf97533dd900cfbef1 9dd31d5cd8f342a19bd9555e720c71cb 9fc24607242047de8a618fa49186eb65--9dd31d5cd8f342a19bd9555e720c71cb f9b780cdddf44273a4542f802dbc95c1 X 9dd31d5cd8f342a19bd9555e720c71cb--f9b780cdddf44273a4542f802dbc95c1 f9b780cdddf44273a4542f802dbc95c1--dd685f52dec741279552277a1b7e4e98 faa65a18598243efa8e4497560549892 RZ(-1.0*g0) f9b780cdddf44273a4542f802dbc95c1--faa65a18598243efa8e4497560549892 fed1b01a5d954763b9b3a4bb365e4804 X faa65a18598243efa8e4497560549892--fed1b01a5d954763b9b3a4bb365e4804 fed1b01a5d954763b9b3a4bb365e4804--f25f32b240d34c8c8cf9368017aeea51 94057491f09b404cbecc5cb3fadb0e8f X fed1b01a5d954763b9b3a4bb365e4804--94057491f09b404cbecc5cb3fadb0e8f 94057491f09b404cbecc5cb3fadb0e8f--d775d53133144de0ba06c30ce18def97 ce2ac3bae27749dd865001c9898a91a2 94057491f09b404cbecc5cb3fadb0e8f--ce2ac3bae27749dd865001c9898a91a2 2d5a7675958e41039c9296666d14227e ce2ac3bae27749dd865001c9898a91a2--2d5a7675958e41039c9296666d14227e ab8e11c06c0d404f891f753bb0555078 2d5a7675958e41039c9296666d14227e--ab8e11c06c0d404f891f753bb0555078 97e3632481b8404c98459f2242da98a5 X ab8e11c06c0d404f891f753bb0555078--97e3632481b8404c98459f2242da98a5 97e3632481b8404c98459f2242da98a5--8618468bf212456e85c9f5047c897be3 2259d539f1934c30a3ecc7be044a39fc RX(b06) 97e3632481b8404c98459f2242da98a5--2259d539f1934c30a3ecc7be044a39fc 4747d14208564e0ea0ece728c130a364 2259d539f1934c30a3ecc7be044a39fc--4747d14208564e0ea0ece728c130a364 dbf41eca7463414eb2977b6f338aad47 4747d14208564e0ea0ece728c130a364--dbf41eca7463414eb2977b6f338aad47 8109a690295e45d5b10d0aaed3c0b12b dbf41eca7463414eb2977b6f338aad47--8109a690295e45d5b10d0aaed3c0b12b 785b0c6d220d4e63a552ad1a4397b32c 8109a690295e45d5b10d0aaed3c0b12b--785b0c6d220d4e63a552ad1a4397b32c 289c41f9205d42289651d5fed047ed9c 785b0c6d220d4e63a552ad1a4397b32c--289c41f9205d42289651d5fed047ed9c 72e9cb3a97a448dc872b4ea0ec78225b X 289c41f9205d42289651d5fed047ed9c--72e9cb3a97a448dc872b4ea0ec78225b 72e9cb3a97a448dc872b4ea0ec78225b--5aaffc15a6554547afc83157a4ffccde c6e0db08e3064dc3be59e99f81cec6a2 72e9cb3a97a448dc872b4ea0ec78225b--c6e0db08e3064dc3be59e99f81cec6a2 80c95cc7f6524f9988ba80ed03fcd44b c6e0db08e3064dc3be59e99f81cec6a2--80c95cc7f6524f9988ba80ed03fcd44b 7bded0e57e5b42c7898a7c843d09489a 80c95cc7f6524f9988ba80ed03fcd44b--7bded0e57e5b42c7898a7c843d09489a 542054ce009642f6970c43a66d31f056 X 7bded0e57e5b42c7898a7c843d09489a--542054ce009642f6970c43a66d31f056 542054ce009642f6970c43a66d31f056--3c64a640d6774e7588c2bca1f0033daa ca6f232c62034cfa8dcb71b6ab404b23 542054ce009642f6970c43a66d31f056--ca6f232c62034cfa8dcb71b6ab404b23 2b5480c6b0e942b29a3ca3ceec7e4480 ca6f232c62034cfa8dcb71b6ab404b23--2b5480c6b0e942b29a3ca3ceec7e4480 5325dca937e64d60940918ca8717b69a 2b5480c6b0e942b29a3ca3ceec7e4480--5325dca937e64d60940918ca8717b69a fd50dc9c472b4d0d9425b53fe99b5b88 5325dca937e64d60940918ca8717b69a--fd50dc9c472b4d0d9425b53fe99b5b88 e2088e5d77fc498e9f458d1f74231c9e fd50dc9c472b4d0d9425b53fe99b5b88--e2088e5d77fc498e9f458d1f74231c9e 7f864b1990ee4c4c93e210f3137de9be e2088e5d77fc498e9f458d1f74231c9e--7f864b1990ee4c4c93e210f3137de9be ea63ac580d67431bac3020e821deced6 7f864b1990ee4c4c93e210f3137de9be--ea63ac580d67431bac3020e821deced6 1b4b7a2f709a428c99d7642608b77b90 ea63ac580d67431bac3020e821deced6--1b4b7a2f709a428c99d7642608b77b90 ec1d5fff97f14702a65eece630ae8ea9 1b4b7a2f709a428c99d7642608b77b90--ec1d5fff97f14702a65eece630ae8ea9 c3e5a118036e4100b0787d9544db60a8 ec1d5fff97f14702a65eece630ae8ea9--c3e5a118036e4100b0787d9544db60a8 65ceaea589334c23872cf8592cbcdb62 c3e5a118036e4100b0787d9544db60a8--65ceaea589334c23872cf8592cbcdb62 835360da1be24eab96c57769c9cffed0 65ceaea589334c23872cf8592cbcdb62--835360da1be24eab96c57769c9cffed0 1ed7ec4517aa45629dee09ff36f256a7 835360da1be24eab96c57769c9cffed0--1ed7ec4517aa45629dee09ff36f256a7 f05503b4c67b4edcb261ebb94efe5c1b 1ed7ec4517aa45629dee09ff36f256a7--f05503b4c67b4edcb261ebb94efe5c1b 33e31caac2444cbbb2e478e6c3cb3f6b f05503b4c67b4edcb261ebb94efe5c1b--33e31caac2444cbbb2e478e6c3cb3f6b 0ce6c5b8c5c042389d3c71d8ddf7ddf0 33e31caac2444cbbb2e478e6c3cb3f6b--0ce6c5b8c5c042389d3c71d8ddf7ddf0 8483fcacdc2d4eda886543e173a85721 0ce6c5b8c5c042389d3c71d8ddf7ddf0--8483fcacdc2d4eda886543e173a85721 31dd20e8bf0b402cb430329c34a0966c 8483fcacdc2d4eda886543e173a85721--31dd20e8bf0b402cb430329c34a0966c 5e33bdfe801c41f0b60552121ba8f41e 31dd20e8bf0b402cb430329c34a0966c--5e33bdfe801c41f0b60552121ba8f41e b363b6c74e144d52a2c87e92c02b35e6 5e33bdfe801c41f0b60552121ba8f41e--b363b6c74e144d52a2c87e92c02b35e6 9b4e63909eee4fbbb2c7324c2c8ee2d0 b363b6c74e144d52a2c87e92c02b35e6--9b4e63909eee4fbbb2c7324c2c8ee2d0 75da18a2902f4b06a7e468bc885665a9 9b4e63909eee4fbbb2c7324c2c8ee2d0--75da18a2902f4b06a7e468bc885665a9 1dbc3ebd8aee48cca495e59db464e583 75da18a2902f4b06a7e468bc885665a9--1dbc3ebd8aee48cca495e59db464e583 f4c178e8cdb940ba9a1f2a5ce481364c 1dbc3ebd8aee48cca495e59db464e583--f4c178e8cdb940ba9a1f2a5ce481364c 77cdbb7537764f5f822463b0e881bea2 X f4c178e8cdb940ba9a1f2a5ce481364c--77cdbb7537764f5f822463b0e881bea2 77cdbb7537764f5f822463b0e881bea2--3308c6f398c2488c93b6a094b8de6e84 72b4a8f6d7f149589438b991c55b630b RZ(-1.0*g1) 77cdbb7537764f5f822463b0e881bea2--72b4a8f6d7f149589438b991c55b630b 074f5007b2f8456e90e1aed21ddde621 X 72b4a8f6d7f149589438b991c55b630b--074f5007b2f8456e90e1aed21ddde621 074f5007b2f8456e90e1aed21ddde621--f30bf038c531473d9dec94c15c01e8cd 58cef2dc3fad45218263f10191ccbb7d 074f5007b2f8456e90e1aed21ddde621--58cef2dc3fad45218263f10191ccbb7d 75cc4876663f4482aea53e6989d87981 58cef2dc3fad45218263f10191ccbb7d--75cc4876663f4482aea53e6989d87981 0fbbbafa96e9494b8b19085aca709a12 75cc4876663f4482aea53e6989d87981--0fbbbafa96e9494b8b19085aca709a12 c71d00f2dccb4d4b9335957512eb72c8 0fbbbafa96e9494b8b19085aca709a12--c71d00f2dccb4d4b9335957512eb72c8 ff3df723bf894cbab43095452aca2537 c71d00f2dccb4d4b9335957512eb72c8--ff3df723bf894cbab43095452aca2537 e500a35f24254f9ab2416468322094a8 ff3df723bf894cbab43095452aca2537--e500a35f24254f9ab2416468322094a8 8d6c786f075b431db4edd8450853e335 e500a35f24254f9ab2416468322094a8--8d6c786f075b431db4edd8450853e335 a813e37f11ce4b739654249d94a73a8a 8d6c786f075b431db4edd8450853e335--a813e37f11ce4b739654249d94a73a8a 9af8fd9320634fe4b1a47230d679be29 a813e37f11ce4b739654249d94a73a8a--9af8fd9320634fe4b1a47230d679be29 9c69f08970f34cdc99eacfca637270ee 9af8fd9320634fe4b1a47230d679be29--9c69f08970f34cdc99eacfca637270ee 6e87dd0c03cc47b185add5741d6d03af X 9c69f08970f34cdc99eacfca637270ee--6e87dd0c03cc47b185add5741d6d03af 6e87dd0c03cc47b185add5741d6d03af--c606c898c7be47c08762dd056be0d9ce 9485eb7c780d4ba6bf06511fa13b377b 6e87dd0c03cc47b185add5741d6d03af--9485eb7c780d4ba6bf06511fa13b377b e8b099a6c82444d2b4db994d679f127e 9485eb7c780d4ba6bf06511fa13b377b--e8b099a6c82444d2b4db994d679f127e d087013673ae428d882fab09742f2d2e e8b099a6c82444d2b4db994d679f127e--d087013673ae428d882fab09742f2d2e 2f26fc53c5a04f30a9df1e397df5a4d2 X d087013673ae428d882fab09742f2d2e--2f26fc53c5a04f30a9df1e397df5a4d2 2f26fc53c5a04f30a9df1e397df5a4d2--4f843b1e0ad446709b5d763ecd4ced36 f9ee8d81b2c544ed9a4c078f7872665d 2f26fc53c5a04f30a9df1e397df5a4d2--f9ee8d81b2c544ed9a4c078f7872665d b6fbaedf05db4ee1a2319ac661a7c064 f9ee8d81b2c544ed9a4c078f7872665d--b6fbaedf05db4ee1a2319ac661a7c064 83662274dadd491fa00cbe4644f2b2bc b6fbaedf05db4ee1a2319ac661a7c064--83662274dadd491fa00cbe4644f2b2bc a8e7f82b82cb4b1ab6505138cc27ea93 83662274dadd491fa00cbe4644f2b2bc--a8e7f82b82cb4b1ab6505138cc27ea93 a41691830e1f4cf28ec013a412c67e96 a8e7f82b82cb4b1ab6505138cc27ea93--a41691830e1f4cf28ec013a412c67e96 ea01bd59c86d4f6ebf90da8e88fcce8f a41691830e1f4cf28ec013a412c67e96--ea01bd59c86d4f6ebf90da8e88fcce8f c51665e9aad7424d9fbeab59411c65e6 ea01bd59c86d4f6ebf90da8e88fcce8f--c51665e9aad7424d9fbeab59411c65e6 a942d6f7343e4362a729c8d343f33edb c51665e9aad7424d9fbeab59411c65e6--a942d6f7343e4362a729c8d343f33edb 4e7489c2dade4c8a8882ad3212162244 a942d6f7343e4362a729c8d343f33edb--4e7489c2dade4c8a8882ad3212162244 44484f879ea94e37b6a5244d8817f238 4e7489c2dade4c8a8882ad3212162244--44484f879ea94e37b6a5244d8817f238 d73369ab9e6d49e5b571856599646972 44484f879ea94e37b6a5244d8817f238--d73369ab9e6d49e5b571856599646972 87aacb514866400ea4aae45aa9ea004c d73369ab9e6d49e5b571856599646972--87aacb514866400ea4aae45aa9ea004c fb44aab951a241158f15c787e88b674b 87aacb514866400ea4aae45aa9ea004c--fb44aab951a241158f15c787e88b674b 94268f76f9dd4dbfbb9c1f8ae9722493 fb44aab951a241158f15c787e88b674b--94268f76f9dd4dbfbb9c1f8ae9722493 c570d8d6fa0a4e2b9b45e39623416621 94268f76f9dd4dbfbb9c1f8ae9722493--c570d8d6fa0a4e2b9b45e39623416621 7bf2c70b5f444ec5801942e5cd48673f c570d8d6fa0a4e2b9b45e39623416621--7bf2c70b5f444ec5801942e5cd48673f 2beb190a82aa43308f29559faf30a3fa 7bf2c70b5f444ec5801942e5cd48673f--2beb190a82aa43308f29559faf30a3fa 62d9e4cd5a304fefbbc914db7b366c0f 2beb190a82aa43308f29559faf30a3fa--62d9e4cd5a304fefbbc914db7b366c0f 2cb834f8fff3431cb572e7b94f66eff9 62d9e4cd5a304fefbbc914db7b366c0f--2cb834f8fff3431cb572e7b94f66eff9 47d0fe54e628457eaa59f3ce61c5a409 2cb834f8fff3431cb572e7b94f66eff9--47d0fe54e628457eaa59f3ce61c5a409 1d34f755b96741459f765f293fd57f9e 47d0fe54e628457eaa59f3ce61c5a409--1d34f755b96741459f765f293fd57f9e d58b9ffa84214891afc30a7cd2d3827c X 1d34f755b96741459f765f293fd57f9e--d58b9ffa84214891afc30a7cd2d3827c d58b9ffa84214891afc30a7cd2d3827c--3bc20757db6e4e058e08efe6a34ebced 66164be9be0b4f18bb9a3d4a648f5467 RZ(-1.0*g1) d58b9ffa84214891afc30a7cd2d3827c--66164be9be0b4f18bb9a3d4a648f5467 42e215e54fb5440cbcc55a847cc5750c X 66164be9be0b4f18bb9a3d4a648f5467--42e215e54fb5440cbcc55a847cc5750c 42e215e54fb5440cbcc55a847cc5750c--920e42123930494d8efddcf59fa3c761 8333cf55325945ac81ee47acd195caae 42e215e54fb5440cbcc55a847cc5750c--8333cf55325945ac81ee47acd195caae eeb6a816c6c843ecbdf18d6390760306 8333cf55325945ac81ee47acd195caae--eeb6a816c6c843ecbdf18d6390760306 f3078d129fdd4399a707dd1660c8c8c0 eeb6a816c6c843ecbdf18d6390760306--f3078d129fdd4399a707dd1660c8c8c0 7067ef2c20854f2c9b114ef2961b1be8 f3078d129fdd4399a707dd1660c8c8c0--7067ef2c20854f2c9b114ef2961b1be8 c459548bf9044ec98396b5997e62f027 7067ef2c20854f2c9b114ef2961b1be8--c459548bf9044ec98396b5997e62f027 bb217ebd8dc84cb59b35f559db1b7eaf c459548bf9044ec98396b5997e62f027--bb217ebd8dc84cb59b35f559db1b7eaf 86ee6b6597a84aa39bd83d945f3c8ce0 bb217ebd8dc84cb59b35f559db1b7eaf--86ee6b6597a84aa39bd83d945f3c8ce0 cd902bc7857a45d5bcc9da03a85fb213 86ee6b6597a84aa39bd83d945f3c8ce0--cd902bc7857a45d5bcc9da03a85fb213 a5b3664319a64c8299103c0d31abf26f cd902bc7857a45d5bcc9da03a85fb213--a5b3664319a64c8299103c0d31abf26f 808ee68ad23b46c78efc5f8bc19f1591 a5b3664319a64c8299103c0d31abf26f--808ee68ad23b46c78efc5f8bc19f1591 f0cef650ebdd46c0b417dc81457af1c2 808ee68ad23b46c78efc5f8bc19f1591--f0cef650ebdd46c0b417dc81457af1c2 ec0b1d9264dd45fb9201daddd9402fd9 f0cef650ebdd46c0b417dc81457af1c2--ec0b1d9264dd45fb9201daddd9402fd9 cd8cfa32e1bf49699a54d258833386fe ec0b1d9264dd45fb9201daddd9402fd9--cd8cfa32e1bf49699a54d258833386fe 9060e5ef382e49cf942aedca6f1cd5b4 cd8cfa32e1bf49699a54d258833386fe--9060e5ef382e49cf942aedca6f1cd5b4 8dec36ccaaf442898f0a597f73c79a7a 9060e5ef382e49cf942aedca6f1cd5b4--8dec36ccaaf442898f0a597f73c79a7a 221b92652b784b329152f4f9c5c31556 8dec36ccaaf442898f0a597f73c79a7a--221b92652b784b329152f4f9c5c31556 282132fbd10e4e1ab844fd9c238c2e34 221b92652b784b329152f4f9c5c31556--282132fbd10e4e1ab844fd9c238c2e34 51f1025897cd4a1384bc3ae23521494f 282132fbd10e4e1ab844fd9c238c2e34--51f1025897cd4a1384bc3ae23521494f cb3ba0b8719640499d1899a817c3054d 51f1025897cd4a1384bc3ae23521494f--cb3ba0b8719640499d1899a817c3054d 13455a76f8504e808f0d809e347676b1 cb3ba0b8719640499d1899a817c3054d--13455a76f8504e808f0d809e347676b1 2328f3c2e603460d92a9f3f9c22f333d 13455a76f8504e808f0d809e347676b1--2328f3c2e603460d92a9f3f9c22f333d 0465c7f3ceba445385c5f1cbc871fb27 2328f3c2e603460d92a9f3f9c22f333d--0465c7f3ceba445385c5f1cbc871fb27 735d200bcd0445e798377699163d11e4 X 0465c7f3ceba445385c5f1cbc871fb27--735d200bcd0445e798377699163d11e4 735d200bcd0445e798377699163d11e4--e17d1652e5b84dc58c1d39325ef498c2 463213114c2d4e2fb51099c678bdb03e RZ(-1.0*g1) 735d200bcd0445e798377699163d11e4--463213114c2d4e2fb51099c678bdb03e 0d183c66ecc8499c8d8d8e2f485544c1 X 463213114c2d4e2fb51099c678bdb03e--0d183c66ecc8499c8d8d8e2f485544c1 0d183c66ecc8499c8d8d8e2f485544c1--a1ebccb84207462a897487f5b5766bb2 705fd13fd7f64766bb4ca24b52d4bc9e 0d183c66ecc8499c8d8d8e2f485544c1--705fd13fd7f64766bb4ca24b52d4bc9e ebe9e93f977a4c998953c386f17c5c08 705fd13fd7f64766bb4ca24b52d4bc9e--ebe9e93f977a4c998953c386f17c5c08 41792b9c26fd44b0b260e78f9f1328d6 ebe9e93f977a4c998953c386f17c5c08--41792b9c26fd44b0b260e78f9f1328d6 4f8bb4f3a78542cb8798a0075da12cab 41792b9c26fd44b0b260e78f9f1328d6--4f8bb4f3a78542cb8798a0075da12cab 5079c03293754813a601330ea3cf1fe6 4f8bb4f3a78542cb8798a0075da12cab--5079c03293754813a601330ea3cf1fe6 77445bcf90e64927a04ce8fc12b35704 5079c03293754813a601330ea3cf1fe6--77445bcf90e64927a04ce8fc12b35704 3e3f2aebb9954df3a2f4ccba2983cb43 X 77445bcf90e64927a04ce8fc12b35704--3e3f2aebb9954df3a2f4ccba2983cb43 3e3f2aebb9954df3a2f4ccba2983cb43--d54161b33f0644d6af76bc891186aeb9 73337b3e564743ac854f1cbe48638f00 3e3f2aebb9954df3a2f4ccba2983cb43--73337b3e564743ac854f1cbe48638f00 1b6541848a794b6dafc9fe14d93ad3f7 73337b3e564743ac854f1cbe48638f00--1b6541848a794b6dafc9fe14d93ad3f7 bf6396b7f9f24740904227cbccc9e24a 1b6541848a794b6dafc9fe14d93ad3f7--bf6396b7f9f24740904227cbccc9e24a be2570200cb74577a68b221fa12956e2 X bf6396b7f9f24740904227cbccc9e24a--be2570200cb74577a68b221fa12956e2 be2570200cb74577a68b221fa12956e2--0cbfa34327ec465482739b874afaa6e4 dd38bde0e30c4019ad7adda612ad0fd0 be2570200cb74577a68b221fa12956e2--dd38bde0e30c4019ad7adda612ad0fd0 79edca8570da439689b105d9150ce118 dd38bde0e30c4019ad7adda612ad0fd0--79edca8570da439689b105d9150ce118 63d8d5de322549d885b014e4b5318e5c 79edca8570da439689b105d9150ce118--63d8d5de322549d885b014e4b5318e5c c027a9a1a69442d986d5a139e8096dac 63d8d5de322549d885b014e4b5318e5c--c027a9a1a69442d986d5a139e8096dac 07a14d4b0e6042748944889e3858ed8b c027a9a1a69442d986d5a139e8096dac--07a14d4b0e6042748944889e3858ed8b d78eee4caea547888d18b3411a729556 07a14d4b0e6042748944889e3858ed8b--d78eee4caea547888d18b3411a729556 bd3ea27903b640ed8a34a894b52be158 d78eee4caea547888d18b3411a729556--bd3ea27903b640ed8a34a894b52be158 a106420435164cafa5782ccff783e40d bd3ea27903b640ed8a34a894b52be158--a106420435164cafa5782ccff783e40d 2c945f7622a84bae8d600553a3ec3cec X a106420435164cafa5782ccff783e40d--2c945f7622a84bae8d600553a3ec3cec 2c945f7622a84bae8d600553a3ec3cec--bb5207ad272b4326a182f46d02c08a40 9dfddaa12b7b463996a6f6e5343dd217 RZ(-1.0*g1) 2c945f7622a84bae8d600553a3ec3cec--9dfddaa12b7b463996a6f6e5343dd217 ccaf7661a51c4c34bce2aa2f0aa16820 X 9dfddaa12b7b463996a6f6e5343dd217--ccaf7661a51c4c34bce2aa2f0aa16820 ccaf7661a51c4c34bce2aa2f0aa16820--05afac0a89c44baf95e6b9a1872c8b41 234c2005a8ca48118deec87ae9193915 ccaf7661a51c4c34bce2aa2f0aa16820--234c2005a8ca48118deec87ae9193915 9d222dd8d1f74bbe961e4e043f4fea08 234c2005a8ca48118deec87ae9193915--9d222dd8d1f74bbe961e4e043f4fea08 51243b88d9ba4c95abf15b8c0d26d08b 9d222dd8d1f74bbe961e4e043f4fea08--51243b88d9ba4c95abf15b8c0d26d08b 951e76ba3fb140b49619f67a8bddf722 51243b88d9ba4c95abf15b8c0d26d08b--951e76ba3fb140b49619f67a8bddf722 27ca3b0fe7ba4172a39c18761c0ff225 951e76ba3fb140b49619f67a8bddf722--27ca3b0fe7ba4172a39c18761c0ff225 ea6167480ce84dbba9d60c3d23b0f627 27ca3b0fe7ba4172a39c18761c0ff225--ea6167480ce84dbba9d60c3d23b0f627 a25e3d7342a34ddfa3897e23f0a348e1 X ea6167480ce84dbba9d60c3d23b0f627--a25e3d7342a34ddfa3897e23f0a348e1 a25e3d7342a34ddfa3897e23f0a348e1--a0c8d999aa2644078dc0d0695a83a207 6bdfbedcd9d74adbb3379a574e81f784 RZ(-1.0*g1) a25e3d7342a34ddfa3897e23f0a348e1--6bdfbedcd9d74adbb3379a574e81f784 a78b8e735bf74c8c9129c56cd26cda32 X 6bdfbedcd9d74adbb3379a574e81f784--a78b8e735bf74c8c9129c56cd26cda32 a78b8e735bf74c8c9129c56cd26cda32--3a78a4adae2b4a0b9741890d1c138c98 856a3193841e407e9c8dcb1c069fab58 a78b8e735bf74c8c9129c56cd26cda32--856a3193841e407e9c8dcb1c069fab58 2a4c400b81534204b5f6d95dd1a503a7 X 856a3193841e407e9c8dcb1c069fab58--2a4c400b81534204b5f6d95dd1a503a7 2a4c400b81534204b5f6d95dd1a503a7--76ff6ebb63c04243a5da42081573cab1 8e1d6d1010104e48a8043df4bce66a94 RZ(-1.0*g1) 2a4c400b81534204b5f6d95dd1a503a7--8e1d6d1010104e48a8043df4bce66a94 bb109ca67c474633bf578f5f5021efae X 8e1d6d1010104e48a8043df4bce66a94--bb109ca67c474633bf578f5f5021efae bb109ca67c474633bf578f5f5021efae--5df04bf7d9334e9ba697b3171f9e3c7e 9f861376a6834487b37b4eaf0e6f7ec6 X bb109ca67c474633bf578f5f5021efae--9f861376a6834487b37b4eaf0e6f7ec6 9f861376a6834487b37b4eaf0e6f7ec6--60de056d5bd34440bd004f1b4ec7b11c 50923a9062a94b389e9242becefebcd7 9f861376a6834487b37b4eaf0e6f7ec6--50923a9062a94b389e9242becefebcd7 fce3098b2ac44397a3f90f18f21542de 50923a9062a94b389e9242becefebcd7--fce3098b2ac44397a3f90f18f21542de e882683f677247bbb2f65e6a16e25c9b fce3098b2ac44397a3f90f18f21542de--e882683f677247bbb2f65e6a16e25c9b fd0fd96973bf466e85e28b361714ad26 X e882683f677247bbb2f65e6a16e25c9b--fd0fd96973bf466e85e28b361714ad26 fd0fd96973bf466e85e28b361714ad26--fd050c76d17d4be0867b87cd4cc2908a 50eab8f8796c4714a34d7ac5d81cbe09 RX(b16) fd0fd96973bf466e85e28b361714ad26--50eab8f8796c4714a34d7ac5d81cbe09 50eab8f8796c4714a34d7ac5d81cbe09--07fad1d41dc94e3eaa1ca34dc2755ec0 6250d638c7df449ca611eb66ffb4f00f 947a522a550443da9fa4a213d5ebc9a2 e75f7f6431c545c89e7ac7191a5a798c--947a522a550443da9fa4a213d5ebc9a2 bff64a173f9f4057b2d6ff7b432d5b8d 947a522a550443da9fa4a213d5ebc9a2--bff64a173f9f4057b2d6ff7b432d5b8d 3949455318af46f099058a64ae0bf080 bff64a173f9f4057b2d6ff7b432d5b8d--3949455318af46f099058a64ae0bf080 fc47108c015f4877b87d9ba4a58ef721 3949455318af46f099058a64ae0bf080--fc47108c015f4877b87d9ba4a58ef721 553155c6fc0f4ec8bb02d9ddc1e0dfeb fc47108c015f4877b87d9ba4a58ef721--553155c6fc0f4ec8bb02d9ddc1e0dfeb 106946fee3e041a58652a12aec6e553c 553155c6fc0f4ec8bb02d9ddc1e0dfeb--106946fee3e041a58652a12aec6e553c cc5af01a1c984a4cb49ea204d83d52ae X 106946fee3e041a58652a12aec6e553c--cc5af01a1c984a4cb49ea204d83d52ae cc5af01a1c984a4cb49ea204d83d52ae--82471788c89f4db28f35744c933fd3b4 948df5909e3c41da98cd9434eceee743 RZ(1.0*g0) cc5af01a1c984a4cb49ea204d83d52ae--948df5909e3c41da98cd9434eceee743 36533367a56c4f569e4e9ab2d051d240 X 948df5909e3c41da98cd9434eceee743--36533367a56c4f569e4e9ab2d051d240 36533367a56c4f569e4e9ab2d051d240--f26d42dd5562417191319ebc95a4082e 1659c939ec4446a5bfb6817ac6c57905 36533367a56c4f569e4e9ab2d051d240--1659c939ec4446a5bfb6817ac6c57905 3b38b6fb8ad04078ae69ddb4edaa1d8e 1659c939ec4446a5bfb6817ac6c57905--3b38b6fb8ad04078ae69ddb4edaa1d8e facb84de6c0f40d58cabc0310a175580 3b38b6fb8ad04078ae69ddb4edaa1d8e--facb84de6c0f40d58cabc0310a175580 4958dedbd27246ffa0be43050bbfde63 facb84de6c0f40d58cabc0310a175580--4958dedbd27246ffa0be43050bbfde63 3d278acc96764be2873be9b58be8e4bf 4958dedbd27246ffa0be43050bbfde63--3d278acc96764be2873be9b58be8e4bf c186d20cb8f549e38b0d6f3bceb01f1a 3d278acc96764be2873be9b58be8e4bf--c186d20cb8f549e38b0d6f3bceb01f1a 3964b6b9e8a0444e895dc992e6a49b75 c186d20cb8f549e38b0d6f3bceb01f1a--3964b6b9e8a0444e895dc992e6a49b75 ffef60382cbb4c4e9a501960364c2069 3964b6b9e8a0444e895dc992e6a49b75--ffef60382cbb4c4e9a501960364c2069 68028dd836e74757a988d14aefe93758 ffef60382cbb4c4e9a501960364c2069--68028dd836e74757a988d14aefe93758 303ae4797fb04576839224e96aa3c7f4 68028dd836e74757a988d14aefe93758--303ae4797fb04576839224e96aa3c7f4 95936f5c8f0f4a54b6e569e99cf1cfeb 303ae4797fb04576839224e96aa3c7f4--95936f5c8f0f4a54b6e569e99cf1cfeb 771cab2282fb45be9db84ebb6ecd6a46 95936f5c8f0f4a54b6e569e99cf1cfeb--771cab2282fb45be9db84ebb6ecd6a46 9e9dfc2650dc488987cb5fe51c37549f 771cab2282fb45be9db84ebb6ecd6a46--9e9dfc2650dc488987cb5fe51c37549f bc7de073ea8d41149d7ab27986d7ffb4 9e9dfc2650dc488987cb5fe51c37549f--bc7de073ea8d41149d7ab27986d7ffb4 4e44b9f334fb466487abd1f375e3638c bc7de073ea8d41149d7ab27986d7ffb4--4e44b9f334fb466487abd1f375e3638c 8b9b865777534b219882d9bdb0e3cbdf 4e44b9f334fb466487abd1f375e3638c--8b9b865777534b219882d9bdb0e3cbdf 386d90440711460a8d7bdddc78af5570 8b9b865777534b219882d9bdb0e3cbdf--386d90440711460a8d7bdddc78af5570 469ae3bf566e42c78339ae90993eb38d 386d90440711460a8d7bdddc78af5570--469ae3bf566e42c78339ae90993eb38d 53777fce78cd40fdbf9ed0a2cc052fde 469ae3bf566e42c78339ae90993eb38d--53777fce78cd40fdbf9ed0a2cc052fde d9922b96cad747c4b452036c8d55f6fc 53777fce78cd40fdbf9ed0a2cc052fde--d9922b96cad747c4b452036c8d55f6fc 2923c9413cfc4d28a6d19e02e13f7dbb d9922b96cad747c4b452036c8d55f6fc--2923c9413cfc4d28a6d19e02e13f7dbb 8f7be3b77d974e5297644aadc662876b 2923c9413cfc4d28a6d19e02e13f7dbb--8f7be3b77d974e5297644aadc662876b df5dbbb69bce44cf949ffacf6b3bddee 8f7be3b77d974e5297644aadc662876b--df5dbbb69bce44cf949ffacf6b3bddee b0c280789ca64853b93f65b01faaa712 df5dbbb69bce44cf949ffacf6b3bddee--b0c280789ca64853b93f65b01faaa712 56dd079376da43c58be0830e2c0c0e89 b0c280789ca64853b93f65b01faaa712--56dd079376da43c58be0830e2c0c0e89 76561925344442699c05e7ae5c6c6ae0 56dd079376da43c58be0830e2c0c0e89--76561925344442699c05e7ae5c6c6ae0 39c9d8ae991d4b95b226dab67e0b142c 76561925344442699c05e7ae5c6c6ae0--39c9d8ae991d4b95b226dab67e0b142c 35e7ffb0be414885a1a6d42df373c282 39c9d8ae991d4b95b226dab67e0b142c--35e7ffb0be414885a1a6d42df373c282 070018a03a3545c19fbca8133896b775 35e7ffb0be414885a1a6d42df373c282--070018a03a3545c19fbca8133896b775 f89619b0a7304ed794c5cab3c8958128 070018a03a3545c19fbca8133896b775--f89619b0a7304ed794c5cab3c8958128 2e2a9d4f57e24139ba5b70550bb22a02 f89619b0a7304ed794c5cab3c8958128--2e2a9d4f57e24139ba5b70550bb22a02 1c0f625480bb42a7ae8da7a90d20f8cb 2e2a9d4f57e24139ba5b70550bb22a02--1c0f625480bb42a7ae8da7a90d20f8cb 66e740736af94c57a11fac52eef217ca 1c0f625480bb42a7ae8da7a90d20f8cb--66e740736af94c57a11fac52eef217ca b22d87a4428b4a4f870f30a29b0f4f91 66e740736af94c57a11fac52eef217ca--b22d87a4428b4a4f870f30a29b0f4f91 192c3fcb88c247cf835199009f9802ed b22d87a4428b4a4f870f30a29b0f4f91--192c3fcb88c247cf835199009f9802ed 5944cfc0e158416d9e11c0fe90dd2745 192c3fcb88c247cf835199009f9802ed--5944cfc0e158416d9e11c0fe90dd2745 abb722bc286f46a187a0402e1a6892cc 5944cfc0e158416d9e11c0fe90dd2745--abb722bc286f46a187a0402e1a6892cc cbda7e547ef64e28b28774e5e5071537 abb722bc286f46a187a0402e1a6892cc--cbda7e547ef64e28b28774e5e5071537 f0af2e99aa9a401b88425d7356c7166a cbda7e547ef64e28b28774e5e5071537--f0af2e99aa9a401b88425d7356c7166a 6700a0eb569149398f4c07d83b2a0aca X f0af2e99aa9a401b88425d7356c7166a--6700a0eb569149398f4c07d83b2a0aca 6700a0eb569149398f4c07d83b2a0aca--d96589807d31452abe2c8e6900b80fc9 52eeb928a14c4e26abeccc104a2dc34a RZ(-1.0*g0) 6700a0eb569149398f4c07d83b2a0aca--52eeb928a14c4e26abeccc104a2dc34a a9c7f49bd9224da8adeca678d2ccb0d1 X 52eeb928a14c4e26abeccc104a2dc34a--a9c7f49bd9224da8adeca678d2ccb0d1 a9c7f49bd9224da8adeca678d2ccb0d1--476019047e6a42f98b3f37c282f440a1 775a766918994417a486c2eaf4afeb3e a9c7f49bd9224da8adeca678d2ccb0d1--775a766918994417a486c2eaf4afeb3e 362fabed800f45a6a794e85f297727a0 775a766918994417a486c2eaf4afeb3e--362fabed800f45a6a794e85f297727a0 72edbda440e2411dafc2cda1381e8e77 362fabed800f45a6a794e85f297727a0--72edbda440e2411dafc2cda1381e8e77 c28662bfa7184d838785ff9be922c3ed 72edbda440e2411dafc2cda1381e8e77--c28662bfa7184d838785ff9be922c3ed d810306f35ec4ae9b28b608333f8e3dd c28662bfa7184d838785ff9be922c3ed--d810306f35ec4ae9b28b608333f8e3dd c672e7b22ffa4dfd94bf79f390256af7 d810306f35ec4ae9b28b608333f8e3dd--c672e7b22ffa4dfd94bf79f390256af7 84f11d8c5e5448eb9cdfa7801e8eb01b c672e7b22ffa4dfd94bf79f390256af7--84f11d8c5e5448eb9cdfa7801e8eb01b 665f4d61d4004479a018addcc106fee2 84f11d8c5e5448eb9cdfa7801e8eb01b--665f4d61d4004479a018addcc106fee2 7187c4633ed14a95a2a0a6d794b3de69 665f4d61d4004479a018addcc106fee2--7187c4633ed14a95a2a0a6d794b3de69 c6e52f655752465d89ec98983d416da8 7187c4633ed14a95a2a0a6d794b3de69--c6e52f655752465d89ec98983d416da8 45245f3857f84c5480962670817341ad c6e52f655752465d89ec98983d416da8--45245f3857f84c5480962670817341ad 638dbe2af4dc45cbb46ff737622dca86 45245f3857f84c5480962670817341ad--638dbe2af4dc45cbb46ff737622dca86 bcbef203b57b46f2bdc4cbbd066f6d78 638dbe2af4dc45cbb46ff737622dca86--bcbef203b57b46f2bdc4cbbd066f6d78 4e468fb650644428acd353d819395cf4 bcbef203b57b46f2bdc4cbbd066f6d78--4e468fb650644428acd353d819395cf4 fb7d34308b494a158d869ed79f6afcd6 4e468fb650644428acd353d819395cf4--fb7d34308b494a158d869ed79f6afcd6 55c7d4003dc44850b30b3599dc398539 fb7d34308b494a158d869ed79f6afcd6--55c7d4003dc44850b30b3599dc398539 f723851f26fc432590e9ed874b719749 55c7d4003dc44850b30b3599dc398539--f723851f26fc432590e9ed874b719749 59e196be460545e18ff51eea5d6fb5cc f723851f26fc432590e9ed874b719749--59e196be460545e18ff51eea5d6fb5cc cdb9c9dd8e914c9382ca3a10c14c3727 59e196be460545e18ff51eea5d6fb5cc--cdb9c9dd8e914c9382ca3a10c14c3727 b28cf5d11dd040519912d9beb0a557fe cdb9c9dd8e914c9382ca3a10c14c3727--b28cf5d11dd040519912d9beb0a557fe 823a67ce56ae43a0a3f23697348682fd b28cf5d11dd040519912d9beb0a557fe--823a67ce56ae43a0a3f23697348682fd 527299635b8f4aeb857c0118dddd34f2 823a67ce56ae43a0a3f23697348682fd--527299635b8f4aeb857c0118dddd34f2 5f05d348910d40fa8ff906c04799d0a4 527299635b8f4aeb857c0118dddd34f2--5f05d348910d40fa8ff906c04799d0a4 83f4b28ef4bd4a4c929b50b52ce4749b 5f05d348910d40fa8ff906c04799d0a4--83f4b28ef4bd4a4c929b50b52ce4749b 14022070142d4b048518e2ad2569a7cb 83f4b28ef4bd4a4c929b50b52ce4749b--14022070142d4b048518e2ad2569a7cb 40a94a0b10b54742be834716db9cc090 14022070142d4b048518e2ad2569a7cb--40a94a0b10b54742be834716db9cc090 118b04f599604e41a41750d1914839c1 40a94a0b10b54742be834716db9cc090--118b04f599604e41a41750d1914839c1 130ba19f1e5641159aa8a5e9ee2a2017 118b04f599604e41a41750d1914839c1--130ba19f1e5641159aa8a5e9ee2a2017 03c38cac417148e09e351fc29c080416 130ba19f1e5641159aa8a5e9ee2a2017--03c38cac417148e09e351fc29c080416 f1dbb4241a704cccbc08c17545d66c4d 03c38cac417148e09e351fc29c080416--f1dbb4241a704cccbc08c17545d66c4d 72de52ca693c42de8c101206a6e392ea f1dbb4241a704cccbc08c17545d66c4d--72de52ca693c42de8c101206a6e392ea c71eddb8b7ac4857a3e73343bb695a70 72de52ca693c42de8c101206a6e392ea--c71eddb8b7ac4857a3e73343bb695a70 0be2782667634737839528d6c1c8a4da c71eddb8b7ac4857a3e73343bb695a70--0be2782667634737839528d6c1c8a4da 4530206990f7409b957aad36144c34f9 0be2782667634737839528d6c1c8a4da--4530206990f7409b957aad36144c34f9 7467f599ed12463caee92e69c18b959b 4530206990f7409b957aad36144c34f9--7467f599ed12463caee92e69c18b959b f7921d0940114b878bb38d484bbe25c3 7467f599ed12463caee92e69c18b959b--f7921d0940114b878bb38d484bbe25c3 f449d6b61dfb472b904c50aa1a1fcd1c f7921d0940114b878bb38d484bbe25c3--f449d6b61dfb472b904c50aa1a1fcd1c 23da8ef638e34681bb1c9345ee20c0e6 f449d6b61dfb472b904c50aa1a1fcd1c--23da8ef638e34681bb1c9345ee20c0e6 32d871eff6d643b5b62dfb86ee6bc474 23da8ef638e34681bb1c9345ee20c0e6--32d871eff6d643b5b62dfb86ee6bc474 76bbf5abbacd4a1b8750e30c71b232ce 32d871eff6d643b5b62dfb86ee6bc474--76bbf5abbacd4a1b8750e30c71b232ce c51eda5147cb4437a16952912c9c00ae 76bbf5abbacd4a1b8750e30c71b232ce--c51eda5147cb4437a16952912c9c00ae a849403ef3814a178dab6a184bb0f214 c51eda5147cb4437a16952912c9c00ae--a849403ef3814a178dab6a184bb0f214 3cd732892a774a0d87d8f279efad3bf4 a849403ef3814a178dab6a184bb0f214--3cd732892a774a0d87d8f279efad3bf4 f9179b49e7cd4fe5aff26d27b7e9d35a 3cd732892a774a0d87d8f279efad3bf4--f9179b49e7cd4fe5aff26d27b7e9d35a ac8093bef50d4f22970e4e82bb6a8728 f9179b49e7cd4fe5aff26d27b7e9d35a--ac8093bef50d4f22970e4e82bb6a8728 9fa3a5c3fd3c4bfa8dc3982f549821d3 ac8093bef50d4f22970e4e82bb6a8728--9fa3a5c3fd3c4bfa8dc3982f549821d3 d62c16c83ba54c6da42599a9b33e88f6 9fa3a5c3fd3c4bfa8dc3982f549821d3--d62c16c83ba54c6da42599a9b33e88f6 e2c6a553e4e94857a8b96ebdad7ed0cf d62c16c83ba54c6da42599a9b33e88f6--e2c6a553e4e94857a8b96ebdad7ed0cf f35a0177345c4b6a9b23e0a7eed80e6d e2c6a553e4e94857a8b96ebdad7ed0cf--f35a0177345c4b6a9b23e0a7eed80e6d e12a81fb364345f083525d635420a714 f35a0177345c4b6a9b23e0a7eed80e6d--e12a81fb364345f083525d635420a714 b3e8d85719294c52bca402de6830d40b e12a81fb364345f083525d635420a714--b3e8d85719294c52bca402de6830d40b 37660b73b0fa4a448b331810dabe57af b3e8d85719294c52bca402de6830d40b--37660b73b0fa4a448b331810dabe57af d4f6f8ca765943d9801a608cb0bfa197 37660b73b0fa4a448b331810dabe57af--d4f6f8ca765943d9801a608cb0bfa197 dd340adbd2cc4dfb80b496ab31ffa537 d4f6f8ca765943d9801a608cb0bfa197--dd340adbd2cc4dfb80b496ab31ffa537 779512fc631e4e2b826b0496e2e6a584 dd340adbd2cc4dfb80b496ab31ffa537--779512fc631e4e2b826b0496e2e6a584 e9abfbdcf5e04e7cb929063627875132 779512fc631e4e2b826b0496e2e6a584--e9abfbdcf5e04e7cb929063627875132 a90b73a708cf489594045c9d4a7e67ff e9abfbdcf5e04e7cb929063627875132--a90b73a708cf489594045c9d4a7e67ff bc81034a12214904b4ed368cf59b63b6 X a90b73a708cf489594045c9d4a7e67ff--bc81034a12214904b4ed368cf59b63b6 bc81034a12214904b4ed368cf59b63b6--e5e8d25806e54288b6a8783762289308 6757791cfb254a489ae52c53132e1b01 RZ(-1.0*g0) bc81034a12214904b4ed368cf59b63b6--6757791cfb254a489ae52c53132e1b01 0af3e67d59dd4780998f1ab9d54e4aec X 6757791cfb254a489ae52c53132e1b01--0af3e67d59dd4780998f1ab9d54e4aec 0af3e67d59dd4780998f1ab9d54e4aec--a5f3fcb866e349fa84fa18a068be5ae1 a5ca167d65b44e89bd704fed0ccd5c85 0af3e67d59dd4780998f1ab9d54e4aec--a5ca167d65b44e89bd704fed0ccd5c85 1793e8f4c2314d89be954d63525abf6d a5ca167d65b44e89bd704fed0ccd5c85--1793e8f4c2314d89be954d63525abf6d 3b6372b129a64a02b58fb0e7a0f7b66d 1793e8f4c2314d89be954d63525abf6d--3b6372b129a64a02b58fb0e7a0f7b66d eb640f08614d4b568e23fa4708f73433 3b6372b129a64a02b58fb0e7a0f7b66d--eb640f08614d4b568e23fa4708f73433 65a5784302934c65a24944433b969a7e eb640f08614d4b568e23fa4708f73433--65a5784302934c65a24944433b969a7e d07fe4f587be4790b2f08e32d2c60a10 65a5784302934c65a24944433b969a7e--d07fe4f587be4790b2f08e32d2c60a10 5c8715df6ed24e97b5bcf91c0be8f0a4 d07fe4f587be4790b2f08e32d2c60a10--5c8715df6ed24e97b5bcf91c0be8f0a4 188232d17b2e4ea9adb2d745ebfc6cec 5c8715df6ed24e97b5bcf91c0be8f0a4--188232d17b2e4ea9adb2d745ebfc6cec 25dbe63b1877405eb0aa8dbbd006fd92 188232d17b2e4ea9adb2d745ebfc6cec--25dbe63b1877405eb0aa8dbbd006fd92 5bea261d5295415fa6645d40111df376 25dbe63b1877405eb0aa8dbbd006fd92--5bea261d5295415fa6645d40111df376 390e057a8cdc44648bba36b7abd17ff9 5bea261d5295415fa6645d40111df376--390e057a8cdc44648bba36b7abd17ff9 491726be8685463a9e621c9f9b5ea586 390e057a8cdc44648bba36b7abd17ff9--491726be8685463a9e621c9f9b5ea586 0d91c080def2411bba0b694ec626aad6 491726be8685463a9e621c9f9b5ea586--0d91c080def2411bba0b694ec626aad6 4e86a4ed959740e4b4af78803e32fe6c 0d91c080def2411bba0b694ec626aad6--4e86a4ed959740e4b4af78803e32fe6c 8d8dbe69650941c3933a0e2e69cf7082 4e86a4ed959740e4b4af78803e32fe6c--8d8dbe69650941c3933a0e2e69cf7082 8b6b81dbb6ef4385b3e3a4e30a3b9767 8d8dbe69650941c3933a0e2e69cf7082--8b6b81dbb6ef4385b3e3a4e30a3b9767 0a73e48066b046fd9af0eba3b6170bb3 8b6b81dbb6ef4385b3e3a4e30a3b9767--0a73e48066b046fd9af0eba3b6170bb3 0cf67f40ff2447e7bd5d78f8f64e91f5 0a73e48066b046fd9af0eba3b6170bb3--0cf67f40ff2447e7bd5d78f8f64e91f5 a5d18d561f5a44b2b92c9cc33551a55a 0cf67f40ff2447e7bd5d78f8f64e91f5--a5d18d561f5a44b2b92c9cc33551a55a b7d2c3c3ab7940339ad1b1124d74dcd2 a5d18d561f5a44b2b92c9cc33551a55a--b7d2c3c3ab7940339ad1b1124d74dcd2 2281b3f32b224e4ca0816f99f357691d b7d2c3c3ab7940339ad1b1124d74dcd2--2281b3f32b224e4ca0816f99f357691d 7adbd57524ae4520a18b1896ccd68aa8 2281b3f32b224e4ca0816f99f357691d--7adbd57524ae4520a18b1896ccd68aa8 de73db1f20a749f2bda6f7f299d1a679 7adbd57524ae4520a18b1896ccd68aa8--de73db1f20a749f2bda6f7f299d1a679 1df8a24bee3241f58785a9f411aba54a de73db1f20a749f2bda6f7f299d1a679--1df8a24bee3241f58785a9f411aba54a 0a5f7967f44e4023a78dc0c5baba4dcc 1df8a24bee3241f58785a9f411aba54a--0a5f7967f44e4023a78dc0c5baba4dcc a5b3b63f01294c609710f390be8d954f 0a5f7967f44e4023a78dc0c5baba4dcc--a5b3b63f01294c609710f390be8d954f e02aa481bca84eedbab17f3f0cf316b5 X a5b3b63f01294c609710f390be8d954f--e02aa481bca84eedbab17f3f0cf316b5 e02aa481bca84eedbab17f3f0cf316b5--ce2ac3bae27749dd865001c9898a91a2 7cf85e73785e443e86c7bbe930c3b23c RZ(-1.0*g0) e02aa481bca84eedbab17f3f0cf316b5--7cf85e73785e443e86c7bbe930c3b23c 54d98ea5f4e14c049d31c42b85171f4d X 7cf85e73785e443e86c7bbe930c3b23c--54d98ea5f4e14c049d31c42b85171f4d 54d98ea5f4e14c049d31c42b85171f4d--ab8e11c06c0d404f891f753bb0555078 da4d2d89c1664ed1b08b457b877fcca7 54d98ea5f4e14c049d31c42b85171f4d--da4d2d89c1664ed1b08b457b877fcca7 93f412e2913f4de9b2edf603480bfabf RX(b07) da4d2d89c1664ed1b08b457b877fcca7--93f412e2913f4de9b2edf603480bfabf d8d8200bee2f41448c1c560ade126539 93f412e2913f4de9b2edf603480bfabf--d8d8200bee2f41448c1c560ade126539 8a97928dbd514b7d8d45a1fafd0272d5 d8d8200bee2f41448c1c560ade126539--8a97928dbd514b7d8d45a1fafd0272d5 f774e12a32d64398930043ba0fad0414 8a97928dbd514b7d8d45a1fafd0272d5--f774e12a32d64398930043ba0fad0414 210426d60b1f4da5b6fb77861c0c3bf8 f774e12a32d64398930043ba0fad0414--210426d60b1f4da5b6fb77861c0c3bf8 bc7623e9f1ff421bb97106fbd432a824 210426d60b1f4da5b6fb77861c0c3bf8--bc7623e9f1ff421bb97106fbd432a824 feb7c51aba4b41aa92460c26ba4db644 bc7623e9f1ff421bb97106fbd432a824--feb7c51aba4b41aa92460c26ba4db644 63807c694aed4c658bfdfaea8fd5990f X feb7c51aba4b41aa92460c26ba4db644--63807c694aed4c658bfdfaea8fd5990f 63807c694aed4c658bfdfaea8fd5990f--c6e0db08e3064dc3be59e99f81cec6a2 36e6f42c42d9482c87094033a5bb5323 RZ(1.0*g1) 63807c694aed4c658bfdfaea8fd5990f--36e6f42c42d9482c87094033a5bb5323 c5253642d6f844ebae117ad787fc8373 X 36e6f42c42d9482c87094033a5bb5323--c5253642d6f844ebae117ad787fc8373 c5253642d6f844ebae117ad787fc8373--7bded0e57e5b42c7898a7c843d09489a de9d7c14fb794c709da6c5e602672049 c5253642d6f844ebae117ad787fc8373--de9d7c14fb794c709da6c5e602672049 bf25bb348c3447cfae2cbf6e7ca1a738 de9d7c14fb794c709da6c5e602672049--bf25bb348c3447cfae2cbf6e7ca1a738 e948499d624a4361b36d83c5a8131f43 bf25bb348c3447cfae2cbf6e7ca1a738--e948499d624a4361b36d83c5a8131f43 5e9af074816348b4831acad18de4969f e948499d624a4361b36d83c5a8131f43--5e9af074816348b4831acad18de4969f 530531f03865479789c55f327a9b80a5 5e9af074816348b4831acad18de4969f--530531f03865479789c55f327a9b80a5 6a2bba7114d8491ab3e3caf111013b0d 530531f03865479789c55f327a9b80a5--6a2bba7114d8491ab3e3caf111013b0d ff05300c460742898046850f5f8a2b55 6a2bba7114d8491ab3e3caf111013b0d--ff05300c460742898046850f5f8a2b55 b2b8e001edd04d46b1c5915d3aa209c8 ff05300c460742898046850f5f8a2b55--b2b8e001edd04d46b1c5915d3aa209c8 a6478648841342fca670c76bf4ff68b8 b2b8e001edd04d46b1c5915d3aa209c8--a6478648841342fca670c76bf4ff68b8 6a2b63a75df5463fb500a6a566e286ad a6478648841342fca670c76bf4ff68b8--6a2b63a75df5463fb500a6a566e286ad 509db927e4f145a39c862a394f73802b 6a2b63a75df5463fb500a6a566e286ad--509db927e4f145a39c862a394f73802b 3c238aa0686843b39b9c257d1505df5f 509db927e4f145a39c862a394f73802b--3c238aa0686843b39b9c257d1505df5f 38f184bfafae4715b59c85620a1703ed 3c238aa0686843b39b9c257d1505df5f--38f184bfafae4715b59c85620a1703ed fee752dbba50441788e25f19ddcd2719 38f184bfafae4715b59c85620a1703ed--fee752dbba50441788e25f19ddcd2719 28016b383ea64262a2badb2a5b297c2d fee752dbba50441788e25f19ddcd2719--28016b383ea64262a2badb2a5b297c2d 4d9d5b95e74b40e1b4c7e20d56e68be6 28016b383ea64262a2badb2a5b297c2d--4d9d5b95e74b40e1b4c7e20d56e68be6 1368bc4976f249be89543c25c9810c44 4d9d5b95e74b40e1b4c7e20d56e68be6--1368bc4976f249be89543c25c9810c44 ba2b0ac219144aef8bbe1523d381dcd0 1368bc4976f249be89543c25c9810c44--ba2b0ac219144aef8bbe1523d381dcd0 6b1bb04ef79a4646b4f1a7ccd0281d98 ba2b0ac219144aef8bbe1523d381dcd0--6b1bb04ef79a4646b4f1a7ccd0281d98 88869cca02a4402b8417c4fcc58e79b5 6b1bb04ef79a4646b4f1a7ccd0281d98--88869cca02a4402b8417c4fcc58e79b5 6e537c06c75243df95a26e7af521f6f4 88869cca02a4402b8417c4fcc58e79b5--6e537c06c75243df95a26e7af521f6f4 38e68b6fc89945d0bf946dfb1d705941 6e537c06c75243df95a26e7af521f6f4--38e68b6fc89945d0bf946dfb1d705941 f83bc791080d4dfb867c6639afe202ca 38e68b6fc89945d0bf946dfb1d705941--f83bc791080d4dfb867c6639afe202ca 9292041de593453c8b62bb34e0fbd6e5 f83bc791080d4dfb867c6639afe202ca--9292041de593453c8b62bb34e0fbd6e5 8c9aa2703d634219996434f337589111 9292041de593453c8b62bb34e0fbd6e5--8c9aa2703d634219996434f337589111 c9f1589eecb04b6687bec72bdf611361 8c9aa2703d634219996434f337589111--c9f1589eecb04b6687bec72bdf611361 212e1ea9912c4b828251ccc3bd0fdcad c9f1589eecb04b6687bec72bdf611361--212e1ea9912c4b828251ccc3bd0fdcad d44313c8eba743f49bbdce3e95ad572b 212e1ea9912c4b828251ccc3bd0fdcad--d44313c8eba743f49bbdce3e95ad572b 6b3a1488bb624d8185e65875b1100092 d44313c8eba743f49bbdce3e95ad572b--6b3a1488bb624d8185e65875b1100092 3956a51b82e249d8bdf459cdd0136d4d 6b3a1488bb624d8185e65875b1100092--3956a51b82e249d8bdf459cdd0136d4d bacda1c40ca24fc2bd32d5028fe91d71 3956a51b82e249d8bdf459cdd0136d4d--bacda1c40ca24fc2bd32d5028fe91d71 cc8caf5be7aa496d970e904516e71376 bacda1c40ca24fc2bd32d5028fe91d71--cc8caf5be7aa496d970e904516e71376 4d431d1304d34d25a52025314d8437be cc8caf5be7aa496d970e904516e71376--4d431d1304d34d25a52025314d8437be 9130a3f4a16f4980aa3be7a1a88d1578 4d431d1304d34d25a52025314d8437be--9130a3f4a16f4980aa3be7a1a88d1578 96da3572a6fa4296a3e39b80911f9936 9130a3f4a16f4980aa3be7a1a88d1578--96da3572a6fa4296a3e39b80911f9936 cf256e1437e14cf788e374a49fae7962 96da3572a6fa4296a3e39b80911f9936--cf256e1437e14cf788e374a49fae7962 6c9f0dba550044eeae686cbff23572c7 cf256e1437e14cf788e374a49fae7962--6c9f0dba550044eeae686cbff23572c7 a4decec29fc5469ca409da796579cd5b 6c9f0dba550044eeae686cbff23572c7--a4decec29fc5469ca409da796579cd5b d3b8f156c4dc4478b18bf77508380331 a4decec29fc5469ca409da796579cd5b--d3b8f156c4dc4478b18bf77508380331 6679c65b09ed4faaadc7b9772b1dbec6 X d3b8f156c4dc4478b18bf77508380331--6679c65b09ed4faaadc7b9772b1dbec6 6679c65b09ed4faaadc7b9772b1dbec6--9485eb7c780d4ba6bf06511fa13b377b 6dcaf3eed6e5466489486c6a13a19335 RZ(-1.0*g1) 6679c65b09ed4faaadc7b9772b1dbec6--6dcaf3eed6e5466489486c6a13a19335 46e1aa9b569d490b80b17031e0af3596 X 6dcaf3eed6e5466489486c6a13a19335--46e1aa9b569d490b80b17031e0af3596 46e1aa9b569d490b80b17031e0af3596--d087013673ae428d882fab09742f2d2e 8b84a17cb97b49d1ae856f6f4b3673be 46e1aa9b569d490b80b17031e0af3596--8b84a17cb97b49d1ae856f6f4b3673be fc66b261809a448e9e5520f85607f939 8b84a17cb97b49d1ae856f6f4b3673be--fc66b261809a448e9e5520f85607f939 259209337e884e4b802b245bea3fda1f fc66b261809a448e9e5520f85607f939--259209337e884e4b802b245bea3fda1f aacd9f839a7b4986bb9f3510048d79a3 259209337e884e4b802b245bea3fda1f--aacd9f839a7b4986bb9f3510048d79a3 b240054f035d4f0c8fd9a6abca4ad59b aacd9f839a7b4986bb9f3510048d79a3--b240054f035d4f0c8fd9a6abca4ad59b 00ec36e6d7eb49d6972249623b6227ec b240054f035d4f0c8fd9a6abca4ad59b--00ec36e6d7eb49d6972249623b6227ec 6b6ffc4a471b4f90a842f8289a94ba64 00ec36e6d7eb49d6972249623b6227ec--6b6ffc4a471b4f90a842f8289a94ba64 62c142b0d6f04867839a471037803426 6b6ffc4a471b4f90a842f8289a94ba64--62c142b0d6f04867839a471037803426 088373a0d7ac45aa9be16c113868cef3 62c142b0d6f04867839a471037803426--088373a0d7ac45aa9be16c113868cef3 6237b67517fd414eb15f91a046fdc620 088373a0d7ac45aa9be16c113868cef3--6237b67517fd414eb15f91a046fdc620 679cc1a9fe06425f994d2b9f952c8cde 6237b67517fd414eb15f91a046fdc620--679cc1a9fe06425f994d2b9f952c8cde 9763774225c648b599481b3f9f39937b 679cc1a9fe06425f994d2b9f952c8cde--9763774225c648b599481b3f9f39937b f4e1731a978142d69c48204b3ffbe36e 9763774225c648b599481b3f9f39937b--f4e1731a978142d69c48204b3ffbe36e 51eace6ed5bf42a7956bbe60a9b73687 f4e1731a978142d69c48204b3ffbe36e--51eace6ed5bf42a7956bbe60a9b73687 4aedaf53b2794d10be4a1e70d144f1f7 51eace6ed5bf42a7956bbe60a9b73687--4aedaf53b2794d10be4a1e70d144f1f7 e5aafdf0d22644698e6ebc4003cd83ee 4aedaf53b2794d10be4a1e70d144f1f7--e5aafdf0d22644698e6ebc4003cd83ee a9c90a50a63040ceb522bbdcf9472699 e5aafdf0d22644698e6ebc4003cd83ee--a9c90a50a63040ceb522bbdcf9472699 01ba94bbd3974d20a6f03ceca47f024b a9c90a50a63040ceb522bbdcf9472699--01ba94bbd3974d20a6f03ceca47f024b 7e2021a88a11476b8aca1ede3aa30892 01ba94bbd3974d20a6f03ceca47f024b--7e2021a88a11476b8aca1ede3aa30892 ce5f6cbfec244b569b5a9de24e4c3147 7e2021a88a11476b8aca1ede3aa30892--ce5f6cbfec244b569b5a9de24e4c3147 da52695763484068bed5ee6647076094 ce5f6cbfec244b569b5a9de24e4c3147--da52695763484068bed5ee6647076094 c167d771ce894ba7840b45e80cba64f8 da52695763484068bed5ee6647076094--c167d771ce894ba7840b45e80cba64f8 476da948b66347fcaca0e6d773237379 c167d771ce894ba7840b45e80cba64f8--476da948b66347fcaca0e6d773237379 dedb6fb316b64f0899d9a7485273a12f 476da948b66347fcaca0e6d773237379--dedb6fb316b64f0899d9a7485273a12f cf78f142e359491e9e033e69c8185e2b dedb6fb316b64f0899d9a7485273a12f--cf78f142e359491e9e033e69c8185e2b b9ce03b62b964a9bb7f2dbf6200a7ca5 cf78f142e359491e9e033e69c8185e2b--b9ce03b62b964a9bb7f2dbf6200a7ca5 e8ae9b0e6fd24e629d211c1861a8dc5a b9ce03b62b964a9bb7f2dbf6200a7ca5--e8ae9b0e6fd24e629d211c1861a8dc5a c2e3b938202641c4b0bdc3aec8ff23c1 e8ae9b0e6fd24e629d211c1861a8dc5a--c2e3b938202641c4b0bdc3aec8ff23c1 3c389dd451bb4ae0a637a568b2955fba c2e3b938202641c4b0bdc3aec8ff23c1--3c389dd451bb4ae0a637a568b2955fba 9fd1dfd191ad4b2ab2aaf66809e896c4 3c389dd451bb4ae0a637a568b2955fba--9fd1dfd191ad4b2ab2aaf66809e896c4 f927a1e97d324cf68d1ee6cee5a8770f 9fd1dfd191ad4b2ab2aaf66809e896c4--f927a1e97d324cf68d1ee6cee5a8770f ce2314a3af3146bbb952ed0c3615a913 f927a1e97d324cf68d1ee6cee5a8770f--ce2314a3af3146bbb952ed0c3615a913 8ffab01ab5b7431881d3cd4e4855b05e ce2314a3af3146bbb952ed0c3615a913--8ffab01ab5b7431881d3cd4e4855b05e 04706305a03547aa8dfc3894f8052c9c 8ffab01ab5b7431881d3cd4e4855b05e--04706305a03547aa8dfc3894f8052c9c 4a418eee378f4e318acee70ca8a273e1 04706305a03547aa8dfc3894f8052c9c--4a418eee378f4e318acee70ca8a273e1 2e22b98aaf6c469db7cd2566be186bc8 4a418eee378f4e318acee70ca8a273e1--2e22b98aaf6c469db7cd2566be186bc8 dbde999a64a64c0d837f4e0f98788313 2e22b98aaf6c469db7cd2566be186bc8--dbde999a64a64c0d837f4e0f98788313 2b05da452a034422b14ab5b661762262 dbde999a64a64c0d837f4e0f98788313--2b05da452a034422b14ab5b661762262 3ca3b0dfc9724bc2beb10d087c4bee51 2b05da452a034422b14ab5b661762262--3ca3b0dfc9724bc2beb10d087c4bee51 18243ec185b74980a1ed2997e5069ad1 3ca3b0dfc9724bc2beb10d087c4bee51--18243ec185b74980a1ed2997e5069ad1 25abb883aba446e88e7bd540f2c38954 18243ec185b74980a1ed2997e5069ad1--25abb883aba446e88e7bd540f2c38954 7175bb9630dc422c9b10e28b72d1ca45 25abb883aba446e88e7bd540f2c38954--7175bb9630dc422c9b10e28b72d1ca45 e157fc3402114e97be6020f7aa4654a8 7175bb9630dc422c9b10e28b72d1ca45--e157fc3402114e97be6020f7aa4654a8 2ae7fc0777764e51a41c9f48db9ccae0 e157fc3402114e97be6020f7aa4654a8--2ae7fc0777764e51a41c9f48db9ccae0 436389d232fb4492b5807714115e970b 2ae7fc0777764e51a41c9f48db9ccae0--436389d232fb4492b5807714115e970b 797a2b6b7e2e4d7999ff6836974362fa 436389d232fb4492b5807714115e970b--797a2b6b7e2e4d7999ff6836974362fa 6c8183f29f07488a8f1da9ffbc2c9828 797a2b6b7e2e4d7999ff6836974362fa--6c8183f29f07488a8f1da9ffbc2c9828 577df088ee7d4f9dab4f90a0537a66d3 6c8183f29f07488a8f1da9ffbc2c9828--577df088ee7d4f9dab4f90a0537a66d3 d8e1781bf02b4b4a86a9b5f69f3d3511 577df088ee7d4f9dab4f90a0537a66d3--d8e1781bf02b4b4a86a9b5f69f3d3511 aa88379eaa534a11839c8d6227d99b21 d8e1781bf02b4b4a86a9b5f69f3d3511--aa88379eaa534a11839c8d6227d99b21 5a9e41d8e1ac4d1bbd8fca586d7c2926 aa88379eaa534a11839c8d6227d99b21--5a9e41d8e1ac4d1bbd8fca586d7c2926 1b35d5adfd9744f1ba499fb537d11341 5a9e41d8e1ac4d1bbd8fca586d7c2926--1b35d5adfd9744f1ba499fb537d11341 a73b1eefab2a4a89ab3ef58b2af5e10f 1b35d5adfd9744f1ba499fb537d11341--a73b1eefab2a4a89ab3ef58b2af5e10f bac5ebef62af4663b934dddddc8e8cb8 a73b1eefab2a4a89ab3ef58b2af5e10f--bac5ebef62af4663b934dddddc8e8cb8 0f570e46e9bc4f12b6ac59201b766c5c bac5ebef62af4663b934dddddc8e8cb8--0f570e46e9bc4f12b6ac59201b766c5c 32cc1c12129145db9a21a5ec660ddc26 0f570e46e9bc4f12b6ac59201b766c5c--32cc1c12129145db9a21a5ec660ddc26 2e34d5ebbe1c477f85304548a2d6304d 32cc1c12129145db9a21a5ec660ddc26--2e34d5ebbe1c477f85304548a2d6304d 112e25b6f6ed473a80fa5599c2b2ab5d X 2e34d5ebbe1c477f85304548a2d6304d--112e25b6f6ed473a80fa5599c2b2ab5d 112e25b6f6ed473a80fa5599c2b2ab5d--73337b3e564743ac854f1cbe48638f00 8edcc686d0234720b252acc6de704b3a RZ(-1.0*g1) 112e25b6f6ed473a80fa5599c2b2ab5d--8edcc686d0234720b252acc6de704b3a 79978bc15ebc41b782840aa05eb58694 X 8edcc686d0234720b252acc6de704b3a--79978bc15ebc41b782840aa05eb58694 79978bc15ebc41b782840aa05eb58694--bf6396b7f9f24740904227cbccc9e24a 1465cd2d3ad44c8187278eba8e00ff83 79978bc15ebc41b782840aa05eb58694--1465cd2d3ad44c8187278eba8e00ff83 98db86d7bfa84f2886989df3927dead3 1465cd2d3ad44c8187278eba8e00ff83--98db86d7bfa84f2886989df3927dead3 e41eee5262884a1c90c84b8d644614b4 98db86d7bfa84f2886989df3927dead3--e41eee5262884a1c90c84b8d644614b4 79e2dc0e085a4d6c93cae9b268d17660 e41eee5262884a1c90c84b8d644614b4--79e2dc0e085a4d6c93cae9b268d17660 102a219810ba405188bc8573b29aa75b 79e2dc0e085a4d6c93cae9b268d17660--102a219810ba405188bc8573b29aa75b 9656d427fcdf4dbea174f2b7e1d583a4 102a219810ba405188bc8573b29aa75b--9656d427fcdf4dbea174f2b7e1d583a4 99f7d713ebd1429f83abf81f16783ba3 9656d427fcdf4dbea174f2b7e1d583a4--99f7d713ebd1429f83abf81f16783ba3 b527a8947eaf42d6ac60f81ee84e15cd 99f7d713ebd1429f83abf81f16783ba3--b527a8947eaf42d6ac60f81ee84e15cd eb046b5b724d4167b20af22facd2fa41 b527a8947eaf42d6ac60f81ee84e15cd--eb046b5b724d4167b20af22facd2fa41 1a07a654ca5046fea4eae9e5d1b1648d eb046b5b724d4167b20af22facd2fa41--1a07a654ca5046fea4eae9e5d1b1648d c774c8bba13b4ccf89a131492f82c1e5 1a07a654ca5046fea4eae9e5d1b1648d--c774c8bba13b4ccf89a131492f82c1e5 455f053a065142d3bec0b730b45c6890 c774c8bba13b4ccf89a131492f82c1e5--455f053a065142d3bec0b730b45c6890 1c4e3f56522742649b4b577483f3ae0a 455f053a065142d3bec0b730b45c6890--1c4e3f56522742649b4b577483f3ae0a 8a7c2146bcf745d59669512e76c30516 1c4e3f56522742649b4b577483f3ae0a--8a7c2146bcf745d59669512e76c30516 48d10679fc814111bea03b554de88b0f 8a7c2146bcf745d59669512e76c30516--48d10679fc814111bea03b554de88b0f 5e63bd42a40d4c54981bbfc09d1e9698 48d10679fc814111bea03b554de88b0f--5e63bd42a40d4c54981bbfc09d1e9698 109b2ac5232c483ab8ec0e6f3f760647 5e63bd42a40d4c54981bbfc09d1e9698--109b2ac5232c483ab8ec0e6f3f760647 a685046269e84ec9a12ddb1e459efc36 109b2ac5232c483ab8ec0e6f3f760647--a685046269e84ec9a12ddb1e459efc36 2ebc3b034701457189a150bc1dddc266 a685046269e84ec9a12ddb1e459efc36--2ebc3b034701457189a150bc1dddc266 c1008d501db7453dbc95ca9f629922bd 2ebc3b034701457189a150bc1dddc266--c1008d501db7453dbc95ca9f629922bd da920dfc090e4089a3d5ef0dabd27a2a c1008d501db7453dbc95ca9f629922bd--da920dfc090e4089a3d5ef0dabd27a2a a240a3b7f5124190ba1bd752c990ca0c da920dfc090e4089a3d5ef0dabd27a2a--a240a3b7f5124190ba1bd752c990ca0c b1d443c0006e462182c6a7e2cb20dbb3 a240a3b7f5124190ba1bd752c990ca0c--b1d443c0006e462182c6a7e2cb20dbb3 4dde5692d2c946958c4fa5761fa6fbd8 b1d443c0006e462182c6a7e2cb20dbb3--4dde5692d2c946958c4fa5761fa6fbd8 46cf4204b8ef4507bae88fb2d177a34a 4dde5692d2c946958c4fa5761fa6fbd8--46cf4204b8ef4507bae88fb2d177a34a 39a434d45f054395bbce9e6ab26b6528 46cf4204b8ef4507bae88fb2d177a34a--39a434d45f054395bbce9e6ab26b6528 3cf782559da340c7b9b9dd5de2ca2ccd X 39a434d45f054395bbce9e6ab26b6528--3cf782559da340c7b9b9dd5de2ca2ccd 3cf782559da340c7b9b9dd5de2ca2ccd--50923a9062a94b389e9242becefebcd7 eb0ebc7919804efd9ee6f018475a2bfd RZ(-1.0*g1) 3cf782559da340c7b9b9dd5de2ca2ccd--eb0ebc7919804efd9ee6f018475a2bfd ac59cb4900bb4cab98c79ea657e686da X eb0ebc7919804efd9ee6f018475a2bfd--ac59cb4900bb4cab98c79ea657e686da ac59cb4900bb4cab98c79ea657e686da--e882683f677247bbb2f65e6a16e25c9b b69a9c27a9a94ea6bc973984b94b4f58 ac59cb4900bb4cab98c79ea657e686da--b69a9c27a9a94ea6bc973984b94b4f58 750fb5a729bc42c68a74bedf7912e5e3 RX(b17) b69a9c27a9a94ea6bc973984b94b4f58--750fb5a729bc42c68a74bedf7912e5e3 750fb5a729bc42c68a74bedf7912e5e3--6250d638c7df449ca611eb66ffb4f00f"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -5.011149344353439\nMaxCut cost at iteration 10: 11.774334214359337\nMaxCut cost at iteration 20: 11.990811495507359\nMaxCut cost at iteration 30: 11.999790860490368\nMaxCut cost at iteration 40: 11.999994958972293\nMaxCut cost at iteration 50: 11.999999546158671\nMaxCut cost at iteration 60: 11.999999769047564\nMaxCut cost at iteration 70: 11.999999853496345\nMaxCut cost at iteration 80: 11.99999990627782\nMaxCut cost at iteration 90: 11.99999994002341\nMaxCut cost at iteration 100: 11.999999961616892\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 10100010  2024-01-17T18:16:28.409298 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2024-01-17T18:16:32.659478 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_d164f77e6268451985386f0700e1f6ee Constant Chebyshev FM cluster_bbd85d04461f42b5a766c26676df9c46 Constant Fourier FM e652cb02251546e59728c36e3fdcf5de 0 3083b54d6206413dade27779f4863c08 RX(phi) e652cb02251546e59728c36e3fdcf5de--3083b54d6206413dade27779f4863c08 e062e4a41ea8469d9ecc866c27d79738 1 e6e1869c86ad4201a63e7c069bc6f272 RX(acos(phi)) 3083b54d6206413dade27779f4863c08--e6e1869c86ad4201a63e7c069bc6f272 3c0d4c38b0394a3fa8287057f699a14d e6e1869c86ad4201a63e7c069bc6f272--3c0d4c38b0394a3fa8287057f699a14d ea4a7dd5bd21428484c8a1a1f53fe108 08070c2aa67141b9902bb09cfcdaa1d5 RX(phi) e062e4a41ea8469d9ecc866c27d79738--08070c2aa67141b9902bb09cfcdaa1d5 9425f3f9e7b44d9da944749a3949d9a6 2 a2c58b84c8394fcb8f03587e85981e6c RX(acos(phi)) 08070c2aa67141b9902bb09cfcdaa1d5--a2c58b84c8394fcb8f03587e85981e6c a2c58b84c8394fcb8f03587e85981e6c--ea4a7dd5bd21428484c8a1a1f53fe108 f0e34ca6ef114cfd83aaaaeb2c8b59fd dbef91e6743c47c49ab27aa8af1b5690 RX(phi) 9425f3f9e7b44d9da944749a3949d9a6--dbef91e6743c47c49ab27aa8af1b5690 2a8ad882de5144b5a1ef621005028a46 RX(acos(phi)) dbef91e6743c47c49ab27aa8af1b5690--2a8ad882de5144b5a1ef621005028a46 2a8ad882de5144b5a1ef621005028a46--f0e34ca6ef114cfd83aaaaeb2c8b59fd <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_999e410a900c40698aad64766a5e690c Constant &lt;function custom_fn at 0x7f815936c430&gt; FM cluster_6ec05e7cb5d94e64b97fa869e7cf4256 Constant asin FM 814551105abb42bbaee843044fe27173 0 df0765f94f324f4e80cfd08b81755633 RX(asin(phi)) 814551105abb42bbaee843044fe27173--df0765f94f324f4e80cfd08b81755633 fb45bf6faa8d4e02b53cd307213d4e47 1 19d78e5b1114433e8fb27377de20440c RX(phi**2 + asin(phi)) df0765f94f324f4e80cfd08b81755633--19d78e5b1114433e8fb27377de20440c df810461dc4343b0827413676f05212b 19d78e5b1114433e8fb27377de20440c--df810461dc4343b0827413676f05212b 04796345cc02454cbda1d0a499a19b7b 1ed2d03d660041e4808139a17c8e58fa RX(asin(phi)) fb45bf6faa8d4e02b53cd307213d4e47--1ed2d03d660041e4808139a17c8e58fa 2abbbbccfb624199be6a335792f52650 2 5466887317044a8b90ba32cbff77b903 RX(phi**2 + asin(phi)) 1ed2d03d660041e4808139a17c8e58fa--5466887317044a8b90ba32cbff77b903 5466887317044a8b90ba32cbff77b903--04796345cc02454cbda1d0a499a19b7b 39e7d6220c0442f4b3908bbe283bdb76 853c5df493074c6598015b65139f9495 RX(asin(phi)) 2abbbbccfb624199be6a335792f52650--853c5df493074c6598015b65139f9495 54ffcbaf0a334f248c03ad797426086a RX(phi**2 + asin(phi)) 853c5df493074c6598015b65139f9495--54ffcbaf0a334f248c03ad797426086a 54ffcbaf0a334f248c03ad797426086a--39e7d6220c0442f4b3908bbe283bdb76 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_5bae8a25e09a45efb9b7adbf0ccfc6bb Exponential Fourier FM cluster_184ace91209443af97de06c5399f43bb Constant Fourier FM cluster_65da035f64cc4c30bacb027741230fcb Tower Fourier FM 474272789dbf467496ffa5b185fc5ba9 0 5b7a6beb6b29467592c026875782e56b RX(phi) 474272789dbf467496ffa5b185fc5ba9--5b7a6beb6b29467592c026875782e56b 05fe295a08b14345aa1a8e489300b4a2 1 1c6825e03f9f4ec7a6e5682086ca86a7 RX(1.0*phi) 5b7a6beb6b29467592c026875782e56b--1c6825e03f9f4ec7a6e5682086ca86a7 76845bbc47d941a6b4e69caa3c6d148b RX(1.0*phi) 1c6825e03f9f4ec7a6e5682086ca86a7--76845bbc47d941a6b4e69caa3c6d148b 3a2f84ce46304bd5be13ce95d7542d35 76845bbc47d941a6b4e69caa3c6d148b--3a2f84ce46304bd5be13ce95d7542d35 5b2ad77078314d9e8b03e81b9e1ac935 23c71e77b46c4041a3f952fca19ee6ab RX(phi) 05fe295a08b14345aa1a8e489300b4a2--23c71e77b46c4041a3f952fca19ee6ab 1d949e3bc5eb4a4a87b3d21e8b862adc 2 0be2ed8c453d49e6aa49bd30faae8942 RX(2.0*phi) 23c71e77b46c4041a3f952fca19ee6ab--0be2ed8c453d49e6aa49bd30faae8942 d4a3206744cb4e2db4dd99e08d2940f1 RX(2.0*phi) 0be2ed8c453d49e6aa49bd30faae8942--d4a3206744cb4e2db4dd99e08d2940f1 d4a3206744cb4e2db4dd99e08d2940f1--5b2ad77078314d9e8b03e81b9e1ac935 8d3e3779aafa4d17b384a15dee2776ac e5bbc8627ce14fa5b33d94c51382c79d RX(phi) 1d949e3bc5eb4a4a87b3d21e8b862adc--e5bbc8627ce14fa5b33d94c51382c79d 6da3bb5c927848e3aeb5344875c2a003 3 9be5b62d879b49348da6fd7994714337 RX(3.0*phi) e5bbc8627ce14fa5b33d94c51382c79d--9be5b62d879b49348da6fd7994714337 eec16c10f7b44b569eb653d88e65881e RX(4.0*phi) 9be5b62d879b49348da6fd7994714337--eec16c10f7b44b569eb653d88e65881e eec16c10f7b44b569eb653d88e65881e--8d3e3779aafa4d17b384a15dee2776ac 71375855ad5244c58d07c023a513721d ef947ecb6be7486fb360d8a00be74d6d RX(phi) 6da3bb5c927848e3aeb5344875c2a003--ef947ecb6be7486fb360d8a00be74d6d 1077d58498be40e09eb361b83b34201c 4 b5ae839d15074354a0a2a5f3140538ac RX(4.0*phi) ef947ecb6be7486fb360d8a00be74d6d--b5ae839d15074354a0a2a5f3140538ac e2c968aa146049bb98e6237645f2af18 RX(8.0*phi) b5ae839d15074354a0a2a5f3140538ac--e2c968aa146049bb98e6237645f2af18 e2c968aa146049bb98e6237645f2af18--71375855ad5244c58d07c023a513721d af579d605af54fafb2643f3304609452 42c61f1915ad43dfb6c97dd929c257b6 RX(phi) 1077d58498be40e09eb361b83b34201c--42c61f1915ad43dfb6c97dd929c257b6 27c4a2850ee6454b86afc93d35eb329a RX(5.0*phi) 42c61f1915ad43dfb6c97dd929c257b6--27c4a2850ee6454b86afc93d35eb329a 9efde9b521484e949faac301b2220999 RX(16.0*phi) 27c4a2850ee6454b86afc93d35eb329a--9efde9b521484e949faac301b2220999 9efde9b521484e949faac301b2220999--af579d605af54fafb2643f3304609452 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 06a7b34e1dd44600a211ab4a7f8a5846 0 9e8155c20ae54a6aa017daf1aa4b9f8f RX(1.0*acos(phi)) 06a7b34e1dd44600a211ab4a7f8a5846--9e8155c20ae54a6aa017daf1aa4b9f8f 52e2b48da27746238fc864fd1fea1988 1 cd4626d50d8941c481942b5d31bfe356 9e8155c20ae54a6aa017daf1aa4b9f8f--cd4626d50d8941c481942b5d31bfe356 fe4fcf3b51054b92840333e100c0cd44 3f92bf82673a48e4ac1404dfad9999ab RX(1.414*acos(phi)) 52e2b48da27746238fc864fd1fea1988--3f92bf82673a48e4ac1404dfad9999ab e6fd11846757422d893d7b4e9c629540 2 3f92bf82673a48e4ac1404dfad9999ab--fe4fcf3b51054b92840333e100c0cd44 375d0dd18afa4d9d911dcb577f1ff9cc 3e01e6c95f9d45a787896f848d7afd83 RX(1.732*acos(phi)) e6fd11846757422d893d7b4e9c629540--3e01e6c95f9d45a787896f848d7afd83 529afea665e842758c728dd7b2629259 3 3e01e6c95f9d45a787896f848d7afd83--375d0dd18afa4d9d911dcb577f1ff9cc b1671dcd90e84510888b1002e8cbfc78 48e107a59fc64a238093fb845e1f0fa1 RX(2.0*acos(phi)) 529afea665e842758c728dd7b2629259--48e107a59fc64a238093fb845e1f0fa1 04f13a7f1ed04497ad1b5d56568fbb1e 4 48e107a59fc64a238093fb845e1f0fa1--b1671dcd90e84510888b1002e8cbfc78 47d92959b6e2465b95a6e66719c76c56 a7ac2e75e91643488491878ba1c9af2f RX(2.236*acos(phi)) 04f13a7f1ed04497ad1b5d56568fbb1e--a7ac2e75e91643488491878ba1c9af2f a7ac2e75e91643488491878ba1c9af2f--47d92959b6e2465b95a6e66719c76c56 <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 cacf773dd3944c53858eabc904408ac0 0 0876aade797346f39923dfd9ba86ff54 RX(1.0*phi*w\u2080) cacf773dd3944c53858eabc904408ac0--0876aade797346f39923dfd9ba86ff54 33562748217e487f85090797fd592fb7 1 355d198d63af4d1abd87b510dd3e9007 0876aade797346f39923dfd9ba86ff54--355d198d63af4d1abd87b510dd3e9007 b5579fc337db45cabf238f5dacd274a2 76424cc8efe246b6be931948be40aca8 RX(2.0*phi*w\u2081) 33562748217e487f85090797fd592fb7--76424cc8efe246b6be931948be40aca8 f3374448a0324fea820ab9684a0a349a 2 76424cc8efe246b6be931948be40aca8--b5579fc337db45cabf238f5dacd274a2 79fe502fe30e43b391345574ed8bd422 dfd4e2b84c5047a3a7d1737d9b4539cb RX(4.0*phi*w\u2082) f3374448a0324fea820ab9684a0a349a--dfd4e2b84c5047a3a7d1737d9b4539cb 0126582997174e0499387160a0090f41 3 dfd4e2b84c5047a3a7d1737d9b4539cb--79fe502fe30e43b391345574ed8bd422 ebb2df1c8d2f47b6ac4f8d3ec546d7a1 d3476b3a487549dda6da4ac6b3e21e59 RX(8.0*phi*w\u2083) 0126582997174e0499387160a0090f41--d3476b3a487549dda6da4ac6b3e21e59 de8691aecd834e0fb74a3a8471cf4dfe 4 d3476b3a487549dda6da4ac6b3e21e59--ebb2df1c8d2f47b6ac4f8d3ec546d7a1 008dba9276bb414087991b46f1ab4beb 58f1c6bf173d4a55b4661d677911fc38 RX(16.0*phi*w\u2084) de8691aecd834e0fb74a3a8471cf4dfe--58f1c6bf173d4a55b4661d677911fc38 58f1c6bf173d4a55b4661d677911fc38--008dba9276bb414087991b46f1ab4beb <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 c185553aee014f978aed234908dde394 0 885b3db8834d453bac19e8a53e8321b6 RY(80.0*acos(w\u2084*(0.667*x + 1.667))) c185553aee014f978aed234908dde394--885b3db8834d453bac19e8a53e8321b6 f6d7a5b6b64b412ba634858b2f19fe94 1 76e22c06110f432c9d14f5ee7d7fed26 885b3db8834d453bac19e8a53e8321b6--76e22c06110f432c9d14f5ee7d7fed26 a943cbf0ab0e4925a2bfed2ed3e883dd 5b441faa358d47d4b4040ea1e7113a88 RY(40.0*acos(w\u2083*(0.667*x + 1.667))) f6d7a5b6b64b412ba634858b2f19fe94--5b441faa358d47d4b4040ea1e7113a88 9e5abf302a8e40fa9f76807f1b16d63a 2 5b441faa358d47d4b4040ea1e7113a88--a943cbf0ab0e4925a2bfed2ed3e883dd f3cf118b39304e4cbe00a5115b65dd89 6498a0ee8ac84bc9865f12e20155ad25 RY(20.0*acos(w\u2082*(0.667*x + 1.667))) 9e5abf302a8e40fa9f76807f1b16d63a--6498a0ee8ac84bc9865f12e20155ad25 5c38f0b1d1c446ad98abecb59b59a41b 3 6498a0ee8ac84bc9865f12e20155ad25--f3cf118b39304e4cbe00a5115b65dd89 77623452b4ee462c93ba472cefb9aa91 bf0db1e5e81e479bbf9c7814e1ce9fcb RY(10.0*acos(w\u2081*(0.667*x + 1.667))) 5c38f0b1d1c446ad98abecb59b59a41b--bf0db1e5e81e479bbf9c7814e1ce9fcb 145bd20b05f0457b8ba5e7ba61930118 4 bf0db1e5e81e479bbf9c7814e1ce9fcb--77623452b4ee462c93ba472cefb9aa91 fddc4e9e9cfb452ca518d537f7d223c6 1e556ae8e9414ccb9bc2c1836b088a35 RY(5.0*acos(w\u2080*(0.667*x + 1.667))) 145bd20b05f0457b8ba5e7ba61930118--1e556ae8e9414ccb9bc2c1836b088a35 1e556ae8e9414ccb9bc2c1836b088a35--fddc4e9e9cfb452ca518d537f7d223c6"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 f216bb1cf13a4ab8bb246dc09f4dab7d 0 0f084dcc58fd40e0b307f614c89562e5 RX(theta\u2080) f216bb1cf13a4ab8bb246dc09f4dab7d--0f084dcc58fd40e0b307f614c89562e5 90ca9f6a44494e428dabdcdbef60cd62 1 bf09afb0052f43e0a6650358f2c9dba1 RY(theta\u2083) 0f084dcc58fd40e0b307f614c89562e5--bf09afb0052f43e0a6650358f2c9dba1 6e901d3027f14e78a9f489a7c3ecc2d4 RX(theta\u2086) bf09afb0052f43e0a6650358f2c9dba1--6e901d3027f14e78a9f489a7c3ecc2d4 f9b02f4024264b06b4defb699c89d198 6e901d3027f14e78a9f489a7c3ecc2d4--f9b02f4024264b06b4defb699c89d198 adcd69d591704530866c20b874843157 f9b02f4024264b06b4defb699c89d198--adcd69d591704530866c20b874843157 999548ac1fa74d8aba14dcd6d57f0b89 RX(theta\u2089) adcd69d591704530866c20b874843157--999548ac1fa74d8aba14dcd6d57f0b89 9d21af9c794047058b2624cdd9d11bc3 RY(theta\u2081\u2082) 999548ac1fa74d8aba14dcd6d57f0b89--9d21af9c794047058b2624cdd9d11bc3 524c7434444e497eaac6748c17838966 RX(theta\u2081\u2085) 9d21af9c794047058b2624cdd9d11bc3--524c7434444e497eaac6748c17838966 d45bb094f9f94fc19bd7dd880279e5fe 524c7434444e497eaac6748c17838966--d45bb094f9f94fc19bd7dd880279e5fe a8f5e6fc3fe8469c919593208a82a42a d45bb094f9f94fc19bd7dd880279e5fe--a8f5e6fc3fe8469c919593208a82a42a 0509f970c3ae4ddabcd95f90c5e6bbfd a8f5e6fc3fe8469c919593208a82a42a--0509f970c3ae4ddabcd95f90c5e6bbfd 79c1afb306b74f0db83d91af4183459b 153796fe5df14fe4a6cf1a7539176335 RX(theta\u2081) 90ca9f6a44494e428dabdcdbef60cd62--153796fe5df14fe4a6cf1a7539176335 3b0e07bf4b934378b4690fa6685f3136 2 ccca1589629a4b189453bfc00c46c57d RY(theta\u2084) 153796fe5df14fe4a6cf1a7539176335--ccca1589629a4b189453bfc00c46c57d 1a1cf859e3704962b9ed5ad1826971a7 RX(theta\u2087) ccca1589629a4b189453bfc00c46c57d--1a1cf859e3704962b9ed5ad1826971a7 bee7fed56f0644848f7ba3749b68ca9b X 1a1cf859e3704962b9ed5ad1826971a7--bee7fed56f0644848f7ba3749b68ca9b bee7fed56f0644848f7ba3749b68ca9b--f9b02f4024264b06b4defb699c89d198 0047421e7dd64000b9dc1027e2f809da bee7fed56f0644848f7ba3749b68ca9b--0047421e7dd64000b9dc1027e2f809da 9a21918948394fb5b102c2fbebf3fd34 RX(theta\u2081\u2080) 0047421e7dd64000b9dc1027e2f809da--9a21918948394fb5b102c2fbebf3fd34 6a64802e83a94939bab14aead486ece1 RY(theta\u2081\u2083) 9a21918948394fb5b102c2fbebf3fd34--6a64802e83a94939bab14aead486ece1 8b1d5e299f234f1fabb56b386d8d0507 RX(theta\u2081\u2086) 6a64802e83a94939bab14aead486ece1--8b1d5e299f234f1fabb56b386d8d0507 4f671b4f41fd422caa78e908b7dae8b6 X 8b1d5e299f234f1fabb56b386d8d0507--4f671b4f41fd422caa78e908b7dae8b6 4f671b4f41fd422caa78e908b7dae8b6--d45bb094f9f94fc19bd7dd880279e5fe b5823ee61b22467d9ecc79af9de0cc33 4f671b4f41fd422caa78e908b7dae8b6--b5823ee61b22467d9ecc79af9de0cc33 b5823ee61b22467d9ecc79af9de0cc33--79c1afb306b74f0db83d91af4183459b 0ff759f980da492cb074d4ce9f2ac56f 5cadb3d97e4b4ce09cd9f1a512dd9b02 RX(theta\u2082) 3b0e07bf4b934378b4690fa6685f3136--5cadb3d97e4b4ce09cd9f1a512dd9b02 64710232422242b4ad8e323a9efced26 RY(theta\u2085) 5cadb3d97e4b4ce09cd9f1a512dd9b02--64710232422242b4ad8e323a9efced26 1347634baa8f494db96a984fc55f6e1e RX(theta\u2088) 64710232422242b4ad8e323a9efced26--1347634baa8f494db96a984fc55f6e1e 212b656366d842a2b8da53cf48b15a1e 1347634baa8f494db96a984fc55f6e1e--212b656366d842a2b8da53cf48b15a1e b3d08d81aef2460ca5f137a55f05791c X 212b656366d842a2b8da53cf48b15a1e--b3d08d81aef2460ca5f137a55f05791c b3d08d81aef2460ca5f137a55f05791c--0047421e7dd64000b9dc1027e2f809da 998e39717fe648f3911acbc060ec7cb0 RX(theta\u2081\u2081) b3d08d81aef2460ca5f137a55f05791c--998e39717fe648f3911acbc060ec7cb0 6b63ccaf04d447dba046980381e361cb RY(theta\u2081\u2084) 998e39717fe648f3911acbc060ec7cb0--6b63ccaf04d447dba046980381e361cb 1592c2f91ca64a4db802e8985cb6f33a RX(theta\u2081\u2087) 6b63ccaf04d447dba046980381e361cb--1592c2f91ca64a4db802e8985cb6f33a bd22594e1e4643e4b44ebc1d6c6ca59a 1592c2f91ca64a4db802e8985cb6f33a--bd22594e1e4643e4b44ebc1d6c6ca59a 4b82e2ee23df4bf5939f79f03daf84ff X bd22594e1e4643e4b44ebc1d6c6ca59a--4b82e2ee23df4bf5939f79f03daf84ff 4b82e2ee23df4bf5939f79f03daf84ff--b5823ee61b22467d9ecc79af9de0cc33 4b82e2ee23df4bf5939f79f03daf84ff--0ff759f980da492cb074d4ce9f2ac56f <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 132790f2ca054aeab70e3e7e0d9da034 0 23493b1e49ad46e89a44e6cda932248c RX(phi\u2080) 132790f2ca054aeab70e3e7e0d9da034--23493b1e49ad46e89a44e6cda932248c a3f3d97b29194a59b8cdf8ac008cd960 1 5cbb2991dc6b48a8baa066b704c7f0b8 RY(phi\u2083) 23493b1e49ad46e89a44e6cda932248c--5cbb2991dc6b48a8baa066b704c7f0b8 568546f1a89a43cfbd62b4416586a744 RX(phi\u2086) 5cbb2991dc6b48a8baa066b704c7f0b8--568546f1a89a43cfbd62b4416586a744 e53f61e2975047e5a5652dff7423d4d8 568546f1a89a43cfbd62b4416586a744--e53f61e2975047e5a5652dff7423d4d8 136393cb5c23423ebf52c11932c89444 e53f61e2975047e5a5652dff7423d4d8--136393cb5c23423ebf52c11932c89444 aff4d189e56845669137a096580e8fe8 RX(phi\u2089) 136393cb5c23423ebf52c11932c89444--aff4d189e56845669137a096580e8fe8 c22e0b63b3c84722b3a6393d5755be24 RY(phi\u2081\u2082) aff4d189e56845669137a096580e8fe8--c22e0b63b3c84722b3a6393d5755be24 385ad0886089421a973e6b9c7d1d42b1 RX(phi\u2081\u2085) c22e0b63b3c84722b3a6393d5755be24--385ad0886089421a973e6b9c7d1d42b1 2cde1bdad94d485db6dfd7f6f597eaf0 385ad0886089421a973e6b9c7d1d42b1--2cde1bdad94d485db6dfd7f6f597eaf0 4066e94a95954fe5852650ecbcba539e 2cde1bdad94d485db6dfd7f6f597eaf0--4066e94a95954fe5852650ecbcba539e 0cda8776cd764b8781109ea474ed6e46 4066e94a95954fe5852650ecbcba539e--0cda8776cd764b8781109ea474ed6e46 5775b5e664d649a0b9c5bf5d9fa3d437 e677cd78244c43698c6173dae1e2f64e RX(phi\u2081) a3f3d97b29194a59b8cdf8ac008cd960--e677cd78244c43698c6173dae1e2f64e c23fa3de07ae4c459edef11ab4a03d8f 2 0d0600d5f7724e07ad39e3f1f53dbe63 RY(phi\u2084) e677cd78244c43698c6173dae1e2f64e--0d0600d5f7724e07ad39e3f1f53dbe63 0f06856a330b48dca0c68a8a14ca2330 RX(phi\u2087) 0d0600d5f7724e07ad39e3f1f53dbe63--0f06856a330b48dca0c68a8a14ca2330 33323ef5a1894644bbb7ad5f74c6f453 PHASE(phi_ent\u2080) 0f06856a330b48dca0c68a8a14ca2330--33323ef5a1894644bbb7ad5f74c6f453 33323ef5a1894644bbb7ad5f74c6f453--e53f61e2975047e5a5652dff7423d4d8 1798c28296e744809e45eee125f5864f 33323ef5a1894644bbb7ad5f74c6f453--1798c28296e744809e45eee125f5864f e0fdf855e7e544e4b6e630a34de63f90 RX(phi\u2081\u2080) 1798c28296e744809e45eee125f5864f--e0fdf855e7e544e4b6e630a34de63f90 5a5355f643d946ee98a56c7a2b6a0283 RY(phi\u2081\u2083) e0fdf855e7e544e4b6e630a34de63f90--5a5355f643d946ee98a56c7a2b6a0283 cb91dfa610294fb795ee6f37997c3148 RX(phi\u2081\u2086) 5a5355f643d946ee98a56c7a2b6a0283--cb91dfa610294fb795ee6f37997c3148 ddc7b2329f104ae68eb3fb198d1847d5 PHASE(phi_ent\u2082) cb91dfa610294fb795ee6f37997c3148--ddc7b2329f104ae68eb3fb198d1847d5 ddc7b2329f104ae68eb3fb198d1847d5--2cde1bdad94d485db6dfd7f6f597eaf0 30cfa347f7f44a4eab93b3c590e34fc6 ddc7b2329f104ae68eb3fb198d1847d5--30cfa347f7f44a4eab93b3c590e34fc6 30cfa347f7f44a4eab93b3c590e34fc6--5775b5e664d649a0b9c5bf5d9fa3d437 af56b4cc6497432383e447fa7b6f143a c67bb102e43e4294af63c158456d6a7b RX(phi\u2082) c23fa3de07ae4c459edef11ab4a03d8f--c67bb102e43e4294af63c158456d6a7b c0983f0a0c7f4c3cbbf15f53dcbc89b5 RY(phi\u2085) c67bb102e43e4294af63c158456d6a7b--c0983f0a0c7f4c3cbbf15f53dcbc89b5 2fc0af0d16b54008aadfcc36a9ad4882 RX(phi\u2088) c0983f0a0c7f4c3cbbf15f53dcbc89b5--2fc0af0d16b54008aadfcc36a9ad4882 5c1c7d70156746ef82d888528ce13f95 2fc0af0d16b54008aadfcc36a9ad4882--5c1c7d70156746ef82d888528ce13f95 061443d0008c4d07ad4e3feb245a2dba PHASE(phi_ent\u2081) 5c1c7d70156746ef82d888528ce13f95--061443d0008c4d07ad4e3feb245a2dba 061443d0008c4d07ad4e3feb245a2dba--1798c28296e744809e45eee125f5864f 6ac9123b5da24c508bcbf12cacb6dfac RX(phi\u2081\u2081) 061443d0008c4d07ad4e3feb245a2dba--6ac9123b5da24c508bcbf12cacb6dfac 0c99173bd34048369c59faee42500039 RY(phi\u2081\u2084) 6ac9123b5da24c508bcbf12cacb6dfac--0c99173bd34048369c59faee42500039 aa447066daea453dba2e8a8a9ff193c0 RX(phi\u2081\u2087) 0c99173bd34048369c59faee42500039--aa447066daea453dba2e8a8a9ff193c0 06ba8c21a30d4796a86cd4d03498bdd8 aa447066daea453dba2e8a8a9ff193c0--06ba8c21a30d4796a86cd4d03498bdd8 d601657444544069a8a0aebb64a79c7c PHASE(phi_ent\u2083) 06ba8c21a30d4796a86cd4d03498bdd8--d601657444544069a8a0aebb64a79c7c d601657444544069a8a0aebb64a79c7c--30cfa347f7f44a4eab93b3c590e34fc6 d601657444544069a8a0aebb64a79c7c--af56b4cc6497432383e447fa7b6f143a <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_32a2dea361eb4a2f8a4fdcaf3cd0b25d cluster_1d73a078015a44499e21f476532d7797 e84e3eeb35a443b3a9651a955b25b879 0 3e44a2fb941c4dcf800591db6d1cf4f1 RX(theta\u2080) e84e3eeb35a443b3a9651a955b25b879--3e44a2fb941c4dcf800591db6d1cf4f1 0cf6dbbeda1d4821a9b3c34ce6f3cf7c 1 afc913bac5a04c8199ca034267efa3ba RY(theta\u2083) 3e44a2fb941c4dcf800591db6d1cf4f1--afc913bac5a04c8199ca034267efa3ba 60be0d5b6ac64bb1b10e59261dcee30e RX(theta\u2086) afc913bac5a04c8199ca034267efa3ba--60be0d5b6ac64bb1b10e59261dcee30e aaa4a27b14e845a19376d63736ffdfe8 HamEvo 60be0d5b6ac64bb1b10e59261dcee30e--aaa4a27b14e845a19376d63736ffdfe8 15c8a4be4d5540f682ae10ab8a3bd4df RX(theta\u2089) aaa4a27b14e845a19376d63736ffdfe8--15c8a4be4d5540f682ae10ab8a3bd4df 737c969965f3439487f2dd5748940ffe RY(theta\u2081\u2082) 15c8a4be4d5540f682ae10ab8a3bd4df--737c969965f3439487f2dd5748940ffe 1180fafd4b9c4e43b2aa36a59fc1e919 RX(theta\u2081\u2085) 737c969965f3439487f2dd5748940ffe--1180fafd4b9c4e43b2aa36a59fc1e919 4776bb384e7947dda120095103c2a6fa HamEvo 1180fafd4b9c4e43b2aa36a59fc1e919--4776bb384e7947dda120095103c2a6fa b9b802602a4e4c8ba8bc472b3a608fec 4776bb384e7947dda120095103c2a6fa--b9b802602a4e4c8ba8bc472b3a608fec 04fb6d3934044df3b26f00d0ed3366f9 06beea953b884658abf87990fcf04d80 RX(theta\u2081) 0cf6dbbeda1d4821a9b3c34ce6f3cf7c--06beea953b884658abf87990fcf04d80 b905f1dbe7224e7a82dd741f7e0728c8 2 e7e84220449f43ee821b20e0b8420943 RY(theta\u2084) 06beea953b884658abf87990fcf04d80--e7e84220449f43ee821b20e0b8420943 0f1af4c9d0f64c40aa212509548429b8 RX(theta\u2087) e7e84220449f43ee821b20e0b8420943--0f1af4c9d0f64c40aa212509548429b8 bc29962a225d4f9998b784d31f716a76 t = theta_t\u2080 0f1af4c9d0f64c40aa212509548429b8--bc29962a225d4f9998b784d31f716a76 0c0b470a68f04c9d991c72d71ab4ba11 RX(theta\u2081\u2080) bc29962a225d4f9998b784d31f716a76--0c0b470a68f04c9d991c72d71ab4ba11 de6ef843eec44c1fb9d9037c5207e351 RY(theta\u2081\u2083) 0c0b470a68f04c9d991c72d71ab4ba11--de6ef843eec44c1fb9d9037c5207e351 6c9bf4ec046249479e12925fed5aed2c RX(theta\u2081\u2086) de6ef843eec44c1fb9d9037c5207e351--6c9bf4ec046249479e12925fed5aed2c 1035f4780d624cc6b684576974271799 t = theta_t\u2081 6c9bf4ec046249479e12925fed5aed2c--1035f4780d624cc6b684576974271799 1035f4780d624cc6b684576974271799--04fb6d3934044df3b26f00d0ed3366f9 6ada83d72e264612a8748397180999f9 5b9832cb433140dab0c3730770af4b9d RX(theta\u2082) b905f1dbe7224e7a82dd741f7e0728c8--5b9832cb433140dab0c3730770af4b9d 26dc66ecafaa4302940fe9eff522226f RY(theta\u2085) 5b9832cb433140dab0c3730770af4b9d--26dc66ecafaa4302940fe9eff522226f b373c5e0b51c459daafcc509d7c4e7d7 RX(theta\u2088) 26dc66ecafaa4302940fe9eff522226f--b373c5e0b51c459daafcc509d7c4e7d7 a0920df12ddc4e1faed61e577fc6c476 b373c5e0b51c459daafcc509d7c4e7d7--a0920df12ddc4e1faed61e577fc6c476 10c52240f9774f01bf48b592e6b0badc RX(theta\u2081\u2081) a0920df12ddc4e1faed61e577fc6c476--10c52240f9774f01bf48b592e6b0badc 969ea84fb5d94a25977a568e6a4d98ff RY(theta\u2081\u2084) 10c52240f9774f01bf48b592e6b0badc--969ea84fb5d94a25977a568e6a4d98ff b5827c58ad784bccb924e63a1a0908d7 RX(theta\u2081\u2087) 969ea84fb5d94a25977a568e6a4d98ff--b5827c58ad784bccb924e63a1a0908d7 897f7cfc5f0b4b958c2bbd0d10690678 b5827c58ad784bccb924e63a1a0908d7--897f7cfc5f0b4b958c2bbd0d10690678 897f7cfc5f0b4b958c2bbd0d10690678--6ada83d72e264612a8748397180999f9 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_1a9916179af044559489af9f56eca406 cluster_cd2dba71725a47abb7d7bd09b991e895 f0e7b4d001f647cc93e7582763871ecf 0 06ec1f4c2a9a4db18ae70fc6719432ce RX(theta\u2080) f0e7b4d001f647cc93e7582763871ecf--06ec1f4c2a9a4db18ae70fc6719432ce 10ccdb619689459e967b52fdd5778554 1 4fff3efab2004fdd9720cdd911f5f346 RY(theta\u2086) 06ec1f4c2a9a4db18ae70fc6719432ce--4fff3efab2004fdd9720cdd911f5f346 3b916e21e9de4266b099a827e3cd3179 RX(theta\u2081\u2082) 4fff3efab2004fdd9720cdd911f5f346--3b916e21e9de4266b099a827e3cd3179 c728f7f1da25432bab61fbcd8291b218 3b916e21e9de4266b099a827e3cd3179--c728f7f1da25432bab61fbcd8291b218 02849fe4490648268b070d6abbebf0d7 RX(theta\u2081\u2088) c728f7f1da25432bab61fbcd8291b218--02849fe4490648268b070d6abbebf0d7 a66f97f81ff6449db4067e3dea560528 RY(theta\u2082\u2084) 02849fe4490648268b070d6abbebf0d7--a66f97f81ff6449db4067e3dea560528 6f6341d0a36f4587b8d51c5e72a1b677 RX(theta\u2083\u2080) a66f97f81ff6449db4067e3dea560528--6f6341d0a36f4587b8d51c5e72a1b677 56cd7ddee5cb4ebf85fd58ca99269d2c 6f6341d0a36f4587b8d51c5e72a1b677--56cd7ddee5cb4ebf85fd58ca99269d2c 78a22b0711a842a49ba7d412cb592c0e 56cd7ddee5cb4ebf85fd58ca99269d2c--78a22b0711a842a49ba7d412cb592c0e 3cb22f902d9c42b1b21f4666b3885c3f 6930c4ffbb5b441c8eb262a8207a5638 RX(theta\u2081) 10ccdb619689459e967b52fdd5778554--6930c4ffbb5b441c8eb262a8207a5638 ae333d3352d849d0aee0ad55afd72e05 2 f7c181f9a16a48db86eb56b79c1eca91 RY(theta\u2087) 6930c4ffbb5b441c8eb262a8207a5638--f7c181f9a16a48db86eb56b79c1eca91 a9d008278c404af0861e7b3b05e9a661 RX(theta\u2081\u2083) f7c181f9a16a48db86eb56b79c1eca91--a9d008278c404af0861e7b3b05e9a661 48389d12e1004d67a148f4835a6232fb a9d008278c404af0861e7b3b05e9a661--48389d12e1004d67a148f4835a6232fb 58c8c803d5304dfc978b2b5735487355 RX(theta\u2081\u2089) 48389d12e1004d67a148f4835a6232fb--58c8c803d5304dfc978b2b5735487355 f24b7b31d1714a939b2f8d851b5318fb RY(theta\u2082\u2085) 58c8c803d5304dfc978b2b5735487355--f24b7b31d1714a939b2f8d851b5318fb 7f239b6d41f844cdbd03e782034872a3 RX(theta\u2083\u2081) f24b7b31d1714a939b2f8d851b5318fb--7f239b6d41f844cdbd03e782034872a3 c88b47abd1ff4276bb7e86588f367c88 7f239b6d41f844cdbd03e782034872a3--c88b47abd1ff4276bb7e86588f367c88 c88b47abd1ff4276bb7e86588f367c88--3cb22f902d9c42b1b21f4666b3885c3f dba45901dbf241e5b12907d0ad718ee1 7574d473768b496295cc86f6aa4cd66c RX(theta\u2082) ae333d3352d849d0aee0ad55afd72e05--7574d473768b496295cc86f6aa4cd66c 4bf2ce3cb29e49f288704b5f98cf2526 3 ac7dc0f7a7d64c989bf49a5349b870d8 RY(theta\u2088) 7574d473768b496295cc86f6aa4cd66c--ac7dc0f7a7d64c989bf49a5349b870d8 9e5443acd1364668aaf938fd1988971e RX(theta\u2081\u2084) ac7dc0f7a7d64c989bf49a5349b870d8--9e5443acd1364668aaf938fd1988971e 54bdeb788fbf406f86906380850e9e45 HamEvo 9e5443acd1364668aaf938fd1988971e--54bdeb788fbf406f86906380850e9e45 f585eb42d207408ebe9c91dbe08413e9 RX(theta\u2082\u2080) 54bdeb788fbf406f86906380850e9e45--f585eb42d207408ebe9c91dbe08413e9 8d426e99bfee4b9a8ab7871d377b39d4 RY(theta\u2082\u2086) f585eb42d207408ebe9c91dbe08413e9--8d426e99bfee4b9a8ab7871d377b39d4 680e626a97f047e48c41a7f722941bd3 RX(theta\u2083\u2082) 8d426e99bfee4b9a8ab7871d377b39d4--680e626a97f047e48c41a7f722941bd3 dc0b16022d054891b8afed2690644609 HamEvo 680e626a97f047e48c41a7f722941bd3--dc0b16022d054891b8afed2690644609 dc0b16022d054891b8afed2690644609--dba45901dbf241e5b12907d0ad718ee1 de99f62895334579b35de7ceef8c7e6e 30e506308c1f48b49b0053f8cf1cec96 RX(theta\u2083) 4bf2ce3cb29e49f288704b5f98cf2526--30e506308c1f48b49b0053f8cf1cec96 861359f7dd49478eb7ef454e8f9ce9a5 4 2e846808f0414dbd96ca6fe4a65e515e RY(theta\u2089) 30e506308c1f48b49b0053f8cf1cec96--2e846808f0414dbd96ca6fe4a65e515e 3a95e2413c7f4af7846e67cb0f8ccc6f RX(theta\u2081\u2085) 2e846808f0414dbd96ca6fe4a65e515e--3a95e2413c7f4af7846e67cb0f8ccc6f 105375a1407e4b1693411eba0fdfc2b3 t = theta_t\u2080 3a95e2413c7f4af7846e67cb0f8ccc6f--105375a1407e4b1693411eba0fdfc2b3 fbc899a0fcdb487c8347856e27eef176 RX(theta\u2082\u2081) 105375a1407e4b1693411eba0fdfc2b3--fbc899a0fcdb487c8347856e27eef176 abbe00c5dfda41fdb560765ff5a0d71a RY(theta\u2082\u2087) fbc899a0fcdb487c8347856e27eef176--abbe00c5dfda41fdb560765ff5a0d71a 5cafba00c04149d5b3fbea88c6c4e621 RX(theta\u2083\u2083) abbe00c5dfda41fdb560765ff5a0d71a--5cafba00c04149d5b3fbea88c6c4e621 3f758551edf4432f836ed996e5466f23 t = theta_t\u2081 5cafba00c04149d5b3fbea88c6c4e621--3f758551edf4432f836ed996e5466f23 3f758551edf4432f836ed996e5466f23--de99f62895334579b35de7ceef8c7e6e 75ccb25c13be4bf98d32ee7599575679 37c6b5e1c8d948a0b500a7600d73af62 RX(theta\u2084) 861359f7dd49478eb7ef454e8f9ce9a5--37c6b5e1c8d948a0b500a7600d73af62 e958c8fbeea142a696d7b557cf90763d 5 ba4037f191f74253978a94b0ef576347 RY(theta\u2081\u2080) 37c6b5e1c8d948a0b500a7600d73af62--ba4037f191f74253978a94b0ef576347 3e80bce156d941e499b076a921844ab7 RX(theta\u2081\u2086) ba4037f191f74253978a94b0ef576347--3e80bce156d941e499b076a921844ab7 7a26b902d0a6478c99d279ac024d431c 3e80bce156d941e499b076a921844ab7--7a26b902d0a6478c99d279ac024d431c 786fa2d5f12741c29485206537e8857a RX(theta\u2082\u2082) 7a26b902d0a6478c99d279ac024d431c--786fa2d5f12741c29485206537e8857a 327a53ad20bf458286fa82f7156b53ec RY(theta\u2082\u2088) 786fa2d5f12741c29485206537e8857a--327a53ad20bf458286fa82f7156b53ec a097a1d269bf4de4bba39b0cfea392a9 RX(theta\u2083\u2084) 327a53ad20bf458286fa82f7156b53ec--a097a1d269bf4de4bba39b0cfea392a9 4e3ad5371e3e4b30a87b3c52f492c3f4 a097a1d269bf4de4bba39b0cfea392a9--4e3ad5371e3e4b30a87b3c52f492c3f4 4e3ad5371e3e4b30a87b3c52f492c3f4--75ccb25c13be4bf98d32ee7599575679 957e00c8c1a24ee4b5994e1caf9a0565 679647f7c3e64d02b0e02175468812dc RX(theta\u2085) e958c8fbeea142a696d7b557cf90763d--679647f7c3e64d02b0e02175468812dc fe2a06a9a9324bfd89e16a18cc7b3e62 RY(theta\u2081\u2081) 679647f7c3e64d02b0e02175468812dc--fe2a06a9a9324bfd89e16a18cc7b3e62 01983c9006af4010b11e86dbafdb0c70 RX(theta\u2081\u2087) fe2a06a9a9324bfd89e16a18cc7b3e62--01983c9006af4010b11e86dbafdb0c70 058d4c9f14b9407fb33a8ea6209a3680 01983c9006af4010b11e86dbafdb0c70--058d4c9f14b9407fb33a8ea6209a3680 41608f413c09456e8acf8598f78c26c1 RX(theta\u2082\u2083) 058d4c9f14b9407fb33a8ea6209a3680--41608f413c09456e8acf8598f78c26c1 ba6e1e16c18d4ecc9b3720813f7fa3b0 RY(theta\u2082\u2089) 41608f413c09456e8acf8598f78c26c1--ba6e1e16c18d4ecc9b3720813f7fa3b0 f04c95a1d0e140bc89c816e9e98568e3 RX(theta\u2083\u2085) ba6e1e16c18d4ecc9b3720813f7fa3b0--f04c95a1d0e140bc89c816e9e98568e3 ba6bcac141744a498a4a19c365882f70 f04c95a1d0e140bc89c816e9e98568e3--ba6bcac141744a498a4a19c365882f70 ba6bcac141744a498a4a19c365882f70--957e00c8c1a24ee4b5994e1caf9a0565"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_ce3175735bf44eb0a54c146f010c430c BPMA-1 cluster_e3596b10c39c454b8af999883e202d79 BPMA-0 d14faee63b40469b8d18cc26e22dbf80 0 4b929124f4884d4e9abd73e123ed0ea2 RX(iia_\u03b1\u2080\u2080) d14faee63b40469b8d18cc26e22dbf80--4b929124f4884d4e9abd73e123ed0ea2 ed0897d6b2984e3db8c0012d9cfdfa92 1 554bd86e6e7c488f9053be911cfe4fa3 RY(iia_\u03b1\u2080\u2083) 4b929124f4884d4e9abd73e123ed0ea2--554bd86e6e7c488f9053be911cfe4fa3 40cbe02ac476404cbf86924f2010bb1f 554bd86e6e7c488f9053be911cfe4fa3--40cbe02ac476404cbf86924f2010bb1f 5d296e70d1da45adac954ad7b29f2dc6 40cbe02ac476404cbf86924f2010bb1f--5d296e70d1da45adac954ad7b29f2dc6 24043de3ffe340eda268b49a3e1ad34c RX(iia_\u03b3\u2080\u2080) 5d296e70d1da45adac954ad7b29f2dc6--24043de3ffe340eda268b49a3e1ad34c 66f7bd62b94b45b98baae28441d4b4b7 24043de3ffe340eda268b49a3e1ad34c--66f7bd62b94b45b98baae28441d4b4b7 6bb8e42f6d794d7687f1918edbe49c69 66f7bd62b94b45b98baae28441d4b4b7--6bb8e42f6d794d7687f1918edbe49c69 2c1c15f5bddc4536be716fad7680e1a8 RY(iia_\u03b2\u2080\u2083) 6bb8e42f6d794d7687f1918edbe49c69--2c1c15f5bddc4536be716fad7680e1a8 2f774d3a850d438c8e329eaa03be2b21 RX(iia_\u03b2\u2080\u2080) 2c1c15f5bddc4536be716fad7680e1a8--2f774d3a850d438c8e329eaa03be2b21 f2fc2018a28346cc835dcecae8747901 RX(iia_\u03b1\u2081\u2080) 2f774d3a850d438c8e329eaa03be2b21--f2fc2018a28346cc835dcecae8747901 0f46755f4b1a49aea768103c6615f259 RY(iia_\u03b1\u2081\u2083) f2fc2018a28346cc835dcecae8747901--0f46755f4b1a49aea768103c6615f259 2fd18d8a921148b4876a54de4455ba1a 0f46755f4b1a49aea768103c6615f259--2fd18d8a921148b4876a54de4455ba1a 20832c71093041128eccd8e042ad304a 2fd18d8a921148b4876a54de4455ba1a--20832c71093041128eccd8e042ad304a 2a57d26686ce4cb98d0feb3229b7673a RX(iia_\u03b3\u2081\u2080) 20832c71093041128eccd8e042ad304a--2a57d26686ce4cb98d0feb3229b7673a 6c7766190af84ff7bbd0d8ea1e387d1e 2a57d26686ce4cb98d0feb3229b7673a--6c7766190af84ff7bbd0d8ea1e387d1e 954b7cf90eb04826a5f87ef16662f5f9 6c7766190af84ff7bbd0d8ea1e387d1e--954b7cf90eb04826a5f87ef16662f5f9 2c4d9ad4508e4f70a0af3f5fd8f420bd RY(iia_\u03b2\u2081\u2083) 954b7cf90eb04826a5f87ef16662f5f9--2c4d9ad4508e4f70a0af3f5fd8f420bd edc107da54334f9195cc39100d562825 RX(iia_\u03b2\u2081\u2080) 2c4d9ad4508e4f70a0af3f5fd8f420bd--edc107da54334f9195cc39100d562825 80329be6fb0f4c4e882d6ca53a6c620f edc107da54334f9195cc39100d562825--80329be6fb0f4c4e882d6ca53a6c620f 48cb51a6264440518732ba4791afa45a 328ec120813641a6a86cc273d013acd1 RX(iia_\u03b1\u2080\u2081) ed0897d6b2984e3db8c0012d9cfdfa92--328ec120813641a6a86cc273d013acd1 9858b26b45e1442fa2c1d38d0d42e0df 2 1444d873232c413abcc400e939bc690a RY(iia_\u03b1\u2080\u2084) 328ec120813641a6a86cc273d013acd1--1444d873232c413abcc400e939bc690a 721efa8a5a924f1bad99e9b82f6e7a51 X 1444d873232c413abcc400e939bc690a--721efa8a5a924f1bad99e9b82f6e7a51 721efa8a5a924f1bad99e9b82f6e7a51--40cbe02ac476404cbf86924f2010bb1f 7a9c70a31dbf4de6a1c438d9f79c38e7 721efa8a5a924f1bad99e9b82f6e7a51--7a9c70a31dbf4de6a1c438d9f79c38e7 690e2fb0d3754e67a127545cf5d20e74 RX(iia_\u03b3\u2080\u2081) 7a9c70a31dbf4de6a1c438d9f79c38e7--690e2fb0d3754e67a127545cf5d20e74 aec87928ccaa4260b4608a422606dbc8 690e2fb0d3754e67a127545cf5d20e74--aec87928ccaa4260b4608a422606dbc8 58d6f5c2778d4761a77bb19c8fac0eec X aec87928ccaa4260b4608a422606dbc8--58d6f5c2778d4761a77bb19c8fac0eec 58d6f5c2778d4761a77bb19c8fac0eec--6bb8e42f6d794d7687f1918edbe49c69 3a8c24a2fd4545c8ba115a0bb034b47a RY(iia_\u03b2\u2080\u2084) 58d6f5c2778d4761a77bb19c8fac0eec--3a8c24a2fd4545c8ba115a0bb034b47a f4be912c610146ab99fb2ae1ea59a3ae RX(iia_\u03b2\u2080\u2081) 3a8c24a2fd4545c8ba115a0bb034b47a--f4be912c610146ab99fb2ae1ea59a3ae 4053f9fa58fd4aa8b0dd891d630f878e RX(iia_\u03b1\u2081\u2081) f4be912c610146ab99fb2ae1ea59a3ae--4053f9fa58fd4aa8b0dd891d630f878e 9c53e5e8be03444aae9f1005f8fbbfc3 RY(iia_\u03b1\u2081\u2084) 4053f9fa58fd4aa8b0dd891d630f878e--9c53e5e8be03444aae9f1005f8fbbfc3 3a445c820f09430a81e0eecfdcab4de6 X 9c53e5e8be03444aae9f1005f8fbbfc3--3a445c820f09430a81e0eecfdcab4de6 3a445c820f09430a81e0eecfdcab4de6--2fd18d8a921148b4876a54de4455ba1a 5fbb55aa5d4447ae8ceff02d093bf54b 3a445c820f09430a81e0eecfdcab4de6--5fbb55aa5d4447ae8ceff02d093bf54b dfeb468974f740d3899dd4b211f8a8b4 RX(iia_\u03b3\u2081\u2081) 5fbb55aa5d4447ae8ceff02d093bf54b--dfeb468974f740d3899dd4b211f8a8b4 9266a21b7d084244b2d958dab6d5dac5 dfeb468974f740d3899dd4b211f8a8b4--9266a21b7d084244b2d958dab6d5dac5 2738a7e12e30494fa7637eb99fe6cc85 X 9266a21b7d084244b2d958dab6d5dac5--2738a7e12e30494fa7637eb99fe6cc85 2738a7e12e30494fa7637eb99fe6cc85--954b7cf90eb04826a5f87ef16662f5f9 90e97e11932a48a9b73781d3438d2506 RY(iia_\u03b2\u2081\u2084) 2738a7e12e30494fa7637eb99fe6cc85--90e97e11932a48a9b73781d3438d2506 b61379a8521d432c99b64445c5fe2970 RX(iia_\u03b2\u2081\u2081) 90e97e11932a48a9b73781d3438d2506--b61379a8521d432c99b64445c5fe2970 b61379a8521d432c99b64445c5fe2970--48cb51a6264440518732ba4791afa45a e63fd7d0374c40f1b6d1e9633e143f82 cfaeb882dae04f1990d0ff5f76f045c8 RX(iia_\u03b1\u2080\u2082) 9858b26b45e1442fa2c1d38d0d42e0df--cfaeb882dae04f1990d0ff5f76f045c8 15f85a5ce2cf46cb93af4bb14800291a RY(iia_\u03b1\u2080\u2085) cfaeb882dae04f1990d0ff5f76f045c8--15f85a5ce2cf46cb93af4bb14800291a d1fb7332dcc044c4b3a71930fafd8292 15f85a5ce2cf46cb93af4bb14800291a--d1fb7332dcc044c4b3a71930fafd8292 4d40884046fc416980d83fdc52f362d2 X d1fb7332dcc044c4b3a71930fafd8292--4d40884046fc416980d83fdc52f362d2 4d40884046fc416980d83fdc52f362d2--7a9c70a31dbf4de6a1c438d9f79c38e7 5d21a9ba293d45d6892854d384e272ba RX(iia_\u03b3\u2080\u2082) 4d40884046fc416980d83fdc52f362d2--5d21a9ba293d45d6892854d384e272ba 33dd11e1009f4eb9baab38a4abf1f41d X 5d21a9ba293d45d6892854d384e272ba--33dd11e1009f4eb9baab38a4abf1f41d 33dd11e1009f4eb9baab38a4abf1f41d--aec87928ccaa4260b4608a422606dbc8 0dc20dbad71b4e21858b58fc9cd2f37e 33dd11e1009f4eb9baab38a4abf1f41d--0dc20dbad71b4e21858b58fc9cd2f37e 945304a1d03f45db9bcee2ebeadcd40a RY(iia_\u03b2\u2080\u2085) 0dc20dbad71b4e21858b58fc9cd2f37e--945304a1d03f45db9bcee2ebeadcd40a 573f1ffb23b644efb5d7b52610e91373 RX(iia_\u03b2\u2080\u2082) 945304a1d03f45db9bcee2ebeadcd40a--573f1ffb23b644efb5d7b52610e91373 d1b7db0090234d498cf67af7fe7fd57a RX(iia_\u03b1\u2081\u2082) 573f1ffb23b644efb5d7b52610e91373--d1b7db0090234d498cf67af7fe7fd57a 1281b999b25c4361b97144527d499585 RY(iia_\u03b1\u2081\u2085) d1b7db0090234d498cf67af7fe7fd57a--1281b999b25c4361b97144527d499585 425e65528a7146b3b90aca686c2944cd 1281b999b25c4361b97144527d499585--425e65528a7146b3b90aca686c2944cd d7f9c9f5a9f14681ba09773fb0dbaad8 X 425e65528a7146b3b90aca686c2944cd--d7f9c9f5a9f14681ba09773fb0dbaad8 d7f9c9f5a9f14681ba09773fb0dbaad8--5fbb55aa5d4447ae8ceff02d093bf54b 17ab3f2ee5a24597b13b8447d39bedab RX(iia_\u03b3\u2081\u2082) d7f9c9f5a9f14681ba09773fb0dbaad8--17ab3f2ee5a24597b13b8447d39bedab 2432a98d2f2b4dc8b45c7c465946f4d9 X 17ab3f2ee5a24597b13b8447d39bedab--2432a98d2f2b4dc8b45c7c465946f4d9 2432a98d2f2b4dc8b45c7c465946f4d9--9266a21b7d084244b2d958dab6d5dac5 93b4d323db0d40fdaabfff0d94fa3c02 2432a98d2f2b4dc8b45c7c465946f4d9--93b4d323db0d40fdaabfff0d94fa3c02 abd9c297ba4a4a538a0f583f926b2f55 RY(iia_\u03b2\u2081\u2085) 93b4d323db0d40fdaabfff0d94fa3c02--abd9c297ba4a4a538a0f583f926b2f55 0f75c23a3a1c4d058e45deae241c2abf RX(iia_\u03b2\u2081\u2082) abd9c297ba4a4a538a0f583f926b2f55--0f75c23a3a1c4d058e45deae241c2abf 0f75c23a3a1c4d058e45deae241c2abf--e63fd7d0374c40f1b6d1e9633e143f82"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0126]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9760]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 228faa97-a79f-465c-a260-7d910c529220, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': c287f59a-5b79-4298-bbc0-845be8fc28a8, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0297d664-b1a3-4f39-be4e-b1ff3ce33720, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': d4e06a9b-f3a8-4c0e-a795-d1bec0f707d8, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ebbc0fb6-0b15-493f-bb80-df3eae9552b0, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': e480e2fa-06ab-48b6-a586-9bd7561a2aa5, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 03955068-9f69-4839-8859-3f080f83df5e, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 8d69b205-7ad8-436d-9892-ae58b54efb88, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 20caaad5-da3c-43c5-bfe2-5e95ae46384e, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 72f3ca15-a2fc-4ccf-9d6c-1811af219055, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 694e5293-f1bb-41d6-85c4-11e89e596034, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_4: tensor([0.4681], requires_grad=True)\n  theta_6: tensor([0.3384], requires_grad=True)\n  theta_3: tensor([0.9100], requires_grad=True)\n  theta_7: tensor([0.5714], requires_grad=True)\n  theta_1: tensor([0.0567], requires_grad=True)\n  theta_5: tensor([0.1901], requires_grad=True)\n  theta_2: tensor([0.0286], requires_grad=True)\n  theta_8: tensor([0.4730], requires_grad=True)\n  theta_0: tensor([0.2443], requires_grad=True)\n}\nembedded = {\n  228faa97-a79f-465c-a260-7d910c529220: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  c287f59a-5b79-4298-bbc0-845be8fc28a8: tensor([2., 2.])\n  0297d664-b1a3-4f39-be4e-b1ff3ce33720: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  d4e06a9b-f3a8-4c0e-a795-d1bec0f707d8: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  ebbc0fb6-0b15-493f-bb80-df3eae9552b0: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  e480e2fa-06ab-48b6-a586-9bd7561a2aa5: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  03955068-9f69-4839-8859-3f080f83df5e: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  8d69b205-7ad8-436d-9892-ae58b54efb88: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  20caaad5-da3c-43c5-bfe2-5e95ae46384e: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  72f3ca15-a2fc-4ccf-9d6c-1811af219055: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  694e5293-f1bb-41d6-85c4-11e89e596034: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.4681], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.3384], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.9100], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0567], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.2443], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1901], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.5714], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.0286], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.4730], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j],\n        [ 0.1024-0.2150j, -0.0442-0.0478j,  0.1181-0.0056j,  0.1793+0.3932j,\n         -0.6275-0.4645j, -0.1817+0.1123j,  0.0725+0.0232j,  0.0196+0.2776j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 250, '100': 190, '011': 145, '111': 140, '001': 88, '110': 67, '101': 62, '010': 58})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(228faa97-a79f-465c-a260-7d910c529220)-C----------------------------------------Rx(0297d664-b1a3-4f39-be4e-b1ff3ce33720)-Ry(e480e2fa-06ab-48b6-a586-9bd7561a2aa5)-Rx(20caaad5-da3c-43c5-bfe2-5e95ae46384e)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(c287f59a-5b79-4298-bbc0-845be8fc28a8)-X----------------------------------------Rx(d4e06a9b-f3a8-4c0e-a795-d1bec0f707d8)-Ry(03955068-9f69-4839-8859-3f080f83df5e)-Rx(72f3ca15-a2fc-4ccf-9d6c-1811af219055)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(ebbc0fb6-0b15-493f-bb80-df3eae9552b0)-Ry(8d69b205-7ad8-436d-9892-ae58b54efb88)-Rx(694e5293-f1bb-41d6-85c4-11e89e596034)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [0297d664-b1a3-4f39-be4e-b1ff3ce33720, 03955068-9f69-4839-8859-3f080f83df5e, 20caaad5-da3c-43c5-bfe2-5e95ae46384e, 228faa97-a79f-465c-a260-7d910c529220, 694e5293-f1bb-41d6-85c4-11e89e596034, 72f3ca15-a2fc-4ccf-9d6c-1811af219055, 8d69b205-7ad8-436d-9892-ae58b54efb88, c287f59a-5b79-4298-bbc0-845be8fc28a8, d4e06a9b-f3a8-4c0e-a795-d1bec0f707d8, e480e2fa-06ab-48b6-a586-9bd7561a2aa5, ebbc0fb6-0b15-493f-bb80-df3eae9552b0].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(1.23)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.24)-DEPO(0.1)-Ry(0.91)-DEPO(0.1)-Rx(0.34)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.83)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.06)-DEPO(0.1)-Ry(0.47)-DEPO(0.1)-Rx(0.57)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.19)-DEPO(0.1)-Rx(0.47)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 27c4b8e81d3545bb8aa3d461c51cc45c 0 6c69e6303c3d44e897eb8caf51f55824 X 27c4b8e81d3545bb8aa3d461c51cc45c--6c69e6303c3d44e897eb8caf51f55824 2a7d2b196b4643a7917989233e5ba74a 1 37f40327a5e04be492d6e1eca498b01a 6c69e6303c3d44e897eb8caf51f55824--37f40327a5e04be492d6e1eca498b01a 69783fb32ada40f3a0c3de26b366ab16 febf73fbb7704085a02b1eac72cb2ecf Y 2a7d2b196b4643a7917989233e5ba74a--febf73fbb7704085a02b1eac72cb2ecf febf73fbb7704085a02b1eac72cb2ecf--69783fb32ada40f3a0c3de26b366ab16 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 b1ec0c5ac2434be986243c20e6122422 0 8f6aef5f8e3b4a05b013c4e8cf42b1c6 RX(0.5) b1ec0c5ac2434be986243c20e6122422--8f6aef5f8e3b4a05b013c4e8cf42b1c6 f028917b67c2409b81da3c7cf7469a9c 8f6aef5f8e3b4a05b013c4e8cf42b1c6--f028917b67c2409b81da3c7cf7469a9c <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 9597fd4c45fc4efea46d965eafd4279b 0 2f9614c538ac4d3eaf4bcd3332ba07cb 9597fd4c45fc4efea46d965eafd4279b--2f9614c538ac4d3eaf4bcd3332ba07cb 3d16b8144ea9421f85658cadb863a85f 1 96a20306e43f4349979aa5aea16e7cb2 2f9614c538ac4d3eaf4bcd3332ba07cb--96a20306e43f4349979aa5aea16e7cb2 64e1f59e156644afa864eea0eab3aff8 aa0aaebcf4e24f0bba202c7210daf802 X 3d16b8144ea9421f85658cadb863a85f--aa0aaebcf4e24f0bba202c7210daf802 aa0aaebcf4e24f0bba202c7210daf802--2f9614c538ac4d3eaf4bcd3332ba07cb aa0aaebcf4e24f0bba202c7210daf802--64e1f59e156644afa864eea0eab3aff8 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 bac22a57564942a5839f0f25037bed24 0 a0e8b0f0adcf4ae582403d874cd0a741 X bac22a57564942a5839f0f25037bed24--a0e8b0f0adcf4ae582403d874cd0a741 86fcb7f858654559ab263d118434650a X a0e8b0f0adcf4ae582403d874cd0a741--86fcb7f858654559ab263d118434650a d9e8e79d74ec4fc6b51479c853dfc4b8 86fcb7f858654559ab263d118434650a--d9e8e79d74ec4fc6b51479c853dfc4b8 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 6a8bf7fd1df648bea9da30d9f5cf58a9 0 eef88cf2ea25453db346521fc24610c5 X 6a8bf7fd1df648bea9da30d9f5cf58a9--eef88cf2ea25453db346521fc24610c5 60133b8de1ef4890a9e9b2320a64f7ae 1 beb302e9ed8d460e95d9018bd2fc1ca3 eef88cf2ea25453db346521fc24610c5--beb302e9ed8d460e95d9018bd2fc1ca3 e7103985f577417494eb68b23b03998a beb302e9ed8d460e95d9018bd2fc1ca3--e7103985f577417494eb68b23b03998a c4b0da5bd591455a88b509ecbae4d10e 524da1efd7a14db59281b3c1e016935b 60133b8de1ef4890a9e9b2320a64f7ae--524da1efd7a14db59281b3c1e016935b 6f4fee5902e24e9da1a5042205c07459 X 524da1efd7a14db59281b3c1e016935b--6f4fee5902e24e9da1a5042205c07459 6f4fee5902e24e9da1a5042205c07459--c4b0da5bd591455a88b509ecbae4d10e </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 26d83d638d724c1a980b9b38f330be7a 0 494bfb168df8479096104b65b32518f1 X 26d83d638d724c1a980b9b38f330be7a--494bfb168df8479096104b65b32518f1 2d82117415e545beba650419386c3a84 1 5c1a71d60a8b46c08a05a55b8fe54d44 494bfb168df8479096104b65b32518f1--5c1a71d60a8b46c08a05a55b8fe54d44 bceb0a102dda401990f7833f0e680e96 39bed7f29e4143b4a742273f9d504114 X 2d82117415e545beba650419386c3a84--39bed7f29e4143b4a742273f9d504114 39bed7f29e4143b4a742273f9d504114--bceb0a102dda401990f7833f0e680e96 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_5b6c38bd6de24af981d2a99735f4fdc6 subblock cluster_89be04ea15744cd3bc23c2b89b46e05b subblock 3ea76a2bfba7434bbcb8785257bdd321 0 a86f45ca5bd244549fc772c155024ab2 X 3ea76a2bfba7434bbcb8785257bdd321--a86f45ca5bd244549fc772c155024ab2 83b87a79234845a7a3534e30d7749180 1 f3918dc416f045d195a3db7ea50ca60d X a86f45ca5bd244549fc772c155024ab2--f3918dc416f045d195a3db7ea50ca60d 6d1b24bd5212410c9747ccf9a3d222b0 f3918dc416f045d195a3db7ea50ca60d--6d1b24bd5212410c9747ccf9a3d222b0 b8802f4ce3354125a32d49999c68fc94 812dd5518fc548fa865a6fa37cbc49bf Y 83b87a79234845a7a3534e30d7749180--812dd5518fc548fa865a6fa37cbc49bf d0a710ed5c0d42259dd48f3b1afe0437 2 58fb09fb3c624ac6a111db37e707661f Y 812dd5518fc548fa865a6fa37cbc49bf--58fb09fb3c624ac6a111db37e707661f 58fb09fb3c624ac6a111db37e707661f--b8802f4ce3354125a32d49999c68fc94 3d4e2f3136a54c32a2d0c2720c5852dd 30ac548164fe43a98a43c11966d58d3d d0a710ed5c0d42259dd48f3b1afe0437--30ac548164fe43a98a43c11966d58d3d 1fad7b5e95e64990a35dfa22bb11e5bd 3 85d67e2e6da64c2998010a5c623ac771 30ac548164fe43a98a43c11966d58d3d--85d67e2e6da64c2998010a5c623ac771 85d67e2e6da64c2998010a5c623ac771--3d4e2f3136a54c32a2d0c2720c5852dd 95a8f3600c284250a4818b387f59362c bedabf7151af4986a927f06ce2ad80b5 1fad7b5e95e64990a35dfa22bb11e5bd--bedabf7151af4986a927f06ce2ad80b5 60a446689e854e4b9d83dabaa713043b 4 85ddb71f9aa543f4a21f0e73fe3e9bb3 bedabf7151af4986a927f06ce2ad80b5--85ddb71f9aa543f4a21f0e73fe3e9bb3 85ddb71f9aa543f4a21f0e73fe3e9bb3--95a8f3600c284250a4818b387f59362c 4ab651b30cfb4a62b14d6b439c02cf45 942d582c2525477b91dd90cfc031b62e X 60a446689e854e4b9d83dabaa713043b--942d582c2525477b91dd90cfc031b62e 942d582c2525477b91dd90cfc031b62e--bedabf7151af4986a927f06ce2ad80b5 ab9f39bd6af74709ae611519f9a14f72 X 942d582c2525477b91dd90cfc031b62e--ab9f39bd6af74709ae611519f9a14f72 ab9f39bd6af74709ae611519f9a14f72--85ddb71f9aa543f4a21f0e73fe3e9bb3 ab9f39bd6af74709ae611519f9a14f72--4ab651b30cfb4a62b14d6b439c02cf45"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 262, '00': 249, '10': 248, '01': 241})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'100': 30, '010': 27, '000': 24, '110': 19})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import numpy as np\nfrom torch import tensor\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea, PI\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": tensor([PI / 2, PI])}\nvalues_ket = {\"psi\": tensor([PI / 2, PI])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2568, 0.0030],\n        [0.0140, 0.0074]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from qadence import RX, run, PI\n\n# Let's use a torch type.\nblock = RX(0, PI)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9048+0.0000j, 0.0000-0.4258j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.9633+0.0000j, 0.0000-0.2685j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.8746+0.0000j, 0.3181+0.0000j, 0.0000-0.3439j, 0.0000-0.1251j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_7e0685147e6f420197a29a0f8152c889 [* 2] cluster_75f02c65b29b4e188e9b9ec1e7d59556 Rotations b55d71e8c2c546da83ab6892bf1b2cc4 0 c4db64c86f5e46629ba7c4fcc96f087a RX(phi/theta) b55d71e8c2c546da83ab6892bf1b2cc4--c4db64c86f5e46629ba7c4fcc96f087a 1e027fb1df7f4a3e98797ae9896e0129 1 65192721b04a4211a20ecd76888d68fb RX(phi) c4db64c86f5e46629ba7c4fcc96f087a--65192721b04a4211a20ecd76888d68fb 6b4dc90cce124b7aaf0c69421a6b5d17 RX(phi) 65192721b04a4211a20ecd76888d68fb--6b4dc90cce124b7aaf0c69421a6b5d17 278a1edb416e49b2aa26cad5a3cec1dd RX(phi + theta) 6b4dc90cce124b7aaf0c69421a6b5d17--278a1edb416e49b2aa26cad5a3cec1dd 62ad636cdd964b1a8626d648ff524225 278a1edb416e49b2aa26cad5a3cec1dd--62ad636cdd964b1a8626d648ff524225 7b9a9e8ba9c1434fba892288c1993e55 62ad636cdd964b1a8626d648ff524225--7b9a9e8ba9c1434fba892288c1993e55 0ac3d1fcf3814ab696482469cc8a3b53 Z 7b9a9e8ba9c1434fba892288c1993e55--0ac3d1fcf3814ab696482469cc8a3b53 ab5ac52f616e4777b83af3b664f54156 0ac3d1fcf3814ab696482469cc8a3b53--ab5ac52f616e4777b83af3b664f54156 69d7ce3fc22b4a1a84fd615474d1c53d 677c9afd49f2466da9cbd66cf6689f06 RY(2*theta) 1e027fb1df7f4a3e98797ae9896e0129--677c9afd49f2466da9cbd66cf6689f06 da9f4d808c244e088a6998f7a634fa90 2 ced5fcae0115440a92c614456e57c8ae RY(theta) 677c9afd49f2466da9cbd66cf6689f06--ced5fcae0115440a92c614456e57c8ae 979137e9d3a14ff689359ca6b316dd5b RY(theta) ced5fcae0115440a92c614456e57c8ae--979137e9d3a14ff689359ca6b316dd5b 28dc4e2896634898bb389c2325673027 RY(theta**2) 979137e9d3a14ff689359ca6b316dd5b--28dc4e2896634898bb389c2325673027 07a5b89c9bb743f4849785211b2a67dc X 28dc4e2896634898bb389c2325673027--07a5b89c9bb743f4849785211b2a67dc 07a5b89c9bb743f4849785211b2a67dc--62ad636cdd964b1a8626d648ff524225 0bb7461f70b14b5f8705ca6dde7318ea 07a5b89c9bb743f4849785211b2a67dc--0bb7461f70b14b5f8705ca6dde7318ea 04870bf157214793b9703d278344ca76 Z 0bb7461f70b14b5f8705ca6dde7318ea--04870bf157214793b9703d278344ca76 04870bf157214793b9703d278344ca76--69d7ce3fc22b4a1a84fd615474d1c53d 6c42442c30e74e499c0b0b9beab7e7dc 33b221d435b844fe87e94a011bdcc21e RZ(cos(phi)) da9f4d808c244e088a6998f7a634fa90--33b221d435b844fe87e94a011bdcc21e 5f7292244a384bbf9fef03c01a3752f9 RZ(phi) 33b221d435b844fe87e94a011bdcc21e--5f7292244a384bbf9fef03c01a3752f9 baddaeb198f64e99aac77d8130e423b2 RZ(phi) 5f7292244a384bbf9fef03c01a3752f9--baddaeb198f64e99aac77d8130e423b2 b61f4b57e21048989016798e5036fbb0 RZ(cos(phi)) baddaeb198f64e99aac77d8130e423b2--b61f4b57e21048989016798e5036fbb0 95d3fe195a6b428e969908effd4df986 b61f4b57e21048989016798e5036fbb0--95d3fe195a6b428e969908effd4df986 a15f3cb90eee4027a862d61d80334dc0 X 95d3fe195a6b428e969908effd4df986--a15f3cb90eee4027a862d61d80334dc0 a15f3cb90eee4027a862d61d80334dc0--0bb7461f70b14b5f8705ca6dde7318ea 414992d59f3d4a3aaae9b36571ad49db Z a15f3cb90eee4027a862d61d80334dc0--414992d59f3d4a3aaae9b36571ad49db 414992d59f3d4a3aaae9b36571ad49db--6c42442c30e74e499c0b0b9beab7e7dc <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.6122]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.8583+0.0000j, 0.3487+0.0000j, 0.0000-0.3487j, 0.0000-0.1417j],\n        [0.9034+0.0000j, 0.2954+0.0000j, 0.0000-0.2954j, 0.0000-0.0966j],\n        [0.6968+0.0000j, 0.4597+0.0000j, 0.0000-0.4597j, 0.0000-0.3032j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 9931952e87054c57a7c4f9b569cfe106 0 f2ded4438ccd4d43b71e93dfaff62595 RX(theta\u2080) 9931952e87054c57a7c4f9b569cfe106--f2ded4438ccd4d43b71e93dfaff62595 f18e26a6a9a346aaaf6499d4773b2d85 1 5adc547418c04afcb4dc35fef624f138 RY(theta\u2084) f2ded4438ccd4d43b71e93dfaff62595--5adc547418c04afcb4dc35fef624f138 1dc4d56c0d6049629a1a3b8feb3b7232 RX(theta\u2088) 5adc547418c04afcb4dc35fef624f138--1dc4d56c0d6049629a1a3b8feb3b7232 7a5f559bc139413f8dadbc493a94feb8 1dc4d56c0d6049629a1a3b8feb3b7232--7a5f559bc139413f8dadbc493a94feb8 019a96c19fed454cb49808c6e6d66f8c 7a5f559bc139413f8dadbc493a94feb8--019a96c19fed454cb49808c6e6d66f8c 509dac88a5c545ea9c571be98c5ffda0 RX(theta\u2081\u2082) 019a96c19fed454cb49808c6e6d66f8c--509dac88a5c545ea9c571be98c5ffda0 9730bb1ebde64a2e90693b2fc099a029 RY(theta\u2081\u2086) 509dac88a5c545ea9c571be98c5ffda0--9730bb1ebde64a2e90693b2fc099a029 a34e89f97fb84f1898fdfd97b5cf3fc4 RX(theta\u2082\u2080) 9730bb1ebde64a2e90693b2fc099a029--a34e89f97fb84f1898fdfd97b5cf3fc4 9d926fac452444e49393377a39d4dac6 a34e89f97fb84f1898fdfd97b5cf3fc4--9d926fac452444e49393377a39d4dac6 a257d7831e0940bdb4538cf3fdb45e24 9d926fac452444e49393377a39d4dac6--a257d7831e0940bdb4538cf3fdb45e24 bac708edfd50452ba2ab488bedf57148 a257d7831e0940bdb4538cf3fdb45e24--bac708edfd50452ba2ab488bedf57148 90010270a52e4d19a8947852309f7140 3f1f7b33c6b543eeb6fa504cb6d1834e RX(theta\u2081) f18e26a6a9a346aaaf6499d4773b2d85--3f1f7b33c6b543eeb6fa504cb6d1834e f14ea5ef97604c9ca90ea57ae4d00051 2 2978cb17c8b9456e8d73c2671811bdda RY(theta\u2085) 3f1f7b33c6b543eeb6fa504cb6d1834e--2978cb17c8b9456e8d73c2671811bdda 5192aecbdece4e9cac2ecd97b5f11a38 RX(theta\u2089) 2978cb17c8b9456e8d73c2671811bdda--5192aecbdece4e9cac2ecd97b5f11a38 dd69d0c9391b4043ab0c5e3c06bafacd X 5192aecbdece4e9cac2ecd97b5f11a38--dd69d0c9391b4043ab0c5e3c06bafacd dd69d0c9391b4043ab0c5e3c06bafacd--7a5f559bc139413f8dadbc493a94feb8 d81d47d117fc4253a48a00ea05de3773 dd69d0c9391b4043ab0c5e3c06bafacd--d81d47d117fc4253a48a00ea05de3773 7656edecff964f75b321982bf53da284 RX(theta\u2081\u2083) d81d47d117fc4253a48a00ea05de3773--7656edecff964f75b321982bf53da284 cb33116ea1e2477a82b939165e8e13bc RY(theta\u2081\u2087) 7656edecff964f75b321982bf53da284--cb33116ea1e2477a82b939165e8e13bc dd655774334345069fef2893ded3541b RX(theta\u2082\u2081) cb33116ea1e2477a82b939165e8e13bc--dd655774334345069fef2893ded3541b 430de1f17b4045bfb3e45fdca3682e56 X dd655774334345069fef2893ded3541b--430de1f17b4045bfb3e45fdca3682e56 430de1f17b4045bfb3e45fdca3682e56--9d926fac452444e49393377a39d4dac6 5f82757ec7e5411881a8d3812cd73507 430de1f17b4045bfb3e45fdca3682e56--5f82757ec7e5411881a8d3812cd73507 5f82757ec7e5411881a8d3812cd73507--90010270a52e4d19a8947852309f7140 ca85c01b42c945d3b56b7f9b3c1c8b57 32033e0b58e1470fb7179817bc89f80b RX(theta\u2082) f14ea5ef97604c9ca90ea57ae4d00051--32033e0b58e1470fb7179817bc89f80b 5b2bbf8ffd494cb882c6c7c6a65eea8b 3 9d66be8b5824402090ddd43ca385190a RY(theta\u2086) 32033e0b58e1470fb7179817bc89f80b--9d66be8b5824402090ddd43ca385190a c7b3eaf05bc74606b3db475eb554891f RX(theta\u2081\u2080) 9d66be8b5824402090ddd43ca385190a--c7b3eaf05bc74606b3db475eb554891f e72da705f5414b65b2d6f59514a122c8 c7b3eaf05bc74606b3db475eb554891f--e72da705f5414b65b2d6f59514a122c8 27b7de0997d34829a140d94df8feb14c X e72da705f5414b65b2d6f59514a122c8--27b7de0997d34829a140d94df8feb14c 27b7de0997d34829a140d94df8feb14c--d81d47d117fc4253a48a00ea05de3773 26a814b3cc71490881c497b52c71101a RX(theta\u2081\u2084) 27b7de0997d34829a140d94df8feb14c--26a814b3cc71490881c497b52c71101a 558d3a7458e1472fa165d16b69812cee RY(theta\u2081\u2088) 26a814b3cc71490881c497b52c71101a--558d3a7458e1472fa165d16b69812cee ae578d814f41481bbe09a68b6717fe77 RX(theta\u2082\u2082) 558d3a7458e1472fa165d16b69812cee--ae578d814f41481bbe09a68b6717fe77 efc0626507764c44a98c7e3ffc0a0d00 ae578d814f41481bbe09a68b6717fe77--efc0626507764c44a98c7e3ffc0a0d00 f409798a677d40cea876d03e4f3069fa X efc0626507764c44a98c7e3ffc0a0d00--f409798a677d40cea876d03e4f3069fa f409798a677d40cea876d03e4f3069fa--5f82757ec7e5411881a8d3812cd73507 f409798a677d40cea876d03e4f3069fa--ca85c01b42c945d3b56b7f9b3c1c8b57 1753c7fc1ab24cb3a7e7675f1bb3de7f 19a47156548d433d86ffed94268d8fcc RX(theta\u2083) 5b2bbf8ffd494cb882c6c7c6a65eea8b--19a47156548d433d86ffed94268d8fcc 3156ef258ef64de5940151535f8373a5 RY(theta\u2087) 19a47156548d433d86ffed94268d8fcc--3156ef258ef64de5940151535f8373a5 15821843339f452996e05e426e47cb05 RX(theta\u2081\u2081) 3156ef258ef64de5940151535f8373a5--15821843339f452996e05e426e47cb05 50f4d3846c074868bc222a246da09799 X 15821843339f452996e05e426e47cb05--50f4d3846c074868bc222a246da09799 50f4d3846c074868bc222a246da09799--e72da705f5414b65b2d6f59514a122c8 892679b67f0a4bd3acbab464d31aa3c6 50f4d3846c074868bc222a246da09799--892679b67f0a4bd3acbab464d31aa3c6 e9e9aeeb9e6348878ebb7c9c84a8916d RX(theta\u2081\u2085) 892679b67f0a4bd3acbab464d31aa3c6--e9e9aeeb9e6348878ebb7c9c84a8916d 3bfd0bde73a74071925e39c6ae58a50f RY(theta\u2081\u2089) e9e9aeeb9e6348878ebb7c9c84a8916d--3bfd0bde73a74071925e39c6ae58a50f b5c2b35616234893890bde6fd3c00cf1 RX(theta\u2082\u2083) 3bfd0bde73a74071925e39c6ae58a50f--b5c2b35616234893890bde6fd3c00cf1 7f442474d0c74d4f8a83713d9733dbb1 X b5c2b35616234893890bde6fd3c00cf1--7f442474d0c74d4f8a83713d9733dbb1 7f442474d0c74d4f8a83713d9733dbb1--efc0626507764c44a98c7e3ffc0a0d00 ede1a51c69be41f184e3e6ffded4d135 7f442474d0c74d4f8a83713d9733dbb1--ede1a51c69be41f184e3e6ffded4d135 ede1a51c69be41f184e3e6ffded4d135--1753c7fc1ab24cb3a7e7675f1bb3de7f </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_d7c4de01668e435e893ec84d3ee675e5 HEA cluster_ebb6a008fe8f4f32aba923bc5faa70d6 HEA 24c931950b6e4cae86e6d8b9f70afee1 0 3b484993ca34450daef770074e5547a0 RX(theta\u2080) 24c931950b6e4cae86e6d8b9f70afee1--3b484993ca34450daef770074e5547a0 c8f673998f044064afe6cace53202687 1 fae43969156b4d1a82ab629ed0f37bd2 RY(theta\u2084) 3b484993ca34450daef770074e5547a0--fae43969156b4d1a82ab629ed0f37bd2 e7b11a3ec55a42bda901a72716918523 RX(theta\u2088) fae43969156b4d1a82ab629ed0f37bd2--e7b11a3ec55a42bda901a72716918523 ec4bcd10fc7f429aa7c6b0da1742eb51 e7b11a3ec55a42bda901a72716918523--ec4bcd10fc7f429aa7c6b0da1742eb51 21bca86a97bf49a68820301fe3974abf ec4bcd10fc7f429aa7c6b0da1742eb51--21bca86a97bf49a68820301fe3974abf dd7dfc7b1b3c44948b70746d09f1502d RX(theta\u2081\u2082) 21bca86a97bf49a68820301fe3974abf--dd7dfc7b1b3c44948b70746d09f1502d 73c1233e3c3948e788cfdfae7b1812aa RY(theta\u2081\u2086) dd7dfc7b1b3c44948b70746d09f1502d--73c1233e3c3948e788cfdfae7b1812aa 0fe88b5a812040a9b3a8687434800afa RX(theta\u2082\u2080) 73c1233e3c3948e788cfdfae7b1812aa--0fe88b5a812040a9b3a8687434800afa 8609b8801aaf4ce39e7f38e6391e6460 0fe88b5a812040a9b3a8687434800afa--8609b8801aaf4ce39e7f38e6391e6460 825807886e754b12b2f059f9c754a096 8609b8801aaf4ce39e7f38e6391e6460--825807886e754b12b2f059f9c754a096 82f070a744a44ebaa21c0b28d3b69ce9 RX(theta\u2080) 825807886e754b12b2f059f9c754a096--82f070a744a44ebaa21c0b28d3b69ce9 533f24c171554094ba996592ee547160 RY(theta\u2084) 82f070a744a44ebaa21c0b28d3b69ce9--533f24c171554094ba996592ee547160 935e0ce4c1e4446a87c1f5207799705b RX(theta\u2088) 533f24c171554094ba996592ee547160--935e0ce4c1e4446a87c1f5207799705b 8c52defc23cc43d781d311874c86fdd2 935e0ce4c1e4446a87c1f5207799705b--8c52defc23cc43d781d311874c86fdd2 b91282dcb1964dac82aa039bb00728fa 8c52defc23cc43d781d311874c86fdd2--b91282dcb1964dac82aa039bb00728fa e6646c40cc6e4debb38095b92dc4a836 RX(theta\u2081\u2082) b91282dcb1964dac82aa039bb00728fa--e6646c40cc6e4debb38095b92dc4a836 afa1e95f908847679de18aaca1fa8135 RY(theta\u2081\u2086) e6646c40cc6e4debb38095b92dc4a836--afa1e95f908847679de18aaca1fa8135 d0f435dc7fc54e32b48581dbe5e7ac51 RX(theta\u2082\u2080) afa1e95f908847679de18aaca1fa8135--d0f435dc7fc54e32b48581dbe5e7ac51 67a235d81a654a048a8d8a91100c35c0 d0f435dc7fc54e32b48581dbe5e7ac51--67a235d81a654a048a8d8a91100c35c0 d61aa6d8c4474e2d9dd067048b852b03 67a235d81a654a048a8d8a91100c35c0--d61aa6d8c4474e2d9dd067048b852b03 78b9bd2379954ffa80aa83d2efd1d6f2 d61aa6d8c4474e2d9dd067048b852b03--78b9bd2379954ffa80aa83d2efd1d6f2 1d3a8f2d6e8c48db86487b0e62965468 04b57351d3084a0d86a094d2b7bda9f4 RX(theta\u2081) c8f673998f044064afe6cace53202687--04b57351d3084a0d86a094d2b7bda9f4 fceb1997d98348d299277b934cac144e 2 79cf53e3ef87408c9eff20c83802169e RY(theta\u2085) 04b57351d3084a0d86a094d2b7bda9f4--79cf53e3ef87408c9eff20c83802169e 5af3e15cd8464ed7b1801a3914f112fa RX(theta\u2089) 79cf53e3ef87408c9eff20c83802169e--5af3e15cd8464ed7b1801a3914f112fa 7f90f24913dd49fdb5581895fda10991 X 5af3e15cd8464ed7b1801a3914f112fa--7f90f24913dd49fdb5581895fda10991 7f90f24913dd49fdb5581895fda10991--ec4bcd10fc7f429aa7c6b0da1742eb51 e74f8f980e404defa5dbf421e059415b 7f90f24913dd49fdb5581895fda10991--e74f8f980e404defa5dbf421e059415b eda63b1642e746d4a29b5f25a715160e RX(theta\u2081\u2083) e74f8f980e404defa5dbf421e059415b--eda63b1642e746d4a29b5f25a715160e 7cb7d035fd2d440c9acfd1d0aa7c424a RY(theta\u2081\u2087) eda63b1642e746d4a29b5f25a715160e--7cb7d035fd2d440c9acfd1d0aa7c424a 1d3f9d7695084ee4bcc76f7ff4722c2c RX(theta\u2082\u2081) 7cb7d035fd2d440c9acfd1d0aa7c424a--1d3f9d7695084ee4bcc76f7ff4722c2c 4994dcb0aa1a4d2696f37b5d2d3fac4e X 1d3f9d7695084ee4bcc76f7ff4722c2c--4994dcb0aa1a4d2696f37b5d2d3fac4e 4994dcb0aa1a4d2696f37b5d2d3fac4e--8609b8801aaf4ce39e7f38e6391e6460 c65d008ab0e943c195a9238a58601c7e 4994dcb0aa1a4d2696f37b5d2d3fac4e--c65d008ab0e943c195a9238a58601c7e 72eb3f55432f45d997793ec514ba06cd RX(theta\u2081) c65d008ab0e943c195a9238a58601c7e--72eb3f55432f45d997793ec514ba06cd 4ceabbd98d1840228fbc2481b87b8fe1 RY(theta\u2085) 72eb3f55432f45d997793ec514ba06cd--4ceabbd98d1840228fbc2481b87b8fe1 490904c68066434e8d5ad3d2f64ff44e RX(theta\u2089) 4ceabbd98d1840228fbc2481b87b8fe1--490904c68066434e8d5ad3d2f64ff44e 2cb1c23ca8994e80ab3766041bdf8370 X 490904c68066434e8d5ad3d2f64ff44e--2cb1c23ca8994e80ab3766041bdf8370 2cb1c23ca8994e80ab3766041bdf8370--8c52defc23cc43d781d311874c86fdd2 3c64e11665c34838b307837951c067f3 2cb1c23ca8994e80ab3766041bdf8370--3c64e11665c34838b307837951c067f3 7603121dd7554d9e97f1f2e65b60b3a1 RX(theta\u2081\u2083) 3c64e11665c34838b307837951c067f3--7603121dd7554d9e97f1f2e65b60b3a1 e1dd7ca5863c458080a435e7deb82b97 RY(theta\u2081\u2087) 7603121dd7554d9e97f1f2e65b60b3a1--e1dd7ca5863c458080a435e7deb82b97 cde27699d4bb45b5bbd5e250773930ff RX(theta\u2082\u2081) e1dd7ca5863c458080a435e7deb82b97--cde27699d4bb45b5bbd5e250773930ff 3410cc2999a14c078de4d44118c254e3 X cde27699d4bb45b5bbd5e250773930ff--3410cc2999a14c078de4d44118c254e3 3410cc2999a14c078de4d44118c254e3--67a235d81a654a048a8d8a91100c35c0 9f9d9cbfa5c24027a11a0b4db64e06ea 3410cc2999a14c078de4d44118c254e3--9f9d9cbfa5c24027a11a0b4db64e06ea 9f9d9cbfa5c24027a11a0b4db64e06ea--1d3a8f2d6e8c48db86487b0e62965468 a2dc2e5e261e42658d571c5e0b613c3e 06cb3381c8f34a50a351c8fe333b2613 RX(theta\u2082) fceb1997d98348d299277b934cac144e--06cb3381c8f34a50a351c8fe333b2613 3660e7945467497581f3239f9775b59a 3 81e4468399de46119a0c991de1c731ad RY(theta\u2086) 06cb3381c8f34a50a351c8fe333b2613--81e4468399de46119a0c991de1c731ad 044c350cf4b44c72a23e1d1c0217c383 RX(theta\u2081\u2080) 81e4468399de46119a0c991de1c731ad--044c350cf4b44c72a23e1d1c0217c383 050a828c1e25472fa73e39ec0e6542e0 044c350cf4b44c72a23e1d1c0217c383--050a828c1e25472fa73e39ec0e6542e0 adcd4e08b1704415b5c76fcb2a1b4b63 X 050a828c1e25472fa73e39ec0e6542e0--adcd4e08b1704415b5c76fcb2a1b4b63 adcd4e08b1704415b5c76fcb2a1b4b63--e74f8f980e404defa5dbf421e059415b 08593fe02e244116946a975231815457 RX(theta\u2081\u2084) adcd4e08b1704415b5c76fcb2a1b4b63--08593fe02e244116946a975231815457 15268349b504492094d5f6946fa298ff RY(theta\u2081\u2088) 08593fe02e244116946a975231815457--15268349b504492094d5f6946fa298ff a85a96b7247347deaf582e684846eae6 RX(theta\u2082\u2082) 15268349b504492094d5f6946fa298ff--a85a96b7247347deaf582e684846eae6 596af2a6677e47dfb6429ecdf3fc04da a85a96b7247347deaf582e684846eae6--596af2a6677e47dfb6429ecdf3fc04da 7dc5ffe6b56f40bead35bd536a4745e1 X 596af2a6677e47dfb6429ecdf3fc04da--7dc5ffe6b56f40bead35bd536a4745e1 7dc5ffe6b56f40bead35bd536a4745e1--c65d008ab0e943c195a9238a58601c7e 1b290022a0f9400c94e6ca52464b9712 RX(theta\u2082) 7dc5ffe6b56f40bead35bd536a4745e1--1b290022a0f9400c94e6ca52464b9712 fee2b3aaccfd4a9fac24b0cb252219d5 RY(theta\u2086) 1b290022a0f9400c94e6ca52464b9712--fee2b3aaccfd4a9fac24b0cb252219d5 d9a0cddb3c3a4d6a94e13d1b40d0caac RX(theta\u2081\u2080) fee2b3aaccfd4a9fac24b0cb252219d5--d9a0cddb3c3a4d6a94e13d1b40d0caac 75af2745c4c34a7f8b43ad828e65f70a d9a0cddb3c3a4d6a94e13d1b40d0caac--75af2745c4c34a7f8b43ad828e65f70a 43fc8fcbb41c4b2198241a6cc2488f40 X 75af2745c4c34a7f8b43ad828e65f70a--43fc8fcbb41c4b2198241a6cc2488f40 43fc8fcbb41c4b2198241a6cc2488f40--3c64e11665c34838b307837951c067f3 f95d9fcda59d4f4dba8b3359e2a68d65 RX(theta\u2081\u2084) 43fc8fcbb41c4b2198241a6cc2488f40--f95d9fcda59d4f4dba8b3359e2a68d65 e9ec2ed6099f4995834344b62d6dc3f1 RY(theta\u2081\u2088) f95d9fcda59d4f4dba8b3359e2a68d65--e9ec2ed6099f4995834344b62d6dc3f1 f08e73576ae34fef9dd02a03aab5c7cb RX(theta\u2082\u2082) e9ec2ed6099f4995834344b62d6dc3f1--f08e73576ae34fef9dd02a03aab5c7cb 2bffd39a29d8419bbc0229b0c56b0833 f08e73576ae34fef9dd02a03aab5c7cb--2bffd39a29d8419bbc0229b0c56b0833 e38ac2ac50ed471fb2ac46b2b6672f46 X 2bffd39a29d8419bbc0229b0c56b0833--e38ac2ac50ed471fb2ac46b2b6672f46 e38ac2ac50ed471fb2ac46b2b6672f46--9f9d9cbfa5c24027a11a0b4db64e06ea e38ac2ac50ed471fb2ac46b2b6672f46--a2dc2e5e261e42658d571c5e0b613c3e 301e2149fe294dbf981e8e594f813d0d c1d8cb52b83148de97a6a2085d41dbe1 RX(theta\u2083) 3660e7945467497581f3239f9775b59a--c1d8cb52b83148de97a6a2085d41dbe1 9beb64e8f9274e29a4ffe98e15bd784f RY(theta\u2087) c1d8cb52b83148de97a6a2085d41dbe1--9beb64e8f9274e29a4ffe98e15bd784f 75186fa3d4ac47c4b57d0c36e0980f00 RX(theta\u2081\u2081) 9beb64e8f9274e29a4ffe98e15bd784f--75186fa3d4ac47c4b57d0c36e0980f00 6be022939572481a9bcd7696e3fd7ffa X 75186fa3d4ac47c4b57d0c36e0980f00--6be022939572481a9bcd7696e3fd7ffa 6be022939572481a9bcd7696e3fd7ffa--050a828c1e25472fa73e39ec0e6542e0 c8c351d93cb64ae09210ca9b5b367d68 6be022939572481a9bcd7696e3fd7ffa--c8c351d93cb64ae09210ca9b5b367d68 8d3fd136d6ae473cba4e292504eec9e5 RX(theta\u2081\u2085) c8c351d93cb64ae09210ca9b5b367d68--8d3fd136d6ae473cba4e292504eec9e5 ccc91630a23348c2a2517009bf97e2e4 RY(theta\u2081\u2089) 8d3fd136d6ae473cba4e292504eec9e5--ccc91630a23348c2a2517009bf97e2e4 944a814b1f25419bb9e9210e6102f9c1 RX(theta\u2082\u2083) ccc91630a23348c2a2517009bf97e2e4--944a814b1f25419bb9e9210e6102f9c1 b1d94ced26024477b9ede85a571b0c42 X 944a814b1f25419bb9e9210e6102f9c1--b1d94ced26024477b9ede85a571b0c42 b1d94ced26024477b9ede85a571b0c42--596af2a6677e47dfb6429ecdf3fc04da e24f98205eec48e6ac2e4b9cdd90a937 b1d94ced26024477b9ede85a571b0c42--e24f98205eec48e6ac2e4b9cdd90a937 81be5e547a1a427783d59803c4e58c3b RX(theta\u2083) e24f98205eec48e6ac2e4b9cdd90a937--81be5e547a1a427783d59803c4e58c3b 453512e33bea45e182f6777c581a81f1 RY(theta\u2087) 81be5e547a1a427783d59803c4e58c3b--453512e33bea45e182f6777c581a81f1 f2aa5259bf1e480babd54110924bd52e RX(theta\u2081\u2081) 453512e33bea45e182f6777c581a81f1--f2aa5259bf1e480babd54110924bd52e 7a5d8c3770c94300bbe7e9828759f5ce X f2aa5259bf1e480babd54110924bd52e--7a5d8c3770c94300bbe7e9828759f5ce 7a5d8c3770c94300bbe7e9828759f5ce--75af2745c4c34a7f8b43ad828e65f70a e17db6f87a294e3cb3ba49c3c0471cc0 7a5d8c3770c94300bbe7e9828759f5ce--e17db6f87a294e3cb3ba49c3c0471cc0 1b1117e39e2b48c39efa78b46a873bb8 RX(theta\u2081\u2085) e17db6f87a294e3cb3ba49c3c0471cc0--1b1117e39e2b48c39efa78b46a873bb8 1ce6f61a79cf4e0693a354f3d9f980d9 RY(theta\u2081\u2089) 1b1117e39e2b48c39efa78b46a873bb8--1ce6f61a79cf4e0693a354f3d9f980d9 ec3a3a72d4d54726bd474dae7db067ad RX(theta\u2082\u2083) 1ce6f61a79cf4e0693a354f3d9f980d9--ec3a3a72d4d54726bd474dae7db067ad dae639e8db184eab9d3e90063492bee0 X ec3a3a72d4d54726bd474dae7db067ad--dae639e8db184eab9d3e90063492bee0 dae639e8db184eab9d3e90063492bee0--2bffd39a29d8419bbc0229b0c56b0833 f6bc03c80b6d4d9988ea30ab86490e82 dae639e8db184eab9d3e90063492bee0--f6bc03c80b6d4d9988ea30ab86490e82 f6bc03c80b6d4d9988ea30ab86490e82--301e2149fe294dbf981e8e594f813d0d </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_977975ec83954ada92ab19e431cf269a HEA cluster_43eff9842f8e4ce5a113452e11ef746b HEA b983fd096d2d4a77bdb75746fe568270 0 f2c4c8ddd8064766a5d5b217c2073957 RX(p1\u2080) b983fd096d2d4a77bdb75746fe568270--f2c4c8ddd8064766a5d5b217c2073957 c5f5f032d3a3475897d2cdc45cfbf6bf 1 66a18d606b7f4133ab302f141e632cc4 RY(p1\u2084) f2c4c8ddd8064766a5d5b217c2073957--66a18d606b7f4133ab302f141e632cc4 b2eb6a042a9d40f5b1cfa4d9a3c9b69a RX(p1\u2088) 66a18d606b7f4133ab302f141e632cc4--b2eb6a042a9d40f5b1cfa4d9a3c9b69a 4c1c5ca94ccd476b8d933ebeae980ef8 b2eb6a042a9d40f5b1cfa4d9a3c9b69a--4c1c5ca94ccd476b8d933ebeae980ef8 4273262a18714505b63e986d2ab9f962 4c1c5ca94ccd476b8d933ebeae980ef8--4273262a18714505b63e986d2ab9f962 0cdc44abd4594d53b8316e3a289d04c0 RX(p1\u2081\u2082) 4273262a18714505b63e986d2ab9f962--0cdc44abd4594d53b8316e3a289d04c0 c74a622fe7534c659fd5e8e0b01798b3 RY(p1\u2081\u2086) 0cdc44abd4594d53b8316e3a289d04c0--c74a622fe7534c659fd5e8e0b01798b3 88429cfbba8c47abb035d6e3dfddb954 RX(p1\u2082\u2080) c74a622fe7534c659fd5e8e0b01798b3--88429cfbba8c47abb035d6e3dfddb954 4806a135758e4fcdbdb939d399121b5e 88429cfbba8c47abb035d6e3dfddb954--4806a135758e4fcdbdb939d399121b5e 3d2943ce1fda4e52a1edcb6f2e4788c2 4806a135758e4fcdbdb939d399121b5e--3d2943ce1fda4e52a1edcb6f2e4788c2 b095edcdc9274225bc4aa959297e5401 RX(p2\u2080) 3d2943ce1fda4e52a1edcb6f2e4788c2--b095edcdc9274225bc4aa959297e5401 1a42a13463324777807f82a5b07382a3 RY(p2\u2084) b095edcdc9274225bc4aa959297e5401--1a42a13463324777807f82a5b07382a3 de9a627b264f4a14b8e52c8f8a526afa RX(p2\u2088) 1a42a13463324777807f82a5b07382a3--de9a627b264f4a14b8e52c8f8a526afa f2921f49ee3346ce9332194a0eadb54d de9a627b264f4a14b8e52c8f8a526afa--f2921f49ee3346ce9332194a0eadb54d 69e7c008c6e84d58b60ea8acf2f7dd98 f2921f49ee3346ce9332194a0eadb54d--69e7c008c6e84d58b60ea8acf2f7dd98 8e636a740bb54f6199a04d1470f56d42 RX(p2\u2081\u2082) 69e7c008c6e84d58b60ea8acf2f7dd98--8e636a740bb54f6199a04d1470f56d42 4ed25dd1e1864d70bf024fb60f385c14 RY(p2\u2081\u2086) 8e636a740bb54f6199a04d1470f56d42--4ed25dd1e1864d70bf024fb60f385c14 5de5ac669c0741808829774528df6cc8 RX(p2\u2082\u2080) 4ed25dd1e1864d70bf024fb60f385c14--5de5ac669c0741808829774528df6cc8 4b13038c63d04560bbcc7ab2e8704710 5de5ac669c0741808829774528df6cc8--4b13038c63d04560bbcc7ab2e8704710 dbc3c0685d544dc5aa4dfc03ab12f9a8 4b13038c63d04560bbcc7ab2e8704710--dbc3c0685d544dc5aa4dfc03ab12f9a8 177934ca87c645aa9ad02113191a5e00 dbc3c0685d544dc5aa4dfc03ab12f9a8--177934ca87c645aa9ad02113191a5e00 33bc9364643a4273a0f74df5171f1bb6 f5177ced06dc49dd9249d36ef9fd2d33 RX(p1\u2081) c5f5f032d3a3475897d2cdc45cfbf6bf--f5177ced06dc49dd9249d36ef9fd2d33 2eb533ec1b234fa387d0b79b7515e6e0 2 9a352b005b9c48b6899cff608505e30c RY(p1\u2085) f5177ced06dc49dd9249d36ef9fd2d33--9a352b005b9c48b6899cff608505e30c 2fabe5b8a54e428492977be30c311159 RX(p1\u2089) 9a352b005b9c48b6899cff608505e30c--2fabe5b8a54e428492977be30c311159 c8cbd82b841b4861bc8e3a3f2330483e X 2fabe5b8a54e428492977be30c311159--c8cbd82b841b4861bc8e3a3f2330483e c8cbd82b841b4861bc8e3a3f2330483e--4c1c5ca94ccd476b8d933ebeae980ef8 d1ef7ea509164aca874096649f8a2cec c8cbd82b841b4861bc8e3a3f2330483e--d1ef7ea509164aca874096649f8a2cec 9c4228c1795a47bb86928588b7b3c900 RX(p1\u2081\u2083) d1ef7ea509164aca874096649f8a2cec--9c4228c1795a47bb86928588b7b3c900 827f9306bbbd489db94fc7cc81d74a8b RY(p1\u2081\u2087) 9c4228c1795a47bb86928588b7b3c900--827f9306bbbd489db94fc7cc81d74a8b a22df1fbbae6467390ceb6f484a967f1 RX(p1\u2082\u2081) 827f9306bbbd489db94fc7cc81d74a8b--a22df1fbbae6467390ceb6f484a967f1 171440b44ad14d1f8ceb6ce45dbcb325 X a22df1fbbae6467390ceb6f484a967f1--171440b44ad14d1f8ceb6ce45dbcb325 171440b44ad14d1f8ceb6ce45dbcb325--4806a135758e4fcdbdb939d399121b5e f9282f041625450fa6edb937c645ca52 171440b44ad14d1f8ceb6ce45dbcb325--f9282f041625450fa6edb937c645ca52 dbe1d7a1789a4761b1cb24520a2c0583 RX(p2\u2081) f9282f041625450fa6edb937c645ca52--dbe1d7a1789a4761b1cb24520a2c0583 6b6b3551a6f241ff808c109e656f9ae7 RY(p2\u2085) dbe1d7a1789a4761b1cb24520a2c0583--6b6b3551a6f241ff808c109e656f9ae7 e6d25fb315ff4d4184b948bb0cba6eab RX(p2\u2089) 6b6b3551a6f241ff808c109e656f9ae7--e6d25fb315ff4d4184b948bb0cba6eab 78d0ba415f2a4e83bd28717b58a16fce X e6d25fb315ff4d4184b948bb0cba6eab--78d0ba415f2a4e83bd28717b58a16fce 78d0ba415f2a4e83bd28717b58a16fce--f2921f49ee3346ce9332194a0eadb54d 319c1ade3cbe4b4e8736b862cc583032 78d0ba415f2a4e83bd28717b58a16fce--319c1ade3cbe4b4e8736b862cc583032 2b08ed39e97b4cb8b764a221f7be6b62 RX(p2\u2081\u2083) 319c1ade3cbe4b4e8736b862cc583032--2b08ed39e97b4cb8b764a221f7be6b62 3b22a7adf4814c7c964430cc554952d7 RY(p2\u2081\u2087) 2b08ed39e97b4cb8b764a221f7be6b62--3b22a7adf4814c7c964430cc554952d7 f7db645c48654e3e928f52cce60f19fb RX(p2\u2082\u2081) 3b22a7adf4814c7c964430cc554952d7--f7db645c48654e3e928f52cce60f19fb c904ae73e4b447019b93c0e22be45e6d X f7db645c48654e3e928f52cce60f19fb--c904ae73e4b447019b93c0e22be45e6d c904ae73e4b447019b93c0e22be45e6d--4b13038c63d04560bbcc7ab2e8704710 a00df2490495431a8ff959c468ff747f c904ae73e4b447019b93c0e22be45e6d--a00df2490495431a8ff959c468ff747f a00df2490495431a8ff959c468ff747f--33bc9364643a4273a0f74df5171f1bb6 edff0d850bb545139214670dba5de82f e946666af7474411851acb2973afba24 RX(p1\u2082) 2eb533ec1b234fa387d0b79b7515e6e0--e946666af7474411851acb2973afba24 019d7d24d78a417ab28fdafb02af52fe 3 c2bd0aff992545009a277372e53733ec RY(p1\u2086) e946666af7474411851acb2973afba24--c2bd0aff992545009a277372e53733ec 81ac6d72d6534e31a20a3f56724fc9f7 RX(p1\u2081\u2080) c2bd0aff992545009a277372e53733ec--81ac6d72d6534e31a20a3f56724fc9f7 ca24ef515dc74102a2618b72a7b2d79e 81ac6d72d6534e31a20a3f56724fc9f7--ca24ef515dc74102a2618b72a7b2d79e 966d96aa70fc401184c2e32ebdbc48c7 X ca24ef515dc74102a2618b72a7b2d79e--966d96aa70fc401184c2e32ebdbc48c7 966d96aa70fc401184c2e32ebdbc48c7--d1ef7ea509164aca874096649f8a2cec 3620f1c5a3ee4a418e05d25e4574a653 RX(p1\u2081\u2084) 966d96aa70fc401184c2e32ebdbc48c7--3620f1c5a3ee4a418e05d25e4574a653 7b98b0bc7b0d467abf12e53b431f3052 RY(p1\u2081\u2088) 3620f1c5a3ee4a418e05d25e4574a653--7b98b0bc7b0d467abf12e53b431f3052 7e8e7d6f13a14471a7857cd924704ddd RX(p1\u2082\u2082) 7b98b0bc7b0d467abf12e53b431f3052--7e8e7d6f13a14471a7857cd924704ddd 3513b7e5ce344d37994d0dbb64c70279 7e8e7d6f13a14471a7857cd924704ddd--3513b7e5ce344d37994d0dbb64c70279 d367426a1bfd43b6b570d704f681d195 X 3513b7e5ce344d37994d0dbb64c70279--d367426a1bfd43b6b570d704f681d195 d367426a1bfd43b6b570d704f681d195--f9282f041625450fa6edb937c645ca52 0ae33b0237b849ac9e9cdb433853f79d RX(p2\u2082) d367426a1bfd43b6b570d704f681d195--0ae33b0237b849ac9e9cdb433853f79d b910a9e6a20746df915a4a5c6a929edd RY(p2\u2086) 0ae33b0237b849ac9e9cdb433853f79d--b910a9e6a20746df915a4a5c6a929edd 2243b48f5ff8411b80a7087de44b00bf RX(p2\u2081\u2080) b910a9e6a20746df915a4a5c6a929edd--2243b48f5ff8411b80a7087de44b00bf d1f1cd02d2bb44b68da4e6c490b7c059 2243b48f5ff8411b80a7087de44b00bf--d1f1cd02d2bb44b68da4e6c490b7c059 a00bcad8ba8c40d3a9b591a87e0d4991 X d1f1cd02d2bb44b68da4e6c490b7c059--a00bcad8ba8c40d3a9b591a87e0d4991 a00bcad8ba8c40d3a9b591a87e0d4991--319c1ade3cbe4b4e8736b862cc583032 bd40360634bc4de791a95a4fbf723db4 RX(p2\u2081\u2084) a00bcad8ba8c40d3a9b591a87e0d4991--bd40360634bc4de791a95a4fbf723db4 a4e359ea085249baa684cb5e7b98580f RY(p2\u2081\u2088) bd40360634bc4de791a95a4fbf723db4--a4e359ea085249baa684cb5e7b98580f dcf6e5e395bf4161bfde8de1c3946efb RX(p2\u2082\u2082) a4e359ea085249baa684cb5e7b98580f--dcf6e5e395bf4161bfde8de1c3946efb df4362f455c1449ea173c105bcba17f1 dcf6e5e395bf4161bfde8de1c3946efb--df4362f455c1449ea173c105bcba17f1 98f230e8cb584e708254ac206c701aa1 X df4362f455c1449ea173c105bcba17f1--98f230e8cb584e708254ac206c701aa1 98f230e8cb584e708254ac206c701aa1--a00df2490495431a8ff959c468ff747f 98f230e8cb584e708254ac206c701aa1--edff0d850bb545139214670dba5de82f 7e4aa5daab0e4fe89061570ded706567 1434a6593ce64aed82df9714464636be RX(p1\u2083) 019d7d24d78a417ab28fdafb02af52fe--1434a6593ce64aed82df9714464636be 157dc3c8790e49ceb06df08b81c6586d RY(p1\u2087) 1434a6593ce64aed82df9714464636be--157dc3c8790e49ceb06df08b81c6586d a4595ed7980f476999a6b845bc0cb078 RX(p1\u2081\u2081) 157dc3c8790e49ceb06df08b81c6586d--a4595ed7980f476999a6b845bc0cb078 cf62c8d3ab0b445d8d3e7b1b18ae6c49 X a4595ed7980f476999a6b845bc0cb078--cf62c8d3ab0b445d8d3e7b1b18ae6c49 cf62c8d3ab0b445d8d3e7b1b18ae6c49--ca24ef515dc74102a2618b72a7b2d79e 33aa830fbab74ef48df2c651a8466b02 cf62c8d3ab0b445d8d3e7b1b18ae6c49--33aa830fbab74ef48df2c651a8466b02 d01965f50c9b4328ad387f6c46db221e RX(p1\u2081\u2085) 33aa830fbab74ef48df2c651a8466b02--d01965f50c9b4328ad387f6c46db221e 051218c0083840358dae93b296e21ffe RY(p1\u2081\u2089) d01965f50c9b4328ad387f6c46db221e--051218c0083840358dae93b296e21ffe 7ef812ea57494b03b4a5e8307b7d0fbf RX(p1\u2082\u2083) 051218c0083840358dae93b296e21ffe--7ef812ea57494b03b4a5e8307b7d0fbf f1cd85985ec4485a98da770e5e59a370 X 7ef812ea57494b03b4a5e8307b7d0fbf--f1cd85985ec4485a98da770e5e59a370 f1cd85985ec4485a98da770e5e59a370--3513b7e5ce344d37994d0dbb64c70279 1fdb93d259ee4d8b88a2fd09fe7f9d15 f1cd85985ec4485a98da770e5e59a370--1fdb93d259ee4d8b88a2fd09fe7f9d15 2b72ea4aa7d94111b4c24777105f9d62 RX(p2\u2083) 1fdb93d259ee4d8b88a2fd09fe7f9d15--2b72ea4aa7d94111b4c24777105f9d62 71d3e5c7055347438ccab16996fb9829 RY(p2\u2087) 2b72ea4aa7d94111b4c24777105f9d62--71d3e5c7055347438ccab16996fb9829 a7b47b2df7ee4674907d99e1bcb8a31c RX(p2\u2081\u2081) 71d3e5c7055347438ccab16996fb9829--a7b47b2df7ee4674907d99e1bcb8a31c 885d9e549f4f4604a887bbd19527623c X a7b47b2df7ee4674907d99e1bcb8a31c--885d9e549f4f4604a887bbd19527623c 885d9e549f4f4604a887bbd19527623c--d1f1cd02d2bb44b68da4e6c490b7c059 85ca4796d4ef45358091da2a3299153e 885d9e549f4f4604a887bbd19527623c--85ca4796d4ef45358091da2a3299153e 1a3613d7af5c40b8b5ac803e64ab3410 RX(p2\u2081\u2085) 85ca4796d4ef45358091da2a3299153e--1a3613d7af5c40b8b5ac803e64ab3410 8280c2c7017849aab4f2c6e265d5dc63 RY(p2\u2081\u2089) 1a3613d7af5c40b8b5ac803e64ab3410--8280c2c7017849aab4f2c6e265d5dc63 3b8cb3e8f0534cbfa434936c56144f4b RX(p2\u2082\u2083) 8280c2c7017849aab4f2c6e265d5dc63--3b8cb3e8f0534cbfa434936c56144f4b c279a7e57a114e22b034262aef404322 X 3b8cb3e8f0534cbfa434936c56144f4b--c279a7e57a114e22b034262aef404322 c279a7e57a114e22b034262aef404322--df4362f455c1449ea173c105bcba17f1 17bf768b8b7648a3a60ac0ad159b7db1 c279a7e57a114e22b034262aef404322--17bf768b8b7648a3a60ac0ad159b7db1 17bf768b8b7648a3a60ac0ad159b7db1--7e4aa5daab0e4fe89061570ded706567 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0855])), ('theta_0', tensor([0.5155])), ('theta_1', tensor([0.9281])), ('theta_10', tensor([0.9866])), ('theta_11', tensor([0.2450])), ('theta_12', tensor([0.4834])), ('theta_13', tensor([0.1215])), ('theta_14', tensor([0.0793])), ('theta_15', tensor([0.7420])), ('theta_16', tensor([0.6813])), ('theta_17', tensor([0.5558])), ('theta_18', tensor([0.9943])), ('theta_19', tensor([0.4941])), ('theta_2', tensor([0.8950])), ('theta_20', tensor([0.5997])), ('theta_21', tensor([0.0895])), ('theta_22', tensor([0.9110])), ('theta_23', tensor([0.1405])), ('theta_3', tensor([0.2954])), ('theta_4', tensor([0.5823])), ('theta_5', tensor([0.5412])), ('theta_6', tensor([0.5837])), ('theta_7', tensor([0.3800])), ('theta_8', tensor([0.2195])), ('theta_9', tensor([0.9872]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.0845])), ('theta_0', tensor([0.5145])), ('theta_1', tensor([0.9291])), ('theta_10', tensor([0.9876])), ('theta_11', tensor([0.2440])), ('theta_12', tensor([0.4844])), ('theta_13', tensor([0.1225])), ('theta_14', tensor([0.0803])), ('theta_15', tensor([0.7410])), ('theta_16', tensor([0.6803])), ('theta_17', tensor([0.5568])), ('theta_18', tensor([0.9933])), ('theta_19', tensor([0.4951])), ('theta_2', tensor([0.8960])), ('theta_20', tensor([0.6007])), ('theta_21', tensor([0.0905])), ('theta_22', tensor([0.9120])), ('theta_23', tensor([0.1395])), ('theta_3', tensor([0.2944])), ('theta_4', tensor([0.5833])), ('theta_5', tensor([0.5422])), ('theta_6', tensor([0.5827])), ('theta_7', tensor([0.3790])), ('theta_8', tensor([0.2205])), ('theta_9', tensor([0.9882]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 9.9885e-01+0.0000j,  0.0000e+00-0.0338j,  0.0000e+00-0.0338j,\n         -1.1468e-03+0.0000j],\n        [ 9.9919e-01+0.0000j,  0.0000e+00-0.0284j,  0.0000e+00-0.0284j,\n         -8.0882e-04+0.0000j],\n        [ 9.8061e-01+0.0000j,  0.0000e+00-0.1379j,  0.0000e+00-0.1379j,\n         -1.9395e-02+0.0000j]])\nxs = [Counter({'00': 100}), Counter({'00': 100}), Counter({'00': 97, '01': 2, '10': 1})]\nex = tensor([[0.9977],\n        [0.9984],\n        [0.9612]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9977, 0.9977],\n        [0.9984, 0.9984],\n        [0.9612, 0.9612]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2024-01-17T18:17:09.218833 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register, PI\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*PI, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2024-01-17T18:17:09.595573 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 52, '10': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample, PI\n\n# RX(PI/4) on qubit 1\nn_qubits = 2\nop = RX(1, PI/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 84, '01': 16})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [0.95664017+0.j         0.        -0.00752554j 0.29116612+0.j\n 0.        -0.0022905j ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_7305264220b3471da02446a1cbbd19ae Circuit block cluster_932422c020144a0ba4163c2a8772a815 Prep block be3925e9ffe94c5cb22f96c8f9b57127 0 dfeaf46a5e164c748651b468cb92d5f7 be3925e9ffe94c5cb22f96c8f9b57127--dfeaf46a5e164c748651b468cb92d5f7 3c8444756f4445859b3c4e5d12433749 1 54f2f108e6114f96992b7adf49ea432d RX(theta\u2080) dfeaf46a5e164c748651b468cb92d5f7--54f2f108e6114f96992b7adf49ea432d 93b2f10816fb4d7e9f209b7052132f82 RY(theta\u2084) 54f2f108e6114f96992b7adf49ea432d--93b2f10816fb4d7e9f209b7052132f82 ff462ff7156245658d93d845c838fc11 RX(theta\u2088) 93b2f10816fb4d7e9f209b7052132f82--ff462ff7156245658d93d845c838fc11 00bdf19df1eb475e8292df67bc77f1dd ff462ff7156245658d93d845c838fc11--00bdf19df1eb475e8292df67bc77f1dd de1adef0b8bb4f7f8f96b899a9cc72c0 00bdf19df1eb475e8292df67bc77f1dd--de1adef0b8bb4f7f8f96b899a9cc72c0 393166091f3f4edbaf4a71753a1cc96f RX(theta\u2081\u2082) de1adef0b8bb4f7f8f96b899a9cc72c0--393166091f3f4edbaf4a71753a1cc96f af94045d0dec4c5b8fc42e7808b7a15e RY(theta\u2081\u2086) 393166091f3f4edbaf4a71753a1cc96f--af94045d0dec4c5b8fc42e7808b7a15e 55a2bfcbee384542b47c2c8a06e8c93c RX(theta\u2082\u2080) af94045d0dec4c5b8fc42e7808b7a15e--55a2bfcbee384542b47c2c8a06e8c93c 7f3721784d4c4d2a82d060fd7ba2c9d5 55a2bfcbee384542b47c2c8a06e8c93c--7f3721784d4c4d2a82d060fd7ba2c9d5 6900dfaa1540404eb44d569154743e1c 7f3721784d4c4d2a82d060fd7ba2c9d5--6900dfaa1540404eb44d569154743e1c efd5fc0422e74f009960cb175ac8fb99 6900dfaa1540404eb44d569154743e1c--efd5fc0422e74f009960cb175ac8fb99 2d58e333d87c4858a977b9d5277138c9 690979b378fc4cf394a1324c0fee9204 3c8444756f4445859b3c4e5d12433749--690979b378fc4cf394a1324c0fee9204 9bfbd9a879514f1685b47381437176ba 2 06464689a2c9436e80b3ce3d049be5b9 RX(theta\u2081) 690979b378fc4cf394a1324c0fee9204--06464689a2c9436e80b3ce3d049be5b9 82863bdd8a2f4ae9a35a1e6f17e3010e RY(theta\u2085) 06464689a2c9436e80b3ce3d049be5b9--82863bdd8a2f4ae9a35a1e6f17e3010e e0546681329343439d8833266273b968 RX(theta\u2089) 82863bdd8a2f4ae9a35a1e6f17e3010e--e0546681329343439d8833266273b968 0f1d27fdcd2e407aa5022e6d1b268915 X e0546681329343439d8833266273b968--0f1d27fdcd2e407aa5022e6d1b268915 0f1d27fdcd2e407aa5022e6d1b268915--00bdf19df1eb475e8292df67bc77f1dd 8a978623409f44b2aa84b9744d203e75 0f1d27fdcd2e407aa5022e6d1b268915--8a978623409f44b2aa84b9744d203e75 b4f9160e328c43f898d5f65d0f816475 RX(theta\u2081\u2083) 8a978623409f44b2aa84b9744d203e75--b4f9160e328c43f898d5f65d0f816475 beff56f662b449f8b70d0f86bc625507 RY(theta\u2081\u2087) b4f9160e328c43f898d5f65d0f816475--beff56f662b449f8b70d0f86bc625507 9b65a1b135ac4ca9a520f6e0e8c89aec RX(theta\u2082\u2081) beff56f662b449f8b70d0f86bc625507--9b65a1b135ac4ca9a520f6e0e8c89aec 2cb2c9358d924839a7666c22b11e08a5 X 9b65a1b135ac4ca9a520f6e0e8c89aec--2cb2c9358d924839a7666c22b11e08a5 2cb2c9358d924839a7666c22b11e08a5--7f3721784d4c4d2a82d060fd7ba2c9d5 5b333f1201b7414bb9997382032b3278 2cb2c9358d924839a7666c22b11e08a5--5b333f1201b7414bb9997382032b3278 5b333f1201b7414bb9997382032b3278--2d58e333d87c4858a977b9d5277138c9 93e3461c61794d869646bb384e834d90 0db1d4dcd8234e5cb49bf768160e1486 9bfbd9a879514f1685b47381437176ba--0db1d4dcd8234e5cb49bf768160e1486 78b79b172d6e4e45b424fbdf916bd6fe 3 35349f902aff412c81940875d8e62b15 RX(theta\u2082) 0db1d4dcd8234e5cb49bf768160e1486--35349f902aff412c81940875d8e62b15 17d04ae8d6334d37b6466b49ba8a0673 RY(theta\u2086) 35349f902aff412c81940875d8e62b15--17d04ae8d6334d37b6466b49ba8a0673 53198ce505984818b606584faf9e0945 RX(theta\u2081\u2080) 17d04ae8d6334d37b6466b49ba8a0673--53198ce505984818b606584faf9e0945 96f4a10755e541e6abcf95bd12f0d8de 53198ce505984818b606584faf9e0945--96f4a10755e541e6abcf95bd12f0d8de 230dd65e464f45fe808747ba202a64d7 X 96f4a10755e541e6abcf95bd12f0d8de--230dd65e464f45fe808747ba202a64d7 230dd65e464f45fe808747ba202a64d7--8a978623409f44b2aa84b9744d203e75 439b840f6d3d48c7be319796a2027645 RX(theta\u2081\u2084) 230dd65e464f45fe808747ba202a64d7--439b840f6d3d48c7be319796a2027645 44bb1595d1ee48339f9b6a6b72f0db2c RY(theta\u2081\u2088) 439b840f6d3d48c7be319796a2027645--44bb1595d1ee48339f9b6a6b72f0db2c e5f66dfddbde456c99f499fd016eb7fd RX(theta\u2082\u2082) 44bb1595d1ee48339f9b6a6b72f0db2c--e5f66dfddbde456c99f499fd016eb7fd 587013b33b004df6b29b5b5ef40b884e e5f66dfddbde456c99f499fd016eb7fd--587013b33b004df6b29b5b5ef40b884e ef52ba9fa87d406e8fe6c2a891d26f36 X 587013b33b004df6b29b5b5ef40b884e--ef52ba9fa87d406e8fe6c2a891d26f36 ef52ba9fa87d406e8fe6c2a891d26f36--5b333f1201b7414bb9997382032b3278 ef52ba9fa87d406e8fe6c2a891d26f36--93e3461c61794d869646bb384e834d90 9909cdd538a24e11b8e3193747d6c00e 73605968200c474e8186e10fb5eeb65f X 78b79b172d6e4e45b424fbdf916bd6fe--73605968200c474e8186e10fb5eeb65f d10725737f4e4e6a9d406c43be317e5e RX(theta\u2083) 73605968200c474e8186e10fb5eeb65f--d10725737f4e4e6a9d406c43be317e5e 91aad4b1b6be47edab24e751512c81bc RY(theta\u2087) d10725737f4e4e6a9d406c43be317e5e--91aad4b1b6be47edab24e751512c81bc 10518f3b900c480cb3b4d8c1f7ddc509 RX(theta\u2081\u2081) 91aad4b1b6be47edab24e751512c81bc--10518f3b900c480cb3b4d8c1f7ddc509 4f2e1c29b4474ad0ba794c1b17b6c1ab X 10518f3b900c480cb3b4d8c1f7ddc509--4f2e1c29b4474ad0ba794c1b17b6c1ab 4f2e1c29b4474ad0ba794c1b17b6c1ab--96f4a10755e541e6abcf95bd12f0d8de 90eb1599b79046c3ab9e6df2ca1b191f 4f2e1c29b4474ad0ba794c1b17b6c1ab--90eb1599b79046c3ab9e6df2ca1b191f 800c72e312344f2a9ee222e52e4f3683 RX(theta\u2081\u2085) 90eb1599b79046c3ab9e6df2ca1b191f--800c72e312344f2a9ee222e52e4f3683 c487ca091a4842aebd0a4c5b61c44104 RY(theta\u2081\u2089) 800c72e312344f2a9ee222e52e4f3683--c487ca091a4842aebd0a4c5b61c44104 6c0038225a8f47339666bcaf7d1c450b RX(theta\u2082\u2083) c487ca091a4842aebd0a4c5b61c44104--6c0038225a8f47339666bcaf7d1c450b ac89b4435ede48d6bf2b58601c671bbd X 6c0038225a8f47339666bcaf7d1c450b--ac89b4435ede48d6bf2b58601c671bbd ac89b4435ede48d6bf2b58601c671bbd--587013b33b004df6b29b5b5ef40b884e cc66885dc52f440897d18842eb33a05e ac89b4435ede48d6bf2b58601c671bbd--cc66885dc52f440897d18842eb33a05e cc66885dc52f440897d18842eb33a05e--9909cdd538a24e11b8e3193747d6c00e  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.4778-0.3032j, -0.2188+0.0063j, -0.5854+0.1054j, -0.0209+0.1171j,\n         -0.1233+0.1146j,  0.2949-0.1529j,  0.2178+0.2514j,  0.0053+0.1206j],\n        [ 0.0060+0.1147j,  0.1033+0.1432j, -0.2309+0.3088j, -0.2681+0.2402j,\n         -0.2283-0.2065j, -0.4066+0.1532j, -0.5098-0.1379j,  0.2512-0.2275j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}