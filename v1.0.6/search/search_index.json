{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\nreturn 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n# Global analog RX block.\nblock = AnalogRX(pi)\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'01': 42, '00': 33, '10': 25})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, configuration=None, noise=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock | None = None,\nbackend: BackendName | str = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nmeasurement: Measurements | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\nnoise: Noise | None = None,\n):\n\"\"\"Initialize a generic QuantumModel instance.\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\nsuper().__init__()\nif not isinstance(circuit, QuantumCircuit):\nTypeError(\nf\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n)\nself.inputs = [p for p in circuit.unique_parameters if not p.trainable and not p.is_number]\nif diff_mode is None:\nraise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\nself.backend = backend_factory(\nbackend=backend, diff_mode=diff_mode, configuration=configuration\n)\nif isinstance(observable, list) or observable is None:\nobservable = observable\nelse:\nobservable = [observable]\nconv = self.backend.convert(circuit, observable)\nself.embedding_fn = conv.embedding_fn\nself._circuit = conv.circuit\nself._observable = conv.observable\nself._backend_name = backend\nself._diff_mode = diff_mode\nself._measurement = measurement\nself._noise = noise\nself._params = nn.ParameterDict(\n{\nstr(key): nn.Parameter(val, requires_grad=val.requires_grad)\nfor key, val in conv.params.items()\n}\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n\"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\nparams = self.embedding_fn(self._params, values)\nreturn self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\nself,\nvalues: dict[str, Tensor] = {},\nobservable: list[ConvertedObservable] | ConvertedObservable | None = None,\nstate: Optional[Tensor] = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute expectation using the given backend.\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\nif observable is None:\nif self._observable is None:\nraise ValueError(\n\"Provide an AbstractBlock as the observable to compute expectation.\"\n\"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n\"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n)\nobservable = self._observable\nparams = self.embedding_fn(self._params, values)\nif measurement is None:\nmeasurement = self._measurement\nif noise is None:\nnoise = self._noise\nreturn self.backend.expectation(\ncircuit=self._circuit,\nobservable=observable,\nparam_values=params,\nstate=state,\nmeasurement=measurement,\nnoise=noise,\nendianness=endianness,\n)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n\"\"\"Reset all the variational parameters with a given list of values.\"\"\"\ncurrent_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\nassert (\nlen(values) == self.num_vparams\n), \"Pass an iterable with the values of all variational parameters\"\nfor i, k in enumerate(current_vparams.keys()):\ncurrent_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN\nfrom qadence import hea, feature_map, hamiltonian_factory, Z\n# create the circuit\nn_qubits, depth = 2, 4\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning = Z)\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n# initialize and use the model\nqnn = QNN(circuit, obs, diff_mode=\"ad\", backend=\"pyqtorch\")\ny = qnn.expectation({\"phi\": torch.rand(3)})\n</code></pre> <pre><code>tensor([[0.7110, 1.4221],\n[1.6172, 3.2344],\n[1.1616, 2.3231]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\nself,\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock] | AbstractBlock,\ntransform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: DiffMode = DiffMode.AD,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nconfiguration: BackendConfiguration | dict | None = None,\n):\n\"\"\"Initialize the QNN.\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\nsuper().__init__(\ncircuit=circuit,\nobservable=observable,\nbackend=backend,\ndiff_mode=diff_mode,\nmeasurement=measurement,\nconfiguration=configuration,\nnoise=noise,\n)\nif self.out_features is None:\nraise ValueError(\"You need to provide at least one observable in the QNN constructor\")\nself.transform = transform if transform else lambda x: x\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\nself,\nvalues: dict[str, Tensor] | Tensor = None,\nstate: Tensor | None = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Forward pass of the model.\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n    Args:\n        values (dict[str, Tensor] | Tensor): the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\nif values is None:\nvalues = {}\nif not isinstance(values, dict):\nvalues = self._format_to_dict(values)\nif measurement is None:\nmeasurement = self._measurement\nif noise is None:\nnoise = self._noise\nreturn self.transform(\nself.expectation(\nvalues=values,\nstate=state,\nmeasurement=measurement,\nendianness=endianness,\nnoise=noise,\n)\n)\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\nclass CustomQuantumModel(QuantumModel):\ndef __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\nsuper().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\nself.n_qubits = circuit.n_qubits\n# define some additional parameters which will scale and shift (variationally) the\n# output of the QuantumModel\n# you can use all torch machinery for building those\nself.scale_out = torch.nn.Parameter(torch.ones(1))\nself.shift_out = torch.nn.Parameter(torch.ones(1))\n# override the forward pass of the model\n# the forward pass is the output of your QuantumModel and in this case\n# it's the (scaled) expectation value of the total magnetization with\n# a variable coefficient in front\ndef forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n# scale the observable\nres = self.expectation(values)\n# scale and shift the result before returning\nreturn self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\ndef quantum_circuit(n_qubits):\nx = Parameter(\"x\", trainable=False)\nfm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\nansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\nansatz = chain(ansatz, CNOT(0, n_qubits-1))\nblock = chain(fm, ansatz)\nblock.tag = \"circuit\"\nreturn QuantumCircuit(n_qubits, block)\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 1.0910],\n[-0.3106],\n[-0.0326],\n[-0.2145],\n[-0.1543],\n[-0.5374],\n[-0.5529],\n[-0.0691],\n[-0.0888],\n[-0.4947]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\ndef __init__(\nself,\ntrain_circuit: QuantumCircuit,\ntarget_circuit: QuantumCircuit,\nbackend=\"pyqtorch\",\n):\nsuper().__init__(circuit=train_circuit, backend=backend)\nself.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\ndef forward(self):\nreturn self.overlap_fn()\n# compute the wavefunction of the associated train circuit\ndef wavefunction(self):\nreturn model.overlap_fn.run({})\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\nmodel = LearnHadamard(train_circuit, target_circuit)\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.5337]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\nloss = criterion(torch.tensor([[1.0]]), model())\nreturn loss, {}\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\nmodel, None, optimizer, config, loss_fn=loss_fn\n)\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\nhamiltonian_factory, QuantumCircuit,\nQuantumModel, BackendName, DiffMode)\nimport torch\nn_qubits = 2\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\nbackend=BackendName.PYQTORCH,\ndiff_mode=DiffMode.GPSR)\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\nexp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\nexp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\nexp_val_ad.detach().numpy(),\nlabel=\"f(x)\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_ad.detach().numpy(),\nlabel=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\ndexpval_x_gpsr.detach().numpy(),\ns=5,\nlabel=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-11-13T15:11:36.530165 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n\"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit and an optional observable to their native representation.\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n\"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n    representation.\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting samples.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run a circuit and return the resulting wave function.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting samples.\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1000,\nstate: Tensor | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bit strings.\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n\"\"\"Return as a string the available fields with types of the configuration.\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\nconf_msg = \"\"\nfor _field in fields(self):\nif not _field.name.startswith(\"_\"):\nconf_msg += (\nf\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n)\nreturn conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n\"\"\"Return parameter names for the current backend.\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\nparam_ids: Tuple\n# FIXME: better type hiearchy?\ntypes = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\nif not isinstance(blk, types):\nraise TypeError(f\"Can not infer param name from {type(blk)}\")\nelse:\nif self._use_gate_params:\nparam_ids = tuple(blk.parameters.uuids())\nelse:\nparam_ids = tuple(map(stringify, blk.parameters.expressions()))\nreturn param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\nself, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n\"\"\"Assign numerical values to the circuit parameters.\"\"\"\nif param_values is None:\nreturn circuit.native()\nparams_copy = param_values.copy()\npnames = [p.name for p in circuit.native.parameters]\n# account for fixed parameters\nfor name in param_values.keys():\nif name not in pnames:\nparams_copy.pop(name)\n# make sure that all the parameters are single floats\n# otherwise it won't be accepted by Braket\nnative_params = promote_parameters(params_copy)\n# assign the parameters to the circuit\nassigned_circuit = circuit.native(**native_params)\nreturn assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return a wavefunction in form of a statevector.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Parameters of the circuit (after calling the embedding function on the user-facing parameters).</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The endianness of the wave function.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"\n    Execute the circuit and return a wavefunction in form of a statevector.\n    Arguments:\n        circuit: The circuit that is executed.\n        param_values: Parameters of the circuit (after calling the embedding\n            function on the user-facing parameters).\n        state: Initial state.\n        endianness: The endianness of the wave function.\n    \"\"\"\nif state is not None:\nraise NotImplementedError\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nresults = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\nfinal_circuit.state_vector()  # set simulation type\ntask = self._device.run(final_circuit, 0)\nresults.append(task.result().values[0])\nstates = torch.tensor(np.array(results))\nn_qubits = circuit.abstract.n_qubits\nif endianness != self.native_endianness and n_qubits &gt; 1:\nfrom qadence.transpile import invert_endianness\nstates = invert_endianness(states)\nreturn states\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor] = {},\nn_shots: int = 1,\nstate: Tensor | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\nif state is not None:\nraise NotImplementedError(\"Braket cannot handle a custom initial state.\")\nif n_shots &lt; 1:\nraise ValueError(\"You can only call sample with n_shots&gt;0.\")\nif self.is_remote:\n# handle here, or different backends?\nraise NotImplementedError\n# loop over all values in the batch\nsamples = []\nfor vals in to_list_of_dicts(param_values):\nfinal_circuit = self.assign_parameters(circuit, vals)\ntask = self._device.run(final_circuit, n_shots)\nsamples.append(task.result().measurement_counts)\nif endianness != self.native_endianness:\nfrom qadence.transpile import invert_endianness\nsamples = invert_endianness(samples)\nif noise is not None:\nsamples = apply(noise=noise, samples=samples)\nreturn samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>Module</code></p> <p>A class to abstract the operations done by the autodiff engine.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def __init__(\nself,\nbackend: QuantumBackend,\ndiff_mode: DiffMode = DiffMode.AD,\n**psr_args: int | float | None,\n) -&gt; None:\nsuper().__init__()\nself.backend = backend\nself.diff_mode = diff_mode\nself.psr_args = psr_args\n# TODO: Add differentiable overlap calculation\nself._overlap: Callable = None  # type: ignore [assignment]\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of a given observable.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A backend native observable to compute the expectation value from.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>A dict of values for symbolic substitution.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>An initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>A shot-based measurement protocol.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the state.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A tensor of expectation values.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def expectation(\nself,\ncircuit: ConvertedCircuit,\nobservable: list[ConvertedObservable] | ConvertedObservable,\nparam_values: dict[str, Tensor] = {},\nstate: Tensor | None = None,\nmeasurement: Measurements | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Compute the expectation value of a given observable.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        observable: A backend native observable to compute the expectation value from.\n        param_values: A dict of values for symbolic substitution.\n        state: An initial state.\n        measurement: A shot-based measurement protocol.\n        endianness: Endianness of the state.\n    Returns:\n        A tensor of expectation values.\n    \"\"\"\nobservable = observable if isinstance(observable, list) else [observable]\ndifferentiable_expectation = DifferentiableExpectation(\nbackend=self.backend,\ncircuit=circuit,\nobservable=observable,\nparam_values=param_values,\nstate=state,\nmeasurement=measurement,\nnoise=noise,\nendianness=endianness,\n)\nif self.diff_mode == DiffMode.AD:\nexpectation = differentiable_expectation.ad\nelse:\ntry:\nfns = get_gpsr_fns()\npsr_fn = fns[self.diff_mode]\nexcept KeyError:\nraise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\nexpectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\nreturn expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG)</code>","text":"<p>Run on the underlying backend.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def run(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict = {},\nstate: Tensor | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n\"\"\"Run on the underlying backend.\"\"\"\nreturn self.backend.run(\ncircuit=circuit, param_values=param_values, state=state, endianness=endianness\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableBackend.sample","title":"<code>sample(circuit, param_values, n_shots=1, state=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Sample bitstring from the registered circuit.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A backend native quantum circuit to be executed.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>The values of the parameters after embedding</p> <p> TYPE: <code>dict[str, Tensor]</code> </p> <code>n_shots</code> <p>The number of shots. Defaults to 1.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bitstrings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>An iterable with all the sampled bitstrings</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>def sample(\nself,\ncircuit: ConvertedCircuit,\nparam_values: dict[str, Tensor],\nn_shots: int = 1,\nstate: Tensor | None = None,\nnoise: Noise | None = None,\nendianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n\"\"\"Sample bitstring from the registered circuit.\n    Arguments:\n        circuit: A backend native quantum circuit to be executed.\n        param_values: The values of the parameters after embedding\n        n_shots: The number of shots. Defaults to 1.\n        state: Initial state.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bitstrings.\n    Returns:\n        An iterable with all the sampled bitstrings\n    \"\"\"\nwith torch.no_grad():\nreturn self.backend.sample(\ncircuit=circuit,\nparam_values=param_values,\nstate=state,\nn_shots=n_shots,\nendianness=endianness,\nnoise=noise,\n)\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation","title":"<code>DifferentiableExpectation</code>  <code>dataclass</code>","text":"<p>A handler for differentiating expectation estimation using various engines.</p>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.DifferentiableExpectation.construct_rules","title":"<code>construct_rules(circuit, observable, psr_fn, **psr_args)</code>  <code>staticmethod</code>","text":"<p>Create a mapping between parameters and PSR functions.</p> Source code in <code>qadence/backends/pytorch_wrapper.py</code> <pre><code>@staticmethod\ndef construct_rules(\ncircuit: QuantumCircuit,\nobservable: list[AbstractBlock],\npsr_fn: Callable,\n**psr_args: int | float | None,\n) -&gt; dict[str, Callable]:\n\"\"\"Create a mapping between parameters and PSR functions.\"\"\"\nuuid_to_eigs = uuid_to_eigen(circuit.block)\n# We currently rely on implicit ordering to match the PSR to the parameter,\n# because we want to cache PSRs.\nparam_to_psr = OrderedDict()\nfor param_id, eigenvalues in uuid_to_eigs.items():\nif eigenvalues is None:\nraise ValueError(\nf\"Eigenvalues are not defined for param_id {param_id}\\n\"\n# f\"of type {type(block)}.\\n\"\n\"PSR cannot be defined in that case.\"\n)\nparam_to_psr[param_id] = psr_fn(eigenvalues, **psr_args)\nfor obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\n# We need the embedded fixed params of the observable in the param_values dict\n# to be able to call expectation. Since torch backward requires\n# a list of param_ids and values of equal length, we need to pass them to PSR too.\n# Since they are constants their gradients are 0.\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\nreturn param_to_psr\n</code></pre>"},{"location":"backends/differentiable/#qadence.backends.pytorch_wrapper.PSRExpectation","title":"<code>PSRExpectation</code>","text":"<p>             Bases: <code>Function</code></p> <p>Overloads the PyTorch AD system to perform parameter shift rule on quantum circuits.</p>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register, spacing=DEFAULT_SPACING)</code>","text":"<p>Create Pulser register instance.</p> PARAMETER  DESCRIPTION <code>register</code> <p>graph representing a register with accompanying coordinate data</p> <p> TYPE: <code>Register</code> </p> <code>spacing</code> <p>distance between qubits in micrometers</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_SPACING</code> </p> RETURNS DESCRIPTION <code>Register</code> <p>Pulser register</p> <p> TYPE: <code>Register</code> </p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register, spacing: float = DEFAULT_SPACING) -&gt; PulserRegister:\n\"\"\"Create Pulser register instance.\n    Args:\n        register (Register): graph representing a register with accompanying coordinate data\n        spacing (float): distance between qubits in micrometers\n    Returns:\n        Register: Pulser register\n    \"\"\"\n# create register from coordinates\ncoords = np.array(list(register.coords.values()))\nreturn PulserRegister.from_coordinates(coords * spacing)\n</code></pre>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device","title":"<code>Device</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.IDEALIZED","title":"<code>IDEALIZED = IdealDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.devices.Device.REALISTIC","title":"<code>REALISTIC = RealisticDevice</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\nself, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n\"\"\"Convert an abstract circuit and an optional observable to their native representation.\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\ndef check_observable(obs_obj: Any) -&gt; AbstractBlock:\nif isinstance(obs_obj, QubitOperator):\nfrom qadence.blocks.manipulate import from_openfermion\nassert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\nreturn from_openfermion(obs_obj)\nelif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\nfrom qadence.blocks.utils import block_is_qubit_hamiltonian\nassert block_is_qubit_hamiltonian(\nobs_obj\n), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\nreturn obs_obj\nraise TypeError(\n\"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n)\nconv_circ = self.circuit(circuit)\ncirc_params, circ_embedding_fn = embedding(\nconv_circ.abstract.block, self.config._use_gate_params\n)\nparams = circ_params\nif observable is not None:\nobservable = observable if isinstance(observable, list) else [observable]\nconv_obs = []\nobs_embedding_fn_list = []\nfor obs in observable:\nobs = check_observable(obs)\nc_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\nobs_params, obs_embedding_fn = embedding(\nc_obs.abstract, self.config._use_gate_params\n)\nparams.update(obs_params)\nobs_embedding_fn_list.append(obs_embedding_fn)\nconv_obs.append(c_obs)\ndef embedding_fn_dict(a: dict, b: dict) -&gt; dict:\nembedding_dict = circ_embedding_fn(a, b)\nfor o in obs_embedding_fn_list:\nembedding_dict.update(o(a, b))\nreturn embedding_dict\nreturn Converted(conv_circ, conv_obs, embedding_fn_dict, params)\ndef embedding_fn(a: dict, b: dict) -&gt; dict:\nreturn circ_embedding_fn(a, b)\nreturn Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.interaction","title":"<code>interaction: Callable | Interaction | str = Interaction.NN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital-analog emulation interaction that is used for <code>AnalogBlock</code>s.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compose a chain of single qubit operations on the same qubit.</p> <p>The result is a single call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\nself,\nops: list[Module],\nqubits: Tuple[int, ...],\nn_qubits: int,\nconfig: Configuration = None,\n):\n\"\"\"Compose a chain of single qubit operations on the same qubit.\n    The result is a single call to _apply_batch_gate.\n    \"\"\"\nsuper().__init__()\nself.operations = ops\nself.qubits = qubits\nself.n_qubits = n_qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.ScalePyQOperation","title":"<code>ScalePyQOperation(n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> <p>Computes:</p> <pre><code>M = matrix(op, theta)\nscale * matmul(M, state)\n</code></pre> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(self, n_qubits: int, block: ScaleBlock, config: Configuration):\nsuper().__init__()\n(self.param_name,) = config.get_param_name(block)\nif not isinstance(block.block, PrimitiveBlock):\nraise NotImplementedError(\n\"The pyqtorch backend can currently only scale `PrimitiveBlock` types.\\\n            Please use the following transpile function on your circuit first:\\\n            from qadence.transpile import scale_primitive_blocks_only\"\n)\nself.operation = convert_block(block.block, n_qubits, config)[0]\ndef _fwd(state: Tensor, values: dict[str, Tensor]) -&gt; Tensor:\nreturn values[self.param_name] * self.operation(state, values)\nif config.use_gradient_checkpointing:\ndef _forward(state: Tensor, values: dict[str, Tensor]) -&gt; Tensor:\nreturn checkpoint(_fwd, state, values, use_reentrant=False)\nelse:\ndef _forward(state: Tensor, values: dict[str, Tensor]) -&gt; Tensor:\nreturn _fwd(state, values)\nself._forward = _forward\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Currently, the only implemented differentiation engine is PyTorch but it is easy to add support to another one like Jax.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are implemented by extending the PyTorch autograd engine using custom <code>Function</code> objects. The implementation is based on this PyTorch guide.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\nclass CustomFunction(Function):\n# forward pass implementation giving the output of the module\n@staticmethod\ndef forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\nctx.save_for_backward(inputs, params)\n...\n# backward pass implementation giving the derivative of the module\n# with respect to the parameters. This must return the whole vector-jacobian\n# product to integrate within the autograd engine\n@staticmethod\ndef backward(ctx, grad_output: torch.Tensor):\ninputs, params = ctx.saved_tensors\n...\n</code></pre> <p>The class <code>PSRExpectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\nreturn PSRExpectation.apply(\nctx.expectation_fn,\nctx.param_psrs,\nparams.keys(),\n*params.values(),\n)\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\nfor param_id, _ in uuid_to_eigen(obs).items():\nparam_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\n</code></pre> %3 65a12f3b8e164643b3bd6541d35d2620 0 b323a76738054ac4bbe214be86d9904f X 65a12f3b8e164643b3bd6541d35d2620--b323a76738054ac4bbe214be86d9904f a27be237dfad44209116b810a3ec98d4 1 d7ae3b90c19442d2b847df1b7ff8a4c9 b323a76738054ac4bbe214be86d9904f--d7ae3b90c19442d2b847df1b7ff8a4c9 c867c4328332406e8174af26f239bd2d 1b92f31b140c46e28fdb66be7442f23b Y a27be237dfad44209116b810a3ec98d4--1b92f31b140c46e28fdb66be7442f23b 1b92f31b140c46e28fdb66be7442f23b--c867c4328332406e8174af26f239bd2d <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(0))\n</code></pre> %3 f9914d6b4e2b43e386074b6ed07aede8 0 0bbf67cc2e4442e1a828536f050c50cf X f9914d6b4e2b43e386074b6ed07aede8--0bbf67cc2e4442e1a828536f050c50cf 7cc964c51e56454a80c4ce9cdc6ec0f7 Y 0bbf67cc2e4442e1a828536f050c50cf--7cc964c51e56454a80c4ce9cdc6ec0f7 c6f27cb851b944908b5461f00c05f9da 7cc964c51e56454a80c4ce9cdc6ec0f7--c6f27cb851b944908b5461f00c05f9da <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\nb = chain(X(0), Y(1))\n</code></pre> %3 bc0333f6eb0043038d78e40c00fde192 0 39df74736c614c7687f074da1cb8ecee X bc0333f6eb0043038d78e40c00fde192--39df74736c614c7687f074da1cb8ecee 7576027d7c8246909e177f7a917e4e9c 1 b7325a76491b4b65a06747c798556d91 39df74736c614c7687f074da1cb8ecee--b7325a76491b4b65a06747c798556d91 ecc3961af49c452e8e73ada020968588 b7325a76491b4b65a06747c798556d91--ecc3961af49c452e8e73ada020968588 1a16b4057af74e51a38c96583f88c59e 84186a55cc28436e81bff3199b8a35aa 7576027d7c8246909e177f7a917e4e9c--84186a55cc28436e81bff3199b8a35aa e0ed2f568f224525bff9b66995f44153 Y 84186a55cc28436e81bff3199b8a35aa--e0ed2f568f224525bff9b66995f44153 e0ed2f568f224525bff9b66995f44153--1a16b4057af74e51a38c96583f88c59e <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_7258e7417f204025bb9027d1912d0cf4 95ae882c27ec458297c1b82eddaa113e 0 d4c051a4705d42ac96de21099a3653f0 95ae882c27ec458297c1b82eddaa113e--d4c051a4705d42ac96de21099a3653f0 165580d4ea084860b35dc117a54aec9b 1 90ef100ace0c402099d35c3479b901bd d4c051a4705d42ac96de21099a3653f0--90ef100ace0c402099d35c3479b901bd d16e448cae894d51915a808c5322d9ea 53471acd46d44bb3856e01925241b7d6 AddBlock 165580d4ea084860b35dc117a54aec9b--53471acd46d44bb3856e01925241b7d6 56d15214cb8f4b378e8fc97cde03694a 2 53471acd46d44bb3856e01925241b7d6--d16e448cae894d51915a808c5322d9ea bca88addc9864007bae637451df02764 afb1d6a9ea524388872c58942616a5b6 56d15214cb8f4b378e8fc97cde03694a--afb1d6a9ea524388872c58942616a5b6 afb1d6a9ea524388872c58942616a5b6--bca88addc9864007bae637451df02764 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n# `chain` puts things in sequence\nblock = chain(\nkron(X(0), Y(1), rx),\nCNOT(2,3),\nHamEvo(gen, 10)\n)\n</code></pre> %3 cluster_7e89b60953074b0bb04c9ee270e3277a cluster_02cdea67bdb3476899f2373304644f2a rx 291e1720f4d5421fb89e37d6fc7ab899 0 851b01791db64ee08c26229edc5f6d8c X 291e1720f4d5421fb89e37d6fc7ab899--851b01791db64ee08c26229edc5f6d8c f5d1583d84074315b6bbc19875b65f5c 1 a72b5665e58d4a9893a9f786ac57a596 851b01791db64ee08c26229edc5f6d8c--a72b5665e58d4a9893a9f786ac57a596 5389be42e3c249999b67367b4ec80199 a72b5665e58d4a9893a9f786ac57a596--5389be42e3c249999b67367b4ec80199 9d8bb4a933954a0b9a237d3bc855d8c6 5389be42e3c249999b67367b4ec80199--9d8bb4a933954a0b9a237d3bc855d8c6 657bcfb199d1485e88ed16645e865707 73214d3f8b064c8ba42efdc12cd5be94 Y f5d1583d84074315b6bbc19875b65f5c--73214d3f8b064c8ba42efdc12cd5be94 ea229e5473b24ee0b85e837a8dc84722 2 ba7f5934e3454a258301631f7d6104cc 73214d3f8b064c8ba42efdc12cd5be94--ba7f5934e3454a258301631f7d6104cc be38ce16ebf8492daa835b1b7d5a731b HamEvo ba7f5934e3454a258301631f7d6104cc--be38ce16ebf8492daa835b1b7d5a731b be38ce16ebf8492daa835b1b7d5a731b--657bcfb199d1485e88ed16645e865707 76d560dca51f4cffaf9d7727ffa86062 472fc4847a30401db53d35c87b68b28a RX(x) ea229e5473b24ee0b85e837a8dc84722--472fc4847a30401db53d35c87b68b28a 26ad61221ffe4a10bd4e9afe10aa3b17 3 13e2ab40f2d04b41b40a4d08e41b29d7 472fc4847a30401db53d35c87b68b28a--13e2ab40f2d04b41b40a4d08e41b29d7 01eafac5b45849398ca38f28a0b7943e t = 10 13e2ab40f2d04b41b40a4d08e41b29d7--01eafac5b45849398ca38f28a0b7943e 01eafac5b45849398ca38f28a0b7943e--76d560dca51f4cffaf9d7727ffa86062 8362532cd244477eb1cb249755972adf 0c788357224b4b579ee8d45aa4816a18 RX(0.5) 26ad61221ffe4a10bd4e9afe10aa3b17--0c788357224b4b579ee8d45aa4816a18 b07f8e4d8d1f42a39b1353bc1dd7e26d X 0c788357224b4b579ee8d45aa4816a18--b07f8e4d8d1f42a39b1353bc1dd7e26d b07f8e4d8d1f42a39b1353bc1dd7e26d--13e2ab40f2d04b41b40a4d08e41b29d7 04cd8a3583e143c8b324a89cdd48b14f b07f8e4d8d1f42a39b1353bc1dd7e26d--04cd8a3583e143c8b324a89cdd48b14f 04cd8a3583e143c8b324a89cdd48b14f--8362532cd244477eb1cb249755972adf <pre><code>from qadence import feature_map, hea, chain\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_f7539ff3aeee4e9a9f34a6f0e2970ae1 HEA cluster_5afdc2a91a194efd923909dea2ccf3fe Tower Fourier FM 2d0ee77469d54ea5ab1132f01ddf8890 0 53a2d704267c4a0488341336f333139b RX(1.0*phi) 2d0ee77469d54ea5ab1132f01ddf8890--53a2d704267c4a0488341336f333139b 885726f8c65549b1bc3945ea9948faec 1 e8b533772e5548d381c0036c19ee1c14 RX(theta\u2080) 53a2d704267c4a0488341336f333139b--e8b533772e5548d381c0036c19ee1c14 08115255fadd4001b9e9c8ce4ef2cd23 RY(theta\u2084) e8b533772e5548d381c0036c19ee1c14--08115255fadd4001b9e9c8ce4ef2cd23 2c07784d361d4d799394984cc429cdf6 RX(theta\u2088) 08115255fadd4001b9e9c8ce4ef2cd23--2c07784d361d4d799394984cc429cdf6 01725cfa70d140a58503a7d728b682a7 2c07784d361d4d799394984cc429cdf6--01725cfa70d140a58503a7d728b682a7 90c32d9c824a42f285bf33d873ba676b 01725cfa70d140a58503a7d728b682a7--90c32d9c824a42f285bf33d873ba676b 8b5ddc3aba7b43858c796c17bde1d997 RX(theta\u2081\u2082) 90c32d9c824a42f285bf33d873ba676b--8b5ddc3aba7b43858c796c17bde1d997 39fcab5bcd0c4cc9990457baa189f563 RY(theta\u2081\u2086) 8b5ddc3aba7b43858c796c17bde1d997--39fcab5bcd0c4cc9990457baa189f563 13564ec6bc59430484e8a2ea77903981 RX(theta\u2082\u2080) 39fcab5bcd0c4cc9990457baa189f563--13564ec6bc59430484e8a2ea77903981 34ee1aec2d6647e6afa6d766dfc8e1ff 13564ec6bc59430484e8a2ea77903981--34ee1aec2d6647e6afa6d766dfc8e1ff d6af2fa7325044d7bd83e009c5d3eab0 34ee1aec2d6647e6afa6d766dfc8e1ff--d6af2fa7325044d7bd83e009c5d3eab0 c8d3bbac8a204b1ebf54a9fdab6c79ad d6af2fa7325044d7bd83e009c5d3eab0--c8d3bbac8a204b1ebf54a9fdab6c79ad 75f8217f055548509c076567b6de1cb9 9edf2449dacc4ff584c8331471df953e RX(2.0*phi) 885726f8c65549b1bc3945ea9948faec--9edf2449dacc4ff584c8331471df953e 4f5c38662c8d46baa2dd5168ab459f98 2 43948dbd659f4826896df383bdd0dce1 RX(theta\u2081) 9edf2449dacc4ff584c8331471df953e--43948dbd659f4826896df383bdd0dce1 26e05f1494374c57bd8f2e7d713d79e7 RY(theta\u2085) 43948dbd659f4826896df383bdd0dce1--26e05f1494374c57bd8f2e7d713d79e7 ecc43338db264c1db1ee892c9b82867b RX(theta\u2089) 26e05f1494374c57bd8f2e7d713d79e7--ecc43338db264c1db1ee892c9b82867b df94c6cb6a4e4bc7ac3c90d59eaca511 X ecc43338db264c1db1ee892c9b82867b--df94c6cb6a4e4bc7ac3c90d59eaca511 df94c6cb6a4e4bc7ac3c90d59eaca511--01725cfa70d140a58503a7d728b682a7 1877935a74e14fd980c480c7447a011e df94c6cb6a4e4bc7ac3c90d59eaca511--1877935a74e14fd980c480c7447a011e 0bdd7b42e8a0476a80b567457e55e810 RX(theta\u2081\u2083) 1877935a74e14fd980c480c7447a011e--0bdd7b42e8a0476a80b567457e55e810 1540610f2f09437e8256211235e33864 RY(theta\u2081\u2087) 0bdd7b42e8a0476a80b567457e55e810--1540610f2f09437e8256211235e33864 9d6c9aae96c94e0f8af5a265c6c0dcf0 RX(theta\u2082\u2081) 1540610f2f09437e8256211235e33864--9d6c9aae96c94e0f8af5a265c6c0dcf0 3a6cdf3c8ac8486daf4d6b1e78a9bcd0 X 9d6c9aae96c94e0f8af5a265c6c0dcf0--3a6cdf3c8ac8486daf4d6b1e78a9bcd0 3a6cdf3c8ac8486daf4d6b1e78a9bcd0--34ee1aec2d6647e6afa6d766dfc8e1ff 4bf75f0991554e2c87be75a1ce36d9db 3a6cdf3c8ac8486daf4d6b1e78a9bcd0--4bf75f0991554e2c87be75a1ce36d9db 4bf75f0991554e2c87be75a1ce36d9db--75f8217f055548509c076567b6de1cb9 3c0fa72279ac485da4a5d20d30487a6d 2b1bf0d4e94f44408ad92d0dc94e8085 RX(3.0*phi) 4f5c38662c8d46baa2dd5168ab459f98--2b1bf0d4e94f44408ad92d0dc94e8085 4f840536d731496cbba45ea923189886 3 1b9013282fab46fdadc723a2066cb4ba RX(theta\u2082) 2b1bf0d4e94f44408ad92d0dc94e8085--1b9013282fab46fdadc723a2066cb4ba 12dc4627569c45749a79a453eea1302e RY(theta\u2086) 1b9013282fab46fdadc723a2066cb4ba--12dc4627569c45749a79a453eea1302e 72a17b995396415cb95c9b0a4e92dd2f RX(theta\u2081\u2080) 12dc4627569c45749a79a453eea1302e--72a17b995396415cb95c9b0a4e92dd2f 978615b8d78b4cdbaaf7be9fbbc4ec9f 72a17b995396415cb95c9b0a4e92dd2f--978615b8d78b4cdbaaf7be9fbbc4ec9f 5bc762ca8ad5460ea3b2da78a6fd61c3 X 978615b8d78b4cdbaaf7be9fbbc4ec9f--5bc762ca8ad5460ea3b2da78a6fd61c3 5bc762ca8ad5460ea3b2da78a6fd61c3--1877935a74e14fd980c480c7447a011e d0968c8274a642f184a8e5c8543e1df1 RX(theta\u2081\u2084) 5bc762ca8ad5460ea3b2da78a6fd61c3--d0968c8274a642f184a8e5c8543e1df1 43a5a34ca8b349c7be3b2744621de892 RY(theta\u2081\u2088) d0968c8274a642f184a8e5c8543e1df1--43a5a34ca8b349c7be3b2744621de892 2d303efc79914b47a7154019edb6a386 RX(theta\u2082\u2082) 43a5a34ca8b349c7be3b2744621de892--2d303efc79914b47a7154019edb6a386 30a27a2124704102adfc6c3d6ba5ccda 2d303efc79914b47a7154019edb6a386--30a27a2124704102adfc6c3d6ba5ccda bc0a8788b3754a05a3fca05ef4480d3e X 30a27a2124704102adfc6c3d6ba5ccda--bc0a8788b3754a05a3fca05ef4480d3e bc0a8788b3754a05a3fca05ef4480d3e--4bf75f0991554e2c87be75a1ce36d9db bc0a8788b3754a05a3fca05ef4480d3e--3c0fa72279ac485da4a5d20d30487a6d e8744a001c224069bd9ef8d58f5f4b0b 462db2b462bf41b493b434b2dbb06c33 RX(4.0*phi) 4f840536d731496cbba45ea923189886--462db2b462bf41b493b434b2dbb06c33 10fd1435a4ca4781afd2f8e70d48b6a4 RX(theta\u2083) 462db2b462bf41b493b434b2dbb06c33--10fd1435a4ca4781afd2f8e70d48b6a4 d167390cc9eb419f84ad488b1b59e501 RY(theta\u2087) 10fd1435a4ca4781afd2f8e70d48b6a4--d167390cc9eb419f84ad488b1b59e501 1afc2d8b567a4bd797c8f4fbd0eb90e2 RX(theta\u2081\u2081) d167390cc9eb419f84ad488b1b59e501--1afc2d8b567a4bd797c8f4fbd0eb90e2 d0a14ec759994acda2795cb455d6028a X 1afc2d8b567a4bd797c8f4fbd0eb90e2--d0a14ec759994acda2795cb455d6028a d0a14ec759994acda2795cb455d6028a--978615b8d78b4cdbaaf7be9fbbc4ec9f 8abf101d40e4437897903a8899155cd9 d0a14ec759994acda2795cb455d6028a--8abf101d40e4437897903a8899155cd9 1bfcfc2df09c439db185a819fb04515d RX(theta\u2081\u2085) 8abf101d40e4437897903a8899155cd9--1bfcfc2df09c439db185a819fb04515d b60dd6f0e0e84f39bc4d3ff8500f054f RY(theta\u2081\u2089) 1bfcfc2df09c439db185a819fb04515d--b60dd6f0e0e84f39bc4d3ff8500f054f 612952ff2ea641d995c1f89d29c9c323 RX(theta\u2082\u2083) b60dd6f0e0e84f39bc4d3ff8500f054f--612952ff2ea641d995c1f89d29c9c323 a777c13b849f45b5a838f6e77e968c09 X 612952ff2ea641d995c1f89d29c9c323--a777c13b849f45b5a838f6e77e968c09 a777c13b849f45b5a838f6e77e968c09--30a27a2124704102adfc6c3d6ba5ccda 465dae4b627d49dbb0144b09d10a09ba a777c13b849f45b5a838f6e77e968c09--465dae4b627d49dbb0144b09d10a09ba 465dae4b627d49dbb0144b09d10a09ba--e8744a001c224069bd9ef8d58f5f4b0b <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_0172aa193ded4561bb508f97929cf6af Obs. cluster_59f25a63990a42289dfa355c833cbc41 cluster_37c3c4d2d26f4329b16106bf9e8dd430 HEA 24bd9f599ff647ecaf9dd796d61b0722 0 05e5150ce3c14729b9be7af035b7fba0 RX(theta\u2080) 24bd9f599ff647ecaf9dd796d61b0722--05e5150ce3c14729b9be7af035b7fba0 954dd5c801504673a750182090cf45e0 1 d6ea2b86f802466a87fa3b08fca0b4ce RY(theta\u2083) 05e5150ce3c14729b9be7af035b7fba0--d6ea2b86f802466a87fa3b08fca0b4ce a86b699bbc5e4143902a8fcb652a6ee7 RX(theta\u2086) d6ea2b86f802466a87fa3b08fca0b4ce--a86b699bbc5e4143902a8fcb652a6ee7 5e384763c28a47078933540fb414a8de a86b699bbc5e4143902a8fcb652a6ee7--5e384763c28a47078933540fb414a8de cfbc5d2ab680444bab90a6792b09587b 5e384763c28a47078933540fb414a8de--cfbc5d2ab680444bab90a6792b09587b 6113b7903f7f43c6b5a85499fc8800e8 RX(theta\u2089) cfbc5d2ab680444bab90a6792b09587b--6113b7903f7f43c6b5a85499fc8800e8 94f1f0dae4fa4029ac2f0941fccea3b7 RY(theta\u2081\u2082) 6113b7903f7f43c6b5a85499fc8800e8--94f1f0dae4fa4029ac2f0941fccea3b7 6b0dffc920e44aeb92f2ba086e56c27c RX(theta\u2081\u2085) 94f1f0dae4fa4029ac2f0941fccea3b7--6b0dffc920e44aeb92f2ba086e56c27c 4d76dcdb798f455394711166775a5b82 6b0dffc920e44aeb92f2ba086e56c27c--4d76dcdb798f455394711166775a5b82 8516da1605db4905bb09d71144529803 4d76dcdb798f455394711166775a5b82--8516da1605db4905bb09d71144529803 5ad9a438c4a44868b495ca68b0d74572 8516da1605db4905bb09d71144529803--5ad9a438c4a44868b495ca68b0d74572 7076d7e3b563465e9668506f710f0ba2 5ad9a438c4a44868b495ca68b0d74572--7076d7e3b563465e9668506f710f0ba2 5864c9f6a8ab457aa8ae7699d9b5c107 079fcfae5b2c42c7997e33b121afad4d RX(theta\u2081) 954dd5c801504673a750182090cf45e0--079fcfae5b2c42c7997e33b121afad4d 5d2089294460443191018226b0160b2f 2 622ca6d71e7b4bd1bc3ff1af1d0c2e3d RY(theta\u2084) 079fcfae5b2c42c7997e33b121afad4d--622ca6d71e7b4bd1bc3ff1af1d0c2e3d 448f78b560db4580aa14c464c5c627b3 RX(theta\u2087) 622ca6d71e7b4bd1bc3ff1af1d0c2e3d--448f78b560db4580aa14c464c5c627b3 16f0a736b5744e22b827ee1a245c8951 X 448f78b560db4580aa14c464c5c627b3--16f0a736b5744e22b827ee1a245c8951 16f0a736b5744e22b827ee1a245c8951--5e384763c28a47078933540fb414a8de 979c45ca929d434aaa24201d37e1e2e4 16f0a736b5744e22b827ee1a245c8951--979c45ca929d434aaa24201d37e1e2e4 946923ce41314227af5b8f596750bdf5 RX(theta\u2081\u2080) 979c45ca929d434aaa24201d37e1e2e4--946923ce41314227af5b8f596750bdf5 5a04c52f47d14bae8cfe10ca270b27a6 RY(theta\u2081\u2083) 946923ce41314227af5b8f596750bdf5--5a04c52f47d14bae8cfe10ca270b27a6 3db333a4c1fd42899a0f6f4c88504310 RX(theta\u2081\u2086) 5a04c52f47d14bae8cfe10ca270b27a6--3db333a4c1fd42899a0f6f4c88504310 d8df4929558f439e8b6d6ab4c79e4f28 X 3db333a4c1fd42899a0f6f4c88504310--d8df4929558f439e8b6d6ab4c79e4f28 d8df4929558f439e8b6d6ab4c79e4f28--4d76dcdb798f455394711166775a5b82 8c42dd97d3f7431884e82df43d7313c1 d8df4929558f439e8b6d6ab4c79e4f28--8c42dd97d3f7431884e82df43d7313c1 3b82adbb366d4717ac997ca2a6027189 AddBlock 8c42dd97d3f7431884e82df43d7313c1--3b82adbb366d4717ac997ca2a6027189 3b82adbb366d4717ac997ca2a6027189--5864c9f6a8ab457aa8ae7699d9b5c107 c8d60dc39dc748eeb71c4b3f225bdfc4 a742669411fd48fbb8a917b4d76d5c48 RX(theta\u2082) 5d2089294460443191018226b0160b2f--a742669411fd48fbb8a917b4d76d5c48 ac9e099bbf0f447aa490f0e8f38ee5b8 RY(theta\u2085) a742669411fd48fbb8a917b4d76d5c48--ac9e099bbf0f447aa490f0e8f38ee5b8 1fe9d04aa6dd447c918a4d3401679eb0 RX(theta\u2088) ac9e099bbf0f447aa490f0e8f38ee5b8--1fe9d04aa6dd447c918a4d3401679eb0 20cbfb1ef6744c5db784f261210ee03d 1fe9d04aa6dd447c918a4d3401679eb0--20cbfb1ef6744c5db784f261210ee03d 1d73822038964cd3bfd47c81b83772d6 X 20cbfb1ef6744c5db784f261210ee03d--1d73822038964cd3bfd47c81b83772d6 1d73822038964cd3bfd47c81b83772d6--979c45ca929d434aaa24201d37e1e2e4 fa38d4545c63408d87d6800d6f513df0 RX(theta\u2081\u2081) 1d73822038964cd3bfd47c81b83772d6--fa38d4545c63408d87d6800d6f513df0 df455bc6b6994704997a18abab5c609d RY(theta\u2081\u2084) fa38d4545c63408d87d6800d6f513df0--df455bc6b6994704997a18abab5c609d 55e85233d47f43308b19f700156cebd4 RX(theta\u2081\u2087) df455bc6b6994704997a18abab5c609d--55e85233d47f43308b19f700156cebd4 f5012c49523f4cc0b0e92e59633bfcda 55e85233d47f43308b19f700156cebd4--f5012c49523f4cc0b0e92e59633bfcda c616823bb91141f18d4f4ec2b25f725f X f5012c49523f4cc0b0e92e59633bfcda--c616823bb91141f18d4f4ec2b25f725f c616823bb91141f18d4f4ec2b25f725f--8c42dd97d3f7431884e82df43d7313c1 12f48c3889fa440cb11b130f3c932aa3 c616823bb91141f18d4f4ec2b25f725f--12f48c3889fa440cb11b130f3c932aa3 12f48c3889fa440cb11b130f3c932aa3--c8d60dc39dc748eeb71c4b3f225bdfc4"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\ngraph_attr = {\n\"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n\"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n\"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n\"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\nnode_attr = {\n\"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n\"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n\"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\ndefault_cluster_attr = {\n\"fontname\": font_name,\n\"fontsize\": font_size,\n\"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n\"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\nhamevo_cluster_attr = {\n\"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Add start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\nhamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n# Define start and end nodes\nfor i in range(4):\nh.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\nh.node(f'e{i}', style='invis', group=f\"{i}\")\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n# Define more nodes\nfor i in range(4):\nh.node(f\"b{i}\", group=f\"{i}\")\nfor i in range(4):\nh.edge(f's{i}', f'a{i}')\nh.edge(f'a{i}', f'b{i}')\nh.edge(f'b{i}', f'e{i}')\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and significant changes to the interface should be expected in the near-future. Nevertheless, the currest version serves as a prototype of the functionality, and any feedback is greatly appreciated.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states.</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. In this tutorial we do not use any information regarding the edges of the register graph, only the coordinates of each node that are used to compute the distance \\(r_{ij}\\) in the interaction term. Below, we create a line register of three qubits directly from the coordinates.</p> <pre><code>from qadence import Register\ndx = 8.0  # Atom spacing in \u03bcm\nreg = Register.from_coordinates([(0, 0), (dx, 0), (2*dx, 0)])\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from math import pi\nfrom qadence import AnalogRot\nrot_op = AnalogRot(\nduration = 500., # [ns]\nomega = pi, # [rad/\u03bcs]\ndelta = pi, # [rad/\u03bcs]\nphase = pi, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n-0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run\nfrom qadence.analog.utils import C6_DICT\nfrom math import pi, cos, sin\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n# Parameters used in the AnalogRot\nduration = 500.\nomega = pi\ndelta = pi\nphase = pi\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n# Building the interaction Hamiltonian\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\nh_int = c_6 * (\n1/(dx**6) * (N(0)@N(1)) +\n1/(dx**6) * (N(1)@N(2)) +\n1/((2*dx)**6) * (N(0)@N(2))\n)\nhamiltonian = h_x + h_y + h_n + h_int\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n-0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <p>Warning</p> <p>When using the Pulser backend it is currently advised to always explicitly pass the register spacing in the <code>configuration</code> dictionary, which is a constant that multiplies the coordinates of the register. The passing of register spacing between PyQTorch and Pulser backends is currently inconsistent, and will soon be unified. By disregarding it in PyQTorch and setting it to 1 in Pulser, results should be consistent.</p> <pre><code>wf = run(\nreg,\nrot_op,\nbackend = BackendName.PULSER,\nconfiguration = {\"spacing\": 1.0}  # Ensures the register is not re-scaled\n)\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n-0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run\nfrom math import pi\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0), (2*dx, 0)])\nn_qubits = 3\n# Rotation angle\ntheta = pi\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n# Some random initial state\ninit_state = random_state(n_qubits)\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\nreg,\nrot_analog,\nstate = init_state,\nbackend = BackendName.PYQTORCH\n)\nwf_digital_pyq = run(\nreg,\nrot_digital,\nstate = init_state,\nbackend = BackendName.PYQTORCH\n)\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\nreg,\nrot_analog,\nstate = init_state,\nbackend = BackendName.PULSER,\nconfiguration = {\"spacing\": 1.0}\n)\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>wait</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, wait, run\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0), (2*dx, 0)])\nn_qubits = 3\nduration = 1000.\nop = wait(duration = duration)\ninit_state = random_state(n_qubits)\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER, configuration = {\"spacing\": 1.0})\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#some-technical-details","title":"Some technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but are under revision for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all the Analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>wait</code> operation initializes a <code>WaitBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = \"global\"</code>. However, the blocks do support local qubit supports, with some constraints. The main constraint is that using <code>kron</code> on operators with different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\ntry:\nblock = kron(rot_0, rot_1)\nexcept ValueError as error:\nprint(\"Error:\", error)\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block:</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, wait\nfrom sympy import acos\n# Line register\nn_qubits = 2\ndx = 8.0  # Atom spacing in \u03bcm\ncoordinates = [(i*dx, 0) for i in range(n_qubits)]\nregister = Register.from_coordinates(coordinates)\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n# Feature map with a few global analog rotations\nfm = chain(\nAnalogRX(x),\nAnalogRY(2*x),\nAnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\nAnalogRX(\"tht_0\"),\nAnalogRY(\"tht_1\"),\nAnalogRZ(\"tht_2\"),\nwait(t_0),\nAnalogRX(\"tht_3\"),\nAnalogRY(\"tht_4\"),\nAnalogRZ(\"tht_5\"),\nwait(t_1),\nAnalogRX(\"tht_6\"),\nAnalogRY(\"tht_7\"),\nAnalogRZ(\"tht_8\"),\nwait(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\nmodel = QuantumModel(\ncircuit,\nobservable = observable,\nbackend = BackendName.PYQTORCH,\ndiff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n# Function to fit:\ndef f(x):\nreturn x**2\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(x_train, y_train):\nout = model.expectation({\"x\": x_train})\nloss = mse_loss(out.squeeze(), y_train)\nreturn loss\nn_epochs = 200\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_fn(x_train, y_train)\nloss.backward()\noptimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2023-11-13T15:11:40.167835 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>Warning</p> <p>Tutorial to be updated</p> <p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom pulser.devices import Chadoq2\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\ndef qubo_register_coords(Q):\n\"\"\"Compute coordinates for register.\"\"\"\nbitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\ncosts = []\n# this takes exponential time with the dimension of the QUBO\nfor b in bitstrings:\nz = np.array(list(b), dtype=int)\ncost = z.T @ Q @ z\ncosts.append(cost)\nzipped = zip(bitstrings, costs)\nsort_zipped = sorted(zipped, key=lambda x: x[1])\ndef evaluate_mapping(new_coords, *args):\n\"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\nQ, shape = args\nnew_coords = np.reshape(new_coords, shape)\nnew_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\nreturn np.linalg.norm(new_Q - Q)\nshape = (len(Q), 2)\ncosts = []\nnp.random.seed(0)\nx0 = np.random.random(shape).flatten()\nres = minimize(\nevaluate_mapping,\nx0,\nargs=(Q, shape),\nmethod=\"Nelder-Mead\",\ntol=1e-6,\noptions={\"maxiter\": 200000, \"maxfev\": None},\n)\nreturn [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom qadence import add_interaction, chain\nfrom qadence import QuantumModel, QuantumCircuit, AnalogRZ, AnalogRX, Register\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\nz = np.array(list(bitstring), dtype=int)\ncost = z.T @ Q @ z\nreturn cost\n# Cost function.\ndef cost_fn(counter, Q):\ncost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\nreturn cost / sum(counter.values())  # Divide by total samples\n# Weights.\nQ = np.array(\n[\n[-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n[19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n[19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n[5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n[5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n]\n)\n</code></pre> <p>Now, build a weighted register graph from the QUBO definition similarly to what is done in Pulser.</p> <pre><code>reg = Register.from_coordinates(qubo_register_coords(Q))\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70.</p> <pre><code>from qadence.analog.utils import ising_interaction\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\nemulated = add_interaction(\nreg, block, interaction=lambda r, ps: ising_interaction(r, ps, rydberg_level=70)\n)\n</code></pre> <pre><code>emulated = ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u2502   \u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430074584827*t0']]\n\u2502   \u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279670303258*s0']]\n\u2514\u2500\u2500 ChainBlock(0,1,2,3,4)\n\u251c\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['51_1430074584827*t1']]\n\u2514\u2500\u2500 HamEvo(0,1,2,3,4) [params: ['38_8279670303258*s1']]\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(QuantumCircuit(reg, emulated), backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 470, '01000': 89, '00100': 86, '10000': 76, '00001': 74, '00010': 72, '00101': 19, '11000': 18, '10010': 13, '01001': 12, '10100': 12, '00011': 11, '00110': 11, '01100': 8, '10001': 8, '01010': 7, '01101': 3, '10110': 3, '00111': 2, '10011': 2, '11010': 2, '01011': 1, '10101': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\nQ = args[0]\nparam = torch.tensor(param)\nmodel.reset_vparams(param)\nC = model.sample({}, n_shots=1000)[0]\nreturn cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\nres = minimize(\nloss,\nargs=Q,\nx0=np.random.uniform(1, 10, size=2 * layers),\nmethod=\"COBYLA\",\ntol=1e-8,\noptions={\"maxiter\": 20},\n)\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 243, '01011': 200, '00100': 103, '01000': 97, '01001': 82, '00110': 72, '00000': 61, '00001': 33, '00010': 25, '10000': 23, '01010': 16, '00101': 14, '10001': 7, '10011': 7, '01111': 5, '10010': 5, '01101': 4, '00011': 2, '01100': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-11-13T15:11:42.063809 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\nn_qubits = 2\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\nH(1),\ncphase_evo,\nH(1)\n)\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n# Interaction strength.\ng_int = 1.0\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\nfor j in range(i):\ninteraction_list.append(g_int * kron(N(i), N(j)))\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\nn_qubits=3,        # Total number of qubits in the transformation\ngen_target=h_int,  # The target Ising generator\nt_f=torch.pi,      # The target evolution time\ngen_build=h_sys,   # The building block Ising generator to be used\nstrategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\nignore_global_phases=False  # Global phases from mapping between Z and N\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_d793e2c8f22e4ce599767ea3a93e9770 cluster_6725fa266ee04af2ab0455151e067b0c cluster_a7956a3454984014889bc05c71e78754 cluster_940a4713caad430c8e1b53764d3f5006 cluster_0cb93661ae0a4ea59beceebeabbb25d6 cluster_d79bff24d3fb4309bc72958f88ea144e cluster_80c23edca0da4b7094638f8f57b4a383 0efe7d12a623440290d696978b4460f0 0 db09583f81e240659b503887d7adc14f HamEvo 0efe7d12a623440290d696978b4460f0--db09583f81e240659b503887d7adc14f 03e4289d771643c29d8e6f1722378165 1 87d6e53aa7654e5dbb4b677ecc14ceea HamEvo db09583f81e240659b503887d7adc14f--87d6e53aa7654e5dbb4b677ecc14ceea a842870397044db3b2c4677897706551 HamEvo 87d6e53aa7654e5dbb4b677ecc14ceea--a842870397044db3b2c4677897706551 f008d01d38b14daa8d5baffe43f5e31d X a842870397044db3b2c4677897706551--f008d01d38b14daa8d5baffe43f5e31d cfc628768b95465d8891889e02bb67f9 HamEvo f008d01d38b14daa8d5baffe43f5e31d--cfc628768b95465d8891889e02bb67f9 d590b8d3cb9b49f9a4b99ed0632f56ae HamEvo cfc628768b95465d8891889e02bb67f9--d590b8d3cb9b49f9a4b99ed0632f56ae 4e15a1160fb44717b3f459c1b3eee9f0 X d590b8d3cb9b49f9a4b99ed0632f56ae--4e15a1160fb44717b3f459c1b3eee9f0 ee164c7d52c04040960bd2649139fdc6 4e15a1160fb44717b3f459c1b3eee9f0--ee164c7d52c04040960bd2649139fdc6 fa65c955ea0c4a1da16c4398da24e7c2 HamEvo ee164c7d52c04040960bd2649139fdc6--fa65c955ea0c4a1da16c4398da24e7c2 a22821fc0080455499ade96d36ce4d84 HamEvo fa65c955ea0c4a1da16c4398da24e7c2--a22821fc0080455499ade96d36ce4d84 6f0bbb32d5be4beeaa41f6ab6e2fc14f a22821fc0080455499ade96d36ce4d84--6f0bbb32d5be4beeaa41f6ab6e2fc14f 99260559bfd34f08998c968b78a5f472 6f0bbb32d5be4beeaa41f6ab6e2fc14f--99260559bfd34f08998c968b78a5f472 634a111ae967435d8f14b359c868cd4c 5418f3390b4e4c228f5974b97c9316db t = -3.142 03e4289d771643c29d8e6f1722378165--5418f3390b4e4c228f5974b97c9316db affa2a8a1af94f5a84b04d061c938324 2 bd31dfc69882472b93e31453f9abdc96 t = 3.142 5418f3390b4e4c228f5974b97c9316db--bd31dfc69882472b93e31453f9abdc96 05d15a4f3a6d4bdcb77f4ea7d3882b03 t = -3.142 bd31dfc69882472b93e31453f9abdc96--05d15a4f3a6d4bdcb77f4ea7d3882b03 df466fe2727c4ac2aed2f80a858043a4 05d15a4f3a6d4bdcb77f4ea7d3882b03--df466fe2727c4ac2aed2f80a858043a4 df8c3769044c41dab98f99325a70997e t = 1.571 df466fe2727c4ac2aed2f80a858043a4--df8c3769044c41dab98f99325a70997e ec32076d96c441df8892a470e199da1e t = 1.571 df8c3769044c41dab98f99325a70997e--ec32076d96c441df8892a470e199da1e 6362ac13a918424a917fb0a9c693d702 ec32076d96c441df8892a470e199da1e--6362ac13a918424a917fb0a9c693d702 345e0a7446474b92a3196ba22169ec9c X 6362ac13a918424a917fb0a9c693d702--345e0a7446474b92a3196ba22169ec9c a4ee8062ad6d4f93a6feba41095dbd5a t = 1.571 345e0a7446474b92a3196ba22169ec9c--a4ee8062ad6d4f93a6feba41095dbd5a 841a8cb51bfc4c11bf1a32a6004d3d72 t = 1.571 a4ee8062ad6d4f93a6feba41095dbd5a--841a8cb51bfc4c11bf1a32a6004d3d72 fbd666b789fe4c51ac63bdc969cf9dc5 X 841a8cb51bfc4c11bf1a32a6004d3d72--fbd666b789fe4c51ac63bdc969cf9dc5 fbd666b789fe4c51ac63bdc969cf9dc5--634a111ae967435d8f14b359c868cd4c 6870c4eafa3244b9a5ef4bea64d17697 1cba5068ccf141ac89951e22bcacad6f affa2a8a1af94f5a84b04d061c938324--1cba5068ccf141ac89951e22bcacad6f 0a97b2cf4d9a47cf9adab084be0b476f 1cba5068ccf141ac89951e22bcacad6f--0a97b2cf4d9a47cf9adab084be0b476f 33aa46a0a62c4f5e94da2c76749b4f70 0a97b2cf4d9a47cf9adab084be0b476f--33aa46a0a62c4f5e94da2c76749b4f70 101eec0a08114ffb8e5fa31104ccb383 X 33aa46a0a62c4f5e94da2c76749b4f70--101eec0a08114ffb8e5fa31104ccb383 b4102da024c748be88e6a10c8d839725 101eec0a08114ffb8e5fa31104ccb383--b4102da024c748be88e6a10c8d839725 2f333bab415b4934b09da72a6a7bb2d6 b4102da024c748be88e6a10c8d839725--2f333bab415b4934b09da72a6a7bb2d6 4dfaafc277824b09a586107df2db7db7 X 2f333bab415b4934b09da72a6a7bb2d6--4dfaafc277824b09a586107df2db7db7 f869b0e6b9574d59bcf101723e6729d4 X 4dfaafc277824b09a586107df2db7db7--f869b0e6b9574d59bcf101723e6729d4 d34385e90f8e40fd92a3abcc324323c2 f869b0e6b9574d59bcf101723e6729d4--d34385e90f8e40fd92a3abcc324323c2 b9673e5da22d4c1a9bcad2011a5c4392 d34385e90f8e40fd92a3abcc324323c2--b9673e5da22d4c1a9bcad2011a5c4392 417e39bddb254666bf4726f2553591d3 X b9673e5da22d4c1a9bcad2011a5c4392--417e39bddb254666bf4726f2553591d3 417e39bddb254666bf4726f2553591d3--6870c4eafa3244b9a5ef4bea64d17697 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\ncnot_daqc = chain(\nH(j),\ntransformed_ising,\nH(j)\n)\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\nreturn g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=1.0),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_bb8f3740967e40f49c2012e340d248f2 cluster_c6ef3081f3544da0b36402e2e0193e87 40cd6f5fa08f408bad91e42f3a826bbb 0 6671d4791e2641b997bdda1673d4aa81 X 40cd6f5fa08f408bad91e42f3a826bbb--6671d4791e2641b997bdda1673d4aa81 3791209ee7e546df8ab41fc3d457a09b 1 6aa06b2d592949dd9e13d31811865fdd HamEvo 6671d4791e2641b997bdda1673d4aa81--6aa06b2d592949dd9e13d31811865fdd 0dde2d7eb4944eed8ab1d40e3c0a2dfc X 6aa06b2d592949dd9e13d31811865fdd--0dde2d7eb4944eed8ab1d40e3c0a2dfc f6e9184976b448fbad891c317a69a50e 0dde2d7eb4944eed8ab1d40e3c0a2dfc--f6e9184976b448fbad891c317a69a50e 9387895f5275486aae56670bd6f565db HamEvo f6e9184976b448fbad891c317a69a50e--9387895f5275486aae56670bd6f565db f2e61e6f3a6747c39ef2c7692f5bb282 9387895f5275486aae56670bd6f565db--f2e61e6f3a6747c39ef2c7692f5bb282 734004f723db4feebc2271f2a50d6b8d f2e61e6f3a6747c39ef2c7692f5bb282--734004f723db4feebc2271f2a50d6b8d 16117b479cb143bc8fc14053a0c76663 e37094482ea243459a1cdd86baf4161e 3791209ee7e546df8ab41fc3d457a09b--e37094482ea243459a1cdd86baf4161e d5b6a235c86943e297afc72122d64c70 2 2f0443068570411cb0ddb02843866ccc t = -0.500 e37094482ea243459a1cdd86baf4161e--2f0443068570411cb0ddb02843866ccc 83f39928076044c782a0c92fa290d40d 2f0443068570411cb0ddb02843866ccc--83f39928076044c782a0c92fa290d40d 2512b93420c841f1ba19e0764b9df75a X 83f39928076044c782a0c92fa290d40d--2512b93420c841f1ba19e0764b9df75a 898b872982fe491fbcdbc1db4188ae80 t = -0.500 2512b93420c841f1ba19e0764b9df75a--898b872982fe491fbcdbc1db4188ae80 d3c48d84aad2494fb9a7c28555b4a7fd X 898b872982fe491fbcdbc1db4188ae80--d3c48d84aad2494fb9a7c28555b4a7fd d3c48d84aad2494fb9a7c28555b4a7fd--16117b479cb143bc8fc14053a0c76663 2fa821d6ac6a4b4fa0ac5538f66fb255 4da3c336890d4f6391515ee28d1d9878 X d5b6a235c86943e297afc72122d64c70--4da3c336890d4f6391515ee28d1d9878 700295c85cc94d2d8ee8f2c16cee8e12 4da3c336890d4f6391515ee28d1d9878--700295c85cc94d2d8ee8f2c16cee8e12 88d7e39f56ea4501b9f647967b1c67c0 X 700295c85cc94d2d8ee8f2c16cee8e12--88d7e39f56ea4501b9f647967b1c67c0 44ecdc3218bb4858989a35932dcf851b X 88d7e39f56ea4501b9f647967b1c67c0--44ecdc3218bb4858989a35932dcf851b a805fbde57c54307a0ba354672496e6c 44ecdc3218bb4858989a35932dcf851b--a805fbde57c54307a0ba354672496e6c ed28034e7b9346699edaa9c262ae98dc X a805fbde57c54307a0ba354672496e6c--ed28034e7b9346699edaa9c262ae98dc ed28034e7b9346699edaa9c262ae98dc--2fa821d6ac6a4b4fa0ac5538f66fb255 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int=0.001),\n)\n# display(transformed_ising)\n</code></pre> %3 cluster_6db4d99a05bf44aa9fa4db214d962ff9 cluster_de7f75da50e14f448a9676e15783de82 6399add413e64109bc4a4f2089ba2cb9 0 d2e15c63bc274996b6e19166d6310a26 X 6399add413e64109bc4a4f2089ba2cb9--d2e15c63bc274996b6e19166d6310a26 1c84a1c38ca544bcad03336343fc39ad 1 ad6801940cea4b4fb88bff49c65db54a HamEvo d2e15c63bc274996b6e19166d6310a26--ad6801940cea4b4fb88bff49c65db54a 75c6ca0e9be3442cad66dcb465e77e01 X ad6801940cea4b4fb88bff49c65db54a--75c6ca0e9be3442cad66dcb465e77e01 d5ed5e3add3a4fc3bdebfb11e4720436 75c6ca0e9be3442cad66dcb465e77e01--d5ed5e3add3a4fc3bdebfb11e4720436 363e754da18842748ac6feea1df4241d HamEvo d5ed5e3add3a4fc3bdebfb11e4720436--363e754da18842748ac6feea1df4241d c691377042014f659d04b5f7bbde4dba 363e754da18842748ac6feea1df4241d--c691377042014f659d04b5f7bbde4dba e0468a2efd744b528965807eb88c9df0 c691377042014f659d04b5f7bbde4dba--e0468a2efd744b528965807eb88c9df0 bca1eb6f28584cd0947069d2d528cd59 b2eb1021f5fa4037910a56880b53c42d 1c84a1c38ca544bcad03336343fc39ad--b2eb1021f5fa4037910a56880b53c42d d332c91b1c95493c919bc5d89843ada5 2 92a68a609ed547e0803056d06c12becc t = -500.000000000000 b2eb1021f5fa4037910a56880b53c42d--92a68a609ed547e0803056d06c12becc 43d3117ad98746d48de68387e689652c 92a68a609ed547e0803056d06c12becc--43d3117ad98746d48de68387e689652c d82a202186f844c8aff684c26cb26241 X 43d3117ad98746d48de68387e689652c--d82a202186f844c8aff684c26cb26241 e42687ccd11b46c3b81825786f4ad387 t = -500.000000000000 d82a202186f844c8aff684c26cb26241--e42687ccd11b46c3b81825786f4ad387 6199b561274c465d854128c0aaa84240 X e42687ccd11b46c3b81825786f4ad387--6199b561274c465d854128c0aaa84240 6199b561274c465d854128c0aaa84240--bca1eb6f28584cd0947069d2d528cd59 695a3531df8a410da0bf3f1bfc4e4de1 4ec17a9391fc4d15b2b9608f0bd61f03 X d332c91b1c95493c919bc5d89843ada5--4ec17a9391fc4d15b2b9608f0bd61f03 ef06e96cb47548b8a0350d3673bc204c 4ec17a9391fc4d15b2b9608f0bd61f03--ef06e96cb47548b8a0350d3673bc204c 868cc13ff0b34443a222a4d77250c50c X ef06e96cb47548b8a0350d3673bc204c--868cc13ff0b34443a222a4d77250c50c 075b385458e44568922c8f44c2c51f2b X 868cc13ff0b34443a222a4d77250c50c--075b385458e44568922c8f44c2c51f2b 890493a05eff43eaaa7b07cff6a47a69 075b385458e44568922c8f44c2c51f2b--890493a05eff43eaaa7b07cff6a47a69 5be2fd00300c449bb6cd2bf76948d702 X 890493a05eff43eaaa7b07cff6a47a69--5be2fd00300c449bb6cd2bf76948d702 5be2fd00300c449bb6cd2bf76948d702--695a3531df8a410da0bf3f1bfc4e4de1 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\ntransformed_ising = daqc_transform(\nn_qubits=3,\ngen_target=gen_target,\nt_f=1.0,\ngen_build=gen_build(g_int = 0.0),\n)\nexcept ValueError as error:\nprint(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <p><code>python exec=\"off\" source=\"material-block\" html=\"1\" session=\"pulser-basic\" config = {     \"cloud_configuration\": {         \"username\": \"&lt;changeme&gt;\",         \"password\": \"&lt;changeme&gt;\",         \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators         \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`     } }</code></p> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\nbell_state = chain(\nentangle(\"t\", qubit_support=(0,1)),\nRY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.4033156033573492, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Return the final state vector\nfinal_vector = model.run(params)\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7113-0.0206j,  0.0371+0.3066j,  0.0073-0.0535j,  0.6181-0.1157j]])\nsample = Counter({'00': 27, '11': 18, '01': 5})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-11-13T15:11:42.479267 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-11-13T15:11:42.604245 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence.backends.pulser.devices import Device\nregister = Register(2)\ncircuit = QuantumCircuit(register, bell_state)\n# Choose a realistic device\nmodel = QuantumModel(\ncircuit,\nbackend=BackendName.PULSER,\ndiff_mode=DiffMode.GPSR,\nconfiguration={\"device_type\": Device.REALISTIC}\n)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([3*torch.pi/2]),\n}\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '01': 17, '11': 6})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n# Custom entanglement operation.\ndef my_entanglement(duration):\nreturn chain(\nAnalogRY(-torch.pi / 2),\nwait(duration)\n)\nprotocol = chain(\nmy_entanglement(\"t\"),\nRY(0, \"y\"),\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"t\": torch.tensor([383]),  # ns\n\"y\": torch.tensor([torch.pi / 2]),\n}\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-11-13T15:11:43.040298 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\nhea_one_layer = chain(\nkron(RY(0, \"th00\"), RY(1, \"th01\")),\nkron(RX(0, \"th10\"), RX(1, \"th11\")),\nkron(RY(0, \"th20\"), RY(1, \"th21\")),\nentangle(\"t\", qubit_support=(0,1)),\n)\nprotocol = chain(\nfourier_feature_map(1, param=\"x\"),\nhea_one_layer,\nAnalogRX(torch.pi/4)\n)\nregister = Register(2)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\nparams = {\n\"x\": torch.tensor([0.8]), # rad\n\"t\": torch.tensor([900]), # ns\n\"th00\":  torch.rand(1), # rad\n\"th01\":  torch.rand(1), # rad\n\"th10\":  torch.rand(1), # rad\n\"th11\":  torch.rand(1), # rad\n\"th20\":  torch.rand(1), # rad\n\"th21\":  torch.rand(1), # rad\n}\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-11-13T15:11:43.205883 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/rydberg-hea/","title":"Hardware efficient ansatz with restricted addressability","text":"<p>Qadence simplifies the execution of digital-analog workloads on neutral atom quantum computers where the local addressability is restricted.</p> <p>In this regime, which we will refer to as semi-local addressing, the full Hamiltonian of the qubit system realized with neutral atoms comprises the following terms:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\textrm{global}} + \\mathcal{H}_{\\textrm{int}} + \\mathcal{H}_{\\textrm{local}} \\] <p>The first two terms are the standard components of a neutral atom Hamiltonians and read as follows:</p> <p>$$     \\mathcal{H}{\\textrm{global}} = \\frac{\\Omega}{2}\\sum{i}^N \\left(         \\textrm{cos}(\\phi)\\sigma^x_i - \\textrm{sin}(\\phi)\\sigma^y_i \\right) -         \\delta \\sum_{i}^N \\hat{n}i \\     \\mathcal{H}{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j $$ where \\(\\Omega\\) is the Rabi frequency, \\(\\phi\\) the global phase, \\(\\delta\\) the detuning which can all be time-dependent (here omitted for simplicity). The operator \\(\\hat{n}_i = \\frac{1+\\sigma_i^z}{2}\\) is the occupation operator for the Rydberg state. \\(R_i\\) represents instead the spatial coordinates of the i-th qubit.</p> <p>The local addressability term reads instead:</p> \\[     \\mathcal{H}_{\\textrm{local}}(w^{drv}, w^{det}) = \\frac{\\tilde{\\Omega}}{2}\\sum_{i}^N         w_i^{drv}\\left(\\textrm{cos}(\\phi)\\sigma^x_i - \\textrm{sin}(\\phi)\\sigma^y_i \\right) -         \\Delta \\sum_{i}^N w_i^{det} \\hat{n}_i \\] <p>In this Hamiltonian, the local addressing pattern in both Rabi frequency and detuning is determined by the weights \\(w^{drv} = \\{w_i^{drv}\\}\\) and \\(w^{det} = \\{w_i^{det}\\}\\) respectively. These weights are assigned before starting the simulation and they should have a unit sum. Their action is to effectively modulate the amplitude of the local drive/detuning pulses given by \\(\\tilde{\\Omega}\\) and \\(\\Delta\\) which are here considered time-independent for simplicity.</p> <p>Qadence implements the Hamiltonian above in two different flavors of increasing complexity described below.</p>"},{"location":"digital_analog_qc/rydberg-hea/#circuit-constructor","title":"Circuit constructor","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\matchcal{H} = \\mathcal{H}_{\\textrm{local}}(w^{drv}, w^{det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{drv}, w_{j}^{det}) \\] <p>Notice that in real-device implementation, one layer only is usually possible.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\nregister,\nn_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\naddressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\naddressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\ntunable_phase=True, # make the phase \\phi as a variational parameter\n)\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\nansatz_layer = rydberg_hea_layer(\nregister,\ntevo_det,\ntevo_drive,\ntevo_int,\ndetunings=weights_det,\ndrives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as PyQTorch and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/rydberg-hea/#usage-with-digital-analog-emulation","title":"Usage with digital-analog emulation","text":"<p>A full integration with the emulated digital-analog framework for realistic simulations is coming soon.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n\"\"\"The number of qubits in the whole system.\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n\"\"\"The number of qubits the block is acting on.\"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n\"\"\"The indices of the qubit(s) the block is acting on.\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\nself.blocks = (target_block,)\n# using tuple expansion because some control operations could\n# have multiple targets, e.g. CSWAP\nsuper().__init__((*control, *target_block.qubit_support))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n\"\"\"The number of parameters required by the block.\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\npass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\nself.blocks = (target_block,)\nself.parameters = target_block.parameters\nsuper().__init__((*control, target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n\"\"\"Decomposition into purely digital gates.\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\nself.block = block\n# TODO: more meaningful name like `scale`?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nsuper().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\nself._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n\"\"\"A chain of analog blocks.\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\nfor b in blocks:\nif not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\nraise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n\"\"\"Stack analog blocks vertically (i.e. in time).\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nself.blocks = blocks\nself.interaction = interaction\nqubit_support = QubitSupport()\nduration = blocks[0].duration\nfor b in blocks:\nif not isinstance(b, AnalogBlock):\nraise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\nif b.qubit_support == QubitSupport(\"global\"):\nraise ValueError(\"Blocks with global support cannot be kron'ed.\")\nif not qubit_support.is_disjoint(b.qubit_support):\nraise ValueError(\"Make sure blocks act on distinct qubits!\")\nif not np.isclose(evaluate(duration), evaluate(b.duration)):\nraise ValueError(\"Kron'ed blocks have to have same duration.\")\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>Can be used with <code>add_interaction</code>. WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p> <p>Can be used with <code>add_interaction</code>.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\nb = chain(X(0), Y(0))\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n\"\"\"Chain blocks sequentially.\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n    Returns:\n        ChainBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n    b = chain(X(0), Y(0))\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogChain` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_chain(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\nb = kron(X(0), Y(1))\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n\"\"\"Stack blocks vertically.\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n    Returns:\n        KronBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n    b = kron(X(0), Y(1))\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n# ugly hack to use `AnalogKron` if we are dealing only with analog blocks\nif len(args) and all(\nisinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n):\nreturn analog_kron(*args)  # type: ignore[return-value,arg-type]\nreturn _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\nb = add(X(0), Y(0))\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n\"\"\"Sums blocks.\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n    Returns:\n        AddBlock\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n    b = add(X(0), Y(0))\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\nreturn _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\nif len(blocks) == 0:\nraise NotImplementedError(\"Empty KronBlocks not supported\")\nqubit_support = QubitSupport()\nfor b in blocks:\nassert (\nQubitSupportType.GLOBAL,\n) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\nassert qubit_support.is_disjoint(\nb.qubit_support\n), \"Make sure blocks act on distinct qubits!\"\nqubit_support += b.qubit_support\nself.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\nblock = hea(2,2)\nprint(block_to_tensor(block))\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1709+0.3017j, -0.4932-0.4932j, -0.4975-0.2831j, -0.1649-0.1961j],\n[-0.0164-0.4321j,  0.3352+0.2216j, -0.3870-0.4641j, -0.5347+0.0218j],\n[-0.2988-0.5635j, -0.2746-0.4115j,  0.3084+0.2571j, -0.3356-0.2731j],\n[-0.0645-0.5308j, -0.3275+0.0013j, -0.1177-0.3636j,  0.6365+0.2357j]]],\ngrad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n[0, 3]]),\nvalues=tensor([ 2.+0.j, -2.+0.j]),\nsize=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\nblock: AbstractBlock,\nvalues: dict[str, TNumber | torch.Tensor] = {},\nqubit_support: tuple | None = None,\nuse_full_support: bool = True,\ntensor_type: TensorType = TensorType.DENSE,\nendianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n\"\"\"\n    Convert a block into a torch tensor.\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n    block = hea(2,2)\n    print(block_to_tensor(block))\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n# FIXME: default use_full_support to False. In general, it would\n# be more efficient to do that, and make sure that computations such\n# as observables only do the matmul of the size of the qubit support.\nif tensor_type == TensorType.DENSE:\nfrom qadence.blocks import embedding\n(ps, embed) = embedding(block)\nreturn _block_to_tensor_embedded(\nblock, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n)\nelif tensor_type == TensorType.SPARSEDIAGONAL:\nt = block_to_diagonal(block, endianness=endianness)\nindices, values, size = torch.nonzero(t), t[t != 0], len(t)\nindices = torch.stack((indices.flatten(), indices.flatten()))\nreturn torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\nparam: str = \"x\",\nfeature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Exponential fourier feature map.\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\nif feature_range is None:\nfeature_range = (0.0, 2.0**n_qubits)\nsupport = tuple(range(n_qubits)) if support is None else support\nhlayer = kron(H(qubit) for qubit in support)\nrlayer = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=RZ,\nfm_type=BasisSet.FOURIER,\nreupload_scaling=ReuploadScaling.EXP,\nfeature_range=feature_range,\ntarget_range=(0.0, 2 * pi),\n)\nrlayer.tag = None\nreturn tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\nn_qubits: int,\nsupport: tuple[int, ...] | None = None,\nparam: Parameter | str = \"phi\",\nop: RotationTypes = RX,\nfm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\nreupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\nfeature_range: tuple[float, float] | None = None,\ntarget_range: tuple[float, float] | None = None,\nmultiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n\"\"\"Construct a feature map of a given type.\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n# Process input\nif support is None:\nsupport = tuple(range(n_qubits))\nelif len(support) != n_qubits:\nraise ValueError(\"Wrong qubit support supplied\")\nif op not in ROTATIONS:\nraise ValueError(\nf\"Operation {op} not supported. \"\nf\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n)\n# Backwards compatibility\nif fm_type in (\"fourier\", \"chebyshev\", \"tower\"):\nlogger.warning(\n\"Selecting `fm_type` as 'fourier', 'chebyshev' or 'tower' is deprecated. \"\n\"Please use the respective enumerations: 'fm_type = BasisSet.FOURIER', \"\n\"'fm_type = BasisSet.CHEBYSHEV' or 'reupload_scaling = ReuploadScaling.TOWER'.\"\n)\nif fm_type == \"fourier\":\nfm_type = BasisSet.FOURIER\nelif fm_type == \"chebyshev\":\nfm_type = BasisSet.CHEBYSHEV\nelif fm_type == \"tower\":\nfm_type = BasisSet.CHEBYSHEV\nreupload_scaling = ReuploadScaling.TOWER\nif isinstance(param, Parameter):\nfparam = param\nfparam.trainable = False\nelse:\nfparam = FeatureParameter(param)\n# Set feature and target range\nfeature_range = _set_range(fm_type) if feature_range is None else feature_range\ntarget_range = _set_range(fm_type) if target_range is None else target_range\n# Rescale the feature parameter\nscaling = (max(target_range) - min(target_range)) / (max(feature_range) - min(feature_range))\nshift = min(target_range) - min(feature_range) * scaling\nif isclose(scaling, 1.0):\n# So we don't get 1.0 factor in visualization\nscaled_fparam = fparam + shift\nelse:\nscaled_fparam = scaling * fparam + shift\n# Transform feature parameter\nif fm_type == BasisSet.FOURIER:\ntransformed_feature = scaled_fparam\nelif fm_type == BasisSet.CHEBYSHEV:\ntransformed_feature = acos(scaled_fparam)\nelif inspect.isclass(fm_type) and issubclass(fm_type, Function):\ntransformed_feature = fm_type(scaled_fparam)\nelse:\nraise NotImplementedError(\nf\"Feature map type {fm_type} not implemented. Choose an item from the BasisSet \"\nf\"enum: {[bs.name for bs in BasisSet]}, or your own sympy.Function to wrap \"\n\"the given feature parameter with.\"\n)\nbasis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n# Set reupload scaling function\nif callable(reupload_scaling):\nrs_func = reupload_scaling\nrs_tag = \"Custom\"\nelse:\nrs_func = RS_FUNC_DICT.get(reupload_scaling, None)  # type: ignore [call-overload]\nif rs_func is None:\nraise NotImplementedError(\nf\"Reupload scaling {reupload_scaling} not implemented; choose an item from \"\nf\"the ReuploadScaling enum: {[rs.name for rs in ReuploadScaling]}, or your own \"\n\"python function with a single int arg as input and int or float output.\"\n)\nif isinstance(reupload_scaling, ReuploadScaling):\nrs_tag = reupload_scaling.value\nelse:\nrs_tag = reupload_scaling\n# Set overall multiplier\nmultiplier = 1 if multiplier is None else multiplier\n# Build feature map\nop_list = []\nfor i, qubit in enumerate(support):\nop_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\nfm = kron(*op_list)\nfm.tag = rs_tag + \" \" + basis_tag + \" FM\"\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Fourier feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\nFutureWarning,\n)\nfm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\nn_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n\"\"\"Construct a Chebyshev tower feature map.\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\nwarnings.warn(\n\"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\nFutureWarning,\n)\nfm = feature_map(\nn_qubits,\nsupport=support,\nparam=param,\nop=op,\nfm_type=BasisSet.CHEBYSHEV,\nreupload_scaling=ReuploadScaling.TOWER,\n)\nreturn fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\nn_qubits: int,\nn_features: int,\ndepth: int = None,\nansatz: Optional[AbstractBlock] = None,\nfm_pauli: Type[RY] = RY,\nspectrum: str = \"simple\",\nbasis: str = \"fourier\",\nfm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n\"\"\"Helper function to build a qadence QNN quantum circuit.\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\ndepth = n_qubits if depth is None else depth\nidx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\nif fm_strategy == \"parallel\":\n_fm = kron(*idx_fms)\nfm = tag(_fm, tag=\"FM\")\nelif fm_strategy == \"serial\":\nfm_components: list[AbstractBlock] = []\nfor j, fm_idx in enumerate(idx_fms[:-1]):\nfm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\nfm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\nfm_components.extend(fm_component)\nfm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\nfm = chain(*fm_components)  # type: ignore[assignment]\nansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\nreturn [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nstrategy=\"sDAQC\",\noperations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nsupport: tuple[int, ...] = None,\nstrategy: Strategy = Strategy.DIGITAL,\n**strategy_args: Any,\n) -&gt; AbstractBlock:\n\"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nhea_func_dict = {\nStrategy.DIGITAL: hea_digital,\nStrategy.SDAQC: hea_sDAQC,\nStrategy.BDAQC: hea_bDAQC,\nStrategy.ANALOG: hea_analog,\n}\ntry:\nhea_func = hea_func_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nhea_block: AbstractBlock = hea_func(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\n**strategy_args,\n)  # type: ignore\nreturn hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\nperiodic: bool = False,\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\ntry:\nif entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\nraise ValueError(\n\"Please provide a valid two-qubit entangler operation for digital HEA.\"\n)\nexcept TypeError:\nraise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\nperiodic=periodic,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\nn_qubits: int,\ndepth: int = 1,\nparam_prefix: str = \"theta\",\noperations: list[type[AbstractBlock]] = [RX, RY, RX],\nsupport: tuple[int, ...] = None,\nentangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n    It uses step-wise digital-analog computation.\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n# TODO: Add qubit support\nif entangler is None:\nentangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif not block_is_qubit_hamiltonian(entangler):\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nexcept NotImplementedError:\nraise ValueError(\n\"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n)\nrot_list = _rotations_digital(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=param_prefix,\nsupport=support,\noperations=operations,\n)\nent_list = _entanglers_analog(\ndepth=depth,\nparam_prefix=param_prefix,\nentangler=entangler,\n)\nlayers = []\nfor d in range(depth):\nlayers.append(rot_list[d])\nlayers.append(ent_list[d])\nreturn tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, force_update=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>force_update</code> <p>force override register detuning and interaction strengths.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\nn_qubits = 3\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\nn_qubits,\ninteraction = Interaction.XY,\nrandom_strength = True,\n)\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\nregister,\ninteraction = Interaction.NN,\ninteraction_strength = \"theta\"\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\nregister: Register | int,\ninteraction: Interaction | None = None,\ndetuning: TDetuning | None = None,\ninteraction_strength: TArray | str | None = None,\ndetuning_strength: TArray | str | None = None,\nrandom_strength: bool = False,\nforce_update: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    General Hamiltonian creation function.\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        force_update: force override register detuning and interaction strengths.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n        n_qubits = 3\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\nif interaction is None and detuning is None:\nraise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n# If number of qubits is given, creates all-to-all register\nregister = Register(register) if isinstance(register, int) else register\n# Get interaction function\ntry:\nint_fn = INTERACTION_DICT[interaction]  # type: ignore [index]\nexcept (KeyError, ValueError) as error:\nif interaction is None:\npass\nelse:\nraise KeyError(f\"Interaction {interaction} not supported.\")\n# Check single-qubit detuning\nif (detuning is not None) and (detuning not in DETUNINGS):\nraise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n# Pre-process detuning and interaction strengths and update register\nhas_detuning_strength, detuning_strength = _preprocess_strengths(\nregister, detuning_strength, \"nodes\", force_update, random_strength\n)\nhas_interaction_strength, interaction_strength = _preprocess_strengths(\nregister, interaction_strength, \"edges\", force_update, random_strength\n)\nif (not has_detuning_strength) or force_update:\nregister = _update_detuning_strength(register, detuning_strength)\nif (not has_interaction_strength) or force_update:\nregister = _update_interaction_strength(register, interaction_strength)\n# Create single-qubit detunings:\nsingle_qubit_terms: List[AbstractBlock] = []\nif detuning is not None:\nfor node in register.nodes:\nblock_sq = detuning(node)  # type: ignore [operator]\nstrength_sq = register.nodes[node][\"strength\"]\nsingle_qubit_terms.append(strength_sq * block_sq)\n# Create two-qubit interactions:\ntwo_qubit_terms: List[AbstractBlock] = []\nif interaction is not None:\nfor edge in register.edges:\nblock_tq = int_fn(*edge)  # type: ignore [operator]\nstrength_tq = register.edges[edge][\"strength\"]\ntwo_qubit_terms.append(strength_tq * block_tq)\nreturn add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising NN interaction.\"\"\"\nreturn N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"XY interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Heisenberg XYZ interaction.\"\"\"\nreturn X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n\"\"\"Ising ZZ interaction.\"\"\"\nreturn Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\nn_qubits = 3\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\nn_qubits: int,\nsupport: tuple[int, ...] = None,\ninverse: bool = False,\nreverse_in: bool = False,\nswaps_out: bool = False,\nstrategy: Strategy = Strategy.DIGITAL,\ngen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n\"\"\"\n    The Quantum Fourier Transform.\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n        n_qubits = 3\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\nif support is None:\nsupport = tuple(range(n_qubits))\nassert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\nif reverse_in:\nsupport = support[::-1]\nqft_layer_dict = {\nStrategy.DIGITAL: _qft_layer_digital,\nStrategy.SDAQC: _qft_layer_sDAQC,\nStrategy.BDAQC: _qft_layer_bDAQC,\nStrategy.ANALOG: _qft_layer_analog,\n}\ntry:\nlayer_func = qft_layer_dict[strategy]\nexcept KeyError:\nraise KeyError(f\"Strategy {strategy} not recognized.\")\nqft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\nqft_circ = chain(\nlayer_func(\nn_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n)  # type: ignore\nfor layer in qft_layers\n)\nif swaps_out:\nswap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\nqft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\nreturn tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\nregister: qd.Register,\nn_layers: int = 1,\naddressable_detuning: bool = True,\naddressable_drive: bool = False,\ntunable_phase: bool = False,\nadditional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n\"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\nn_qubits = register.n_qubits\nprefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\ndetunings = None\n# add a detuning pattern locally addressing the atoms\nif addressable_detuning:\ndetunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\ndrives = None\n# add a drive pattern locally addressing the atoms\nif addressable_drive:\ndrives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\nphase = None\nif tunable_phase:\nphase = qd.VariationalParameter(\"phase\")\nreturn chain(\nrydberg_hea_layer(\nregister,\nVariationalParameter(f\"At{prefix}_{layer}\"),\nVariationalParameter(f\"Omega{prefix}_{layer}\"),\nVariationalParameter(f\"wait{prefix}_{layer}\"),\ndetunings=detunings,\ndrives=drives,\nphase=phase,\n)\nfor layer in range(n_layers)\n)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\nregister: qd.Register,\ntevo_drive: Parameter | float,\ntevo_det: Parameter | float,\ntevo_wait: Parameter | float,\nphase: Parameter | float | None = None,\ndetunings: list[Parameter] | list[float] | None = None,\ndrives: list[Parameter] | list[float] | None = None,\ndrive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n\"\"\"A single layer of the Rydberg hardware efficient ansatz.\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\nn_qubits = register.n_qubits\ndrive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\ndrive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\ndetuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\ninteraction = hamiltonian_factory(register, qd.Interaction.NN)\n# drive and interaction are not commuting thus they need to be\n# added directly into the final Hamiltonian generator\nif phase is not None:\ngenerator = (\ndrive_scaling * sympy.cos(phase) * drive_x\n- drive_scaling * sympy.sin(phase) * drive_y\n+ interaction\n)\nelse:\ngenerator = drive_scaling * drive_x + interaction\nreturn chain(\nqd.HamEvo(generator, tevo_drive),\n# detuning and interaction are commuting, so they\n# can be ordered arbitrarily and treated separately\nqd.HamEvo(interaction, tevo_wait),\nqd.HamEvo(detuning, tevo_det),\n)\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\nn_qubits = 3\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\ngen_target = 0.1 * (Z(1)@Z(2))\nt_f = 2.0\ntransformed_circuit = daqc_transform(\nn_qubits = n_qubits,\ngen_target = gen_target,\nt_f = t_f,\ngen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\nn_qubits: int,\ngen_target: AbstractBlock,\nt_f: float,\ngen_build: AbstractBlock | None = None,\nzero_tol: float = 1e-08,\nstrategy: Strategy = Strategy.SDAQC,\nignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n\"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n    The result is another fixed 2-body Hamiltonian.\n    Reference for universality of 2-body Hamiltonians:\n    -- https://arxiv.org/abs/quant-ph/0106064\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n    -- https://arxiv.org/abs/1812.03637\n    The transform translates a target weighted generator of the type:\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n    To a circuit using analog evolutions with a fixed building block generator:\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n    where `op = Z` or `op = N`.\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n    Notes:\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n        n_qubits = 3\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n        gen_target = 0.1 * (Z(1)@Z(2))\n        t_f = 2.0\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n##################\n# Input controls #\n##################\nif strategy != Strategy.SDAQC:\nraise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\nif n_qubits == 4:\nraise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\nif gen_build is None:\ngen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\ntry:\nif (not block_is_qubit_hamiltonian(gen_target)) or (\nnot block_is_qubit_hamiltonian(gen_build)\n):\nraise ValueError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\nexcept NotImplementedError:\n# Happens when block_is_qubit_hamiltonian is called on something that is not a block.\nraise TypeError(\n\"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n)\n#####################\n# Generator parsing #\n#####################\ng_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\ng_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n# Get the global phase hamiltonian and single-qubit detuning hamiltonian\nif build_type == GenDAQC.NN:\nh_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\nif target_type == GenDAQC.NN:\nh_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n# Time re-scalings\nif build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\nt_star = t_f / 4.0\nelif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\nt_star = 4.0 * t_f\nelse:\nt_star = t_f\n# Check if target Hamiltonian can be mapped with the build Hamiltonian\nassert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n##################\n# DAQC Transform #\n##################\n# Section III A of https://arxiv.org/abs/1812.03637:\n# Matrix M for the linear system, exemplified in Table I:\nmatrix_M = _build_matrix_M(n_qubits)\n# Linear system mapping interaction ratios -&gt; evolution times.\nt_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n# ZZ-DAQC with ZZ or NN build Hamiltonian\ndaqc_slices = []\nfor m in range(2, n_qubits + 1):\nfor n in range(1, m):\nalpha = _ix_map(n_qubits, n, m)\nt = t_slices[alpha - 1]\nif abs(t) &gt; zero_tol:\nif abs(t) &gt; (1 / (zero_tol**0.5)):\nlogger.warning(\n\"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n)\nx_gates = kron(X(n - 1), X(m - 1))\nanalog_evo = HamEvo(gen_build, t)\n# TODO: Fix repeated X-gates\nif build_type == GenDAQC.NN:\n# Local detuning at each DAQC layer for NN build Hamiltonian\nsq_detuning_build = HamEvo(h_sq_build, t)\ndaqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\nelif build_type == GenDAQC.ZZ:\ndaqc_slices.append(chain(x_gates, analog_evo, x_gates))\ndaqc_circuit = chain(*daqc_slices)\n########################\n# Phases and Detunings #\n########################\nif target_type == GenDAQC.NN:\n# Local detuning given a NN target Hamiltonian\nsq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\ndaqc_circuit = chain(sq_detuning_target, daqc_circuit)\nif not ignore_global_phases:\nif build_type == GenDAQC.NN:\n# Constant global phase given a NN build Hamiltonian\nglobal_phase_build = HamEvo(h_phase_build, t_slices.sum())\ndaqc_circuit = chain(global_phase_build, daqc_circuit)\nif target_type == GenDAQC.NN:\n# Constant global phase and given a NN target Hamiltonian\nglobal_phase_target = HamEvo(h_phase_target, t_f).dagger()\ndaqc_circuit = chain(global_phase_target, daqc_circuit)\nreturn daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\nbasis: str,\nfm_pauli: Type[RY],\nfm_strategy: str,\nn_features: int,\nn_qubits: int,\nspectrum: str,\n) -&gt; list[KronBlock]:\n\"\"\"Builds the index feature maps based on the given parameters.\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\nidx_fms = []\nfor i in range(n_features):\ntarget_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\nparam = FeatureParameter(f\"x{i}\")\nblock = kron(\n*[\nfm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\nfor j, qubit in enumerate(target_qubits)\n]\n)\nidx_fm = block\nidx_fms.append(idx_fm)\nreturn idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n\"\"\"Converts a spectrum string, e.g. tower or exponential.\n    The result is the correct generator prefactor.\n    \"\"\"\nspectrum = spectrum.lower()\nconversion_dict: dict[str, float | int] = {\n\"simple\": 1,\n\"tower\": qubit_index + 1,\n\"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n}\nreturn conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n\"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n    Returns:\n        List[int]: The list of target qubits.\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\nif fm_strategy == \"parallel\":\nn_qubits_per_feature = int(n_qubits / n_features)\ntarget_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\nelif fm_strategy == \"serial\":\ntarget_qubits = range(0, n_qubits)\nelse:\nraise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\nreturn target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\nx: Any,\nqcd: QuantumCircuitDiagram | Cluster | None = None,\nlayout: str = \"LR\",\ntheme: str = \"light\",\nfill: bool = True,\n**kwargs: Any,\n) -&gt; Graph:\n\"\"\"Display a block, circuit, or quantum model.\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\nreturn make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\nmake_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\nobservable: Union[list[AbstractBlock], AbstractBlock],\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\ndiff_mode: Union[DiffMode, str, None] = None,\nnoise: Union[Noise, None] = None,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\nraise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Tensor = None,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n\"\"\"Convenience wrapper for the `QuantumModel.run` method.\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n    Returns:\n        A wavefunction\n    \"\"\"\nraise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\nx: Union[QuantumCircuit, AbstractBlock, Register, int],\n*args: Any,\nvalues: dict = {},\nstate: Union[Tensor, None] = None,\nn_shots: int = 100,\nbackend: BackendName = BackendName.PYQTORCH,\nendianness: Endianness = Endianness.BIG,\nnoise: Union[Noise, None] = None,\nconfiguration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n\"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\nraise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f002d082b00&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f002d083c70&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n\"\"\"Retrieve all trainable model parameters in a single vector.\n    Args:\n        model (Module): the input PyTorch model\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\nps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\nreturn torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n\"\"\"Return the total number of parameters of the given model.\"\"\"\nreturn len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n\"\"\"Set all trainable parameters of a model from a single vector.\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\nwith torch.no_grad():\nidx = 0\nfor ps in model.parameters():\nif ps.requires_grad:\nn = torch.numel(ps)\nif ps.ndim == 0:\nps[()] = theta[idx : idx + n]\nelse:\nps[:] = theta[idx : idx + n].reshape(ps.size())\nidx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\nmodel: Module,\noptimizer: Optimizer,\nloss_fn: Callable,\nxs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n\"\"\"Default Torch optimize step with closure.\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\nloss, metrics = None, {}\ndef closure() -&gt; Any:\n# NOTE: We need the nonlocal as we can't return a metric dict and\n# because e.g. LBFGS calls this closure multiple times but for some\n# reason the returned loss is always the first one...\nnonlocal metrics, loss\noptimizer.zero_grad()\nloss, metrics = loss_fn(model, xs)\nloss.backward(retain_graph=True)\nreturn loss.item()\noptimizer.step(closure)\n# return the loss/metrics that are being mutated inside the closure...\nreturn loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n## lets prepare the train routine\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: Union[None, DataLoader, DictDataLoader],\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\"\"\"Runs the training loop with gradient-based optimizer.\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n    ## lets prepare the train routine\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n## Training\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if dataloader is not None else None\n# outer epoch loop\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\ntry:\n# in case there is not data needed by the model\n# this is the case, for example, of quantum models\n# which do not have classical input data (e.g. chemistry)\nif dataloader is None:\nloss, metrics = optimize_step(model, optimizer, loss_fn, None)\nloss = loss.item()\nelif isinstance(dataloader, (DictDataLoader, DataLoader)):\ndata = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\nloss, metrics = optimize_step(model, optimizer, loss_fn, data)\nelse:\nraise NotImplementedError(\nf\"Unsupported dataloader type: {type(dataloader)}. \"\n\"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n)\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nexcept KeyboardInterrupt:\nprint(\"Terminating training gracefully after the current iteration.\")\nbreak\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\nmodel: Module,\ndataloader: DictDataLoader | DataLoader | None,\noptimizer: NGOptimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n\"\"\"Runs the training loop with a gradient-free optimizer.\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\nlogger.debug(f\"Loaded model and optimizer from {config.folder}\")\ndef _update_parameters(\ndata: Tensor | None, ng_params: ng.p.Array\n) -&gt; tuple[float, dict, ng.p.Array]:\nloss, metrics = loss_fn(model, data)  # type: ignore[misc]\noptimizer.tell(ng_params, float(loss))\nng_params = optimizer.ask()  # type: ignore [assignment]\nparams = promote_to_tensor(ng_params.value, requires_grad=False)\nset_parameters(model, params)\nreturn loss, metrics, ng_params\nassert loss_fn is not None, \"Provide a valid loss function\"\n# TODO: support also Scipy optimizers\nassert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\n# set optimizer configuration and initial parameters\noptimizer.budget = config.max_iter\noptimizer.enable_pickling()\n# TODO: Make it GPU compatible if possible\nparams = get_parameters(model).detach().numpy()\nng_params = ng.p.Array(init=params)\n# serial training\n# TODO: Add a parallelization using the num_workers argument in Nevergrad\nprogress = Progress(\nTextColumn(\"[progress.description]{task.description}\"),\nBarColumn(),\nTaskProgressColumn(),\nTimeRemainingColumn(elapsed_when_finished=True),\n)\nwith progress:\ndl_iter = iter(dataloader) if dataloader is not None else None\nfor iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\nif dataloader is None:\nloss, metrics, ng_params = _update_parameters(None, ng_params)\nelif isinstance(dataloader, (DictDataLoader, DataLoader)):\ndata = next(dl_iter)  # type: ignore[arg-type]\nloss, metrics, ng_params = _update_parameters(data, ng_params)\nelse:\nraise NotImplementedError(\"Unsupported dataloader type!\")\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nif iteration &gt;= init_iter + config.max_iter:\nbreak\n## Final writing and stuff\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.4065, 0.8547]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n\"\"\"Randomly sample points from the first dimension of the given tensors.\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\nself.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.5520, 0.5128, 0.8844, 0.3853, 0.1138]), tensor([0.7267, 0.4795, 0.8860, 0.1588, 0.1412]), tensor([0.4323, 0.2156, 0.6628, 0.0107, 0.0522])]\n[tensor([0.1679, 0.2914, 0.0584, 0.0124, 0.3985]), tensor([0.8215, 0.9256, 0.2762, 0.3432, 0.2289]), tensor([0.5735, 0.7052, 0.1925, 0.1755, 0.1534])]\n[tensor([0.5520, 0.5128, 0.8844, 0.3853, 0.1138]), tensor([0.7267, 0.4795, 0.8860, 0.1588, 0.1412]), tensor([0.4323, 0.2156, 0.6628, 0.0107, 0.0522])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n\"\"\"Convert torch tensors an (infinite) Dataloader.\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\nds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\nreturn DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\na11 = 0.5 * (Z(control) - I(control))\na22 = -0.5 * (Z(target) + I(target))\na12 = 0.5 * (chain(X(control), Z(control)) + X(control))\na21 = 0.5 * (chain(Z(target), X(target)) + X(target))\nself.generator = (\nkron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n)\nsuper().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nself.generator = kron((I(control) - Z(control)) * 0.5, X(target) - I(target))\nsuper().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\nsuper().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n# TODO: should we give them more meaningful names? like 'angle'?\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = X(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Y(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\nself.parameters = (\nparameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n)\nself.generator = Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ncontrol: int,\ntarget: int,\nparameter: Parameter | TNumber | sympy.Expr | str,\n):\nsuper().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\nself.parameters = ParamMap(parameter=parameter)\nself.generator = I(target) - Z(target)\nsuper().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1804-4.2794e-17j, -0.6272+2.2739e-17j],\n[ 1.0007-2.3573e-18j, -0.0385+9.0640e-20j]])\ntensor([[1.6181-0.0440j, 0.2614-0.1383j],\n[1.3914-0.0214j, 0.1634-0.0779j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\nself,\ngenerator: Union[TGenerator, AbstractBlock],\nparameter: TParameter,\nqubit_support: tuple[int, ...] = None,\n):\ngen_exprs = {}\nif qubit_support is None and not isinstance(generator, AbstractBlock):\nraise ValueError(\"You have to supply a qubit support for non-block generators.\")\nsuper().__init__(qubit_support if qubit_support else generator.qubit_support)\nif isinstance(generator, AbstractBlock):\nqubit_support = generator.qubit_support\nif generator.is_parametric:\ngen_exprs = {str(e): e for e in expressions(generator)}\nelif isinstance(generator, torch.Tensor):\nmsg = \"Please provide a square generator.\"\nif len(generator.shape) == 2:\nassert generator.shape[0] == generator.shape[1], msg\nelif len(generator.shape) == 3:\nassert generator.shape[1] == generator.shape[2], msg\nassert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\nelse:\nraise TypeError(\n\"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n)\ngen_exprs = {str(generator.__hash__()): generator}\nelif isinstance(generator, (sympy.Basic, sympy.Array)):\ngen_exprs = {str(generator): generator}\nelse:\nraise TypeError(\nf\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n)\nps = {\"parameter\": Parameter(parameter), **gen_exprs}\nself.parameters = ParamMap(**ps)\nself.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n\"\"\"Decompose the Hamiltonian evolution into digital gates.\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n# psi(t) = exp(-i * H * t * psi0)\n# psi(t) = exp(-i * lambda * t * psi0)\n# H = sum(Paulin) + sum(Pauli1*Pauli2)\nlogger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\nblocks = []\n# how to change the type/dict to enum effectively\n# when there is a term including non-commuting matrices use st2 or st4\n# 1) should check that the given generator respects the constraints\n# single-qubit gates\nassert isinstance(\nself.generator, AbstractBlock\n), \"Only a generator represented as a block can be decomposed\"\nif block_is_qubit_hamiltonian(self.generator):\ntry:\nblock_is_commuting_hamiltonian(self.generator)\napproximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\nexcept TypeError:\nlogger.warning(\n\"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n)\nblocks.extend(\nlie_trotter_suzuki(\nblock=self.generator,\nparameter=self.parameters.parameter,\norder=LTSOrder[approximation],\n)\n)\n# 2) return an AbstractBlock instance with the set of gates\n# resulting from the decomposition\nreturn chain(*blocks)\nelse:\nraise NotImplementedError(\n\"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\nrydberg_ising_hamiltonian_generator = (\n4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n+ (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(control)\n+ (1.0 + np.sqrt(5.0) / 3) * Z(target)\n)\nsuper().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global')</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog X rotation.\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=0)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global')</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Y rotation.\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nreturn _analog_rot(angle, qubit_support, phase=-np.pi / 2)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global')</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\nangle: float | str | Parameter,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nalpha = _cast(Parameter, angle)\ndelta = np.pi\nduration = alpha / delta * 1000\nps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=0.0)\nreturn ConstantAnalogRotation(qubit_support=q, parameters=ps)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global')</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\nduration: float | str | Parameter = 1000.0,\nomega: float | str | Parameter = 0,\ndelta: float | str | Parameter = 0,\nphase: float | str | Parameter = 0,\nqubit_support: str | QubitSupport | Tuple = \"global\",\n) -&gt; ConstantAnalogRotation:\n\"\"\"General analog rotation operation.\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nif isinstance(duration, str):\nduration = Parameter(duration)\nalpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000  # type: ignore [operator]\nps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\nreturn ConstantAnalogRotation(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global')</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\nduration: TNumber | sympy.Basic,\nqubit_support: str | QubitSupport | tuple = \"global\",\n) -&gt; WaitBlock:\n\"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n    Returns:\n        a `WaitBlock`\n    \"\"\"\nq = _cast(QubitSupport, qubit_support)\nps = ParamMap(duration=duration)\nreturn WaitBlock(parameters=ps, qubit_support=q)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['c6db1b1f-f5c2-494e-915e-034a65896b66', '9017a3f6-b314-4f9f-a426-6b0e0ec32b65'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\nself._name_dict: dict[str, tuple[str, Basic]] = {}\nself._uuid_dict: dict[str, str] = {}\nfor name, v in kwargs.items():\nparam = v if isinstance(v, sympy.Basic) else Parameter(v)\nuuid = str(uuid4())\nself._name_dict[name] = (uuid, param)\nself._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.7043476796040012\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\ncls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n\"\"\"\n    Arguments:\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\np: Parameter\nif isinstance(name, get_args(TNumber)):\nreturn sympify(name)\nelif isinstance(name, Tensor):\nif name.numel() == 1:\nreturn sympify(name)\nelse:\nreturn Array(name.detach().numpy())\nelif isinstance(name, Parameter):\np = super().__new__(cls, name.name, **assumptions)\np.name = name.name\np.trainable = name.trainable\np.value = name.value\nreturn p\nelif isinstance(name, (Basic, Expr)):\nif name.is_number:\nreturn sympify(evaluate(name))\nreturn name\nelif isinstance(name, str):\np = super().__new__(cls, name, **assumptions)\np.trainable = assumptions.get(\"trainable\", True)\np.value = assumptions.get(\"value\", None)\nif p.value is None:\np.value = rand(1).item()\nreturn p\nelse:\nraise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\nreturn Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n\"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\nreturn Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\nexpr = Parameter(\"x\") * Parameter(\"y\")\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.11942186246998064\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\nres: Basic\nres_value: TNumber | Tensor\nquery: dict[Parameter, TNumber | Tensor] = {}\nif isinstance(expr, Array):\nreturn Tensor(expr.tolist())\nelse:\nif not expr.is_number:\nfor s in expr.free_symbols:\nif s.name in values.keys():\nquery[s] = values[s.name]\nelif hasattr(s, \"value\"):\nquery[s] = s.value\nelse:\nraise ValueError(f\"No value provided for symbol {s.name}\")\nif as_torch:\nres_value = torchify(expr)(**{s.name: tensor(v) for s, v in query.items()})\nelse:\nres = expr.subs(query)\nres_value = sympy_to_numeric(res)\nreturn res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\nparam: Expr,\n) -&gt; TNumber | Tensor | Expr:\n\"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\nreturn param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.torchify","title":"<code>torchify(expr)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\n</code></pre> RETURNS DESCRIPTION <code>SymPyModule</code> <p>A torchified, differentiable Expression.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def torchify(expr: Expr) -&gt; SymPyModule:\n\"\"\"\n    Arguments:\n        expr: An expression consisting of Parameters.\n    Returns:\n        A torchified, differentiable Expression.\n    \"\"\"\nextra_funcs = {sympy.core.numbers.ImaginaryUnit: 1.0j}\nreturn SymPyModule(expressions=[sympy.N(expr)], extra_funcs=extra_funcs)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False)</code>","text":"<p>Construct embedding function.</p> <p>It maps user-facing parameters to either expression-level parameters or gate-level parameters. The construced embedding function has the signature:</p> <pre><code> embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\nblock: AbstractBlock, to_gate_params: bool = False\n) -&gt; tuple[StrTensorDict, Callable[[StrTensorDict, StrTensorDict], StrTensorDict],]:\n\"\"\"Construct embedding function.\n    It maps user-facing parameters to either *expression-level*\n    parameters or *gate-level* parameters. The construced embedding function has the signature:\n         embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\nunique_expressions = unique(expressions(block))\nunique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\nunique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\nunique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n# NOTE\n# there are 3 kinds of parameters in qadence\n# - non-trainable which are considered as inputs for classical data\n# - trainable which are the variational parameters to be optimized\n# - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n#\n# both non-trainable and trainable parameters can have the same element applied\n# to different operations in the quantum circuit, e.g. assigning the same parameter\n# to multiple gates.\nnon_numeric_symbols = [p for p in unique_symbols if not p.is_number]\ntrainable_symbols = [p for p in non_numeric_symbols if p.trainable]\nconstant_expressions = [expr for expr in unique_expressions if expr.is_number]\n# we dont need to care about constant symbols if they are contained in an symbolic expression\n# we only care about gate params which are ONLY a constant\nembeddings: dict[sympy.Expr, sympytorch.SymPyModule] = {\nexpr: torchify(expr) for expr in unique_expressions if not expr.is_number\n}\nuuid_to_expr = uuid_to_expression(block)\ndef embedding_fn(params: StrTensorDict, inputs: StrTensorDict) -&gt; StrTensorDict:\nembedded_params: dict[sympy.Expr, Tensor] = {}\nfor expr, fn in embeddings.items():\nangle: Tensor\nvalues = {}\nfor symbol in expr.free_symbols:\nif symbol.name in inputs:\nvalue = inputs[symbol.name]\nelif symbol.name in params:\nvalue = params[symbol.name]\nelse:\nmsg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\nraise KeyError(\nf\"{msg_trainable} parameter '{symbol.name}' not found in the \"\nf\"inputs list: {list(inputs.keys())} nor the \"\nf\"params list: {list(params.keys())}.\"\n)\nvalues[symbol.name] = value\nangle = fn(**values)\n# do not reshape parameters which are multi-dimensional\n# tensors, such as for example generator matrices\nif not len(angle.squeeze().shape) &gt; 1:\nangle = angle.reshape(-1)\nembedded_params[expr] = angle\nfor e in constant_expressions + unique_const_matrices:\nembedded_params[e] = params[stringify(e)]\nif to_gate_params:\ngate_lvl_params: StrTensorDict = {}\nfor uuid, e in uuid_to_expr.items():\ngate_lvl_params[uuid] = embedded_params[e]\nreturn gate_lvl_params\nelse:\nreturn {stringify(k): v for k, v in embedded_params.items()}\nparams: StrTensorDict\nparams = {p.name: torch.tensor([p.value], requires_grad=True) for p in trainable_symbols}\nparams.update(\n{\nstringify(expr): torch.tensor([evaluate(expr)], requires_grad=False)\nfor expr in constant_expressions\n}\n)\nparams.update(\n{\nstringify(expr): torch.tensor(\nnp.array(expr.tolist(), dtype=np.cdouble), requires_grad=False\n)\nfor expr in unique_const_matrices\n}\n)\nreturn params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n\"\"\"\n    Arguments:\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\nself.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\nself.register = Register(support) if isinstance(support, int) else support\nglobal_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\nif not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\nraise ValueError(\nf\"Register with {self.register.n_qubits} qubits is too small for the \"\nf\"given block with {self.block.n_qubits} qubits\"\n)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n\"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\nreturn QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n\"\"\"Extract one or more blocks using the human-readable tag.\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n    Args:\n        tag (str): the tag to look for\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\ndef _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\nblocks = []\nif block.tag == tag:\nblocks += [block]\nif isinstance(block, CompositeBlock):\nblocks += flatten(*[_get_block(b) for b in block.blocks])\nreturn blocks\nreturn _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n\"\"\"Extract all parameters for primitive blocks in the circuit.\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\nreturn parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <p>Examples: <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(self, support: nx.Graph | int):\n\"\"\"A 2D register of qubits which includes their coordinates.\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\nself.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits, spacing=1.0)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int, spacing: float = 1.0) -&gt; nx.Graph:\n\"\"\"Create graph representing linear lattice.\n    Args:\n        n_qubits (int): number of nodes in the graph\n    Returns:\n        graph instance\n    \"\"\"\ngraph = nx.Graph()\nfor i in range(n_qubits):\ngraph.add_node(i, pos=(i * spacing, 0.0))\nfor i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\ngraph.add_edge(i, j)\nreturn graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ca3efb8d-ec82-421a-9242-bf1f541c7323', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.789175520652516'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('73fe2237-370d-4d05-bf05-63d1cc4ed75e', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.41066690020480434'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('754b0cdd-c4b5-40ce-a846-a360a807c842', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.7262773469971591'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('82295911-5060-41a8-8db7-8511a14b4c31', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.9592730319839947'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3dff25ce-25ba-4dd4-9031-4be081d698eb', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.29853362350562773'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('39e76275-3a4b-43a7-b6b8-220b0e87d393', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.8358036266838368'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nobj: Any\nif d.get(\"expression\"):\nexpr = eval(d[\"expression\"])\nif hasattr(expr, \"free_symbols\"):\nfor symb in expr.free_symbols:\nsymb.value = float(d[\"symbols\"][symb.name][\"value\"])\nobj = expr\nelif d.get(\"QuantumModel\"):\nobj = QuantumModel._from_dict(d, as_torch)\nelif d.get(\"QNN\"):\nobj = QNN._from_dict(d, as_torch)\nelif d.get(\"TransformedModule\"):\nobj = TransformedModule._from_dict(d, as_torch)\nelif d.get(\"block\") and d.get(\"register\"):\nobj = QuantumCircuit._from_dict(d)\nelif d.get(\"graph\"):\nobj = Register._from_dict(d)\nelif d.get(\"type\"):\nif d[\"type\"] in ALL_BLOCK_NAMES:\nblock: AbstractBlock = (\ngetattr(operations, d[\"type\"])._from_dict(d)\nif hasattr(operations, d[\"type\"])\nelse getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n)\nif d[\"tag\"] is not None:\nblock = tag(block, d[\"tag\"])\nobj = block\nelse:\nimport warnings\nmsg = warnings.warn(\n\"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n)\ntry:\nmodule_name = list(d.keys())[0]\nobj = getattr(globals(), module_name)\nobj.load_state_dict(d[module_name])\nexcept Exception as e:\nlogger.error(\nTypeError(\nf\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n)\n)\nreturn obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nd = {}\nif isinstance(file_path, str):\nfile_path = Path(file_path)\nif not os.path.exists(file_path):\nlogger.error(f\"File {file_path} not found.\")\nraise FileNotFoundError\nFORMAT = file_extension(file_path)\n_, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\ntry:\nd = load_fn(file_path, map_location)\nlogger.debug(f\"Successfully loaded {d} from {file_path}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to load Object from {file_path} due to {e}\")\nreturn deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\nobj: SUPPORTED_TYPES,\nfolder: str | Path,\nfile_name: str = \"\",\nformat: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n\"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(f\"Serialization of object type {type(obj)} not supported.\")\nfolder = Path(folder)\nif not folder.is_dir():\nlogger.error(NotADirectoryError)\nif file_name == \"\":\nfile_name = type(obj).__name__\ntry:\nsuffix, save_fn, _, save_params = FORMAT_DICT[format]\nd = serialize(obj, save_params)\nfile_path = folder / Path(file_name + suffix)\nsave_fn(d, file_path)\nlogger.debug(f\"Successfully saved {obj} from to {folder}.\")\nexcept Exception as e:\nlogger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n## Lets use myblock in a QuantumCircuit and serialize it.\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7c597ddb-e9e7-47ba-a2b3-c9611a38bf6a', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.39070750051343706'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5c964f5b-34b3-4972-8c25-649a1a8d9577', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.41850047742945184'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('7954fe57-da63-4bd1-9b14-861a0f79238a', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.9575646045718003'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('874d2c78-8bf2-4634-9fdf-928028b13feb', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.04088597391021753'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8a894baa-0684-4d75-808a-03f62993377f', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.8270642740051448'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('bd8d4500-77d6-49d2-bb04-21cb2a751091', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.8746260993314904'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n\"\"\"\n    Supported Types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\nif not isinstance(obj, get_args(SUPPORTED_TYPES)):\nlogger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\nd: dict = {}\ntry:\nif isinstance(obj, Expr):\nsymb_dict = {}\nexpr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\nsymbs: set[Parameter | Basic] = obj.free_symbols\nif symbs:\nsymb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\nd = {**expr_dict, **symb_dict}\nelif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\nd = obj._to_dict(save_params)\nelif isinstance(obj, torch.nn.Module):\nd = {type(obj).__name__: obj.state_dict()}\nelse:\nd = obj._to_dict()\nexcept Exception as e:\nlogger.error(f\"Serialization of object {obj} failed due to {e}\")\nreturn d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n\"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A ChainBlock representing the GHZ state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\ncnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\nreturn chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a GHZ state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2))\nreturn norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n\"\"\"\n    Checks if a wave function is normalized.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n    Returns:\n        A bool.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nwf = wf.unsqueeze(0)\nsum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\nones = torch.ones_like(sum_probs)\nreturn torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n\"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\nif wf.dim() == 1:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum())\nelse:\nreturn wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the one state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the one state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"1\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n\"\"\"\n    Converts a wave function into a torch Distribution.\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n    Returns:\n        A torch.distributions.Distribution.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\nreturn Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n\"\"\"\n    Creates an abstract product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\nreturn _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\nbitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n\"\"\"\n    Creates a product state from a bitstring.\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\nreturn _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>01111110\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n\"\"\"\n    Creates a random bistring.\n    Arguments:\n        N (int): The length of the bitstring.\n    Returns:\n        A string.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\nreturn \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Creates a block representing a random abstract product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the product state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\nreturn product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Creates a random product state.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\nwf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\nrand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\nwf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\nreturn wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[-0.1316-0.2250j, -0.0565-0.1414j,  0.3979+0.3708j,  0.7759-0.1056j]])\ntensor([[0.8432+0.0000j, 0.1777+0.0000j, 0.0000+0.4965j, 0.0000+0.1047j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\nn_qubits: int,\nbatch_size: int = 1,\nbackend: str = BackendName.PYQTORCH,\ntype: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n\"\"\"\n    Generates a random state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\nif type == StateGeneratorType.HAAR_MEASURE_FAST:\nstate = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.HAAR_MEASURE_SLOW:\nstate = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\nelif type == StateGeneratorType.RANDOM_ROTATIONS:\nstate = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\nassert all(list(map(is_normalized, state)))\nreturn state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the uniform state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the uniform state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nnorm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\nreturn norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n\"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits.\n    Returns:\n        A KronBlock representing the zero state.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\nreturn _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n\"\"\"\n    Generates the zero state for a specified number of qubits.\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n    Returns:\n        A torch.Tensor.\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\nbitstring = \"0\" * n_qubits\nreturn _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n@blockfn_to_circfn\ndef fn(block):\n# un-decorated function accepts a block and returns a block\nreturn block * block\ntransp = transpile(\n# the decorated function accepts a circuit and returns a circuit\nfn,\n# already existing functions can also be decorated\nblockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n\"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n    Returns:\n        Composed function.\n    Examples:\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\nreturn lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n\u2514\u2500\u2500 KronBlock(0,1)\n\u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\nif is_chain_of_primitivekrons(block):\ntry:\nreturn kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\nexcept Exception as e:\nlogger.debug(\nf\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n)\nreturn block\nelif isinstance(block, CompositeBlock):\nreturn _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\nelse:\nreturn block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 ChainBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \u2514\u2500\u2500 AddBlock(0)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n\"\"\"Push the scale all the way down into the leaves of the block tree.\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n    Examples:\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\nraise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\nblocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n\"\"\"Set the trainability of all parameters in a block to a given value.\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\nif isinstance(blocks, AbstractBlock):\nblocks = [blocks]\nif inplace:\nfor block in blocks:\nparams: list[sympy.Basic] = parameters(block)\nfor p in params:\nif not p.is_number:\np.trainable = value\nelse:\nraise NotImplementedError(\"Not inplace set_trainable is not yet available\")\nreturn blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n\u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n\u2514\u2500\u2500 ChainBlock(0)\n\u2514\u2500\u2500 put on (0)\n\u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n\"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n    Reassigns qubit locations appropriately.\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\nvblock: AbstractBlock\nfrom qadence.transpile import reassign\nif isinstance(block, ControlBlock):\nvblock = deepcopy(block)\nb: AbstractBlock\n(b,) = block.blocks\nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nb = validate(b)\nvblock.blocks = (b,)  # type: ignore[assignment]\nelif isinstance(block, CompositeBlock):\nblocks = []\nfor b in block.blocks:\nmi, ma = min(b.qubit_support), max(b.qubit_support)\nnb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\nnb = validate(nb)\nnb = PutBlock(nb, tuple(range(mi, ma + 1)))\nblocks.append(nb)\ntry:\nvblock = _construct(type(block), tuple(blocks))\nexcept AssertionError as e:\nif str(e) == \"Make sure blocks act on distinct qubits!\":\nvblock = chain(*blocks)\nelse:\nraise e\nelif isinstance(block, PrimitiveBlock):\nvblock = deepcopy(block)\nelse:\nraise NotImplementedError\nvblock.tag = block.tag\nreturn vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>add_interaction</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Used when dumping enum fields in a schema.\"\"\"\nret: str = self.value\nreturn ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\nn_qubits = 4\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 69, '1000': 10, '0001': 9, '0100': 7, '0010': 2, '0011': 1, '1010': 1, '1100': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\nmodel = qd.QNN(circuit, observable)\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: tensor([[0.4619],\n[0.2336],\n[0.3466],\n[0.3091],\n[0.3848],\n[0.5296],\n[0.1685],\n[0.2566],\n[0.3779],\n[0.2013]], grad_fn=&lt;CatBackward0&gt;)\nFirst-order derivative w.r.t. the feature parameter: tensor([-1.0731,  0.7376,  0.7347,  0.7483, -1.9705,  0.1689,  0.6896, -5.4024,\n0.7118,  0.7184], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: tensor([-1.0731,  0.7376,  0.7347,  0.7483, -1.9705,  0.1689,  0.6896, -5.4024,\n0.7118,  0.7184], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\nx = torch.linspace(0, 1, data_size).reshape(-1, 1)\ny = torch.sin(x)\nreturn to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\ndls = {}\nfor k in [\"y1\", \"y2\"]:\nx = torch.rand(data_size, 1)\ny = torch.sin(x)\ndls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\nreturn DictDataLoader(dls)\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\nprint(f\"Standard {x = }\")\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n(x, y) = next(dl)\nprint(f\"Infinite {x = }\")\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n[0.2000]])\nStandard x = tensor([[0.4000],\n[0.6000]])\nStandard x = tensor([[0.8000],\n[1.0000]])\nInfinite x = tensor([[0.0000],\n[0.2000]])\nInfinite x = tensor([[0.4000],\n[0.6000]])\nInfinite x = tensor([[0.8000],\n[1.0000]])\nInfinite x = tensor([[0.0000],\n[0.2000]])\nInfinite x = tensor([[0.4000],\n[0.6000]])\ndata = {'y1': [tensor([[0.2434],\n[0.3151],\n[0.1038],\n[0.4767],\n[0.1838]]), tensor([[0.2410],\n[0.3099],\n[0.1036],\n[0.4589],\n[0.1827]])], 'y2': [tensor([[0.9386],\n[0.6771],\n[0.9058],\n[0.5234],\n[0.6710]]), tensor([[0.8067],\n[0.6266],\n[0.7869],\n[0.4999],\n[0.6218]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\nbatch_size = 5\nn_epochs = 100\nconfig = TrainConfig(\nfolder=\"some_path/\",\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\nnext(cnt)\nx, y = data[0], data[1]\nout = model(x)\nloss = criterion(out, y)\nreturn loss, {}\ntmp_path = Path(\"/tmp\")\nn_epochs = 50\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nbatch_size = 25\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-11-13T15:11:46.045411 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\ntmp_path = Path(\"/tmp\")\nconfig = TrainConfig(\nfolder=tmp_path,\nmax_iter=n_epochs,\ncheckpoint_every=100,\nwrite_every=100,\nbatch_size=batch_size,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\nfor i in range(n_epochs):\nout = model(x)\nloss = criterion(out, y)\nloss.backward()\noptimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\ndef train(\nmodel: Module,\ndata: DataLoader,\noptimizer: Optimizer,\nconfig: TrainConfig,\nloss_fn: Callable,\ndevice: str = \"cpu\",\noptimize_step: Callable = optimize_step,\nwrite_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n# Move model to device before optimizer is loaded\nmodel = model.to(device)\n# load available checkpoint\ninit_iter = 0\nif config.folder:\nmodel, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n# initialize tensorboard\nwriter = SummaryWriter(config.folder, purge_step=init_iter)\ndl_iter = iter(dataloader)\n# outer epoch loop\nfor iteration in range(init_iter, init_iter + config.max_iter):\ndata = data_to_device(next(dl_iter), device)\nloss, metrics = optimize_step(model, optimizer, loss_fn, data)\nif iteration % config.print_every == 0 and config.verbose:\nprint_metrics(loss, metrics, iteration)\nif iteration % config.write_every == 0:\nwrite_tensorboard(writer, loss, metrics, iteration)\nif config.folder:\nif iteration % config.checkpoint_every == 0:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\n# Final writing and checkpointing\nif config.folder:\nwrite_checkpoint(config.folder, model, optimizer, iteration)\nwrite_tensorboard(writer, loss, metrics, iteration)\nwriter.close()\nreturn model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\nnx.draw(graph)\n</code></pre> 2023-11-13T15:11:46.592146 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\nn_qubits = graph.number_of_nodes()\nn_layers = 2\ncost_ham = Zero()\nfor op in zz_ops:\ncost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\nlayers = []\nfor layer in range(n_layers):\n# cost layer with digital decomposition\ncost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\ncost_layer = tag(cost_layer, \"cost\")\n# mixing layer with single qubit rotations\nmixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\nmixing_layer = tag(mixing_layer, \"mixing\")\n# putting all together in a single ChainBlock\nlayers.append(chain(cost_layer, mixing_layer))\nfinal_b = chain(*layers)\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_8c0306cf4c8b4e00b08de9133f9eb34b mixing cluster_e6d89d01251f401fb60227a130a53f12 cost cluster_cbb71f5488d74606b40c0b5269f6256c mixing cluster_d8cf15e4e47a426ab5c82c4b05a0dcf8 cost fbb5f6a78cac436fbc907e59d96ae8b2 0 548874ce627246b3816a617c7146054a fbb5f6a78cac436fbc907e59d96ae8b2--548874ce627246b3816a617c7146054a 695d670d2e954487bbec97d2378a96eb 1 9179ef4ce0e84416acfc65f88faa1320 548874ce627246b3816a617c7146054a--9179ef4ce0e84416acfc65f88faa1320 5da98747c0ab4a92982a2dd067260e06 9179ef4ce0e84416acfc65f88faa1320--5da98747c0ab4a92982a2dd067260e06 821281580726464e88b1905dc6644ddf 5da98747c0ab4a92982a2dd067260e06--821281580726464e88b1905dc6644ddf 00e8118a313f4a159b477f45284bb34d 821281580726464e88b1905dc6644ddf--00e8118a313f4a159b477f45284bb34d 4c92a2240b4e4f1a8ec34c44475d846c 00e8118a313f4a159b477f45284bb34d--4c92a2240b4e4f1a8ec34c44475d846c 9d4ed89ce60a448a964fe217779f669d 4c92a2240b4e4f1a8ec34c44475d846c--9d4ed89ce60a448a964fe217779f669d cff49033dc924cc4a410aee5a4649e47 9d4ed89ce60a448a964fe217779f669d--cff49033dc924cc4a410aee5a4649e47 10b83021216945f7a542b8d887647ec0 cff49033dc924cc4a410aee5a4649e47--10b83021216945f7a542b8d887647ec0 ad946c6a11674160ba94452f90495a16 10b83021216945f7a542b8d887647ec0--ad946c6a11674160ba94452f90495a16 6fdf9c9c1f1d4011ae6250a5658c16b4 ad946c6a11674160ba94452f90495a16--6fdf9c9c1f1d4011ae6250a5658c16b4 ed9102308d064051ba6b25bc4f8fa9a0 6fdf9c9c1f1d4011ae6250a5658c16b4--ed9102308d064051ba6b25bc4f8fa9a0 249e878a8de244299c4f8fe2dfa13a2d ed9102308d064051ba6b25bc4f8fa9a0--249e878a8de244299c4f8fe2dfa13a2d 5f5504fa80364f5da44489717a9ff4e6 249e878a8de244299c4f8fe2dfa13a2d--5f5504fa80364f5da44489717a9ff4e6 01690ffcda4b4967ad8bd7ee7df89b20 5f5504fa80364f5da44489717a9ff4e6--01690ffcda4b4967ad8bd7ee7df89b20 04084aedda9c466a9b69dfb2a4350e88 01690ffcda4b4967ad8bd7ee7df89b20--04084aedda9c466a9b69dfb2a4350e88 07aea4c9a66f43e294dd06c1ad8d3aeb 04084aedda9c466a9b69dfb2a4350e88--07aea4c9a66f43e294dd06c1ad8d3aeb 5ec18bb1c732453d88d63142ff7d8257 07aea4c9a66f43e294dd06c1ad8d3aeb--5ec18bb1c732453d88d63142ff7d8257 cab3482b30af4367957aebecdbc871b1 5ec18bb1c732453d88d63142ff7d8257--cab3482b30af4367957aebecdbc871b1 614ca804b3c04959892422686efbf52d cab3482b30af4367957aebecdbc871b1--614ca804b3c04959892422686efbf52d 5dc707f466b14001a42caf6cef036bbf 614ca804b3c04959892422686efbf52d--5dc707f466b14001a42caf6cef036bbf 7e0c5d04c61245d5af6025359fd9839a 5dc707f466b14001a42caf6cef036bbf--7e0c5d04c61245d5af6025359fd9839a 6dff104927c14fb89ad69682fbd35f72 7e0c5d04c61245d5af6025359fd9839a--6dff104927c14fb89ad69682fbd35f72 d4c73b715f6545be98f1533940395a20 6dff104927c14fb89ad69682fbd35f72--d4c73b715f6545be98f1533940395a20 c758ba80e2574a86864dd14c62c73b3a d4c73b715f6545be98f1533940395a20--c758ba80e2574a86864dd14c62c73b3a f9a4a0649c524f2e9a720a8ed546174b c758ba80e2574a86864dd14c62c73b3a--f9a4a0649c524f2e9a720a8ed546174b 3d933b5b02754faab8b5f6f43110fb8a f9a4a0649c524f2e9a720a8ed546174b--3d933b5b02754faab8b5f6f43110fb8a 7a13f9fa5d34466f9502dc247727c2e4 3d933b5b02754faab8b5f6f43110fb8a--7a13f9fa5d34466f9502dc247727c2e4 e0e12237bd47456385b851179d082e91 7a13f9fa5d34466f9502dc247727c2e4--e0e12237bd47456385b851179d082e91 8fde939e3d7d42ccb6c21c60c3b071c9 e0e12237bd47456385b851179d082e91--8fde939e3d7d42ccb6c21c60c3b071c9 959e90c6bdac4250a08e81f38aba2ca2 8fde939e3d7d42ccb6c21c60c3b071c9--959e90c6bdac4250a08e81f38aba2ca2 73647fbf28164cb08de228144709de95 959e90c6bdac4250a08e81f38aba2ca2--73647fbf28164cb08de228144709de95 4e7656e3b96448698860c83d6e90ef7f 73647fbf28164cb08de228144709de95--4e7656e3b96448698860c83d6e90ef7f eddbb6287ea2414bae4170009f2cf9b2 4e7656e3b96448698860c83d6e90ef7f--eddbb6287ea2414bae4170009f2cf9b2 1fb4bd6ee9624b3abf4773cb4e49186b eddbb6287ea2414bae4170009f2cf9b2--1fb4bd6ee9624b3abf4773cb4e49186b e1693558415140dd91c9fff3d554fd94 1fb4bd6ee9624b3abf4773cb4e49186b--e1693558415140dd91c9fff3d554fd94 c63370f7140d495682713e13d22f74cb e1693558415140dd91c9fff3d554fd94--c63370f7140d495682713e13d22f74cb 767b5e2e8b234ba08b775ae558408abd c63370f7140d495682713e13d22f74cb--767b5e2e8b234ba08b775ae558408abd 7234040a44d84473a991f32c9c374b0b 767b5e2e8b234ba08b775ae558408abd--7234040a44d84473a991f32c9c374b0b d7f58df67d3d45958c08d2d85ec746aa 7234040a44d84473a991f32c9c374b0b--d7f58df67d3d45958c08d2d85ec746aa cd88615654f04c0b8d26cf003fabfeff d7f58df67d3d45958c08d2d85ec746aa--cd88615654f04c0b8d26cf003fabfeff df31d0e4fb0144db9eff196db184d5d8 cd88615654f04c0b8d26cf003fabfeff--df31d0e4fb0144db9eff196db184d5d8 487aaafdf32040b2abb82ebbf7c9cddb df31d0e4fb0144db9eff196db184d5d8--487aaafdf32040b2abb82ebbf7c9cddb 4b11b7b106ae4607818733097d8d225d 487aaafdf32040b2abb82ebbf7c9cddb--4b11b7b106ae4607818733097d8d225d 36592b2ce7cd455bb4122e17ae57d862 4b11b7b106ae4607818733097d8d225d--36592b2ce7cd455bb4122e17ae57d862 3108ce27ec14414a9b5d4c0bb2e482cb 36592b2ce7cd455bb4122e17ae57d862--3108ce27ec14414a9b5d4c0bb2e482cb 6e76ceedad0347e6b3a8aa3d842af797 3108ce27ec14414a9b5d4c0bb2e482cb--6e76ceedad0347e6b3a8aa3d842af797 fbe2023ddb3a47df990529a6ebb9abb0 6e76ceedad0347e6b3a8aa3d842af797--fbe2023ddb3a47df990529a6ebb9abb0 5dd6f37ca95144a0aa8b08a31ef17399 fbe2023ddb3a47df990529a6ebb9abb0--5dd6f37ca95144a0aa8b08a31ef17399 23bab16004fd405ba02bc4aeb1b9b7a1 5dd6f37ca95144a0aa8b08a31ef17399--23bab16004fd405ba02bc4aeb1b9b7a1 08d7deb7380f4c3294ec20c42c937c48 23bab16004fd405ba02bc4aeb1b9b7a1--08d7deb7380f4c3294ec20c42c937c48 0953ed615c0c404dacd13befead445ab 08d7deb7380f4c3294ec20c42c937c48--0953ed615c0c404dacd13befead445ab 1326839fcd154770a14b1e337ac78f1e 0953ed615c0c404dacd13befead445ab--1326839fcd154770a14b1e337ac78f1e ce0f9e3193e04a318eec74786ee96a39 1326839fcd154770a14b1e337ac78f1e--ce0f9e3193e04a318eec74786ee96a39 75afff6b8788401c8cc6e3368a6c9e4a ce0f9e3193e04a318eec74786ee96a39--75afff6b8788401c8cc6e3368a6c9e4a 4bdf1cde9911404cbd6aafc66fea9943 75afff6b8788401c8cc6e3368a6c9e4a--4bdf1cde9911404cbd6aafc66fea9943 5a0caad3174044be8995b39e09a982ec 4bdf1cde9911404cbd6aafc66fea9943--5a0caad3174044be8995b39e09a982ec a90f71105d884f99bb651dd15d1a625e 5a0caad3174044be8995b39e09a982ec--a90f71105d884f99bb651dd15d1a625e 1d584ecaafa14894b3e9e204c6bd6b49 a90f71105d884f99bb651dd15d1a625e--1d584ecaafa14894b3e9e204c6bd6b49 7ac02d8ff1e14a2a91f7403aa36243df 1d584ecaafa14894b3e9e204c6bd6b49--7ac02d8ff1e14a2a91f7403aa36243df bb6851aa06b5459a89fd5d5759afdaca 7ac02d8ff1e14a2a91f7403aa36243df--bb6851aa06b5459a89fd5d5759afdaca 2ee848d062c34ffa8816fc6068ed0e22 bb6851aa06b5459a89fd5d5759afdaca--2ee848d062c34ffa8816fc6068ed0e22 4ae272630de74b7d96f48df916d35fb0 2ee848d062c34ffa8816fc6068ed0e22--4ae272630de74b7d96f48df916d35fb0 08a2bcf3e60d445b9238a7bddfab9cd6 4ae272630de74b7d96f48df916d35fb0--08a2bcf3e60d445b9238a7bddfab9cd6 8e2394fd937b4895a583fa2136dc2dfc 08a2bcf3e60d445b9238a7bddfab9cd6--8e2394fd937b4895a583fa2136dc2dfc 02613fa03cf345039c8475bc36ac3a45 8e2394fd937b4895a583fa2136dc2dfc--02613fa03cf345039c8475bc36ac3a45 1b69bdc81f5d48b7a8f3e4684b87fd06 02613fa03cf345039c8475bc36ac3a45--1b69bdc81f5d48b7a8f3e4684b87fd06 ee5a813250564de39bfe3b0e479ca2fd 1b69bdc81f5d48b7a8f3e4684b87fd06--ee5a813250564de39bfe3b0e479ca2fd c389c881c9c642089389c2cc966e0841 ee5a813250564de39bfe3b0e479ca2fd--c389c881c9c642089389c2cc966e0841 754ab26736ad47eca76a8aa696d39b40 c389c881c9c642089389c2cc966e0841--754ab26736ad47eca76a8aa696d39b40 e407d43db7b04f6495361828b8407a1e 754ab26736ad47eca76a8aa696d39b40--e407d43db7b04f6495361828b8407a1e a49faf2b9e734a26b022d3b67e1f99d6 e407d43db7b04f6495361828b8407a1e--a49faf2b9e734a26b022d3b67e1f99d6 efc9614564bf460e9912ba649f1059ae a49faf2b9e734a26b022d3b67e1f99d6--efc9614564bf460e9912ba649f1059ae 91bfcc1bb05a41f2aed090ab8bdba87d efc9614564bf460e9912ba649f1059ae--91bfcc1bb05a41f2aed090ab8bdba87d 33f00b28db974c918df3264399201507 91bfcc1bb05a41f2aed090ab8bdba87d--33f00b28db974c918df3264399201507 6dabcf40ec444d68a82637696d29e7be 33f00b28db974c918df3264399201507--6dabcf40ec444d68a82637696d29e7be 7970e62f0f4a4a748c7b3a8dc78d33c1 6dabcf40ec444d68a82637696d29e7be--7970e62f0f4a4a748c7b3a8dc78d33c1 bb8363ced3d3465a82c1cfd9f82274c4 7970e62f0f4a4a748c7b3a8dc78d33c1--bb8363ced3d3465a82c1cfd9f82274c4 869cc442cadf46d08266ae47fb2766d7 bb8363ced3d3465a82c1cfd9f82274c4--869cc442cadf46d08266ae47fb2766d7 6adb672129574af9ad309c0744465319 869cc442cadf46d08266ae47fb2766d7--6adb672129574af9ad309c0744465319 bd5ee20aec6c423599b28410db95b9b9 6adb672129574af9ad309c0744465319--bd5ee20aec6c423599b28410db95b9b9 0f72e4e5c61743259f9a9f46fd8fd982 bd5ee20aec6c423599b28410db95b9b9--0f72e4e5c61743259f9a9f46fd8fd982 f05d071c54bd475892ba9640d2e12860 0f72e4e5c61743259f9a9f46fd8fd982--f05d071c54bd475892ba9640d2e12860 2d66ac1baae74b26bcd35bd13b2016d6 f05d071c54bd475892ba9640d2e12860--2d66ac1baae74b26bcd35bd13b2016d6 5fbd307ec015439fa68dc8da21724276 2d66ac1baae74b26bcd35bd13b2016d6--5fbd307ec015439fa68dc8da21724276 dc1d494ebe5a40c0a2604e49a70d9288 5fbd307ec015439fa68dc8da21724276--dc1d494ebe5a40c0a2604e49a70d9288 23a3c5aeffe54af1a3b1eac62e337157 dc1d494ebe5a40c0a2604e49a70d9288--23a3c5aeffe54af1a3b1eac62e337157 75118f77ee964977a22d76ce96b4a882 23a3c5aeffe54af1a3b1eac62e337157--75118f77ee964977a22d76ce96b4a882 9d9f8aa7dbc245ba80e06f270bb6c7a2 75118f77ee964977a22d76ce96b4a882--9d9f8aa7dbc245ba80e06f270bb6c7a2 466687fa583b485e92ea9ea4770dd305 9d9f8aa7dbc245ba80e06f270bb6c7a2--466687fa583b485e92ea9ea4770dd305 ab12215bf0a94a37a714bfd7955e558f 466687fa583b485e92ea9ea4770dd305--ab12215bf0a94a37a714bfd7955e558f 961c1dc09f304f88b5251198e1ca624c ab12215bf0a94a37a714bfd7955e558f--961c1dc09f304f88b5251198e1ca624c a1431e518e0a4390848d43af134168c4 961c1dc09f304f88b5251198e1ca624c--a1431e518e0a4390848d43af134168c4 afe31c9b375b451ca1eb08c850b2472c a1431e518e0a4390848d43af134168c4--afe31c9b375b451ca1eb08c850b2472c e60bbb6bec9c477c95238188a18baa96 afe31c9b375b451ca1eb08c850b2472c--e60bbb6bec9c477c95238188a18baa96 e1d91dbf98df42b9b29a3d47bf966c7d e60bbb6bec9c477c95238188a18baa96--e1d91dbf98df42b9b29a3d47bf966c7d 5c79c00260c145e9a273ee13dd0ef156 e1d91dbf98df42b9b29a3d47bf966c7d--5c79c00260c145e9a273ee13dd0ef156 c592b211989249b795c3e65561df8338 5c79c00260c145e9a273ee13dd0ef156--c592b211989249b795c3e65561df8338 b35c5c9b4a3d48139d2310e77849ed1c c592b211989249b795c3e65561df8338--b35c5c9b4a3d48139d2310e77849ed1c e8d92e16505d42ed8650047a1cb33854 b35c5c9b4a3d48139d2310e77849ed1c--e8d92e16505d42ed8650047a1cb33854 1449960f6ce74a8d80e6208c79f0fa16 e8d92e16505d42ed8650047a1cb33854--1449960f6ce74a8d80e6208c79f0fa16 96e7e41758ae44c9a8694b449ae6d3a8 1449960f6ce74a8d80e6208c79f0fa16--96e7e41758ae44c9a8694b449ae6d3a8 6fbf199ffa3c4071afa29357766daaf8 96e7e41758ae44c9a8694b449ae6d3a8--6fbf199ffa3c4071afa29357766daaf8 838851f811f145ee97aa31e9fd6715ce 6fbf199ffa3c4071afa29357766daaf8--838851f811f145ee97aa31e9fd6715ce a0fe88831bf540a89fdd162aae504808 838851f811f145ee97aa31e9fd6715ce--a0fe88831bf540a89fdd162aae504808 bc8d0d4787d14d9f80efb728d41bf88b a0fe88831bf540a89fdd162aae504808--bc8d0d4787d14d9f80efb728d41bf88b aad9f89d7a044123a621c56fd29aa097 bc8d0d4787d14d9f80efb728d41bf88b--aad9f89d7a044123a621c56fd29aa097 19c51c34007c418a847414dcd682eddd aad9f89d7a044123a621c56fd29aa097--19c51c34007c418a847414dcd682eddd ad00c18812f5491ba12cf0f80ddfdc54 19c51c34007c418a847414dcd682eddd--ad00c18812f5491ba12cf0f80ddfdc54 2ffaa06f6e074f9a8c203367d63f762d ad00c18812f5491ba12cf0f80ddfdc54--2ffaa06f6e074f9a8c203367d63f762d 7682838bb1d6401aa02cf209ad83aa4d 2ffaa06f6e074f9a8c203367d63f762d--7682838bb1d6401aa02cf209ad83aa4d 25146c8f81b04bbbb75a2d562508af2c 7682838bb1d6401aa02cf209ad83aa4d--25146c8f81b04bbbb75a2d562508af2c 7ecfdad03e554061a8242387b360481c 25146c8f81b04bbbb75a2d562508af2c--7ecfdad03e554061a8242387b360481c 80e70cdfdd8a4656a4a7dc9d0960b32b 7ecfdad03e554061a8242387b360481c--80e70cdfdd8a4656a4a7dc9d0960b32b 61f6a3b9024b4b4c9db02dcf225bd7ed 80e70cdfdd8a4656a4a7dc9d0960b32b--61f6a3b9024b4b4c9db02dcf225bd7ed cd9f0b0794d1414596c96394f7ba836c 61f6a3b9024b4b4c9db02dcf225bd7ed--cd9f0b0794d1414596c96394f7ba836c 2734ce28c3e54228bf1078024a41af08 cd9f0b0794d1414596c96394f7ba836c--2734ce28c3e54228bf1078024a41af08 c5da3532f6e94860aa62f2b1872fee6e 2734ce28c3e54228bf1078024a41af08--c5da3532f6e94860aa62f2b1872fee6e 8d5f2eb18544403993aefb69cfbc41e3 c5da3532f6e94860aa62f2b1872fee6e--8d5f2eb18544403993aefb69cfbc41e3 f4ff375c82a846caa3bac56198be8fe4 8d5f2eb18544403993aefb69cfbc41e3--f4ff375c82a846caa3bac56198be8fe4 e0cd089bfe0f4eb6b054ba556051f340 f4ff375c82a846caa3bac56198be8fe4--e0cd089bfe0f4eb6b054ba556051f340 b2fa85c3797149ae8fa692048881a38f e0cd089bfe0f4eb6b054ba556051f340--b2fa85c3797149ae8fa692048881a38f e9534f118af84faeb45893d27fee118b b2fa85c3797149ae8fa692048881a38f--e9534f118af84faeb45893d27fee118b 0529ba2015194f9693a438c0eab96641 e9534f118af84faeb45893d27fee118b--0529ba2015194f9693a438c0eab96641 b1982661079c45399f28dcb57fe9e2ca 0529ba2015194f9693a438c0eab96641--b1982661079c45399f28dcb57fe9e2ca 8edf5577d58140dfb809eca239c5bbdf b1982661079c45399f28dcb57fe9e2ca--8edf5577d58140dfb809eca239c5bbdf b0c298e7d50e4f8fa9541b777a1b6f06 8edf5577d58140dfb809eca239c5bbdf--b0c298e7d50e4f8fa9541b777a1b6f06 294e768e96234b839bf38baeb5814a9a b0c298e7d50e4f8fa9541b777a1b6f06--294e768e96234b839bf38baeb5814a9a 368cdb08fa5746b6bfec6ddd4e14a6b9 294e768e96234b839bf38baeb5814a9a--368cdb08fa5746b6bfec6ddd4e14a6b9 23f22a7f0c1a4fb5aa9ea8d8560423ad RX(b00) 368cdb08fa5746b6bfec6ddd4e14a6b9--23f22a7f0c1a4fb5aa9ea8d8560423ad ff4ed23f71904df5be1d95daadd78c6a 23f22a7f0c1a4fb5aa9ea8d8560423ad--ff4ed23f71904df5be1d95daadd78c6a 12dfee2526ea4c91b5a4d5ab232016b7 ff4ed23f71904df5be1d95daadd78c6a--12dfee2526ea4c91b5a4d5ab232016b7 eb69f3b575e842d28e97953973564411 12dfee2526ea4c91b5a4d5ab232016b7--eb69f3b575e842d28e97953973564411 409f0751166a4dfcb887319d75758a29 eb69f3b575e842d28e97953973564411--409f0751166a4dfcb887319d75758a29 ca8d4204528f42828ef3bfb99c22564e 409f0751166a4dfcb887319d75758a29--ca8d4204528f42828ef3bfb99c22564e a6551c91fd6b495c9d15c7cef7c12b6e ca8d4204528f42828ef3bfb99c22564e--a6551c91fd6b495c9d15c7cef7c12b6e 3b2193d93ef0430f9bf31bde739010a4 a6551c91fd6b495c9d15c7cef7c12b6e--3b2193d93ef0430f9bf31bde739010a4 5430036ce2b442fbaac5896ce770edbc 3b2193d93ef0430f9bf31bde739010a4--5430036ce2b442fbaac5896ce770edbc 2159306b10214728a0fa158efac5dc48 5430036ce2b442fbaac5896ce770edbc--2159306b10214728a0fa158efac5dc48 97afc18168c84606a16c6d9ddb799bc2 2159306b10214728a0fa158efac5dc48--97afc18168c84606a16c6d9ddb799bc2 7ae1857cb6794415917b32648506d343 97afc18168c84606a16c6d9ddb799bc2--7ae1857cb6794415917b32648506d343 891c5ac43a4a4772a5582f69d9c1ad3d 7ae1857cb6794415917b32648506d343--891c5ac43a4a4772a5582f69d9c1ad3d fff7b5b45ba5440ea818ced34f336656 891c5ac43a4a4772a5582f69d9c1ad3d--fff7b5b45ba5440ea818ced34f336656 4fadc99044a34d06bdf857e2ad45ce4a fff7b5b45ba5440ea818ced34f336656--4fadc99044a34d06bdf857e2ad45ce4a a60fdf1a29b74cbf886e9928b990d286 4fadc99044a34d06bdf857e2ad45ce4a--a60fdf1a29b74cbf886e9928b990d286 1bc1a5a299124355b38a242fa67a7125 a60fdf1a29b74cbf886e9928b990d286--1bc1a5a299124355b38a242fa67a7125 56c1deac00f14572a4e116238fac866b 1bc1a5a299124355b38a242fa67a7125--56c1deac00f14572a4e116238fac866b b0e2348b6edf4e96b9f5c1b0a7d920b1 56c1deac00f14572a4e116238fac866b--b0e2348b6edf4e96b9f5c1b0a7d920b1 9839b1f725da46c5be1d75b18a53dfdb b0e2348b6edf4e96b9f5c1b0a7d920b1--9839b1f725da46c5be1d75b18a53dfdb 32a2168985b24b6c902b7e710dd3f263 9839b1f725da46c5be1d75b18a53dfdb--32a2168985b24b6c902b7e710dd3f263 544148d78c3c4b629a5ca44fbf03dea9 32a2168985b24b6c902b7e710dd3f263--544148d78c3c4b629a5ca44fbf03dea9 6853f52f49f64534bc558b5a7f43b750 544148d78c3c4b629a5ca44fbf03dea9--6853f52f49f64534bc558b5a7f43b750 b9d3afa732b64f9189133bfd3e8ace19 6853f52f49f64534bc558b5a7f43b750--b9d3afa732b64f9189133bfd3e8ace19 d9ea0f47e4e541389acd4730393f7e69 b9d3afa732b64f9189133bfd3e8ace19--d9ea0f47e4e541389acd4730393f7e69 c510e554460b48ff83028b3cfbe4d4c1 d9ea0f47e4e541389acd4730393f7e69--c510e554460b48ff83028b3cfbe4d4c1 694cc02418f54a6084857d81a9d8e99d c510e554460b48ff83028b3cfbe4d4c1--694cc02418f54a6084857d81a9d8e99d a223302b589145ca89c64bb67f5cfc6f 694cc02418f54a6084857d81a9d8e99d--a223302b589145ca89c64bb67f5cfc6f fc9f085c587a41b5bd36d74e464fdd03 a223302b589145ca89c64bb67f5cfc6f--fc9f085c587a41b5bd36d74e464fdd03 4c2ea86835d047b3a51f39f43ea269c3 fc9f085c587a41b5bd36d74e464fdd03--4c2ea86835d047b3a51f39f43ea269c3 890fc56409d74d32b1d5b8f310052315 4c2ea86835d047b3a51f39f43ea269c3--890fc56409d74d32b1d5b8f310052315 5bceba11378a4015ac1b1c5b8c1522c8 890fc56409d74d32b1d5b8f310052315--5bceba11378a4015ac1b1c5b8c1522c8 df4e6cbfe54c49e4aa0889f5bbc8fc54 5bceba11378a4015ac1b1c5b8c1522c8--df4e6cbfe54c49e4aa0889f5bbc8fc54 d0cdca1891554d7d9b9bc430f198bcd8 df4e6cbfe54c49e4aa0889f5bbc8fc54--d0cdca1891554d7d9b9bc430f198bcd8 4b30cc84b489457b8087fc2c4d0a98a4 d0cdca1891554d7d9b9bc430f198bcd8--4b30cc84b489457b8087fc2c4d0a98a4 7303b781de77409498de7e73ec3da112 4b30cc84b489457b8087fc2c4d0a98a4--7303b781de77409498de7e73ec3da112 a82ba04495cd470d8029ef2d6068af33 7303b781de77409498de7e73ec3da112--a82ba04495cd470d8029ef2d6068af33 b03853df93d042eb942b21652e615508 a82ba04495cd470d8029ef2d6068af33--b03853df93d042eb942b21652e615508 1299a8e648b44a44b02181239cec42eb b03853df93d042eb942b21652e615508--1299a8e648b44a44b02181239cec42eb cfb2ddd62a194f3a9b4dc00d30e2d2e0 1299a8e648b44a44b02181239cec42eb--cfb2ddd62a194f3a9b4dc00d30e2d2e0 55368ed76b69423db0cfdaa6191998e8 cfb2ddd62a194f3a9b4dc00d30e2d2e0--55368ed76b69423db0cfdaa6191998e8 bac15dad140849dda5f96a761d81d1a1 55368ed76b69423db0cfdaa6191998e8--bac15dad140849dda5f96a761d81d1a1 16fc42476ebc4332b421c00f7482ac40 bac15dad140849dda5f96a761d81d1a1--16fc42476ebc4332b421c00f7482ac40 8637682858424066b5d931bc7be572ad 16fc42476ebc4332b421c00f7482ac40--8637682858424066b5d931bc7be572ad ea0c413d3d6f4538a62d0e951e16aad4 8637682858424066b5d931bc7be572ad--ea0c413d3d6f4538a62d0e951e16aad4 20e8024160e848b7bd8c09cbe05231d9 ea0c413d3d6f4538a62d0e951e16aad4--20e8024160e848b7bd8c09cbe05231d9 4a7ce93226fd4b6dbbc31da1d5fed94a 20e8024160e848b7bd8c09cbe05231d9--4a7ce93226fd4b6dbbc31da1d5fed94a 3eed870abd0649f4807e809717ac87ec 4a7ce93226fd4b6dbbc31da1d5fed94a--3eed870abd0649f4807e809717ac87ec f0609f954d854e01a619eed125932daf 3eed870abd0649f4807e809717ac87ec--f0609f954d854e01a619eed125932daf 2c099dc668b5456a975831443eaee2ee f0609f954d854e01a619eed125932daf--2c099dc668b5456a975831443eaee2ee 648e1c5ed26a40d0ad318851f39f0e6f 2c099dc668b5456a975831443eaee2ee--648e1c5ed26a40d0ad318851f39f0e6f 0f043ea075d44a3abf843d223ec449b2 648e1c5ed26a40d0ad318851f39f0e6f--0f043ea075d44a3abf843d223ec449b2 bcdb042501a946d6a3b9bb3be7ee044c 0f043ea075d44a3abf843d223ec449b2--bcdb042501a946d6a3b9bb3be7ee044c c29d1668cf35463cbeca67b5cc4e1a15 bcdb042501a946d6a3b9bb3be7ee044c--c29d1668cf35463cbeca67b5cc4e1a15 2039bfdc0f51495196b41012c1d7b351 c29d1668cf35463cbeca67b5cc4e1a15--2039bfdc0f51495196b41012c1d7b351 1a50af8482ea40c89984f217756bdded 2039bfdc0f51495196b41012c1d7b351--1a50af8482ea40c89984f217756bdded d559b804fbbb45c68ec020c6ecc7d025 1a50af8482ea40c89984f217756bdded--d559b804fbbb45c68ec020c6ecc7d025 bcf8404bba5a4ad09240978eb2a9fe2e d559b804fbbb45c68ec020c6ecc7d025--bcf8404bba5a4ad09240978eb2a9fe2e 596cde9beb45441d91c0c7d0a36e308b bcf8404bba5a4ad09240978eb2a9fe2e--596cde9beb45441d91c0c7d0a36e308b ab3d437e615049d68267a652981578d1 596cde9beb45441d91c0c7d0a36e308b--ab3d437e615049d68267a652981578d1 9a144574d9be4804800898bc483f0342 ab3d437e615049d68267a652981578d1--9a144574d9be4804800898bc483f0342 0d5a2d402df74482b085470a8b529e49 9a144574d9be4804800898bc483f0342--0d5a2d402df74482b085470a8b529e49 046aa2981d1a4269b4137d57242d39a3 0d5a2d402df74482b085470a8b529e49--046aa2981d1a4269b4137d57242d39a3 e533cbd1214d4b76987ae538b1575bf2 046aa2981d1a4269b4137d57242d39a3--e533cbd1214d4b76987ae538b1575bf2 dee8b0f93b274c5398ada11969587a13 e533cbd1214d4b76987ae538b1575bf2--dee8b0f93b274c5398ada11969587a13 254976fe6bc54987a93694be9da7a9c7 dee8b0f93b274c5398ada11969587a13--254976fe6bc54987a93694be9da7a9c7 b5908686b9234406afe852a102c2fbb2 254976fe6bc54987a93694be9da7a9c7--b5908686b9234406afe852a102c2fbb2 37b8db51390e4ad094fb6391113131a6 b5908686b9234406afe852a102c2fbb2--37b8db51390e4ad094fb6391113131a6 20579a685b40443a8f1e0b46211aa926 37b8db51390e4ad094fb6391113131a6--20579a685b40443a8f1e0b46211aa926 d11d7225163847919d1d300c05a27442 20579a685b40443a8f1e0b46211aa926--d11d7225163847919d1d300c05a27442 ec3d0ab7d7114982a53828e7d197addd d11d7225163847919d1d300c05a27442--ec3d0ab7d7114982a53828e7d197addd f897a08d7e1a46e6837cb48525ca3350 ec3d0ab7d7114982a53828e7d197addd--f897a08d7e1a46e6837cb48525ca3350 4b8ffeafe0d540ffa72b48854b6694d8 f897a08d7e1a46e6837cb48525ca3350--4b8ffeafe0d540ffa72b48854b6694d8 484c6fac02374f02a89b18c4d88cd418 4b8ffeafe0d540ffa72b48854b6694d8--484c6fac02374f02a89b18c4d88cd418 b93f96433f4c4e1c88447eeba54d1b69 484c6fac02374f02a89b18c4d88cd418--b93f96433f4c4e1c88447eeba54d1b69 12ef8c1ad0ff4a49944a15d3af205d15 b93f96433f4c4e1c88447eeba54d1b69--12ef8c1ad0ff4a49944a15d3af205d15 8232241ac883417a85af611949cc8520 12ef8c1ad0ff4a49944a15d3af205d15--8232241ac883417a85af611949cc8520 9c9094143dd4441cbf0c094eb58cf687 8232241ac883417a85af611949cc8520--9c9094143dd4441cbf0c094eb58cf687 e786096136074242b529d2994cbae1c1 9c9094143dd4441cbf0c094eb58cf687--e786096136074242b529d2994cbae1c1 b95a2e39c7454b728e8ffe81db16b98d e786096136074242b529d2994cbae1c1--b95a2e39c7454b728e8ffe81db16b98d 7e2b27829f294537a0c12be0219ad38d b95a2e39c7454b728e8ffe81db16b98d--7e2b27829f294537a0c12be0219ad38d e6ea284a27fe4533ba2ad12099c25418 7e2b27829f294537a0c12be0219ad38d--e6ea284a27fe4533ba2ad12099c25418 cb6e29c81a7b4f5594062ace133bb273 e6ea284a27fe4533ba2ad12099c25418--cb6e29c81a7b4f5594062ace133bb273 95d487ce7d45498aa2d0f9bdf99a86e2 cb6e29c81a7b4f5594062ace133bb273--95d487ce7d45498aa2d0f9bdf99a86e2 60d7b640d2e242cca866250a6c56171f 95d487ce7d45498aa2d0f9bdf99a86e2--60d7b640d2e242cca866250a6c56171f c5b7b0643e3b4bb2b4f29272f3aae8ec 60d7b640d2e242cca866250a6c56171f--c5b7b0643e3b4bb2b4f29272f3aae8ec 80c4c342043a4567bda5b4a7cd961140 c5b7b0643e3b4bb2b4f29272f3aae8ec--80c4c342043a4567bda5b4a7cd961140 0f7531e556fb451eb585b2a3fe998e8d 80c4c342043a4567bda5b4a7cd961140--0f7531e556fb451eb585b2a3fe998e8d 6a6d048fb66b4be099c05b9584ac0aae 0f7531e556fb451eb585b2a3fe998e8d--6a6d048fb66b4be099c05b9584ac0aae b91a485fe861427484ad088a7c53ed4c 6a6d048fb66b4be099c05b9584ac0aae--b91a485fe861427484ad088a7c53ed4c e412e8542e9a47e8ba43ee32d89fb17c b91a485fe861427484ad088a7c53ed4c--e412e8542e9a47e8ba43ee32d89fb17c 73b7be84b8fa4adaa4f5116eba5a64f7 e412e8542e9a47e8ba43ee32d89fb17c--73b7be84b8fa4adaa4f5116eba5a64f7 987a53acd9bb43b2bbb5a1e7977c3019 73b7be84b8fa4adaa4f5116eba5a64f7--987a53acd9bb43b2bbb5a1e7977c3019 d97c6373ac4440028dc360d44592a5f0 987a53acd9bb43b2bbb5a1e7977c3019--d97c6373ac4440028dc360d44592a5f0 143c6b4c16bb4da1978a97d2cca06bb6 d97c6373ac4440028dc360d44592a5f0--143c6b4c16bb4da1978a97d2cca06bb6 03ee55a0f115490ba6c0f0bb5de35a33 143c6b4c16bb4da1978a97d2cca06bb6--03ee55a0f115490ba6c0f0bb5de35a33 d99f1cfe6b64443fbe52d92e3660c5a7 03ee55a0f115490ba6c0f0bb5de35a33--d99f1cfe6b64443fbe52d92e3660c5a7 91b563dca7674210a83fd6bb7785209b d99f1cfe6b64443fbe52d92e3660c5a7--91b563dca7674210a83fd6bb7785209b c1fe2d4793a34714a3c30619085634a6 91b563dca7674210a83fd6bb7785209b--c1fe2d4793a34714a3c30619085634a6 19ac75bcd8ba481a87e57829415c93c7 c1fe2d4793a34714a3c30619085634a6--19ac75bcd8ba481a87e57829415c93c7 027b7bf779ca41278ee9dd56e2387f8e 19ac75bcd8ba481a87e57829415c93c7--027b7bf779ca41278ee9dd56e2387f8e 64cee8a00ca740b8b060773892435793 027b7bf779ca41278ee9dd56e2387f8e--64cee8a00ca740b8b060773892435793 92c1c671061d4e1282853beb36ec02f6 64cee8a00ca740b8b060773892435793--92c1c671061d4e1282853beb36ec02f6 b3b695043135427ea3759216c59cc02b 92c1c671061d4e1282853beb36ec02f6--b3b695043135427ea3759216c59cc02b f2f308add9d84878907e3f101b79f702 b3b695043135427ea3759216c59cc02b--f2f308add9d84878907e3f101b79f702 8c0fecd0b04741ceac2e443c43cf5b8a f2f308add9d84878907e3f101b79f702--8c0fecd0b04741ceac2e443c43cf5b8a 7222650856774d3b9f218f59f824c2c5 8c0fecd0b04741ceac2e443c43cf5b8a--7222650856774d3b9f218f59f824c2c5 11a0e6053a0344b18e1c5b0bf772620d 7222650856774d3b9f218f59f824c2c5--11a0e6053a0344b18e1c5b0bf772620d cfc29501bc7243b5a5f1e6d4383ce286 11a0e6053a0344b18e1c5b0bf772620d--cfc29501bc7243b5a5f1e6d4383ce286 7f4bcc7753ff4b0f8709715810c1cdf5 cfc29501bc7243b5a5f1e6d4383ce286--7f4bcc7753ff4b0f8709715810c1cdf5 3628c2c4f2c2445a8a65b81b9179e4b9 7f4bcc7753ff4b0f8709715810c1cdf5--3628c2c4f2c2445a8a65b81b9179e4b9 5f1c46d4000f42a98b42fa5537237556 3628c2c4f2c2445a8a65b81b9179e4b9--5f1c46d4000f42a98b42fa5537237556 be3b280e9f724b92b57c74c9556e8943 5f1c46d4000f42a98b42fa5537237556--be3b280e9f724b92b57c74c9556e8943 e15a020e68834388b2e566817866b755 be3b280e9f724b92b57c74c9556e8943--e15a020e68834388b2e566817866b755 4d24723fe1684d1bb3f386f8f7b96ea2 e15a020e68834388b2e566817866b755--4d24723fe1684d1bb3f386f8f7b96ea2 fc8e10bf69cc4122817f013598a8f422 4d24723fe1684d1bb3f386f8f7b96ea2--fc8e10bf69cc4122817f013598a8f422 455d6fc5cf214593951cb04df2bab09d fc8e10bf69cc4122817f013598a8f422--455d6fc5cf214593951cb04df2bab09d 031bbb9d494e4873b219b752b3fab7cb 455d6fc5cf214593951cb04df2bab09d--031bbb9d494e4873b219b752b3fab7cb a71c6c55ab0d4c2a878049fe1090fbde 031bbb9d494e4873b219b752b3fab7cb--a71c6c55ab0d4c2a878049fe1090fbde c3cf55ffb7dd44f2aa483e4badf1c7bf a71c6c55ab0d4c2a878049fe1090fbde--c3cf55ffb7dd44f2aa483e4badf1c7bf 738722fad687452498c07039b10ddab6 c3cf55ffb7dd44f2aa483e4badf1c7bf--738722fad687452498c07039b10ddab6 3dda68a8ec2f426cb565cc63dcadc43c 738722fad687452498c07039b10ddab6--3dda68a8ec2f426cb565cc63dcadc43c c7d79ebb6e944e9881930d5a4de7ee62 3dda68a8ec2f426cb565cc63dcadc43c--c7d79ebb6e944e9881930d5a4de7ee62 7f42b87f74304dd09c6018991c4fdb3a c7d79ebb6e944e9881930d5a4de7ee62--7f42b87f74304dd09c6018991c4fdb3a 051314fd8f78447dbce812e5c4542554 7f42b87f74304dd09c6018991c4fdb3a--051314fd8f78447dbce812e5c4542554 a261219bff8c42c589ab356637b4a20d 051314fd8f78447dbce812e5c4542554--a261219bff8c42c589ab356637b4a20d 4fbf8810f25347bbaa1c19fa9e171f81 a261219bff8c42c589ab356637b4a20d--4fbf8810f25347bbaa1c19fa9e171f81 ec3b5ce9eb274393a50278012e16def8 4fbf8810f25347bbaa1c19fa9e171f81--ec3b5ce9eb274393a50278012e16def8 e6ad1e6826e8424d8fb2702c00e9f6a0 ec3b5ce9eb274393a50278012e16def8--e6ad1e6826e8424d8fb2702c00e9f6a0 5fc1529e3f1f4e0a8a04de32d3ef5366 e6ad1e6826e8424d8fb2702c00e9f6a0--5fc1529e3f1f4e0a8a04de32d3ef5366 5c599a8095654373afbbac573b41755f RX(b10) 5fc1529e3f1f4e0a8a04de32d3ef5366--5c599a8095654373afbbac573b41755f a4fc6270766b4230a6a4bfe648b35799 5c599a8095654373afbbac573b41755f--a4fc6270766b4230a6a4bfe648b35799 7b49e063bf1c4f7aa0f6e5ef9d248e42 9f5d208b349c45dfbe1b6a8898b83cee X 695d670d2e954487bbec97d2378a96eb--9f5d208b349c45dfbe1b6a8898b83cee 23e94fc5e3ac43d89a7837e702d02a52 2 9f5d208b349c45dfbe1b6a8898b83cee--548874ce627246b3816a617c7146054a 131b9f8d61784f50870ddcfd0dbc1ac2 9f5d208b349c45dfbe1b6a8898b83cee--131b9f8d61784f50870ddcfd0dbc1ac2 e938c1a3dfeb44aebc11394df998022b 131b9f8d61784f50870ddcfd0dbc1ac2--e938c1a3dfeb44aebc11394df998022b 66793e0bb7b640bd857df960ab030d2b e938c1a3dfeb44aebc11394df998022b--66793e0bb7b640bd857df960ab030d2b fabf7a426ad3437d876f49ea323e814d 66793e0bb7b640bd857df960ab030d2b--fabf7a426ad3437d876f49ea323e814d be2354ca4c564b178aa7ad3ce169f7c8 fabf7a426ad3437d876f49ea323e814d--be2354ca4c564b178aa7ad3ce169f7c8 bebb1fed994f48d4bdaaf293b2d4b9dd be2354ca4c564b178aa7ad3ce169f7c8--bebb1fed994f48d4bdaaf293b2d4b9dd 0a4d55f1707f4b79a97caf1741be4b86 bebb1fed994f48d4bdaaf293b2d4b9dd--0a4d55f1707f4b79a97caf1741be4b86 8d74b02e10374ab8affc60bf1c400751 0a4d55f1707f4b79a97caf1741be4b86--8d74b02e10374ab8affc60bf1c400751 197d4777984541079bc6211ff5e4d0d9 8d74b02e10374ab8affc60bf1c400751--197d4777984541079bc6211ff5e4d0d9 239c31b63c794d82b8d330bf594553c8 197d4777984541079bc6211ff5e4d0d9--239c31b63c794d82b8d330bf594553c8 f30cf36afa4b4c52abb59e236be7151f 239c31b63c794d82b8d330bf594553c8--f30cf36afa4b4c52abb59e236be7151f dcb3888eae394b69a9effded80059130 f30cf36afa4b4c52abb59e236be7151f--dcb3888eae394b69a9effded80059130 01c1b5fcdab1466998a05f98f58b00e5 dcb3888eae394b69a9effded80059130--01c1b5fcdab1466998a05f98f58b00e5 4800bcc656704543851f2626c9fb0573 X 01c1b5fcdab1466998a05f98f58b00e5--4800bcc656704543851f2626c9fb0573 4800bcc656704543851f2626c9fb0573--01690ffcda4b4967ad8bd7ee7df89b20 33bb248332ec432d9677d0049bad6137 X 4800bcc656704543851f2626c9fb0573--33bb248332ec432d9677d0049bad6137 33bb248332ec432d9677d0049bad6137--04084aedda9c466a9b69dfb2a4350e88 943b2effb9174378abe1a3c0b315bc6c RZ(-1.0*g0) 33bb248332ec432d9677d0049bad6137--943b2effb9174378abe1a3c0b315bc6c 675c727936794b3fabd060fc21cbb00c X 943b2effb9174378abe1a3c0b315bc6c--675c727936794b3fabd060fc21cbb00c 675c727936794b3fabd060fc21cbb00c--5ec18bb1c732453d88d63142ff7d8257 2ea93cfee48d4acd94cd8de78432b918 X 675c727936794b3fabd060fc21cbb00c--2ea93cfee48d4acd94cd8de78432b918 2ea93cfee48d4acd94cd8de78432b918--cab3482b30af4367957aebecdbc871b1 36564b69a7a2445dbb33853cb5a2901c 2ea93cfee48d4acd94cd8de78432b918--36564b69a7a2445dbb33853cb5a2901c f3cb3614f0774c6d99c7734aef515d97 36564b69a7a2445dbb33853cb5a2901c--f3cb3614f0774c6d99c7734aef515d97 fb7a724e783944a1bd63869d1baf1959 f3cb3614f0774c6d99c7734aef515d97--fb7a724e783944a1bd63869d1baf1959 020a3309180c43ac86e6119080964645 fb7a724e783944a1bd63869d1baf1959--020a3309180c43ac86e6119080964645 3528db914df9494bad5cf1db2a76e081 020a3309180c43ac86e6119080964645--3528db914df9494bad5cf1db2a76e081 bc1ac393a9f54fa3afae2c554a879557 3528db914df9494bad5cf1db2a76e081--bc1ac393a9f54fa3afae2c554a879557 0675a27fad16485f9654543d4455822b bc1ac393a9f54fa3afae2c554a879557--0675a27fad16485f9654543d4455822b 7141761b19d44c7a93f3ba4cb76b93bc X 0675a27fad16485f9654543d4455822b--7141761b19d44c7a93f3ba4cb76b93bc 7141761b19d44c7a93f3ba4cb76b93bc--3d933b5b02754faab8b5f6f43110fb8a d67c5f688f2049ca99446f459719593d X 7141761b19d44c7a93f3ba4cb76b93bc--d67c5f688f2049ca99446f459719593d d67c5f688f2049ca99446f459719593d--7a13f9fa5d34466f9502dc247727c2e4 eb9d202f9a3b4cf0a4861d30f206e8ec d67c5f688f2049ca99446f459719593d--eb9d202f9a3b4cf0a4861d30f206e8ec 76591965fe7749dba45703724c067712 eb9d202f9a3b4cf0a4861d30f206e8ec--76591965fe7749dba45703724c067712 017bf379c8bf4b3b909ad3729e69f19c 76591965fe7749dba45703724c067712--017bf379c8bf4b3b909ad3729e69f19c 039009bf33ad4d739f7442c863874364 017bf379c8bf4b3b909ad3729e69f19c--039009bf33ad4d739f7442c863874364 fb2abf8e5ce648deaf9c413901001b67 039009bf33ad4d739f7442c863874364--fb2abf8e5ce648deaf9c413901001b67 66a95c05035d41ce9023d603a6aa7a22 fb2abf8e5ce648deaf9c413901001b67--66a95c05035d41ce9023d603a6aa7a22 9226f8ff55d34184873a17c20a8273f0 66a95c05035d41ce9023d603a6aa7a22--9226f8ff55d34184873a17c20a8273f0 d64b544597ed43eb942082e5d4b86c72 9226f8ff55d34184873a17c20a8273f0--d64b544597ed43eb942082e5d4b86c72 5090979b353c47b7bfe2d2e3b8c56e1e d64b544597ed43eb942082e5d4b86c72--5090979b353c47b7bfe2d2e3b8c56e1e 1a43ee56d5754c3c9a239c038b472c3d 5090979b353c47b7bfe2d2e3b8c56e1e--1a43ee56d5754c3c9a239c038b472c3d aa7cd435ce544c008f384208e07a6d18 1a43ee56d5754c3c9a239c038b472c3d--aa7cd435ce544c008f384208e07a6d18 f906702cf25d42d9b2ebb78cc91c953e X aa7cd435ce544c008f384208e07a6d18--f906702cf25d42d9b2ebb78cc91c953e f906702cf25d42d9b2ebb78cc91c953e--d7f58df67d3d45958c08d2d85ec746aa dc6f90303c754f3a97e66cc21ab5b7f5 f906702cf25d42d9b2ebb78cc91c953e--dc6f90303c754f3a97e66cc21ab5b7f5 cf96d94cac5c4635a819d2d5b3f88261 dc6f90303c754f3a97e66cc21ab5b7f5--cf96d94cac5c4635a819d2d5b3f88261 2d28d898e4414b6d8c0d3a15b901d326 cf96d94cac5c4635a819d2d5b3f88261--2d28d898e4414b6d8c0d3a15b901d326 7cb76051e4ff4f40a7f66eb140dfe733 2d28d898e4414b6d8c0d3a15b901d326--7cb76051e4ff4f40a7f66eb140dfe733 afc3330b65f542b8b83137fd2d79147a 7cb76051e4ff4f40a7f66eb140dfe733--afc3330b65f542b8b83137fd2d79147a 15de4d37373e417c96707372e2ea11ac afc3330b65f542b8b83137fd2d79147a--15de4d37373e417c96707372e2ea11ac 7c829a54112049debd006badc4075e4b 15de4d37373e417c96707372e2ea11ac--7c829a54112049debd006badc4075e4b bb6ba2fc8c384c4f8579cb08f6c0d094 7c829a54112049debd006badc4075e4b--bb6ba2fc8c384c4f8579cb08f6c0d094 7d51bbfd9e994a13a58f83bf19e30ff4 bb6ba2fc8c384c4f8579cb08f6c0d094--7d51bbfd9e994a13a58f83bf19e30ff4 c2b59877b7c34c959a68866f2f3fab7b 7d51bbfd9e994a13a58f83bf19e30ff4--c2b59877b7c34c959a68866f2f3fab7b 2a554acfaa674d3f936f0b34def999a3 c2b59877b7c34c959a68866f2f3fab7b--2a554acfaa674d3f936f0b34def999a3 669cf5ea817b48669d886388c5e365ca 2a554acfaa674d3f936f0b34def999a3--669cf5ea817b48669d886388c5e365ca ec25525980a342278a858ca7d18508e6 669cf5ea817b48669d886388c5e365ca--ec25525980a342278a858ca7d18508e6 d04c6a82678845759c7405632da96d41 ec25525980a342278a858ca7d18508e6--d04c6a82678845759c7405632da96d41 d7909f02a79343b28820f012377947c7 d04c6a82678845759c7405632da96d41--d7909f02a79343b28820f012377947c7 b1e17e151e1f403a92b5451ac95b406b d7909f02a79343b28820f012377947c7--b1e17e151e1f403a92b5451ac95b406b d0d9c97bf1e545c38febd2b882340b9d b1e17e151e1f403a92b5451ac95b406b--d0d9c97bf1e545c38febd2b882340b9d a24525cea30e4c2b92bc0b1072e0a3cc d0d9c97bf1e545c38febd2b882340b9d--a24525cea30e4c2b92bc0b1072e0a3cc 1ac9523d1f3f45f093a27882af4d7b88 a24525cea30e4c2b92bc0b1072e0a3cc--1ac9523d1f3f45f093a27882af4d7b88 f6fd3f6e2139426d814ff08d20074061 1ac9523d1f3f45f093a27882af4d7b88--f6fd3f6e2139426d814ff08d20074061 4485843e42f444d899b0dc6ccdeeb5a7 f6fd3f6e2139426d814ff08d20074061--4485843e42f444d899b0dc6ccdeeb5a7 f8f1bf99c0ee42f6830adc6522a43575 4485843e42f444d899b0dc6ccdeeb5a7--f8f1bf99c0ee42f6830adc6522a43575 93e1df9c103d46f9b7193b9e6b183c73 f8f1bf99c0ee42f6830adc6522a43575--93e1df9c103d46f9b7193b9e6b183c73 413ffbd820804cf6b6ef8445455c010b 93e1df9c103d46f9b7193b9e6b183c73--413ffbd820804cf6b6ef8445455c010b 0b618ebec4f641cbb7e4d90a22f91127 413ffbd820804cf6b6ef8445455c010b--0b618ebec4f641cbb7e4d90a22f91127 58f8a3c7ed2b41cabdcef161aee9bd74 0b618ebec4f641cbb7e4d90a22f91127--58f8a3c7ed2b41cabdcef161aee9bd74 00a01cfae0754d87b6c44df8f28a807b 58f8a3c7ed2b41cabdcef161aee9bd74--00a01cfae0754d87b6c44df8f28a807b e2527d2c23aa4b23b6dd520529c5e693 00a01cfae0754d87b6c44df8f28a807b--e2527d2c23aa4b23b6dd520529c5e693 40533b26bea04045a0440acf2505e53f e2527d2c23aa4b23b6dd520529c5e693--40533b26bea04045a0440acf2505e53f 3998a800df144cad88cc5e9be4f41067 40533b26bea04045a0440acf2505e53f--3998a800df144cad88cc5e9be4f41067 77bc9e03b3a54d4f87967b1c5d50425a 3998a800df144cad88cc5e9be4f41067--77bc9e03b3a54d4f87967b1c5d50425a f09214700d824be388fc04825b0b7345 77bc9e03b3a54d4f87967b1c5d50425a--f09214700d824be388fc04825b0b7345 666d746b026242a385a172cf18d1880b f09214700d824be388fc04825b0b7345--666d746b026242a385a172cf18d1880b 588a52585c7a4247b20db27f344d55c6 666d746b026242a385a172cf18d1880b--588a52585c7a4247b20db27f344d55c6 9e5d3cb7f7e24a6aafa0234399b189c1 588a52585c7a4247b20db27f344d55c6--9e5d3cb7f7e24a6aafa0234399b189c1 8e7b77de958c40c78d542ae5f942908e 9e5d3cb7f7e24a6aafa0234399b189c1--8e7b77de958c40c78d542ae5f942908e 4726297ecabe4e6298b493912a18b00d 8e7b77de958c40c78d542ae5f942908e--4726297ecabe4e6298b493912a18b00d b4f2cae79bba4e3db95228f1efc10be7 4726297ecabe4e6298b493912a18b00d--b4f2cae79bba4e3db95228f1efc10be7 2c699093908b46c3aa8550011b7fc157 b4f2cae79bba4e3db95228f1efc10be7--2c699093908b46c3aa8550011b7fc157 c106f408c4034441928af7daaba4705f 2c699093908b46c3aa8550011b7fc157--c106f408c4034441928af7daaba4705f 6cfb60f2e85444b298553ebe371bfd3d c106f408c4034441928af7daaba4705f--6cfb60f2e85444b298553ebe371bfd3d d59c78ab28bf4b7c85da8dfe0dd1d23b 6cfb60f2e85444b298553ebe371bfd3d--d59c78ab28bf4b7c85da8dfe0dd1d23b 6e70c8cc7f214938a80e84fb45a30db5 d59c78ab28bf4b7c85da8dfe0dd1d23b--6e70c8cc7f214938a80e84fb45a30db5 9ae98b25858a4cde88dcb55f361952fa 6e70c8cc7f214938a80e84fb45a30db5--9ae98b25858a4cde88dcb55f361952fa 83f346a93c944b419d29698653b3e89d 9ae98b25858a4cde88dcb55f361952fa--83f346a93c944b419d29698653b3e89d 3020dad25c724839be7b2f3aa8c63e5e 83f346a93c944b419d29698653b3e89d--3020dad25c724839be7b2f3aa8c63e5e 8a8705d2e2144a01ab93023e78ffbb38 3020dad25c724839be7b2f3aa8c63e5e--8a8705d2e2144a01ab93023e78ffbb38 e0ad1ade51db49aaaefd3c96cdbe94a2 8a8705d2e2144a01ab93023e78ffbb38--e0ad1ade51db49aaaefd3c96cdbe94a2 826ff448093440f5a67e28b140ca0864 e0ad1ade51db49aaaefd3c96cdbe94a2--826ff448093440f5a67e28b140ca0864 46627674cd1a49beb71910d8659018f7 826ff448093440f5a67e28b140ca0864--46627674cd1a49beb71910d8659018f7 0eb8aec4c271468da0b1ce8c35aca7df 46627674cd1a49beb71910d8659018f7--0eb8aec4c271468da0b1ce8c35aca7df 3ff48828ba5e4bfb84a6f1d999e978ab 0eb8aec4c271468da0b1ce8c35aca7df--3ff48828ba5e4bfb84a6f1d999e978ab 60c1f58c50d541c1877a2d1ea6158452 3ff48828ba5e4bfb84a6f1d999e978ab--60c1f58c50d541c1877a2d1ea6158452 6fb20c52ea5b436383a2770aaff8bb75 60c1f58c50d541c1877a2d1ea6158452--6fb20c52ea5b436383a2770aaff8bb75 563e9096a6c844188511f98fde835b95 6fb20c52ea5b436383a2770aaff8bb75--563e9096a6c844188511f98fde835b95 5ea5c42de31340dc943eb494b2995268 563e9096a6c844188511f98fde835b95--5ea5c42de31340dc943eb494b2995268 3c22b6310e414d2fa1b51d6f4a90fd43 5ea5c42de31340dc943eb494b2995268--3c22b6310e414d2fa1b51d6f4a90fd43 3a8cf51db55e4941a84ee947d929f31e 3c22b6310e414d2fa1b51d6f4a90fd43--3a8cf51db55e4941a84ee947d929f31e 78da90fa5a6c452b9f55b4dd78a26162 3a8cf51db55e4941a84ee947d929f31e--78da90fa5a6c452b9f55b4dd78a26162 4654194b92604b60b08e51c07bb9a6ee 78da90fa5a6c452b9f55b4dd78a26162--4654194b92604b60b08e51c07bb9a6ee 1c68576963644468a5b14fb1a55ca492 4654194b92604b60b08e51c07bb9a6ee--1c68576963644468a5b14fb1a55ca492 1dcc3e5ddfe346839384343331b313b1 1c68576963644468a5b14fb1a55ca492--1dcc3e5ddfe346839384343331b313b1 35f4cc6e448c432f88c383f08f33daae 1dcc3e5ddfe346839384343331b313b1--35f4cc6e448c432f88c383f08f33daae f57fe7ec3e384e1fb059ab01eb1c0389 35f4cc6e448c432f88c383f08f33daae--f57fe7ec3e384e1fb059ab01eb1c0389 c24b7be89bb14b96bbabc9ab2ef68b8c f57fe7ec3e384e1fb059ab01eb1c0389--c24b7be89bb14b96bbabc9ab2ef68b8c 76fe9bfb76ea4be8850a07eccf4396c8 c24b7be89bb14b96bbabc9ab2ef68b8c--76fe9bfb76ea4be8850a07eccf4396c8 d3be87bb56a141c181d2da1f46c98fb1 76fe9bfb76ea4be8850a07eccf4396c8--d3be87bb56a141c181d2da1f46c98fb1 ff395a5ae1d74ab2a021a7ebe486bb7c d3be87bb56a141c181d2da1f46c98fb1--ff395a5ae1d74ab2a021a7ebe486bb7c 6e8b960203124e2a8a704288916579b1 ff395a5ae1d74ab2a021a7ebe486bb7c--6e8b960203124e2a8a704288916579b1 1bd260636a7541aca283d8f0fb1607ab 6e8b960203124e2a8a704288916579b1--1bd260636a7541aca283d8f0fb1607ab 63322b8eca4c4bf08233631b7a49fe50 1bd260636a7541aca283d8f0fb1607ab--63322b8eca4c4bf08233631b7a49fe50 3375bc2ea84f4e2a8c37c827699aa6df 63322b8eca4c4bf08233631b7a49fe50--3375bc2ea84f4e2a8c37c827699aa6df 002d4e3bba6941289efbdef4663dda47 3375bc2ea84f4e2a8c37c827699aa6df--002d4e3bba6941289efbdef4663dda47 88116dbd3e1e4fe1905c514cd2f94f97 002d4e3bba6941289efbdef4663dda47--88116dbd3e1e4fe1905c514cd2f94f97 248b1b03dce440bb8415b48fcbb25981 88116dbd3e1e4fe1905c514cd2f94f97--248b1b03dce440bb8415b48fcbb25981 46ed5ef24fd143e69fe521a791e8d173 248b1b03dce440bb8415b48fcbb25981--46ed5ef24fd143e69fe521a791e8d173 f57cbf16b6bc468d867e907631360bba 46ed5ef24fd143e69fe521a791e8d173--f57cbf16b6bc468d867e907631360bba d7e0e2cd7dca4af1a6ff293ca36dfae7 f57cbf16b6bc468d867e907631360bba--d7e0e2cd7dca4af1a6ff293ca36dfae7 34bd2629b3d84d5eac19c2ac9bc2dc3f d7e0e2cd7dca4af1a6ff293ca36dfae7--34bd2629b3d84d5eac19c2ac9bc2dc3f 4d5345abac134282a5904dc512af48c7 34bd2629b3d84d5eac19c2ac9bc2dc3f--4d5345abac134282a5904dc512af48c7 2f5830b2631242aab1b91b3b3cc9a73a 4d5345abac134282a5904dc512af48c7--2f5830b2631242aab1b91b3b3cc9a73a bfc649b46509412eb4a1087f61ffd70c 2f5830b2631242aab1b91b3b3cc9a73a--bfc649b46509412eb4a1087f61ffd70c 17c62513e45d490f88ce06ef6644a548 bfc649b46509412eb4a1087f61ffd70c--17c62513e45d490f88ce06ef6644a548 7a191666b1ee484aacd30e62a1841e2e 17c62513e45d490f88ce06ef6644a548--7a191666b1ee484aacd30e62a1841e2e 473de9857a2e45ae851cfcd27e317f55 7a191666b1ee484aacd30e62a1841e2e--473de9857a2e45ae851cfcd27e317f55 e5e9cb5523c94d168e45e47f4ae859ea 473de9857a2e45ae851cfcd27e317f55--e5e9cb5523c94d168e45e47f4ae859ea b11c07bc7b7a4d43bba081c63a6efc4f e5e9cb5523c94d168e45e47f4ae859ea--b11c07bc7b7a4d43bba081c63a6efc4f 7ecfc455d1904519a6795fb32a1abeb9 b11c07bc7b7a4d43bba081c63a6efc4f--7ecfc455d1904519a6795fb32a1abeb9 d6e93c583338417f866abcd13d4a957b 7ecfc455d1904519a6795fb32a1abeb9--d6e93c583338417f866abcd13d4a957b 4f272dceba4140a38d4513dde153f1b1 RX(b01) d6e93c583338417f866abcd13d4a957b--4f272dceba4140a38d4513dde153f1b1 f9fe54176e054bc59cd0bce85296d924 X 4f272dceba4140a38d4513dde153f1b1--f9fe54176e054bc59cd0bce85296d924 f9fe54176e054bc59cd0bce85296d924--ff4ed23f71904df5be1d95daadd78c6a d2cd0bb181bf41e2af50f55618c82b77 f9fe54176e054bc59cd0bce85296d924--d2cd0bb181bf41e2af50f55618c82b77 80e657e3dcfe405b94e311e6493e6c3c d2cd0bb181bf41e2af50f55618c82b77--80e657e3dcfe405b94e311e6493e6c3c 5c6b441c108e4710834cff384e847729 80e657e3dcfe405b94e311e6493e6c3c--5c6b441c108e4710834cff384e847729 e60f8bf3efcc4417ab6077258d5c6944 5c6b441c108e4710834cff384e847729--e60f8bf3efcc4417ab6077258d5c6944 68adccd0134149cb8090fd5343174a42 e60f8bf3efcc4417ab6077258d5c6944--68adccd0134149cb8090fd5343174a42 d42f2bdf372048ac803262e5637f3351 68adccd0134149cb8090fd5343174a42--d42f2bdf372048ac803262e5637f3351 2905b48c2337440aac84be1c3eb889b7 d42f2bdf372048ac803262e5637f3351--2905b48c2337440aac84be1c3eb889b7 095670b9ac604e9dacd66554c94be9ce 2905b48c2337440aac84be1c3eb889b7--095670b9ac604e9dacd66554c94be9ce b49c96d76e344685ba3ac2d4e95998f0 095670b9ac604e9dacd66554c94be9ce--b49c96d76e344685ba3ac2d4e95998f0 cec693ef9f804965a62efe05b65c00b0 b49c96d76e344685ba3ac2d4e95998f0--cec693ef9f804965a62efe05b65c00b0 2da70e17e7cd464489b0e39ed5cbc555 cec693ef9f804965a62efe05b65c00b0--2da70e17e7cd464489b0e39ed5cbc555 cce0d192b38c46ecbe0c2ac10fb300bb 2da70e17e7cd464489b0e39ed5cbc555--cce0d192b38c46ecbe0c2ac10fb300bb 8e5a7a2a81484402a2ce6d96d07bf477 cce0d192b38c46ecbe0c2ac10fb300bb--8e5a7a2a81484402a2ce6d96d07bf477 e1df8c95186b48adbd81e9950e86bbdb X 8e5a7a2a81484402a2ce6d96d07bf477--e1df8c95186b48adbd81e9950e86bbdb e1df8c95186b48adbd81e9950e86bbdb--a60fdf1a29b74cbf886e9928b990d286 7f507aad03824224a09fc8b3e8406209 X e1df8c95186b48adbd81e9950e86bbdb--7f507aad03824224a09fc8b3e8406209 7f507aad03824224a09fc8b3e8406209--1bc1a5a299124355b38a242fa67a7125 e77537916040486ebb6434f184386e41 RZ(-1.0*g1) 7f507aad03824224a09fc8b3e8406209--e77537916040486ebb6434f184386e41 251a7944b4fd449f818e004625c70bd0 X e77537916040486ebb6434f184386e41--251a7944b4fd449f818e004625c70bd0 251a7944b4fd449f818e004625c70bd0--b0e2348b6edf4e96b9f5c1b0a7d920b1 a43b97fad389421d92306fb83068b75d X 251a7944b4fd449f818e004625c70bd0--a43b97fad389421d92306fb83068b75d a43b97fad389421d92306fb83068b75d--9839b1f725da46c5be1d75b18a53dfdb b3cfc67a2e72406792e4f32c6bd23fb7 a43b97fad389421d92306fb83068b75d--b3cfc67a2e72406792e4f32c6bd23fb7 5c96e9d507614c5792be5bc3cfa8ad84 b3cfc67a2e72406792e4f32c6bd23fb7--5c96e9d507614c5792be5bc3cfa8ad84 c74ab992f2b942ff8657518681b2fdb7 5c96e9d507614c5792be5bc3cfa8ad84--c74ab992f2b942ff8657518681b2fdb7 4ad2b7e11f0e42a095b05e8dfcc2788c c74ab992f2b942ff8657518681b2fdb7--4ad2b7e11f0e42a095b05e8dfcc2788c 25fdc8c4dea3421eb97f2300c6be041d 4ad2b7e11f0e42a095b05e8dfcc2788c--25fdc8c4dea3421eb97f2300c6be041d 23f006a453a64f18bb5fe45ed8156d95 25fdc8c4dea3421eb97f2300c6be041d--23f006a453a64f18bb5fe45ed8156d95 6c43d3c67aef4ac598a101fb76d87f93 23f006a453a64f18bb5fe45ed8156d95--6c43d3c67aef4ac598a101fb76d87f93 f20926fc09cc46278d9549d72fd17385 X 6c43d3c67aef4ac598a101fb76d87f93--f20926fc09cc46278d9549d72fd17385 f20926fc09cc46278d9549d72fd17385--a223302b589145ca89c64bb67f5cfc6f adb852b756e64a5aa3495e744e38c39f X f20926fc09cc46278d9549d72fd17385--adb852b756e64a5aa3495e744e38c39f adb852b756e64a5aa3495e744e38c39f--fc9f085c587a41b5bd36d74e464fdd03 6a847121957741c0b1252a128f734599 adb852b756e64a5aa3495e744e38c39f--6a847121957741c0b1252a128f734599 a815609f4ff34c679bf3844a18b7cd74 6a847121957741c0b1252a128f734599--a815609f4ff34c679bf3844a18b7cd74 0a5da7e5040f436caab4ab16fc95c363 a815609f4ff34c679bf3844a18b7cd74--0a5da7e5040f436caab4ab16fc95c363 b7b5a627547c458da1eb10b29b4e5cf1 0a5da7e5040f436caab4ab16fc95c363--b7b5a627547c458da1eb10b29b4e5cf1 a1c7107dd19e4c28939222e8a7d348ec b7b5a627547c458da1eb10b29b4e5cf1--a1c7107dd19e4c28939222e8a7d348ec 5b5001537f0d48918d9159a6658c1208 a1c7107dd19e4c28939222e8a7d348ec--5b5001537f0d48918d9159a6658c1208 1bbd3f51fc15451290fc98b32f0e319d 5b5001537f0d48918d9159a6658c1208--1bbd3f51fc15451290fc98b32f0e319d 423405868eff4ec68423c36549e6939d 1bbd3f51fc15451290fc98b32f0e319d--423405868eff4ec68423c36549e6939d ceefc75c95b643b7938dc46c9c0f0840 423405868eff4ec68423c36549e6939d--ceefc75c95b643b7938dc46c9c0f0840 6eb25519dd144caaa3b7d4468fdab501 ceefc75c95b643b7938dc46c9c0f0840--6eb25519dd144caaa3b7d4468fdab501 101c2d90c56144ac9a2728446cdaff3c 6eb25519dd144caaa3b7d4468fdab501--101c2d90c56144ac9a2728446cdaff3c e6b4b85fffa14818a4d83c699beca264 X 101c2d90c56144ac9a2728446cdaff3c--e6b4b85fffa14818a4d83c699beca264 e6b4b85fffa14818a4d83c699beca264--55368ed76b69423db0cfdaa6191998e8 161b6f922c60476c98a20e72b86f5ffc e6b4b85fffa14818a4d83c699beca264--161b6f922c60476c98a20e72b86f5ffc ea04a813a7ed4b0f92d366548681eeb4 161b6f922c60476c98a20e72b86f5ffc--ea04a813a7ed4b0f92d366548681eeb4 07f73904d793431e9b341ddcdce3a6e8 ea04a813a7ed4b0f92d366548681eeb4--07f73904d793431e9b341ddcdce3a6e8 5a387cbbd53f4ff187d14a6b30ae9da8 07f73904d793431e9b341ddcdce3a6e8--5a387cbbd53f4ff187d14a6b30ae9da8 302f40105a044500866aec3fbe1c7a1e 5a387cbbd53f4ff187d14a6b30ae9da8--302f40105a044500866aec3fbe1c7a1e bd78c600d8e74bd0820b2cda8db6db7a 302f40105a044500866aec3fbe1c7a1e--bd78c600d8e74bd0820b2cda8db6db7a 4e21f7e06c1049ac8ead1a3d2caf9013 bd78c600d8e74bd0820b2cda8db6db7a--4e21f7e06c1049ac8ead1a3d2caf9013 66a1883ceb644470a886c569a5172a8d 4e21f7e06c1049ac8ead1a3d2caf9013--66a1883ceb644470a886c569a5172a8d 6acd6e63afa84bfeb85c86c6c0510c59 66a1883ceb644470a886c569a5172a8d--6acd6e63afa84bfeb85c86c6c0510c59 79892da53a2d4c4080b2c84478e513bb 6acd6e63afa84bfeb85c86c6c0510c59--79892da53a2d4c4080b2c84478e513bb 19bfdc7ce95a4beb8d1e1982fb47a732 79892da53a2d4c4080b2c84478e513bb--19bfdc7ce95a4beb8d1e1982fb47a732 7958790a1815481892d5b8fd6765dc04 19bfdc7ce95a4beb8d1e1982fb47a732--7958790a1815481892d5b8fd6765dc04 37cb2ad123954743821ace23ea645f4b 7958790a1815481892d5b8fd6765dc04--37cb2ad123954743821ace23ea645f4b 7868e895b9924c70b5df37c1fd089dae 37cb2ad123954743821ace23ea645f4b--7868e895b9924c70b5df37c1fd089dae 78d7718f427f4b309dd90352dfa57f1f 7868e895b9924c70b5df37c1fd089dae--78d7718f427f4b309dd90352dfa57f1f bcb5d7de2f62439dbab60b7fa08f0751 78d7718f427f4b309dd90352dfa57f1f--bcb5d7de2f62439dbab60b7fa08f0751 abaf68a1fad24c36bde6ec57387c2f67 bcb5d7de2f62439dbab60b7fa08f0751--abaf68a1fad24c36bde6ec57387c2f67 cd502ab5891c4526958dbb70e9a078a3 abaf68a1fad24c36bde6ec57387c2f67--cd502ab5891c4526958dbb70e9a078a3 d2a1a136ac924640bb4526d7f95aa3be cd502ab5891c4526958dbb70e9a078a3--d2a1a136ac924640bb4526d7f95aa3be f6ca99dd1890471b89c4014bbb8a645e d2a1a136ac924640bb4526d7f95aa3be--f6ca99dd1890471b89c4014bbb8a645e 8d873d0f7a5b41589a1fb904a620de5b f6ca99dd1890471b89c4014bbb8a645e--8d873d0f7a5b41589a1fb904a620de5b 37050c843460491c88fff1d0971d5a30 8d873d0f7a5b41589a1fb904a620de5b--37050c843460491c88fff1d0971d5a30 0dae2ca2a91c40a1bb5744d16ef4266b 37050c843460491c88fff1d0971d5a30--0dae2ca2a91c40a1bb5744d16ef4266b f082001d5b1b4770b6fab84400b28f94 0dae2ca2a91c40a1bb5744d16ef4266b--f082001d5b1b4770b6fab84400b28f94 f9d288dff80e462393dd7c3697d6ce81 f082001d5b1b4770b6fab84400b28f94--f9d288dff80e462393dd7c3697d6ce81 87e8be6a7f4e4009a821ab77129aa35d f9d288dff80e462393dd7c3697d6ce81--87e8be6a7f4e4009a821ab77129aa35d 3a5bc2bcea2d48519863704590f165d1 87e8be6a7f4e4009a821ab77129aa35d--3a5bc2bcea2d48519863704590f165d1 003d5585296b45b8adbcc21d3e952a61 3a5bc2bcea2d48519863704590f165d1--003d5585296b45b8adbcc21d3e952a61 9cb12dbececd4fe69b087099e569d537 003d5585296b45b8adbcc21d3e952a61--9cb12dbececd4fe69b087099e569d537 90a67dabe4624582a3babf999df27c2a 9cb12dbececd4fe69b087099e569d537--90a67dabe4624582a3babf999df27c2a 220ebffbcfd14d73a105c6d86c941380 90a67dabe4624582a3babf999df27c2a--220ebffbcfd14d73a105c6d86c941380 60c0d9eececa4315a9f6c5db0db90776 220ebffbcfd14d73a105c6d86c941380--60c0d9eececa4315a9f6c5db0db90776 2f6a889eb6e841f58822bd62af140008 60c0d9eececa4315a9f6c5db0db90776--2f6a889eb6e841f58822bd62af140008 9deb39de56774f97b0cc3470d29d447f 2f6a889eb6e841f58822bd62af140008--9deb39de56774f97b0cc3470d29d447f e4dee62a382a42ab8bc8baf7447c9de3 9deb39de56774f97b0cc3470d29d447f--e4dee62a382a42ab8bc8baf7447c9de3 2e098e860e7846f4af6e48a8e9c009d6 e4dee62a382a42ab8bc8baf7447c9de3--2e098e860e7846f4af6e48a8e9c009d6 97b0c9f471444e55b17da7a157feba56 2e098e860e7846f4af6e48a8e9c009d6--97b0c9f471444e55b17da7a157feba56 736604ed71a241c7bba70eef0038b5fe 97b0c9f471444e55b17da7a157feba56--736604ed71a241c7bba70eef0038b5fe 5d846fbf8df2473dbf9746906ae89705 736604ed71a241c7bba70eef0038b5fe--5d846fbf8df2473dbf9746906ae89705 7cdf59b0aab04746bb7d50e1d7e30780 5d846fbf8df2473dbf9746906ae89705--7cdf59b0aab04746bb7d50e1d7e30780 a6d3df6e51be4f528585081ace893403 7cdf59b0aab04746bb7d50e1d7e30780--a6d3df6e51be4f528585081ace893403 df1a12dc8ea04d4a99394a8c46e2a40c a6d3df6e51be4f528585081ace893403--df1a12dc8ea04d4a99394a8c46e2a40c 34dda72383be4bf4bb06c0487e5bf7c3 df1a12dc8ea04d4a99394a8c46e2a40c--34dda72383be4bf4bb06c0487e5bf7c3 2e123a31a19a48fca31143b231a4ab1a 34dda72383be4bf4bb06c0487e5bf7c3--2e123a31a19a48fca31143b231a4ab1a ecc76d6009b1494db3912684b6362822 2e123a31a19a48fca31143b231a4ab1a--ecc76d6009b1494db3912684b6362822 8bc7969734674691bb9b8839c188fdc6 ecc76d6009b1494db3912684b6362822--8bc7969734674691bb9b8839c188fdc6 6078e8aa1e664c8a8bc9b4bb7a9c6dc9 8bc7969734674691bb9b8839c188fdc6--6078e8aa1e664c8a8bc9b4bb7a9c6dc9 bd10e9c172d54ca4a5d60b6669ab5c1f 6078e8aa1e664c8a8bc9b4bb7a9c6dc9--bd10e9c172d54ca4a5d60b6669ab5c1f 861e2a68012345db9b358dc88cc8cc19 bd10e9c172d54ca4a5d60b6669ab5c1f--861e2a68012345db9b358dc88cc8cc19 cece6caf488a43d18b3fad06e609205b 861e2a68012345db9b358dc88cc8cc19--cece6caf488a43d18b3fad06e609205b 723edf09d2114dcaaa9d2db2ca8092f3 cece6caf488a43d18b3fad06e609205b--723edf09d2114dcaaa9d2db2ca8092f3 1c2e4cb938e44f5598901a81db56a843 723edf09d2114dcaaa9d2db2ca8092f3--1c2e4cb938e44f5598901a81db56a843 90301c8809f148faa02b980afe248500 1c2e4cb938e44f5598901a81db56a843--90301c8809f148faa02b980afe248500 79e29106ba164ed487c730a7ae7c15c0 90301c8809f148faa02b980afe248500--79e29106ba164ed487c730a7ae7c15c0 c5803361654444b0802a78139634d8e6 79e29106ba164ed487c730a7ae7c15c0--c5803361654444b0802a78139634d8e6 a55ec7d261c349bc88317b0f43e4579e c5803361654444b0802a78139634d8e6--a55ec7d261c349bc88317b0f43e4579e e9fd8c2b97b149e7abf7761174a79746 a55ec7d261c349bc88317b0f43e4579e--e9fd8c2b97b149e7abf7761174a79746 352e47df1c21427ba2e71e3902a40eb1 e9fd8c2b97b149e7abf7761174a79746--352e47df1c21427ba2e71e3902a40eb1 3cb295569c5546a39d733b979973c5e4 352e47df1c21427ba2e71e3902a40eb1--3cb295569c5546a39d733b979973c5e4 54f7ddda2c0a47abb2a78c74a890d38e 3cb295569c5546a39d733b979973c5e4--54f7ddda2c0a47abb2a78c74a890d38e 69cc7403d13e4c1fa4f7a781ec38d0a3 54f7ddda2c0a47abb2a78c74a890d38e--69cc7403d13e4c1fa4f7a781ec38d0a3 c3acd0518fed48de8136a5c1b3fa4614 69cc7403d13e4c1fa4f7a781ec38d0a3--c3acd0518fed48de8136a5c1b3fa4614 bfc92d9e75434aaab8acc80971d17a75 c3acd0518fed48de8136a5c1b3fa4614--bfc92d9e75434aaab8acc80971d17a75 2235a34be8cd4a559323a42dae38cb14 bfc92d9e75434aaab8acc80971d17a75--2235a34be8cd4a559323a42dae38cb14 384ed97d9e6a49deb1ddd8de9c5edac9 2235a34be8cd4a559323a42dae38cb14--384ed97d9e6a49deb1ddd8de9c5edac9 ec44e5c616c44d94833fd737aabf0bb5 384ed97d9e6a49deb1ddd8de9c5edac9--ec44e5c616c44d94833fd737aabf0bb5 ff5f99697fbc45c6aa9a9422252c0eea ec44e5c616c44d94833fd737aabf0bb5--ff5f99697fbc45c6aa9a9422252c0eea 5860db42bd454f9b963c7a6ef7516818 ff5f99697fbc45c6aa9a9422252c0eea--5860db42bd454f9b963c7a6ef7516818 1c443b8115ab4eafb3b164ccdcb0898f 5860db42bd454f9b963c7a6ef7516818--1c443b8115ab4eafb3b164ccdcb0898f e02f0846f0ea4b94bf5bc40489dc4ab8 1c443b8115ab4eafb3b164ccdcb0898f--e02f0846f0ea4b94bf5bc40489dc4ab8 e22eebf35a1c4e72a49eb543514c8766 e02f0846f0ea4b94bf5bc40489dc4ab8--e22eebf35a1c4e72a49eb543514c8766 0e571aa344d441dd8c4c2cfceb694417 e22eebf35a1c4e72a49eb543514c8766--0e571aa344d441dd8c4c2cfceb694417 db32988efcc944839e4851daeec30602 0e571aa344d441dd8c4c2cfceb694417--db32988efcc944839e4851daeec30602 73321b6837b140e58d822dcfee74ccbf db32988efcc944839e4851daeec30602--73321b6837b140e58d822dcfee74ccbf f7eb60fb9b90455caf24c16e2d4dffca 73321b6837b140e58d822dcfee74ccbf--f7eb60fb9b90455caf24c16e2d4dffca 5178c1cc641f4cbd8d0fd972d91a95b2 f7eb60fb9b90455caf24c16e2d4dffca--5178c1cc641f4cbd8d0fd972d91a95b2 df2c436c98cb45bd9df702e3c8cdbd70 5178c1cc641f4cbd8d0fd972d91a95b2--df2c436c98cb45bd9df702e3c8cdbd70 542e3bfb6a684e68a84714f0f592a828 df2c436c98cb45bd9df702e3c8cdbd70--542e3bfb6a684e68a84714f0f592a828 973c08d1b8154ba4bd123ac65fb7ac4f 542e3bfb6a684e68a84714f0f592a828--973c08d1b8154ba4bd123ac65fb7ac4f 3f18d926948e4fbd99b32da86abf6ba5 973c08d1b8154ba4bd123ac65fb7ac4f--3f18d926948e4fbd99b32da86abf6ba5 66964a70101f437db12a2e0d37e865ea 3f18d926948e4fbd99b32da86abf6ba5--66964a70101f437db12a2e0d37e865ea c639ab56a4d445baada271a8fbe40d8c 66964a70101f437db12a2e0d37e865ea--c639ab56a4d445baada271a8fbe40d8c 661ab57838344c0984eb3285ff648a88 c639ab56a4d445baada271a8fbe40d8c--661ab57838344c0984eb3285ff648a88 c96f636a2fa04d33a18f3fdca7efec6d 661ab57838344c0984eb3285ff648a88--c96f636a2fa04d33a18f3fdca7efec6d 9fa0ca8a51ce409dbdc52cd2c6071436 c96f636a2fa04d33a18f3fdca7efec6d--9fa0ca8a51ce409dbdc52cd2c6071436 e6c16bb5ddd34d8bb22f5f3097500c6f 9fa0ca8a51ce409dbdc52cd2c6071436--e6c16bb5ddd34d8bb22f5f3097500c6f 91d39b84c0f541d9bc6eca947b582e64 e6c16bb5ddd34d8bb22f5f3097500c6f--91d39b84c0f541d9bc6eca947b582e64 7751521c281f44998208b3b44d5f4561 91d39b84c0f541d9bc6eca947b582e64--7751521c281f44998208b3b44d5f4561 543f2d302448445bae738cc3a26a038f 7751521c281f44998208b3b44d5f4561--543f2d302448445bae738cc3a26a038f d450a87128a64ce2aed575d0ee39f442 RX(b11) 543f2d302448445bae738cc3a26a038f--d450a87128a64ce2aed575d0ee39f442 d450a87128a64ce2aed575d0ee39f442--7b49e063bf1c4f7aa0f6e5ef9d248e42 b1b3e090dc98414b92c93aa79d824030 60e07eb14119490385c508af45abda5b 23e94fc5e3ac43d89a7837e702d02a52--60e07eb14119490385c508af45abda5b 5b1ab9bb428141c6b6797519b723d148 3 6f2f3686473945a7aad7f4e9363d7b59 X 60e07eb14119490385c508af45abda5b--6f2f3686473945a7aad7f4e9363d7b59 6f2f3686473945a7aad7f4e9363d7b59--131b9f8d61784f50870ddcfd0dbc1ac2 c1cc654f16e84a6c9747fd283ac79e05 6f2f3686473945a7aad7f4e9363d7b59--c1cc654f16e84a6c9747fd283ac79e05 a60fddd524894ebcb7297c5ccba5460b c1cc654f16e84a6c9747fd283ac79e05--a60fddd524894ebcb7297c5ccba5460b e6b2a95dc751410191198e6693edb299 a60fddd524894ebcb7297c5ccba5460b--e6b2a95dc751410191198e6693edb299 c44204741e6846bab3e6ba1fa75247ec e6b2a95dc751410191198e6693edb299--c44204741e6846bab3e6ba1fa75247ec e756f2c5565641aa803d3e5822949f72 c44204741e6846bab3e6ba1fa75247ec--e756f2c5565641aa803d3e5822949f72 f5a172d52284404781133e2a2e089246 e756f2c5565641aa803d3e5822949f72--f5a172d52284404781133e2a2e089246 04c164f51cee4f94b5950e0ca9c94ad9 f5a172d52284404781133e2a2e089246--04c164f51cee4f94b5950e0ca9c94ad9 c187749be8bb4638ac81d8443971ad66 04c164f51cee4f94b5950e0ca9c94ad9--c187749be8bb4638ac81d8443971ad66 8fdf82be782941468ca1fd24fda7a165 c187749be8bb4638ac81d8443971ad66--8fdf82be782941468ca1fd24fda7a165 097cc2bc77ac4da69a7778fdac807ee8 8fdf82be782941468ca1fd24fda7a165--097cc2bc77ac4da69a7778fdac807ee8 1ccde31dd6254ce182a59c1584012372 097cc2bc77ac4da69a7778fdac807ee8--1ccde31dd6254ce182a59c1584012372 4cfcb122e67f48fe965bf0ac1d5d816b X 1ccde31dd6254ce182a59c1584012372--4cfcb122e67f48fe965bf0ac1d5d816b 4cfcb122e67f48fe965bf0ac1d5d816b--01c1b5fcdab1466998a05f98f58b00e5 5b4a1f4af1f04badb59d57087a1f42c8 4cfcb122e67f48fe965bf0ac1d5d816b--5b4a1f4af1f04badb59d57087a1f42c8 816be5d7610c4c44aa0d48c92f4fceee 5b4a1f4af1f04badb59d57087a1f42c8--816be5d7610c4c44aa0d48c92f4fceee dfb6349cb63f4c5c971c8755a247bc73 816be5d7610c4c44aa0d48c92f4fceee--dfb6349cb63f4c5c971c8755a247bc73 fc964e202b434f7abb5a09db54b7c05b dfb6349cb63f4c5c971c8755a247bc73--fc964e202b434f7abb5a09db54b7c05b cff0a4d680b8429f8510c868e8aed6fc fc964e202b434f7abb5a09db54b7c05b--cff0a4d680b8429f8510c868e8aed6fc 6326ad7447cb48fb941164fbb9f37df7 X cff0a4d680b8429f8510c868e8aed6fc--6326ad7447cb48fb941164fbb9f37df7 6326ad7447cb48fb941164fbb9f37df7--36564b69a7a2445dbb33853cb5a2901c 2cdaa42c98a045e7b7d2181f3113c205 6326ad7447cb48fb941164fbb9f37df7--2cdaa42c98a045e7b7d2181f3113c205 0d18a5a6d9ff456bb8da379925a77cdd 2cdaa42c98a045e7b7d2181f3113c205--0d18a5a6d9ff456bb8da379925a77cdd ab224571ae26404193c55c41da50fce3 0d18a5a6d9ff456bb8da379925a77cdd--ab224571ae26404193c55c41da50fce3 b5760236873f42108d5938d8d8dd94c8 ab224571ae26404193c55c41da50fce3--b5760236873f42108d5938d8d8dd94c8 1ed86c9148284637a613c716aa203e64 b5760236873f42108d5938d8d8dd94c8--1ed86c9148284637a613c716aa203e64 55a511a06a9b44699c2d2236de2b8935 X 1ed86c9148284637a613c716aa203e64--55a511a06a9b44699c2d2236de2b8935 55a511a06a9b44699c2d2236de2b8935--0675a27fad16485f9654543d4455822b 3ec1c665988f41dc855284a1b6aa1455 55a511a06a9b44699c2d2236de2b8935--3ec1c665988f41dc855284a1b6aa1455 6852fd3b921f4dd9986d9ce5308c1484 3ec1c665988f41dc855284a1b6aa1455--6852fd3b921f4dd9986d9ce5308c1484 b09c5e0b30d047c9be0b46a7d112c39a X 6852fd3b921f4dd9986d9ce5308c1484--b09c5e0b30d047c9be0b46a7d112c39a b09c5e0b30d047c9be0b46a7d112c39a--eb9d202f9a3b4cf0a4861d30f206e8ec f00c76085ecc4527be7bbf500d9bbe4c b09c5e0b30d047c9be0b46a7d112c39a--f00c76085ecc4527be7bbf500d9bbe4c bd801f77e9384b4180ed7bfd09a0f004 f00c76085ecc4527be7bbf500d9bbe4c--bd801f77e9384b4180ed7bfd09a0f004 752dde4e224040c599e4a0cc579ff7f9 bd801f77e9384b4180ed7bfd09a0f004--752dde4e224040c599e4a0cc579ff7f9 eab59e35621a4cf08c85cb2f6773ff90 752dde4e224040c599e4a0cc579ff7f9--eab59e35621a4cf08c85cb2f6773ff90 e4f9ea7aca49466fa2891229da7073d6 eab59e35621a4cf08c85cb2f6773ff90--e4f9ea7aca49466fa2891229da7073d6 a25584f79ae24408bf8f7541e9cff464 e4f9ea7aca49466fa2891229da7073d6--a25584f79ae24408bf8f7541e9cff464 608722b5a4644d0ea238aeea60138af3 a25584f79ae24408bf8f7541e9cff464--608722b5a4644d0ea238aeea60138af3 19da05af619146c9a9aeadbe06ff60af 608722b5a4644d0ea238aeea60138af3--19da05af619146c9a9aeadbe06ff60af fb1ce0f8565d4d2798f80730235076f2 19da05af619146c9a9aeadbe06ff60af--fb1ce0f8565d4d2798f80730235076f2 447e0a519d3144fdabf96e0153ef693c X fb1ce0f8565d4d2798f80730235076f2--447e0a519d3144fdabf96e0153ef693c 447e0a519d3144fdabf96e0153ef693c--aa7cd435ce544c008f384208e07a6d18 c14d666f78cf4a82b0f710b225244c0e 447e0a519d3144fdabf96e0153ef693c--c14d666f78cf4a82b0f710b225244c0e 4e84aed43a7d47e883df823b85961f5e X c14d666f78cf4a82b0f710b225244c0e--4e84aed43a7d47e883df823b85961f5e 4e84aed43a7d47e883df823b85961f5e--dc6f90303c754f3a97e66cc21ab5b7f5 884f54dbc1324c4484858e11dbb19bce RZ(-1.0*g0) 4e84aed43a7d47e883df823b85961f5e--884f54dbc1324c4484858e11dbb19bce a5305340d2b84209bdb4a6b38bda9b0d X 884f54dbc1324c4484858e11dbb19bce--a5305340d2b84209bdb4a6b38bda9b0d a5305340d2b84209bdb4a6b38bda9b0d--2d28d898e4414b6d8c0d3a15b901d326 9cd0dbbd70f44ec9b80e8c403c4879e1 X a5305340d2b84209bdb4a6b38bda9b0d--9cd0dbbd70f44ec9b80e8c403c4879e1 9cd0dbbd70f44ec9b80e8c403c4879e1--7cb76051e4ff4f40a7f66eb140dfe733 18e7db7ffc014397a29c1eb9cd51bc9e 9cd0dbbd70f44ec9b80e8c403c4879e1--18e7db7ffc014397a29c1eb9cd51bc9e c3c4925573b64dffbea6f359e3b83fc8 18e7db7ffc014397a29c1eb9cd51bc9e--c3c4925573b64dffbea6f359e3b83fc8 cbeccc633b5842e382854449202944be c3c4925573b64dffbea6f359e3b83fc8--cbeccc633b5842e382854449202944be e0ba47bad1114685aaf4bb966b570a68 cbeccc633b5842e382854449202944be--e0ba47bad1114685aaf4bb966b570a68 5920c626e9084576b0768a3f4bdae3a2 e0ba47bad1114685aaf4bb966b570a68--5920c626e9084576b0768a3f4bdae3a2 e3e9460b4e65408381675ba601290061 5920c626e9084576b0768a3f4bdae3a2--e3e9460b4e65408381675ba601290061 0e1355df6b5f4cbd902a5ca52fb4e4a4 e3e9460b4e65408381675ba601290061--0e1355df6b5f4cbd902a5ca52fb4e4a4 667e4c581c874d42bd4a6f84a729bd24 X 0e1355df6b5f4cbd902a5ca52fb4e4a4--667e4c581c874d42bd4a6f84a729bd24 667e4c581c874d42bd4a6f84a729bd24--669cf5ea817b48669d886388c5e365ca 086fe243a17d4a34ae3bffe14eff703f X 667e4c581c874d42bd4a6f84a729bd24--086fe243a17d4a34ae3bffe14eff703f 086fe243a17d4a34ae3bffe14eff703f--ec25525980a342278a858ca7d18508e6 64264b56aba84857a3606399c4eebc0d 086fe243a17d4a34ae3bffe14eff703f--64264b56aba84857a3606399c4eebc0d 66e7f96031e44fc891f9935f2f4b096b 64264b56aba84857a3606399c4eebc0d--66e7f96031e44fc891f9935f2f4b096b da8d81a1a11b4ef88ca08ad112f75f5d 66e7f96031e44fc891f9935f2f4b096b--da8d81a1a11b4ef88ca08ad112f75f5d 0c1c420d1cfe4b3e88543a317c4a5b34 da8d81a1a11b4ef88ca08ad112f75f5d--0c1c420d1cfe4b3e88543a317c4a5b34 323b02daa14e4f9c98d921aeefd664d0 0c1c420d1cfe4b3e88543a317c4a5b34--323b02daa14e4f9c98d921aeefd664d0 50c0069472e14aff91ca2643f449fb31 323b02daa14e4f9c98d921aeefd664d0--50c0069472e14aff91ca2643f449fb31 417718127d064cd8ad1f67a70c1ea3db 50c0069472e14aff91ca2643f449fb31--417718127d064cd8ad1f67a70c1ea3db f5be6bd986104f2abe81e650a228d797 417718127d064cd8ad1f67a70c1ea3db--f5be6bd986104f2abe81e650a228d797 bf7095c212d344a8ad816f78dd4d8a15 f5be6bd986104f2abe81e650a228d797--bf7095c212d344a8ad816f78dd4d8a15 708898f8da85433c91f4bc9840d80212 bf7095c212d344a8ad816f78dd4d8a15--708898f8da85433c91f4bc9840d80212 de9e70c3f5ac49eba3d11366f0ca0c3f 708898f8da85433c91f4bc9840d80212--de9e70c3f5ac49eba3d11366f0ca0c3f fbeb348eded3451c8e6dd5a4dafa5d8d X de9e70c3f5ac49eba3d11366f0ca0c3f--fbeb348eded3451c8e6dd5a4dafa5d8d fbeb348eded3451c8e6dd5a4dafa5d8d--0b618ebec4f641cbb7e4d90a22f91127 21b5b8b19dbe426894c07ab167a42ea4 fbeb348eded3451c8e6dd5a4dafa5d8d--21b5b8b19dbe426894c07ab167a42ea4 e39b3341741144fba97564988725baaa 21b5b8b19dbe426894c07ab167a42ea4--e39b3341741144fba97564988725baaa 01c57b5dc19443049d69f15b86e8dc66 e39b3341741144fba97564988725baaa--01c57b5dc19443049d69f15b86e8dc66 ebd1becd84c941608999a33615d65316 01c57b5dc19443049d69f15b86e8dc66--ebd1becd84c941608999a33615d65316 9eb3ded37ec446999936da9eb4c2000f ebd1becd84c941608999a33615d65316--9eb3ded37ec446999936da9eb4c2000f 1e9168cf546241db9c37618ee7ad7826 9eb3ded37ec446999936da9eb4c2000f--1e9168cf546241db9c37618ee7ad7826 fe9a781208bd4a7da06b19244b4b7e9e 1e9168cf546241db9c37618ee7ad7826--fe9a781208bd4a7da06b19244b4b7e9e a3b761b5f4294faf8652bae09ad5ac05 fe9a781208bd4a7da06b19244b4b7e9e--a3b761b5f4294faf8652bae09ad5ac05 b001c8c39b82473eb9b8626f55dad319 a3b761b5f4294faf8652bae09ad5ac05--b001c8c39b82473eb9b8626f55dad319 5466e47127df4b82bea93407f0741e8e b001c8c39b82473eb9b8626f55dad319--5466e47127df4b82bea93407f0741e8e 6b774ca2fbf943febed0049b4473186d 5466e47127df4b82bea93407f0741e8e--6b774ca2fbf943febed0049b4473186d 22d9331797d84fb5a4decf0a06271a96 6b774ca2fbf943febed0049b4473186d--22d9331797d84fb5a4decf0a06271a96 ec9429843c6749c49111410c7130e2db 22d9331797d84fb5a4decf0a06271a96--ec9429843c6749c49111410c7130e2db a031dabd57104200aea657d4edf551e0 ec9429843c6749c49111410c7130e2db--a031dabd57104200aea657d4edf551e0 3679cf5e3a3a464a99c7bdb6ba4e07ae a031dabd57104200aea657d4edf551e0--3679cf5e3a3a464a99c7bdb6ba4e07ae 091c39b169fc409b83bffe0e7d920231 3679cf5e3a3a464a99c7bdb6ba4e07ae--091c39b169fc409b83bffe0e7d920231 b3250c4951594fe89e15535e2967ed12 091c39b169fc409b83bffe0e7d920231--b3250c4951594fe89e15535e2967ed12 ccbf4b7fd703431c92d7b8640ed85394 b3250c4951594fe89e15535e2967ed12--ccbf4b7fd703431c92d7b8640ed85394 483430e1023d444b876471da489fa957 ccbf4b7fd703431c92d7b8640ed85394--483430e1023d444b876471da489fa957 8bd0a026375b44dba85fe622e2d8065b 483430e1023d444b876471da489fa957--8bd0a026375b44dba85fe622e2d8065b 0b9d407f66c743ababb2b8744578f6ee 8bd0a026375b44dba85fe622e2d8065b--0b9d407f66c743ababb2b8744578f6ee 81bcf3c844574388b3f2a97d7304d2e6 0b9d407f66c743ababb2b8744578f6ee--81bcf3c844574388b3f2a97d7304d2e6 77312d2302be417688f7fd2a28e800e1 81bcf3c844574388b3f2a97d7304d2e6--77312d2302be417688f7fd2a28e800e1 e4e8199b6d944745a95a125817f9c759 77312d2302be417688f7fd2a28e800e1--e4e8199b6d944745a95a125817f9c759 3aeca339dcae40c6a4a3a1230077d391 e4e8199b6d944745a95a125817f9c759--3aeca339dcae40c6a4a3a1230077d391 a440bd322ee54ed482664083246f0d54 3aeca339dcae40c6a4a3a1230077d391--a440bd322ee54ed482664083246f0d54 af602e4150a34b56ae7cd3e3da705c72 a440bd322ee54ed482664083246f0d54--af602e4150a34b56ae7cd3e3da705c72 dd93d4768161460896b94e7f8655830c af602e4150a34b56ae7cd3e3da705c72--dd93d4768161460896b94e7f8655830c 0dd1f48ebdb14e0383f3c5be8a103937 dd93d4768161460896b94e7f8655830c--0dd1f48ebdb14e0383f3c5be8a103937 f7e524fbb46947f8a10739f247dcaadf 0dd1f48ebdb14e0383f3c5be8a103937--f7e524fbb46947f8a10739f247dcaadf 196f81b9510b4033b2dfa220368f2730 f7e524fbb46947f8a10739f247dcaadf--196f81b9510b4033b2dfa220368f2730 0e40b319466842ffa834efc0005698f8 196f81b9510b4033b2dfa220368f2730--0e40b319466842ffa834efc0005698f8 209e4429dd5641e5a24cac44c972ce09 0e40b319466842ffa834efc0005698f8--209e4429dd5641e5a24cac44c972ce09 8248f096ed9440d999419fa18bbce736 209e4429dd5641e5a24cac44c972ce09--8248f096ed9440d999419fa18bbce736 929bc7c170594954b523967260257f83 8248f096ed9440d999419fa18bbce736--929bc7c170594954b523967260257f83 3ccb6ef7280d4031bcd67ecbcd52bc7d 929bc7c170594954b523967260257f83--3ccb6ef7280d4031bcd67ecbcd52bc7d c420e09bf3d140dd893c7c0cd9a09db2 3ccb6ef7280d4031bcd67ecbcd52bc7d--c420e09bf3d140dd893c7c0cd9a09db2 bc9403bfb1f747cfb1c32c3b8722b312 c420e09bf3d140dd893c7c0cd9a09db2--bc9403bfb1f747cfb1c32c3b8722b312 2e1b90e9854e4ba39bd06d3ab5a2dc4c bc9403bfb1f747cfb1c32c3b8722b312--2e1b90e9854e4ba39bd06d3ab5a2dc4c 12fcd0a64d854be5a74b9be9e8190cec 2e1b90e9854e4ba39bd06d3ab5a2dc4c--12fcd0a64d854be5a74b9be9e8190cec ae8d4faf4c644a85ac618bade704657a 12fcd0a64d854be5a74b9be9e8190cec--ae8d4faf4c644a85ac618bade704657a 5161df4ddde84ae0b973c4b7a0d75a7d ae8d4faf4c644a85ac618bade704657a--5161df4ddde84ae0b973c4b7a0d75a7d febb6d12c6ac427f9654502527611e42 5161df4ddde84ae0b973c4b7a0d75a7d--febb6d12c6ac427f9654502527611e42 ac64bd18d2cf4bc5b0e20a677675d765 febb6d12c6ac427f9654502527611e42--ac64bd18d2cf4bc5b0e20a677675d765 ce01962abbb046e5a042565547819b37 ac64bd18d2cf4bc5b0e20a677675d765--ce01962abbb046e5a042565547819b37 a6ede38a46e64391b2290ec58064b166 ce01962abbb046e5a042565547819b37--a6ede38a46e64391b2290ec58064b166 05857b94a83443678888e1910a386807 a6ede38a46e64391b2290ec58064b166--05857b94a83443678888e1910a386807 69d77a4a350e49158fef10af1c2cd2e5 05857b94a83443678888e1910a386807--69d77a4a350e49158fef10af1c2cd2e5 0f9eabbc9a52407581ad5edb87847e89 69d77a4a350e49158fef10af1c2cd2e5--0f9eabbc9a52407581ad5edb87847e89 d30095c46b30415898f522bb105c45f5 0f9eabbc9a52407581ad5edb87847e89--d30095c46b30415898f522bb105c45f5 b0cb421bd093497ab738e8ec54b8d013 d30095c46b30415898f522bb105c45f5--b0cb421bd093497ab738e8ec54b8d013 29a44103b2494f399b37a3e8430e3dad b0cb421bd093497ab738e8ec54b8d013--29a44103b2494f399b37a3e8430e3dad 52dd1045bc1c45f59ce8f953f469723a 29a44103b2494f399b37a3e8430e3dad--52dd1045bc1c45f59ce8f953f469723a 0d543a9121e64ee4b94e12369c4b1cc3 52dd1045bc1c45f59ce8f953f469723a--0d543a9121e64ee4b94e12369c4b1cc3 9287c3fa6c71414d9496ffc44da207ec 0d543a9121e64ee4b94e12369c4b1cc3--9287c3fa6c71414d9496ffc44da207ec 3017dc0df6314e28ac0e8e6d4a705c79 9287c3fa6c71414d9496ffc44da207ec--3017dc0df6314e28ac0e8e6d4a705c79 6857ed6c1c8e4661b00d33b802de9ac6 3017dc0df6314e28ac0e8e6d4a705c79--6857ed6c1c8e4661b00d33b802de9ac6 7d054d1732e849a4bcc44220924ab695 6857ed6c1c8e4661b00d33b802de9ac6--7d054d1732e849a4bcc44220924ab695 24129692f3244430851a7d3f6533ef59 7d054d1732e849a4bcc44220924ab695--24129692f3244430851a7d3f6533ef59 b79c854efed64404a7d8a32478783859 24129692f3244430851a7d3f6533ef59--b79c854efed64404a7d8a32478783859 e4b89bc0cc41423797d9f018b429df48 b79c854efed64404a7d8a32478783859--e4b89bc0cc41423797d9f018b429df48 57cd97a610884d80bd76053e7d27c0d6 e4b89bc0cc41423797d9f018b429df48--57cd97a610884d80bd76053e7d27c0d6 ca8d412a47cc4cceb5064b5b5913bcd1 57cd97a610884d80bd76053e7d27c0d6--ca8d412a47cc4cceb5064b5b5913bcd1 52fe787fdd8d45f287df3d4867fd9cb2 ca8d412a47cc4cceb5064b5b5913bcd1--52fe787fdd8d45f287df3d4867fd9cb2 85d6cf8bd84d45169a8739dc97917f60 RX(b02) 52fe787fdd8d45f287df3d4867fd9cb2--85d6cf8bd84d45169a8739dc97917f60 9fbb502849814e7f9450a1ec05665613 85d6cf8bd84d45169a8739dc97917f60--9fbb502849814e7f9450a1ec05665613 32476b208a454e2eaed1c316b5749b7f X 9fbb502849814e7f9450a1ec05665613--32476b208a454e2eaed1c316b5749b7f 32476b208a454e2eaed1c316b5749b7f--d2cd0bb181bf41e2af50f55618c82b77 011579e3e4de47d29d673f48cbe22da2 32476b208a454e2eaed1c316b5749b7f--011579e3e4de47d29d673f48cbe22da2 6bbf569fee6f41d0808135a45aaff52d 011579e3e4de47d29d673f48cbe22da2--6bbf569fee6f41d0808135a45aaff52d d7c680fb1c2c4963bda51555c7ad5e43 6bbf569fee6f41d0808135a45aaff52d--d7c680fb1c2c4963bda51555c7ad5e43 a115deb37234474e8d773a22abf4dc46 d7c680fb1c2c4963bda51555c7ad5e43--a115deb37234474e8d773a22abf4dc46 03a1d69572964f1889b5ee857159e177 a115deb37234474e8d773a22abf4dc46--03a1d69572964f1889b5ee857159e177 e2fd30df83634f959cb9603801718b4e 03a1d69572964f1889b5ee857159e177--e2fd30df83634f959cb9603801718b4e b875acc60e0142f4a9bf91d5c3f4dc97 e2fd30df83634f959cb9603801718b4e--b875acc60e0142f4a9bf91d5c3f4dc97 d4053a2b61954dff8682b45330e5396f b875acc60e0142f4a9bf91d5c3f4dc97--d4053a2b61954dff8682b45330e5396f 947a06e1362843e9abfc3f92529e7a95 d4053a2b61954dff8682b45330e5396f--947a06e1362843e9abfc3f92529e7a95 79a574a00ad149149ac21fcc6e49667b 947a06e1362843e9abfc3f92529e7a95--79a574a00ad149149ac21fcc6e49667b 5122e0fdc0aa4041a35613afb40e0230 79a574a00ad149149ac21fcc6e49667b--5122e0fdc0aa4041a35613afb40e0230 8fafb69347c74cc19c0dca60f388c2b4 X 5122e0fdc0aa4041a35613afb40e0230--8fafb69347c74cc19c0dca60f388c2b4 8fafb69347c74cc19c0dca60f388c2b4--8e5a7a2a81484402a2ce6d96d07bf477 55cfa441db734230aec0816f856783bb 8fafb69347c74cc19c0dca60f388c2b4--55cfa441db734230aec0816f856783bb c5967e3f00274dcd9c8650da61ec5e92 55cfa441db734230aec0816f856783bb--c5967e3f00274dcd9c8650da61ec5e92 5e72f73ff85a49f4a50ba85591b82d80 c5967e3f00274dcd9c8650da61ec5e92--5e72f73ff85a49f4a50ba85591b82d80 864977672d79494d9bf12278fab1aec9 5e72f73ff85a49f4a50ba85591b82d80--864977672d79494d9bf12278fab1aec9 6418f5be839a472497e371018de4145f 864977672d79494d9bf12278fab1aec9--6418f5be839a472497e371018de4145f c0184a5c69a14a0d9df318be1192d159 X 6418f5be839a472497e371018de4145f--c0184a5c69a14a0d9df318be1192d159 c0184a5c69a14a0d9df318be1192d159--b3cfc67a2e72406792e4f32c6bd23fb7 fe0fc056246c441aa3379fb724fc72b1 c0184a5c69a14a0d9df318be1192d159--fe0fc056246c441aa3379fb724fc72b1 eb3531ed191e4b7ab32e4410e482a114 fe0fc056246c441aa3379fb724fc72b1--eb3531ed191e4b7ab32e4410e482a114 5d7ee0674e9244d1a254c4c48814db51 eb3531ed191e4b7ab32e4410e482a114--5d7ee0674e9244d1a254c4c48814db51 b97c5a6245f74a0bbe0cff347281d266 5d7ee0674e9244d1a254c4c48814db51--b97c5a6245f74a0bbe0cff347281d266 2b8b1bcc78754ea888f940d7b291239a b97c5a6245f74a0bbe0cff347281d266--2b8b1bcc78754ea888f940d7b291239a cd19a356559c4b4386bc1962e6d01e92 X 2b8b1bcc78754ea888f940d7b291239a--cd19a356559c4b4386bc1962e6d01e92 cd19a356559c4b4386bc1962e6d01e92--6c43d3c67aef4ac598a101fb76d87f93 01f23df649e24114bee00de3342b9bab cd19a356559c4b4386bc1962e6d01e92--01f23df649e24114bee00de3342b9bab 493289a7d02f4a7ba6f8a1f1284ab2f5 01f23df649e24114bee00de3342b9bab--493289a7d02f4a7ba6f8a1f1284ab2f5 522faec842534d40a60e66fce5e8b5c3 X 493289a7d02f4a7ba6f8a1f1284ab2f5--522faec842534d40a60e66fce5e8b5c3 522faec842534d40a60e66fce5e8b5c3--6a847121957741c0b1252a128f734599 21c33212469643e991c5979fa04ae838 522faec842534d40a60e66fce5e8b5c3--21c33212469643e991c5979fa04ae838 7c6deec499a64e12a2136abc87187209 21c33212469643e991c5979fa04ae838--7c6deec499a64e12a2136abc87187209 2d205c97fe814e93b45b5a6f1d0522e3 7c6deec499a64e12a2136abc87187209--2d205c97fe814e93b45b5a6f1d0522e3 916073dd0da8414c814657ca56d47b2b 2d205c97fe814e93b45b5a6f1d0522e3--916073dd0da8414c814657ca56d47b2b f7cdabfde3b349bb9f13925d4d69be2f 916073dd0da8414c814657ca56d47b2b--f7cdabfde3b349bb9f13925d4d69be2f fad10f82ad2640faa431ff351ab1180b f7cdabfde3b349bb9f13925d4d69be2f--fad10f82ad2640faa431ff351ab1180b 1d0905d929d24e2e8b03826fd892abe6 fad10f82ad2640faa431ff351ab1180b--1d0905d929d24e2e8b03826fd892abe6 be50123da29a4dd19386adb23cbf0168 1d0905d929d24e2e8b03826fd892abe6--be50123da29a4dd19386adb23cbf0168 38d7aecaff2e4256927ec70a333225de be50123da29a4dd19386adb23cbf0168--38d7aecaff2e4256927ec70a333225de 874f0aeb50724eb480aa9ed2dcbfe880 X 38d7aecaff2e4256927ec70a333225de--874f0aeb50724eb480aa9ed2dcbfe880 874f0aeb50724eb480aa9ed2dcbfe880--101c2d90c56144ac9a2728446cdaff3c cb6d715adf2046b194a2fa0801a02f40 874f0aeb50724eb480aa9ed2dcbfe880--cb6d715adf2046b194a2fa0801a02f40 877d44b77973430bacd32123968d27a5 X cb6d715adf2046b194a2fa0801a02f40--877d44b77973430bacd32123968d27a5 877d44b77973430bacd32123968d27a5--161b6f922c60476c98a20e72b86f5ffc af555833181b40e7a5fcf6fe8886caa9 RZ(-1.0*g1) 877d44b77973430bacd32123968d27a5--af555833181b40e7a5fcf6fe8886caa9 6a324d7292fb4a328f30627756495626 X af555833181b40e7a5fcf6fe8886caa9--6a324d7292fb4a328f30627756495626 6a324d7292fb4a328f30627756495626--07f73904d793431e9b341ddcdce3a6e8 54cfbe8452564b1482fa368e9620a05b X 6a324d7292fb4a328f30627756495626--54cfbe8452564b1482fa368e9620a05b 54cfbe8452564b1482fa368e9620a05b--5a387cbbd53f4ff187d14a6b30ae9da8 74bed90ca04e4c8794f910911c0acab7 54cfbe8452564b1482fa368e9620a05b--74bed90ca04e4c8794f910911c0acab7 361bd4ca60f549c59c4310c9311452d8 74bed90ca04e4c8794f910911c0acab7--361bd4ca60f549c59c4310c9311452d8 11a857ca171d402ca309687a07488a61 361bd4ca60f549c59c4310c9311452d8--11a857ca171d402ca309687a07488a61 2d28fd247c3c43d49e8d9d08d4a5c141 11a857ca171d402ca309687a07488a61--2d28fd247c3c43d49e8d9d08d4a5c141 dc33db6657c54421b0f94940ae958e52 2d28fd247c3c43d49e8d9d08d4a5c141--dc33db6657c54421b0f94940ae958e52 30822fa8760a4172adeec4144c01ced2 dc33db6657c54421b0f94940ae958e52--30822fa8760a4172adeec4144c01ced2 603afeca24bb4d47870604474e8c0cae 30822fa8760a4172adeec4144c01ced2--603afeca24bb4d47870604474e8c0cae 7d0700e3ba3c4812956d7991587578c9 X 603afeca24bb4d47870604474e8c0cae--7d0700e3ba3c4812956d7991587578c9 7d0700e3ba3c4812956d7991587578c9--7958790a1815481892d5b8fd6765dc04 9319652008244c34912d654a3852e040 X 7d0700e3ba3c4812956d7991587578c9--9319652008244c34912d654a3852e040 9319652008244c34912d654a3852e040--37cb2ad123954743821ace23ea645f4b 1b4b7238e1e14cc8886714136562bed7 9319652008244c34912d654a3852e040--1b4b7238e1e14cc8886714136562bed7 cfdd5d7473924c3bbdb8bc0517b10ba4 1b4b7238e1e14cc8886714136562bed7--cfdd5d7473924c3bbdb8bc0517b10ba4 644e8284e53f47379ad13b9d0ddccb57 cfdd5d7473924c3bbdb8bc0517b10ba4--644e8284e53f47379ad13b9d0ddccb57 242bcf8f31604e4b8567f1afd0b4b604 644e8284e53f47379ad13b9d0ddccb57--242bcf8f31604e4b8567f1afd0b4b604 d6bbfb925c754f658d14266e3af6a45c 242bcf8f31604e4b8567f1afd0b4b604--d6bbfb925c754f658d14266e3af6a45c 0141e0a10da8452fad60db23b39f02b1 d6bbfb925c754f658d14266e3af6a45c--0141e0a10da8452fad60db23b39f02b1 c5203642b94d45e28212f3ba438f2de1 0141e0a10da8452fad60db23b39f02b1--c5203642b94d45e28212f3ba438f2de1 5947ab23c42c439ba4e66ca9c21c4a1c c5203642b94d45e28212f3ba438f2de1--5947ab23c42c439ba4e66ca9c21c4a1c c380069112104ac59b247a61809bcea2 5947ab23c42c439ba4e66ca9c21c4a1c--c380069112104ac59b247a61809bcea2 f416a38b26504704b63fc06ebe2780b5 c380069112104ac59b247a61809bcea2--f416a38b26504704b63fc06ebe2780b5 f0d938f682494ac8afdb07a815c91a1b f416a38b26504704b63fc06ebe2780b5--f0d938f682494ac8afdb07a815c91a1b a52aa0c312de4ef0babecfbae3dad194 X f0d938f682494ac8afdb07a815c91a1b--a52aa0c312de4ef0babecfbae3dad194 a52aa0c312de4ef0babecfbae3dad194--f9d288dff80e462393dd7c3697d6ce81 c2556983d7414fac89a991b0b390e1bd a52aa0c312de4ef0babecfbae3dad194--c2556983d7414fac89a991b0b390e1bd 69edcbe1c666496bb510efe15fc0cfe8 c2556983d7414fac89a991b0b390e1bd--69edcbe1c666496bb510efe15fc0cfe8 7b6ba90b6c474b36a637dadb68fb9893 69edcbe1c666496bb510efe15fc0cfe8--7b6ba90b6c474b36a637dadb68fb9893 cd24506cadce4df0b11f85c295f77e1e 7b6ba90b6c474b36a637dadb68fb9893--cd24506cadce4df0b11f85c295f77e1e d55b51deb6d64d38a67b5973689fdfb6 cd24506cadce4df0b11f85c295f77e1e--d55b51deb6d64d38a67b5973689fdfb6 060c6a3d795b43769e8a3b3b40ff7a4c d55b51deb6d64d38a67b5973689fdfb6--060c6a3d795b43769e8a3b3b40ff7a4c c8c6c7baeed44b718a09af5beb041bdd 060c6a3d795b43769e8a3b3b40ff7a4c--c8c6c7baeed44b718a09af5beb041bdd 89ccc2c699924277a26ebbfbe93717f3 c8c6c7baeed44b718a09af5beb041bdd--89ccc2c699924277a26ebbfbe93717f3 98e9d38a533d4f1da72a5ef4c77e73cc 89ccc2c699924277a26ebbfbe93717f3--98e9d38a533d4f1da72a5ef4c77e73cc 3dcd10d36d7641c282126ba7717e6ccf 98e9d38a533d4f1da72a5ef4c77e73cc--3dcd10d36d7641c282126ba7717e6ccf 6c58be7bdddb410b983901f083f9e12a 3dcd10d36d7641c282126ba7717e6ccf--6c58be7bdddb410b983901f083f9e12a b67b5153a1ed46f4aef8e7eec6935f66 6c58be7bdddb410b983901f083f9e12a--b67b5153a1ed46f4aef8e7eec6935f66 90a1e71ff046462bbc76b50514b26058 b67b5153a1ed46f4aef8e7eec6935f66--90a1e71ff046462bbc76b50514b26058 8e349eb94cfa4cdfbc51d6a77ea96aa8 90a1e71ff046462bbc76b50514b26058--8e349eb94cfa4cdfbc51d6a77ea96aa8 1abfb1bda84c4aceb33551fbe877bdaa 8e349eb94cfa4cdfbc51d6a77ea96aa8--1abfb1bda84c4aceb33551fbe877bdaa 88034d649e9c40c9a552a309bf2c82cf 1abfb1bda84c4aceb33551fbe877bdaa--88034d649e9c40c9a552a309bf2c82cf 14a37b187c52492e9a3a24c35ba8163b 88034d649e9c40c9a552a309bf2c82cf--14a37b187c52492e9a3a24c35ba8163b 256fe4ae8a0d4fe29857ec3c6462b3e5 14a37b187c52492e9a3a24c35ba8163b--256fe4ae8a0d4fe29857ec3c6462b3e5 2c0133c5e6444f9d9117300223648ba1 256fe4ae8a0d4fe29857ec3c6462b3e5--2c0133c5e6444f9d9117300223648ba1 d2cf606779d449bcbb6b8ef3520a8c90 2c0133c5e6444f9d9117300223648ba1--d2cf606779d449bcbb6b8ef3520a8c90 994634a0067f46d0acc5dd59510b8caa d2cf606779d449bcbb6b8ef3520a8c90--994634a0067f46d0acc5dd59510b8caa df618e1f74e54904b323331f78e893a2 994634a0067f46d0acc5dd59510b8caa--df618e1f74e54904b323331f78e893a2 5e27da7717214c87a35adeb1ab628a5c df618e1f74e54904b323331f78e893a2--5e27da7717214c87a35adeb1ab628a5c 1b077fae3dfd4bc687547a72a579cf48 5e27da7717214c87a35adeb1ab628a5c--1b077fae3dfd4bc687547a72a579cf48 010e62467376417785ce43b5a82e67e5 1b077fae3dfd4bc687547a72a579cf48--010e62467376417785ce43b5a82e67e5 53b3f70dfc0943c09de7ae0e66fffaf3 010e62467376417785ce43b5a82e67e5--53b3f70dfc0943c09de7ae0e66fffaf3 7ed313848f3c4c59af1870ce1c058821 53b3f70dfc0943c09de7ae0e66fffaf3--7ed313848f3c4c59af1870ce1c058821 45dbcc488fa7432eb7fa337ce08b9955 7ed313848f3c4c59af1870ce1c058821--45dbcc488fa7432eb7fa337ce08b9955 0da340e1fcbd4783a185048297b778e8 45dbcc488fa7432eb7fa337ce08b9955--0da340e1fcbd4783a185048297b778e8 878126302adf4ec4a385725e0495f063 0da340e1fcbd4783a185048297b778e8--878126302adf4ec4a385725e0495f063 2423bfa99d89420496a9611f87db2136 878126302adf4ec4a385725e0495f063--2423bfa99d89420496a9611f87db2136 1bc741a510b34a2ca2b82a4611011302 2423bfa99d89420496a9611f87db2136--1bc741a510b34a2ca2b82a4611011302 0ac0ddb25e6241a987f4c4d0f1519dd7 1bc741a510b34a2ca2b82a4611011302--0ac0ddb25e6241a987f4c4d0f1519dd7 5c5fc07746544790959d4990df092403 0ac0ddb25e6241a987f4c4d0f1519dd7--5c5fc07746544790959d4990df092403 d7961a1264e24944a6480648399fdc47 5c5fc07746544790959d4990df092403--d7961a1264e24944a6480648399fdc47 c55df1bf6c9f492cbd940e7ab051e4ed d7961a1264e24944a6480648399fdc47--c55df1bf6c9f492cbd940e7ab051e4ed 4f832a6761d44fd6bbb81a7f594e6b7a c55df1bf6c9f492cbd940e7ab051e4ed--4f832a6761d44fd6bbb81a7f594e6b7a 1618ee47cf944785842c7c332adee22e 4f832a6761d44fd6bbb81a7f594e6b7a--1618ee47cf944785842c7c332adee22e 740ece78fdf94604a00e3e2572023adb 1618ee47cf944785842c7c332adee22e--740ece78fdf94604a00e3e2572023adb d452c3e96e654bc29268aeb905f95191 740ece78fdf94604a00e3e2572023adb--d452c3e96e654bc29268aeb905f95191 9e5bbe89054343a58bc89658e1564808 d452c3e96e654bc29268aeb905f95191--9e5bbe89054343a58bc89658e1564808 da1ed36606a4493bb20d8547c4e461d3 9e5bbe89054343a58bc89658e1564808--da1ed36606a4493bb20d8547c4e461d3 d703527e82ef4f14bc2877b939a3efbc da1ed36606a4493bb20d8547c4e461d3--d703527e82ef4f14bc2877b939a3efbc 5ca68c68701b415fb5a551d2833c083a d703527e82ef4f14bc2877b939a3efbc--5ca68c68701b415fb5a551d2833c083a 0a1278a0d90a4d82b66d46de5d6c0585 5ca68c68701b415fb5a551d2833c083a--0a1278a0d90a4d82b66d46de5d6c0585 15ff1646e83e45e580dc299ee9df364a 0a1278a0d90a4d82b66d46de5d6c0585--15ff1646e83e45e580dc299ee9df364a c91d98ef1ff842d9919c2cbb5cace346 15ff1646e83e45e580dc299ee9df364a--c91d98ef1ff842d9919c2cbb5cace346 363daaf423664e968d89d2bf624d9b05 c91d98ef1ff842d9919c2cbb5cace346--363daaf423664e968d89d2bf624d9b05 47b2eca165f64e94b45a014fbe4ae42a 363daaf423664e968d89d2bf624d9b05--47b2eca165f64e94b45a014fbe4ae42a 2eb76891400b4cffb624592eb14fa782 47b2eca165f64e94b45a014fbe4ae42a--2eb76891400b4cffb624592eb14fa782 44fd022ce826488a97c2547e49644c2c 2eb76891400b4cffb624592eb14fa782--44fd022ce826488a97c2547e49644c2c 9a53a6ee56ea44748e13aede629233fb 44fd022ce826488a97c2547e49644c2c--9a53a6ee56ea44748e13aede629233fb c7626283d3f041ecaad7b827cb27655b 9a53a6ee56ea44748e13aede629233fb--c7626283d3f041ecaad7b827cb27655b ce6f285ee9794ef1b8c0c184929fa927 c7626283d3f041ecaad7b827cb27655b--ce6f285ee9794ef1b8c0c184929fa927 ffe035fbfc5a434fbe29d5c81d37dafd ce6f285ee9794ef1b8c0c184929fa927--ffe035fbfc5a434fbe29d5c81d37dafd e06aa219b8c54c49a57b077d7603bc1f ffe035fbfc5a434fbe29d5c81d37dafd--e06aa219b8c54c49a57b077d7603bc1f b03327d5c97c4e6fad66cadbe0bbcf9c e06aa219b8c54c49a57b077d7603bc1f--b03327d5c97c4e6fad66cadbe0bbcf9c 887e1e7110ca4b4696c262bb988d8b5f b03327d5c97c4e6fad66cadbe0bbcf9c--887e1e7110ca4b4696c262bb988d8b5f d68fbc373b2c4f0a8220d269e8e54dfa 887e1e7110ca4b4696c262bb988d8b5f--d68fbc373b2c4f0a8220d269e8e54dfa ba2d21834ee14cb8a165953652bdc364 d68fbc373b2c4f0a8220d269e8e54dfa--ba2d21834ee14cb8a165953652bdc364 3c9fab121e83426e9d30aad24afee3a4 ba2d21834ee14cb8a165953652bdc364--3c9fab121e83426e9d30aad24afee3a4 63e20ac63a794ca8b78710a191bbf676 3c9fab121e83426e9d30aad24afee3a4--63e20ac63a794ca8b78710a191bbf676 0dfe938078254bf988fd936128a03ae5 63e20ac63a794ca8b78710a191bbf676--0dfe938078254bf988fd936128a03ae5 31237246620848b785a1f76ff4fa21a6 0dfe938078254bf988fd936128a03ae5--31237246620848b785a1f76ff4fa21a6 c8875f4b350c4cfeb3ffe29bd5362e20 RX(b12) 31237246620848b785a1f76ff4fa21a6--c8875f4b350c4cfeb3ffe29bd5362e20 c8875f4b350c4cfeb3ffe29bd5362e20--b1b3e090dc98414b92c93aa79d824030 f070e24129124bdfa834cd7b81d512b0 44c9ae9b9b304a808c7f1030911455d1 5b1ab9bb428141c6b6797519b723d148--44c9ae9b9b304a808c7f1030911455d1 0fac5cb585034513bca6adb5c1a2ae33 4 cb4564e3e05f4c53982c6f2206a3c170 44c9ae9b9b304a808c7f1030911455d1--cb4564e3e05f4c53982c6f2206a3c170 7ad36862fe884ec5ac5fcd3cfbae6499 X cb4564e3e05f4c53982c6f2206a3c170--7ad36862fe884ec5ac5fcd3cfbae6499 7ad36862fe884ec5ac5fcd3cfbae6499--c1cc654f16e84a6c9747fd283ac79e05 16e1e819aebb463d91f71230df83549c 7ad36862fe884ec5ac5fcd3cfbae6499--16e1e819aebb463d91f71230df83549c 8df3efdf80d4462284f65f296c4ad370 16e1e819aebb463d91f71230df83549c--8df3efdf80d4462284f65f296c4ad370 a3ed47f392b34e2a9de4be6d8f0631d9 8df3efdf80d4462284f65f296c4ad370--a3ed47f392b34e2a9de4be6d8f0631d9 91cbdd46008d40cfa2ffdb0737c3f4f4 a3ed47f392b34e2a9de4be6d8f0631d9--91cbdd46008d40cfa2ffdb0737c3f4f4 fe63e0a61c9b42b5bccb049c903dc849 91cbdd46008d40cfa2ffdb0737c3f4f4--fe63e0a61c9b42b5bccb049c903dc849 351d4e21e721437e86a8bb1cd2a83376 fe63e0a61c9b42b5bccb049c903dc849--351d4e21e721437e86a8bb1cd2a83376 53499cfeb1324483a6e5f3e3702993bb 351d4e21e721437e86a8bb1cd2a83376--53499cfeb1324483a6e5f3e3702993bb 7c4645986a8c4330a6087e78a41366b1 53499cfeb1324483a6e5f3e3702993bb--7c4645986a8c4330a6087e78a41366b1 705e26897be0493db5506b1e41112997 7c4645986a8c4330a6087e78a41366b1--705e26897be0493db5506b1e41112997 1ba23051746a490198ce6df99c028ff6 X 705e26897be0493db5506b1e41112997--1ba23051746a490198ce6df99c028ff6 1ba23051746a490198ce6df99c028ff6--1ccde31dd6254ce182a59c1584012372 b371cac635b84854bf7061a8358a0ee1 1ba23051746a490198ce6df99c028ff6--b371cac635b84854bf7061a8358a0ee1 0de0563602ad4be482e4786fc3285448 b371cac635b84854bf7061a8358a0ee1--0de0563602ad4be482e4786fc3285448 ff769cb17b37494294eb160dc4869887 0de0563602ad4be482e4786fc3285448--ff769cb17b37494294eb160dc4869887 1bac4583282d4b03b0ead14966143869 ff769cb17b37494294eb160dc4869887--1bac4583282d4b03b0ead14966143869 c7664d0015ac45e6b7d937afdb239aea 1bac4583282d4b03b0ead14966143869--c7664d0015ac45e6b7d937afdb239aea a9e40d3b85e4479a91e32d515ccd6d5d c7664d0015ac45e6b7d937afdb239aea--a9e40d3b85e4479a91e32d515ccd6d5d 4b8d85bd1ea44e49be525cf883a39a5e a9e40d3b85e4479a91e32d515ccd6d5d--4b8d85bd1ea44e49be525cf883a39a5e 89e0ec4fe96341ddaab74dbbdc6bda66 X 4b8d85bd1ea44e49be525cf883a39a5e--89e0ec4fe96341ddaab74dbbdc6bda66 89e0ec4fe96341ddaab74dbbdc6bda66--2cdaa42c98a045e7b7d2181f3113c205 a40a67d02d5f4f69bea5b1f152836a5e 89e0ec4fe96341ddaab74dbbdc6bda66--a40a67d02d5f4f69bea5b1f152836a5e 81eadd4d0d314c8fa233dcf3ab691eb0 a40a67d02d5f4f69bea5b1f152836a5e--81eadd4d0d314c8fa233dcf3ab691eb0 37854451dbc042e39f823266afc3df4f 81eadd4d0d314c8fa233dcf3ab691eb0--37854451dbc042e39f823266afc3df4f 37d7f0a934fa4ca6b742b34a343f1aaa X 37854451dbc042e39f823266afc3df4f--37d7f0a934fa4ca6b742b34a343f1aaa 37d7f0a934fa4ca6b742b34a343f1aaa--1ed86c9148284637a613c716aa203e64 f678f043e1f7468580c914fde43de918 37d7f0a934fa4ca6b742b34a343f1aaa--f678f043e1f7468580c914fde43de918 82fbd422e9bd450397b07183865de81b f678f043e1f7468580c914fde43de918--82fbd422e9bd450397b07183865de81b 8c51f12958eb4006be4fe314b111ab87 82fbd422e9bd450397b07183865de81b--8c51f12958eb4006be4fe314b111ab87 e24c2292b2f54e1ead906682557d5141 8c51f12958eb4006be4fe314b111ab87--e24c2292b2f54e1ead906682557d5141 cb29f5317dda4fc8a54f39f3cf5f3e6c X e24c2292b2f54e1ead906682557d5141--cb29f5317dda4fc8a54f39f3cf5f3e6c cb29f5317dda4fc8a54f39f3cf5f3e6c--f00c76085ecc4527be7bbf500d9bbe4c 72292e33823e4ccfb052e1a21744371e cb29f5317dda4fc8a54f39f3cf5f3e6c--72292e33823e4ccfb052e1a21744371e 32ed5239ab8042dd9fca288510c87746 72292e33823e4ccfb052e1a21744371e--32ed5239ab8042dd9fca288510c87746 a095a98b4f71448ebc73790e87018f4c 32ed5239ab8042dd9fca288510c87746--a095a98b4f71448ebc73790e87018f4c e73a4a14b0ab42e78d15ef690e4e866c a095a98b4f71448ebc73790e87018f4c--e73a4a14b0ab42e78d15ef690e4e866c 9018449c0a1946e4a4948a4302225a1c e73a4a14b0ab42e78d15ef690e4e866c--9018449c0a1946e4a4948a4302225a1c 00f40eef5fc84378bcd0717127021dd5 9018449c0a1946e4a4948a4302225a1c--00f40eef5fc84378bcd0717127021dd5 8d87bccba303431e97244f5fdf4236e4 00f40eef5fc84378bcd0717127021dd5--8d87bccba303431e97244f5fdf4236e4 60ea78f842df4276b776acedcdbe9a8f X 8d87bccba303431e97244f5fdf4236e4--60ea78f842df4276b776acedcdbe9a8f 60ea78f842df4276b776acedcdbe9a8f--fb1ce0f8565d4d2798f80730235076f2 73570a90f86e4be3b36afd30b616ef34 60ea78f842df4276b776acedcdbe9a8f--73570a90f86e4be3b36afd30b616ef34 8f0e6a961656472d87bb8d47e5dc6fe2 73570a90f86e4be3b36afd30b616ef34--8f0e6a961656472d87bb8d47e5dc6fe2 2b2b82c54e054178a87101a597e95769 8f0e6a961656472d87bb8d47e5dc6fe2--2b2b82c54e054178a87101a597e95769 1c4cf03ec7ff43cc94ae81442c50092f 2b2b82c54e054178a87101a597e95769--1c4cf03ec7ff43cc94ae81442c50092f f3259e83b788426580cadcd9ff2c901d 1c4cf03ec7ff43cc94ae81442c50092f--f3259e83b788426580cadcd9ff2c901d a678df7d3a8242c0864490009bdf48de f3259e83b788426580cadcd9ff2c901d--a678df7d3a8242c0864490009bdf48de 28a9557210f749ee8836734bffd8d0ae X a678df7d3a8242c0864490009bdf48de--28a9557210f749ee8836734bffd8d0ae 28a9557210f749ee8836734bffd8d0ae--18e7db7ffc014397a29c1eb9cd51bc9e 43895d609ae64079a31ff45f47079d8c 28a9557210f749ee8836734bffd8d0ae--43895d609ae64079a31ff45f47079d8c 5a6d4bb5c11e439daaf5baf7b907ee5e 43895d609ae64079a31ff45f47079d8c--5a6d4bb5c11e439daaf5baf7b907ee5e 7a57e307783145d2a2024d5c6aca31b3 5a6d4bb5c11e439daaf5baf7b907ee5e--7a57e307783145d2a2024d5c6aca31b3 536d9f880813403a888c02f37e18d99c 7a57e307783145d2a2024d5c6aca31b3--536d9f880813403a888c02f37e18d99c 44af79adc9ad4c609d51ca9631e0ae2d 536d9f880813403a888c02f37e18d99c--44af79adc9ad4c609d51ca9631e0ae2d 7c50a76b77c64f949884235a077f644e X 44af79adc9ad4c609d51ca9631e0ae2d--7c50a76b77c64f949884235a077f644e 7c50a76b77c64f949884235a077f644e--0e1355df6b5f4cbd902a5ca52fb4e4a4 b66f9fc1bb1c4a6a8e8f3b86a5eba6b4 7c50a76b77c64f949884235a077f644e--b66f9fc1bb1c4a6a8e8f3b86a5eba6b4 5dcdadbab04e41f88dcd7cced42e9959 b66f9fc1bb1c4a6a8e8f3b86a5eba6b4--5dcdadbab04e41f88dcd7cced42e9959 d92f711f752b4a44b3d26f59d46553c9 X 5dcdadbab04e41f88dcd7cced42e9959--d92f711f752b4a44b3d26f59d46553c9 d92f711f752b4a44b3d26f59d46553c9--64264b56aba84857a3606399c4eebc0d 7a96cb85c21a45e2839bcc4c286a8ccf d92f711f752b4a44b3d26f59d46553c9--7a96cb85c21a45e2839bcc4c286a8ccf e91c9790178d4b648a6e25a227e6325d 7a96cb85c21a45e2839bcc4c286a8ccf--e91c9790178d4b648a6e25a227e6325d 45e12a2c74f24155adc5271354b03226 e91c9790178d4b648a6e25a227e6325d--45e12a2c74f24155adc5271354b03226 47a3673859584f99b601566b5759fda0 45e12a2c74f24155adc5271354b03226--47a3673859584f99b601566b5759fda0 87ebdcefc0804e53a10b8c16a6164a11 47a3673859584f99b601566b5759fda0--87ebdcefc0804e53a10b8c16a6164a11 1c35d88c3ea345e0b87023d1e81c54ff 87ebdcefc0804e53a10b8c16a6164a11--1c35d88c3ea345e0b87023d1e81c54ff ec89ce8312c846769adcc137cf04994d 1c35d88c3ea345e0b87023d1e81c54ff--ec89ce8312c846769adcc137cf04994d 33f0772fc28f4f76b40fbbb4f92eb1b2 ec89ce8312c846769adcc137cf04994d--33f0772fc28f4f76b40fbbb4f92eb1b2 5c96f9e168124c5f82f55cacda867812 33f0772fc28f4f76b40fbbb4f92eb1b2--5c96f9e168124c5f82f55cacda867812 51657d395c454d4e93c735581f5ea08f X 5c96f9e168124c5f82f55cacda867812--51657d395c454d4e93c735581f5ea08f 51657d395c454d4e93c735581f5ea08f--de9e70c3f5ac49eba3d11366f0ca0c3f 5d8b799eac9e44a59c0fa242646e590b 51657d395c454d4e93c735581f5ea08f--5d8b799eac9e44a59c0fa242646e590b f1c1e52a41f44b158e8071ed27b136f4 X 5d8b799eac9e44a59c0fa242646e590b--f1c1e52a41f44b158e8071ed27b136f4 f1c1e52a41f44b158e8071ed27b136f4--21b5b8b19dbe426894c07ab167a42ea4 7ba199bdd0814c99b9ebd641f8a45f77 f1c1e52a41f44b158e8071ed27b136f4--7ba199bdd0814c99b9ebd641f8a45f77 bda63f0b1b3044fd8635ad5f2ac76606 7ba199bdd0814c99b9ebd641f8a45f77--bda63f0b1b3044fd8635ad5f2ac76606 64d4bb0fbda44e849000e81a9d710556 bda63f0b1b3044fd8635ad5f2ac76606--64d4bb0fbda44e849000e81a9d710556 1d851dd792a34d4e86cdc2d16091f7ac 64d4bb0fbda44e849000e81a9d710556--1d851dd792a34d4e86cdc2d16091f7ac 9f1b088087174a3aac0a6bcbab6efe34 1d851dd792a34d4e86cdc2d16091f7ac--9f1b088087174a3aac0a6bcbab6efe34 1044ef34bec54437bbdc38002cf4bd78 X 9f1b088087174a3aac0a6bcbab6efe34--1044ef34bec54437bbdc38002cf4bd78 1044ef34bec54437bbdc38002cf4bd78--fe9a781208bd4a7da06b19244b4b7e9e 3522554fe00e40ac81062efa603e9bf2 X 1044ef34bec54437bbdc38002cf4bd78--3522554fe00e40ac81062efa603e9bf2 3522554fe00e40ac81062efa603e9bf2--a3b761b5f4294faf8652bae09ad5ac05 e21e8150e5424352a1119ace12348155 3522554fe00e40ac81062efa603e9bf2--e21e8150e5424352a1119ace12348155 12439920c96e4e30b6a749bc3d112f0a e21e8150e5424352a1119ace12348155--12439920c96e4e30b6a749bc3d112f0a 90372ce5644f465aadf5d0eb6d3166fa 12439920c96e4e30b6a749bc3d112f0a--90372ce5644f465aadf5d0eb6d3166fa 54f52cee28754eb08bafdff3f8501209 90372ce5644f465aadf5d0eb6d3166fa--54f52cee28754eb08bafdff3f8501209 89b5ada7c2c74fafbc63124cbcbb778f 54f52cee28754eb08bafdff3f8501209--89b5ada7c2c74fafbc63124cbcbb778f f775783ef82b4442999ffd3ba7ce5374 89b5ada7c2c74fafbc63124cbcbb778f--f775783ef82b4442999ffd3ba7ce5374 02f96eb5c26e45d4b0be50442ba575a4 f775783ef82b4442999ffd3ba7ce5374--02f96eb5c26e45d4b0be50442ba575a4 191d55f052d54ea9b77b05debf3be18c X 02f96eb5c26e45d4b0be50442ba575a4--191d55f052d54ea9b77b05debf3be18c 191d55f052d54ea9b77b05debf3be18c--091c39b169fc409b83bffe0e7d920231 76d1c37249834398abf4dc8e4e8cea93 X 191d55f052d54ea9b77b05debf3be18c--76d1c37249834398abf4dc8e4e8cea93 76d1c37249834398abf4dc8e4e8cea93--b3250c4951594fe89e15535e2967ed12 bd8b90cb362247508776fd16557750f5 76d1c37249834398abf4dc8e4e8cea93--bd8b90cb362247508776fd16557750f5 9ac28ddc552f49aab06c038ff74758bf bd8b90cb362247508776fd16557750f5--9ac28ddc552f49aab06c038ff74758bf bf17fb970953434480b97f2c2a592919 9ac28ddc552f49aab06c038ff74758bf--bf17fb970953434480b97f2c2a592919 b1ebbbbca83945329466f812d8d4ea13 bf17fb970953434480b97f2c2a592919--b1ebbbbca83945329466f812d8d4ea13 8185db6139264b35804930d2069043cb b1ebbbbca83945329466f812d8d4ea13--8185db6139264b35804930d2069043cb e69506e7cb284f68a82d2f4679136585 8185db6139264b35804930d2069043cb--e69506e7cb284f68a82d2f4679136585 45a53b32e9fa4101bc36569d03da2a1d e69506e7cb284f68a82d2f4679136585--45a53b32e9fa4101bc36569d03da2a1d ba00c19af53f4d178d3da9fd8e819526 45a53b32e9fa4101bc36569d03da2a1d--ba00c19af53f4d178d3da9fd8e819526 6317ffd68857447aba50fa3e5392ea02 ba00c19af53f4d178d3da9fd8e819526--6317ffd68857447aba50fa3e5392ea02 254a6f549f094f3995f093456f68cebe X 6317ffd68857447aba50fa3e5392ea02--254a6f549f094f3995f093456f68cebe 254a6f549f094f3995f093456f68cebe--af602e4150a34b56ae7cd3e3da705c72 c835e850e34e4b04874713dd33a6534d 254a6f549f094f3995f093456f68cebe--c835e850e34e4b04874713dd33a6534d 6fc3026c1393462fa4bc5cd051d78899 c835e850e34e4b04874713dd33a6534d--6fc3026c1393462fa4bc5cd051d78899 8c486ea208ba48fb8164ec59c9988aad 6fc3026c1393462fa4bc5cd051d78899--8c486ea208ba48fb8164ec59c9988aad 40faeddc3eaf4d7d8fbf1dacb6761218 8c486ea208ba48fb8164ec59c9988aad--40faeddc3eaf4d7d8fbf1dacb6761218 7498a0f29b9e440686c1ce1f46a450d8 40faeddc3eaf4d7d8fbf1dacb6761218--7498a0f29b9e440686c1ce1f46a450d8 aa9d839fa3ab4865a1aa7f7d680f81a1 7498a0f29b9e440686c1ce1f46a450d8--aa9d839fa3ab4865a1aa7f7d680f81a1 c62db06d84ba48a2827882fc0a046bf2 aa9d839fa3ab4865a1aa7f7d680f81a1--c62db06d84ba48a2827882fc0a046bf2 3f34322fbc6646ad9702b9da407fe790 c62db06d84ba48a2827882fc0a046bf2--3f34322fbc6646ad9702b9da407fe790 6dd7baa93a1748d5a5c70d31b97acce6 3f34322fbc6646ad9702b9da407fe790--6dd7baa93a1748d5a5c70d31b97acce6 13dca00a5ea64648b1639cfd52583d8a 6dd7baa93a1748d5a5c70d31b97acce6--13dca00a5ea64648b1639cfd52583d8a e4adbeb83c8a4aa7bea4d29506d19146 13dca00a5ea64648b1639cfd52583d8a--e4adbeb83c8a4aa7bea4d29506d19146 09da38997f8c4c5a8ec3054237a2797e e4adbeb83c8a4aa7bea4d29506d19146--09da38997f8c4c5a8ec3054237a2797e 62c83e60f8234ee0a0a1da25189364b0 09da38997f8c4c5a8ec3054237a2797e--62c83e60f8234ee0a0a1da25189364b0 5a89d833eaf2402aaf8c2b81e02cbc49 62c83e60f8234ee0a0a1da25189364b0--5a89d833eaf2402aaf8c2b81e02cbc49 6fb802de418f4014b1b644d6170aac83 5a89d833eaf2402aaf8c2b81e02cbc49--6fb802de418f4014b1b644d6170aac83 c0911cfb04354e28a17c140b1995f14e 6fb802de418f4014b1b644d6170aac83--c0911cfb04354e28a17c140b1995f14e 3c76e33912d74f3db7c2ff6771b49a3f c0911cfb04354e28a17c140b1995f14e--3c76e33912d74f3db7c2ff6771b49a3f 17edbcf162fa453a8188bd5e2b9bb451 3c76e33912d74f3db7c2ff6771b49a3f--17edbcf162fa453a8188bd5e2b9bb451 aab1748ad32a451ebdf6b784ef264278 17edbcf162fa453a8188bd5e2b9bb451--aab1748ad32a451ebdf6b784ef264278 7a95d3c153364f28b7a0d7c08cfbaacc aab1748ad32a451ebdf6b784ef264278--7a95d3c153364f28b7a0d7c08cfbaacc 702390faacb04a879203cb61606e33fb 7a95d3c153364f28b7a0d7c08cfbaacc--702390faacb04a879203cb61606e33fb 89ec2df894ca4817afd0dfd7905f409d 702390faacb04a879203cb61606e33fb--89ec2df894ca4817afd0dfd7905f409d 742ed0d12f6346b39de5392eec41c21f 89ec2df894ca4817afd0dfd7905f409d--742ed0d12f6346b39de5392eec41c21f ef0ecc00a100451294487850d2f9ec61 742ed0d12f6346b39de5392eec41c21f--ef0ecc00a100451294487850d2f9ec61 cde78d03c3544a65879c9f325dff05a6 ef0ecc00a100451294487850d2f9ec61--cde78d03c3544a65879c9f325dff05a6 6c3cf53698b9415da68dd1a9e139a1db cde78d03c3544a65879c9f325dff05a6--6c3cf53698b9415da68dd1a9e139a1db 9ad68e66083a42e8883df325db747fcd 6c3cf53698b9415da68dd1a9e139a1db--9ad68e66083a42e8883df325db747fcd 03ba1e4346e44015b0a4dca9dc9d521d 9ad68e66083a42e8883df325db747fcd--03ba1e4346e44015b0a4dca9dc9d521d 262d4d6699584a18902a9001e77e2120 03ba1e4346e44015b0a4dca9dc9d521d--262d4d6699584a18902a9001e77e2120 54bf6120759346939fbb5d92bec754d1 262d4d6699584a18902a9001e77e2120--54bf6120759346939fbb5d92bec754d1 69bfe331fcad4064a5a02236bfd0b323 54bf6120759346939fbb5d92bec754d1--69bfe331fcad4064a5a02236bfd0b323 2652dcefdfea405fa22b9b3b394c7791 69bfe331fcad4064a5a02236bfd0b323--2652dcefdfea405fa22b9b3b394c7791 714e47d637d648f49f7147ff287265dd 2652dcefdfea405fa22b9b3b394c7791--714e47d637d648f49f7147ff287265dd c71069df036b43d3ad8500c7d47d8b2e 714e47d637d648f49f7147ff287265dd--c71069df036b43d3ad8500c7d47d8b2e f24587f1c1a2460c90878f329f4ceef3 c71069df036b43d3ad8500c7d47d8b2e--f24587f1c1a2460c90878f329f4ceef3 05aa3266894944cda9dc3f2bdf252ded f24587f1c1a2460c90878f329f4ceef3--05aa3266894944cda9dc3f2bdf252ded d595c976b13f47c58d2588a9d83aad99 05aa3266894944cda9dc3f2bdf252ded--d595c976b13f47c58d2588a9d83aad99 daa43ce0ea954993814cb6e4297e5821 RX(b03) d595c976b13f47c58d2588a9d83aad99--daa43ce0ea954993814cb6e4297e5821 523fd0977ed5487e853b476468735026 daa43ce0ea954993814cb6e4297e5821--523fd0977ed5487e853b476468735026 6d56e8b7b9bd4856a14705e37d220677 523fd0977ed5487e853b476468735026--6d56e8b7b9bd4856a14705e37d220677 ad34c409820a4ab2ae7c2fdeaa54d628 X 6d56e8b7b9bd4856a14705e37d220677--ad34c409820a4ab2ae7c2fdeaa54d628 ad34c409820a4ab2ae7c2fdeaa54d628--011579e3e4de47d29d673f48cbe22da2 1da057d0c2674be28e2d496a60b4482f ad34c409820a4ab2ae7c2fdeaa54d628--1da057d0c2674be28e2d496a60b4482f 801a32cfc9ca4903afd824667c1fd056 1da057d0c2674be28e2d496a60b4482f--801a32cfc9ca4903afd824667c1fd056 ae7404ace5fa4cc29ec285d867fbba59 801a32cfc9ca4903afd824667c1fd056--ae7404ace5fa4cc29ec285d867fbba59 1d2cd640fdd84ee0b7be60d035a05f38 ae7404ace5fa4cc29ec285d867fbba59--1d2cd640fdd84ee0b7be60d035a05f38 c84fd449b632489bb6c4c99f6261041a 1d2cd640fdd84ee0b7be60d035a05f38--c84fd449b632489bb6c4c99f6261041a dcc95e0ac1fe470d9b798664750560d8 c84fd449b632489bb6c4c99f6261041a--dcc95e0ac1fe470d9b798664750560d8 285538c051a140999797ed047fbf30a3 dcc95e0ac1fe470d9b798664750560d8--285538c051a140999797ed047fbf30a3 e888db6ac48e4b02967fee9d75b9de5e 285538c051a140999797ed047fbf30a3--e888db6ac48e4b02967fee9d75b9de5e 3b0eb5c5271042abbbde45b5ee1134df e888db6ac48e4b02967fee9d75b9de5e--3b0eb5c5271042abbbde45b5ee1134df 9ed31501b59e425497def5d6a87defbf X 3b0eb5c5271042abbbde45b5ee1134df--9ed31501b59e425497def5d6a87defbf 9ed31501b59e425497def5d6a87defbf--5122e0fdc0aa4041a35613afb40e0230 194277c652f84c7a9e3c404932b5e89a 9ed31501b59e425497def5d6a87defbf--194277c652f84c7a9e3c404932b5e89a 7cbed0d6623c4421b45f1e17b9c7b3e2 194277c652f84c7a9e3c404932b5e89a--7cbed0d6623c4421b45f1e17b9c7b3e2 0a6a26ec00384bea9a856383173b4eeb 7cbed0d6623c4421b45f1e17b9c7b3e2--0a6a26ec00384bea9a856383173b4eeb 40f7db4a91ab4c6683ad0fff4c3873c6 0a6a26ec00384bea9a856383173b4eeb--40f7db4a91ab4c6683ad0fff4c3873c6 33ddd809479a4b68aef49796c394a171 40f7db4a91ab4c6683ad0fff4c3873c6--33ddd809479a4b68aef49796c394a171 659cb9217bba4abaa7d9b421da5c5651 33ddd809479a4b68aef49796c394a171--659cb9217bba4abaa7d9b421da5c5651 3fe01c1db4a3477ab686ee39ad68ab3e 659cb9217bba4abaa7d9b421da5c5651--3fe01c1db4a3477ab686ee39ad68ab3e fe0e304c464a4b80b6900ff38bf3d497 X 3fe01c1db4a3477ab686ee39ad68ab3e--fe0e304c464a4b80b6900ff38bf3d497 fe0e304c464a4b80b6900ff38bf3d497--fe0fc056246c441aa3379fb724fc72b1 2e8a0ae4afe9441e8c6836a925215401 fe0e304c464a4b80b6900ff38bf3d497--2e8a0ae4afe9441e8c6836a925215401 b0a15b6338f54c6cba5bc2c489d5c5c9 2e8a0ae4afe9441e8c6836a925215401--b0a15b6338f54c6cba5bc2c489d5c5c9 a8ceab9d7c664c43b845243751c643f0 b0a15b6338f54c6cba5bc2c489d5c5c9--a8ceab9d7c664c43b845243751c643f0 b170f56df78d40d0bb3fdc5d8885dcb8 X a8ceab9d7c664c43b845243751c643f0--b170f56df78d40d0bb3fdc5d8885dcb8 b170f56df78d40d0bb3fdc5d8885dcb8--2b8b1bcc78754ea888f940d7b291239a 8e27b8367c4c498caf3284c76474aa34 b170f56df78d40d0bb3fdc5d8885dcb8--8e27b8367c4c498caf3284c76474aa34 2348ec3d0c064610a189fea47b6db948 8e27b8367c4c498caf3284c76474aa34--2348ec3d0c064610a189fea47b6db948 97b64c6d1ff84c12882cc6891428eaff 2348ec3d0c064610a189fea47b6db948--97b64c6d1ff84c12882cc6891428eaff 1c7b4e09a7494d56b562af0bdb9a91c5 97b64c6d1ff84c12882cc6891428eaff--1c7b4e09a7494d56b562af0bdb9a91c5 52cdb21a044342eaa72747013d80f0fc X 1c7b4e09a7494d56b562af0bdb9a91c5--52cdb21a044342eaa72747013d80f0fc 52cdb21a044342eaa72747013d80f0fc--21c33212469643e991c5979fa04ae838 b95876663e164d67bccbac5758b8d8b2 52cdb21a044342eaa72747013d80f0fc--b95876663e164d67bccbac5758b8d8b2 866ea17add8c42cea4463fd02017692e b95876663e164d67bccbac5758b8d8b2--866ea17add8c42cea4463fd02017692e 342e119dc5af4a62a6d0f7616b12d1be 866ea17add8c42cea4463fd02017692e--342e119dc5af4a62a6d0f7616b12d1be 99d7955ae7c24e32b95002a62a69153f 342e119dc5af4a62a6d0f7616b12d1be--99d7955ae7c24e32b95002a62a69153f 5d9a32a68ecb4e889ebe719f16e6e5db 99d7955ae7c24e32b95002a62a69153f--5d9a32a68ecb4e889ebe719f16e6e5db b534521e0fe244c9bdf0a7f16e0dc3ff 5d9a32a68ecb4e889ebe719f16e6e5db--b534521e0fe244c9bdf0a7f16e0dc3ff 17a5a6ed87854877af53cd2810e19c38 b534521e0fe244c9bdf0a7f16e0dc3ff--17a5a6ed87854877af53cd2810e19c38 3cef6c5192b34277911516f4dbe8d3d6 X 17a5a6ed87854877af53cd2810e19c38--3cef6c5192b34277911516f4dbe8d3d6 3cef6c5192b34277911516f4dbe8d3d6--38d7aecaff2e4256927ec70a333225de 0210497dd9974f8b8310c9345866212a 3cef6c5192b34277911516f4dbe8d3d6--0210497dd9974f8b8310c9345866212a af95df1e266c4ee48f223a8c28d0c697 0210497dd9974f8b8310c9345866212a--af95df1e266c4ee48f223a8c28d0c697 7441dd8291b94b37913b06fae50d731e af95df1e266c4ee48f223a8c28d0c697--7441dd8291b94b37913b06fae50d731e 8ad9b9964a524499813e1c5fac3b70af 7441dd8291b94b37913b06fae50d731e--8ad9b9964a524499813e1c5fac3b70af 83241153dbef4dfe8ffa65e705532149 8ad9b9964a524499813e1c5fac3b70af--83241153dbef4dfe8ffa65e705532149 e0f273252c4741968870b3985629298d 83241153dbef4dfe8ffa65e705532149--e0f273252c4741968870b3985629298d f20ac9153ca94ce8a1f5b68c82978a6a X e0f273252c4741968870b3985629298d--f20ac9153ca94ce8a1f5b68c82978a6a f20ac9153ca94ce8a1f5b68c82978a6a--74bed90ca04e4c8794f910911c0acab7 0df3c1a9c4ed47818ff45c9175d20218 f20ac9153ca94ce8a1f5b68c82978a6a--0df3c1a9c4ed47818ff45c9175d20218 14158505485f484c8c5efec2da0ad808 0df3c1a9c4ed47818ff45c9175d20218--14158505485f484c8c5efec2da0ad808 8c714e78d08d45fb87f98ccc932cf763 14158505485f484c8c5efec2da0ad808--8c714e78d08d45fb87f98ccc932cf763 7574c1d23ad24e0db9726d2b052b3f78 8c714e78d08d45fb87f98ccc932cf763--7574c1d23ad24e0db9726d2b052b3f78 26977e5040014e5b81d6e80cae3119e1 7574c1d23ad24e0db9726d2b052b3f78--26977e5040014e5b81d6e80cae3119e1 0d45b6f425154bf7bac13518f36ad845 X 26977e5040014e5b81d6e80cae3119e1--0d45b6f425154bf7bac13518f36ad845 0d45b6f425154bf7bac13518f36ad845--603afeca24bb4d47870604474e8c0cae fd4f20f075e64126ad5bb8fd75376ab5 0d45b6f425154bf7bac13518f36ad845--fd4f20f075e64126ad5bb8fd75376ab5 94c3099486dc4a37b3becf6c282c8ab4 fd4f20f075e64126ad5bb8fd75376ab5--94c3099486dc4a37b3becf6c282c8ab4 26d96b70fe3f473abba482d4031c67d1 X 94c3099486dc4a37b3becf6c282c8ab4--26d96b70fe3f473abba482d4031c67d1 26d96b70fe3f473abba482d4031c67d1--1b4b7238e1e14cc8886714136562bed7 760058e0c11b4f8cbdd1304af42c1a14 26d96b70fe3f473abba482d4031c67d1--760058e0c11b4f8cbdd1304af42c1a14 d5a3b23748a54098aa40385855e7a55f 760058e0c11b4f8cbdd1304af42c1a14--d5a3b23748a54098aa40385855e7a55f b9220d5d15a44c65b2ddec1f02467495 d5a3b23748a54098aa40385855e7a55f--b9220d5d15a44c65b2ddec1f02467495 ff786eb968a94f2497c2163c3d766eae b9220d5d15a44c65b2ddec1f02467495--ff786eb968a94f2497c2163c3d766eae 74508e2d16d7432e87dab9fabc83a370 ff786eb968a94f2497c2163c3d766eae--74508e2d16d7432e87dab9fabc83a370 7c256b3853f84a119a8f7a571bdc6f27 74508e2d16d7432e87dab9fabc83a370--7c256b3853f84a119a8f7a571bdc6f27 caef45e06385499c8bf96fbdfb533519 7c256b3853f84a119a8f7a571bdc6f27--caef45e06385499c8bf96fbdfb533519 61c2d8436d67417da59d8c333ce24480 caef45e06385499c8bf96fbdfb533519--61c2d8436d67417da59d8c333ce24480 100e4e8dc64f4b7882781c7181812584 61c2d8436d67417da59d8c333ce24480--100e4e8dc64f4b7882781c7181812584 83b6c9d60f7c4b16be24494ab5e3b72c X 100e4e8dc64f4b7882781c7181812584--83b6c9d60f7c4b16be24494ab5e3b72c 83b6c9d60f7c4b16be24494ab5e3b72c--f0d938f682494ac8afdb07a815c91a1b 87d5fcf363354b44b9455ecea1b541cc 83b6c9d60f7c4b16be24494ab5e3b72c--87d5fcf363354b44b9455ecea1b541cc c53ca3573e944c6984a22257907afa43 X 87d5fcf363354b44b9455ecea1b541cc--c53ca3573e944c6984a22257907afa43 c53ca3573e944c6984a22257907afa43--c2556983d7414fac89a991b0b390e1bd e5e969bbacca4702a6fd1b5615dd88e3 c53ca3573e944c6984a22257907afa43--e5e969bbacca4702a6fd1b5615dd88e3 85a34db9dfe44044b041659899edb152 e5e969bbacca4702a6fd1b5615dd88e3--85a34db9dfe44044b041659899edb152 b4940c2654ec4a7d888cbf60c308253f 85a34db9dfe44044b041659899edb152--b4940c2654ec4a7d888cbf60c308253f 7115a493ff654c7ba70c51145e017aba b4940c2654ec4a7d888cbf60c308253f--7115a493ff654c7ba70c51145e017aba 1d36e146250c4a01bfd088139d96d663 7115a493ff654c7ba70c51145e017aba--1d36e146250c4a01bfd088139d96d663 9374eff475fc4ce78356396d3bd27be3 X 1d36e146250c4a01bfd088139d96d663--9374eff475fc4ce78356396d3bd27be3 9374eff475fc4ce78356396d3bd27be3--c8c6c7baeed44b718a09af5beb041bdd 1e2fc376ec054014b4400d78d3108caa X 9374eff475fc4ce78356396d3bd27be3--1e2fc376ec054014b4400d78d3108caa 1e2fc376ec054014b4400d78d3108caa--89ccc2c699924277a26ebbfbe93717f3 9776d9a156c145118bb6d19e192a3c94 1e2fc376ec054014b4400d78d3108caa--9776d9a156c145118bb6d19e192a3c94 e198707b2f9644a382c20d371ef7af9d 9776d9a156c145118bb6d19e192a3c94--e198707b2f9644a382c20d371ef7af9d 48a5c42d4afe4058935c5a2c5f628eda e198707b2f9644a382c20d371ef7af9d--48a5c42d4afe4058935c5a2c5f628eda 1e5f89ba779d453396d86cf6565d546b 48a5c42d4afe4058935c5a2c5f628eda--1e5f89ba779d453396d86cf6565d546b 727f9c51d6ba48708d02c8c29817a66f 1e5f89ba779d453396d86cf6565d546b--727f9c51d6ba48708d02c8c29817a66f 955ade7eb1fa46789559ef7aa3c604d6 727f9c51d6ba48708d02c8c29817a66f--955ade7eb1fa46789559ef7aa3c604d6 645f7639b3d44eb383cba6295f63bf9e 955ade7eb1fa46789559ef7aa3c604d6--645f7639b3d44eb383cba6295f63bf9e ac23c4b815e04adbbf27ef53819861f9 X 645f7639b3d44eb383cba6295f63bf9e--ac23c4b815e04adbbf27ef53819861f9 ac23c4b815e04adbbf27ef53819861f9--88034d649e9c40c9a552a309bf2c82cf c4f3234bae4548f5ad667efad692e2e5 X ac23c4b815e04adbbf27ef53819861f9--c4f3234bae4548f5ad667efad692e2e5 c4f3234bae4548f5ad667efad692e2e5--14a37b187c52492e9a3a24c35ba8163b 1efa31ae06c44b09966b2ba23e3545d4 c4f3234bae4548f5ad667efad692e2e5--1efa31ae06c44b09966b2ba23e3545d4 1e6c01c3b16343c3aa53a51a3b5754bd 1efa31ae06c44b09966b2ba23e3545d4--1e6c01c3b16343c3aa53a51a3b5754bd 890d5396f8f04f8cbcaabca1b39e42ff 1e6c01c3b16343c3aa53a51a3b5754bd--890d5396f8f04f8cbcaabca1b39e42ff e708a662dab1455e85e8076d91f5689c 890d5396f8f04f8cbcaabca1b39e42ff--e708a662dab1455e85e8076d91f5689c 7ae7cfe412ca449899fffdc66e1dd621 e708a662dab1455e85e8076d91f5689c--7ae7cfe412ca449899fffdc66e1dd621 9b9a9f4cf1b14fa192a86856ad5250b7 7ae7cfe412ca449899fffdc66e1dd621--9b9a9f4cf1b14fa192a86856ad5250b7 95ea05f31ea249f8977a1d1dc9a65c1f 9b9a9f4cf1b14fa192a86856ad5250b7--95ea05f31ea249f8977a1d1dc9a65c1f 9fe1ab204998484f94a6ba939f9209d3 95ea05f31ea249f8977a1d1dc9a65c1f--9fe1ab204998484f94a6ba939f9209d3 7d3738e1cb9446af8306a52098f8a8bf 9fe1ab204998484f94a6ba939f9209d3--7d3738e1cb9446af8306a52098f8a8bf f9f56a3468f44eb0b105ed55b5c7bc62 X 7d3738e1cb9446af8306a52098f8a8bf--f9f56a3468f44eb0b105ed55b5c7bc62 f9f56a3468f44eb0b105ed55b5c7bc62--7ed313848f3c4c59af1870ce1c058821 8bc34d31eae9434bb89a91a2b1bd5bab f9f56a3468f44eb0b105ed55b5c7bc62--8bc34d31eae9434bb89a91a2b1bd5bab 1481ae43ff7f4297803ac2388e62da26 8bc34d31eae9434bb89a91a2b1bd5bab--1481ae43ff7f4297803ac2388e62da26 1422c4dad8234762bc915d9974f24dca 1481ae43ff7f4297803ac2388e62da26--1422c4dad8234762bc915d9974f24dca b9f9f5ae86c1409cbaa7476e111f3e33 1422c4dad8234762bc915d9974f24dca--b9f9f5ae86c1409cbaa7476e111f3e33 b5791c40f60443e2a0f958f5f2fbabc7 b9f9f5ae86c1409cbaa7476e111f3e33--b5791c40f60443e2a0f958f5f2fbabc7 616b0c62052d46a9ab216660f49d3093 b5791c40f60443e2a0f958f5f2fbabc7--616b0c62052d46a9ab216660f49d3093 2ba4694714c94174b08fbf2cd58975fe 616b0c62052d46a9ab216660f49d3093--2ba4694714c94174b08fbf2cd58975fe a5461d9c86da43bf8005cf092c0043ce 2ba4694714c94174b08fbf2cd58975fe--a5461d9c86da43bf8005cf092c0043ce f45dd11f4f38412ebd20603945c915c9 a5461d9c86da43bf8005cf092c0043ce--f45dd11f4f38412ebd20603945c915c9 e3d86239bc5a496fa0b94aecbc75fed0 f45dd11f4f38412ebd20603945c915c9--e3d86239bc5a496fa0b94aecbc75fed0 c9775809cf2a4f10bc9a612be0abe9d7 e3d86239bc5a496fa0b94aecbc75fed0--c9775809cf2a4f10bc9a612be0abe9d7 e1a3508cc47c4e8fb9ec6366c0128cc7 c9775809cf2a4f10bc9a612be0abe9d7--e1a3508cc47c4e8fb9ec6366c0128cc7 4ca2d13eac4044f29df956444336e165 e1a3508cc47c4e8fb9ec6366c0128cc7--4ca2d13eac4044f29df956444336e165 dfe3b3bb30394446a695b755eb7f3647 4ca2d13eac4044f29df956444336e165--dfe3b3bb30394446a695b755eb7f3647 4956b32fb94e40ac8d80a7d686b4a969 dfe3b3bb30394446a695b755eb7f3647--4956b32fb94e40ac8d80a7d686b4a969 d183c9a171db4d0fa6c4f006c4cbeb79 4956b32fb94e40ac8d80a7d686b4a969--d183c9a171db4d0fa6c4f006c4cbeb79 54323ce4a40b49ab993ce2e20bb3a1ab d183c9a171db4d0fa6c4f006c4cbeb79--54323ce4a40b49ab993ce2e20bb3a1ab 28510d09fec543aaaa02764f86e68534 54323ce4a40b49ab993ce2e20bb3a1ab--28510d09fec543aaaa02764f86e68534 face9115352745ed83a98ae1bf06c143 28510d09fec543aaaa02764f86e68534--face9115352745ed83a98ae1bf06c143 e04d0118559446ecb6e9b4513f35055f face9115352745ed83a98ae1bf06c143--e04d0118559446ecb6e9b4513f35055f eea96b64041449db9e02f1b5ed367596 e04d0118559446ecb6e9b4513f35055f--eea96b64041449db9e02f1b5ed367596 cad7ee9239734de6a24f1396cde2f219 eea96b64041449db9e02f1b5ed367596--cad7ee9239734de6a24f1396cde2f219 29eab96bd02a41a88e1b5a93f139702f cad7ee9239734de6a24f1396cde2f219--29eab96bd02a41a88e1b5a93f139702f c1da17ed34cf4526b4f0277172ced5f4 29eab96bd02a41a88e1b5a93f139702f--c1da17ed34cf4526b4f0277172ced5f4 d677ce163ac7410c821785086f9b015a c1da17ed34cf4526b4f0277172ced5f4--d677ce163ac7410c821785086f9b015a 9a7abe2dc0154211b879ceb3c7877a68 d677ce163ac7410c821785086f9b015a--9a7abe2dc0154211b879ceb3c7877a68 fe0a5681e6dd461a9af7f50a76819956 9a7abe2dc0154211b879ceb3c7877a68--fe0a5681e6dd461a9af7f50a76819956 ee4f5c40ef3d4d8fa7a814ab91afcb04 fe0a5681e6dd461a9af7f50a76819956--ee4f5c40ef3d4d8fa7a814ab91afcb04 025f5a91c20049b394e92aab4a47677e ee4f5c40ef3d4d8fa7a814ab91afcb04--025f5a91c20049b394e92aab4a47677e 623f2a17db3c4aeab53e856c1d69418a 025f5a91c20049b394e92aab4a47677e--623f2a17db3c4aeab53e856c1d69418a 3cd4f6fc4bcc4766ba53be3de6ff5e42 623f2a17db3c4aeab53e856c1d69418a--3cd4f6fc4bcc4766ba53be3de6ff5e42 0172594486344b34b850bcbb0a315409 3cd4f6fc4bcc4766ba53be3de6ff5e42--0172594486344b34b850bcbb0a315409 109dfe185f944bdda3c90d7c766438fe 0172594486344b34b850bcbb0a315409--109dfe185f944bdda3c90d7c766438fe 731b787ec74b49de9463475808a8e5ee 109dfe185f944bdda3c90d7c766438fe--731b787ec74b49de9463475808a8e5ee 1eb97bde239b47cd962cfc70277d1a70 731b787ec74b49de9463475808a8e5ee--1eb97bde239b47cd962cfc70277d1a70 c63fb82b22814bddba10da1579e4ad1b 1eb97bde239b47cd962cfc70277d1a70--c63fb82b22814bddba10da1579e4ad1b 14be36074ca64d54bec4e50a7c640848 c63fb82b22814bddba10da1579e4ad1b--14be36074ca64d54bec4e50a7c640848 d6d576836fbd4054b1ce40c5daf0c2b2 RX(b13) 14be36074ca64d54bec4e50a7c640848--d6d576836fbd4054b1ce40c5daf0c2b2 d6d576836fbd4054b1ce40c5daf0c2b2--f070e24129124bdfa834cd7b81d512b0 278385aabf4d452e8237c7b411c3f89e 567972730d1647d6b9ef6405449588f1 0fac5cb585034513bca6adb5c1a2ae33--567972730d1647d6b9ef6405449588f1 500a11f8eef34b6eb5fc5fa5e87e4090 5 7f42297245bc4226b4f127209b0d43c3 567972730d1647d6b9ef6405449588f1--7f42297245bc4226b4f127209b0d43c3 4f37c8d905b24db68cbfb3f201194848 7f42297245bc4226b4f127209b0d43c3--4f37c8d905b24db68cbfb3f201194848 91c05e4beb7447e896f6a7a6cfb2c3de X 4f37c8d905b24db68cbfb3f201194848--91c05e4beb7447e896f6a7a6cfb2c3de 91c05e4beb7447e896f6a7a6cfb2c3de--16e1e819aebb463d91f71230df83549c cdd06fdfb394494caaa9357467653cbc 91c05e4beb7447e896f6a7a6cfb2c3de--cdd06fdfb394494caaa9357467653cbc 4fd93c26274e4198a44a7daa3279a2ed cdd06fdfb394494caaa9357467653cbc--4fd93c26274e4198a44a7daa3279a2ed be3fcdf093d54fa89582764a2fa5e5a6 4fd93c26274e4198a44a7daa3279a2ed--be3fcdf093d54fa89582764a2fa5e5a6 8660a9aabfb44e8eb0094e77f71ab62e be3fcdf093d54fa89582764a2fa5e5a6--8660a9aabfb44e8eb0094e77f71ab62e 262a1fd9f06f4fba93fde5c44226b1f4 8660a9aabfb44e8eb0094e77f71ab62e--262a1fd9f06f4fba93fde5c44226b1f4 e6face8c87f04ae2a3533e43d0f69b20 262a1fd9f06f4fba93fde5c44226b1f4--e6face8c87f04ae2a3533e43d0f69b20 deab1bf2f9484e629bde6418fb994a2f e6face8c87f04ae2a3533e43d0f69b20--deab1bf2f9484e629bde6418fb994a2f a9099d549fe14ba68c892ccc6e08efd8 X deab1bf2f9484e629bde6418fb994a2f--a9099d549fe14ba68c892ccc6e08efd8 a9099d549fe14ba68c892ccc6e08efd8--705e26897be0493db5506b1e41112997 12c3f2c75b394f30af95348dfd0c266a a9099d549fe14ba68c892ccc6e08efd8--12c3f2c75b394f30af95348dfd0c266a d3abf6c56c8949fc97f5bfaa64910fcd 12c3f2c75b394f30af95348dfd0c266a--d3abf6c56c8949fc97f5bfaa64910fcd dc03fa17182f462cba8566dfb0ed3162 d3abf6c56c8949fc97f5bfaa64910fcd--dc03fa17182f462cba8566dfb0ed3162 40f16e21e5cd4a019446c7b7c0896bfb dc03fa17182f462cba8566dfb0ed3162--40f16e21e5cd4a019446c7b7c0896bfb 15d26aea411147c9a0bb84398941effc 40f16e21e5cd4a019446c7b7c0896bfb--15d26aea411147c9a0bb84398941effc c62938113c2d4b5cb1c9e0fae598a750 15d26aea411147c9a0bb84398941effc--c62938113c2d4b5cb1c9e0fae598a750 6b50b4af2fd74d53ae998da97e663507 c62938113c2d4b5cb1c9e0fae598a750--6b50b4af2fd74d53ae998da97e663507 6853bbad677a4470adaa8a1feaf399d3 6b50b4af2fd74d53ae998da97e663507--6853bbad677a4470adaa8a1feaf399d3 1ba3392068c44cfe9497feddcf3f0dbd 6853bbad677a4470adaa8a1feaf399d3--1ba3392068c44cfe9497feddcf3f0dbd 789bac7327934208baaf4faf2af867ab X 1ba3392068c44cfe9497feddcf3f0dbd--789bac7327934208baaf4faf2af867ab 789bac7327934208baaf4faf2af867ab--a40a67d02d5f4f69bea5b1f152836a5e 04721d59a801423594c240396d2f2b24 RZ(-1.0*g0) 789bac7327934208baaf4faf2af867ab--04721d59a801423594c240396d2f2b24 504096d1b8504d45a0b2d1ea07b2dc1a X 04721d59a801423594c240396d2f2b24--504096d1b8504d45a0b2d1ea07b2dc1a 504096d1b8504d45a0b2d1ea07b2dc1a--37854451dbc042e39f823266afc3df4f f6dc6c721bc544e48396b1609d5269ca 504096d1b8504d45a0b2d1ea07b2dc1a--f6dc6c721bc544e48396b1609d5269ca a88b504747664ec98aa6fb92544c20b2 f6dc6c721bc544e48396b1609d5269ca--a88b504747664ec98aa6fb92544c20b2 e5c3422ab0004c37b65bd404c56fca94 a88b504747664ec98aa6fb92544c20b2--e5c3422ab0004c37b65bd404c56fca94 a0a4dcd0af3c4106b56497f563b195f3 e5c3422ab0004c37b65bd404c56fca94--a0a4dcd0af3c4106b56497f563b195f3 b19787058db9440abf415121e73eb8d9 a0a4dcd0af3c4106b56497f563b195f3--b19787058db9440abf415121e73eb8d9 2d1431c0c194469cbfc174e78c10cbcd b19787058db9440abf415121e73eb8d9--2d1431c0c194469cbfc174e78c10cbcd bbd85a80e8a44d83be18aff2ae8d3399 X 2d1431c0c194469cbfc174e78c10cbcd--bbd85a80e8a44d83be18aff2ae8d3399 bbd85a80e8a44d83be18aff2ae8d3399--72292e33823e4ccfb052e1a21744371e e007e950a1c94de3906360e309c29a38 bbd85a80e8a44d83be18aff2ae8d3399--e007e950a1c94de3906360e309c29a38 f3f2fec7e0494b58aa39dc385cc388a2 e007e950a1c94de3906360e309c29a38--f3f2fec7e0494b58aa39dc385cc388a2 9bef10161c1146bc87ca64facb9bd5b5 f3f2fec7e0494b58aa39dc385cc388a2--9bef10161c1146bc87ca64facb9bd5b5 28f2f691c5684d85b0be66d147504377 9bef10161c1146bc87ca64facb9bd5b5--28f2f691c5684d85b0be66d147504377 1ce5cb5d423349a7acc897a1b11e61e5 28f2f691c5684d85b0be66d147504377--1ce5cb5d423349a7acc897a1b11e61e5 ce1ddb6bd09f411ea13b9b936eff5352 X 1ce5cb5d423349a7acc897a1b11e61e5--ce1ddb6bd09f411ea13b9b936eff5352 ce1ddb6bd09f411ea13b9b936eff5352--8d87bccba303431e97244f5fdf4236e4 12dd68f74df140dda2174be78491e973 ce1ddb6bd09f411ea13b9b936eff5352--12dd68f74df140dda2174be78491e973 bf8213ed2fc64485994a845415c946b4 12dd68f74df140dda2174be78491e973--bf8213ed2fc64485994a845415c946b4 52a8af06ebe34901936fcd6eee867a3c bf8213ed2fc64485994a845415c946b4--52a8af06ebe34901936fcd6eee867a3c 99541f494ae34096a51fae6e6562a6c5 52a8af06ebe34901936fcd6eee867a3c--99541f494ae34096a51fae6e6562a6c5 d5228e5581bc44e2a2da2226adf73445 99541f494ae34096a51fae6e6562a6c5--d5228e5581bc44e2a2da2226adf73445 fc700ba9b8814f3698b775d37a166725 d5228e5581bc44e2a2da2226adf73445--fc700ba9b8814f3698b775d37a166725 55a0630255204ddfba2c17e6d3fbdca7 fc700ba9b8814f3698b775d37a166725--55a0630255204ddfba2c17e6d3fbdca7 f4572cd364134aac856c49a2e899f50c 55a0630255204ddfba2c17e6d3fbdca7--f4572cd364134aac856c49a2e899f50c 2333d7d1a12a4931a8151d86d65a5944 X f4572cd364134aac856c49a2e899f50c--2333d7d1a12a4931a8151d86d65a5944 2333d7d1a12a4931a8151d86d65a5944--43895d609ae64079a31ff45f47079d8c 594b59e7a5304d8793c42455c5002532 2333d7d1a12a4931a8151d86d65a5944--594b59e7a5304d8793c42455c5002532 091f90c8aef24ed7ab9aa7a72eed5199 594b59e7a5304d8793c42455c5002532--091f90c8aef24ed7ab9aa7a72eed5199 829d0ffbfb0c4fc1b829c923b59429be 091f90c8aef24ed7ab9aa7a72eed5199--829d0ffbfb0c4fc1b829c923b59429be 1e00df3108864665953d207df1ae9084 X 829d0ffbfb0c4fc1b829c923b59429be--1e00df3108864665953d207df1ae9084 1e00df3108864665953d207df1ae9084--44af79adc9ad4c609d51ca9631e0ae2d 9cce47a1a0d3431d89515af04c939f28 1e00df3108864665953d207df1ae9084--9cce47a1a0d3431d89515af04c939f28 0261f3ef58c04acea855847ec3763d8b 9cce47a1a0d3431d89515af04c939f28--0261f3ef58c04acea855847ec3763d8b 7b62bd5dec604178bbf14935bb6a22bf 0261f3ef58c04acea855847ec3763d8b--7b62bd5dec604178bbf14935bb6a22bf a7ed6d1530b04e0fac5e0075ae8db7f3 7b62bd5dec604178bbf14935bb6a22bf--a7ed6d1530b04e0fac5e0075ae8db7f3 aca174353af948329b2e561aca104b8b X a7ed6d1530b04e0fac5e0075ae8db7f3--aca174353af948329b2e561aca104b8b aca174353af948329b2e561aca104b8b--7a96cb85c21a45e2839bcc4c286a8ccf 75c15ae131f7493fbf3628938db39c30 aca174353af948329b2e561aca104b8b--75c15ae131f7493fbf3628938db39c30 ae6dd5865639483c8bf8e4017b19300c 75c15ae131f7493fbf3628938db39c30--ae6dd5865639483c8bf8e4017b19300c 5b6fc9715ba0475090388721f98a5aa5 ae6dd5865639483c8bf8e4017b19300c--5b6fc9715ba0475090388721f98a5aa5 f967a179833043d28daa5a9729e4fc6c 5b6fc9715ba0475090388721f98a5aa5--f967a179833043d28daa5a9729e4fc6c a93340834a0a4c5baaf16239760c1c44 f967a179833043d28daa5a9729e4fc6c--a93340834a0a4c5baaf16239760c1c44 6368564268d24ef19c732f4072cba8f9 a93340834a0a4c5baaf16239760c1c44--6368564268d24ef19c732f4072cba8f9 7e595c24659f48a9b6f69a9909cf6ba5 6368564268d24ef19c732f4072cba8f9--7e595c24659f48a9b6f69a9909cf6ba5 8aba4f13f5264cf1ab4e2469a94f67e2 X 7e595c24659f48a9b6f69a9909cf6ba5--8aba4f13f5264cf1ab4e2469a94f67e2 8aba4f13f5264cf1ab4e2469a94f67e2--5c96f9e168124c5f82f55cacda867812 74d88266b40240d7a80e5f78a4f7605b 8aba4f13f5264cf1ab4e2469a94f67e2--74d88266b40240d7a80e5f78a4f7605b 98867e25eda84939a910dfa483c083dd 74d88266b40240d7a80e5f78a4f7605b--98867e25eda84939a910dfa483c083dd ef0639286b8c4a81b5d178d71ae5e324 98867e25eda84939a910dfa483c083dd--ef0639286b8c4a81b5d178d71ae5e324 5e75a28844f14500bc0fb716a400b3bc X ef0639286b8c4a81b5d178d71ae5e324--5e75a28844f14500bc0fb716a400b3bc 5e75a28844f14500bc0fb716a400b3bc--7ba199bdd0814c99b9ebd641f8a45f77 ed7307af7a1a48d5ba510d527d538cad 5e75a28844f14500bc0fb716a400b3bc--ed7307af7a1a48d5ba510d527d538cad 5ac32ecd9d294d658639997e1826ef80 ed7307af7a1a48d5ba510d527d538cad--5ac32ecd9d294d658639997e1826ef80 88764bbc5eab4d1aa68571cd753c4f75 5ac32ecd9d294d658639997e1826ef80--88764bbc5eab4d1aa68571cd753c4f75 7221d8b6805a465a84d3fef8665eb5cd X 88764bbc5eab4d1aa68571cd753c4f75--7221d8b6805a465a84d3fef8665eb5cd 7221d8b6805a465a84d3fef8665eb5cd--9f1b088087174a3aac0a6bcbab6efe34 2c3b52c2c6a34f058178957d6eee16c1 7221d8b6805a465a84d3fef8665eb5cd--2c3b52c2c6a34f058178957d6eee16c1 ff67be7c765a47fbbc7d87eecf4756ec 2c3b52c2c6a34f058178957d6eee16c1--ff67be7c765a47fbbc7d87eecf4756ec 7832f7a4a3524d9b9c57d6983da3fc25 X ff67be7c765a47fbbc7d87eecf4756ec--7832f7a4a3524d9b9c57d6983da3fc25 7832f7a4a3524d9b9c57d6983da3fc25--e21e8150e5424352a1119ace12348155 3ff428ea9d52439c9f43206d6e860d1d 7832f7a4a3524d9b9c57d6983da3fc25--3ff428ea9d52439c9f43206d6e860d1d f882b5035b81431790c9cb5ffc66bb4c 3ff428ea9d52439c9f43206d6e860d1d--f882b5035b81431790c9cb5ffc66bb4c b6fc3752ac5542caa04261bf2efddadf f882b5035b81431790c9cb5ffc66bb4c--b6fc3752ac5542caa04261bf2efddadf 3a954929224f4d6f95c094abcfa13535 b6fc3752ac5542caa04261bf2efddadf--3a954929224f4d6f95c094abcfa13535 33a49f8c08bf4736afd151e13ed50800 3a954929224f4d6f95c094abcfa13535--33a49f8c08bf4736afd151e13ed50800 c02edfe4eede4803abedf3e97de691bb X 33a49f8c08bf4736afd151e13ed50800--c02edfe4eede4803abedf3e97de691bb c02edfe4eede4803abedf3e97de691bb--02f96eb5c26e45d4b0be50442ba575a4 c3c411d188184871a893f1372c6e0977 c02edfe4eede4803abedf3e97de691bb--c3c411d188184871a893f1372c6e0977 53d5dd218f5247d285158724c7710756 c3c411d188184871a893f1372c6e0977--53d5dd218f5247d285158724c7710756 18332fdcca3c4f628a021cfe347451d4 X 53d5dd218f5247d285158724c7710756--18332fdcca3c4f628a021cfe347451d4 18332fdcca3c4f628a021cfe347451d4--bd8b90cb362247508776fd16557750f5 ae1511db5bde4159a09cb45f36b09ba9 18332fdcca3c4f628a021cfe347451d4--ae1511db5bde4159a09cb45f36b09ba9 35431f03e0474c219022be1a3d641023 ae1511db5bde4159a09cb45f36b09ba9--35431f03e0474c219022be1a3d641023 873f75d385ac4391a4519ab318489d02 35431f03e0474c219022be1a3d641023--873f75d385ac4391a4519ab318489d02 bed4fd3dee7d409d9490475f8b8bb238 873f75d385ac4391a4519ab318489d02--bed4fd3dee7d409d9490475f8b8bb238 4268556970124e2aa985538690447429 bed4fd3dee7d409d9490475f8b8bb238--4268556970124e2aa985538690447429 b6558c2800e04dfe93ea7dbcd55440eb 4268556970124e2aa985538690447429--b6558c2800e04dfe93ea7dbcd55440eb 509cc40f3eb04a2586c12817786960d9 b6558c2800e04dfe93ea7dbcd55440eb--509cc40f3eb04a2586c12817786960d9 f150abfeed834efe9a7613bb81b46994 X 509cc40f3eb04a2586c12817786960d9--f150abfeed834efe9a7613bb81b46994 f150abfeed834efe9a7613bb81b46994--6317ffd68857447aba50fa3e5392ea02 e4526f9a649c4634b2106c2756ad9e70 f150abfeed834efe9a7613bb81b46994--e4526f9a649c4634b2106c2756ad9e70 c51208f2095949b2971df9d84688b375 X e4526f9a649c4634b2106c2756ad9e70--c51208f2095949b2971df9d84688b375 c51208f2095949b2971df9d84688b375--c835e850e34e4b04874713dd33a6534d 3441e9fc6b904ecdb53c8b34d3e43508 c51208f2095949b2971df9d84688b375--3441e9fc6b904ecdb53c8b34d3e43508 b164dff75b7f40e9ab53f74e52771916 3441e9fc6b904ecdb53c8b34d3e43508--b164dff75b7f40e9ab53f74e52771916 365f3ecf86384d06a6d29abb0bf55ca5 b164dff75b7f40e9ab53f74e52771916--365f3ecf86384d06a6d29abb0bf55ca5 28d2f9f5715a42a888fb4e2bfabc55fe X 365f3ecf86384d06a6d29abb0bf55ca5--28d2f9f5715a42a888fb4e2bfabc55fe 28d2f9f5715a42a888fb4e2bfabc55fe--7498a0f29b9e440686c1ce1f46a450d8 514b6404afd8431485e812396c643361 X 28d2f9f5715a42a888fb4e2bfabc55fe--514b6404afd8431485e812396c643361 514b6404afd8431485e812396c643361--aa9d839fa3ab4865a1aa7f7d680f81a1 717f5dc6265a45d9b99e7c3643871e24 514b6404afd8431485e812396c643361--717f5dc6265a45d9b99e7c3643871e24 53cec2c756ab41118d957254b8b1b0f8 717f5dc6265a45d9b99e7c3643871e24--53cec2c756ab41118d957254b8b1b0f8 b0c2b79aaab44ae6ab2fef23c64a172b 53cec2c756ab41118d957254b8b1b0f8--b0c2b79aaab44ae6ab2fef23c64a172b a7740f4c68d14417915afc13d43fee0b b0c2b79aaab44ae6ab2fef23c64a172b--a7740f4c68d14417915afc13d43fee0b 5ff683e226c344189977fa00a1075d0e a7740f4c68d14417915afc13d43fee0b--5ff683e226c344189977fa00a1075d0e edfe05b4344a414aa278f6bcaeccfbdf 5ff683e226c344189977fa00a1075d0e--edfe05b4344a414aa278f6bcaeccfbdf a60673e5907e441a84798f4df027c282 edfe05b4344a414aa278f6bcaeccfbdf--a60673e5907e441a84798f4df027c282 549227da66f54fa4b2e5c9d3a1a6bb4f X a60673e5907e441a84798f4df027c282--549227da66f54fa4b2e5c9d3a1a6bb4f 549227da66f54fa4b2e5c9d3a1a6bb4f--5a89d833eaf2402aaf8c2b81e02cbc49 013fc85077fb407eac9606e3f3313f5e 549227da66f54fa4b2e5c9d3a1a6bb4f--013fc85077fb407eac9606e3f3313f5e ba8f530e17c441ee85d782de325e8627 013fc85077fb407eac9606e3f3313f5e--ba8f530e17c441ee85d782de325e8627 b51aec70653a4af7bf290fca8eb5fca0 ba8f530e17c441ee85d782de325e8627--b51aec70653a4af7bf290fca8eb5fca0 8b96c2a872f741f2b07b45d67d7c436f b51aec70653a4af7bf290fca8eb5fca0--8b96c2a872f741f2b07b45d67d7c436f c70fa9f7aeb4445c839f9909eed02c93 8b96c2a872f741f2b07b45d67d7c436f--c70fa9f7aeb4445c839f9909eed02c93 170eea326b4144d6b15114bfa56aefa3 c70fa9f7aeb4445c839f9909eed02c93--170eea326b4144d6b15114bfa56aefa3 3fc4de9947ac4441a1dd834a6e5c054e 170eea326b4144d6b15114bfa56aefa3--3fc4de9947ac4441a1dd834a6e5c054e 1fe689ba14b64046aca4c3dec5af4ed8 3fc4de9947ac4441a1dd834a6e5c054e--1fe689ba14b64046aca4c3dec5af4ed8 a8bc949b3b54420c9fce3d578bea4139 1fe689ba14b64046aca4c3dec5af4ed8--a8bc949b3b54420c9fce3d578bea4139 36992fc19e1a4a91a776c1c5fa65b62c a8bc949b3b54420c9fce3d578bea4139--36992fc19e1a4a91a776c1c5fa65b62c b4f51fad59cf430ca1087cb39260fa81 36992fc19e1a4a91a776c1c5fa65b62c--b4f51fad59cf430ca1087cb39260fa81 779b9554cae34f4997145d238a6090f5 b4f51fad59cf430ca1087cb39260fa81--779b9554cae34f4997145d238a6090f5 9f3b1b4d64284f4cbe3885a859a6626d 779b9554cae34f4997145d238a6090f5--9f3b1b4d64284f4cbe3885a859a6626d 62226be324f04854822ef7bfbfee7870 9f3b1b4d64284f4cbe3885a859a6626d--62226be324f04854822ef7bfbfee7870 65e585a773764eeea13968611ef16de2 62226be324f04854822ef7bfbfee7870--65e585a773764eeea13968611ef16de2 687c17df82954a5599c0470f42eda20f 65e585a773764eeea13968611ef16de2--687c17df82954a5599c0470f42eda20f e9290bcb1e5942399aecd70571aa9284 687c17df82954a5599c0470f42eda20f--e9290bcb1e5942399aecd70571aa9284 ec1c0bd9e5724304a2abcd76acae3ab4 e9290bcb1e5942399aecd70571aa9284--ec1c0bd9e5724304a2abcd76acae3ab4 5321da3b086a4e87ae447dd7ecf6cd01 ec1c0bd9e5724304a2abcd76acae3ab4--5321da3b086a4e87ae447dd7ecf6cd01 8d4d9b3c535b408094813c495d88324a 5321da3b086a4e87ae447dd7ecf6cd01--8d4d9b3c535b408094813c495d88324a 3188c7b8b7ef41dc98820784e43e7886 8d4d9b3c535b408094813c495d88324a--3188c7b8b7ef41dc98820784e43e7886 68118bb6c9ee4a618f92f8dd00cc5016 3188c7b8b7ef41dc98820784e43e7886--68118bb6c9ee4a618f92f8dd00cc5016 734d461a96a04b8096f24aa22f37e21c 68118bb6c9ee4a618f92f8dd00cc5016--734d461a96a04b8096f24aa22f37e21c b18baaba37f941a3b94d435fcec9b90f RX(b04) 734d461a96a04b8096f24aa22f37e21c--b18baaba37f941a3b94d435fcec9b90f a3501ad4eb8a46ee95258b6effcb096c b18baaba37f941a3b94d435fcec9b90f--a3501ad4eb8a46ee95258b6effcb096c 2b3166a0da3e453b9f7af98f9df8739b a3501ad4eb8a46ee95258b6effcb096c--2b3166a0da3e453b9f7af98f9df8739b 2671a711f49545cabaee66a6f8730131 2b3166a0da3e453b9f7af98f9df8739b--2671a711f49545cabaee66a6f8730131 042e766016a84d42bda45f81b3ef9613 X 2671a711f49545cabaee66a6f8730131--042e766016a84d42bda45f81b3ef9613 042e766016a84d42bda45f81b3ef9613--1da057d0c2674be28e2d496a60b4482f f5f1640a5a34449aa906d87437efe5a8 042e766016a84d42bda45f81b3ef9613--f5f1640a5a34449aa906d87437efe5a8 b3e501101fc74281840823377bd7c4cc f5f1640a5a34449aa906d87437efe5a8--b3e501101fc74281840823377bd7c4cc f0391b97337f46538b458431ae652e37 b3e501101fc74281840823377bd7c4cc--f0391b97337f46538b458431ae652e37 1b66ea46e53640d6844c4cc5f5d2e081 f0391b97337f46538b458431ae652e37--1b66ea46e53640d6844c4cc5f5d2e081 ea058de5872b4be0b0dff6aeb2a407a1 1b66ea46e53640d6844c4cc5f5d2e081--ea058de5872b4be0b0dff6aeb2a407a1 0cdf4bb9eb7e422a9a88401bd4fed7f3 ea058de5872b4be0b0dff6aeb2a407a1--0cdf4bb9eb7e422a9a88401bd4fed7f3 1286bc8d3db64a03aac4609e4e4b12c0 0cdf4bb9eb7e422a9a88401bd4fed7f3--1286bc8d3db64a03aac4609e4e4b12c0 6467adec40f244cea99f054720268794 X 1286bc8d3db64a03aac4609e4e4b12c0--6467adec40f244cea99f054720268794 6467adec40f244cea99f054720268794--3b0eb5c5271042abbbde45b5ee1134df bd7a8a8157df49659ff2a7ab5f3d3b08 6467adec40f244cea99f054720268794--bd7a8a8157df49659ff2a7ab5f3d3b08 3d64ab04ae7e4a12aede7d5e3b5baa52 bd7a8a8157df49659ff2a7ab5f3d3b08--3d64ab04ae7e4a12aede7d5e3b5baa52 1b470773d9f149ad884181806c2f66ce 3d64ab04ae7e4a12aede7d5e3b5baa52--1b470773d9f149ad884181806c2f66ce 3d1b5e3f669445a6af6d7f4b65717f47 1b470773d9f149ad884181806c2f66ce--3d1b5e3f669445a6af6d7f4b65717f47 a7dea6ac6c2a45a7b8bb89582b3843b6 3d1b5e3f669445a6af6d7f4b65717f47--a7dea6ac6c2a45a7b8bb89582b3843b6 e80ef4910d4d4075be6224bcd9168b25 a7dea6ac6c2a45a7b8bb89582b3843b6--e80ef4910d4d4075be6224bcd9168b25 1a2e21a635db47a9abb5a3813f8900b7 e80ef4910d4d4075be6224bcd9168b25--1a2e21a635db47a9abb5a3813f8900b7 fbe3cf07eba446ada830a5863d053f48 1a2e21a635db47a9abb5a3813f8900b7--fbe3cf07eba446ada830a5863d053f48 5225663f3ed747699b2937ad53107e2d fbe3cf07eba446ada830a5863d053f48--5225663f3ed747699b2937ad53107e2d f9aeb2870220459f8feaaa63a480b2b5 X 5225663f3ed747699b2937ad53107e2d--f9aeb2870220459f8feaaa63a480b2b5 f9aeb2870220459f8feaaa63a480b2b5--2e8a0ae4afe9441e8c6836a925215401 4dc585e267d94a2883044b502b98c26a RZ(-1.0*g1) f9aeb2870220459f8feaaa63a480b2b5--4dc585e267d94a2883044b502b98c26a cf29f68b7f454dbd89921795d2bdbb10 X 4dc585e267d94a2883044b502b98c26a--cf29f68b7f454dbd89921795d2bdbb10 cf29f68b7f454dbd89921795d2bdbb10--a8ceab9d7c664c43b845243751c643f0 9f44e1d0666d4d0da2bd54355a4d8f8c cf29f68b7f454dbd89921795d2bdbb10--9f44e1d0666d4d0da2bd54355a4d8f8c 21b7ecfc8d004fbf8c1bd16b363ca8bd 9f44e1d0666d4d0da2bd54355a4d8f8c--21b7ecfc8d004fbf8c1bd16b363ca8bd 485ed8b414234b208ae109eebe33db49 21b7ecfc8d004fbf8c1bd16b363ca8bd--485ed8b414234b208ae109eebe33db49 91d1cf491f5d4e8289bd86de4cb5b7a1 485ed8b414234b208ae109eebe33db49--91d1cf491f5d4e8289bd86de4cb5b7a1 1a7a919c0f1d4e27b2367a743c950b66 91d1cf491f5d4e8289bd86de4cb5b7a1--1a7a919c0f1d4e27b2367a743c950b66 be0d622077d640f889b73858861b188f 1a7a919c0f1d4e27b2367a743c950b66--be0d622077d640f889b73858861b188f a429ec86c15e46cbbde8d4555bebb461 X be0d622077d640f889b73858861b188f--a429ec86c15e46cbbde8d4555bebb461 a429ec86c15e46cbbde8d4555bebb461--b95876663e164d67bccbac5758b8d8b2 80115fff48704f5384669badb0717b46 a429ec86c15e46cbbde8d4555bebb461--80115fff48704f5384669badb0717b46 0724232f40554a298faefcf1c2edbc37 80115fff48704f5384669badb0717b46--0724232f40554a298faefcf1c2edbc37 5937e23261354ef9b22c669102ef8ffb 0724232f40554a298faefcf1c2edbc37--5937e23261354ef9b22c669102ef8ffb 111936e1933148888e532a7fe626e00b 5937e23261354ef9b22c669102ef8ffb--111936e1933148888e532a7fe626e00b 376827d2cb1847d28943d439b2eed1dc 111936e1933148888e532a7fe626e00b--376827d2cb1847d28943d439b2eed1dc 407acbd96c7c4eaaa375d1bf390a65e2 X 376827d2cb1847d28943d439b2eed1dc--407acbd96c7c4eaaa375d1bf390a65e2 407acbd96c7c4eaaa375d1bf390a65e2--17a5a6ed87854877af53cd2810e19c38 f91860c8f9bd43ed853bca1271c4fa8a 407acbd96c7c4eaaa375d1bf390a65e2--f91860c8f9bd43ed853bca1271c4fa8a 1c2f184af9a648afb13e0123eaa5c449 f91860c8f9bd43ed853bca1271c4fa8a--1c2f184af9a648afb13e0123eaa5c449 0a01a47812624868b635d725d04cdb1d 1c2f184af9a648afb13e0123eaa5c449--0a01a47812624868b635d725d04cdb1d 502c2d15ad914fad954860c6d3d39188 0a01a47812624868b635d725d04cdb1d--502c2d15ad914fad954860c6d3d39188 187906304cd44a74b90fbb999244c721 502c2d15ad914fad954860c6d3d39188--187906304cd44a74b90fbb999244c721 4b0ef2fe49c940728321600f97924687 187906304cd44a74b90fbb999244c721--4b0ef2fe49c940728321600f97924687 29880706eb7f4e7da76bc6e98b6c5f8a 4b0ef2fe49c940728321600f97924687--29880706eb7f4e7da76bc6e98b6c5f8a 9056b08314d446f9a010e382ede25362 29880706eb7f4e7da76bc6e98b6c5f8a--9056b08314d446f9a010e382ede25362 8ad41cf0c8d34642967f22849a74faf6 X 9056b08314d446f9a010e382ede25362--8ad41cf0c8d34642967f22849a74faf6 8ad41cf0c8d34642967f22849a74faf6--0df3c1a9c4ed47818ff45c9175d20218 21dbeff602de43c19046e1b760e4a768 8ad41cf0c8d34642967f22849a74faf6--21dbeff602de43c19046e1b760e4a768 9d92609499b54c0384b367b23d3e18a5 21dbeff602de43c19046e1b760e4a768--9d92609499b54c0384b367b23d3e18a5 3a66c9a98c4f433ab6abed5cdb3d9ec5 9d92609499b54c0384b367b23d3e18a5--3a66c9a98c4f433ab6abed5cdb3d9ec5 e20cd0cd4e93416ab616d0ffd50ceec6 X 3a66c9a98c4f433ab6abed5cdb3d9ec5--e20cd0cd4e93416ab616d0ffd50ceec6 e20cd0cd4e93416ab616d0ffd50ceec6--26977e5040014e5b81d6e80cae3119e1 95da72917bbc44af9ef5e7c76d53debf e20cd0cd4e93416ab616d0ffd50ceec6--95da72917bbc44af9ef5e7c76d53debf 3e8c564894e845dfbe99c8f45607bb7c 95da72917bbc44af9ef5e7c76d53debf--3e8c564894e845dfbe99c8f45607bb7c 84f6cd4bd75544b58f5cf766216f6f37 3e8c564894e845dfbe99c8f45607bb7c--84f6cd4bd75544b58f5cf766216f6f37 b9ebf0cb25504270ac78c1b436609008 84f6cd4bd75544b58f5cf766216f6f37--b9ebf0cb25504270ac78c1b436609008 1abb0b2513d44dcd89e150260b4df339 X b9ebf0cb25504270ac78c1b436609008--1abb0b2513d44dcd89e150260b4df339 1abb0b2513d44dcd89e150260b4df339--760058e0c11b4f8cbdd1304af42c1a14 d6235c8a7429453aa805c876b5208a80 1abb0b2513d44dcd89e150260b4df339--d6235c8a7429453aa805c876b5208a80 46eb700ae0f44c008c35cb03e0ff279a d6235c8a7429453aa805c876b5208a80--46eb700ae0f44c008c35cb03e0ff279a b4697c0409cc4decbb68973a4ee935c9 46eb700ae0f44c008c35cb03e0ff279a--b4697c0409cc4decbb68973a4ee935c9 86660e0fb3d14fa5a98cdddb4ef5b482 b4697c0409cc4decbb68973a4ee935c9--86660e0fb3d14fa5a98cdddb4ef5b482 e155b4e97d024c78852117a72c8ab1ce 86660e0fb3d14fa5a98cdddb4ef5b482--e155b4e97d024c78852117a72c8ab1ce 72521c73572b4f03ad27bd542acf42a3 e155b4e97d024c78852117a72c8ab1ce--72521c73572b4f03ad27bd542acf42a3 7f106b854a2447f79ff4b318dfa9eb79 72521c73572b4f03ad27bd542acf42a3--7f106b854a2447f79ff4b318dfa9eb79 1a7e5cfa619a4c688685cba319c74e89 X 7f106b854a2447f79ff4b318dfa9eb79--1a7e5cfa619a4c688685cba319c74e89 1a7e5cfa619a4c688685cba319c74e89--100e4e8dc64f4b7882781c7181812584 08393f354ca141f3be0034404f6904c4 1a7e5cfa619a4c688685cba319c74e89--08393f354ca141f3be0034404f6904c4 b2fb1cc0ec1549848890989b9d6e64cf 08393f354ca141f3be0034404f6904c4--b2fb1cc0ec1549848890989b9d6e64cf a90d5796073546c38cc67d5255aa703c b2fb1cc0ec1549848890989b9d6e64cf--a90d5796073546c38cc67d5255aa703c 0f8b79e123f44108ac90772df64d2927 X a90d5796073546c38cc67d5255aa703c--0f8b79e123f44108ac90772df64d2927 0f8b79e123f44108ac90772df64d2927--e5e969bbacca4702a6fd1b5615dd88e3 aa029e0015ce4d9badaae1e56f7d4485 0f8b79e123f44108ac90772df64d2927--aa029e0015ce4d9badaae1e56f7d4485 aa3aba23229c42728333948633895d31 aa029e0015ce4d9badaae1e56f7d4485--aa3aba23229c42728333948633895d31 4bcb25817eab45ca80b41d9887043656 aa3aba23229c42728333948633895d31--4bcb25817eab45ca80b41d9887043656 af65ca23f47a446ab37aa8bbc55b0d20 X 4bcb25817eab45ca80b41d9887043656--af65ca23f47a446ab37aa8bbc55b0d20 af65ca23f47a446ab37aa8bbc55b0d20--1d36e146250c4a01bfd088139d96d663 ac51411604a24e72a0303947d659bd1f af65ca23f47a446ab37aa8bbc55b0d20--ac51411604a24e72a0303947d659bd1f 933a7dc3084045b1a6ddfd6cc167cf0b ac51411604a24e72a0303947d659bd1f--933a7dc3084045b1a6ddfd6cc167cf0b c35c706cc074412fa5fffd13c5945f6c X 933a7dc3084045b1a6ddfd6cc167cf0b--c35c706cc074412fa5fffd13c5945f6c c35c706cc074412fa5fffd13c5945f6c--9776d9a156c145118bb6d19e192a3c94 cefd95b299cc4801875e6cea0b5367dc c35c706cc074412fa5fffd13c5945f6c--cefd95b299cc4801875e6cea0b5367dc 756586c3d9354dc7bb427d2215bceb86 cefd95b299cc4801875e6cea0b5367dc--756586c3d9354dc7bb427d2215bceb86 5903ab0451c841ffa1f32a14ccf5b486 756586c3d9354dc7bb427d2215bceb86--5903ab0451c841ffa1f32a14ccf5b486 0e3c1fa0cd7248f0af065b049b778b5e 5903ab0451c841ffa1f32a14ccf5b486--0e3c1fa0cd7248f0af065b049b778b5e 143149072af14dda83b189bd226cf3c9 0e3c1fa0cd7248f0af065b049b778b5e--143149072af14dda83b189bd226cf3c9 542448dce03d4497a27f2dcd1c8762f7 X 143149072af14dda83b189bd226cf3c9--542448dce03d4497a27f2dcd1c8762f7 542448dce03d4497a27f2dcd1c8762f7--645f7639b3d44eb383cba6295f63bf9e 3e514a1f48ba4b4b8e681ffa287cf73c 542448dce03d4497a27f2dcd1c8762f7--3e514a1f48ba4b4b8e681ffa287cf73c f79dbed00faf43c3a4ab93f71bc1116f 3e514a1f48ba4b4b8e681ffa287cf73c--f79dbed00faf43c3a4ab93f71bc1116f 3926358e47444d50a6cc3b438e1cd5b9 X f79dbed00faf43c3a4ab93f71bc1116f--3926358e47444d50a6cc3b438e1cd5b9 3926358e47444d50a6cc3b438e1cd5b9--1efa31ae06c44b09966b2ba23e3545d4 1875d9644d134b7cb3e3c087e4ced0ae 3926358e47444d50a6cc3b438e1cd5b9--1875d9644d134b7cb3e3c087e4ced0ae 38bbfdddfe8846dcb8e7ad76b74ee06b 1875d9644d134b7cb3e3c087e4ced0ae--38bbfdddfe8846dcb8e7ad76b74ee06b 664e47403a1e44f995a3336b6d0e12d4 38bbfdddfe8846dcb8e7ad76b74ee06b--664e47403a1e44f995a3336b6d0e12d4 b209cfa9cc3e40b286a732ec101bb4da 664e47403a1e44f995a3336b6d0e12d4--b209cfa9cc3e40b286a732ec101bb4da 047d0a5f3c0e4685a376f82c05a6bac0 b209cfa9cc3e40b286a732ec101bb4da--047d0a5f3c0e4685a376f82c05a6bac0 d90e01d39240490f91ca98da2d2bc5c3 047d0a5f3c0e4685a376f82c05a6bac0--d90e01d39240490f91ca98da2d2bc5c3 10bf967cde55437292837343ae326cf7 d90e01d39240490f91ca98da2d2bc5c3--10bf967cde55437292837343ae326cf7 6151f03b3ffb46b3a4ca087e906dfd0a X 10bf967cde55437292837343ae326cf7--6151f03b3ffb46b3a4ca087e906dfd0a 6151f03b3ffb46b3a4ca087e906dfd0a--7d3738e1cb9446af8306a52098f8a8bf daa86a6f4dc444deaaf419827391cdbb 6151f03b3ffb46b3a4ca087e906dfd0a--daa86a6f4dc444deaaf419827391cdbb 6a197556741e41678e262f2296a41e71 X daa86a6f4dc444deaaf419827391cdbb--6a197556741e41678e262f2296a41e71 6a197556741e41678e262f2296a41e71--8bc34d31eae9434bb89a91a2b1bd5bab 5a079093764347e8839c1764eeda3395 6a197556741e41678e262f2296a41e71--5a079093764347e8839c1764eeda3395 c32151ada9e04060995937e205cc934b 5a079093764347e8839c1764eeda3395--c32151ada9e04060995937e205cc934b 00aef1467cfb4534b4f66c516e7ece3d c32151ada9e04060995937e205cc934b--00aef1467cfb4534b4f66c516e7ece3d 6411b102e230472b83cec22a7c7daec4 X 00aef1467cfb4534b4f66c516e7ece3d--6411b102e230472b83cec22a7c7daec4 6411b102e230472b83cec22a7c7daec4--b5791c40f60443e2a0f958f5f2fbabc7 1321d9ef69fe4139b058c0752e242c3d X 6411b102e230472b83cec22a7c7daec4--1321d9ef69fe4139b058c0752e242c3d 1321d9ef69fe4139b058c0752e242c3d--616b0c62052d46a9ab216660f49d3093 f71e246e780041678662a71e6c071842 1321d9ef69fe4139b058c0752e242c3d--f71e246e780041678662a71e6c071842 95e1782503d4490d93230a9bcda584a4 f71e246e780041678662a71e6c071842--95e1782503d4490d93230a9bcda584a4 a511fd9eaf5d4f639a1680dd051d70a5 95e1782503d4490d93230a9bcda584a4--a511fd9eaf5d4f639a1680dd051d70a5 15037bf8b68d4149bd9f821d1685eb89 a511fd9eaf5d4f639a1680dd051d70a5--15037bf8b68d4149bd9f821d1685eb89 57280d6a0bb24635a8a39b76e514a920 15037bf8b68d4149bd9f821d1685eb89--57280d6a0bb24635a8a39b76e514a920 eec62813392f4c71858db759adee7ac9 57280d6a0bb24635a8a39b76e514a920--eec62813392f4c71858db759adee7ac9 ad5cfadea3c0458e8b5afade10490204 eec62813392f4c71858db759adee7ac9--ad5cfadea3c0458e8b5afade10490204 2d46d0235a784c3da25f914ea9a65224 X ad5cfadea3c0458e8b5afade10490204--2d46d0235a784c3da25f914ea9a65224 2d46d0235a784c3da25f914ea9a65224--dfe3b3bb30394446a695b755eb7f3647 d96ec7e4fd6c4ae5a4b7a13af70e7eab 2d46d0235a784c3da25f914ea9a65224--d96ec7e4fd6c4ae5a4b7a13af70e7eab 9e98897e168042679573ea74f87a9c0d d96ec7e4fd6c4ae5a4b7a13af70e7eab--9e98897e168042679573ea74f87a9c0d 5c8691b2cb27404493d1ba426c8ce0e8 9e98897e168042679573ea74f87a9c0d--5c8691b2cb27404493d1ba426c8ce0e8 58238da15f424d73b2fe306d26c6fb6a 5c8691b2cb27404493d1ba426c8ce0e8--58238da15f424d73b2fe306d26c6fb6a 1aca57158bbc409da0bac5baf0873a1e 58238da15f424d73b2fe306d26c6fb6a--1aca57158bbc409da0bac5baf0873a1e 7395208b0ba84099b0268b35b9465c76 1aca57158bbc409da0bac5baf0873a1e--7395208b0ba84099b0268b35b9465c76 d08db7d230a94a0b9dca428fe7c1def6 7395208b0ba84099b0268b35b9465c76--d08db7d230a94a0b9dca428fe7c1def6 1457edef690d4eeb88ba28b656019531 d08db7d230a94a0b9dca428fe7c1def6--1457edef690d4eeb88ba28b656019531 d1ce8079a17d440a901b3c8d711297e0 1457edef690d4eeb88ba28b656019531--d1ce8079a17d440a901b3c8d711297e0 f207987af5794eb5862ca004b060ab13 d1ce8079a17d440a901b3c8d711297e0--f207987af5794eb5862ca004b060ab13 625e77701bc74904b1504cd16c230cc0 f207987af5794eb5862ca004b060ab13--625e77701bc74904b1504cd16c230cc0 26a00c9f33794bfcb824df4f38b26f25 625e77701bc74904b1504cd16c230cc0--26a00c9f33794bfcb824df4f38b26f25 712b3f74d8144140a59e06569365e1f5 26a00c9f33794bfcb824df4f38b26f25--712b3f74d8144140a59e06569365e1f5 c55bfae71e554d749d828e3530cae802 712b3f74d8144140a59e06569365e1f5--c55bfae71e554d749d828e3530cae802 15652b2cfac542ebb251b8a5b8b2d65a c55bfae71e554d749d828e3530cae802--15652b2cfac542ebb251b8a5b8b2d65a a1b712276aa74030a3c168f28be2b779 15652b2cfac542ebb251b8a5b8b2d65a--a1b712276aa74030a3c168f28be2b779 9c158cb8cae745b7a51d70797298ba22 a1b712276aa74030a3c168f28be2b779--9c158cb8cae745b7a51d70797298ba22 7259fa257dd144c483b7f3f8fac9e5b3 9c158cb8cae745b7a51d70797298ba22--7259fa257dd144c483b7f3f8fac9e5b3 aa47e1ffc5bc40dcba565b80f9108558 7259fa257dd144c483b7f3f8fac9e5b3--aa47e1ffc5bc40dcba565b80f9108558 a9634b62c9744a87bbc411069c3a96a1 aa47e1ffc5bc40dcba565b80f9108558--a9634b62c9744a87bbc411069c3a96a1 a8bb70c5dfd54c27a31dbaeb73aeb6c5 a9634b62c9744a87bbc411069c3a96a1--a8bb70c5dfd54c27a31dbaeb73aeb6c5 e182ad478107409daffaadad0eced54e a8bb70c5dfd54c27a31dbaeb73aeb6c5--e182ad478107409daffaadad0eced54e e20f8070524b4958bebab628adeba41b e182ad478107409daffaadad0eced54e--e20f8070524b4958bebab628adeba41b 5a7665bf98574f0e91c9c9db2c0bc685 RX(b14) e20f8070524b4958bebab628adeba41b--5a7665bf98574f0e91c9c9db2c0bc685 5a7665bf98574f0e91c9c9db2c0bc685--278385aabf4d452e8237c7b411c3f89e e5959ee6ec3f4aa5a065ba1066d67f14 b821d698dd7941fdb334fa14e788701a 500a11f8eef34b6eb5fc5fa5e87e4090--b821d698dd7941fdb334fa14e788701a 7c5efbbd2c534b96a489df883f51c485 6 0e6ae031cbed478e871b32cb75419dca b821d698dd7941fdb334fa14e788701a--0e6ae031cbed478e871b32cb75419dca c6a87b9a6b0542e9b0d9fc6bff66f217 0e6ae031cbed478e871b32cb75419dca--c6a87b9a6b0542e9b0d9fc6bff66f217 ffd5bae91be940c9ba7914ffaa2ef5a5 c6a87b9a6b0542e9b0d9fc6bff66f217--ffd5bae91be940c9ba7914ffaa2ef5a5 d627dfef45824f8aa5fe9385f25bad93 X ffd5bae91be940c9ba7914ffaa2ef5a5--d627dfef45824f8aa5fe9385f25bad93 d627dfef45824f8aa5fe9385f25bad93--cdd06fdfb394494caaa9357467653cbc 56ebb62f0736499fa082cb04d9b6ab3e d627dfef45824f8aa5fe9385f25bad93--56ebb62f0736499fa082cb04d9b6ab3e 3fb9fe2387a6424c94c3701553e43c4d 56ebb62f0736499fa082cb04d9b6ab3e--3fb9fe2387a6424c94c3701553e43c4d df314a74ee804ee4abb613b058ee5c19 3fb9fe2387a6424c94c3701553e43c4d--df314a74ee804ee4abb613b058ee5c19 13f10a8e18a9428892fb7e43963a36ca df314a74ee804ee4abb613b058ee5c19--13f10a8e18a9428892fb7e43963a36ca 3c83baa4d7cd4c3c8e66693622f13952 13f10a8e18a9428892fb7e43963a36ca--3c83baa4d7cd4c3c8e66693622f13952 4bb81159e0df4ff4926fbd1c2be5e0ec X 3c83baa4d7cd4c3c8e66693622f13952--4bb81159e0df4ff4926fbd1c2be5e0ec 4bb81159e0df4ff4926fbd1c2be5e0ec--deab1bf2f9484e629bde6418fb994a2f 1dd66f26a81b4e9781fd76c9023dbd72 4bb81159e0df4ff4926fbd1c2be5e0ec--1dd66f26a81b4e9781fd76c9023dbd72 520298b42dee47fe9aa287565590765a 1dd66f26a81b4e9781fd76c9023dbd72--520298b42dee47fe9aa287565590765a e0562bcc8eca4e908bc22fb6988ccf7e 520298b42dee47fe9aa287565590765a--e0562bcc8eca4e908bc22fb6988ccf7e e3af3984747746ffad97c707e265140c e0562bcc8eca4e908bc22fb6988ccf7e--e3af3984747746ffad97c707e265140c 97355fa4333e4f2490e8e124198f3d12 e3af3984747746ffad97c707e265140c--97355fa4333e4f2490e8e124198f3d12 8940660f29564115b741ef5d33aa4a81 97355fa4333e4f2490e8e124198f3d12--8940660f29564115b741ef5d33aa4a81 5dd50d4e7ed141fd91526733513af449 8940660f29564115b741ef5d33aa4a81--5dd50d4e7ed141fd91526733513af449 9e93170070fe480ca8fc68bfdb59c665 5dd50d4e7ed141fd91526733513af449--9e93170070fe480ca8fc68bfdb59c665 ef7ce22e851e411ea26b279d12d6262c 9e93170070fe480ca8fc68bfdb59c665--ef7ce22e851e411ea26b279d12d6262c e04741d007d7406aa271f2162e42bbea ef7ce22e851e411ea26b279d12d6262c--e04741d007d7406aa271f2162e42bbea 40824a4262ec4603b91a6399dbdd014b e04741d007d7406aa271f2162e42bbea--40824a4262ec4603b91a6399dbdd014b 7f0613f8f9a7400f8bc509724b4c91dd 40824a4262ec4603b91a6399dbdd014b--7f0613f8f9a7400f8bc509724b4c91dd 6811c07aca6d4283af6e2fd1b3940732 7f0613f8f9a7400f8bc509724b4c91dd--6811c07aca6d4283af6e2fd1b3940732 f91b04160b10451dacd06412286b7f2f 6811c07aca6d4283af6e2fd1b3940732--f91b04160b10451dacd06412286b7f2f 7dcf4c2149f149ebab744c2139b52771 f91b04160b10451dacd06412286b7f2f--7dcf4c2149f149ebab744c2139b52771 8cece849d5744708b31d3f1fb1370e31 7dcf4c2149f149ebab744c2139b52771--8cece849d5744708b31d3f1fb1370e31 d66355fe8b4d4581bd011618a7b4b5ed 8cece849d5744708b31d3f1fb1370e31--d66355fe8b4d4581bd011618a7b4b5ed 9ae2eba592c443569acbd85d02b15149 d66355fe8b4d4581bd011618a7b4b5ed--9ae2eba592c443569acbd85d02b15149 c38cff18322c445192e7b37fd1ca4164 9ae2eba592c443569acbd85d02b15149--c38cff18322c445192e7b37fd1ca4164 75392d13914d46edb284e43e6fec6f56 c38cff18322c445192e7b37fd1ca4164--75392d13914d46edb284e43e6fec6f56 f4af5d8a4aac42f5a57f1fa741780797 X 75392d13914d46edb284e43e6fec6f56--f4af5d8a4aac42f5a57f1fa741780797 f4af5d8a4aac42f5a57f1fa741780797--e007e950a1c94de3906360e309c29a38 35490db9a22645d091a3bf5503a8ead9 f4af5d8a4aac42f5a57f1fa741780797--35490db9a22645d091a3bf5503a8ead9 549d7cfa05bd4d7ba4ea582e9b6ae3a2 35490db9a22645d091a3bf5503a8ead9--549d7cfa05bd4d7ba4ea582e9b6ae3a2 971664034b7f45f8ae90db7cfa749b56 549d7cfa05bd4d7ba4ea582e9b6ae3a2--971664034b7f45f8ae90db7cfa749b56 4677fd3159fb4eb4a2c085cc0e960d12 X 971664034b7f45f8ae90db7cfa749b56--4677fd3159fb4eb4a2c085cc0e960d12 4677fd3159fb4eb4a2c085cc0e960d12--1ce5cb5d423349a7acc897a1b11e61e5 4cfed272e596413fa2863a39e7d91ba9 4677fd3159fb4eb4a2c085cc0e960d12--4cfed272e596413fa2863a39e7d91ba9 ed4d1580fb794d55b426985bf30d83f7 4cfed272e596413fa2863a39e7d91ba9--ed4d1580fb794d55b426985bf30d83f7 4536adef462a4908942e55759085efc2 ed4d1580fb794d55b426985bf30d83f7--4536adef462a4908942e55759085efc2 22ab5e8850944521b04ad94bb4b35be4 4536adef462a4908942e55759085efc2--22ab5e8850944521b04ad94bb4b35be4 5bcaf6aa8fd64108a725d026db87e65d 22ab5e8850944521b04ad94bb4b35be4--5bcaf6aa8fd64108a725d026db87e65d 919f8e0f17a64bfba55a34a955d8d5e0 5bcaf6aa8fd64108a725d026db87e65d--919f8e0f17a64bfba55a34a955d8d5e0 268cbf14eef64fb99f9cb7c37f91bd43 919f8e0f17a64bfba55a34a955d8d5e0--268cbf14eef64fb99f9cb7c37f91bd43 8f255a705eaa48d09680720f25dd3194 268cbf14eef64fb99f9cb7c37f91bd43--8f255a705eaa48d09680720f25dd3194 e79769665b834f3d99a79e3d0b29855e 8f255a705eaa48d09680720f25dd3194--e79769665b834f3d99a79e3d0b29855e c579fa4ad4cf412bb90ef05e678ca649 e79769665b834f3d99a79e3d0b29855e--c579fa4ad4cf412bb90ef05e678ca649 3752016559ae4c26b4a80081e263617d X c579fa4ad4cf412bb90ef05e678ca649--3752016559ae4c26b4a80081e263617d 3752016559ae4c26b4a80081e263617d--594b59e7a5304d8793c42455c5002532 ddf7a2f161fe4424bca18d565688a9ef RZ(-1.0*g0) 3752016559ae4c26b4a80081e263617d--ddf7a2f161fe4424bca18d565688a9ef c68fbb6a43024f0b93938d9b0eab79e6 X ddf7a2f161fe4424bca18d565688a9ef--c68fbb6a43024f0b93938d9b0eab79e6 c68fbb6a43024f0b93938d9b0eab79e6--829d0ffbfb0c4fc1b829c923b59429be 6225fc1f4a8e4e1192eb4628473e7bf8 c68fbb6a43024f0b93938d9b0eab79e6--6225fc1f4a8e4e1192eb4628473e7bf8 1750e8224a4f417bbc3dcda982890050 6225fc1f4a8e4e1192eb4628473e7bf8--1750e8224a4f417bbc3dcda982890050 8eb859e3f0344dfbb640e8657dc2968b 1750e8224a4f417bbc3dcda982890050--8eb859e3f0344dfbb640e8657dc2968b 5aade8d737224651a3e7ffb0f13627c8 8eb859e3f0344dfbb640e8657dc2968b--5aade8d737224651a3e7ffb0f13627c8 23ad7bdd2d24455fbcd19342048d4f9c 5aade8d737224651a3e7ffb0f13627c8--23ad7bdd2d24455fbcd19342048d4f9c 7ef6bde048a44fc7bdf248b16c13fa21 23ad7bdd2d24455fbcd19342048d4f9c--7ef6bde048a44fc7bdf248b16c13fa21 5f9ada1fc8704cf0a50218665d316363 X 7ef6bde048a44fc7bdf248b16c13fa21--5f9ada1fc8704cf0a50218665d316363 5f9ada1fc8704cf0a50218665d316363--75c15ae131f7493fbf3628938db39c30 30f733fe85d04f44957f9d6a7787fcde 5f9ada1fc8704cf0a50218665d316363--30f733fe85d04f44957f9d6a7787fcde 01ad457052d845b5857e9eb734586080 30f733fe85d04f44957f9d6a7787fcde--01ad457052d845b5857e9eb734586080 13f12f5f2876478eb247202e5b2d490d 01ad457052d845b5857e9eb734586080--13f12f5f2876478eb247202e5b2d490d 380ecfd2aa56426e98c4e2cdfcb0f034 13f12f5f2876478eb247202e5b2d490d--380ecfd2aa56426e98c4e2cdfcb0f034 560c4537f2e547bc9e1dd63477bb815f 380ecfd2aa56426e98c4e2cdfcb0f034--560c4537f2e547bc9e1dd63477bb815f c07094b186ae47c7a8c1dbfff8245a98 X 560c4537f2e547bc9e1dd63477bb815f--c07094b186ae47c7a8c1dbfff8245a98 c07094b186ae47c7a8c1dbfff8245a98--7e595c24659f48a9b6f69a9909cf6ba5 7c3ce8503ace4949a0c285cbe1290b6a c07094b186ae47c7a8c1dbfff8245a98--7c3ce8503ace4949a0c285cbe1290b6a 96d8001141ad41c6a547ce854de81078 7c3ce8503ace4949a0c285cbe1290b6a--96d8001141ad41c6a547ce854de81078 06dcb48c2c3f42ebb677edaf1cc84a8d 96d8001141ad41c6a547ce854de81078--06dcb48c2c3f42ebb677edaf1cc84a8d 186b071ab6114b7e9067eeb0e5f2e303 06dcb48c2c3f42ebb677edaf1cc84a8d--186b071ab6114b7e9067eeb0e5f2e303 132814f59f52425e8bdfa241614c97f8 186b071ab6114b7e9067eeb0e5f2e303--132814f59f52425e8bdfa241614c97f8 b12616939322482583e56610ffa77a51 X 132814f59f52425e8bdfa241614c97f8--b12616939322482583e56610ffa77a51 b12616939322482583e56610ffa77a51--ed7307af7a1a48d5ba510d527d538cad 64985d30d0bf4a888fed8bff053b264e RZ(-1.0*g0) b12616939322482583e56610ffa77a51--64985d30d0bf4a888fed8bff053b264e b801cbda6aba4c61bb79926c87f9630c X 64985d30d0bf4a888fed8bff053b264e--b801cbda6aba4c61bb79926c87f9630c b801cbda6aba4c61bb79926c87f9630c--88764bbc5eab4d1aa68571cd753c4f75 d5c25d81fb754f9188ea62d13a60a5c6 b801cbda6aba4c61bb79926c87f9630c--d5c25d81fb754f9188ea62d13a60a5c6 2273586bb1894162a7a5e781f5d1b45c d5c25d81fb754f9188ea62d13a60a5c6--2273586bb1894162a7a5e781f5d1b45c 0fbd192408454690955365ce315644df 2273586bb1894162a7a5e781f5d1b45c--0fbd192408454690955365ce315644df 8e84ec759e2144708ea4d20d7337b275 0fbd192408454690955365ce315644df--8e84ec759e2144708ea4d20d7337b275 4ac895e4a20b47108ffe8bd1f46c8ef3 X 8e84ec759e2144708ea4d20d7337b275--4ac895e4a20b47108ffe8bd1f46c8ef3 4ac895e4a20b47108ffe8bd1f46c8ef3--3ff428ea9d52439c9f43206d6e860d1d 5bc9dd3bad8643078903195e24d77653 4ac895e4a20b47108ffe8bd1f46c8ef3--5bc9dd3bad8643078903195e24d77653 e1b72d3f63224a3bad0797ce163fd357 5bc9dd3bad8643078903195e24d77653--e1b72d3f63224a3bad0797ce163fd357 6e0b633b3e0b42ec8f3195a52232662d e1b72d3f63224a3bad0797ce163fd357--6e0b633b3e0b42ec8f3195a52232662d ac9efb39ee744d4c863dca7664bf3284 X 6e0b633b3e0b42ec8f3195a52232662d--ac9efb39ee744d4c863dca7664bf3284 ac9efb39ee744d4c863dca7664bf3284--33a49f8c08bf4736afd151e13ed50800 faee42babc52403a85582530fec5b39a ac9efb39ee744d4c863dca7664bf3284--faee42babc52403a85582530fec5b39a ec3dbf04e4e44aeabf8d0b3000272d03 faee42babc52403a85582530fec5b39a--ec3dbf04e4e44aeabf8d0b3000272d03 4e8527988d9f454c88c01868fe562668 ec3dbf04e4e44aeabf8d0b3000272d03--4e8527988d9f454c88c01868fe562668 760381b3e8e4477db6bfe08ac44e1b28 4e8527988d9f454c88c01868fe562668--760381b3e8e4477db6bfe08ac44e1b28 ba64124e442f43cfa8714f8bf24c0679 X 760381b3e8e4477db6bfe08ac44e1b28--ba64124e442f43cfa8714f8bf24c0679 ba64124e442f43cfa8714f8bf24c0679--ae1511db5bde4159a09cb45f36b09ba9 b0a0ffa320e148adb91bd1d076e32e82 ba64124e442f43cfa8714f8bf24c0679--b0a0ffa320e148adb91bd1d076e32e82 52ff623700ac4be1a3f903a4089ace28 b0a0ffa320e148adb91bd1d076e32e82--52ff623700ac4be1a3f903a4089ace28 a1c32603aa70404c91ff3efc9eb0ac01 52ff623700ac4be1a3f903a4089ace28--a1c32603aa70404c91ff3efc9eb0ac01 ee51fbbf30aa4dfeb44e67fbfa3b6082 a1c32603aa70404c91ff3efc9eb0ac01--ee51fbbf30aa4dfeb44e67fbfa3b6082 990a8ff7b9e443b5ab49d7257b919817 ee51fbbf30aa4dfeb44e67fbfa3b6082--990a8ff7b9e443b5ab49d7257b919817 f8824111a2e44f34b238d291c129ecee X 990a8ff7b9e443b5ab49d7257b919817--f8824111a2e44f34b238d291c129ecee f8824111a2e44f34b238d291c129ecee--509cc40f3eb04a2586c12817786960d9 bb9e854993ff44f892e7d5e08091e26b f8824111a2e44f34b238d291c129ecee--bb9e854993ff44f892e7d5e08091e26b 846ca52ced574f35910c41050198c526 bb9e854993ff44f892e7d5e08091e26b--846ca52ced574f35910c41050198c526 db022990e82e4c6c905010ca26d0c018 846ca52ced574f35910c41050198c526--db022990e82e4c6c905010ca26d0c018 8b0f508773a7422e8653ea02074a6f14 X db022990e82e4c6c905010ca26d0c018--8b0f508773a7422e8653ea02074a6f14 8b0f508773a7422e8653ea02074a6f14--3441e9fc6b904ecdb53c8b34d3e43508 f7f6f442a72e4b24aa4403f398b1ca9c RZ(-1.0*g0) 8b0f508773a7422e8653ea02074a6f14--f7f6f442a72e4b24aa4403f398b1ca9c 853a17d4b18d4e3f82406cea4a33f427 X f7f6f442a72e4b24aa4403f398b1ca9c--853a17d4b18d4e3f82406cea4a33f427 853a17d4b18d4e3f82406cea4a33f427--365f3ecf86384d06a6d29abb0bf55ca5 57374483c6684fbfb10676ec047d701f 853a17d4b18d4e3f82406cea4a33f427--57374483c6684fbfb10676ec047d701f d66f76787ff741bcb868dc96dd15084d 57374483c6684fbfb10676ec047d701f--d66f76787ff741bcb868dc96dd15084d 70ab837cdcf6492ea88225bae56a52fd X d66f76787ff741bcb868dc96dd15084d--70ab837cdcf6492ea88225bae56a52fd 70ab837cdcf6492ea88225bae56a52fd--717f5dc6265a45d9b99e7c3643871e24 7ef9782ded6444a3af1c622b50223b2d 70ab837cdcf6492ea88225bae56a52fd--7ef9782ded6444a3af1c622b50223b2d 7c2346e5250d4503af6816020d7c34a9 7ef9782ded6444a3af1c622b50223b2d--7c2346e5250d4503af6816020d7c34a9 7bd15ea51f7c4bd3ad6cb146e6de8e98 7c2346e5250d4503af6816020d7c34a9--7bd15ea51f7c4bd3ad6cb146e6de8e98 69b68ac5ede542f0bb1e531a2f8380f1 7bd15ea51f7c4bd3ad6cb146e6de8e98--69b68ac5ede542f0bb1e531a2f8380f1 72e38d010c0f4ebfa9a27eff0e58603f 69b68ac5ede542f0bb1e531a2f8380f1--72e38d010c0f4ebfa9a27eff0e58603f 91f42b69a756481e974c88ad79f8a421 X 72e38d010c0f4ebfa9a27eff0e58603f--91f42b69a756481e974c88ad79f8a421 91f42b69a756481e974c88ad79f8a421--a60673e5907e441a84798f4df027c282 1e95671e4fe14ee4bfd7d453dd695695 91f42b69a756481e974c88ad79f8a421--1e95671e4fe14ee4bfd7d453dd695695 118db7cf2cee4dd2a634b07b0e9fc7ff X 1e95671e4fe14ee4bfd7d453dd695695--118db7cf2cee4dd2a634b07b0e9fc7ff 118db7cf2cee4dd2a634b07b0e9fc7ff--013fc85077fb407eac9606e3f3313f5e 7caf67fccfe04e038eda8a9631ac756d RZ(-1.0*g0) 118db7cf2cee4dd2a634b07b0e9fc7ff--7caf67fccfe04e038eda8a9631ac756d 23dc620f1ef842d99f2c1f6772beb58d X 7caf67fccfe04e038eda8a9631ac756d--23dc620f1ef842d99f2c1f6772beb58d 23dc620f1ef842d99f2c1f6772beb58d--b51aec70653a4af7bf290fca8eb5fca0 24e539fd09f14e8a843fe4f04c57ef13 X 23dc620f1ef842d99f2c1f6772beb58d--24e539fd09f14e8a843fe4f04c57ef13 24e539fd09f14e8a843fe4f04c57ef13--8b96c2a872f741f2b07b45d67d7c436f 6f6b8cb3c8324a38b386a8db1cb11f93 24e539fd09f14e8a843fe4f04c57ef13--6f6b8cb3c8324a38b386a8db1cb11f93 099845b9419f4481b1dcbf079e2f8165 6f6b8cb3c8324a38b386a8db1cb11f93--099845b9419f4481b1dcbf079e2f8165 6c6d6c8e8cd84311b39517038f4728e4 099845b9419f4481b1dcbf079e2f8165--6c6d6c8e8cd84311b39517038f4728e4 c23189d70e624001b2fb7b8fb170d0a4 X 6c6d6c8e8cd84311b39517038f4728e4--c23189d70e624001b2fb7b8fb170d0a4 c23189d70e624001b2fb7b8fb170d0a4--1fe689ba14b64046aca4c3dec5af4ed8 007b747c454540678217a19c2c941383 X c23189d70e624001b2fb7b8fb170d0a4--007b747c454540678217a19c2c941383 007b747c454540678217a19c2c941383--a8bc949b3b54420c9fce3d578bea4139 43758eb29d0647b6a6cddff1cc9293b1 007b747c454540678217a19c2c941383--43758eb29d0647b6a6cddff1cc9293b1 9ce2c6d189ed41a2a9335571eb26498e 43758eb29d0647b6a6cddff1cc9293b1--9ce2c6d189ed41a2a9335571eb26498e 2893dbf1f9214d7f8a3c15e8268edb30 9ce2c6d189ed41a2a9335571eb26498e--2893dbf1f9214d7f8a3c15e8268edb30 5a7775a2f9de4cff9a49640a9b5314a1 2893dbf1f9214d7f8a3c15e8268edb30--5a7775a2f9de4cff9a49640a9b5314a1 e6282e5333bc4589ae8f96bc11449f25 5a7775a2f9de4cff9a49640a9b5314a1--e6282e5333bc4589ae8f96bc11449f25 a1f63d3df0f84244a13807d8ff3780b2 X e6282e5333bc4589ae8f96bc11449f25--a1f63d3df0f84244a13807d8ff3780b2 a1f63d3df0f84244a13807d8ff3780b2--65e585a773764eeea13968611ef16de2 a2b32f7af08748289b3760bae1caa7b2 a1f63d3df0f84244a13807d8ff3780b2--a2b32f7af08748289b3760bae1caa7b2 c63f599169ec4e4ab2e2b020f8cd1132 a2b32f7af08748289b3760bae1caa7b2--c63f599169ec4e4ab2e2b020f8cd1132 15695d5cde1e47668d897a42ddd36a61 c63f599169ec4e4ab2e2b020f8cd1132--15695d5cde1e47668d897a42ddd36a61 627fb1eca4f64b799965786218a57d12 15695d5cde1e47668d897a42ddd36a61--627fb1eca4f64b799965786218a57d12 f1db60eff5864fa898525541f621f268 627fb1eca4f64b799965786218a57d12--f1db60eff5864fa898525541f621f268 03dba87f7a0c4ba583b8d8b9cac838f5 f1db60eff5864fa898525541f621f268--03dba87f7a0c4ba583b8d8b9cac838f5 1ad20b789736489ba07e7b7c4bd6c51c 03dba87f7a0c4ba583b8d8b9cac838f5--1ad20b789736489ba07e7b7c4bd6c51c 7503ba4b0e7e4285a7301a3477b864d5 1ad20b789736489ba07e7b7c4bd6c51c--7503ba4b0e7e4285a7301a3477b864d5 8697f0d2ce404a30ae33884ed419f159 RX(b05) 7503ba4b0e7e4285a7301a3477b864d5--8697f0d2ce404a30ae33884ed419f159 0af7bb04925849d5bc3e5e74418df993 8697f0d2ce404a30ae33884ed419f159--0af7bb04925849d5bc3e5e74418df993 1ba1fd0e13ca4dbbb3bb583ab68844ca 0af7bb04925849d5bc3e5e74418df993--1ba1fd0e13ca4dbbb3bb583ab68844ca 08e2a4baef9341369a7d2f35acd23a0e 1ba1fd0e13ca4dbbb3bb583ab68844ca--08e2a4baef9341369a7d2f35acd23a0e dcb17a57a9324ea18f08567e6d7a81b0 08e2a4baef9341369a7d2f35acd23a0e--dcb17a57a9324ea18f08567e6d7a81b0 6463838aad464800be46f5f0d46db6c2 X dcb17a57a9324ea18f08567e6d7a81b0--6463838aad464800be46f5f0d46db6c2 6463838aad464800be46f5f0d46db6c2--f5f1640a5a34449aa906d87437efe5a8 eed43c8d9a7244e48d6a84960b9b4f2e 6463838aad464800be46f5f0d46db6c2--eed43c8d9a7244e48d6a84960b9b4f2e 28a0860d7c95408e90dc41a6e7765775 eed43c8d9a7244e48d6a84960b9b4f2e--28a0860d7c95408e90dc41a6e7765775 9c87289df325460d9f6a07c9a6255db1 28a0860d7c95408e90dc41a6e7765775--9c87289df325460d9f6a07c9a6255db1 969dc1724f764264a3293ee26f8d8b97 9c87289df325460d9f6a07c9a6255db1--969dc1724f764264a3293ee26f8d8b97 144b26a70eae419895438dd1f15b1519 969dc1724f764264a3293ee26f8d8b97--144b26a70eae419895438dd1f15b1519 3e1d60bfaa094b85ace8648326352470 X 144b26a70eae419895438dd1f15b1519--3e1d60bfaa094b85ace8648326352470 3e1d60bfaa094b85ace8648326352470--1286bc8d3db64a03aac4609e4e4b12c0 301297a911264855afb19dab5b378a67 3e1d60bfaa094b85ace8648326352470--301297a911264855afb19dab5b378a67 8672db41974349a69bf4a4642f1adb63 301297a911264855afb19dab5b378a67--8672db41974349a69bf4a4642f1adb63 20d084a2d87a4f5482cec408f87689ce 8672db41974349a69bf4a4642f1adb63--20d084a2d87a4f5482cec408f87689ce 5a9648fd1746474fa969dc72cc7105bb 20d084a2d87a4f5482cec408f87689ce--5a9648fd1746474fa969dc72cc7105bb 873b6c6a224d4cc99d0ab9e491795278 5a9648fd1746474fa969dc72cc7105bb--873b6c6a224d4cc99d0ab9e491795278 bf8102c3d86447159ca58ee4f59e1e30 873b6c6a224d4cc99d0ab9e491795278--bf8102c3d86447159ca58ee4f59e1e30 2394f7815222404190296678b365c4a8 bf8102c3d86447159ca58ee4f59e1e30--2394f7815222404190296678b365c4a8 a52aca2337404808b91fa6f249f18100 2394f7815222404190296678b365c4a8--a52aca2337404808b91fa6f249f18100 0959ac01902649da9b9fc20608611fa4 a52aca2337404808b91fa6f249f18100--0959ac01902649da9b9fc20608611fa4 1a5d6de4f6254f719dc2f29b0e460ab1 0959ac01902649da9b9fc20608611fa4--1a5d6de4f6254f719dc2f29b0e460ab1 fe3b461d49314fa3b512e838a2039437 1a5d6de4f6254f719dc2f29b0e460ab1--fe3b461d49314fa3b512e838a2039437 9a960ab4413f45d889cdbf0ee46dda8f fe3b461d49314fa3b512e838a2039437--9a960ab4413f45d889cdbf0ee46dda8f 263104c45e9b400e83e7df00375e8d62 9a960ab4413f45d889cdbf0ee46dda8f--263104c45e9b400e83e7df00375e8d62 af07d185171e47b49ad0f0e2a1c6ef27 263104c45e9b400e83e7df00375e8d62--af07d185171e47b49ad0f0e2a1c6ef27 09cfed106510425fb42d76b641652b8b af07d185171e47b49ad0f0e2a1c6ef27--09cfed106510425fb42d76b641652b8b c1bc21138fff4c039044109d4efadd13 09cfed106510425fb42d76b641652b8b--c1bc21138fff4c039044109d4efadd13 65e35332542d43f7b3a7ed53e0d7ead6 c1bc21138fff4c039044109d4efadd13--65e35332542d43f7b3a7ed53e0d7ead6 6d9c80c5c710483c95f50a0e23a22495 65e35332542d43f7b3a7ed53e0d7ead6--6d9c80c5c710483c95f50a0e23a22495 2b232ac39dc54a2c9e95538466f95745 6d9c80c5c710483c95f50a0e23a22495--2b232ac39dc54a2c9e95538466f95745 34489c63f5784cada2a2d03a6ea86da8 2b232ac39dc54a2c9e95538466f95745--34489c63f5784cada2a2d03a6ea86da8 88d84697b4834f17ba1a884cd7d05593 X 34489c63f5784cada2a2d03a6ea86da8--88d84697b4834f17ba1a884cd7d05593 88d84697b4834f17ba1a884cd7d05593--80115fff48704f5384669badb0717b46 b98e92a3901340ec963f4beda6aaa670 88d84697b4834f17ba1a884cd7d05593--b98e92a3901340ec963f4beda6aaa670 a00a60053be14ecb9ea28168f9f61860 b98e92a3901340ec963f4beda6aaa670--a00a60053be14ecb9ea28168f9f61860 682f8f6b702e42799afb42be09b9d663 a00a60053be14ecb9ea28168f9f61860--682f8f6b702e42799afb42be09b9d663 8d2a5d67996f4abfad7a61d42265f777 X 682f8f6b702e42799afb42be09b9d663--8d2a5d67996f4abfad7a61d42265f777 8d2a5d67996f4abfad7a61d42265f777--376827d2cb1847d28943d439b2eed1dc faf07f85619540f7b6ce45066bc7e58c 8d2a5d67996f4abfad7a61d42265f777--faf07f85619540f7b6ce45066bc7e58c 6e96342e93d141d1809347e89011b613 faf07f85619540f7b6ce45066bc7e58c--6e96342e93d141d1809347e89011b613 d607bc91db7c4c4b9fa6de04663419a4 6e96342e93d141d1809347e89011b613--d607bc91db7c4c4b9fa6de04663419a4 de2961c988ad4d3db3d317392cacffe9 d607bc91db7c4c4b9fa6de04663419a4--de2961c988ad4d3db3d317392cacffe9 49fd01663da64418b37fc587ebd977bc de2961c988ad4d3db3d317392cacffe9--49fd01663da64418b37fc587ebd977bc b91fd799e51649c88cff5a878e22e3f5 49fd01663da64418b37fc587ebd977bc--b91fd799e51649c88cff5a878e22e3f5 0cc3fb602f5644f5aa85243f2849c772 b91fd799e51649c88cff5a878e22e3f5--0cc3fb602f5644f5aa85243f2849c772 a7f3db842c264f3c92d2d9806226759e 0cc3fb602f5644f5aa85243f2849c772--a7f3db842c264f3c92d2d9806226759e 8cd44239b7a94151be299b4785922974 a7f3db842c264f3c92d2d9806226759e--8cd44239b7a94151be299b4785922974 315d2a6e3f4c4f40858866b61c870464 8cd44239b7a94151be299b4785922974--315d2a6e3f4c4f40858866b61c870464 01dfa36c841d4e48980cb10393e72f7e X 315d2a6e3f4c4f40858866b61c870464--01dfa36c841d4e48980cb10393e72f7e 01dfa36c841d4e48980cb10393e72f7e--21dbeff602de43c19046e1b760e4a768 98e7975ab8ed4db4b90694b2606e01c0 RZ(-1.0*g1) 01dfa36c841d4e48980cb10393e72f7e--98e7975ab8ed4db4b90694b2606e01c0 a54883efc42a470caa455276a5a45d83 X 98e7975ab8ed4db4b90694b2606e01c0--a54883efc42a470caa455276a5a45d83 a54883efc42a470caa455276a5a45d83--3a66c9a98c4f433ab6abed5cdb3d9ec5 762cd7fc6b5342d7a65b27958f7c159d a54883efc42a470caa455276a5a45d83--762cd7fc6b5342d7a65b27958f7c159d d1853c83b7434917a3cb3bdf0aa686af 762cd7fc6b5342d7a65b27958f7c159d--d1853c83b7434917a3cb3bdf0aa686af f53567f6c0924171a010790627b3a51f d1853c83b7434917a3cb3bdf0aa686af--f53567f6c0924171a010790627b3a51f 9864faa8234c4864bd6859879da17873 f53567f6c0924171a010790627b3a51f--9864faa8234c4864bd6859879da17873 096295edb4344569833d65663719c2f9 9864faa8234c4864bd6859879da17873--096295edb4344569833d65663719c2f9 1a4f081054304d9c8672a88a7eb588e4 096295edb4344569833d65663719c2f9--1a4f081054304d9c8672a88a7eb588e4 9f1be803076a407d9128a2b60b33ca35 X 1a4f081054304d9c8672a88a7eb588e4--9f1be803076a407d9128a2b60b33ca35 9f1be803076a407d9128a2b60b33ca35--d6235c8a7429453aa805c876b5208a80 deb722c95285492fb0565b012a9d6e7b 9f1be803076a407d9128a2b60b33ca35--deb722c95285492fb0565b012a9d6e7b cd0f01080bb042079edc9b38301531f9 deb722c95285492fb0565b012a9d6e7b--cd0f01080bb042079edc9b38301531f9 c10f3b4a2e9c40c2856510670e188a3b cd0f01080bb042079edc9b38301531f9--c10f3b4a2e9c40c2856510670e188a3b 2f6299c69eaf42e492a89f1249f5f778 c10f3b4a2e9c40c2856510670e188a3b--2f6299c69eaf42e492a89f1249f5f778 ef8a81b903564c228dfa315035c8627c 2f6299c69eaf42e492a89f1249f5f778--ef8a81b903564c228dfa315035c8627c 01edb90460614ecdbc57b98d2f5f63ba X ef8a81b903564c228dfa315035c8627c--01edb90460614ecdbc57b98d2f5f63ba 01edb90460614ecdbc57b98d2f5f63ba--7f106b854a2447f79ff4b318dfa9eb79 1aaed14e85b34a48818f97a4086cabc8 01edb90460614ecdbc57b98d2f5f63ba--1aaed14e85b34a48818f97a4086cabc8 7f727bd6eac643e9aea238bf42d9317c 1aaed14e85b34a48818f97a4086cabc8--7f727bd6eac643e9aea238bf42d9317c 87cf65ccbf384e98b684fcc34bc975f7 7f727bd6eac643e9aea238bf42d9317c--87cf65ccbf384e98b684fcc34bc975f7 483f93d5977b47608008667db7d3dbec 87cf65ccbf384e98b684fcc34bc975f7--483f93d5977b47608008667db7d3dbec f9002814922b4ee090923ef08e4e5a82 483f93d5977b47608008667db7d3dbec--f9002814922b4ee090923ef08e4e5a82 c915c15f24954ce5bb454562e23713ce X f9002814922b4ee090923ef08e4e5a82--c915c15f24954ce5bb454562e23713ce c915c15f24954ce5bb454562e23713ce--aa029e0015ce4d9badaae1e56f7d4485 26d36af7481444baaf7ccaaf79c55578 RZ(-1.0*g1) c915c15f24954ce5bb454562e23713ce--26d36af7481444baaf7ccaaf79c55578 4be3d7ab454f41dfa0af7c72215464e1 X 26d36af7481444baaf7ccaaf79c55578--4be3d7ab454f41dfa0af7c72215464e1 4be3d7ab454f41dfa0af7c72215464e1--4bcb25817eab45ca80b41d9887043656 dc1ff78fbe4a4be4ac946ed295c53d72 4be3d7ab454f41dfa0af7c72215464e1--dc1ff78fbe4a4be4ac946ed295c53d72 2f20049a1bc643ed80ce322fbb744cc1 dc1ff78fbe4a4be4ac946ed295c53d72--2f20049a1bc643ed80ce322fbb744cc1 4ef912112605496abc49b8aed76bcb44 2f20049a1bc643ed80ce322fbb744cc1--4ef912112605496abc49b8aed76bcb44 710d8fa2796a4923835e7827989499ab 4ef912112605496abc49b8aed76bcb44--710d8fa2796a4923835e7827989499ab b9a1e7cb5b6e4b2391680933d27b31b4 X 710d8fa2796a4923835e7827989499ab--b9a1e7cb5b6e4b2391680933d27b31b4 b9a1e7cb5b6e4b2391680933d27b31b4--cefd95b299cc4801875e6cea0b5367dc 79a5bebf634340f3a50b24de2139c4ac b9a1e7cb5b6e4b2391680933d27b31b4--79a5bebf634340f3a50b24de2139c4ac 3f03ea429dac4168a32091b80619b96b 79a5bebf634340f3a50b24de2139c4ac--3f03ea429dac4168a32091b80619b96b 3f3c53b7851a4c43af499d4b78e5fc1b 3f03ea429dac4168a32091b80619b96b--3f3c53b7851a4c43af499d4b78e5fc1b bfd9bfc36c764a73b9ecb0a902ca4b86 X 3f3c53b7851a4c43af499d4b78e5fc1b--bfd9bfc36c764a73b9ecb0a902ca4b86 bfd9bfc36c764a73b9ecb0a902ca4b86--143149072af14dda83b189bd226cf3c9 65d278b8e1184518a186841fb200019c bfd9bfc36c764a73b9ecb0a902ca4b86--65d278b8e1184518a186841fb200019c df308b468a4d443d8f884aba94d9758c 65d278b8e1184518a186841fb200019c--df308b468a4d443d8f884aba94d9758c ebb0ec9d75ab4fa5a797b9bed3936030 df308b468a4d443d8f884aba94d9758c--ebb0ec9d75ab4fa5a797b9bed3936030 3ff6f080bb35497080ea335131636d63 ebb0ec9d75ab4fa5a797b9bed3936030--3ff6f080bb35497080ea335131636d63 62e2f96de9b9426899ae5cc4354b227e X 3ff6f080bb35497080ea335131636d63--62e2f96de9b9426899ae5cc4354b227e 62e2f96de9b9426899ae5cc4354b227e--1875d9644d134b7cb3e3c087e4ced0ae 685ec1dbcdb94ed592915719cc35463f 62e2f96de9b9426899ae5cc4354b227e--685ec1dbcdb94ed592915719cc35463f d51691a82009439582c40d4efcb5acd6 685ec1dbcdb94ed592915719cc35463f--d51691a82009439582c40d4efcb5acd6 b4b9f671b4c94114a7790c5c23439207 d51691a82009439582c40d4efcb5acd6--b4b9f671b4c94114a7790c5c23439207 6600d389ed83427a8014a6a5022221e7 b4b9f671b4c94114a7790c5c23439207--6600d389ed83427a8014a6a5022221e7 c744305414a0410da66c79789f9d1921 6600d389ed83427a8014a6a5022221e7--c744305414a0410da66c79789f9d1921 acbb2cf069384e4c8730eb86e179e136 X c744305414a0410da66c79789f9d1921--acbb2cf069384e4c8730eb86e179e136 acbb2cf069384e4c8730eb86e179e136--10bf967cde55437292837343ae326cf7 f990ac479a3344b3b592109980035f46 acbb2cf069384e4c8730eb86e179e136--f990ac479a3344b3b592109980035f46 72ab6d17b2bc46dc9d9d9a0ee321e2e7 f990ac479a3344b3b592109980035f46--72ab6d17b2bc46dc9d9d9a0ee321e2e7 02bec2a716e24859bf428a6336c5eeab 72ab6d17b2bc46dc9d9d9a0ee321e2e7--02bec2a716e24859bf428a6336c5eeab faf076298773468dba352df81c737bda X 02bec2a716e24859bf428a6336c5eeab--faf076298773468dba352df81c737bda faf076298773468dba352df81c737bda--5a079093764347e8839c1764eeda3395 233b98538b704985885cc015e62aee7a RZ(-1.0*g1) faf076298773468dba352df81c737bda--233b98538b704985885cc015e62aee7a 443a831b12d64029abcd1467c2d0c756 X 233b98538b704985885cc015e62aee7a--443a831b12d64029abcd1467c2d0c756 443a831b12d64029abcd1467c2d0c756--00aef1467cfb4534b4f66c516e7ece3d 17883018ccbb4af4a986bacb59166640 443a831b12d64029abcd1467c2d0c756--17883018ccbb4af4a986bacb59166640 1891d51519af48d2b741f50f0a09c1ae 17883018ccbb4af4a986bacb59166640--1891d51519af48d2b741f50f0a09c1ae f871658f4e8f4b1dbfe1bb48e6350d95 X 1891d51519af48d2b741f50f0a09c1ae--f871658f4e8f4b1dbfe1bb48e6350d95 f871658f4e8f4b1dbfe1bb48e6350d95--f71e246e780041678662a71e6c071842 faea8a18c8f346ff8cbbb588c9f951b6 f871658f4e8f4b1dbfe1bb48e6350d95--faea8a18c8f346ff8cbbb588c9f951b6 b65401d73de54bdeb28a822b0f6d28f7 faea8a18c8f346ff8cbbb588c9f951b6--b65401d73de54bdeb28a822b0f6d28f7 30eff63f72914975b90050c39ca32c1c b65401d73de54bdeb28a822b0f6d28f7--30eff63f72914975b90050c39ca32c1c f1cbec21231a4bdebe3294fab8503e41 30eff63f72914975b90050c39ca32c1c--f1cbec21231a4bdebe3294fab8503e41 1305b78e350140b1ae3032ae742c663f f1cbec21231a4bdebe3294fab8503e41--1305b78e350140b1ae3032ae742c663f 070fc1f8dcf149c2b426ab2750402e57 X 1305b78e350140b1ae3032ae742c663f--070fc1f8dcf149c2b426ab2750402e57 070fc1f8dcf149c2b426ab2750402e57--ad5cfadea3c0458e8b5afade10490204 60687afbfe3445c6a545bf32d88def61 070fc1f8dcf149c2b426ab2750402e57--60687afbfe3445c6a545bf32d88def61 73c48adccd854210b749d2cdcb1b86a4 X 60687afbfe3445c6a545bf32d88def61--73c48adccd854210b749d2cdcb1b86a4 73c48adccd854210b749d2cdcb1b86a4--d96ec7e4fd6c4ae5a4b7a13af70e7eab d83cda6d8b6a4ec19845cd95ee68df15 RZ(-1.0*g1) 73c48adccd854210b749d2cdcb1b86a4--d83cda6d8b6a4ec19845cd95ee68df15 01bebb05df33492382c6ee22a0cd3668 X d83cda6d8b6a4ec19845cd95ee68df15--01bebb05df33492382c6ee22a0cd3668 01bebb05df33492382c6ee22a0cd3668--5c8691b2cb27404493d1ba426c8ce0e8 f2746b0e827441baae06cd1bf5d75918 X 01bebb05df33492382c6ee22a0cd3668--f2746b0e827441baae06cd1bf5d75918 f2746b0e827441baae06cd1bf5d75918--58238da15f424d73b2fe306d26c6fb6a 302ab664468e4812912d952ea0626834 f2746b0e827441baae06cd1bf5d75918--302ab664468e4812912d952ea0626834 152b2c2e16f5435a8d7ab9b24c9d1320 302ab664468e4812912d952ea0626834--152b2c2e16f5435a8d7ab9b24c9d1320 bd54a7d2e25c4d19a7f54306d693b052 152b2c2e16f5435a8d7ab9b24c9d1320--bd54a7d2e25c4d19a7f54306d693b052 fc77bfd4499244baa801d8a311cd4a78 X bd54a7d2e25c4d19a7f54306d693b052--fc77bfd4499244baa801d8a311cd4a78 fc77bfd4499244baa801d8a311cd4a78--1457edef690d4eeb88ba28b656019531 368ad411ef554d2c9f5c96727ad3747e X fc77bfd4499244baa801d8a311cd4a78--368ad411ef554d2c9f5c96727ad3747e 368ad411ef554d2c9f5c96727ad3747e--d1ce8079a17d440a901b3c8d711297e0 ee5aa45fb046489784d5cde283a688c5 368ad411ef554d2c9f5c96727ad3747e--ee5aa45fb046489784d5cde283a688c5 b8b900bd8879443685cf4b57cefcdec4 ee5aa45fb046489784d5cde283a688c5--b8b900bd8879443685cf4b57cefcdec4 6f02f472e27e4b2bb3a0d0114d90d088 b8b900bd8879443685cf4b57cefcdec4--6f02f472e27e4b2bb3a0d0114d90d088 8af64bcf8f6f4983b3203b3c0f8387c5 6f02f472e27e4b2bb3a0d0114d90d088--8af64bcf8f6f4983b3203b3c0f8387c5 9adb7d7eb3db40ee80b5babcc5f0d2e8 8af64bcf8f6f4983b3203b3c0f8387c5--9adb7d7eb3db40ee80b5babcc5f0d2e8 ee2e48f7f5ba4b1b9ee65fb2e9dd2f4e X 9adb7d7eb3db40ee80b5babcc5f0d2e8--ee2e48f7f5ba4b1b9ee65fb2e9dd2f4e ee2e48f7f5ba4b1b9ee65fb2e9dd2f4e--15652b2cfac542ebb251b8a5b8b2d65a cd7e5118e6814844818cff67d0ed047c ee2e48f7f5ba4b1b9ee65fb2e9dd2f4e--cd7e5118e6814844818cff67d0ed047c fe6fefb5011f449793b6d692b534a17d cd7e5118e6814844818cff67d0ed047c--fe6fefb5011f449793b6d692b534a17d 9dc2939178e34e858385b98bed7c94ab fe6fefb5011f449793b6d692b534a17d--9dc2939178e34e858385b98bed7c94ab b0871f8ce5c64ad8bf09e9c119072de2 9dc2939178e34e858385b98bed7c94ab--b0871f8ce5c64ad8bf09e9c119072de2 30665cd888b14b69a797b8548791cbc2 b0871f8ce5c64ad8bf09e9c119072de2--30665cd888b14b69a797b8548791cbc2 91bf6956a0904bb6b0d944cfbf92c1df 30665cd888b14b69a797b8548791cbc2--91bf6956a0904bb6b0d944cfbf92c1df 55c9ec31fe1440cb8a5c97c1c9994c6b 91bf6956a0904bb6b0d944cfbf92c1df--55c9ec31fe1440cb8a5c97c1c9994c6b 65b910bd8a584a2786edfc6041c40411 55c9ec31fe1440cb8a5c97c1c9994c6b--65b910bd8a584a2786edfc6041c40411 a9a244c3994f429c8565711d4d325bfd RX(b15) 65b910bd8a584a2786edfc6041c40411--a9a244c3994f429c8565711d4d325bfd a9a244c3994f429c8565711d4d325bfd--e5959ee6ec3f4aa5a065ba1066d67f14 7976b77086334bb0819dcb43f98cbb40 519c2f6d8fe74ca09bab0e1a7cb7f0eb 7c5efbbd2c534b96a489df883f51c485--519c2f6d8fe74ca09bab0e1a7cb7f0eb 98d92d7fcecd43d3b3e4d21ac6c70e12 7 74cba93c21924660a53f2abd127d8c44 519c2f6d8fe74ca09bab0e1a7cb7f0eb--74cba93c21924660a53f2abd127d8c44 42c8fd436f124fb1a2714ecfb0d4c33f 74cba93c21924660a53f2abd127d8c44--42c8fd436f124fb1a2714ecfb0d4c33f ef4654d3cb014d598988163bb0532c9d 42c8fd436f124fb1a2714ecfb0d4c33f--ef4654d3cb014d598988163bb0532c9d fef4031c13484d8080234f604c839663 ef4654d3cb014d598988163bb0532c9d--fef4031c13484d8080234f604c839663 72b2dc4d0f7d46d6931634c4a890b47c X fef4031c13484d8080234f604c839663--72b2dc4d0f7d46d6931634c4a890b47c 72b2dc4d0f7d46d6931634c4a890b47c--56ebb62f0736499fa082cb04d9b6ab3e a97a5b293f7841a092a627482507d9a1 72b2dc4d0f7d46d6931634c4a890b47c--a97a5b293f7841a092a627482507d9a1 8e46ce5ba1cb49ef8a9b7a181d537d92 a97a5b293f7841a092a627482507d9a1--8e46ce5ba1cb49ef8a9b7a181d537d92 78ba49f070e743b997b6ca65625a8ce5 8e46ce5ba1cb49ef8a9b7a181d537d92--78ba49f070e743b997b6ca65625a8ce5 9c12a04d0b0a4be58726f2717b849076 X 78ba49f070e743b997b6ca65625a8ce5--9c12a04d0b0a4be58726f2717b849076 9c12a04d0b0a4be58726f2717b849076--3c83baa4d7cd4c3c8e66693622f13952 11c4922d8fac4badb49a2ff92d1f2dee 9c12a04d0b0a4be58726f2717b849076--11c4922d8fac4badb49a2ff92d1f2dee 531acae637924ef78bd764836104082c 11c4922d8fac4badb49a2ff92d1f2dee--531acae637924ef78bd764836104082c 5d699335df9d412194926fdaecd8134d 531acae637924ef78bd764836104082c--5d699335df9d412194926fdaecd8134d bd0e528caf714a0aad329372bb985b43 5d699335df9d412194926fdaecd8134d--bd0e528caf714a0aad329372bb985b43 8b7e3f540db343458eaff41634045615 bd0e528caf714a0aad329372bb985b43--8b7e3f540db343458eaff41634045615 6940a0132c3849d9a1a056b93babd8ce 8b7e3f540db343458eaff41634045615--6940a0132c3849d9a1a056b93babd8ce 6fd08b3d90614bdb8085ae4c4d7ec6d8 6940a0132c3849d9a1a056b93babd8ce--6fd08b3d90614bdb8085ae4c4d7ec6d8 0951f2356dcf421485e9a8f175167fdc 6fd08b3d90614bdb8085ae4c4d7ec6d8--0951f2356dcf421485e9a8f175167fdc 61f40b8c54924bd5bbf616bead625071 0951f2356dcf421485e9a8f175167fdc--61f40b8c54924bd5bbf616bead625071 3700dec5104b4474a8edaa4fc4935934 61f40b8c54924bd5bbf616bead625071--3700dec5104b4474a8edaa4fc4935934 cd9d132023114fe6bd58403a90958b1e 3700dec5104b4474a8edaa4fc4935934--cd9d132023114fe6bd58403a90958b1e f6075179a9a54dcba8b97ca6e8c4b1a7 cd9d132023114fe6bd58403a90958b1e--f6075179a9a54dcba8b97ca6e8c4b1a7 18ece7d33b6e4f878e50b767692d6669 f6075179a9a54dcba8b97ca6e8c4b1a7--18ece7d33b6e4f878e50b767692d6669 08aa2925629f4c3c9de45a673e997e34 18ece7d33b6e4f878e50b767692d6669--08aa2925629f4c3c9de45a673e997e34 5c54942fd77a4a12bd8663caa1ec7e62 08aa2925629f4c3c9de45a673e997e34--5c54942fd77a4a12bd8663caa1ec7e62 95d90bf520b241dc864f617aad522ffa 5c54942fd77a4a12bd8663caa1ec7e62--95d90bf520b241dc864f617aad522ffa d562dff72e4b4bf2bfde6d87f48ac631 95d90bf520b241dc864f617aad522ffa--d562dff72e4b4bf2bfde6d87f48ac631 1c1db240be6742629124309b79562f5d d562dff72e4b4bf2bfde6d87f48ac631--1c1db240be6742629124309b79562f5d e67c83aaa8204c41bc161df6dfc5bf7f 1c1db240be6742629124309b79562f5d--e67c83aaa8204c41bc161df6dfc5bf7f 40613949e3c9486290a6fa6fddae18a4 e67c83aaa8204c41bc161df6dfc5bf7f--40613949e3c9486290a6fa6fddae18a4 0715341c0ec64c628297b4db1444ad08 40613949e3c9486290a6fa6fddae18a4--0715341c0ec64c628297b4db1444ad08 230baa33267c492c929866fbbe93ba19 0715341c0ec64c628297b4db1444ad08--230baa33267c492c929866fbbe93ba19 5070b7092113443dbea72a30f87f59ac X 230baa33267c492c929866fbbe93ba19--5070b7092113443dbea72a30f87f59ac 5070b7092113443dbea72a30f87f59ac--35490db9a22645d091a3bf5503a8ead9 ec7d2f754f4c43ffad67666c9aeb01bb RZ(-1.0*g0) 5070b7092113443dbea72a30f87f59ac--ec7d2f754f4c43ffad67666c9aeb01bb f894c47dc0ef43b88b7329f30be35f43 X ec7d2f754f4c43ffad67666c9aeb01bb--f894c47dc0ef43b88b7329f30be35f43 f894c47dc0ef43b88b7329f30be35f43--971664034b7f45f8ae90db7cfa749b56 b583fd47c22e4ae59de22f836d8c3a33 f894c47dc0ef43b88b7329f30be35f43--b583fd47c22e4ae59de22f836d8c3a33 fba8511cf22647c8b731cebe2046552d b583fd47c22e4ae59de22f836d8c3a33--fba8511cf22647c8b731cebe2046552d ed3d0c27d3364310bcd4c10b51639aa6 fba8511cf22647c8b731cebe2046552d--ed3d0c27d3364310bcd4c10b51639aa6 c75db3ed63c14e10b4d8e1c1874f7234 ed3d0c27d3364310bcd4c10b51639aa6--c75db3ed63c14e10b4d8e1c1874f7234 20a29ba732204ed8ab8385f46554cdc4 c75db3ed63c14e10b4d8e1c1874f7234--20a29ba732204ed8ab8385f46554cdc4 45b040c41c594efbb7fd8238271bd48f 20a29ba732204ed8ab8385f46554cdc4--45b040c41c594efbb7fd8238271bd48f f3ad70b54a8148d49394b065072345e9 45b040c41c594efbb7fd8238271bd48f--f3ad70b54a8148d49394b065072345e9 16290193d9cb4eeca7a6bcd49cc7ef7c f3ad70b54a8148d49394b065072345e9--16290193d9cb4eeca7a6bcd49cc7ef7c 0d9eef00b0bd4d1ba12e051c4a0b7ae6 16290193d9cb4eeca7a6bcd49cc7ef7c--0d9eef00b0bd4d1ba12e051c4a0b7ae6 be4180e01b024f21af6b5926ebfaf975 0d9eef00b0bd4d1ba12e051c4a0b7ae6--be4180e01b024f21af6b5926ebfaf975 5e7766164efb41cb82063d69e7d960fc be4180e01b024f21af6b5926ebfaf975--5e7766164efb41cb82063d69e7d960fc b5b157e8c3804273b491691396baf0de 5e7766164efb41cb82063d69e7d960fc--b5b157e8c3804273b491691396baf0de 99cd305669f84e179668b748076b58d5 b5b157e8c3804273b491691396baf0de--99cd305669f84e179668b748076b58d5 5a260edb6cc64f85a142bf07d62fdb77 99cd305669f84e179668b748076b58d5--5a260edb6cc64f85a142bf07d62fdb77 3d328822de9642eeb653deaf72fde4c1 5a260edb6cc64f85a142bf07d62fdb77--3d328822de9642eeb653deaf72fde4c1 401a14450c0f453abef46e488646d7a1 3d328822de9642eeb653deaf72fde4c1--401a14450c0f453abef46e488646d7a1 3d655010527a4d38a3db5c808e0f0c87 401a14450c0f453abef46e488646d7a1--3d655010527a4d38a3db5c808e0f0c87 08bf459fd85c40b08b3d7618cfc6747a 3d655010527a4d38a3db5c808e0f0c87--08bf459fd85c40b08b3d7618cfc6747a 5825f602a686423f9b008652be655ea5 08bf459fd85c40b08b3d7618cfc6747a--5825f602a686423f9b008652be655ea5 f25d1253cb3544e2a92cb13e9169d38b 5825f602a686423f9b008652be655ea5--f25d1253cb3544e2a92cb13e9169d38b 12ded637db0e4ba3a74e197ca610da19 f25d1253cb3544e2a92cb13e9169d38b--12ded637db0e4ba3a74e197ca610da19 991c1ae483534ba481e90c19115a1638 X 12ded637db0e4ba3a74e197ca610da19--991c1ae483534ba481e90c19115a1638 991c1ae483534ba481e90c19115a1638--30f733fe85d04f44957f9d6a7787fcde 7dcbda9a7e174d1ab0d45ab954422ecb 991c1ae483534ba481e90c19115a1638--7dcbda9a7e174d1ab0d45ab954422ecb d4696f3908ac41dfa62a7fa0f9345e47 7dcbda9a7e174d1ab0d45ab954422ecb--d4696f3908ac41dfa62a7fa0f9345e47 256ea1cd59cd4687a862787b0802abf5 d4696f3908ac41dfa62a7fa0f9345e47--256ea1cd59cd4687a862787b0802abf5 917cd841cfe145f0b0c686287e852928 X 256ea1cd59cd4687a862787b0802abf5--917cd841cfe145f0b0c686287e852928 917cd841cfe145f0b0c686287e852928--560c4537f2e547bc9e1dd63477bb815f 9452e3e8f88f439d8bf9981e946f3026 917cd841cfe145f0b0c686287e852928--9452e3e8f88f439d8bf9981e946f3026 7c0e257b485b44f6a203dd84e0212647 9452e3e8f88f439d8bf9981e946f3026--7c0e257b485b44f6a203dd84e0212647 d294d9c1cfc044e8823b470ee3b13ac5 7c0e257b485b44f6a203dd84e0212647--d294d9c1cfc044e8823b470ee3b13ac5 9a2f6871d17b412f8812bc5d26e34d10 d294d9c1cfc044e8823b470ee3b13ac5--9a2f6871d17b412f8812bc5d26e34d10 34914cbf955a40f3b248ebe80112287d 9a2f6871d17b412f8812bc5d26e34d10--34914cbf955a40f3b248ebe80112287d 74fd12c0fbc64819b168340ef0d7c599 34914cbf955a40f3b248ebe80112287d--74fd12c0fbc64819b168340ef0d7c599 d0def12ab827450e936bad0052bb5ba7 74fd12c0fbc64819b168340ef0d7c599--d0def12ab827450e936bad0052bb5ba7 7c8ec0a248804c519b4cf1e45205aadb d0def12ab827450e936bad0052bb5ba7--7c8ec0a248804c519b4cf1e45205aadb 753de259308c491ebb267fc9f53c5c29 7c8ec0a248804c519b4cf1e45205aadb--753de259308c491ebb267fc9f53c5c29 1862f877fc5f4c0baead5347160a23d5 753de259308c491ebb267fc9f53c5c29--1862f877fc5f4c0baead5347160a23d5 9d76becc798048efb08af604ea560dc4 1862f877fc5f4c0baead5347160a23d5--9d76becc798048efb08af604ea560dc4 088970a9246f42388f71e9c6ced75124 9d76becc798048efb08af604ea560dc4--088970a9246f42388f71e9c6ced75124 fb9d83e48f974c6f87fc806da86074f7 088970a9246f42388f71e9c6ced75124--fb9d83e48f974c6f87fc806da86074f7 9b7b8c1b93bc44afba3279e0d377d489 fb9d83e48f974c6f87fc806da86074f7--9b7b8c1b93bc44afba3279e0d377d489 ce2270f8e26240f88a67f7914170c5ca X 9b7b8c1b93bc44afba3279e0d377d489--ce2270f8e26240f88a67f7914170c5ca ce2270f8e26240f88a67f7914170c5ca--5bc9dd3bad8643078903195e24d77653 9e47393144214e2a88f0f6756c8ac5ad RZ(-1.0*g0) ce2270f8e26240f88a67f7914170c5ca--9e47393144214e2a88f0f6756c8ac5ad d8c49b43a874440981da47d5fbfb6f4a X 9e47393144214e2a88f0f6756c8ac5ad--d8c49b43a874440981da47d5fbfb6f4a d8c49b43a874440981da47d5fbfb6f4a--6e0b633b3e0b42ec8f3195a52232662d d6a683c750ab41dd958f65fb0a0461a8 d8c49b43a874440981da47d5fbfb6f4a--d6a683c750ab41dd958f65fb0a0461a8 893036925d004abbb5245ea60b656ce4 d6a683c750ab41dd958f65fb0a0461a8--893036925d004abbb5245ea60b656ce4 e9740a46890f424a83c719c06a0cd777 893036925d004abbb5245ea60b656ce4--e9740a46890f424a83c719c06a0cd777 254f478186aa4d23ab2ba6d7e555bc98 e9740a46890f424a83c719c06a0cd777--254f478186aa4d23ab2ba6d7e555bc98 e07bc83d87074a2dab98a3e57b1f3b9e 254f478186aa4d23ab2ba6d7e555bc98--e07bc83d87074a2dab98a3e57b1f3b9e 72b10e5182c1410a8f7a781268502065 e07bc83d87074a2dab98a3e57b1f3b9e--72b10e5182c1410a8f7a781268502065 23f02e35ba274871a16b53120ac90cd3 X 72b10e5182c1410a8f7a781268502065--23f02e35ba274871a16b53120ac90cd3 23f02e35ba274871a16b53120ac90cd3--b0a0ffa320e148adb91bd1d076e32e82 af32c7fdce4e4849a3f11bbbfd85dc2c 23f02e35ba274871a16b53120ac90cd3--af32c7fdce4e4849a3f11bbbfd85dc2c 7e6fa38055344092b8d5fee53c800cf7 af32c7fdce4e4849a3f11bbbfd85dc2c--7e6fa38055344092b8d5fee53c800cf7 f07b2913b69a4c859e15a409acfe1bb1 7e6fa38055344092b8d5fee53c800cf7--f07b2913b69a4c859e15a409acfe1bb1 b2764d9402334721b3bc7f34cb8bb31a X f07b2913b69a4c859e15a409acfe1bb1--b2764d9402334721b3bc7f34cb8bb31a b2764d9402334721b3bc7f34cb8bb31a--990a8ff7b9e443b5ab49d7257b919817 3eba5724ad1f46e9b49426c71b12ede1 b2764d9402334721b3bc7f34cb8bb31a--3eba5724ad1f46e9b49426c71b12ede1 f0ef18899f09475a9510cf33ae9e97a4 3eba5724ad1f46e9b49426c71b12ede1--f0ef18899f09475a9510cf33ae9e97a4 42296f0f4c684970a65a1c546e1a7094 f0ef18899f09475a9510cf33ae9e97a4--42296f0f4c684970a65a1c546e1a7094 39ceea0e31ba4e05b0f1b4e76bd699c6 42296f0f4c684970a65a1c546e1a7094--39ceea0e31ba4e05b0f1b4e76bd699c6 71747fa3e978447eaaad4fe4988aa154 39ceea0e31ba4e05b0f1b4e76bd699c6--71747fa3e978447eaaad4fe4988aa154 656e0c513a3e47e19391719a7e0ff297 71747fa3e978447eaaad4fe4988aa154--656e0c513a3e47e19391719a7e0ff297 bdc33aa991fc40ffbcba89e27ceb1d29 656e0c513a3e47e19391719a7e0ff297--bdc33aa991fc40ffbcba89e27ceb1d29 83140024f646444abf4174d380d7c10a bdc33aa991fc40ffbcba89e27ceb1d29--83140024f646444abf4174d380d7c10a 60c3aea936ec41c2a06dba9f3db6412d 83140024f646444abf4174d380d7c10a--60c3aea936ec41c2a06dba9f3db6412d 941169031a8844e8b7f65e96e05b5e59 60c3aea936ec41c2a06dba9f3db6412d--941169031a8844e8b7f65e96e05b5e59 17ec91f7643f468da592be9dbbc1e2f7 X 941169031a8844e8b7f65e96e05b5e59--17ec91f7643f468da592be9dbbc1e2f7 17ec91f7643f468da592be9dbbc1e2f7--7ef9782ded6444a3af1c622b50223b2d e1b2e21bb046477bbb60ddb2c1c51dcc 17ec91f7643f468da592be9dbbc1e2f7--e1b2e21bb046477bbb60ddb2c1c51dcc ee3efe6056af4c62a355ea643f9614b9 e1b2e21bb046477bbb60ddb2c1c51dcc--ee3efe6056af4c62a355ea643f9614b9 9281ac3b9a184e20b00162e575fdbffe ee3efe6056af4c62a355ea643f9614b9--9281ac3b9a184e20b00162e575fdbffe c11295b3c77a4be6bf8ce54c3e2e2c40 X 9281ac3b9a184e20b00162e575fdbffe--c11295b3c77a4be6bf8ce54c3e2e2c40 c11295b3c77a4be6bf8ce54c3e2e2c40--72e38d010c0f4ebfa9a27eff0e58603f 4e68aeec994f46909f7d238583916000 c11295b3c77a4be6bf8ce54c3e2e2c40--4e68aeec994f46909f7d238583916000 2d67d35bfede4d02acbaa96e29dae1e3 4e68aeec994f46909f7d238583916000--2d67d35bfede4d02acbaa96e29dae1e3 62112bda51e542cdbfce261c3379696e 2d67d35bfede4d02acbaa96e29dae1e3--62112bda51e542cdbfce261c3379696e 4467960531e44ff4befc2ee4482b3737 62112bda51e542cdbfce261c3379696e--4467960531e44ff4befc2ee4482b3737 6d95c6ac74314893b55523e5434ebbf4 4467960531e44ff4befc2ee4482b3737--6d95c6ac74314893b55523e5434ebbf4 a41be3fb4755474285ea2c1f1ccba162 6d95c6ac74314893b55523e5434ebbf4--a41be3fb4755474285ea2c1f1ccba162 02af4cc336294a158e1803a5e2b84b54 X a41be3fb4755474285ea2c1f1ccba162--02af4cc336294a158e1803a5e2b84b54 02af4cc336294a158e1803a5e2b84b54--6f6b8cb3c8324a38b386a8db1cb11f93 4adc238ae41c4768942c9eabb5c1b768 RZ(-1.0*g0) 02af4cc336294a158e1803a5e2b84b54--4adc238ae41c4768942c9eabb5c1b768 77c9e055e9254f178a785663fe4ab9ee X 4adc238ae41c4768942c9eabb5c1b768--77c9e055e9254f178a785663fe4ab9ee 77c9e055e9254f178a785663fe4ab9ee--6c6d6c8e8cd84311b39517038f4728e4 301600378dca4727821eb6b7a88a9af1 77c9e055e9254f178a785663fe4ab9ee--301600378dca4727821eb6b7a88a9af1 592cdb3cfed044f6a11da39354c553a5 301600378dca4727821eb6b7a88a9af1--592cdb3cfed044f6a11da39354c553a5 dbee388f325a4f5991d5c017338322f2 X 592cdb3cfed044f6a11da39354c553a5--dbee388f325a4f5991d5c017338322f2 dbee388f325a4f5991d5c017338322f2--43758eb29d0647b6a6cddff1cc9293b1 70fc713df190424b98eb11f8846d2063 dbee388f325a4f5991d5c017338322f2--70fc713df190424b98eb11f8846d2063 f1ec7a6d82834c22bddd3c95b519f99f 70fc713df190424b98eb11f8846d2063--f1ec7a6d82834c22bddd3c95b519f99f 45c13c0227f449f8aa99779313ba90cf f1ec7a6d82834c22bddd3c95b519f99f--45c13c0227f449f8aa99779313ba90cf 760cae086f164cfea29a7fb88a68a028 X 45c13c0227f449f8aa99779313ba90cf--760cae086f164cfea29a7fb88a68a028 760cae086f164cfea29a7fb88a68a028--e6282e5333bc4589ae8f96bc11449f25 d4221054cd0b4de39cfe3f830ca039fc 760cae086f164cfea29a7fb88a68a028--d4221054cd0b4de39cfe3f830ca039fc a14b1e7c79f3462b884330ea5eff3479 X d4221054cd0b4de39cfe3f830ca039fc--a14b1e7c79f3462b884330ea5eff3479 a14b1e7c79f3462b884330ea5eff3479--a2b32f7af08748289b3760bae1caa7b2 8e4c3d6c82eb4cb1907ca2fb1afac1af RZ(-1.0*g0) a14b1e7c79f3462b884330ea5eff3479--8e4c3d6c82eb4cb1907ca2fb1afac1af 7ec96fc6213647cca4fd62d9a999927f X 8e4c3d6c82eb4cb1907ca2fb1afac1af--7ec96fc6213647cca4fd62d9a999927f 7ec96fc6213647cca4fd62d9a999927f--15695d5cde1e47668d897a42ddd36a61 4fc15e66fd614c2491f262f9b3e64697 X 7ec96fc6213647cca4fd62d9a999927f--4fc15e66fd614c2491f262f9b3e64697 4fc15e66fd614c2491f262f9b3e64697--627fb1eca4f64b799965786218a57d12 b16ef552c6914385b83daa96f2dde7bc 4fc15e66fd614c2491f262f9b3e64697--b16ef552c6914385b83daa96f2dde7bc cfccabb88df647acabfab86e4017c0fc b16ef552c6914385b83daa96f2dde7bc--cfccabb88df647acabfab86e4017c0fc 7d618255f2614543b1f0495d80eef2b8 cfccabb88df647acabfab86e4017c0fc--7d618255f2614543b1f0495d80eef2b8 e88ed45bc5344124a9f89dada27e6681 X 7d618255f2614543b1f0495d80eef2b8--e88ed45bc5344124a9f89dada27e6681 e88ed45bc5344124a9f89dada27e6681--7503ba4b0e7e4285a7301a3477b864d5 702963fa11614df7a60e252e2935bcf4 RX(b06) e88ed45bc5344124a9f89dada27e6681--702963fa11614df7a60e252e2935bcf4 41cbf0ab2640414697422d069a4e2aaf 702963fa11614df7a60e252e2935bcf4--41cbf0ab2640414697422d069a4e2aaf 8af4f6d7186f4488bafea3c7ed2079e5 41cbf0ab2640414697422d069a4e2aaf--8af4f6d7186f4488bafea3c7ed2079e5 dedbe2c2d27545f192078d4648b547b4 8af4f6d7186f4488bafea3c7ed2079e5--dedbe2c2d27545f192078d4648b547b4 4f206445b7ea43b1b14376afcdb133a5 dedbe2c2d27545f192078d4648b547b4--4f206445b7ea43b1b14376afcdb133a5 ef228b16daf042e1887f73896ffc9042 4f206445b7ea43b1b14376afcdb133a5--ef228b16daf042e1887f73896ffc9042 d2f7418a27c24fd9a687f95b398fe038 X ef228b16daf042e1887f73896ffc9042--d2f7418a27c24fd9a687f95b398fe038 d2f7418a27c24fd9a687f95b398fe038--eed43c8d9a7244e48d6a84960b9b4f2e ea5fcfe1df3c48bea800763d74d1898d d2f7418a27c24fd9a687f95b398fe038--ea5fcfe1df3c48bea800763d74d1898d 001fb5da4ae740d7a7a7ab7729cb6835 ea5fcfe1df3c48bea800763d74d1898d--001fb5da4ae740d7a7a7ab7729cb6835 9d63466badef4d05b8556d9669271914 001fb5da4ae740d7a7a7ab7729cb6835--9d63466badef4d05b8556d9669271914 097df7a8cf6e481f96637e48dd29a611 X 9d63466badef4d05b8556d9669271914--097df7a8cf6e481f96637e48dd29a611 097df7a8cf6e481f96637e48dd29a611--144b26a70eae419895438dd1f15b1519 46818cfc92e848f7aa88bebc4af12946 097df7a8cf6e481f96637e48dd29a611--46818cfc92e848f7aa88bebc4af12946 9cebcc7b85f34193ab245d8da8d78ad3 46818cfc92e848f7aa88bebc4af12946--9cebcc7b85f34193ab245d8da8d78ad3 408f90001c644c5cbc9349e4391341fd 9cebcc7b85f34193ab245d8da8d78ad3--408f90001c644c5cbc9349e4391341fd b6800492b67b4d6a912425531a8573c1 408f90001c644c5cbc9349e4391341fd--b6800492b67b4d6a912425531a8573c1 db8431ab69ab49bba4e23f7ecd038a7f b6800492b67b4d6a912425531a8573c1--db8431ab69ab49bba4e23f7ecd038a7f e878643be1d34054b6cc9662211a57da db8431ab69ab49bba4e23f7ecd038a7f--e878643be1d34054b6cc9662211a57da 20568ef788b444ff9369a7ab8fb51e94 e878643be1d34054b6cc9662211a57da--20568ef788b444ff9369a7ab8fb51e94 3e792f4c53a542c8b2a23c93c379659b 20568ef788b444ff9369a7ab8fb51e94--3e792f4c53a542c8b2a23c93c379659b b6423b8a0aba44c086b9c13737186d05 3e792f4c53a542c8b2a23c93c379659b--b6423b8a0aba44c086b9c13737186d05 a32c24b0036e46408ac7b2971e6f1dc1 b6423b8a0aba44c086b9c13737186d05--a32c24b0036e46408ac7b2971e6f1dc1 b704f5a579dc48e2b9e94ffdb364f46f a32c24b0036e46408ac7b2971e6f1dc1--b704f5a579dc48e2b9e94ffdb364f46f d1c1e04dcde443d4ac6f06ebf217afb0 b704f5a579dc48e2b9e94ffdb364f46f--d1c1e04dcde443d4ac6f06ebf217afb0 bce4e42c5d0c41c4b22754d3992898d3 d1c1e04dcde443d4ac6f06ebf217afb0--bce4e42c5d0c41c4b22754d3992898d3 352fe9d1665d409a9be449ea3e0f04ec bce4e42c5d0c41c4b22754d3992898d3--352fe9d1665d409a9be449ea3e0f04ec 53a0be7c19eb4c75a45ceba8f5d026bc 352fe9d1665d409a9be449ea3e0f04ec--53a0be7c19eb4c75a45ceba8f5d026bc 379090cb1ed249708910369ba6ba2720 53a0be7c19eb4c75a45ceba8f5d026bc--379090cb1ed249708910369ba6ba2720 c32e4434ff044edeae52946fc7187785 379090cb1ed249708910369ba6ba2720--c32e4434ff044edeae52946fc7187785 dfab324b768a4eb493398554a94fe13d c32e4434ff044edeae52946fc7187785--dfab324b768a4eb493398554a94fe13d d39d732fec6e43a694cdc0d6fe0afcda dfab324b768a4eb493398554a94fe13d--d39d732fec6e43a694cdc0d6fe0afcda 5dfcfa52e9894599b7b7b7583722080b d39d732fec6e43a694cdc0d6fe0afcda--5dfcfa52e9894599b7b7b7583722080b 851deff7adf0457ca0176d5408f06390 5dfcfa52e9894599b7b7b7583722080b--851deff7adf0457ca0176d5408f06390 7e4aea4786b2461e90b662e4db578d47 851deff7adf0457ca0176d5408f06390--7e4aea4786b2461e90b662e4db578d47 6a0d94ca8f3c489ca5d7deee33d0afb5 X 7e4aea4786b2461e90b662e4db578d47--6a0d94ca8f3c489ca5d7deee33d0afb5 6a0d94ca8f3c489ca5d7deee33d0afb5--b98e92a3901340ec963f4beda6aaa670 efc573f2377e49598ac8b55ccd41ba63 RZ(-1.0*g1) 6a0d94ca8f3c489ca5d7deee33d0afb5--efc573f2377e49598ac8b55ccd41ba63 93318d9105bf4ddf961d94ee52bd400e X efc573f2377e49598ac8b55ccd41ba63--93318d9105bf4ddf961d94ee52bd400e 93318d9105bf4ddf961d94ee52bd400e--682f8f6b702e42799afb42be09b9d663 fa49ef8e51e74a14b62807e27ec9b9d1 93318d9105bf4ddf961d94ee52bd400e--fa49ef8e51e74a14b62807e27ec9b9d1 92c6fe44263a4080bcaf5607d0453bdc fa49ef8e51e74a14b62807e27ec9b9d1--92c6fe44263a4080bcaf5607d0453bdc 0374fe987baf4ec8a2adaa366f51be70 92c6fe44263a4080bcaf5607d0453bdc--0374fe987baf4ec8a2adaa366f51be70 e9a74ff1d548430097514aa5e13afa05 0374fe987baf4ec8a2adaa366f51be70--e9a74ff1d548430097514aa5e13afa05 9b6e96715a6e41f199d69ac4130134a9 e9a74ff1d548430097514aa5e13afa05--9b6e96715a6e41f199d69ac4130134a9 4efd347540fd43c4ac82d5cd0f23d16a 9b6e96715a6e41f199d69ac4130134a9--4efd347540fd43c4ac82d5cd0f23d16a 2f8dfa07a6474f4cb4e719f939ad3817 4efd347540fd43c4ac82d5cd0f23d16a--2f8dfa07a6474f4cb4e719f939ad3817 9f151c5506084bbd884042d2c38cfa69 2f8dfa07a6474f4cb4e719f939ad3817--9f151c5506084bbd884042d2c38cfa69 3756f94a02da44a8aa8ed168ef7db7c6 9f151c5506084bbd884042d2c38cfa69--3756f94a02da44a8aa8ed168ef7db7c6 beb0754107764b6ba3c55c9f1f29a1d7 3756f94a02da44a8aa8ed168ef7db7c6--beb0754107764b6ba3c55c9f1f29a1d7 ff67f33da29a4912897709886c60e3f3 beb0754107764b6ba3c55c9f1f29a1d7--ff67f33da29a4912897709886c60e3f3 39ab54580da949258e230eae03a7175e ff67f33da29a4912897709886c60e3f3--39ab54580da949258e230eae03a7175e a97952fdef6848cc95760dd25cdf7cea 39ab54580da949258e230eae03a7175e--a97952fdef6848cc95760dd25cdf7cea 1042621b8b9746a4a544705e08d21ace a97952fdef6848cc95760dd25cdf7cea--1042621b8b9746a4a544705e08d21ace 5fd75ea5495149caaf26cb8b530cbe47 1042621b8b9746a4a544705e08d21ace--5fd75ea5495149caaf26cb8b530cbe47 56c7bda4cf054dc891f1ca335e053ac6 5fd75ea5495149caaf26cb8b530cbe47--56c7bda4cf054dc891f1ca335e053ac6 b0158b02829c4a3ebc3fa3999b65830f 56c7bda4cf054dc891f1ca335e053ac6--b0158b02829c4a3ebc3fa3999b65830f 5179fb5bed834f35a6d8acfea6f94500 b0158b02829c4a3ebc3fa3999b65830f--5179fb5bed834f35a6d8acfea6f94500 fb76fcfcac7e4c85b2177fe4c47cca39 5179fb5bed834f35a6d8acfea6f94500--fb76fcfcac7e4c85b2177fe4c47cca39 8daa43dd459b47a98b3989104e284595 fb76fcfcac7e4c85b2177fe4c47cca39--8daa43dd459b47a98b3989104e284595 a262d0444f9f45cf86a5971ebe9ccdd3 8daa43dd459b47a98b3989104e284595--a262d0444f9f45cf86a5971ebe9ccdd3 244674bb38f14f0e98df835aca89fdd1 X a262d0444f9f45cf86a5971ebe9ccdd3--244674bb38f14f0e98df835aca89fdd1 244674bb38f14f0e98df835aca89fdd1--deb722c95285492fb0565b012a9d6e7b 145c62b2a4e7418fb354b9f856e45945 244674bb38f14f0e98df835aca89fdd1--145c62b2a4e7418fb354b9f856e45945 32ba2d7ea3b14a569ccf88592be595b7 145c62b2a4e7418fb354b9f856e45945--32ba2d7ea3b14a569ccf88592be595b7 57e55360b5c6423387d40d9c0b599855 32ba2d7ea3b14a569ccf88592be595b7--57e55360b5c6423387d40d9c0b599855 d8361ba9ec8445aebd0185cdd5ddbce5 X 57e55360b5c6423387d40d9c0b599855--d8361ba9ec8445aebd0185cdd5ddbce5 d8361ba9ec8445aebd0185cdd5ddbce5--ef8a81b903564c228dfa315035c8627c b46e9087740d422fa71a7870f4dfcf3c d8361ba9ec8445aebd0185cdd5ddbce5--b46e9087740d422fa71a7870f4dfcf3c f59972dc0a3a46399b6c8a7ea1962b85 b46e9087740d422fa71a7870f4dfcf3c--f59972dc0a3a46399b6c8a7ea1962b85 fad73470cd324125b0494108ad5c776c f59972dc0a3a46399b6c8a7ea1962b85--fad73470cd324125b0494108ad5c776c 3e2c9f580efb4bb69a8987fe67c30cd8 fad73470cd324125b0494108ad5c776c--3e2c9f580efb4bb69a8987fe67c30cd8 3ec1749f70474849b9578517c3604284 3e2c9f580efb4bb69a8987fe67c30cd8--3ec1749f70474849b9578517c3604284 a3ecfce87edf4d37bf1e05373de8895e 3ec1749f70474849b9578517c3604284--a3ecfce87edf4d37bf1e05373de8895e 8fbd35d581ad43b7b40f778d556a5fba a3ecfce87edf4d37bf1e05373de8895e--8fbd35d581ad43b7b40f778d556a5fba 4d1b89669ded466581001f373541645a 8fbd35d581ad43b7b40f778d556a5fba--4d1b89669ded466581001f373541645a 2115c49af2ad4ca3ae3d5e3b29a8d30e 4d1b89669ded466581001f373541645a--2115c49af2ad4ca3ae3d5e3b29a8d30e 48cacb89f8974400813052ed71e66c1f 2115c49af2ad4ca3ae3d5e3b29a8d30e--48cacb89f8974400813052ed71e66c1f 231989e7c012447dacdc19f5856e22ce 48cacb89f8974400813052ed71e66c1f--231989e7c012447dacdc19f5856e22ce baeb7980c5ed4f89a5f62508f737d2a9 231989e7c012447dacdc19f5856e22ce--baeb7980c5ed4f89a5f62508f737d2a9 26f7d1d598034c0ab3db922dc02eac6c baeb7980c5ed4f89a5f62508f737d2a9--26f7d1d598034c0ab3db922dc02eac6c c165b19209b7418798159e5dea01157f 26f7d1d598034c0ab3db922dc02eac6c--c165b19209b7418798159e5dea01157f ff0c80b5f8e9404490432a4c4c637d72 X c165b19209b7418798159e5dea01157f--ff0c80b5f8e9404490432a4c4c637d72 ff0c80b5f8e9404490432a4c4c637d72--79a5bebf634340f3a50b24de2139c4ac d9566285dd954ddfbd03d228335a328e RZ(-1.0*g1) ff0c80b5f8e9404490432a4c4c637d72--d9566285dd954ddfbd03d228335a328e dd0d969ddd0641bfa97819e00c426e04 X d9566285dd954ddfbd03d228335a328e--dd0d969ddd0641bfa97819e00c426e04 dd0d969ddd0641bfa97819e00c426e04--3f3c53b7851a4c43af499d4b78e5fc1b 2d6318946e334a9aab4dd16ea2d70785 dd0d969ddd0641bfa97819e00c426e04--2d6318946e334a9aab4dd16ea2d70785 c345cf104daf4e92afa5405a5b216bbe 2d6318946e334a9aab4dd16ea2d70785--c345cf104daf4e92afa5405a5b216bbe ed69767269db4b6497a1fded2de063be c345cf104daf4e92afa5405a5b216bbe--ed69767269db4b6497a1fded2de063be 780477de4d7b40cc95402cfecccd5e43 ed69767269db4b6497a1fded2de063be--780477de4d7b40cc95402cfecccd5e43 c8ee4a86d22641a0be73f4b03a80cc56 780477de4d7b40cc95402cfecccd5e43--c8ee4a86d22641a0be73f4b03a80cc56 580e16e917c843f3b43ac590b694b68f c8ee4a86d22641a0be73f4b03a80cc56--580e16e917c843f3b43ac590b694b68f cfba57a1fb4d4f9e8e7391549109e324 X 580e16e917c843f3b43ac590b694b68f--cfba57a1fb4d4f9e8e7391549109e324 cfba57a1fb4d4f9e8e7391549109e324--685ec1dbcdb94ed592915719cc35463f f16c879b837148e7a50a07834738476c cfba57a1fb4d4f9e8e7391549109e324--f16c879b837148e7a50a07834738476c 3547ff5dab1b4d10aa56cb42660ac3c3 f16c879b837148e7a50a07834738476c--3547ff5dab1b4d10aa56cb42660ac3c3 96d6c275ae0d4775a8e1c228749bc769 3547ff5dab1b4d10aa56cb42660ac3c3--96d6c275ae0d4775a8e1c228749bc769 9aa5fdbbb3ea434b867249103dd10486 X 96d6c275ae0d4775a8e1c228749bc769--9aa5fdbbb3ea434b867249103dd10486 9aa5fdbbb3ea434b867249103dd10486--c744305414a0410da66c79789f9d1921 3344dbdbea064d3d96191a0d03ded08d 9aa5fdbbb3ea434b867249103dd10486--3344dbdbea064d3d96191a0d03ded08d 9c6be2bc8c4b4b3da5c19d39f4afbfb5 3344dbdbea064d3d96191a0d03ded08d--9c6be2bc8c4b4b3da5c19d39f4afbfb5 38a6f295019c4be694b4c4e8d0210c64 9c6be2bc8c4b4b3da5c19d39f4afbfb5--38a6f295019c4be694b4c4e8d0210c64 71da3244ec7f4f7882a300377977b2a1 38a6f295019c4be694b4c4e8d0210c64--71da3244ec7f4f7882a300377977b2a1 1c76182a7707438db6d12afd885766fa 71da3244ec7f4f7882a300377977b2a1--1c76182a7707438db6d12afd885766fa 40284df3bc6546b0945b15082b54d2b8 1c76182a7707438db6d12afd885766fa--40284df3bc6546b0945b15082b54d2b8 1443285f20854b6db0a87dde1582865b 40284df3bc6546b0945b15082b54d2b8--1443285f20854b6db0a87dde1582865b db77327f260b43949c248dde57f4cb6e 1443285f20854b6db0a87dde1582865b--db77327f260b43949c248dde57f4cb6e 7cd1ed7513674e4588a174eced9af3e0 db77327f260b43949c248dde57f4cb6e--7cd1ed7513674e4588a174eced9af3e0 f00a1e9a7048491b9a24a45cfcb773ee 7cd1ed7513674e4588a174eced9af3e0--f00a1e9a7048491b9a24a45cfcb773ee 9a063500981c4f26851378daa754fb41 X f00a1e9a7048491b9a24a45cfcb773ee--9a063500981c4f26851378daa754fb41 9a063500981c4f26851378daa754fb41--faea8a18c8f346ff8cbbb588c9f951b6 fe76c02f965c4d6fabbaa844ab2b4f65 9a063500981c4f26851378daa754fb41--fe76c02f965c4d6fabbaa844ab2b4f65 01766acd8fd3411fa8bf66bef1049138 fe76c02f965c4d6fabbaa844ab2b4f65--01766acd8fd3411fa8bf66bef1049138 15654be719ce46858fb8fd84a0fa8c51 01766acd8fd3411fa8bf66bef1049138--15654be719ce46858fb8fd84a0fa8c51 58eaf821d11e458fb3e9f274744ea16f X 15654be719ce46858fb8fd84a0fa8c51--58eaf821d11e458fb3e9f274744ea16f 58eaf821d11e458fb3e9f274744ea16f--1305b78e350140b1ae3032ae742c663f a99c35e9a2a849d386eb579339954efe 58eaf821d11e458fb3e9f274744ea16f--a99c35e9a2a849d386eb579339954efe 592ef3e6e7ef4b2ca236524eb826fb63 a99c35e9a2a849d386eb579339954efe--592ef3e6e7ef4b2ca236524eb826fb63 bdd58ecc935e45ec89a2ddeb2f206917 592ef3e6e7ef4b2ca236524eb826fb63--bdd58ecc935e45ec89a2ddeb2f206917 12ac46a7f50d448eb0ef5f669afd20fd bdd58ecc935e45ec89a2ddeb2f206917--12ac46a7f50d448eb0ef5f669afd20fd 3eddeb97f3bc40408eb00990e38d390c 12ac46a7f50d448eb0ef5f669afd20fd--3eddeb97f3bc40408eb00990e38d390c de383d0234ea4531bc16eac14d48f16b 3eddeb97f3bc40408eb00990e38d390c--de383d0234ea4531bc16eac14d48f16b 4063aed581a24e18b5b6de2723de0b69 X de383d0234ea4531bc16eac14d48f16b--4063aed581a24e18b5b6de2723de0b69 4063aed581a24e18b5b6de2723de0b69--302ab664468e4812912d952ea0626834 102258678e964e70b1b1605f3028c756 RZ(-1.0*g1) 4063aed581a24e18b5b6de2723de0b69--102258678e964e70b1b1605f3028c756 7607cfd85150473ab839ec9d8cdeb1ee X 102258678e964e70b1b1605f3028c756--7607cfd85150473ab839ec9d8cdeb1ee 7607cfd85150473ab839ec9d8cdeb1ee--bd54a7d2e25c4d19a7f54306d693b052 9479253e5fb64f209c1e44961b5c6dc8 7607cfd85150473ab839ec9d8cdeb1ee--9479253e5fb64f209c1e44961b5c6dc8 af08abbf855b4a86a5819e5ca52fd643 9479253e5fb64f209c1e44961b5c6dc8--af08abbf855b4a86a5819e5ca52fd643 b4bf004282e845108d928e1a6fac291c X af08abbf855b4a86a5819e5ca52fd643--b4bf004282e845108d928e1a6fac291c b4bf004282e845108d928e1a6fac291c--ee5aa45fb046489784d5cde283a688c5 ce530826e01f4d41ae467255ed57897d b4bf004282e845108d928e1a6fac291c--ce530826e01f4d41ae467255ed57897d 28fc9c6f772540d4bed67ec5e8b9f450 ce530826e01f4d41ae467255ed57897d--28fc9c6f772540d4bed67ec5e8b9f450 ae7ced29376448e2a8f94b41432e4bff 28fc9c6f772540d4bed67ec5e8b9f450--ae7ced29376448e2a8f94b41432e4bff e27af8198be44d5b8752450de1e38514 X ae7ced29376448e2a8f94b41432e4bff--e27af8198be44d5b8752450de1e38514 e27af8198be44d5b8752450de1e38514--9adb7d7eb3db40ee80b5babcc5f0d2e8 545dfc893a9d4905972fe60c539931af e27af8198be44d5b8752450de1e38514--545dfc893a9d4905972fe60c539931af 03ad76390c024388ba4c973cc4a401f0 X 545dfc893a9d4905972fe60c539931af--03ad76390c024388ba4c973cc4a401f0 03ad76390c024388ba4c973cc4a401f0--cd7e5118e6814844818cff67d0ed047c a72c2ddedd9e446198efe80694b9fa1b RZ(-1.0*g1) 03ad76390c024388ba4c973cc4a401f0--a72c2ddedd9e446198efe80694b9fa1b d2d22bcadbe7484ab00da1ffb3fbcd9a X a72c2ddedd9e446198efe80694b9fa1b--d2d22bcadbe7484ab00da1ffb3fbcd9a d2d22bcadbe7484ab00da1ffb3fbcd9a--9dc2939178e34e858385b98bed7c94ab c5cba7e59baa478f9b501e11d41e5cb2 X d2d22bcadbe7484ab00da1ffb3fbcd9a--c5cba7e59baa478f9b501e11d41e5cb2 c5cba7e59baa478f9b501e11d41e5cb2--b0871f8ce5c64ad8bf09e9c119072de2 079065bf717140cda4a303ec2d46cffe c5cba7e59baa478f9b501e11d41e5cb2--079065bf717140cda4a303ec2d46cffe e4f4edac4fc94ee6ad78bf9dad3a3d20 079065bf717140cda4a303ec2d46cffe--e4f4edac4fc94ee6ad78bf9dad3a3d20 c93277bb14454248a2532e434cf3e47b e4f4edac4fc94ee6ad78bf9dad3a3d20--c93277bb14454248a2532e434cf3e47b ac2d0b42eab9428788b7a1c5a77372cf X c93277bb14454248a2532e434cf3e47b--ac2d0b42eab9428788b7a1c5a77372cf ac2d0b42eab9428788b7a1c5a77372cf--65b910bd8a584a2786edfc6041c40411 4f397ed5ef8e4c239c3bb23c5489a845 RX(b16) ac2d0b42eab9428788b7a1c5a77372cf--4f397ed5ef8e4c239c3bb23c5489a845 4f397ed5ef8e4c239c3bb23c5489a845--7976b77086334bb0819dcb43f98cbb40 d261571b8a20469ba87495dfd0ac7bcc 214c47a224ee4757879b1982c01fb643 98d92d7fcecd43d3b3e4d21ac6c70e12--214c47a224ee4757879b1982c01fb643 e36566412fbf4122aa56094100f851b3 214c47a224ee4757879b1982c01fb643--e36566412fbf4122aa56094100f851b3 2a065e462d414e209cf8bfe9b496a97f e36566412fbf4122aa56094100f851b3--2a065e462d414e209cf8bfe9b496a97f a11bda316b524cefae1eae96fa2daf58 2a065e462d414e209cf8bfe9b496a97f--a11bda316b524cefae1eae96fa2daf58 a71b8fd0b21b4a9c8d55428911bbce6d a11bda316b524cefae1eae96fa2daf58--a71b8fd0b21b4a9c8d55428911bbce6d 502545e50fea4a289a78c63ef146199c a71b8fd0b21b4a9c8d55428911bbce6d--502545e50fea4a289a78c63ef146199c 76aea57b56ee458a92c9beeb58ccfd18 X 502545e50fea4a289a78c63ef146199c--76aea57b56ee458a92c9beeb58ccfd18 76aea57b56ee458a92c9beeb58ccfd18--a97a5b293f7841a092a627482507d9a1 6f302881f3044eafa2028c45eab734ac RZ(1.0*g0) 76aea57b56ee458a92c9beeb58ccfd18--6f302881f3044eafa2028c45eab734ac 32c5436314924e55882be13d9867795a X 6f302881f3044eafa2028c45eab734ac--32c5436314924e55882be13d9867795a 32c5436314924e55882be13d9867795a--78ba49f070e743b997b6ca65625a8ce5 be81a7f07eb14b0c99f571f57a8fcbb9 32c5436314924e55882be13d9867795a--be81a7f07eb14b0c99f571f57a8fcbb9 f79a9dac2b794aa5b450dee2808c4660 be81a7f07eb14b0c99f571f57a8fcbb9--f79a9dac2b794aa5b450dee2808c4660 963174066c06491b9d905ccc947e0523 f79a9dac2b794aa5b450dee2808c4660--963174066c06491b9d905ccc947e0523 24cf72e6dbd046dbb0147b4b45b39f0c 963174066c06491b9d905ccc947e0523--24cf72e6dbd046dbb0147b4b45b39f0c 2d19ba62a6c6457b8a8e75905e0e8947 24cf72e6dbd046dbb0147b4b45b39f0c--2d19ba62a6c6457b8a8e75905e0e8947 bcf28084ee1344639d0c228c43876507 2d19ba62a6c6457b8a8e75905e0e8947--bcf28084ee1344639d0c228c43876507 09dc3f109b7f4fd98fba16bcfa4485cf bcf28084ee1344639d0c228c43876507--09dc3f109b7f4fd98fba16bcfa4485cf 680f8e19beb04c42908fea982168c64a 09dc3f109b7f4fd98fba16bcfa4485cf--680f8e19beb04c42908fea982168c64a 07b553f6f85b4a2a8847bd52584c4ada 680f8e19beb04c42908fea982168c64a--07b553f6f85b4a2a8847bd52584c4ada f3202e20fc01424ca14c88a0cb804564 07b553f6f85b4a2a8847bd52584c4ada--f3202e20fc01424ca14c88a0cb804564 db8c261d82724ff186957cea67966cb0 f3202e20fc01424ca14c88a0cb804564--db8c261d82724ff186957cea67966cb0 056ac7fdaa094a1f8a262ab4c418b7c0 db8c261d82724ff186957cea67966cb0--056ac7fdaa094a1f8a262ab4c418b7c0 96789ebb74f34a25a3fbcba2bcb804ab 056ac7fdaa094a1f8a262ab4c418b7c0--96789ebb74f34a25a3fbcba2bcb804ab 90997665a23b44a79a0b56cd6401afd3 96789ebb74f34a25a3fbcba2bcb804ab--90997665a23b44a79a0b56cd6401afd3 ca75cb06519a4c05b67268101dc16637 90997665a23b44a79a0b56cd6401afd3--ca75cb06519a4c05b67268101dc16637 7a132fe6a00b444c844b305aed8f392b ca75cb06519a4c05b67268101dc16637--7a132fe6a00b444c844b305aed8f392b f73175662ba946a480452f507083f0b5 7a132fe6a00b444c844b305aed8f392b--f73175662ba946a480452f507083f0b5 9ada5d4fb4464e399bacb35f61bb1cbf f73175662ba946a480452f507083f0b5--9ada5d4fb4464e399bacb35f61bb1cbf 6f44f5e42ce341ac8bbf34ce38571bde 9ada5d4fb4464e399bacb35f61bb1cbf--6f44f5e42ce341ac8bbf34ce38571bde 54f14365122b4c9ea9525023b829134c 6f44f5e42ce341ac8bbf34ce38571bde--54f14365122b4c9ea9525023b829134c d11ebcecb3ee4817853211062e1a94f1 54f14365122b4c9ea9525023b829134c--d11ebcecb3ee4817853211062e1a94f1 99073d7ca5934217bf23f964e48d97b4 d11ebcecb3ee4817853211062e1a94f1--99073d7ca5934217bf23f964e48d97b4 941ef39ae3034f51ab038b130283810c 99073d7ca5934217bf23f964e48d97b4--941ef39ae3034f51ab038b130283810c 531baf1f61e245538167de2bb014d444 941ef39ae3034f51ab038b130283810c--531baf1f61e245538167de2bb014d444 08938a355a45432d960dbe15da02b617 531baf1f61e245538167de2bb014d444--08938a355a45432d960dbe15da02b617 f0bf20c378db4e0387964b94bf244a9e 08938a355a45432d960dbe15da02b617--f0bf20c378db4e0387964b94bf244a9e 024b45125f6b4a60adf2f6f83a0fda90 f0bf20c378db4e0387964b94bf244a9e--024b45125f6b4a60adf2f6f83a0fda90 4456aa923cb6433fb188ae021884ce87 024b45125f6b4a60adf2f6f83a0fda90--4456aa923cb6433fb188ae021884ce87 c10c7858616d42a89260d71613996922 4456aa923cb6433fb188ae021884ce87--c10c7858616d42a89260d71613996922 f5c85785fd3e4a0a850dc4f6a12b4232 c10c7858616d42a89260d71613996922--f5c85785fd3e4a0a850dc4f6a12b4232 e6a00a5a5d6d4a8094c4c6fa8c2ec2e9 f5c85785fd3e4a0a850dc4f6a12b4232--e6a00a5a5d6d4a8094c4c6fa8c2ec2e9 75ab8c7c07884ec7bde9cf33148a68db e6a00a5a5d6d4a8094c4c6fa8c2ec2e9--75ab8c7c07884ec7bde9cf33148a68db 681215814ca94153824c1547a296fe0c 75ab8c7c07884ec7bde9cf33148a68db--681215814ca94153824c1547a296fe0c 145428652f59438faba1bbe76772c99f 681215814ca94153824c1547a296fe0c--145428652f59438faba1bbe76772c99f 593b84f66d164a9497fadd50c3fd1589 145428652f59438faba1bbe76772c99f--593b84f66d164a9497fadd50c3fd1589 38741d3dff5c4051a8fc6db8aefbdf89 593b84f66d164a9497fadd50c3fd1589--38741d3dff5c4051a8fc6db8aefbdf89 2e95dbebdde4416985955fe05e8afcf4 38741d3dff5c4051a8fc6db8aefbdf89--2e95dbebdde4416985955fe05e8afcf4 4e4b04306b6a4537989e1ef76eb5083c 2e95dbebdde4416985955fe05e8afcf4--4e4b04306b6a4537989e1ef76eb5083c d9dadf10a8ae477aab3accbc3e44ceb5 4e4b04306b6a4537989e1ef76eb5083c--d9dadf10a8ae477aab3accbc3e44ceb5 25d44f0001344f5cab80d4b5b124786b d9dadf10a8ae477aab3accbc3e44ceb5--25d44f0001344f5cab80d4b5b124786b 9d8ff4eee008407dbe1722bb6360a9f8 25d44f0001344f5cab80d4b5b124786b--9d8ff4eee008407dbe1722bb6360a9f8 a7b6493c756a4167b1140fc06036f06b 9d8ff4eee008407dbe1722bb6360a9f8--a7b6493c756a4167b1140fc06036f06b 48e4f58d37374b4cab98aa1bc96cda84 a7b6493c756a4167b1140fc06036f06b--48e4f58d37374b4cab98aa1bc96cda84 0dd062d95bfb4edcba9f8a9e28af66e8 48e4f58d37374b4cab98aa1bc96cda84--0dd062d95bfb4edcba9f8a9e28af66e8 fcd1b8a71a904311a8cb3a5cb73d07bf 0dd062d95bfb4edcba9f8a9e28af66e8--fcd1b8a71a904311a8cb3a5cb73d07bf 748f365381764af9b4274e380b71a67b fcd1b8a71a904311a8cb3a5cb73d07bf--748f365381764af9b4274e380b71a67b a197b2f9cec842e6b5cff546ac71eb3f 748f365381764af9b4274e380b71a67b--a197b2f9cec842e6b5cff546ac71eb3f 7e33ebe265f0429489632922a286fe6c a197b2f9cec842e6b5cff546ac71eb3f--7e33ebe265f0429489632922a286fe6c 6bc4ee369304408e8b7cbe7d4575b64f X 7e33ebe265f0429489632922a286fe6c--6bc4ee369304408e8b7cbe7d4575b64f 6bc4ee369304408e8b7cbe7d4575b64f--7dcbda9a7e174d1ab0d45ab954422ecb 5a6e32c9642b4193a42d18b22be08027 RZ(-1.0*g0) 6bc4ee369304408e8b7cbe7d4575b64f--5a6e32c9642b4193a42d18b22be08027 ada8adfd96aa4a1c9f10ce2c2ea779e3 X 5a6e32c9642b4193a42d18b22be08027--ada8adfd96aa4a1c9f10ce2c2ea779e3 ada8adfd96aa4a1c9f10ce2c2ea779e3--256ea1cd59cd4687a862787b0802abf5 a3d3fb8b1d3a40ce81144093ca73e7d7 ada8adfd96aa4a1c9f10ce2c2ea779e3--a3d3fb8b1d3a40ce81144093ca73e7d7 32d58b65537e4ca59f5a7f8b138c68a8 a3d3fb8b1d3a40ce81144093ca73e7d7--32d58b65537e4ca59f5a7f8b138c68a8 1864727da2444c86978f0d538309aeee 32d58b65537e4ca59f5a7f8b138c68a8--1864727da2444c86978f0d538309aeee dfe8ddce13b24ab99128524a1a53ca92 1864727da2444c86978f0d538309aeee--dfe8ddce13b24ab99128524a1a53ca92 174b62bf94204eba99c67ec02b00790b dfe8ddce13b24ab99128524a1a53ca92--174b62bf94204eba99c67ec02b00790b 97a28a72ec624bb79618ea6dca5e483c 174b62bf94204eba99c67ec02b00790b--97a28a72ec624bb79618ea6dca5e483c 3f47994f60774ee5a1f4cc35f6d6a479 97a28a72ec624bb79618ea6dca5e483c--3f47994f60774ee5a1f4cc35f6d6a479 d8dcd441dace49b0a4517d461e16bab3 3f47994f60774ee5a1f4cc35f6d6a479--d8dcd441dace49b0a4517d461e16bab3 6ea3b97a724e4a14a87e70c612ea6dbc d8dcd441dace49b0a4517d461e16bab3--6ea3b97a724e4a14a87e70c612ea6dbc 6beb3b609dae484c9f7dd4ab5b5f2638 6ea3b97a724e4a14a87e70c612ea6dbc--6beb3b609dae484c9f7dd4ab5b5f2638 008832d8208c44669620eaea6ac2f5b2 6beb3b609dae484c9f7dd4ab5b5f2638--008832d8208c44669620eaea6ac2f5b2 1e5ea4c9df084fcfb31ed19eec3a4462 008832d8208c44669620eaea6ac2f5b2--1e5ea4c9df084fcfb31ed19eec3a4462 47c956f5fe9040abb23043e60841b9cf 1e5ea4c9df084fcfb31ed19eec3a4462--47c956f5fe9040abb23043e60841b9cf 46aa3fc8fcc84b43b09131d9b55b893e 47c956f5fe9040abb23043e60841b9cf--46aa3fc8fcc84b43b09131d9b55b893e 707bc6566cda40a99e5a747099dfbd59 46aa3fc8fcc84b43b09131d9b55b893e--707bc6566cda40a99e5a747099dfbd59 40c0e57a1b1043ccb9ed989f4608ea6b 707bc6566cda40a99e5a747099dfbd59--40c0e57a1b1043ccb9ed989f4608ea6b c44e6130c7a1410391b2852d274038e0 40c0e57a1b1043ccb9ed989f4608ea6b--c44e6130c7a1410391b2852d274038e0 50f828d6bbcb442e87a7c8cbfa653eec c44e6130c7a1410391b2852d274038e0--50f828d6bbcb442e87a7c8cbfa653eec 1816de7d469a45d89669f063cbc8e7f6 50f828d6bbcb442e87a7c8cbfa653eec--1816de7d469a45d89669f063cbc8e7f6 f7a0ccf63afe43a6b30baebecf0fc1c5 1816de7d469a45d89669f063cbc8e7f6--f7a0ccf63afe43a6b30baebecf0fc1c5 b40bef1217344d5da86dc121c8ef4d1e f7a0ccf63afe43a6b30baebecf0fc1c5--b40bef1217344d5da86dc121c8ef4d1e b9d938d8a91e460994badccfebb45316 b40bef1217344d5da86dc121c8ef4d1e--b9d938d8a91e460994badccfebb45316 eba44276d1d64db89ead49287c31c11b b9d938d8a91e460994badccfebb45316--eba44276d1d64db89ead49287c31c11b 814336b22a564ec59efb43b640ae3569 eba44276d1d64db89ead49287c31c11b--814336b22a564ec59efb43b640ae3569 bc0b3ffe112b49acb0e50d8545c8fa84 814336b22a564ec59efb43b640ae3569--bc0b3ffe112b49acb0e50d8545c8fa84 898b633af7af4e9ca35a3a218f6e229d X bc0b3ffe112b49acb0e50d8545c8fa84--898b633af7af4e9ca35a3a218f6e229d 898b633af7af4e9ca35a3a218f6e229d--af32c7fdce4e4849a3f11bbbfd85dc2c aa5287637219415493bb8e02fc24a8cf RZ(-1.0*g0) 898b633af7af4e9ca35a3a218f6e229d--aa5287637219415493bb8e02fc24a8cf ffa39d7bfd4348c1a373912e01d6c5c3 X aa5287637219415493bb8e02fc24a8cf--ffa39d7bfd4348c1a373912e01d6c5c3 ffa39d7bfd4348c1a373912e01d6c5c3--f07b2913b69a4c859e15a409acfe1bb1 182fa6d03a8d44bdb1d6f5102c8db59c ffa39d7bfd4348c1a373912e01d6c5c3--182fa6d03a8d44bdb1d6f5102c8db59c cb7a144d9f2e40dda5fddaac00723567 182fa6d03a8d44bdb1d6f5102c8db59c--cb7a144d9f2e40dda5fddaac00723567 ad0e84b9c996496eb90dc640f0e9676d cb7a144d9f2e40dda5fddaac00723567--ad0e84b9c996496eb90dc640f0e9676d bac8c547221d4a4ea2ee7eb48a349bea ad0e84b9c996496eb90dc640f0e9676d--bac8c547221d4a4ea2ee7eb48a349bea 2a2ed83bbc6f427c8219e86b8e7b0831 bac8c547221d4a4ea2ee7eb48a349bea--2a2ed83bbc6f427c8219e86b8e7b0831 b56d60ccca5e463499780e03832b17ca 2a2ed83bbc6f427c8219e86b8e7b0831--b56d60ccca5e463499780e03832b17ca 6118edd30562428c92605f04509e4ba6 b56d60ccca5e463499780e03832b17ca--6118edd30562428c92605f04509e4ba6 4c1fa6368daa49b6b8cc977016f0da89 6118edd30562428c92605f04509e4ba6--4c1fa6368daa49b6b8cc977016f0da89 2a8f862262894032b5e957bc05b26f75 4c1fa6368daa49b6b8cc977016f0da89--2a8f862262894032b5e957bc05b26f75 44b83ceda4b74cfa92f280c49d68a6e7 2a8f862262894032b5e957bc05b26f75--44b83ceda4b74cfa92f280c49d68a6e7 55d1d30bfaf44491b278ef1433f4e669 44b83ceda4b74cfa92f280c49d68a6e7--55d1d30bfaf44491b278ef1433f4e669 a54630a8265e47be99df688e1f1912d4 55d1d30bfaf44491b278ef1433f4e669--a54630a8265e47be99df688e1f1912d4 74d2b078388941cdacfd530fa10d67f8 X a54630a8265e47be99df688e1f1912d4--74d2b078388941cdacfd530fa10d67f8 74d2b078388941cdacfd530fa10d67f8--e1b2e21bb046477bbb60ddb2c1c51dcc 98be763bbe5149c1805d4019ac2cf71f RZ(-1.0*g0) 74d2b078388941cdacfd530fa10d67f8--98be763bbe5149c1805d4019ac2cf71f e304074e087c43feb2abca24753ba3a9 X 98be763bbe5149c1805d4019ac2cf71f--e304074e087c43feb2abca24753ba3a9 e304074e087c43feb2abca24753ba3a9--9281ac3b9a184e20b00162e575fdbffe e929a843f7bc4d61a209b9dac2319ec1 e304074e087c43feb2abca24753ba3a9--e929a843f7bc4d61a209b9dac2319ec1 c1bab883c0f7430faebdb178825eb21d e929a843f7bc4d61a209b9dac2319ec1--c1bab883c0f7430faebdb178825eb21d 7bc0d725373b49cab1e3aad5c8c1341a c1bab883c0f7430faebdb178825eb21d--7bc0d725373b49cab1e3aad5c8c1341a 6e2e3d633d444c52953a1b80a3c49648 7bc0d725373b49cab1e3aad5c8c1341a--6e2e3d633d444c52953a1b80a3c49648 b4b61647034c4b3594669e3f3e6c9be0 6e2e3d633d444c52953a1b80a3c49648--b4b61647034c4b3594669e3f3e6c9be0 cd561d5d39fe4d3683c2795668ca66cc b4b61647034c4b3594669e3f3e6c9be0--cd561d5d39fe4d3683c2795668ca66cc 12e189f04c1d4449b490351f48f0605a cd561d5d39fe4d3683c2795668ca66cc--12e189f04c1d4449b490351f48f0605a 3ce8653b95b14a5e81f5443096d7a0f0 12e189f04c1d4449b490351f48f0605a--3ce8653b95b14a5e81f5443096d7a0f0 8c7099e9f2604fd7aea9c37cffdd979b 3ce8653b95b14a5e81f5443096d7a0f0--8c7099e9f2604fd7aea9c37cffdd979b f2cf7b5a57cd4dbbafe8eed026cf4c7c 8c7099e9f2604fd7aea9c37cffdd979b--f2cf7b5a57cd4dbbafe8eed026cf4c7c 43ae5171f0f44d11875bad45778a07c4 f2cf7b5a57cd4dbbafe8eed026cf4c7c--43ae5171f0f44d11875bad45778a07c4 aaaff481a38f421eac0b08613dc448e8 43ae5171f0f44d11875bad45778a07c4--aaaff481a38f421eac0b08613dc448e8 d0e77d91fc384ccc9f24309061b0aab9 aaaff481a38f421eac0b08613dc448e8--d0e77d91fc384ccc9f24309061b0aab9 701ce8cc9b354d28874b052cce90467f X d0e77d91fc384ccc9f24309061b0aab9--701ce8cc9b354d28874b052cce90467f 701ce8cc9b354d28874b052cce90467f--70fc713df190424b98eb11f8846d2063 51bedeffa56e4265b9e35c0952197f83 RZ(-1.0*g0) 701ce8cc9b354d28874b052cce90467f--51bedeffa56e4265b9e35c0952197f83 4602b30371114393aa34cd7dfdd7bc98 X 51bedeffa56e4265b9e35c0952197f83--4602b30371114393aa34cd7dfdd7bc98 4602b30371114393aa34cd7dfdd7bc98--45c13c0227f449f8aa99779313ba90cf c1690c396b444db99090ebe18f59b525 4602b30371114393aa34cd7dfdd7bc98--c1690c396b444db99090ebe18f59b525 5494edb3b13749a1b8cf921ed5c9cdfc c1690c396b444db99090ebe18f59b525--5494edb3b13749a1b8cf921ed5c9cdfc 72b6a9e35d214e10a4495269919471a1 5494edb3b13749a1b8cf921ed5c9cdfc--72b6a9e35d214e10a4495269919471a1 6e938be504ce46fd92149824a5e516ec 72b6a9e35d214e10a4495269919471a1--6e938be504ce46fd92149824a5e516ec 4a5c4042327f4e5f80e793fd101b5931 6e938be504ce46fd92149824a5e516ec--4a5c4042327f4e5f80e793fd101b5931 5421b955acf340a19a4c717c1408800d 4a5c4042327f4e5f80e793fd101b5931--5421b955acf340a19a4c717c1408800d 9102ed63d5f14a4b8e63311492f58368 X 5421b955acf340a19a4c717c1408800d--9102ed63d5f14a4b8e63311492f58368 9102ed63d5f14a4b8e63311492f58368--b16ef552c6914385b83daa96f2dde7bc 998434ceddbe4f5992ac856b4a37f2e1 RZ(-1.0*g0) 9102ed63d5f14a4b8e63311492f58368--998434ceddbe4f5992ac856b4a37f2e1 0787a872a5e34f3498b639b6278bdf1b X 998434ceddbe4f5992ac856b4a37f2e1--0787a872a5e34f3498b639b6278bdf1b 0787a872a5e34f3498b639b6278bdf1b--7d618255f2614543b1f0495d80eef2b8 b88f7bcb7d37429b9d0ed535ff4701d0 0787a872a5e34f3498b639b6278bdf1b--b88f7bcb7d37429b9d0ed535ff4701d0 1fc4f786d2724908a0b4778b851e4be6 RX(b07) b88f7bcb7d37429b9d0ed535ff4701d0--1fc4f786d2724908a0b4778b851e4be6 baf87cfffec44aee9576d6de9ba98fde 1fc4f786d2724908a0b4778b851e4be6--baf87cfffec44aee9576d6de9ba98fde 5d51e6539b054dcc82cbfcc2780c4803 baf87cfffec44aee9576d6de9ba98fde--5d51e6539b054dcc82cbfcc2780c4803 1b0dac194fad44f692799379b089d380 5d51e6539b054dcc82cbfcc2780c4803--1b0dac194fad44f692799379b089d380 ee722cc67c414c3fbbf9d98a4339dfde 1b0dac194fad44f692799379b089d380--ee722cc67c414c3fbbf9d98a4339dfde 866758bdaf4948e59bf1225db2d9880b ee722cc67c414c3fbbf9d98a4339dfde--866758bdaf4948e59bf1225db2d9880b 7f3389e4800c4a69a6a071a207a3859a 866758bdaf4948e59bf1225db2d9880b--7f3389e4800c4a69a6a071a207a3859a 555276ff37094753bf462662ef0afedc X 7f3389e4800c4a69a6a071a207a3859a--555276ff37094753bf462662ef0afedc 555276ff37094753bf462662ef0afedc--ea5fcfe1df3c48bea800763d74d1898d 98274d0526e2406e8ff5d6150ff2af78 RZ(1.0*g1) 555276ff37094753bf462662ef0afedc--98274d0526e2406e8ff5d6150ff2af78 bfe4704d33e14dd3be41a1bd17f96ebe X 98274d0526e2406e8ff5d6150ff2af78--bfe4704d33e14dd3be41a1bd17f96ebe bfe4704d33e14dd3be41a1bd17f96ebe--9d63466badef4d05b8556d9669271914 119a3da2fd89453bbb2f7f74f74e0a8b bfe4704d33e14dd3be41a1bd17f96ebe--119a3da2fd89453bbb2f7f74f74e0a8b 8522cebf69724e18906b88112d950bc1 119a3da2fd89453bbb2f7f74f74e0a8b--8522cebf69724e18906b88112d950bc1 7cdcbc5ff4d34af49e0596b5abc0fd07 8522cebf69724e18906b88112d950bc1--7cdcbc5ff4d34af49e0596b5abc0fd07 3c06347fdf7f49a5a7eba8da5ded07b8 7cdcbc5ff4d34af49e0596b5abc0fd07--3c06347fdf7f49a5a7eba8da5ded07b8 ad7e6322f75d47df89070ae9e9b41202 3c06347fdf7f49a5a7eba8da5ded07b8--ad7e6322f75d47df89070ae9e9b41202 2a523bf428744f5fa841b1ba3d6bf494 ad7e6322f75d47df89070ae9e9b41202--2a523bf428744f5fa841b1ba3d6bf494 80cbfc9812f44dacac06bf4d6ab90b73 2a523bf428744f5fa841b1ba3d6bf494--80cbfc9812f44dacac06bf4d6ab90b73 c42298e6d8314cb2a8c34b63bbc3829f 80cbfc9812f44dacac06bf4d6ab90b73--c42298e6d8314cb2a8c34b63bbc3829f 833499c61dcc4852a832b88afb4ad731 c42298e6d8314cb2a8c34b63bbc3829f--833499c61dcc4852a832b88afb4ad731 89d574bb546c4c71a4c9ae5b3bed59eb 833499c61dcc4852a832b88afb4ad731--89d574bb546c4c71a4c9ae5b3bed59eb 752d653b94944c98b094daa94d864f29 89d574bb546c4c71a4c9ae5b3bed59eb--752d653b94944c98b094daa94d864f29 a39c4818f4f84e5187b00d949948db82 752d653b94944c98b094daa94d864f29--a39c4818f4f84e5187b00d949948db82 7d2a197256034a108a0a7a4479e5266f a39c4818f4f84e5187b00d949948db82--7d2a197256034a108a0a7a4479e5266f 020d75fb1bc849d6a99607d10d027141 7d2a197256034a108a0a7a4479e5266f--020d75fb1bc849d6a99607d10d027141 ec87493d9c5442089722316441408f38 020d75fb1bc849d6a99607d10d027141--ec87493d9c5442089722316441408f38 b0112fa80e53422281f2c959978e28f7 ec87493d9c5442089722316441408f38--b0112fa80e53422281f2c959978e28f7 8ebf9a6ac37740bebe8abf22744b0467 b0112fa80e53422281f2c959978e28f7--8ebf9a6ac37740bebe8abf22744b0467 04f7ee1eb4cd44d8bb35794ea3874b4c 8ebf9a6ac37740bebe8abf22744b0467--04f7ee1eb4cd44d8bb35794ea3874b4c 1e1c8839f3014e2fb2a5da24bd7e1e1c 04f7ee1eb4cd44d8bb35794ea3874b4c--1e1c8839f3014e2fb2a5da24bd7e1e1c 6e262a4d4bea40aca89dd74b6381e620 1e1c8839f3014e2fb2a5da24bd7e1e1c--6e262a4d4bea40aca89dd74b6381e620 0e822509a10f46e79d3c0292ffc17444 6e262a4d4bea40aca89dd74b6381e620--0e822509a10f46e79d3c0292ffc17444 ff67e4ca2ce74171915d7ba71cad1783 0e822509a10f46e79d3c0292ffc17444--ff67e4ca2ce74171915d7ba71cad1783 287cce7cb7b24113ae75ffe40b554c9f ff67e4ca2ce74171915d7ba71cad1783--287cce7cb7b24113ae75ffe40b554c9f 856d4fd00fc64300b09e4385d464e562 287cce7cb7b24113ae75ffe40b554c9f--856d4fd00fc64300b09e4385d464e562 a86e96b959b942ae97534250b7034b42 856d4fd00fc64300b09e4385d464e562--a86e96b959b942ae97534250b7034b42 710a0a7d5fc54480b00ae11b34e2c1dd a86e96b959b942ae97534250b7034b42--710a0a7d5fc54480b00ae11b34e2c1dd d39602997c9b4f3ab7706c2c409cbc99 710a0a7d5fc54480b00ae11b34e2c1dd--d39602997c9b4f3ab7706c2c409cbc99 3e24235aa9d04a9e9861721631a5c18f d39602997c9b4f3ab7706c2c409cbc99--3e24235aa9d04a9e9861721631a5c18f ee7b4960cd624f73a51ce960ab3db6be 3e24235aa9d04a9e9861721631a5c18f--ee7b4960cd624f73a51ce960ab3db6be 27b9192191934da8ad2c444d23baa7df ee7b4960cd624f73a51ce960ab3db6be--27b9192191934da8ad2c444d23baa7df 74cabc01b8c041018e752983be0a1ba9 27b9192191934da8ad2c444d23baa7df--74cabc01b8c041018e752983be0a1ba9 4550f165817d4150b3c5d19a3d8024a8 74cabc01b8c041018e752983be0a1ba9--4550f165817d4150b3c5d19a3d8024a8 c2efa3eb68c542b38de6e2d2da97d19c 4550f165817d4150b3c5d19a3d8024a8--c2efa3eb68c542b38de6e2d2da97d19c e4fd3171ca3d45099b50a23bc9bcd3e5 c2efa3eb68c542b38de6e2d2da97d19c--e4fd3171ca3d45099b50a23bc9bcd3e5 2e16dacb613040599a89d5d3845528ba e4fd3171ca3d45099b50a23bc9bcd3e5--2e16dacb613040599a89d5d3845528ba e90db7381e9d4db491032b85d73077ca 2e16dacb613040599a89d5d3845528ba--e90db7381e9d4db491032b85d73077ca b509cd819f004881a5e548684e0aac70 e90db7381e9d4db491032b85d73077ca--b509cd819f004881a5e548684e0aac70 1bfe1bb01fcf46d0ad917107249f2b8b b509cd819f004881a5e548684e0aac70--1bfe1bb01fcf46d0ad917107249f2b8b e56b5c0e0d604bdcac720ef911632e7a 1bfe1bb01fcf46d0ad917107249f2b8b--e56b5c0e0d604bdcac720ef911632e7a 1dd64e435fd943df92dd81406aa4cac7 e56b5c0e0d604bdcac720ef911632e7a--1dd64e435fd943df92dd81406aa4cac7 26d2deb3a51e46b09bde1fb1424d0aef 1dd64e435fd943df92dd81406aa4cac7--26d2deb3a51e46b09bde1fb1424d0aef 2f88eb9742b44cd697d4402682451af5 26d2deb3a51e46b09bde1fb1424d0aef--2f88eb9742b44cd697d4402682451af5 c8e452b0c78d41998169113ba313e960 2f88eb9742b44cd697d4402682451af5--c8e452b0c78d41998169113ba313e960 14bc0ca7158045b1b217dedd2dc4eca9 c8e452b0c78d41998169113ba313e960--14bc0ca7158045b1b217dedd2dc4eca9 38ece9b5188f44f4a07fc3befd637751 14bc0ca7158045b1b217dedd2dc4eca9--38ece9b5188f44f4a07fc3befd637751 238e8c0c38874437adedba009c47bc99 38ece9b5188f44f4a07fc3befd637751--238e8c0c38874437adedba009c47bc99 1aba6e3f39194050b4e383973a87733e 238e8c0c38874437adedba009c47bc99--1aba6e3f39194050b4e383973a87733e f8ff228e558d43bb937336908d00b150 1aba6e3f39194050b4e383973a87733e--f8ff228e558d43bb937336908d00b150 d24f50f935544e259ddcf480c99f0e41 X f8ff228e558d43bb937336908d00b150--d24f50f935544e259ddcf480c99f0e41 d24f50f935544e259ddcf480c99f0e41--145c62b2a4e7418fb354b9f856e45945 617f00da2c5a4564af54696600301baa RZ(-1.0*g1) d24f50f935544e259ddcf480c99f0e41--617f00da2c5a4564af54696600301baa 33482463d382457fb5950c6275d1bb73 X 617f00da2c5a4564af54696600301baa--33482463d382457fb5950c6275d1bb73 33482463d382457fb5950c6275d1bb73--57e55360b5c6423387d40d9c0b599855 940111a66c774a52b28bd34236f30dbd 33482463d382457fb5950c6275d1bb73--940111a66c774a52b28bd34236f30dbd f364fce5747f4544b0a0da8070aca6cc 940111a66c774a52b28bd34236f30dbd--f364fce5747f4544b0a0da8070aca6cc 07562588a03146699fbcc0095e9ef68c f364fce5747f4544b0a0da8070aca6cc--07562588a03146699fbcc0095e9ef68c 03e68b4cbe5b46039a5ea0a6e1088fcf 07562588a03146699fbcc0095e9ef68c--03e68b4cbe5b46039a5ea0a6e1088fcf 1084f141498d425f8f7926c5d86bace0 03e68b4cbe5b46039a5ea0a6e1088fcf--1084f141498d425f8f7926c5d86bace0 f0604bf8a1dc49c9b85d8108e66b4774 1084f141498d425f8f7926c5d86bace0--f0604bf8a1dc49c9b85d8108e66b4774 6ad96ecad22f4dd39a34bcc73a52abb2 f0604bf8a1dc49c9b85d8108e66b4774--6ad96ecad22f4dd39a34bcc73a52abb2 f3e13023d3b148279c59cd1d2d91ab0c 6ad96ecad22f4dd39a34bcc73a52abb2--f3e13023d3b148279c59cd1d2d91ab0c e6ba84cdbe3041219fbb6732ea332b1e f3e13023d3b148279c59cd1d2d91ab0c--e6ba84cdbe3041219fbb6732ea332b1e 3ba79a9b1b744bb695a403e813d94ef5 e6ba84cdbe3041219fbb6732ea332b1e--3ba79a9b1b744bb695a403e813d94ef5 4e49133e329444d5a8371e034a5d8d8b 3ba79a9b1b744bb695a403e813d94ef5--4e49133e329444d5a8371e034a5d8d8b 3186fd513bdf4e3c847a277f96fc0e3d 4e49133e329444d5a8371e034a5d8d8b--3186fd513bdf4e3c847a277f96fc0e3d 8ebb8e0612e14346bb7eadb9d5443920 3186fd513bdf4e3c847a277f96fc0e3d--8ebb8e0612e14346bb7eadb9d5443920 f6be58ae74284350b70f3147089e86b9 8ebb8e0612e14346bb7eadb9d5443920--f6be58ae74284350b70f3147089e86b9 a8b92855fbc9418b9561b5098ad9fbf0 f6be58ae74284350b70f3147089e86b9--a8b92855fbc9418b9561b5098ad9fbf0 e54f62adf8594bd4b90ecc3a458be7cf a8b92855fbc9418b9561b5098ad9fbf0--e54f62adf8594bd4b90ecc3a458be7cf 34694b7a9c2844aba8ac3b14924b8327 e54f62adf8594bd4b90ecc3a458be7cf--34694b7a9c2844aba8ac3b14924b8327 4e0570d0ec0546708bbdb0f03664a1e5 34694b7a9c2844aba8ac3b14924b8327--4e0570d0ec0546708bbdb0f03664a1e5 ca45d72ac2904d70bf9dbea6bf10a8ca 4e0570d0ec0546708bbdb0f03664a1e5--ca45d72ac2904d70bf9dbea6bf10a8ca 3c646c0583fa4c088b461cf4f9f5e079 ca45d72ac2904d70bf9dbea6bf10a8ca--3c646c0583fa4c088b461cf4f9f5e079 7f203960a40b4c7685eeaedae92e961c 3c646c0583fa4c088b461cf4f9f5e079--7f203960a40b4c7685eeaedae92e961c 1166f179b5b74f30b98eb318240fe9de 7f203960a40b4c7685eeaedae92e961c--1166f179b5b74f30b98eb318240fe9de 63b6f7edd3f6492ba4aadc58b898e32c 1166f179b5b74f30b98eb318240fe9de--63b6f7edd3f6492ba4aadc58b898e32c ffdce0a453ae4703a94bba152ef38b89 63b6f7edd3f6492ba4aadc58b898e32c--ffdce0a453ae4703a94bba152ef38b89 7b6c3ae912bf44e8a8da1dbc59feaae4 ffdce0a453ae4703a94bba152ef38b89--7b6c3ae912bf44e8a8da1dbc59feaae4 4e33c136fa0e45cfbe63596ac2f14014 X 7b6c3ae912bf44e8a8da1dbc59feaae4--4e33c136fa0e45cfbe63596ac2f14014 4e33c136fa0e45cfbe63596ac2f14014--f16c879b837148e7a50a07834738476c b2f961b441b849c3a18e218d7c997814 RZ(-1.0*g1) 4e33c136fa0e45cfbe63596ac2f14014--b2f961b441b849c3a18e218d7c997814 4e4258636a8a4c87a2f9d3165c88cf86 X b2f961b441b849c3a18e218d7c997814--4e4258636a8a4c87a2f9d3165c88cf86 4e4258636a8a4c87a2f9d3165c88cf86--96d6c275ae0d4775a8e1c228749bc769 440634b9bc6d4d72b877e2bd8180029c 4e4258636a8a4c87a2f9d3165c88cf86--440634b9bc6d4d72b877e2bd8180029c 533925c7bb53449e948f1ff863a1aa48 440634b9bc6d4d72b877e2bd8180029c--533925c7bb53449e948f1ff863a1aa48 160c984b27f14ebc9540b6a636d72840 533925c7bb53449e948f1ff863a1aa48--160c984b27f14ebc9540b6a636d72840 a9fd53592ffb48ebafc2118bd63b424e 160c984b27f14ebc9540b6a636d72840--a9fd53592ffb48ebafc2118bd63b424e ccea489ce76c403982fb5a8d6dbe51db a9fd53592ffb48ebafc2118bd63b424e--ccea489ce76c403982fb5a8d6dbe51db aeb40db2573b4858914b528cd6c2408a ccea489ce76c403982fb5a8d6dbe51db--aeb40db2573b4858914b528cd6c2408a a3a2bcb2bd3a42df990295831693f1ab aeb40db2573b4858914b528cd6c2408a--a3a2bcb2bd3a42df990295831693f1ab 1a7b6295e4a94a6f81c0444230194a7d a3a2bcb2bd3a42df990295831693f1ab--1a7b6295e4a94a6f81c0444230194a7d 3ac0837a1b1d4a59b7bc6299bd2e27f3 1a7b6295e4a94a6f81c0444230194a7d--3ac0837a1b1d4a59b7bc6299bd2e27f3 74bd8968059d4dbd9feebfd2ce01e436 3ac0837a1b1d4a59b7bc6299bd2e27f3--74bd8968059d4dbd9feebfd2ce01e436 85531d537adb46898d779f143e0d8f68 74bd8968059d4dbd9feebfd2ce01e436--85531d537adb46898d779f143e0d8f68 9775fe642d90453995b317a095c21374 85531d537adb46898d779f143e0d8f68--9775fe642d90453995b317a095c21374 3b625a20bc8641faa9393c02719f696b X 9775fe642d90453995b317a095c21374--3b625a20bc8641faa9393c02719f696b 3b625a20bc8641faa9393c02719f696b--fe76c02f965c4d6fabbaa844ab2b4f65 dc4afb6c4208424ca38d393cff5be892 RZ(-1.0*g1) 3b625a20bc8641faa9393c02719f696b--dc4afb6c4208424ca38d393cff5be892 ba367b8cd4244bef9d7184879ed03177 X dc4afb6c4208424ca38d393cff5be892--ba367b8cd4244bef9d7184879ed03177 ba367b8cd4244bef9d7184879ed03177--15654be719ce46858fb8fd84a0fa8c51 3fd677cb4e084a468096efe136df7543 ba367b8cd4244bef9d7184879ed03177--3fd677cb4e084a468096efe136df7543 682ed6527b2f4333b0d305db6c3b19f4 3fd677cb4e084a468096efe136df7543--682ed6527b2f4333b0d305db6c3b19f4 7bead7c560614dbf8ff51e3f37598d33 682ed6527b2f4333b0d305db6c3b19f4--7bead7c560614dbf8ff51e3f37598d33 3c2499a3a9c34db2b8c4ecd9a577821f 7bead7c560614dbf8ff51e3f37598d33--3c2499a3a9c34db2b8c4ecd9a577821f 37020e72fd0c47d78f1e44a9d6a782c0 3c2499a3a9c34db2b8c4ecd9a577821f--37020e72fd0c47d78f1e44a9d6a782c0 bc9fe8f040dd4720a4c99e970276e66f 37020e72fd0c47d78f1e44a9d6a782c0--bc9fe8f040dd4720a4c99e970276e66f 1e4453be7a8e4c16ab60c0d6f976a89f bc9fe8f040dd4720a4c99e970276e66f--1e4453be7a8e4c16ab60c0d6f976a89f d68051dda7224b04bfb1bc7018db494a 1e4453be7a8e4c16ab60c0d6f976a89f--d68051dda7224b04bfb1bc7018db494a 06c74ac4cd2c4dda82920f7f09b1bc53 d68051dda7224b04bfb1bc7018db494a--06c74ac4cd2c4dda82920f7f09b1bc53 6fac8950ccb640c18a5661ce2c593f5f 06c74ac4cd2c4dda82920f7f09b1bc53--6fac8950ccb640c18a5661ce2c593f5f f8564a00de144d64875e6ca9c950b9e7 6fac8950ccb640c18a5661ce2c593f5f--f8564a00de144d64875e6ca9c950b9e7 8932c386a0f84cb2aaf3bc264f5a26e3 f8564a00de144d64875e6ca9c950b9e7--8932c386a0f84cb2aaf3bc264f5a26e3 49c2eba87c214ef095e550029e871e1e 8932c386a0f84cb2aaf3bc264f5a26e3--49c2eba87c214ef095e550029e871e1e d438e3be6cdc4e2bb6a6f6aa83de7e63 X 49c2eba87c214ef095e550029e871e1e--d438e3be6cdc4e2bb6a6f6aa83de7e63 d438e3be6cdc4e2bb6a6f6aa83de7e63--ce530826e01f4d41ae467255ed57897d 0036bd673f0f406a8cc6d321c2da9334 RZ(-1.0*g1) d438e3be6cdc4e2bb6a6f6aa83de7e63--0036bd673f0f406a8cc6d321c2da9334 e304d2885cf14b369c43c61184bf4b45 X 0036bd673f0f406a8cc6d321c2da9334--e304d2885cf14b369c43c61184bf4b45 e304d2885cf14b369c43c61184bf4b45--ae7ced29376448e2a8f94b41432e4bff d4ffa38e820a484abdb6341debfc9f08 e304d2885cf14b369c43c61184bf4b45--d4ffa38e820a484abdb6341debfc9f08 51ec6018296c4c029223114208a50ea8 d4ffa38e820a484abdb6341debfc9f08--51ec6018296c4c029223114208a50ea8 a5c1e58e8e6844b0bf1ec6bd412b4df7 51ec6018296c4c029223114208a50ea8--a5c1e58e8e6844b0bf1ec6bd412b4df7 8170f548053b40848f38c5d9517cc4fc a5c1e58e8e6844b0bf1ec6bd412b4df7--8170f548053b40848f38c5d9517cc4fc b7c47c6a3e4b4d37a4ed9280f419a916 8170f548053b40848f38c5d9517cc4fc--b7c47c6a3e4b4d37a4ed9280f419a916 8330a9d10b044101857c07e5fb296d72 b7c47c6a3e4b4d37a4ed9280f419a916--8330a9d10b044101857c07e5fb296d72 4166691a13e9439695931730ac703d62 X 8330a9d10b044101857c07e5fb296d72--4166691a13e9439695931730ac703d62 4166691a13e9439695931730ac703d62--079065bf717140cda4a303ec2d46cffe ae1ff82cf5e245f4960fbd12dc443c25 RZ(-1.0*g1) 4166691a13e9439695931730ac703d62--ae1ff82cf5e245f4960fbd12dc443c25 4fbfbd2352964fce96ea3f102d5bb43f X ae1ff82cf5e245f4960fbd12dc443c25--4fbfbd2352964fce96ea3f102d5bb43f 4fbfbd2352964fce96ea3f102d5bb43f--c93277bb14454248a2532e434cf3e47b 1e73378097e94dc8aa1678963887f46a 4fbfbd2352964fce96ea3f102d5bb43f--1e73378097e94dc8aa1678963887f46a 5d564089e7b5402796c413ba720af64a RX(b17) 1e73378097e94dc8aa1678963887f46a--5d564089e7b5402796c413ba720af64a 5d564089e7b5402796c413ba720af64a--d261571b8a20469ba87495dfd0ac7bcc"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\ntorch.manual_seed(seed)\ndef loss_function(_model: QuantumModel):\nexpval_ops = _model.expectation().squeeze()\n# this corresponds to the MaxCut cost by definition\n# with negative sign in front to perform maximization\nexpval = 0.0\nfor val in expval_ops:\nexpval += 0.5 * (1 - val)\nreturn -1.0 * expval\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n# train the model\nn_epochs = 100\nlr = 1.0\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\nfor i in range(n_epochs):\noptimizer.zero_grad()\nloss = loss_function(model)\nloss.backward()\noptimizer.step()\nif (i+1) % (n_epochs // 10) == 0:\nprint(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.240171725110143\nMaxCut cost at iteration 10: 10.312990602134034\nMaxCut cost at iteration 20: 10.987715802895353\nMaxCut cost at iteration 30: 10.99542024495118\nMaxCut cost at iteration 40: 10.993989370598293\nMaxCut cost at iteration 50: 10.997852988160199\nMaxCut cost at iteration 60: 10.999696316273003\nMaxCut cost at iteration 70: 10.999963032713957\nMaxCut cost at iteration 80: 10.999995559226681\nMaxCut cost at iteration 90: 10.999999462791724\nMaxCut cost at iteration 100: 10.999999934062107\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\ncolors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\nlabels[node] = \"A\" if int(b) == 0 else \"B\"\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 10101100  2023-11-13T15:11:54.517497 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\ndef qcl_training_data(\ndomain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\nstart, end = domain\nx_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\ny_rand = torch.sin(x_rand)\nreturn x_rand, y_rand\nx, y = qcl_training_data()\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\nn_qubits = 4\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n[0.1315],\n[0.2424],\n[0.1552],\n[0.1592],\n[0.2063],\n[0.1899],\n[0.2208],\n[0.2472],\n[0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\nfor i in range(n_epochs):\noptimizer.zero_grad()\n# given a `n_batch` number of input points and a `n_observables`\n# number of input observables to measure, the QNN returns\n# an output of the following shape: [n_batch x n_observables]\n# given that there is only one observable, a squeeze is applied to get\n# a 1-dimensional tensor\nloss = mse_loss(model(values=x_train).squeeze(), y_train)\nloss.backward()\noptimizer.step()\nif (i+1) % 20 == 0:\nprint(f\"Epoch {i+1} - Loss: {loss.item()}\")\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\ny_pred = model({\"phi\": x_test})\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-11-13T15:11:58.356244 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\nn_qubits = 3\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_9bdd034321ea4b5e86f8a3b3e35a6c6d Constant Chebyshev FM cluster_bffbbd6af270445292f5dd9d3cd7d7e3 Constant Fourier FM dedb52ba55384c6db4a2d35a1bdaad51 0 73077a5e9ca44e40a5f41abe5a16361d RX(phi) dedb52ba55384c6db4a2d35a1bdaad51--73077a5e9ca44e40a5f41abe5a16361d 04ef59b3e10e48aca3928df20bd64851 1 5a93532f667e4259916b5f1c8ce2288f RX(acos(phi)) 73077a5e9ca44e40a5f41abe5a16361d--5a93532f667e4259916b5f1c8ce2288f 8e0ce426bb15428da2d6be3fc179e2ad 5a93532f667e4259916b5f1c8ce2288f--8e0ce426bb15428da2d6be3fc179e2ad 722c2b13f1cd4dea93a5c6405edef966 5d3a793fc7014461ad471ac444f40694 RX(phi) 04ef59b3e10e48aca3928df20bd64851--5d3a793fc7014461ad471ac444f40694 0f8127fa9f614474abe856538a93f32d 2 2f307897a5ee4008bd14869ae029984a RX(acos(phi)) 5d3a793fc7014461ad471ac444f40694--2f307897a5ee4008bd14869ae029984a 2f307897a5ee4008bd14869ae029984a--722c2b13f1cd4dea93a5c6405edef966 c85933db9d16476095094ae5f09c1f84 ca3e42f915ee43f49f9822d19b6bd3d9 RX(phi) 0f8127fa9f614474abe856538a93f32d--ca3e42f915ee43f49f9822d19b6bd3d9 b35a7532d72242ba9d2efa5c60f1ac6c RX(acos(phi)) ca3e42f915ee43f49f9822d19b6bd3d9--b35a7532d72242ba9d2efa5c60f1ac6c b35a7532d72242ba9d2efa5c60f1ac6c--c85933db9d16476095094ae5f09c1f84 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\nn_qubits = 3\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n@classmethod\ndef eval(cls, x):\nreturn asin(x) + x**2\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_37b76e43bd4140e785e0373bae250221 Constant custom_func FM cluster_05ee7b2d5c584e8a81ba96d42c1e0472 Constant asin FM 4457d86454f04336af4bf33afb1c50d0 0 d1511ba33dd842f5b756cd5cabfc1227 RX(asin(phi)) 4457d86454f04336af4bf33afb1c50d0--d1511ba33dd842f5b756cd5cabfc1227 1b7e60b575884b3cb4823e12afd47325 1 528fe1f39f0b4afd8e9f177f20213501 RX(phi**2 + asin(phi)) d1511ba33dd842f5b756cd5cabfc1227--528fe1f39f0b4afd8e9f177f20213501 bfbf1126da554049bffea74423e5e760 528fe1f39f0b4afd8e9f177f20213501--bfbf1126da554049bffea74423e5e760 fd995f9a5c994ea1b6f284aaff92a188 deb6fce7996d49a59f2a166949cc02a8 RX(asin(phi)) 1b7e60b575884b3cb4823e12afd47325--deb6fce7996d49a59f2a166949cc02a8 2de5c121d7be4ea594f5b454e878ff88 2 c0bdd0f528784a55b7f66da0f375836a RX(phi**2 + asin(phi)) deb6fce7996d49a59f2a166949cc02a8--c0bdd0f528784a55b7f66da0f375836a c0bdd0f528784a55b7f66da0f375836a--fd995f9a5c994ea1b6f284aaff92a188 f31dc78e18b04307b9bce05fe934646d 0894ccf71b524c20bfe7731903a89e18 RX(asin(phi)) 2de5c121d7be4ea594f5b454e878ff88--0894ccf71b524c20bfe7731903a89e18 7670486b106d46b786cc1eb61536884a RX(phi**2 + asin(phi)) 0894ccf71b524c20bfe7731903a89e18--7670486b106d46b786cc1eb61536884a 7670486b106d46b786cc1eb61536884a--f31dc78e18b04307b9bce05fe934646d <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\nn_qubits = 5\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_cc61d2b72e464240bdb748983a2270b7 Exponential Fourier FM cluster_f068b57837b44f168bbee5dc631eb769 Constant Fourier FM cluster_04ac7187ceac41c1b50076b9dbb8e996 Tower Fourier FM 4473b30c125a464eb34ceeacafcf77ee 0 216e349c994d477aa8c081562d77bf10 RX(phi) 4473b30c125a464eb34ceeacafcf77ee--216e349c994d477aa8c081562d77bf10 f5c45a3f604a4910b3f88fb8542f7cbd 1 1d646e947573453abd839547b1c20f2e RX(1.0*phi) 216e349c994d477aa8c081562d77bf10--1d646e947573453abd839547b1c20f2e 712753094d3049faa550afaa2325eaea RX(1.0*phi) 1d646e947573453abd839547b1c20f2e--712753094d3049faa550afaa2325eaea 504598c1181d41f0b7fc49f26d2270ff 712753094d3049faa550afaa2325eaea--504598c1181d41f0b7fc49f26d2270ff 4d1406d1073745a6b0d8f2884a3397f4 41b3a27df0ad41e6a015b8efcd7d93fb RX(phi) f5c45a3f604a4910b3f88fb8542f7cbd--41b3a27df0ad41e6a015b8efcd7d93fb 6a7d5da3a4dc4e1b8cddd51c58b76efe 2 48fe28b648ca4f8f8b2a6773e0b8dedd RX(2.0*phi) 41b3a27df0ad41e6a015b8efcd7d93fb--48fe28b648ca4f8f8b2a6773e0b8dedd eb45715accf34151bfa002b34f80d4e8 RX(2.0*phi) 48fe28b648ca4f8f8b2a6773e0b8dedd--eb45715accf34151bfa002b34f80d4e8 eb45715accf34151bfa002b34f80d4e8--4d1406d1073745a6b0d8f2884a3397f4 708e39a999054ed88c5b22aee537bc3a e32ef531cfad428d8f396b7e63656e79 RX(phi) 6a7d5da3a4dc4e1b8cddd51c58b76efe--e32ef531cfad428d8f396b7e63656e79 6894a40179c24f8ab408509b537d916a 3 3259863fe91d4feeba0a4e36456b3b81 RX(3.0*phi) e32ef531cfad428d8f396b7e63656e79--3259863fe91d4feeba0a4e36456b3b81 7130383384584b37b34618cf6b357f9d RX(4.0*phi) 3259863fe91d4feeba0a4e36456b3b81--7130383384584b37b34618cf6b357f9d 7130383384584b37b34618cf6b357f9d--708e39a999054ed88c5b22aee537bc3a f80b088094444e4b842ccd39e8661873 93908fe5d56141d394c46f0fbd753fd4 RX(phi) 6894a40179c24f8ab408509b537d916a--93908fe5d56141d394c46f0fbd753fd4 ec92a3adc3ed48968e2440ad7f296294 4 cdfe80740c2143a4a3e9489007b6bb26 RX(4.0*phi) 93908fe5d56141d394c46f0fbd753fd4--cdfe80740c2143a4a3e9489007b6bb26 e58e5ff7daf94a9499ab53bfadd49a50 RX(8.0*phi) cdfe80740c2143a4a3e9489007b6bb26--e58e5ff7daf94a9499ab53bfadd49a50 e58e5ff7daf94a9499ab53bfadd49a50--f80b088094444e4b842ccd39e8661873 1c801655dc944f76889cdb0b677ddafc eebbccad852949dfb32425b02cae1de2 RX(phi) ec92a3adc3ed48968e2440ad7f296294--eebbccad852949dfb32425b02cae1de2 af2b0ae0a2664de2bb839f600b368d42 RX(5.0*phi) eebbccad852949dfb32425b02cae1de2--af2b0ae0a2664de2bb839f600b368d42 4be114e7f07044009bccbd3a330602b2 RX(16.0*phi) af2b0ae0a2664de2bb839f600b368d42--4be114e7f07044009bccbd3a330602b2 4be114e7f07044009bccbd3a330602b2--1c801655dc944f76889cdb0b677ddafc <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\ndef custom_scaling(i: int) -&gt; int | float:\n\"\"\"Sqrt(i+1)\"\"\"\nreturn (i+1) ** (0.5)\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 24f4ce6b27dc45fba58a8915b0096c14 0 9388eb4dfa484bf68bc369ebf4003beb RX(1.0*acos(phi)) 24f4ce6b27dc45fba58a8915b0096c14--9388eb4dfa484bf68bc369ebf4003beb 5fc4a68256be498799999ae93bfdaba8 1 51f559ece0c74e588e199bcd41bfea3e 9388eb4dfa484bf68bc369ebf4003beb--51f559ece0c74e588e199bcd41bfea3e e768c62fb52b4068addf6492b2744806 f64f188597994220a25ead80f55a576a RX(1.414*acos(phi)) 5fc4a68256be498799999ae93bfdaba8--f64f188597994220a25ead80f55a576a 7e49be8e98de473cb79b0094ee52a4c2 2 f64f188597994220a25ead80f55a576a--e768c62fb52b4068addf6492b2744806 d83136d848e744a6b8e3b26a047cdb9b dedbc8db28bf4339a64b3dbb99fe1de8 RX(1.732*acos(phi)) 7e49be8e98de473cb79b0094ee52a4c2--dedbc8db28bf4339a64b3dbb99fe1de8 4ba9ee5480aa4d7ea9c6cd4941a23dbf 3 dedbc8db28bf4339a64b3dbb99fe1de8--d83136d848e744a6b8e3b26a047cdb9b 567f924d344446f4a7b38b5e70d68b02 b3d30d9aaf494a6d8295e69f6cde3492 RX(2.0*acos(phi)) 4ba9ee5480aa4d7ea9c6cd4941a23dbf--b3d30d9aaf494a6d8295e69f6cde3492 395391d799964f3fab296aa298ccdb12 4 b3d30d9aaf494a6d8295e69f6cde3492--567f924d344446f4a7b38b5e70d68b02 0806f2f5899c4d1a910444fe12eec46c 168d9e2e262a48669706119148204833 RX(2.236*acos(phi)) 395391d799964f3fab296aa298ccdb12--168d9e2e262a48669706119148204833 168d9e2e262a48669706119148204833--0806f2f5899c4d1a910444fe12eec46c <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\nn_qubits = 5\n# Custom scaling function\nfm_full = feature_map(\nn_qubits = n_qubits,\nsupport = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\nparam = \"x\", # Change the name of the parameter\nop = RY, # Change the rotation gate between RX, RY, RZ or PHASE\nfm_type = BasisSet.CHEBYSHEV,\nreupload_scaling = ReuploadScaling.EXP,\nfeature_range = (-1.0, 2.0), # Range from which the input data comes from\ntarget_range = (1.0, 3.0), # Range the encoder assumes as the natural range\nmultiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 f59e92d5cb0c4566b9a2e004971ae8d5 0 580c6cc17fc440f48a5511dd71ff8a88 RY(80.0*acos(0.667*x + 1.667)) f59e92d5cb0c4566b9a2e004971ae8d5--580c6cc17fc440f48a5511dd71ff8a88 f33ba6ad47b9431cba2b53a573a1eb24 1 4b2ca6275a6b472f9927635830c5c375 580c6cc17fc440f48a5511dd71ff8a88--4b2ca6275a6b472f9927635830c5c375 87636a2b39684ea9b24b51f8d3c7123b 4089deda20674c2b9619e0775e4b9007 RY(40.0*acos(0.667*x + 1.667)) f33ba6ad47b9431cba2b53a573a1eb24--4089deda20674c2b9619e0775e4b9007 58027cf9506c4cbcae0b29b39e514f6b 2 4089deda20674c2b9619e0775e4b9007--87636a2b39684ea9b24b51f8d3c7123b e3bf57ba79214db199035f358cce4be1 83e53199dc974b19af9db16c700412af RY(20.0*acos(0.667*x + 1.667)) 58027cf9506c4cbcae0b29b39e514f6b--83e53199dc974b19af9db16c700412af f374aa32ec2d4833a1f4a97e5b99d8a6 3 83e53199dc974b19af9db16c700412af--e3bf57ba79214db199035f358cce4be1 d28d03e56d7f4cf3aad8a86fb5d02cc8 178a87d9c56f4f7b95406ce4f1a8bed4 RY(10.0*acos(0.667*x + 1.667)) f374aa32ec2d4833a1f4a97e5b99d8a6--178a87d9c56f4f7b95406ce4f1a8bed4 8a23d5aa94204be2bb816a7e5a049fd7 4 178a87d9c56f4f7b95406ce4f1a8bed4--d28d03e56d7f4cf3aad8a86fb5d02cc8 c791bb3106ee44dfb5e5969a72cecde0 f42bd42f72f54906ae3b25a08dd7140c RY(5.0*acos(0.667*x + 1.667)) 8a23d5aa94204be2bb816a7e5a049fd7--f42bd42f72f54906ae3b25a08dd7140c f42bd42f72f54906ae3b25a08dd7140c--c791bb3106ee44dfb5e5969a72cecde0"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\nn_qubits = 3\ndepth = 2\nansatz = hea(n_qubits, depth)\n</code></pre> %3 d2259a55539048c6a6a2276f8e8ff46d 0 fd68a7e067904a3fabd9cad4ab990839 RX(theta\u2080) d2259a55539048c6a6a2276f8e8ff46d--fd68a7e067904a3fabd9cad4ab990839 a52ba28c7c00472f92a9dd11e5339ada 1 3b1e8c8ad7c0473186c5cccdd05235cd RY(theta\u2083) fd68a7e067904a3fabd9cad4ab990839--3b1e8c8ad7c0473186c5cccdd05235cd cf8c82eb0aba4800b4c5a96daa4bee16 RX(theta\u2086) 3b1e8c8ad7c0473186c5cccdd05235cd--cf8c82eb0aba4800b4c5a96daa4bee16 2e50841badd9459f8ee5450d4d8405b0 cf8c82eb0aba4800b4c5a96daa4bee16--2e50841badd9459f8ee5450d4d8405b0 3f640339f5eb40118e071e0753306ba5 2e50841badd9459f8ee5450d4d8405b0--3f640339f5eb40118e071e0753306ba5 070319e8d44b4176b1890b68e8d0bac1 RX(theta\u2089) 3f640339f5eb40118e071e0753306ba5--070319e8d44b4176b1890b68e8d0bac1 7574ce13943f4350bb5fb24ec635e883 RY(theta\u2081\u2082) 070319e8d44b4176b1890b68e8d0bac1--7574ce13943f4350bb5fb24ec635e883 03ab0f47e67e4647a743fb0527f2f061 RX(theta\u2081\u2085) 7574ce13943f4350bb5fb24ec635e883--03ab0f47e67e4647a743fb0527f2f061 dbf078c162df4ea687ad278805af7567 03ab0f47e67e4647a743fb0527f2f061--dbf078c162df4ea687ad278805af7567 7e7241c130d04f9fb32d7183dcab1734 dbf078c162df4ea687ad278805af7567--7e7241c130d04f9fb32d7183dcab1734 d23af25c780848f6a445ecba728d56e1 7e7241c130d04f9fb32d7183dcab1734--d23af25c780848f6a445ecba728d56e1 88f405e20a264bcea64f29e235814e7e 5bda83cf84334f6490f11948ddf784d6 RX(theta\u2081) a52ba28c7c00472f92a9dd11e5339ada--5bda83cf84334f6490f11948ddf784d6 4765fcd8c3bd444ebcc74430aab81631 2 62328fee5df74d9aacdf7cad7c1d7102 RY(theta\u2084) 5bda83cf84334f6490f11948ddf784d6--62328fee5df74d9aacdf7cad7c1d7102 89b0eabfc2ea42a1a5801b96bbbe0e29 RX(theta\u2087) 62328fee5df74d9aacdf7cad7c1d7102--89b0eabfc2ea42a1a5801b96bbbe0e29 929b43df1989476c98b0bd0af7ae2b7a X 89b0eabfc2ea42a1a5801b96bbbe0e29--929b43df1989476c98b0bd0af7ae2b7a 929b43df1989476c98b0bd0af7ae2b7a--2e50841badd9459f8ee5450d4d8405b0 59eadf3ea15748f0b24cde44dc9a196f 929b43df1989476c98b0bd0af7ae2b7a--59eadf3ea15748f0b24cde44dc9a196f 3ae58632a1884c39bb93e3d9948887e4 RX(theta\u2081\u2080) 59eadf3ea15748f0b24cde44dc9a196f--3ae58632a1884c39bb93e3d9948887e4 75b2e81d6d0646a6985b05a73cad4625 RY(theta\u2081\u2083) 3ae58632a1884c39bb93e3d9948887e4--75b2e81d6d0646a6985b05a73cad4625 5d1ea5785c9944189c2794219b1277f7 RX(theta\u2081\u2086) 75b2e81d6d0646a6985b05a73cad4625--5d1ea5785c9944189c2794219b1277f7 14d3553f1282488781b24c62334fc8c7 X 5d1ea5785c9944189c2794219b1277f7--14d3553f1282488781b24c62334fc8c7 14d3553f1282488781b24c62334fc8c7--dbf078c162df4ea687ad278805af7567 0007afce5f6546baaff3fd1321f3186a 14d3553f1282488781b24c62334fc8c7--0007afce5f6546baaff3fd1321f3186a 0007afce5f6546baaff3fd1321f3186a--88f405e20a264bcea64f29e235814e7e 4192dab7c42d487fa1c77cf284318d75 84c1f8c7158f4af9a5e87161dc8b7269 RX(theta\u2082) 4765fcd8c3bd444ebcc74430aab81631--84c1f8c7158f4af9a5e87161dc8b7269 eda6055ec5cc4d5689b1fac26cbb9722 RY(theta\u2085) 84c1f8c7158f4af9a5e87161dc8b7269--eda6055ec5cc4d5689b1fac26cbb9722 a00847073a054cf9b0ca16cb5b6f2825 RX(theta\u2088) eda6055ec5cc4d5689b1fac26cbb9722--a00847073a054cf9b0ca16cb5b6f2825 db5794eda399486c8452f85fd8122f6f a00847073a054cf9b0ca16cb5b6f2825--db5794eda399486c8452f85fd8122f6f 26d6f609c24640f1b068b107ee24da8f X db5794eda399486c8452f85fd8122f6f--26d6f609c24640f1b068b107ee24da8f 26d6f609c24640f1b068b107ee24da8f--59eadf3ea15748f0b24cde44dc9a196f a40d8080eb414603bfce2dfefc72d7ff RX(theta\u2081\u2081) 26d6f609c24640f1b068b107ee24da8f--a40d8080eb414603bfce2dfefc72d7ff f959251a2dac4de080f0679390bcfeda RY(theta\u2081\u2084) a40d8080eb414603bfce2dfefc72d7ff--f959251a2dac4de080f0679390bcfeda 47bb2fe55f1e43d188e466f5ba417105 RX(theta\u2081\u2087) f959251a2dac4de080f0679390bcfeda--47bb2fe55f1e43d188e466f5ba417105 e106e8884b954c358d2a89e4ac075332 47bb2fe55f1e43d188e466f5ba417105--e106e8884b954c358d2a89e4ac075332 1925b14d4fb74e3d9211669cd419e011 X e106e8884b954c358d2a89e4ac075332--1925b14d4fb74e3d9211669cd419e011 1925b14d4fb74e3d9211669cd419e011--0007afce5f6546baaff3fd1321f3186a 1925b14d4fb74e3d9211669cd419e011--4192dab7c42d487fa1c77cf284318d75 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\nansatz = hea(\nn_qubits=n_qubits,\ndepth=depth,\nparam_prefix=\"phi\",\noperations=[RX, RY, RX],\nentangler=CPHASE\n)\n</code></pre> %3 61bebd38e5d94ad49172e0b547917b00 0 eb5d79deabca44288417a9601fc7e77d RX(phi\u2080) 61bebd38e5d94ad49172e0b547917b00--eb5d79deabca44288417a9601fc7e77d aad8bd092d6f496aa1c3d1c5b25fa659 1 c2b8f51e85fe4aadbf58983db73e8cda RY(phi\u2083) eb5d79deabca44288417a9601fc7e77d--c2b8f51e85fe4aadbf58983db73e8cda 70442ef111d24d439e386edba16408c4 RX(phi\u2086) c2b8f51e85fe4aadbf58983db73e8cda--70442ef111d24d439e386edba16408c4 9287a22c0a1949ad9074dd6c1980cea4 70442ef111d24d439e386edba16408c4--9287a22c0a1949ad9074dd6c1980cea4 84773c06045b427f97ddd364ba8646d2 9287a22c0a1949ad9074dd6c1980cea4--84773c06045b427f97ddd364ba8646d2 2d92482973164b4291d90fadde7f404f RX(phi\u2089) 84773c06045b427f97ddd364ba8646d2--2d92482973164b4291d90fadde7f404f fcb77d20877949638bbcaaa600f38437 RY(phi\u2081\u2082) 2d92482973164b4291d90fadde7f404f--fcb77d20877949638bbcaaa600f38437 de4f2ff0f4084dd2955487141e39d678 RX(phi\u2081\u2085) fcb77d20877949638bbcaaa600f38437--de4f2ff0f4084dd2955487141e39d678 847e91f0ee5e45e08ca22ab1861057e7 de4f2ff0f4084dd2955487141e39d678--847e91f0ee5e45e08ca22ab1861057e7 fee5bf0a5ec44066812b289e8969cc78 847e91f0ee5e45e08ca22ab1861057e7--fee5bf0a5ec44066812b289e8969cc78 10ae12d729e6455da060e82a5ac72032 fee5bf0a5ec44066812b289e8969cc78--10ae12d729e6455da060e82a5ac72032 ced4d9af081e491dbe43490bb6ac9cb2 fb9436a4da7e475f8b40ad64fbc4daf3 RX(phi\u2081) aad8bd092d6f496aa1c3d1c5b25fa659--fb9436a4da7e475f8b40ad64fbc4daf3 2ad1af5f9de042dba509b9e19054c68e 2 3ca2248c0f3e4684b14f856595e167cc RY(phi\u2084) fb9436a4da7e475f8b40ad64fbc4daf3--3ca2248c0f3e4684b14f856595e167cc 3cb5b046d45d470ea2b811859033d405 RX(phi\u2087) 3ca2248c0f3e4684b14f856595e167cc--3cb5b046d45d470ea2b811859033d405 eae61a38b17047fd9823ccdff5b36fe3 PHASE(phi_ent\u2080) 3cb5b046d45d470ea2b811859033d405--eae61a38b17047fd9823ccdff5b36fe3 eae61a38b17047fd9823ccdff5b36fe3--9287a22c0a1949ad9074dd6c1980cea4 7047d755140949d99a48a6d80f2b5bb5 eae61a38b17047fd9823ccdff5b36fe3--7047d755140949d99a48a6d80f2b5bb5 ed2af1677e0f4dacbf59122a7fe0806f RX(phi\u2081\u2080) 7047d755140949d99a48a6d80f2b5bb5--ed2af1677e0f4dacbf59122a7fe0806f 39d1f6122c00403db723b9c03d571098 RY(phi\u2081\u2083) ed2af1677e0f4dacbf59122a7fe0806f--39d1f6122c00403db723b9c03d571098 2c64adaba3ac4e18a6cd8788113d0d58 RX(phi\u2081\u2086) 39d1f6122c00403db723b9c03d571098--2c64adaba3ac4e18a6cd8788113d0d58 5bb3ea58520f4b989dc164e554aa3cfb PHASE(phi_ent\u2082) 2c64adaba3ac4e18a6cd8788113d0d58--5bb3ea58520f4b989dc164e554aa3cfb 5bb3ea58520f4b989dc164e554aa3cfb--847e91f0ee5e45e08ca22ab1861057e7 533278c33dd54a06ada463cfb74232e3 5bb3ea58520f4b989dc164e554aa3cfb--533278c33dd54a06ada463cfb74232e3 533278c33dd54a06ada463cfb74232e3--ced4d9af081e491dbe43490bb6ac9cb2 c260b5b95c9547a4a50fff5c359cf49b 82e0facfdedf493491abef373d814a60 RX(phi\u2082) 2ad1af5f9de042dba509b9e19054c68e--82e0facfdedf493491abef373d814a60 ef35ee22d89c49b6ac0262d0ee0f80e6 RY(phi\u2085) 82e0facfdedf493491abef373d814a60--ef35ee22d89c49b6ac0262d0ee0f80e6 03df4b570e744826a6312aed94505925 RX(phi\u2088) ef35ee22d89c49b6ac0262d0ee0f80e6--03df4b570e744826a6312aed94505925 2514c17de967427da69a48193cd70c5c 03df4b570e744826a6312aed94505925--2514c17de967427da69a48193cd70c5c 83def89e63e1438f97b3ce8fa61f609e PHASE(phi_ent\u2081) 2514c17de967427da69a48193cd70c5c--83def89e63e1438f97b3ce8fa61f609e 83def89e63e1438f97b3ce8fa61f609e--7047d755140949d99a48a6d80f2b5bb5 668fe63b9d12408587cbc23c2cb19bfe RX(phi\u2081\u2081) 83def89e63e1438f97b3ce8fa61f609e--668fe63b9d12408587cbc23c2cb19bfe 82a72267debe4fd1be4889089f71fbf4 RY(phi\u2081\u2084) 668fe63b9d12408587cbc23c2cb19bfe--82a72267debe4fd1be4889089f71fbf4 e93f776311d64f14b3d7d65535e7dafe RX(phi\u2081\u2087) 82a72267debe4fd1be4889089f71fbf4--e93f776311d64f14b3d7d65535e7dafe 21cffc268f7f4cfbaacc8c09a10b5f0f e93f776311d64f14b3d7d65535e7dafe--21cffc268f7f4cfbaacc8c09a10b5f0f 76309e6b70cd45ec8aacd43a2bbf771b PHASE(phi_ent\u2083) 21cffc268f7f4cfbaacc8c09a10b5f0f--76309e6b70cd45ec8aacd43a2bbf771b 76309e6b70cd45ec8aacd43a2bbf771b--533278c33dd54a06ada463cfb74232e3 76309e6b70cd45ec8aacd43a2bbf771b--c260b5b95c9547a4a50fff5c359cf49b <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\nansatz = hea(\nn_qubits,\ndepth=depth,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_09123db1b81449139ca640591f602d50 cluster_4aa71dc301bd433da9b55301e00969aa 99b6a3ca556c4530b684d89da3fb8a6b 0 64539e01f2144eeea162cdff8a347191 RX(theta\u2080) 99b6a3ca556c4530b684d89da3fb8a6b--64539e01f2144eeea162cdff8a347191 b6e7cd9e4bd44176bb7405530d3da1bb 1 a76072a5f07049829561ea21b4573c6e RY(theta\u2083) 64539e01f2144eeea162cdff8a347191--a76072a5f07049829561ea21b4573c6e b80cdcace146456b95dbf0e53b764620 RX(theta\u2086) a76072a5f07049829561ea21b4573c6e--b80cdcace146456b95dbf0e53b764620 d242c6b4aba44b759206596786cc7108 HamEvo b80cdcace146456b95dbf0e53b764620--d242c6b4aba44b759206596786cc7108 67953a599e5d45cd8bba5548818935eb RX(theta\u2089) d242c6b4aba44b759206596786cc7108--67953a599e5d45cd8bba5548818935eb 1e8a740f4fbe43fbb0b83fed32c96d57 RY(theta\u2081\u2082) 67953a599e5d45cd8bba5548818935eb--1e8a740f4fbe43fbb0b83fed32c96d57 8beed8876cb347f8a9887c1697eada79 RX(theta\u2081\u2085) 1e8a740f4fbe43fbb0b83fed32c96d57--8beed8876cb347f8a9887c1697eada79 b8317003112b4b64aa25bf1812f1f324 HamEvo 8beed8876cb347f8a9887c1697eada79--b8317003112b4b64aa25bf1812f1f324 652dfed76b2545e5bb8c23e57d27afd3 b8317003112b4b64aa25bf1812f1f324--652dfed76b2545e5bb8c23e57d27afd3 8e3334c97d1248468d11d181ba706d52 301e2d7e4acb42f4ade7cc51a51c8159 RX(theta\u2081) b6e7cd9e4bd44176bb7405530d3da1bb--301e2d7e4acb42f4ade7cc51a51c8159 24a591be413c47eb94e793d7ee33685c 2 b6de5287f6b543058bd129b67d76c0ff RY(theta\u2084) 301e2d7e4acb42f4ade7cc51a51c8159--b6de5287f6b543058bd129b67d76c0ff ddc7caf8a6104245aefc42759878e584 RX(theta\u2087) b6de5287f6b543058bd129b67d76c0ff--ddc7caf8a6104245aefc42759878e584 375625ec54b44a628d3992714639af0d t = theta_t\u2080 ddc7caf8a6104245aefc42759878e584--375625ec54b44a628d3992714639af0d cf3583cf2e4240c8b974f2bf822969e9 RX(theta\u2081\u2080) 375625ec54b44a628d3992714639af0d--cf3583cf2e4240c8b974f2bf822969e9 c0175209f918449ab1694f7b423f8843 RY(theta\u2081\u2083) cf3583cf2e4240c8b974f2bf822969e9--c0175209f918449ab1694f7b423f8843 9189db1a2f13477084294bacbacd4417 RX(theta\u2081\u2086) c0175209f918449ab1694f7b423f8843--9189db1a2f13477084294bacbacd4417 3ae31869fc114127961d837da459c8f1 t = theta_t\u2081 9189db1a2f13477084294bacbacd4417--3ae31869fc114127961d837da459c8f1 3ae31869fc114127961d837da459c8f1--8e3334c97d1248468d11d181ba706d52 2ad5793def3c4a459a2d7bc0503cebcf dffd40972b114290b48e062febfd9bd1 RX(theta\u2082) 24a591be413c47eb94e793d7ee33685c--dffd40972b114290b48e062febfd9bd1 9fa3d7cccd474466a6f77749213b1f98 RY(theta\u2085) dffd40972b114290b48e062febfd9bd1--9fa3d7cccd474466a6f77749213b1f98 e2598082f88345758f998dd314e5938b RX(theta\u2088) 9fa3d7cccd474466a6f77749213b1f98--e2598082f88345758f998dd314e5938b 3ac848840abc46e8947fda7f80777f53 e2598082f88345758f998dd314e5938b--3ac848840abc46e8947fda7f80777f53 c7d452f839c14acda16ea79af28fa18b RX(theta\u2081\u2081) 3ac848840abc46e8947fda7f80777f53--c7d452f839c14acda16ea79af28fa18b 79d9976e64204990a8a535d4d798eb87 RY(theta\u2081\u2084) c7d452f839c14acda16ea79af28fa18b--79d9976e64204990a8a535d4d798eb87 32531c27974f4c058eacf182f618c136 RX(theta\u2081\u2087) 79d9976e64204990a8a535d4d798eb87--32531c27974f4c058eacf182f618c136 d717d8e14e6f4deb85fb0be4cf4ad65b 32531c27974f4c058eacf182f618c136--d717d8e14e6f4deb85fb0be4cf4ad65b d717d8e14e6f4deb85fb0be4cf4ad65b--2ad5793def3c4a459a2d7bc0503cebcf <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\nentangler = hamiltonian_factory(\nregister,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"e\",\ndetuning_strength=\"n\"\n)\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\nansatz = hea(\nn_qubits=register.n_qubits,\ndepth=depth,\noperations=[RX, RY, RX],\nentangler=entangler,\nstrategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_479105c721c049d4896926f0ffa5e590 cluster_af96d05c946c4362a78aa26c1c05b0fa ba77cc39701c4292be86eec4063078f8 0 3a9cac7628fc44c1afbb8a68f3889353 RX(theta\u2080) ba77cc39701c4292be86eec4063078f8--3a9cac7628fc44c1afbb8a68f3889353 e54c29aabfd6412b93daa191e4d2d166 1 d8c430b5f95644e284e8d18359f980b3 RY(theta\u2086) 3a9cac7628fc44c1afbb8a68f3889353--d8c430b5f95644e284e8d18359f980b3 4b76cc56fef94f62adda66c04b19d081 RX(theta\u2081\u2082) d8c430b5f95644e284e8d18359f980b3--4b76cc56fef94f62adda66c04b19d081 e70c9d0847e940e19329917ba6b57569 4b76cc56fef94f62adda66c04b19d081--e70c9d0847e940e19329917ba6b57569 590f42b026aa4e6a806208e13bb57143 RX(theta\u2081\u2088) e70c9d0847e940e19329917ba6b57569--590f42b026aa4e6a806208e13bb57143 ab83b3debfe84edca64e24747a25087a RY(theta\u2082\u2084) 590f42b026aa4e6a806208e13bb57143--ab83b3debfe84edca64e24747a25087a da928dca407d4b40bbb2564eff4dfc7d RX(theta\u2083\u2080) ab83b3debfe84edca64e24747a25087a--da928dca407d4b40bbb2564eff4dfc7d cce56dc7f52847e8b0d77b2bd711d410 da928dca407d4b40bbb2564eff4dfc7d--cce56dc7f52847e8b0d77b2bd711d410 97d9be8f335148068fa3cfaa931cea29 cce56dc7f52847e8b0d77b2bd711d410--97d9be8f335148068fa3cfaa931cea29 5a27d72a78924a4f80bfef474c9401a2 187e5e035632415dbe1c8dc5bdb55cf1 RX(theta\u2081) e54c29aabfd6412b93daa191e4d2d166--187e5e035632415dbe1c8dc5bdb55cf1 9267f8b9db2b43e7863acebbbf32de78 2 63bc06c68a6b428291a2016422826489 RY(theta\u2087) 187e5e035632415dbe1c8dc5bdb55cf1--63bc06c68a6b428291a2016422826489 abd8e25367dc4f73905b007127fd1963 RX(theta\u2081\u2083) 63bc06c68a6b428291a2016422826489--abd8e25367dc4f73905b007127fd1963 d63d23a3ca89463a90d328d21b3b88d2 abd8e25367dc4f73905b007127fd1963--d63d23a3ca89463a90d328d21b3b88d2 c020f0b8cebf45d09a8a9640c4f0b378 RX(theta\u2081\u2089) d63d23a3ca89463a90d328d21b3b88d2--c020f0b8cebf45d09a8a9640c4f0b378 7305ce5841ec473fab5b6808684c49a7 RY(theta\u2082\u2085) c020f0b8cebf45d09a8a9640c4f0b378--7305ce5841ec473fab5b6808684c49a7 58a5f1782e434d99ac3caa9384765a90 RX(theta\u2083\u2081) 7305ce5841ec473fab5b6808684c49a7--58a5f1782e434d99ac3caa9384765a90 46806b94779e434e89063855ff4fa6af 58a5f1782e434d99ac3caa9384765a90--46806b94779e434e89063855ff4fa6af 46806b94779e434e89063855ff4fa6af--5a27d72a78924a4f80bfef474c9401a2 8eaf99cd4668459bb8cb89c9aecbaaf1 9105b4405dd44c85aa85f9422c3a9734 RX(theta\u2082) 9267f8b9db2b43e7863acebbbf32de78--9105b4405dd44c85aa85f9422c3a9734 13ec193725654481941bdd50803318e1 3 7552ed23eb3249afbe4096dd03010b80 RY(theta\u2088) 9105b4405dd44c85aa85f9422c3a9734--7552ed23eb3249afbe4096dd03010b80 d675f72bd7014cf7922abba7a21ad6c4 RX(theta\u2081\u2084) 7552ed23eb3249afbe4096dd03010b80--d675f72bd7014cf7922abba7a21ad6c4 162762cc871f40bc89a97018619d4145 HamEvo d675f72bd7014cf7922abba7a21ad6c4--162762cc871f40bc89a97018619d4145 d1e479939d0d4975a13ea049870fbd34 RX(theta\u2082\u2080) 162762cc871f40bc89a97018619d4145--d1e479939d0d4975a13ea049870fbd34 9c927ec69602420c9b0bf1d4c1f889d1 RY(theta\u2082\u2086) d1e479939d0d4975a13ea049870fbd34--9c927ec69602420c9b0bf1d4c1f889d1 cdabca294d524a60ba068788c27dcb5b RX(theta\u2083\u2082) 9c927ec69602420c9b0bf1d4c1f889d1--cdabca294d524a60ba068788c27dcb5b ec59d98453b644389b9a73750148edc5 HamEvo cdabca294d524a60ba068788c27dcb5b--ec59d98453b644389b9a73750148edc5 ec59d98453b644389b9a73750148edc5--8eaf99cd4668459bb8cb89c9aecbaaf1 3c25a4e0b49043beb1256eabf7025ded 27f98ca04ddf426b83f13bdf61efb798 RX(theta\u2083) 13ec193725654481941bdd50803318e1--27f98ca04ddf426b83f13bdf61efb798 3b070694fc364f93b04320149af94488 4 4d44af7ede7e433495a1d7ef6b996f13 RY(theta\u2089) 27f98ca04ddf426b83f13bdf61efb798--4d44af7ede7e433495a1d7ef6b996f13 255a5b8065a14817824fa563e6f7594f RX(theta\u2081\u2085) 4d44af7ede7e433495a1d7ef6b996f13--255a5b8065a14817824fa563e6f7594f 55a3b2858b9245cba3d12c5079b9dde7 t = theta_t\u2080 255a5b8065a14817824fa563e6f7594f--55a3b2858b9245cba3d12c5079b9dde7 6d4defc97a1146ae83e3ce87ec0c7b16 RX(theta\u2082\u2081) 55a3b2858b9245cba3d12c5079b9dde7--6d4defc97a1146ae83e3ce87ec0c7b16 d68e46a4f2bf40c5baaa780c8e992a82 RY(theta\u2082\u2087) 6d4defc97a1146ae83e3ce87ec0c7b16--d68e46a4f2bf40c5baaa780c8e992a82 3a1117a04b4d474e9a5ec7cfb5aaf687 RX(theta\u2083\u2083) d68e46a4f2bf40c5baaa780c8e992a82--3a1117a04b4d474e9a5ec7cfb5aaf687 e959bffa1c824ca8b4c5ce915cacf256 t = theta_t\u2081 3a1117a04b4d474e9a5ec7cfb5aaf687--e959bffa1c824ca8b4c5ce915cacf256 e959bffa1c824ca8b4c5ce915cacf256--3c25a4e0b49043beb1256eabf7025ded 011fa407cc3b407bba6969f78b1025a9 7e1fd123b612427e9e9757a70e636ab6 RX(theta\u2084) 3b070694fc364f93b04320149af94488--7e1fd123b612427e9e9757a70e636ab6 30baf6c51d0b45729742ff484478638f 5 af18c1e63ef544efab840b10ec404481 RY(theta\u2081\u2080) 7e1fd123b612427e9e9757a70e636ab6--af18c1e63ef544efab840b10ec404481 34f0ab8764bf48688b1b0824af5ee712 RX(theta\u2081\u2086) af18c1e63ef544efab840b10ec404481--34f0ab8764bf48688b1b0824af5ee712 c22bbc432d6c45f19649cbf24da5c810 34f0ab8764bf48688b1b0824af5ee712--c22bbc432d6c45f19649cbf24da5c810 9b78f42f52e44988bed3af185b9eab65 RX(theta\u2082\u2082) c22bbc432d6c45f19649cbf24da5c810--9b78f42f52e44988bed3af185b9eab65 11e2b3275aa7431bb87a4c7e482684f9 RY(theta\u2082\u2088) 9b78f42f52e44988bed3af185b9eab65--11e2b3275aa7431bb87a4c7e482684f9 0b6d2591adad41e181b80dbbc35d7efd RX(theta\u2083\u2084) 11e2b3275aa7431bb87a4c7e482684f9--0b6d2591adad41e181b80dbbc35d7efd 45d6b3f981374d17a7e0aa162d39d300 0b6d2591adad41e181b80dbbc35d7efd--45d6b3f981374d17a7e0aa162d39d300 45d6b3f981374d17a7e0aa162d39d300--011fa407cc3b407bba6969f78b1025a9 a4f5a15c14e54906b0f8745178b50a77 5d6513dd18994aae9c027e18e56b83ab RX(theta\u2085) 30baf6c51d0b45729742ff484478638f--5d6513dd18994aae9c027e18e56b83ab 4f2efc36587748abb71687db563a75ec RY(theta\u2081\u2081) 5d6513dd18994aae9c027e18e56b83ab--4f2efc36587748abb71687db563a75ec b141d230f25347a3b01f376916844673 RX(theta\u2081\u2087) 4f2efc36587748abb71687db563a75ec--b141d230f25347a3b01f376916844673 b0163419a98142c7b3aba1502da0c9fc b141d230f25347a3b01f376916844673--b0163419a98142c7b3aba1502da0c9fc a830567a2b134c468c7603aed9977f48 RX(theta\u2082\u2083) b0163419a98142c7b3aba1502da0c9fc--a830567a2b134c468c7603aed9977f48 dd9b6c6670714f228cd42e08ec0c0b38 RY(theta\u2082\u2089) a830567a2b134c468c7603aed9977f48--dd9b6c6670714f228cd42e08ec0c0b38 17da49f6f1dd46bdbe70be5bff07125a RX(theta\u2083\u2085) dd9b6c6670714f228cd42e08ec0c0b38--17da49f6f1dd46bdbe70be5bff07125a f8bdbbce5f724dbab335d2f0764f7394 17da49f6f1dd46bdbe70be5bff07125a--f8bdbbce5f724dbab335d2f0764f7394 f8bdbbce5f724dbab335d2f0764f7394--a4f5a15c14e54906b0f8745178b50a77"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>This section introduces the various measurement protocols.</p>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>This section introduces mitigation protocols.</p>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 51, '00': 49})]\nnoisy = [Counter({'00': 47, '10': 42, '01': 7, '11': 4})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0022]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9704]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\nRX(0, 3 * x),\nRX(0, x),\nRZ(1, sympy.exp(y)),\nRX(0, 3.14),\nRZ(1, \"theta\")\n)\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\ncircuit = QuantumCircuit(2, block)\nobservable = Z(0)\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n# Compute expectation.\nexp = model.expectation(values)\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1,2)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n\u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 KronBlock(1,2)\n\u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': c86d4d88-e6c0-41f2-aad5-2db303dcc910, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': 34649d1c-c44e-4095-87f3-3d0cd9907418, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': aeba9a25-4344-4287-a978-d7e33c81abb3, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 4781b958-e7b2-4758-93b1-bebf95610fe0, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 024a459a-cacb-4a1a-91bc-eafe85885d17, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': dc4d9b72-6c1c-4e4d-b9d8-a9259b1f4755, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 00c900e0-5b78-4b69-b8f9-081a3a06c54c, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 26c753d1-70d9-4f66-b0af-598c9ba4cb71, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ed9c7d09-3fd4-4af3-9e08-381688b0d9ab, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': ece2a23b-3f0f-455c-94b7-900da32eeb4f, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c8bb2621-a133-4e7e-913a-362ab64e8233, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n# Contains fixed parameters and variational (from the HEA)\nconv.params\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\ntheta_4: tensor([0.5653], requires_grad=True)\ntheta_6: tensor([0.4400], requires_grad=True)\ntheta_8: tensor([0.4669], requires_grad=True)\ntheta_0: tensor([0.7204], requires_grad=True)\ntheta_7: tensor([0.3154], requires_grad=True)\ntheta_5: tensor([0.7221], requires_grad=True)\ntheta_2: tensor([0.9389], requires_grad=True)\ntheta_3: tensor([0.9021], requires_grad=True)\ntheta_1: tensor([0.9737], requires_grad=True)\n}\nembedded = {\nc86d4d88-e6c0-41f2-aad5-2db303dcc910: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n34649d1c-c44e-4095-87f3-3d0cd9907418: tensor([2., 2.])\naeba9a25-4344-4287-a978-d7e33c81abb3: tensor([0.7204], grad_fn=&lt;ViewBackward0&gt;)\n4781b958-e7b2-4758-93b1-bebf95610fe0: tensor([0.9737], grad_fn=&lt;ViewBackward0&gt;)\n024a459a-cacb-4a1a-91bc-eafe85885d17: tensor([0.9389], grad_fn=&lt;ViewBackward0&gt;)\ndc4d9b72-6c1c-4e4d-b9d8-a9259b1f4755: tensor([0.9021], grad_fn=&lt;ViewBackward0&gt;)\n00c900e0-5b78-4b69-b8f9-081a3a06c54c: tensor([0.5653], grad_fn=&lt;ViewBackward0&gt;)\n26c753d1-70d9-4f66-b0af-598c9ba4cb71: tensor([0.7221], grad_fn=&lt;ViewBackward0&gt;)\ned9c7d09-3fd4-4af3-9e08-381688b0d9ab: tensor([0.4400], grad_fn=&lt;ViewBackward0&gt;)\nece2a23b-3f0f-455c-94b7-900da32eeb4f: tensor([0.3154], grad_fn=&lt;ViewBackward0&gt;)\nc8bb2621-a133-4e7e-913a-362ab64e8233: tensor([0.4669], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\ntheta_4: tensor([0.5653], grad_fn=&lt;ViewBackward0&gt;)\n3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\ntheta_6: tensor([0.4400], grad_fn=&lt;ViewBackward0&gt;)\ntheta_8: tensor([0.4669], grad_fn=&lt;ViewBackward0&gt;)\ntheta_0: tensor([0.7204], grad_fn=&lt;ViewBackward0&gt;)\ntheta_7: tensor([0.3154], grad_fn=&lt;ViewBackward0&gt;)\ny: tensor([2., 2.])\ntheta_5: tensor([0.7221], grad_fn=&lt;ViewBackward0&gt;)\ntheta_2: tensor([0.9389], grad_fn=&lt;ViewBackward0&gt;)\ntheta_3: tensor([0.9021], grad_fn=&lt;ViewBackward0&gt;)\ntheta_1: tensor([0.9737], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.2898-0.1516j, -0.0255-0.3156j,  0.3169+0.0869j,  0.0452+0.3364j,\n-0.3899-0.2018j, -0.3272+0.2711j,  0.2551+0.1729j, -0.0615+0.3124j],\n[ 0.2898-0.1516j, -0.0255-0.3156j,  0.3169+0.0869j,  0.0452+0.3364j,\n-0.3899-0.2018j, -0.3272+0.2711j,  0.2551+0.1729j, -0.0615+0.3124j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'100': 145, '000': 133, '010': 132, '101': 127, '110': 123, '111': 120, '001': 110, '011': 110})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nq0 : -Rx(c86d4d88-e6c0-41f2-aad5-2db303dcc910)-C----------------------------------------Rx(aeba9a25-4344-4287-a978-d7e33c81abb3)-Ry(dc4d9b72-6c1c-4e4d-b9d8-a9259b1f4755)-Rx(ed9c7d09-3fd4-4af3-9e08-381688b0d9ab)-C---\n|                                                                                                                                                                   |   q1 : -Rz(34649d1c-c44e-4095-87f3-3d0cd9907418)-X----------------------------------------Rx(4781b958-e7b2-4758-93b1-bebf95610fe0)-Ry(00c900e0-5b78-4b69-b8f9-081a3a06c54c)-Rx(ece2a23b-3f0f-455c-94b7-900da32eeb4f)-X-C-\n| q2 : -Rx(024a459a-cacb-4a1a-91bc-eafe85885d17)-Ry(26c753d1-70d9-4f66-b0af-598c9ba4cb71)-Rx(c8bb2621-a133-4e7e-913a-362ab64e8233)-------------------------------------------------------------------------------------X-\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\nUnassigned parameters: [00c900e0-5b78-4b69-b8f9-081a3a06c54c, 024a459a-cacb-4a1a-91bc-eafe85885d17, 26c753d1-70d9-4f66-b0af-598c9ba4cb71, 34649d1c-c44e-4095-87f3-3d0cd9907418, 4781b958-e7b2-4758-93b1-bebf95610fe0, aeba9a25-4344-4287-a978-d7e33c81abb3, c86d4d88-e6c0-41f2-aad5-2db303dcc910, c8bb2621-a133-4e7e-913a-362ab64e8233, dc4d9b72-6c1c-4e4d-b9d8-a9259b1f4755, ece2a23b-3f0f-455c-94b7-900da32eeb4f, ed9c7d09-3fd4-4af3-9e08-381688b0d9ab].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\nq0 : -Rx(2.96)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.72)-DEPO(0.1)-Ry(0.90)-DEPO(0.1)-Rx(0.44)-DEPO(0.1)-C-DEPO(0.1)-------------\n|                                                                           |                       q1 : -Rz(0.92)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.97)-DEPO(0.1)-Ry(0.57)-DEPO(0.1)-Rx(0.32)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n|           q2 : -Rx(0.94)-DEPO(0.1)-Ry(0.72)-DEPO(0.1)-Rx(0.47)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 926afc1f15924066a4eb3577276845a4 0 a2c480c972ec4c44bdfb1addf0024ebd X 926afc1f15924066a4eb3577276845a4--a2c480c972ec4c44bdfb1addf0024ebd 9c245414f25e4596871d363e33a16614 1 26ec69f11b56481294db22b48b468737 a2c480c972ec4c44bdfb1addf0024ebd--26ec69f11b56481294db22b48b468737 7011b372f085491f8db4221a149632c2 0dc0fe55d91b424d8d4519728f29436d Y 9c245414f25e4596871d363e33a16614--0dc0fe55d91b424d8d4519728f29436d 0dc0fe55d91b424d8d4519728f29436d--7011b372f085491f8db4221a149632c2 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 e7217fcd128c4b85a77c3fb4c7f673f8 0 f8e65a2d17dd4dbdbd624f70da1d1e1e RX(0.5) e7217fcd128c4b85a77c3fb4c7f673f8--f8e65a2d17dd4dbdbd624f70da1d1e1e aa217b040c8443dbb9baa1d13c2c2a3c f8e65a2d17dd4dbdbd624f70da1d1e1e--aa217b040c8443dbb9baa1d13c2c2a3c <pre><code>from qadence import CNOT\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 0bd16f728b164487a399146b8faa27c0 0 40d76bd0f3e949509ef917d5fa0c3358 0bd16f728b164487a399146b8faa27c0--40d76bd0f3e949509ef917d5fa0c3358 50760741be114b2bbd3bafc9f17f54b0 1 9e376effcbbf458ebb2a4376fe2972b4 40d76bd0f3e949509ef917d5fa0c3358--9e376effcbbf458ebb2a4376fe2972b4 439362cbd22147e9af5e240889395207 fe37a546acd844719d82b7e41eb449c1 X 50760741be114b2bbd3bafc9f17f54b0--fe37a546acd844719d82b7e41eb449c1 fe37a546acd844719d82b7e41eb449c1--40d76bd0f3e949509ef917d5fa0c3358 fe37a546acd844719d82b7e41eb449c1--439362cbd22147e9af5e240889395207 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 3f1c89e3d9834776afecf4c842d9816e 0 c9a4c79439e945e4b7f6c21839efd46e X 3f1c89e3d9834776afecf4c842d9816e--c9a4c79439e945e4b7f6c21839efd46e 66bf5f9a4380440b9c8acf83d24e87ac X c9a4c79439e945e4b7f6c21839efd46e--66bf5f9a4380440b9c8acf83d24e87ac f72dd11c8a5142968dbddd2f1e9cb0e5 66bf5f9a4380440b9c8acf83d24e87ac--f72dd11c8a5142968dbddd2f1e9cb0e5 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 02ff494324ec4c91862b462d6f1a314c 0 999fea471cc34c5ea1dda227ab5f87be X 02ff494324ec4c91862b462d6f1a314c--999fea471cc34c5ea1dda227ab5f87be 1efdfaf9e7f1497888503215f4f1c839 1 45cd67f949354fb28255dbeaf6e42706 999fea471cc34c5ea1dda227ab5f87be--45cd67f949354fb28255dbeaf6e42706 f0436b1b1cf744a4914cd956f0e2c11f 45cd67f949354fb28255dbeaf6e42706--f0436b1b1cf744a4914cd956f0e2c11f d383be802abb4088bb15c4bd0b65359c 228874fcb855405a9bfb036ab910eed9 1efdfaf9e7f1497888503215f4f1c839--228874fcb855405a9bfb036ab910eed9 4944d8e9a612440bb295eb7d329307b6 X 228874fcb855405a9bfb036ab910eed9--4944d8e9a612440bb295eb7d329307b6 4944d8e9a612440bb295eb7d329307b6--d383be802abb4088bb15c4bd0b65359c </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 e23f354aaffd4b79889221c110768714 0 47d47282a3134e12911488420041f2ee X e23f354aaffd4b79889221c110768714--47d47282a3134e12911488420041f2ee dec76b0d5e42490a887c99c8cc15f5b0 1 b50c682d19644cddb3e2424344c35774 47d47282a3134e12911488420041f2ee--b50c682d19644cddb3e2424344c35774 a8f736b8fe674bba91a941bbf0925dfe bb860a4500944376b7cdc990894423bc X dec76b0d5e42490a887c99c8cc15f5b0--bb860a4500944376b7cdc990894423bc bb860a4500944376b7cdc990894423bc--a8f736b8fe674bba91a941bbf0925dfe <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n[ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_d69173c244a14958917e758a8da44564 subblock cluster_30d644e7e1de4fceb0d43e6bd7a8354a subblock dc47f64b461a42f28c457da8ce0d862c 0 e6988a3f0f01493ea407321fe1650fb7 X dc47f64b461a42f28c457da8ce0d862c--e6988a3f0f01493ea407321fe1650fb7 4e8a80075e3b4efa8bc9e5196206943f 1 7579152657af4639bb461d0b35c46bb4 X e6988a3f0f01493ea407321fe1650fb7--7579152657af4639bb461d0b35c46bb4 72f22d0882fd44b8935da921ce25ad7d 7579152657af4639bb461d0b35c46bb4--72f22d0882fd44b8935da921ce25ad7d 46f2abc33bf24fc2a829404e9c3ca049 c7acb673c16242b0a5d9568887d686aa Y 4e8a80075e3b4efa8bc9e5196206943f--c7acb673c16242b0a5d9568887d686aa 95b469a3b0874a799ad493708cd4d976 2 c4b22dc7e7a84c36bf6c19b422d8e1a4 Y c7acb673c16242b0a5d9568887d686aa--c4b22dc7e7a84c36bf6c19b422d8e1a4 c4b22dc7e7a84c36bf6c19b422d8e1a4--46f2abc33bf24fc2a829404e9c3ca049 dc490ba365454094bd673634d13f7fac 5877832240d048379f739c5577740f83 95b469a3b0874a799ad493708cd4d976--5877832240d048379f739c5577740f83 9c93f55180674581add82b5b134a0c91 3 0d8e77bd1ceb4fc880101a6757257e21 5877832240d048379f739c5577740f83--0d8e77bd1ceb4fc880101a6757257e21 0d8e77bd1ceb4fc880101a6757257e21--dc490ba365454094bd673634d13f7fac 06a0ce00268443a182f7c95a6616e4e2 e403700281824a61bbced8fd8ee643e0 9c93f55180674581add82b5b134a0c91--e403700281824a61bbced8fd8ee643e0 8d4a2efab4da47e180ea807fb40d215a 4 7d3cb472a8814a85bb17ce88d0f3dfa8 e403700281824a61bbced8fd8ee643e0--7d3cb472a8814a85bb17ce88d0f3dfa8 7d3cb472a8814a85bb17ce88d0f3dfa8--06a0ce00268443a182f7c95a6616e4e2 1c5c98c618ee4cca9cd9f090f97f7a70 84b4a3d5fce341ea947f287b61492016 X 8d4a2efab4da47e180ea807fb40d215a--84b4a3d5fce341ea947f287b61492016 84b4a3d5fce341ea947f287b61492016--e403700281824a61bbced8fd8ee643e0 bc69e7f9b0d14a12851d4a383bb45b79 X 84b4a3d5fce341ea947f287b61492016--bc69e7f9b0d14a12851d4a383bb45b79 bc69e7f9b0d14a12851d4a383bb45b79--7d3cb472a8814a85bb17ce88d0f3dfa8 bc69e7f9b0d14a12851d4a383bb45b79--1c5c98c618ee4cca9cd9f090f97f7a70"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\nn_qubits = 2\nblock = chain(H(0), H(1))\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 260, '10': 253, '00': 250, '01': 237})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 31, '100': 27, '000': 24, '010': 18})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\nn_qubits = 3\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\nhamilt = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=[0.5, 0.2, 0.1],\ndetuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 Z(1)\n\u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edge</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\nzz_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.ZZ,\ndetuning=Z,\ninteraction_strength=zz_terms,\ndetuning_strength=z_terms\n)\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(1)\n\u251c\u2500\u2500 [mul: -1.00000000000000] \u2502   \u2514\u2500\u2500 X(2)\n\u2514\u2500\u2500 [mul: -1.00000000000000] \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\nreg = Register.square(qubits_side=2)\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Custom Hamiltonian coefficients can also be added to the register beforehand using the <code>\"strength\"</code> key.</p> <pre><code>reg = Register.square(qubits_side = 2)\nfor i, edge in enumerate(reg.edges):\nreg.edges[edge][\"strength\"] = (0.5 * i) ** 2\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.0] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.250] \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 2.250] \u2514\u2500\u2500 KronBlock(2,3)\n\u251c\u2500\u2500 N(2)\n\u2514\u2500\u2500 N(3)\n</code></pre> <p>Alternatively, if the register already stores interaction or detuning strengths, it is possible to override them in the Hamiltonian creation by using <code>force_update = True</code>.</p>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments:</p> <pre><code>n_qubits = 3\nnn_ham = hamiltonian_factory(\nn_qubits,\ninteraction=Interaction.NN,\ndetuning=N,\ninteraction_strength=\"c\",\ndetuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \u2514\u2500\u2500 KronBlock(1,2)\n\u251c\u2500\u2500 N(1)\n\u2514\u2500\u2500 N(2)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\ntensor([[2.5000e-01, 1.8747e-33],\n[1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\ntensor([[ 2.5000e-01, -3.3307e-16],\n[-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\ntensor([[ 0.2624, -0.0142],\n[ 0.0118,  0.0006]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[1.0000+0.0000j, 0.0000-0.0005j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\nblock = RX(0, FeatureParameter(\"phi\"))\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n[0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8865+0.0000j, 0.0000-0.4627j],\n[0.9895+0.0000j, 0.0000-0.1448j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\nblock = chain(\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\nkron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[9.9947e-01+0.0000e+00j, 2.8254e-04+0.0000e+00j, 0.0000e+00-3.2686e-02j,\n0.0000e+00-9.2401e-06j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\nblock = chain(\nkron(\nRX(0, phi/theta),\nRY(1, theta*2),\nRZ(2, sympy.cos(phi)),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi),\nRY(1, theta),\nRZ(2, phi),\n),\nkron(\nRX(0, phi + theta),\nRY(1, theta**2),\nRZ(2, sympy.cos(phi)),\n),\nchain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_5ad33ba079b44fff8dfc5bf353c6d1de [* 2] cluster_0b62e76a855e4781b4208a7f759db8b6 Rotations cb0b05306723446c91520bcbc13854b3 0 86fa269642ed47a284d03743bd0237ff RX(phi/theta) cb0b05306723446c91520bcbc13854b3--86fa269642ed47a284d03743bd0237ff bae631d4141b40cdafb850a1b9fdff39 1 9d9fcb108f93475491712141bc2c19fd RX(phi) 86fa269642ed47a284d03743bd0237ff--9d9fcb108f93475491712141bc2c19fd cbe910a932ee4df6a8114f4fdd8f455b RX(phi) 9d9fcb108f93475491712141bc2c19fd--cbe910a932ee4df6a8114f4fdd8f455b 7c85c3351a394f86971f1035314a7b8d RX(phi + theta) cbe910a932ee4df6a8114f4fdd8f455b--7c85c3351a394f86971f1035314a7b8d b485f01451d140c0a928e1ce337b55a3 7c85c3351a394f86971f1035314a7b8d--b485f01451d140c0a928e1ce337b55a3 98741d4175af47d6942088b16759fd16 b485f01451d140c0a928e1ce337b55a3--98741d4175af47d6942088b16759fd16 fa7fced3c22f4a02bb27ae02b822e19d Z 98741d4175af47d6942088b16759fd16--fa7fced3c22f4a02bb27ae02b822e19d 868461f9be31425f999bdd47e7059cde fa7fced3c22f4a02bb27ae02b822e19d--868461f9be31425f999bdd47e7059cde 48723cece6dc437f9f42ac9d0f5c318c de876aa809404a828c53fc86d129e6c3 RY(2*theta) bae631d4141b40cdafb850a1b9fdff39--de876aa809404a828c53fc86d129e6c3 830bdc638d1b418ea448e29c8eb26853 2 19bdbe914bf1438aafa62d73360a9f8e RY(theta) de876aa809404a828c53fc86d129e6c3--19bdbe914bf1438aafa62d73360a9f8e 4bc0759704824e4da334e8318eca66cc RY(theta) 19bdbe914bf1438aafa62d73360a9f8e--4bc0759704824e4da334e8318eca66cc f5d34e8daf2d4b5fb9ca0372db517632 RY(theta**2) 4bc0759704824e4da334e8318eca66cc--f5d34e8daf2d4b5fb9ca0372db517632 69292b1eded94b2198043b07261dd5ee X f5d34e8daf2d4b5fb9ca0372db517632--69292b1eded94b2198043b07261dd5ee 69292b1eded94b2198043b07261dd5ee--b485f01451d140c0a928e1ce337b55a3 113108d6e9094b39b0ff2faeec382bca 69292b1eded94b2198043b07261dd5ee--113108d6e9094b39b0ff2faeec382bca 71207b1387d7496998038d000dca8904 Z 113108d6e9094b39b0ff2faeec382bca--71207b1387d7496998038d000dca8904 71207b1387d7496998038d000dca8904--48723cece6dc437f9f42ac9d0f5c318c 524b8a6225ec46d68c49fc2dfedffdd6 803b20a6e5fb461fb1d13ac6332b7629 RZ(cos(phi)) 830bdc638d1b418ea448e29c8eb26853--803b20a6e5fb461fb1d13ac6332b7629 fefea8477f674a03bd60a052d3e79334 RZ(phi) 803b20a6e5fb461fb1d13ac6332b7629--fefea8477f674a03bd60a052d3e79334 965c69176f7640f392b7e5cfbf33d083 RZ(phi) fefea8477f674a03bd60a052d3e79334--965c69176f7640f392b7e5cfbf33d083 78cf983a851747fe8fca0871475a2751 RZ(cos(phi)) 965c69176f7640f392b7e5cfbf33d083--78cf983a851747fe8fca0871475a2751 457fd04fb6d6467f81fe46967f076d90 78cf983a851747fe8fca0871475a2751--457fd04fb6d6467f81fe46967f076d90 72feaf89191b496d9e0662f79f3c5959 X 457fd04fb6d6467f81fe46967f076d90--72feaf89191b496d9e0662f79f3c5959 72feaf89191b496d9e0662f79f3c5959--113108d6e9094b39b0ff2faeec382bca 8ad39a522c564f53ad13da7c0f6ea156 Z 72feaf89191b496d9e0662f79f3c5959--8ad39a522c564f53ad13da7c0f6ea156 8ad39a522c564f53ad13da7c0f6ea156--524b8a6225ec46d68c49fc2dfedffdd6 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\nblock = chain(\nkron(RX(0, theta), RY(1, theta)),\nkron(RX(0, phi), RY(1, phi)),\n)\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.5946]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.7476+0.0000j, 0.4344+0.0000j, 0.0000-0.4344j, 0.0000-0.2524j],\n[0.8146+0.0000j, 0.3886+0.0000j, 0.0000-0.3886j, 0.0000-0.1854j],\n[0.7536+0.0000j, 0.4309+0.0000j, 0.0000-0.4309j, 0.0000-0.2464j]],\ngrad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\nn_qubits = 4\ndepth = 2\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 75f9a1462b2d4ea79a7ba0effd0286e9 0 653471c6dabf40c09b82e27dd2993ebf RX(theta\u2080) 75f9a1462b2d4ea79a7ba0effd0286e9--653471c6dabf40c09b82e27dd2993ebf e01e7089d19a42269bce7be868bef92d 1 f545e0e39b9b4f83bca4e7cae93ced16 RY(theta\u2084) 653471c6dabf40c09b82e27dd2993ebf--f545e0e39b9b4f83bca4e7cae93ced16 e5aa2c7cc9d64cfc8aa2b2469ed1dcb7 RX(theta\u2088) f545e0e39b9b4f83bca4e7cae93ced16--e5aa2c7cc9d64cfc8aa2b2469ed1dcb7 3eeb7eb77e354657be6af107b2997370 e5aa2c7cc9d64cfc8aa2b2469ed1dcb7--3eeb7eb77e354657be6af107b2997370 1c7066a92d4e4899bb7490813b9abb95 3eeb7eb77e354657be6af107b2997370--1c7066a92d4e4899bb7490813b9abb95 9353e5627ee14a26bf8e1d345c6dfb7a RX(theta\u2081\u2082) 1c7066a92d4e4899bb7490813b9abb95--9353e5627ee14a26bf8e1d345c6dfb7a 99185b0cd7d64609b07c409e6d6d6eb2 RY(theta\u2081\u2086) 9353e5627ee14a26bf8e1d345c6dfb7a--99185b0cd7d64609b07c409e6d6d6eb2 95fbe86761364e4e80bb255459f7ccc0 RX(theta\u2082\u2080) 99185b0cd7d64609b07c409e6d6d6eb2--95fbe86761364e4e80bb255459f7ccc0 24131c2f5aee407881bcc09fd0b5896f 95fbe86761364e4e80bb255459f7ccc0--24131c2f5aee407881bcc09fd0b5896f 878b08507f044b5f9354b26b6e08b834 24131c2f5aee407881bcc09fd0b5896f--878b08507f044b5f9354b26b6e08b834 10677b8b9a524d5bbea25b138f758d97 878b08507f044b5f9354b26b6e08b834--10677b8b9a524d5bbea25b138f758d97 908d435ecd344688b6340c5ebfd25791 719c4f8621d7421799514c6bbd74fb35 RX(theta\u2081) e01e7089d19a42269bce7be868bef92d--719c4f8621d7421799514c6bbd74fb35 f75a90220d754d61b5908e3cd0c4885b 2 cabd78a8f38b40cf971d592b2c3168ec RY(theta\u2085) 719c4f8621d7421799514c6bbd74fb35--cabd78a8f38b40cf971d592b2c3168ec f956cb72b51648c6b3e3ab83d74ed63b RX(theta\u2089) cabd78a8f38b40cf971d592b2c3168ec--f956cb72b51648c6b3e3ab83d74ed63b 5854c14b02594c0cbd03c01616f0735d X f956cb72b51648c6b3e3ab83d74ed63b--5854c14b02594c0cbd03c01616f0735d 5854c14b02594c0cbd03c01616f0735d--3eeb7eb77e354657be6af107b2997370 a021c9e9b8e545d1a575c022e819f548 5854c14b02594c0cbd03c01616f0735d--a021c9e9b8e545d1a575c022e819f548 c55db7c03b8c466d87d8e7de09e24e17 RX(theta\u2081\u2083) a021c9e9b8e545d1a575c022e819f548--c55db7c03b8c466d87d8e7de09e24e17 cecf096de41d43b89da1594a398b4311 RY(theta\u2081\u2087) c55db7c03b8c466d87d8e7de09e24e17--cecf096de41d43b89da1594a398b4311 7723650f9ba046b0b4ec4aa5b6f4e6ae RX(theta\u2082\u2081) cecf096de41d43b89da1594a398b4311--7723650f9ba046b0b4ec4aa5b6f4e6ae 44d2a46f3a7b4910911d9289135deb00 X 7723650f9ba046b0b4ec4aa5b6f4e6ae--44d2a46f3a7b4910911d9289135deb00 44d2a46f3a7b4910911d9289135deb00--24131c2f5aee407881bcc09fd0b5896f 0cfb9ffa41434545bd343fb128e0ab90 44d2a46f3a7b4910911d9289135deb00--0cfb9ffa41434545bd343fb128e0ab90 0cfb9ffa41434545bd343fb128e0ab90--908d435ecd344688b6340c5ebfd25791 0edd9c62f5b74b9c866ef937fd0dd684 edfa4c92cbba4f93859f9e4397fb4f38 RX(theta\u2082) f75a90220d754d61b5908e3cd0c4885b--edfa4c92cbba4f93859f9e4397fb4f38 919e277f2eb349c0aa73f74434fde05c 3 05fd8e19d8e54c3086f9206a048dac9a RY(theta\u2086) edfa4c92cbba4f93859f9e4397fb4f38--05fd8e19d8e54c3086f9206a048dac9a 63bd57775c6c4fb086c7fca78574fa9c RX(theta\u2081\u2080) 05fd8e19d8e54c3086f9206a048dac9a--63bd57775c6c4fb086c7fca78574fa9c 632bc6ed91804a268d3c58ed34b67ecd 63bd57775c6c4fb086c7fca78574fa9c--632bc6ed91804a268d3c58ed34b67ecd 74726519ae40405ea4e8acbc2cc0bea8 X 632bc6ed91804a268d3c58ed34b67ecd--74726519ae40405ea4e8acbc2cc0bea8 74726519ae40405ea4e8acbc2cc0bea8--a021c9e9b8e545d1a575c022e819f548 6b7d5d0b0eda4930a283de5d9e62006c RX(theta\u2081\u2084) 74726519ae40405ea4e8acbc2cc0bea8--6b7d5d0b0eda4930a283de5d9e62006c 28f4d94f2c78492f99422c216b303611 RY(theta\u2081\u2088) 6b7d5d0b0eda4930a283de5d9e62006c--28f4d94f2c78492f99422c216b303611 198b7857c6be4a3190844a74a7d6f753 RX(theta\u2082\u2082) 28f4d94f2c78492f99422c216b303611--198b7857c6be4a3190844a74a7d6f753 c057e4c40c2144f8a1607dbfde4163f2 198b7857c6be4a3190844a74a7d6f753--c057e4c40c2144f8a1607dbfde4163f2 e4581887c35849a6a679e0bd3af54d03 X c057e4c40c2144f8a1607dbfde4163f2--e4581887c35849a6a679e0bd3af54d03 e4581887c35849a6a679e0bd3af54d03--0cfb9ffa41434545bd343fb128e0ab90 e4581887c35849a6a679e0bd3af54d03--0edd9c62f5b74b9c866ef937fd0dd684 ba5877bbf9cd4f7da4f2e12bbc1b4219 c59749d06bae4f838400f842c0d6bbee RX(theta\u2083) 919e277f2eb349c0aa73f74434fde05c--c59749d06bae4f838400f842c0d6bbee a3d0389b83654691a107f35ac2825772 RY(theta\u2087) c59749d06bae4f838400f842c0d6bbee--a3d0389b83654691a107f35ac2825772 59f3c4a1fe4a45ed911dc3b4784a4a09 RX(theta\u2081\u2081) a3d0389b83654691a107f35ac2825772--59f3c4a1fe4a45ed911dc3b4784a4a09 cf79eda0e375427281a5927748019972 X 59f3c4a1fe4a45ed911dc3b4784a4a09--cf79eda0e375427281a5927748019972 cf79eda0e375427281a5927748019972--632bc6ed91804a268d3c58ed34b67ecd 0522bef21da74a3392500cb15e139150 cf79eda0e375427281a5927748019972--0522bef21da74a3392500cb15e139150 2ebaa4bed75e4138a2c4099828d249ca RX(theta\u2081\u2085) 0522bef21da74a3392500cb15e139150--2ebaa4bed75e4138a2c4099828d249ca cd04dc4dead14e17b2e8d523847d29ed RY(theta\u2081\u2089) 2ebaa4bed75e4138a2c4099828d249ca--cd04dc4dead14e17b2e8d523847d29ed a9819df49f8e462ba59a713b8d9b1fa2 RX(theta\u2082\u2083) cd04dc4dead14e17b2e8d523847d29ed--a9819df49f8e462ba59a713b8d9b1fa2 bcbddd694e014e78857602ba31f6aa70 X a9819df49f8e462ba59a713b8d9b1fa2--bcbddd694e014e78857602ba31f6aa70 bcbddd694e014e78857602ba31f6aa70--c057e4c40c2144f8a1607dbfde4163f2 f87b0a37f950444a8ed39a179b6e0351 bcbddd694e014e78857602ba31f6aa70--f87b0a37f950444a8ed39a179b6e0351 f87b0a37f950444a8ed39a179b6e0351--ba5877bbf9cd4f7da4f2e12bbc1b4219 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_1cd02535c0db42d7b232d00d27f8aad8 HEA cluster_2f2419fb4c1341dda1ca7aabe1ecdaa0 HEA 324b64f9aa3f4b75aa1f4418c1c6d3a5 0 68b4d640ba2e47c6b87bf883e5045820 RX(theta\u2080) 324b64f9aa3f4b75aa1f4418c1c6d3a5--68b4d640ba2e47c6b87bf883e5045820 a1e1264d355546a7a9235a208abc6c7a 1 304a1c7c180a4780b5bb80b106a0361a RY(theta\u2084) 68b4d640ba2e47c6b87bf883e5045820--304a1c7c180a4780b5bb80b106a0361a 421997b87de2408cbad65f1108faf73b RX(theta\u2088) 304a1c7c180a4780b5bb80b106a0361a--421997b87de2408cbad65f1108faf73b 495c9e2eac314c9fa9ead497ced9bffd 421997b87de2408cbad65f1108faf73b--495c9e2eac314c9fa9ead497ced9bffd 3c0b8db622d64f1bb9428c61b42ce0aa 495c9e2eac314c9fa9ead497ced9bffd--3c0b8db622d64f1bb9428c61b42ce0aa f1c6edfe2c294fbd8421729acb5f95e7 RX(theta\u2081\u2082) 3c0b8db622d64f1bb9428c61b42ce0aa--f1c6edfe2c294fbd8421729acb5f95e7 1356f5f064fc472987b4cfa687fdb94e RY(theta\u2081\u2086) f1c6edfe2c294fbd8421729acb5f95e7--1356f5f064fc472987b4cfa687fdb94e f49009d3d4334d608253632280235c3b RX(theta\u2082\u2080) 1356f5f064fc472987b4cfa687fdb94e--f49009d3d4334d608253632280235c3b 439a7dfcae00408b90de2aa3e168fe66 f49009d3d4334d608253632280235c3b--439a7dfcae00408b90de2aa3e168fe66 73169193ac454a849521ac693c07c457 439a7dfcae00408b90de2aa3e168fe66--73169193ac454a849521ac693c07c457 0d508b5ac1c94b28a3c0c72f5666709f RX(theta\u2080) 73169193ac454a849521ac693c07c457--0d508b5ac1c94b28a3c0c72f5666709f af01f2b79a764ee58f2ca3d556e3de09 RY(theta\u2084) 0d508b5ac1c94b28a3c0c72f5666709f--af01f2b79a764ee58f2ca3d556e3de09 5da6317ebdef4612adaf9d5c8e653de7 RX(theta\u2088) af01f2b79a764ee58f2ca3d556e3de09--5da6317ebdef4612adaf9d5c8e653de7 b0da4c5d383744f29725c2d1e2737e55 5da6317ebdef4612adaf9d5c8e653de7--b0da4c5d383744f29725c2d1e2737e55 5b8acb66226b4075a55ddc59adc8dcb8 b0da4c5d383744f29725c2d1e2737e55--5b8acb66226b4075a55ddc59adc8dcb8 35dd1038f4114149a7d288fe516671c1 RX(theta\u2081\u2082) 5b8acb66226b4075a55ddc59adc8dcb8--35dd1038f4114149a7d288fe516671c1 fe7772cb4d4d4a39918d383105f45945 RY(theta\u2081\u2086) 35dd1038f4114149a7d288fe516671c1--fe7772cb4d4d4a39918d383105f45945 7c1eeb791e8344dfb51f51bf92013e8b RX(theta\u2082\u2080) fe7772cb4d4d4a39918d383105f45945--7c1eeb791e8344dfb51f51bf92013e8b ca53d370e8684169b64d5269e9ac1137 7c1eeb791e8344dfb51f51bf92013e8b--ca53d370e8684169b64d5269e9ac1137 7ca84e74617a400aaf47acf0b8de2f33 ca53d370e8684169b64d5269e9ac1137--7ca84e74617a400aaf47acf0b8de2f33 9744197316064c779bc955287a4dbeb8 7ca84e74617a400aaf47acf0b8de2f33--9744197316064c779bc955287a4dbeb8 e8c52d631be14a3bb7988c3c1aa1bfed 01e4dab4bd1a4002a9953ed897fa55cd RX(theta\u2081) a1e1264d355546a7a9235a208abc6c7a--01e4dab4bd1a4002a9953ed897fa55cd 8c42ffa37ab049c2ae9f3ca890239284 2 94741d56fcba48739912db37bf7ea882 RY(theta\u2085) 01e4dab4bd1a4002a9953ed897fa55cd--94741d56fcba48739912db37bf7ea882 9d522f71eb904608897df3ef0d177402 RX(theta\u2089) 94741d56fcba48739912db37bf7ea882--9d522f71eb904608897df3ef0d177402 1927331aed53498f820132373a71d189 X 9d522f71eb904608897df3ef0d177402--1927331aed53498f820132373a71d189 1927331aed53498f820132373a71d189--495c9e2eac314c9fa9ead497ced9bffd 92f8d258265c446883832ebacde90151 1927331aed53498f820132373a71d189--92f8d258265c446883832ebacde90151 df727e0765dc476c98ad99ce24826e11 RX(theta\u2081\u2083) 92f8d258265c446883832ebacde90151--df727e0765dc476c98ad99ce24826e11 9b7e77ea41f245429da7b6bde597ef3b RY(theta\u2081\u2087) df727e0765dc476c98ad99ce24826e11--9b7e77ea41f245429da7b6bde597ef3b f596c2b1b8c3438b8d6de24a97ed8b74 RX(theta\u2082\u2081) 9b7e77ea41f245429da7b6bde597ef3b--f596c2b1b8c3438b8d6de24a97ed8b74 f8faea248ce543d3abc96eaa55c2f946 X f596c2b1b8c3438b8d6de24a97ed8b74--f8faea248ce543d3abc96eaa55c2f946 f8faea248ce543d3abc96eaa55c2f946--439a7dfcae00408b90de2aa3e168fe66 dd72fd25440047cb8d25f9112780519c f8faea248ce543d3abc96eaa55c2f946--dd72fd25440047cb8d25f9112780519c f1f220fa94e8498eb5a6881e7f8bd1d0 RX(theta\u2081) dd72fd25440047cb8d25f9112780519c--f1f220fa94e8498eb5a6881e7f8bd1d0 847e2347f5004f4f994b2c3c8879d07a RY(theta\u2085) f1f220fa94e8498eb5a6881e7f8bd1d0--847e2347f5004f4f994b2c3c8879d07a 413393a263e64f82aea0d66b7fa32db2 RX(theta\u2089) 847e2347f5004f4f994b2c3c8879d07a--413393a263e64f82aea0d66b7fa32db2 41b890282ed44e36ab7dd74381f8f990 X 413393a263e64f82aea0d66b7fa32db2--41b890282ed44e36ab7dd74381f8f990 41b890282ed44e36ab7dd74381f8f990--b0da4c5d383744f29725c2d1e2737e55 841d4786fe4240d682c7c9deb69573b2 41b890282ed44e36ab7dd74381f8f990--841d4786fe4240d682c7c9deb69573b2 08561bcbe2784fc2b6b5e6a1f8d10757 RX(theta\u2081\u2083) 841d4786fe4240d682c7c9deb69573b2--08561bcbe2784fc2b6b5e6a1f8d10757 8c6a047a09444ca9b73509c14931ed5a RY(theta\u2081\u2087) 08561bcbe2784fc2b6b5e6a1f8d10757--8c6a047a09444ca9b73509c14931ed5a 3d8774cfe5bf4bbdbdacbd99fc3ba6c8 RX(theta\u2082\u2081) 8c6a047a09444ca9b73509c14931ed5a--3d8774cfe5bf4bbdbdacbd99fc3ba6c8 d2cb0030b13849cd974c41a74990b394 X 3d8774cfe5bf4bbdbdacbd99fc3ba6c8--d2cb0030b13849cd974c41a74990b394 d2cb0030b13849cd974c41a74990b394--ca53d370e8684169b64d5269e9ac1137 9ed0043638f94748b174cfe47f540a8b d2cb0030b13849cd974c41a74990b394--9ed0043638f94748b174cfe47f540a8b 9ed0043638f94748b174cfe47f540a8b--e8c52d631be14a3bb7988c3c1aa1bfed 86288babb4ee4737a5a4f25161e3817d b221da2114074a5898b38b0ce81748fd RX(theta\u2082) 8c42ffa37ab049c2ae9f3ca890239284--b221da2114074a5898b38b0ce81748fd 26a607cd6348428ebf787db8c193dbdc 3 a5da4b5ec6f94de4ab1b77374aa8c730 RY(theta\u2086) b221da2114074a5898b38b0ce81748fd--a5da4b5ec6f94de4ab1b77374aa8c730 e36f6a52831f4453b4e7c81d20012e3a RX(theta\u2081\u2080) a5da4b5ec6f94de4ab1b77374aa8c730--e36f6a52831f4453b4e7c81d20012e3a ab7c080680ab40e5a12f7bf7bb28d510 e36f6a52831f4453b4e7c81d20012e3a--ab7c080680ab40e5a12f7bf7bb28d510 2d49864480934abc88ab45533ec3ef54 X ab7c080680ab40e5a12f7bf7bb28d510--2d49864480934abc88ab45533ec3ef54 2d49864480934abc88ab45533ec3ef54--92f8d258265c446883832ebacde90151 4c3f272dcb5c44009f0aa941da45321a RX(theta\u2081\u2084) 2d49864480934abc88ab45533ec3ef54--4c3f272dcb5c44009f0aa941da45321a 92c077da5d184493840b4e9b3a3c81c7 RY(theta\u2081\u2088) 4c3f272dcb5c44009f0aa941da45321a--92c077da5d184493840b4e9b3a3c81c7 c25e00474136461497fbe138cbfb25ea RX(theta\u2082\u2082) 92c077da5d184493840b4e9b3a3c81c7--c25e00474136461497fbe138cbfb25ea e58a8cb16a6949c5abf665f5ff04aa8f c25e00474136461497fbe138cbfb25ea--e58a8cb16a6949c5abf665f5ff04aa8f bcbeaf464ab54dd68f9f5008abb9f4f4 X e58a8cb16a6949c5abf665f5ff04aa8f--bcbeaf464ab54dd68f9f5008abb9f4f4 bcbeaf464ab54dd68f9f5008abb9f4f4--dd72fd25440047cb8d25f9112780519c fc23bbf7235448409fcd31e32112844b RX(theta\u2082) bcbeaf464ab54dd68f9f5008abb9f4f4--fc23bbf7235448409fcd31e32112844b f0ed3f898ca542b9bfb1f2f495749d3d RY(theta\u2086) fc23bbf7235448409fcd31e32112844b--f0ed3f898ca542b9bfb1f2f495749d3d 060ca44f33e4497292ac0a2c2916e196 RX(theta\u2081\u2080) f0ed3f898ca542b9bfb1f2f495749d3d--060ca44f33e4497292ac0a2c2916e196 32015f4c68e94a1590171c56d0da0884 060ca44f33e4497292ac0a2c2916e196--32015f4c68e94a1590171c56d0da0884 b72da5917fb240b68a25f9df94cf4d0f X 32015f4c68e94a1590171c56d0da0884--b72da5917fb240b68a25f9df94cf4d0f b72da5917fb240b68a25f9df94cf4d0f--841d4786fe4240d682c7c9deb69573b2 880a093703a247bc926fa52d5ea1809f RX(theta\u2081\u2084) b72da5917fb240b68a25f9df94cf4d0f--880a093703a247bc926fa52d5ea1809f 2eb7965c32944231a1c2bdab3edc6451 RY(theta\u2081\u2088) 880a093703a247bc926fa52d5ea1809f--2eb7965c32944231a1c2bdab3edc6451 6e36e4c356564f32aa7db0f2cb24f557 RX(theta\u2082\u2082) 2eb7965c32944231a1c2bdab3edc6451--6e36e4c356564f32aa7db0f2cb24f557 3c4b70c204aa4d1aadaceaa9a9e7a2ae 6e36e4c356564f32aa7db0f2cb24f557--3c4b70c204aa4d1aadaceaa9a9e7a2ae 2de7829d48e241088a9101dbce897803 X 3c4b70c204aa4d1aadaceaa9a9e7a2ae--2de7829d48e241088a9101dbce897803 2de7829d48e241088a9101dbce897803--9ed0043638f94748b174cfe47f540a8b 2de7829d48e241088a9101dbce897803--86288babb4ee4737a5a4f25161e3817d d1946ce60d204cae9590de144fb2a1ed 299ea02d70464ee3944b8ac50f306486 RX(theta\u2083) 26a607cd6348428ebf787db8c193dbdc--299ea02d70464ee3944b8ac50f306486 13e2bff3e92742b18d4014d3298ff2f8 RY(theta\u2087) 299ea02d70464ee3944b8ac50f306486--13e2bff3e92742b18d4014d3298ff2f8 ddfc141fc25144d098ee6883a741b12f RX(theta\u2081\u2081) 13e2bff3e92742b18d4014d3298ff2f8--ddfc141fc25144d098ee6883a741b12f 5587acbb769341b9a452a2521b94dcad X ddfc141fc25144d098ee6883a741b12f--5587acbb769341b9a452a2521b94dcad 5587acbb769341b9a452a2521b94dcad--ab7c080680ab40e5a12f7bf7bb28d510 d4bc7c094acd4ac0acab11c0f94bc114 5587acbb769341b9a452a2521b94dcad--d4bc7c094acd4ac0acab11c0f94bc114 be22f87936ca4b8d90e7d2957631db12 RX(theta\u2081\u2085) d4bc7c094acd4ac0acab11c0f94bc114--be22f87936ca4b8d90e7d2957631db12 61eeb435e9d14c689de801dad2f743e0 RY(theta\u2081\u2089) be22f87936ca4b8d90e7d2957631db12--61eeb435e9d14c689de801dad2f743e0 3b15c5df63f8440b9b9232367ad17cd1 RX(theta\u2082\u2083) 61eeb435e9d14c689de801dad2f743e0--3b15c5df63f8440b9b9232367ad17cd1 9a89b267576243c18b2e8deac0135470 X 3b15c5df63f8440b9b9232367ad17cd1--9a89b267576243c18b2e8deac0135470 9a89b267576243c18b2e8deac0135470--e58a8cb16a6949c5abf665f5ff04aa8f 11ac6c0955144d1cac4a72fd1d128ae1 9a89b267576243c18b2e8deac0135470--11ac6c0955144d1cac4a72fd1d128ae1 f30e50a3467441c38d8bb38e2dace232 RX(theta\u2083) 11ac6c0955144d1cac4a72fd1d128ae1--f30e50a3467441c38d8bb38e2dace232 4bfe556e197f48f59cc11f1dc632ffcf RY(theta\u2087) f30e50a3467441c38d8bb38e2dace232--4bfe556e197f48f59cc11f1dc632ffcf 3cd99204e24f4ccfa6743fc19f0c27ce RX(theta\u2081\u2081) 4bfe556e197f48f59cc11f1dc632ffcf--3cd99204e24f4ccfa6743fc19f0c27ce 8e8cda1007334b74b001da926a78bb19 X 3cd99204e24f4ccfa6743fc19f0c27ce--8e8cda1007334b74b001da926a78bb19 8e8cda1007334b74b001da926a78bb19--32015f4c68e94a1590171c56d0da0884 9ac99d948684497ba3df3c3560345b46 8e8cda1007334b74b001da926a78bb19--9ac99d948684497ba3df3c3560345b46 e37150ee3c5b46fc91566b773d2dc9c4 RX(theta\u2081\u2085) 9ac99d948684497ba3df3c3560345b46--e37150ee3c5b46fc91566b773d2dc9c4 9a41264d0f014dca842c3a1975d52b50 RY(theta\u2081\u2089) e37150ee3c5b46fc91566b773d2dc9c4--9a41264d0f014dca842c3a1975d52b50 4c4cd81819e1416688331048971cb55d RX(theta\u2082\u2083) 9a41264d0f014dca842c3a1975d52b50--4c4cd81819e1416688331048971cb55d 1ea6db49c30844719361200729b5f426 X 4c4cd81819e1416688331048971cb55d--1ea6db49c30844719361200729b5f426 1ea6db49c30844719361200729b5f426--3c4b70c204aa4d1aadaceaa9a9e7a2ae 86be9f4050424022a798b75019fb5e54 1ea6db49c30844719361200729b5f426--86be9f4050424022a798b75019fb5e54 86be9f4050424022a798b75019fb5e54--d1946ce60d204cae9590de144fb2a1ed </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_ddb2bc84a67d4dd4b169ed1d33b4d451 HEA cluster_5fceb1f909c94a3494c932a778fe212b HEA 1ab4ef94e57a422c9cc37ade8d47f2e9 0 24523b8865c34ed5b78cc3206bd23044 RX(p1\u2080) 1ab4ef94e57a422c9cc37ade8d47f2e9--24523b8865c34ed5b78cc3206bd23044 066f7cf7d25f4d669ae12203fdc5258a 1 53b100920e4c4a4a91613981dbc64faf RY(p1\u2084) 24523b8865c34ed5b78cc3206bd23044--53b100920e4c4a4a91613981dbc64faf 1f0c589adfb24da8a772a4d90986b0c3 RX(p1\u2088) 53b100920e4c4a4a91613981dbc64faf--1f0c589adfb24da8a772a4d90986b0c3 ad5529ab57ed4e95a2e01158192d59fe 1f0c589adfb24da8a772a4d90986b0c3--ad5529ab57ed4e95a2e01158192d59fe c8c85731531b4365b4f63400f8b99611 ad5529ab57ed4e95a2e01158192d59fe--c8c85731531b4365b4f63400f8b99611 d7c7dbdb5dbf456ba45debf47d19295a RX(p1\u2081\u2082) c8c85731531b4365b4f63400f8b99611--d7c7dbdb5dbf456ba45debf47d19295a b2754a992c674bdc99fcf0bc35b854cb RY(p1\u2081\u2086) d7c7dbdb5dbf456ba45debf47d19295a--b2754a992c674bdc99fcf0bc35b854cb a0da4a8e5f2e4b9bb1f36c626b70a620 RX(p1\u2082\u2080) b2754a992c674bdc99fcf0bc35b854cb--a0da4a8e5f2e4b9bb1f36c626b70a620 c06fbe92fb9d41c89d9a588950bfc990 a0da4a8e5f2e4b9bb1f36c626b70a620--c06fbe92fb9d41c89d9a588950bfc990 2ad7465165f944648b83d16b1a480e8c c06fbe92fb9d41c89d9a588950bfc990--2ad7465165f944648b83d16b1a480e8c 746365ab2ce046c7b1b3289255aacd6e RX(p2\u2080) 2ad7465165f944648b83d16b1a480e8c--746365ab2ce046c7b1b3289255aacd6e eef376d059eb4fb3b4066bead0f3f6b2 RY(p2\u2084) 746365ab2ce046c7b1b3289255aacd6e--eef376d059eb4fb3b4066bead0f3f6b2 44ad3b1d7dad4b09852431f9844747a6 RX(p2\u2088) eef376d059eb4fb3b4066bead0f3f6b2--44ad3b1d7dad4b09852431f9844747a6 ba1f39fa3cea4877858334b776d13768 44ad3b1d7dad4b09852431f9844747a6--ba1f39fa3cea4877858334b776d13768 a41d234d7d2e485b9b8b5915e8fc3b5e ba1f39fa3cea4877858334b776d13768--a41d234d7d2e485b9b8b5915e8fc3b5e 38d3c06605bb4746b9f185297718fc89 RX(p2\u2081\u2082) a41d234d7d2e485b9b8b5915e8fc3b5e--38d3c06605bb4746b9f185297718fc89 8954606ccb154e2eb45718f5036e3388 RY(p2\u2081\u2086) 38d3c06605bb4746b9f185297718fc89--8954606ccb154e2eb45718f5036e3388 1a59c32ee04c46e4ab5d4b0afcaf820c RX(p2\u2082\u2080) 8954606ccb154e2eb45718f5036e3388--1a59c32ee04c46e4ab5d4b0afcaf820c 4f49053c1bde443b97d46684174c202f 1a59c32ee04c46e4ab5d4b0afcaf820c--4f49053c1bde443b97d46684174c202f 93c75bdc921b49fab2228e83a9940ecf 4f49053c1bde443b97d46684174c202f--93c75bdc921b49fab2228e83a9940ecf 35fcf5f74551416db32f092154be2111 93c75bdc921b49fab2228e83a9940ecf--35fcf5f74551416db32f092154be2111 6d6dd080292a4ef5a68dc5698da59f6a 0e25a04dae24442393dc782a5bdb4d4d RX(p1\u2081) 066f7cf7d25f4d669ae12203fdc5258a--0e25a04dae24442393dc782a5bdb4d4d 6e874bd915464a22962f87e9e4ff0e0a 2 ce7557fd7b4243509d67225945d2f8df RY(p1\u2085) 0e25a04dae24442393dc782a5bdb4d4d--ce7557fd7b4243509d67225945d2f8df d73ac2e3e3be4764a02cca4f607db4e5 RX(p1\u2089) ce7557fd7b4243509d67225945d2f8df--d73ac2e3e3be4764a02cca4f607db4e5 6f941024261e4ea6a352b0ea2b896517 X d73ac2e3e3be4764a02cca4f607db4e5--6f941024261e4ea6a352b0ea2b896517 6f941024261e4ea6a352b0ea2b896517--ad5529ab57ed4e95a2e01158192d59fe abc97fee3fb64baaa3577988a8095da5 6f941024261e4ea6a352b0ea2b896517--abc97fee3fb64baaa3577988a8095da5 4e2c30a6238841de909222711713ddf2 RX(p1\u2081\u2083) abc97fee3fb64baaa3577988a8095da5--4e2c30a6238841de909222711713ddf2 9abc6d0776874844ad8d05d6c39652a1 RY(p1\u2081\u2087) 4e2c30a6238841de909222711713ddf2--9abc6d0776874844ad8d05d6c39652a1 1a0dc2d6a39a4ebdb98c0d123be8474a RX(p1\u2082\u2081) 9abc6d0776874844ad8d05d6c39652a1--1a0dc2d6a39a4ebdb98c0d123be8474a 9ff9843c56be4e9e9368139869cc2db4 X 1a0dc2d6a39a4ebdb98c0d123be8474a--9ff9843c56be4e9e9368139869cc2db4 9ff9843c56be4e9e9368139869cc2db4--c06fbe92fb9d41c89d9a588950bfc990 3af6102355854fb28453482ed35af756 9ff9843c56be4e9e9368139869cc2db4--3af6102355854fb28453482ed35af756 05db0b8bab6a4fd49415db16753533d6 RX(p2\u2081) 3af6102355854fb28453482ed35af756--05db0b8bab6a4fd49415db16753533d6 a28eee8661e346028afe3f25a73eccbf RY(p2\u2085) 05db0b8bab6a4fd49415db16753533d6--a28eee8661e346028afe3f25a73eccbf de54a00365244aa0aa6822f7c7f09d39 RX(p2\u2089) a28eee8661e346028afe3f25a73eccbf--de54a00365244aa0aa6822f7c7f09d39 59a164b840734b4cb4a2190fab986739 X de54a00365244aa0aa6822f7c7f09d39--59a164b840734b4cb4a2190fab986739 59a164b840734b4cb4a2190fab986739--ba1f39fa3cea4877858334b776d13768 105da4e41e2e4c3a9b04bd9eaaf4da7d 59a164b840734b4cb4a2190fab986739--105da4e41e2e4c3a9b04bd9eaaf4da7d c80f9c37a5dd48e8bb33e61b00f86a7c RX(p2\u2081\u2083) 105da4e41e2e4c3a9b04bd9eaaf4da7d--c80f9c37a5dd48e8bb33e61b00f86a7c 8ced13311e134a77a36d06a399455510 RY(p2\u2081\u2087) c80f9c37a5dd48e8bb33e61b00f86a7c--8ced13311e134a77a36d06a399455510 272b8bef81b34fe3b1d428900b6a88c8 RX(p2\u2082\u2081) 8ced13311e134a77a36d06a399455510--272b8bef81b34fe3b1d428900b6a88c8 a36486164334454585ad621e3eac7e5c X 272b8bef81b34fe3b1d428900b6a88c8--a36486164334454585ad621e3eac7e5c a36486164334454585ad621e3eac7e5c--4f49053c1bde443b97d46684174c202f 823f47f2466942019c67a9da2caafcbe a36486164334454585ad621e3eac7e5c--823f47f2466942019c67a9da2caafcbe 823f47f2466942019c67a9da2caafcbe--6d6dd080292a4ef5a68dc5698da59f6a ddba77c3ef3244fb974f41e8b19bc88c 90051eed789d4ec8b5f3b2e0368f2bff RX(p1\u2082) 6e874bd915464a22962f87e9e4ff0e0a--90051eed789d4ec8b5f3b2e0368f2bff 3be0fd4de1f6498896ee66b351983328 3 b986f0d6ad6846b8921487b65a26bd4e RY(p1\u2086) 90051eed789d4ec8b5f3b2e0368f2bff--b986f0d6ad6846b8921487b65a26bd4e 9e902420e9f64a75babda301257b49dc RX(p1\u2081\u2080) b986f0d6ad6846b8921487b65a26bd4e--9e902420e9f64a75babda301257b49dc a9fa2d4eae304c4c9531f382d475e433 9e902420e9f64a75babda301257b49dc--a9fa2d4eae304c4c9531f382d475e433 dcc732a4986e444bbdb6ad79733d2f21 X a9fa2d4eae304c4c9531f382d475e433--dcc732a4986e444bbdb6ad79733d2f21 dcc732a4986e444bbdb6ad79733d2f21--abc97fee3fb64baaa3577988a8095da5 8c9646b2fab74ae88f6b7d1d11d22309 RX(p1\u2081\u2084) dcc732a4986e444bbdb6ad79733d2f21--8c9646b2fab74ae88f6b7d1d11d22309 a59d098100e7445f8d6ea17536eb486a RY(p1\u2081\u2088) 8c9646b2fab74ae88f6b7d1d11d22309--a59d098100e7445f8d6ea17536eb486a fc6f501e948e4dc68eb44160e0a59ba9 RX(p1\u2082\u2082) a59d098100e7445f8d6ea17536eb486a--fc6f501e948e4dc68eb44160e0a59ba9 24a6e7ec51f64c2caca641ffa8a22c1f fc6f501e948e4dc68eb44160e0a59ba9--24a6e7ec51f64c2caca641ffa8a22c1f 6a50e640dd7642ea8987da3215b4b700 X 24a6e7ec51f64c2caca641ffa8a22c1f--6a50e640dd7642ea8987da3215b4b700 6a50e640dd7642ea8987da3215b4b700--3af6102355854fb28453482ed35af756 424c4dbf899e4e3881ca344cc8ba2ff4 RX(p2\u2082) 6a50e640dd7642ea8987da3215b4b700--424c4dbf899e4e3881ca344cc8ba2ff4 ffecffe4bc134c51a788cbe12162e15b RY(p2\u2086) 424c4dbf899e4e3881ca344cc8ba2ff4--ffecffe4bc134c51a788cbe12162e15b 767dcdce41f0498db09c44385ca260e7 RX(p2\u2081\u2080) ffecffe4bc134c51a788cbe12162e15b--767dcdce41f0498db09c44385ca260e7 cec1124bde5c4b9bb74fb6d02251e6e1 767dcdce41f0498db09c44385ca260e7--cec1124bde5c4b9bb74fb6d02251e6e1 16a82be741084c0f94ba55e4eec813d7 X cec1124bde5c4b9bb74fb6d02251e6e1--16a82be741084c0f94ba55e4eec813d7 16a82be741084c0f94ba55e4eec813d7--105da4e41e2e4c3a9b04bd9eaaf4da7d e7815e34a05645429e87943dac0640f8 RX(p2\u2081\u2084) 16a82be741084c0f94ba55e4eec813d7--e7815e34a05645429e87943dac0640f8 5ef79eef2c6947af808b61e47ecab0dc RY(p2\u2081\u2088) e7815e34a05645429e87943dac0640f8--5ef79eef2c6947af808b61e47ecab0dc d3a57ee426b9453ebbc85bd1983a286f RX(p2\u2082\u2082) 5ef79eef2c6947af808b61e47ecab0dc--d3a57ee426b9453ebbc85bd1983a286f 12085b1f120649248e1fcc3f4c8df29b d3a57ee426b9453ebbc85bd1983a286f--12085b1f120649248e1fcc3f4c8df29b 64c588b1bbb34618b8136b39b3b3af0d X 12085b1f120649248e1fcc3f4c8df29b--64c588b1bbb34618b8136b39b3b3af0d 64c588b1bbb34618b8136b39b3b3af0d--823f47f2466942019c67a9da2caafcbe 64c588b1bbb34618b8136b39b3b3af0d--ddba77c3ef3244fb974f41e8b19bc88c 72180f1e47ae479896bff40c4208ac90 4f4aa1a301e847b7a31c7db7f0fd31ef RX(p1\u2083) 3be0fd4de1f6498896ee66b351983328--4f4aa1a301e847b7a31c7db7f0fd31ef 1b6370b5349140b8a2329fb8e2d14fc1 RY(p1\u2087) 4f4aa1a301e847b7a31c7db7f0fd31ef--1b6370b5349140b8a2329fb8e2d14fc1 54f7f07cfe764f82a907c5e2e36c6ff0 RX(p1\u2081\u2081) 1b6370b5349140b8a2329fb8e2d14fc1--54f7f07cfe764f82a907c5e2e36c6ff0 1964bd3fae19423f97433ca569cff8ee X 54f7f07cfe764f82a907c5e2e36c6ff0--1964bd3fae19423f97433ca569cff8ee 1964bd3fae19423f97433ca569cff8ee--a9fa2d4eae304c4c9531f382d475e433 5efc5d2bad314ed89776e30f38fad309 1964bd3fae19423f97433ca569cff8ee--5efc5d2bad314ed89776e30f38fad309 597eb8527b4a401d84769ecc189ab1a3 RX(p1\u2081\u2085) 5efc5d2bad314ed89776e30f38fad309--597eb8527b4a401d84769ecc189ab1a3 3c21b5b549544ed6b741a8f21cbaf80c RY(p1\u2081\u2089) 597eb8527b4a401d84769ecc189ab1a3--3c21b5b549544ed6b741a8f21cbaf80c 2f1d5a3579ac4189ac76559a10e7f212 RX(p1\u2082\u2083) 3c21b5b549544ed6b741a8f21cbaf80c--2f1d5a3579ac4189ac76559a10e7f212 98290b8d7e494c1c8d27a224f610a5d0 X 2f1d5a3579ac4189ac76559a10e7f212--98290b8d7e494c1c8d27a224f610a5d0 98290b8d7e494c1c8d27a224f610a5d0--24a6e7ec51f64c2caca641ffa8a22c1f 00634dd7fc3d4e39a36244a5bfe69b96 98290b8d7e494c1c8d27a224f610a5d0--00634dd7fc3d4e39a36244a5bfe69b96 6447774d1775442c83d1c63057cad127 RX(p2\u2083) 00634dd7fc3d4e39a36244a5bfe69b96--6447774d1775442c83d1c63057cad127 0914c919183e452694b846ce091cae08 RY(p2\u2087) 6447774d1775442c83d1c63057cad127--0914c919183e452694b846ce091cae08 fc9c8e2b8b1440c9ac02fa3c9af9be30 RX(p2\u2081\u2081) 0914c919183e452694b846ce091cae08--fc9c8e2b8b1440c9ac02fa3c9af9be30 6e9e1da0e9dd4e76852f31f382574d06 X fc9c8e2b8b1440c9ac02fa3c9af9be30--6e9e1da0e9dd4e76852f31f382574d06 6e9e1da0e9dd4e76852f31f382574d06--cec1124bde5c4b9bb74fb6d02251e6e1 c0434e9bfd6248da87021550c3f4288d 6e9e1da0e9dd4e76852f31f382574d06--c0434e9bfd6248da87021550c3f4288d 2598e4ad9baa477289902a6c592b1be7 RX(p2\u2081\u2085) c0434e9bfd6248da87021550c3f4288d--2598e4ad9baa477289902a6c592b1be7 a0b5597243894e76b60e9e587406af43 RY(p2\u2081\u2089) 2598e4ad9baa477289902a6c592b1be7--a0b5597243894e76b60e9e587406af43 98376f1d4675421ba3cef0c9136c0d16 RX(p2\u2082\u2083) a0b5597243894e76b60e9e587406af43--98376f1d4675421ba3cef0c9136c0d16 8f39e48585ce435bb66941453ed91086 X 98376f1d4675421ba3cef0c9136c0d16--8f39e48585ce435bb66941453ed91086 8f39e48585ce435bb66941453ed91086--12085b1f120649248e1fcc3f4c8df29b 4419150da10f4f52ac5728ea2f696b4e 8f39e48585ce435bb66941453ed91086--4419150da10f4f52ac5728ea2f696b4e 4419150da10f4f52ac5728ea2f696b4e--72180f1e47ae479896bff40c4208ac90 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9608])), ('theta_0', tensor([0.6551])), ('theta_1', tensor([0.0534])), ('theta_10', tensor([0.6509])), ('theta_11', tensor([0.8235])), ('theta_12', tensor([0.2038])), ('theta_13', tensor([0.7853])), ('theta_14', tensor([0.2668])), ('theta_15', tensor([0.5797])), ('theta_16', tensor([0.4227])), ('theta_17', tensor([0.6723])), ('theta_18', tensor([0.1476])), ('theta_19', tensor([0.6309])), ('theta_2', tensor([0.6050])), ('theta_20', tensor([0.1834])), ('theta_21', tensor([0.8038])), ('theta_22', tensor([0.9408])), ('theta_23', tensor([0.4441])), ('theta_3', tensor([0.7862])), ('theta_4', tensor([0.9296])), ('theta_5', tensor([0.9995])), ('theta_6', tensor([0.9985])), ('theta_7', tensor([0.9648])), ('theta_8', tensor([0.7446])), ('theta_9', tensor([0.1812]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.9598])), ('theta_0', tensor([0.6541])), ('theta_1', tensor([0.0524])), ('theta_10', tensor([0.6499])), ('theta_11', tensor([0.8225])), ('theta_12', tensor([0.2028])), ('theta_13', tensor([0.7843])), ('theta_14', tensor([0.2658])), ('theta_15', tensor([0.5787])), ('theta_16', tensor([0.4217])), ('theta_17', tensor([0.6713])), ('theta_18', tensor([0.1486])), ('theta_19', tensor([0.6319])), ('theta_2', tensor([0.6040])), ('theta_20', tensor([0.1824])), ('theta_21', tensor([0.8028])), ('theta_22', tensor([0.9398])), ('theta_23', tensor([0.4431])), ('theta_3', tensor([0.7852])), ('theta_4', tensor([0.9286])), ('theta_5', tensor([0.9985])), ('theta_6', tensor([0.9975])), ('theta_7', tensor([0.9658])), ('theta_8', tensor([0.7436])), ('theta_9', tensor([0.1802]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\nx = Parameter(\"x\")\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = QuantumCircuit(\n(operations): ModuleList(\n(0): QuantumCircuit(\n(operations): ModuleList(\n(0): RX(qubit_support=(0,))\n(1): RX(qubit_support=(1,))\n)\n)\n)\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9704+0.0000j,  0.0000-0.1694j,  0.0000-0.1694j, -0.0296+0.0000j],\n[ 0.9090+0.0000j,  0.0000-0.2876j,  0.0000-0.2876j, -0.0910+0.0000j],\n[ 0.9077+0.0000j,  0.0000-0.2895j,  0.0000-0.2895j, -0.0923+0.0000j]])\nxs = [Counter({'00': 93, '01': 3, '10': 3, '11': 1}), Counter({'00': 77, '10': 15, '01': 8}), Counter({'00': 82, '10': 10, '01': 8})]\nex = tensor([[0.9408],\n[0.8180],\n[0.8154]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9408, 0.9408],\n[0.8180, 0.8180],\n[0.8154, 0.8154]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-11-13T15:12:00.218265 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code>:</p> <pre><code>from qadence import Register\nreg = Register.honeycomb_lattice(2, 3)\nreg.draw(show=False)\n</code></pre> 2023-11-13T15:12:00.829693 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Arbitrarily shaped registers can be constructed by providing coordinates.</p> <p>Registers defined from coordinates</p> <p><code>Register</code> constructed via the <code>from_coordinates</code> method do not define edges in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\nreg = Register.from_coordinates(\n[(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\nreg.draw(show=False)\n</code></pre> 2023-11-13T15:12:00.939776 image/svg+xml Matplotlib v3.7.3, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units given to qubit coordinates. However, if used in the context of a Hamiltonian coefficient, the quantity \\(H.t\\) must be dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\) (consistent ). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>It is possible to customize qubit interaction through the <code>add_interaction</code> method. In that case, <code>Register.coords</code> are accessible from the concrete graph:</p> <pre><code>print(f\"{reg.coords = }\")\n</code></pre> <pre><code>reg.coords = {0: (0.0, 0.0), 1: (0.0, 1.0), 2: (1.0, 0.0), 3: (1.0, 1.0), 4: (2.0, 0.0), 5: (2.0, 1.0)}\n</code></pre> <p>More details about their usage in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\nn_qubits = 4\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 51, '00': 49})]\nSample in little endian = [Counter({'10': 54, '00': 46})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 51, '00': 49})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nCNOT matrix in little endian =\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\nOn PyQTorch = [Counter({'00': 87, '01': 13})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 89, '01': 11})]\nSame wavefunction order:\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n# Check the normalization.\nassert is_normalized(state)\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\nstate = [ 0.85139706+0.j          0.        +0.49866638j  0.        +0.14034828j\n-0.0822025 +0.j        ]\nProduct state corresponding to bitstring '01':\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n# Let's now prepare a circuit.\nn_qubits = 4\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_3934ac68c4ae41b99faf90d704f6bd32 Circuit block cluster_8355210bd6ab4ca6b1c87500d9304bb8 Prep block cfd4e96c60454606b57c4fc66dae18c8 0 5439b9e43de34b53b112f90c5fb0abd6 cfd4e96c60454606b57c4fc66dae18c8--5439b9e43de34b53b112f90c5fb0abd6 2cacda3403ed47caa4e94b1faa747c34 1 ddee1d03f6014f34962b56aaf514c0dd RX(theta\u2080) 5439b9e43de34b53b112f90c5fb0abd6--ddee1d03f6014f34962b56aaf514c0dd c0b927e657f14d18907dddb3bdba1f59 RY(theta\u2084) ddee1d03f6014f34962b56aaf514c0dd--c0b927e657f14d18907dddb3bdba1f59 20d063099b794782bae311565880f972 RX(theta\u2088) c0b927e657f14d18907dddb3bdba1f59--20d063099b794782bae311565880f972 baddd71052cf471eb99ea42813ea07bf 20d063099b794782bae311565880f972--baddd71052cf471eb99ea42813ea07bf 88a7804c4dcf495eb2a1fefd83337cc9 baddd71052cf471eb99ea42813ea07bf--88a7804c4dcf495eb2a1fefd83337cc9 0458df360bc842729b312ffdc31243b9 RX(theta\u2081\u2082) 88a7804c4dcf495eb2a1fefd83337cc9--0458df360bc842729b312ffdc31243b9 0b25b56ff2044f929447391b71e6d3b1 RY(theta\u2081\u2086) 0458df360bc842729b312ffdc31243b9--0b25b56ff2044f929447391b71e6d3b1 ada7aba0d84f47dba2fa8a62450c928e RX(theta\u2082\u2080) 0b25b56ff2044f929447391b71e6d3b1--ada7aba0d84f47dba2fa8a62450c928e 97765c84c5aa497d8a1fbb964a1e9f6d ada7aba0d84f47dba2fa8a62450c928e--97765c84c5aa497d8a1fbb964a1e9f6d 23f5b41eb4ba4380a0c05cfa768f3ea9 97765c84c5aa497d8a1fbb964a1e9f6d--23f5b41eb4ba4380a0c05cfa768f3ea9 864e69dded2b4e39b5f487b1bd00dceb 23f5b41eb4ba4380a0c05cfa768f3ea9--864e69dded2b4e39b5f487b1bd00dceb 55655821e7764cfcafd4960f3fc714e4 3bfe2db109ef4bfcb7d479dbc45adee0 2cacda3403ed47caa4e94b1faa747c34--3bfe2db109ef4bfcb7d479dbc45adee0 c745fc6c8d61482fae8dd05e31c88148 2 2a1f4c8591174e0d9bfc364bc0e3f20a RX(theta\u2081) 3bfe2db109ef4bfcb7d479dbc45adee0--2a1f4c8591174e0d9bfc364bc0e3f20a 4d16d01a1c20495ba060acd8c4436e71 RY(theta\u2085) 2a1f4c8591174e0d9bfc364bc0e3f20a--4d16d01a1c20495ba060acd8c4436e71 661c2ce281bd4467b6e0297a996418c1 RX(theta\u2089) 4d16d01a1c20495ba060acd8c4436e71--661c2ce281bd4467b6e0297a996418c1 d2404308d4114597a85d0e0bf796aa88 X 661c2ce281bd4467b6e0297a996418c1--d2404308d4114597a85d0e0bf796aa88 d2404308d4114597a85d0e0bf796aa88--baddd71052cf471eb99ea42813ea07bf 0f2569ce098449e28ce66129194f9a02 d2404308d4114597a85d0e0bf796aa88--0f2569ce098449e28ce66129194f9a02 d988cf5e1a18455999c10d66579c0269 RX(theta\u2081\u2083) 0f2569ce098449e28ce66129194f9a02--d988cf5e1a18455999c10d66579c0269 5a5f224da6444cb88c9c463b2e883a4b RY(theta\u2081\u2087) d988cf5e1a18455999c10d66579c0269--5a5f224da6444cb88c9c463b2e883a4b 24840e9b4ae549919e3b244113e60d28 RX(theta\u2082\u2081) 5a5f224da6444cb88c9c463b2e883a4b--24840e9b4ae549919e3b244113e60d28 e7a356803fb34764b7ff0b70f7b5b97e X 24840e9b4ae549919e3b244113e60d28--e7a356803fb34764b7ff0b70f7b5b97e e7a356803fb34764b7ff0b70f7b5b97e--97765c84c5aa497d8a1fbb964a1e9f6d 028f51b761a943caaea4bcddb569c804 e7a356803fb34764b7ff0b70f7b5b97e--028f51b761a943caaea4bcddb569c804 028f51b761a943caaea4bcddb569c804--55655821e7764cfcafd4960f3fc714e4 a101340f9fff429fa6c878ee2ea12607 d0cf92d5e9af4c00a41ed90f60c87212 c745fc6c8d61482fae8dd05e31c88148--d0cf92d5e9af4c00a41ed90f60c87212 75abf5197bbd4e979a642e0bd42fa138 3 db0200d09d9b4726973d174cf6f15b93 RX(theta\u2082) d0cf92d5e9af4c00a41ed90f60c87212--db0200d09d9b4726973d174cf6f15b93 d064e403bfae482cacc7d7d4f9d32be0 RY(theta\u2086) db0200d09d9b4726973d174cf6f15b93--d064e403bfae482cacc7d7d4f9d32be0 d446a35fb988474eb79b5a9ef20a1d18 RX(theta\u2081\u2080) d064e403bfae482cacc7d7d4f9d32be0--d446a35fb988474eb79b5a9ef20a1d18 707a0f63a38c43fa8d8b0e52d0f53a08 d446a35fb988474eb79b5a9ef20a1d18--707a0f63a38c43fa8d8b0e52d0f53a08 cdc35221e76d439c9de946db0e6a3782 X 707a0f63a38c43fa8d8b0e52d0f53a08--cdc35221e76d439c9de946db0e6a3782 cdc35221e76d439c9de946db0e6a3782--0f2569ce098449e28ce66129194f9a02 18acaac294af45fab459c7c369ab087c RX(theta\u2081\u2084) cdc35221e76d439c9de946db0e6a3782--18acaac294af45fab459c7c369ab087c 52a8f304c6b1447d9fd06ff7da83a120 RY(theta\u2081\u2088) 18acaac294af45fab459c7c369ab087c--52a8f304c6b1447d9fd06ff7da83a120 a12d872ed5c8405794b79ad7ef165cce RX(theta\u2082\u2082) 52a8f304c6b1447d9fd06ff7da83a120--a12d872ed5c8405794b79ad7ef165cce d2fa75f75cc74c389fd77ee9eb9a8e8a a12d872ed5c8405794b79ad7ef165cce--d2fa75f75cc74c389fd77ee9eb9a8e8a c03bc8e9de7e4d5696519533a5831957 X d2fa75f75cc74c389fd77ee9eb9a8e8a--c03bc8e9de7e4d5696519533a5831957 c03bc8e9de7e4d5696519533a5831957--028f51b761a943caaea4bcddb569c804 c03bc8e9de7e4d5696519533a5831957--a101340f9fff429fa6c878ee2ea12607 f98362f336374dedb4acac86d07cd997 e5e64b7fbb2f4fcda42e6296c717ead0 X 75abf5197bbd4e979a642e0bd42fa138--e5e64b7fbb2f4fcda42e6296c717ead0 70aa09a0998e4b96bb9467177b503bb1 RX(theta\u2083) e5e64b7fbb2f4fcda42e6296c717ead0--70aa09a0998e4b96bb9467177b503bb1 49730a4027ed4699b2a24ebc31b7b23d RY(theta\u2087) 70aa09a0998e4b96bb9467177b503bb1--49730a4027ed4699b2a24ebc31b7b23d 6a978faf41e14665b1e7b5b7cfe25cf7 RX(theta\u2081\u2081) 49730a4027ed4699b2a24ebc31b7b23d--6a978faf41e14665b1e7b5b7cfe25cf7 3df93b55231147a89bc5aa754bfe135a X 6a978faf41e14665b1e7b5b7cfe25cf7--3df93b55231147a89bc5aa754bfe135a 3df93b55231147a89bc5aa754bfe135a--707a0f63a38c43fa8d8b0e52d0f53a08 d86ee0f188d748e086ba805f6e3852a0 3df93b55231147a89bc5aa754bfe135a--d86ee0f188d748e086ba805f6e3852a0 788f074b6a2142d596fdd0612d488b52 RX(theta\u2081\u2085) d86ee0f188d748e086ba805f6e3852a0--788f074b6a2142d596fdd0612d488b52 d047abc2dc9942a0b93d60d75afcfa53 RY(theta\u2081\u2089) 788f074b6a2142d596fdd0612d488b52--d047abc2dc9942a0b93d60d75afcfa53 6897cdf0cd344c5faf17d6e0d3345269 RX(theta\u2082\u2083) d047abc2dc9942a0b93d60d75afcfa53--6897cdf0cd344c5faf17d6e0d3345269 83f1187f3385478aa06542b0588ac576 X 6897cdf0cd344c5faf17d6e0d3345269--83f1187f3385478aa06542b0588ac576 83f1187f3385478aa06542b0588ac576--d2fa75f75cc74c389fd77ee9eb9a8e8a 5285e2e369934727bc1d405f33d82589 83f1187f3385478aa06542b0588ac576--5285e2e369934727bc1d405f33d82589 5285e2e369934727bc1d405f33d82589--f98362f336374dedb4acac86d07cd997  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\nn_qubits = 3\nbatch_size = 2\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = tensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j],\n[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n0.3536+0.j]])\nZero state = tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nRandom state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j],\n[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = tensor([[ 0.1643-0.0622j, -0.5407+0.1029j,  0.1102-0.1265j, -0.6922+0.0940j,\n-0.1508-0.2266j, -0.1701+0.0631j,  0.1501-0.0578j, -0.0811+0.1033j],\n[-0.0584-0.0556j, -0.0646+0.2321j,  0.2937-0.1183j,  0.0567+0.0674j,\n0.3735+0.2155j,  0.2888-0.0695j, -0.3494-0.3858j, -0.0950+0.5228j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\nn_qubits = 3\nuniform_block = uniform_block(n_qubits)\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\nproduct_block = product_block(\"100\")\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 I(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 I(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n\u251c\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\nn_qubits = 3\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}