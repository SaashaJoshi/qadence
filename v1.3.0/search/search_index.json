{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>For a high-level overview of Qadence features, check out our white paper.</p> <p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from qadence import X, Y, HamEvo, Register, product_state, sample, add, PI\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = PI / (2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from qadence import Register, AnalogRX, sample, PI\n\n# Global analog RX block.\nblock = AnalogRX(PI)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(PI))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'10': 41, '00': 30, '01': 29})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@article{qadence2024pasqal,\n  title = {Qadence: a differentiable interface for digital-analog programs.},\n  author={Dominik Seitz and Niklas Heim and Jo\u00e3o P. Moutinho and Roland Guichard and Vytautas Abramavicius and Aleksander Wennersteen and Gert-Jan Both and Anton Quelle and Caroline de Groot and Gergana V. Velikova and Vincent E. Elfving and Mario Dagrada},\n  journal={arXiv:2401.09915},\n  url = {https://github.com/pasqal-io/qadence},\n  year = {2024}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    else:\n        self._noise = noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available via the PyQTorch or Horqrux backends</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> or <code>horqrux</code> backends are selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p>Qadence also offers a memory-efficient, non-device compatible alternative to automatic differentation, called 'Adjoint Differentiation' <sup>4</sup> and allows for precisely calculating the gradients of variational parameters in O(P) time and using O(1) state-vectors. Adjoint Differentation is currently only supported by the Torch Engine and allows for first-order derivatives only.</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the differentiation modes can be selected via the <code>diff_mode</code> argument of the QuantumModel class. It either accepts a <code>DiffMode</code>(<code>DiffMode.GSPR</code>, <code>DiffMode.AD</code> or <code>DiffMode.ADJOINT</code>) or a string (<code>\"gpsr\"\"</code>, <code>\"ad\"</code> or <code>\"adjoint\"</code>). The code in the box below shows how to create <code>QuantumModel</code> instances with all available differentiation modes.</p> <pre><code>from qadence import (FeatureParameter, RX, Z, hea, chain,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# Define a symbolic parameter to differentiate with respect to\nx = FeatureParameter(\"x\")\n\nblock = chain(hea(n_qubits, 1), RX(0, x))\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD, ADJOINT and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_adjoint = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.ADJOINT)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# Create concrete values for the parameter we want to differentiate with respect to\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_adjoint = model_adjoint.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_adjoint = torch.autograd.grad(\n    exp_val_adjoint, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD ,ADJOINT and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_adjoint.detach().numpy(),\n           label=\"df/dx ADJOINT\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2024-02-06T10:21:28.550618 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#low-level-differentiation-of-qadence-circuits-using-jax","title":"Low-level differentiation of qadence circuits using JAX","text":"<p>For users interested in using the <code>JAX</code> engine instead, we show how to run and differentiate qadence programs using the <code>horqrux</code> backend under qadence examples.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> <li> <p>Tyson et al., Efficient calculation of gradients in classical simulations of variational quantum algorithms \u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, InteractionBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n    self.hmat: Tensor\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self.register_buffer(\"hmat\", hmat)\n        self._hamiltonian = lambda self, values: self.hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self.register_buffer(\"hmat\", hmat)\n        self._hamiltonian = lambda self, values: self.hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda self, values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(self: PyQHamiltonianEvolution, values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n                device=self.device,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n    self._device: torch_device = (\n        self.hmat.device if hasattr(self, \"hmat\") else torch_device(\"cpu\")\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n            device=self.device,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(self, values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(self, values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 1daa117c21bb43e5b7e8dece3354dc53 0 3a85c69e67da4e12a757a2fcda22f635 X 1daa117c21bb43e5b7e8dece3354dc53--3a85c69e67da4e12a757a2fcda22f635 fd54127a3e084cb8a0a0da963b07d270 1 dc8d14ba2ee4485e97b5084f4dd3ef7a 3a85c69e67da4e12a757a2fcda22f635--dc8d14ba2ee4485e97b5084f4dd3ef7a 6b7ed2e1c9be46c0aafed23df7aa6f79 961d22eef5c94689b8c1fa1e515184ce Y fd54127a3e084cb8a0a0da963b07d270--961d22eef5c94689b8c1fa1e515184ce 961d22eef5c94689b8c1fa1e515184ce--6b7ed2e1c9be46c0aafed23df7aa6f79 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 2dddc6d8157c41e3ad047617a58e1c13 0 d50c205a7f634f33ba002e9b699708d2 X 2dddc6d8157c41e3ad047617a58e1c13--d50c205a7f634f33ba002e9b699708d2 ab58099b57ec483da8987ca32daee2cb Y d50c205a7f634f33ba002e9b699708d2--ab58099b57ec483da8987ca32daee2cb a9291538dffd46ab8daa65f322a17203 ab58099b57ec483da8987ca32daee2cb--a9291538dffd46ab8daa65f322a17203 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 a904cc09d8d241b7b0c07654253b789b 0 dbaf08d4537441b78a40d32feae2cc9d X a904cc09d8d241b7b0c07654253b789b--dbaf08d4537441b78a40d32feae2cc9d ec0a0159732f4d1e82803c29fd783a18 1 cddd9e33694e4943ab8e7768642edc45 dbaf08d4537441b78a40d32feae2cc9d--cddd9e33694e4943ab8e7768642edc45 8ee3bf44ddfb445a8a67f61c557224bc cddd9e33694e4943ab8e7768642edc45--8ee3bf44ddfb445a8a67f61c557224bc 96ecd7a7bf84460eae84b12fef1b7e54 24cd5aa748554241bb0ba759db887979 ec0a0159732f4d1e82803c29fd783a18--24cd5aa748554241bb0ba759db887979 5b5c1c825a074eadb7eafcfcb4ffcf10 Y 24cd5aa748554241bb0ba759db887979--5b5c1c825a074eadb7eafcfcb4ffcf10 5b5c1c825a074eadb7eafcfcb4ffcf10--96ecd7a7bf84460eae84b12fef1b7e54 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_3ddd5bf09da94c4695ac9dec721403e2 9b5e3a341b2f4d4fa04cc0377ec6c9ca 0 89afc7e30d484c41804ad0263e7d428d 9b5e3a341b2f4d4fa04cc0377ec6c9ca--89afc7e30d484c41804ad0263e7d428d c48b76c9ff6042de92367bfb7daa0a1c 1 28fd3f84df8e4347b757af7969714cf1 89afc7e30d484c41804ad0263e7d428d--28fd3f84df8e4347b757af7969714cf1 57c07b25c3a84e9cbb6e794dfe12ded4 e6c96c3c822841438b506e2e434730ca AddBlock c48b76c9ff6042de92367bfb7daa0a1c--e6c96c3c822841438b506e2e434730ca 3e1819fd937444788d7a76adc06e45e5 2 e6c96c3c822841438b506e2e434730ca--57c07b25c3a84e9cbb6e794dfe12ded4 8a4f7661175c43c1a9901c07dfe9733d 34c9dc4b98f14127b7f3f2592ed35a70 3e1819fd937444788d7a76adc06e45e5--34c9dc4b98f14127b7f3f2592ed35a70 34c9dc4b98f14127b7f3f2592ed35a70--8a4f7661175c43c1a9901c07dfe9733d <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_f309f73916c547b590252bc85fc6047b cluster_211ceb986dc14e658d8bc52a711019ef rx c5026c52bbcd459ebde4ee9453314e0d 0 a6239b9bf6b6475ab88b765e4c00e097 X c5026c52bbcd459ebde4ee9453314e0d--a6239b9bf6b6475ab88b765e4c00e097 7a0cc5ff2c0045809a9d22a5683059d4 1 f74ef5ffb3e146e28256e264b48bddd9 a6239b9bf6b6475ab88b765e4c00e097--f74ef5ffb3e146e28256e264b48bddd9 76ddfafeec5c4f4b92e16dc49bbdad0b f74ef5ffb3e146e28256e264b48bddd9--76ddfafeec5c4f4b92e16dc49bbdad0b 3b5fb597985a4e7683fc95183a4ec6f8 76ddfafeec5c4f4b92e16dc49bbdad0b--3b5fb597985a4e7683fc95183a4ec6f8 fbe101d686c34253a165b7aae7ec7950 3cb12ed091f94ab6a255c35cbaf8dd02 Y 7a0cc5ff2c0045809a9d22a5683059d4--3cb12ed091f94ab6a255c35cbaf8dd02 e1b0129cc6c94b26862688bfca581a40 2 18b065d736e24ec8b00fc8e5626ddefc 3cb12ed091f94ab6a255c35cbaf8dd02--18b065d736e24ec8b00fc8e5626ddefc 2dd0a94139be4b318312608f11e6ddc6 HamEvo 18b065d736e24ec8b00fc8e5626ddefc--2dd0a94139be4b318312608f11e6ddc6 2dd0a94139be4b318312608f11e6ddc6--fbe101d686c34253a165b7aae7ec7950 b882e79f850c497c8c89fbcfd925722c 3e328bc354894f9dbd127131eaa24885 RX(x) e1b0129cc6c94b26862688bfca581a40--3e328bc354894f9dbd127131eaa24885 65c80d2359e14da09572db060e94fc25 3 868e20a75b2a410e9b5999b05f063387 3e328bc354894f9dbd127131eaa24885--868e20a75b2a410e9b5999b05f063387 287d8b46e5d24649809bcea5e47f5c7b t = 10 868e20a75b2a410e9b5999b05f063387--287d8b46e5d24649809bcea5e47f5c7b 287d8b46e5d24649809bcea5e47f5c7b--b882e79f850c497c8c89fbcfd925722c 6ce3e454c6b14ad6bc80db03fae0b687 1f97c61a05134ff3b2d3efad94d37db3 RX(0.5) 65c80d2359e14da09572db060e94fc25--1f97c61a05134ff3b2d3efad94d37db3 b059e2d0f1eb4700965cb333458b40e8 X 1f97c61a05134ff3b2d3efad94d37db3--b059e2d0f1eb4700965cb333458b40e8 b059e2d0f1eb4700965cb333458b40e8--868e20a75b2a410e9b5999b05f063387 287970447c8b41bfb75e1268510aa867 b059e2d0f1eb4700965cb333458b40e8--287970447c8b41bfb75e1268510aa867 287970447c8b41bfb75e1268510aa867--6ce3e454c6b14ad6bc80db03fae0b687 <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_5a30865feea649058fceece1715d86cb HEA cluster_f9c9cfe0288244548bf9a341b702a200 Tower Fourier FM a3b03fafd66c43759ed4e8b5563a1c6f 0 fb609ae447014a6d89967f89c062f451 RX(1.0*phi) a3b03fafd66c43759ed4e8b5563a1c6f--fb609ae447014a6d89967f89c062f451 3dd53dd129334e3389bcc86fda892a0d 1 3b05ff3f5e69461ea9a8b4c9d94878ce RX(theta\u2080) fb609ae447014a6d89967f89c062f451--3b05ff3f5e69461ea9a8b4c9d94878ce a092aa4c378749e4a38fb642ce9343a4 RY(theta\u2084) 3b05ff3f5e69461ea9a8b4c9d94878ce--a092aa4c378749e4a38fb642ce9343a4 587c6cc8e0bf4b36ab722ba5420999c7 RX(theta\u2088) a092aa4c378749e4a38fb642ce9343a4--587c6cc8e0bf4b36ab722ba5420999c7 38baf10af8674bf5b6438d6199957743 587c6cc8e0bf4b36ab722ba5420999c7--38baf10af8674bf5b6438d6199957743 19a93cd80785490fa2ce47be074485a4 38baf10af8674bf5b6438d6199957743--19a93cd80785490fa2ce47be074485a4 2e5b3d4ebe2246d79d9592e1e7d457d4 RX(theta\u2081\u2082) 19a93cd80785490fa2ce47be074485a4--2e5b3d4ebe2246d79d9592e1e7d457d4 b1b8f39ea7414ef3b57688f46a1797d7 RY(theta\u2081\u2086) 2e5b3d4ebe2246d79d9592e1e7d457d4--b1b8f39ea7414ef3b57688f46a1797d7 0fe58212e74d47a9ab9f492be45da475 RX(theta\u2082\u2080) b1b8f39ea7414ef3b57688f46a1797d7--0fe58212e74d47a9ab9f492be45da475 4af8129727b345ac8c808e2a5517118f 0fe58212e74d47a9ab9f492be45da475--4af8129727b345ac8c808e2a5517118f 318c74940a5e4c729b06b82cb5814b61 4af8129727b345ac8c808e2a5517118f--318c74940a5e4c729b06b82cb5814b61 54706e2dfb2245c2b6f27fcd648b2445 318c74940a5e4c729b06b82cb5814b61--54706e2dfb2245c2b6f27fcd648b2445 a00c8900da7a428cb46d35ce63212fe8 3572f9193cba4bf7af87b1bc8b62229e RX(2.0*phi) 3dd53dd129334e3389bcc86fda892a0d--3572f9193cba4bf7af87b1bc8b62229e f658111ec85f49329e3d6914d24b8481 2 ba56c55af34f4766b6219be9cc12d84e RX(theta\u2081) 3572f9193cba4bf7af87b1bc8b62229e--ba56c55af34f4766b6219be9cc12d84e e3ccaf7a819a40d0a2b56aa2ce671387 RY(theta\u2085) ba56c55af34f4766b6219be9cc12d84e--e3ccaf7a819a40d0a2b56aa2ce671387 d5da058a79214537ab446272cedd8a2d RX(theta\u2089) e3ccaf7a819a40d0a2b56aa2ce671387--d5da058a79214537ab446272cedd8a2d 2d51759e928941b1bb1d60fc31dbdca4 X d5da058a79214537ab446272cedd8a2d--2d51759e928941b1bb1d60fc31dbdca4 2d51759e928941b1bb1d60fc31dbdca4--38baf10af8674bf5b6438d6199957743 d8d1aec99567452a92a62040393e9e8f 2d51759e928941b1bb1d60fc31dbdca4--d8d1aec99567452a92a62040393e9e8f d7e4abcbd7fb4b4ea84d23f781667884 RX(theta\u2081\u2083) d8d1aec99567452a92a62040393e9e8f--d7e4abcbd7fb4b4ea84d23f781667884 8f6912124f9d4a84a596da1f177ebeb4 RY(theta\u2081\u2087) d7e4abcbd7fb4b4ea84d23f781667884--8f6912124f9d4a84a596da1f177ebeb4 13e941f197ed4babb9814902b5ee04d4 RX(theta\u2082\u2081) 8f6912124f9d4a84a596da1f177ebeb4--13e941f197ed4babb9814902b5ee04d4 f59e2ca264d4413e820e005e52f251c5 X 13e941f197ed4babb9814902b5ee04d4--f59e2ca264d4413e820e005e52f251c5 f59e2ca264d4413e820e005e52f251c5--4af8129727b345ac8c808e2a5517118f 1608498244074258ae913f798b2a4a4d f59e2ca264d4413e820e005e52f251c5--1608498244074258ae913f798b2a4a4d 1608498244074258ae913f798b2a4a4d--a00c8900da7a428cb46d35ce63212fe8 c3d2b5ccd7ed469c9abbc7129e4ae547 88a8e1ce18c6403aa5ca4392f3cddaed RX(3.0*phi) f658111ec85f49329e3d6914d24b8481--88a8e1ce18c6403aa5ca4392f3cddaed baeb67ff0fc44f3e9cf6ef7f4c535205 3 3393edd4aa23467fb975af7af06d1b1d RX(theta\u2082) 88a8e1ce18c6403aa5ca4392f3cddaed--3393edd4aa23467fb975af7af06d1b1d 8ba4ece96aee4d5e95e6d5a6517616cd RY(theta\u2086) 3393edd4aa23467fb975af7af06d1b1d--8ba4ece96aee4d5e95e6d5a6517616cd 3818a4a1cd6a4e88b82dffc8309e79fe RX(theta\u2081\u2080) 8ba4ece96aee4d5e95e6d5a6517616cd--3818a4a1cd6a4e88b82dffc8309e79fe 42bd302e87a846ae940f91f2c9edc511 3818a4a1cd6a4e88b82dffc8309e79fe--42bd302e87a846ae940f91f2c9edc511 c822a1643465439782e99463adb60703 X 42bd302e87a846ae940f91f2c9edc511--c822a1643465439782e99463adb60703 c822a1643465439782e99463adb60703--d8d1aec99567452a92a62040393e9e8f 637403fa5a3a4ce5afb3480f32641519 RX(theta\u2081\u2084) c822a1643465439782e99463adb60703--637403fa5a3a4ce5afb3480f32641519 e4c19e22b2234ccaaaf1e9dde902c5f4 RY(theta\u2081\u2088) 637403fa5a3a4ce5afb3480f32641519--e4c19e22b2234ccaaaf1e9dde902c5f4 584741a6e5e24ba3b1bab5f1b010f4e5 RX(theta\u2082\u2082) e4c19e22b2234ccaaaf1e9dde902c5f4--584741a6e5e24ba3b1bab5f1b010f4e5 5f605fb9baef47eb912af489befca9aa 584741a6e5e24ba3b1bab5f1b010f4e5--5f605fb9baef47eb912af489befca9aa fd1b44808afc452487810951d5668080 X 5f605fb9baef47eb912af489befca9aa--fd1b44808afc452487810951d5668080 fd1b44808afc452487810951d5668080--1608498244074258ae913f798b2a4a4d fd1b44808afc452487810951d5668080--c3d2b5ccd7ed469c9abbc7129e4ae547 174b1d7c14554b15bc35871253e2c372 35a5507d64d743c4843d0d80931750f8 RX(4.0*phi) baeb67ff0fc44f3e9cf6ef7f4c535205--35a5507d64d743c4843d0d80931750f8 c842ee7e06bc4bc0a804914bbe47c840 RX(theta\u2083) 35a5507d64d743c4843d0d80931750f8--c842ee7e06bc4bc0a804914bbe47c840 0f1c49eb14204c2a9d421c999de51983 RY(theta\u2087) c842ee7e06bc4bc0a804914bbe47c840--0f1c49eb14204c2a9d421c999de51983 d09c27da3c6847ed83e455f01ff95b02 RX(theta\u2081\u2081) 0f1c49eb14204c2a9d421c999de51983--d09c27da3c6847ed83e455f01ff95b02 b6ec1b43bccf437981ac0d881e0373f8 X d09c27da3c6847ed83e455f01ff95b02--b6ec1b43bccf437981ac0d881e0373f8 b6ec1b43bccf437981ac0d881e0373f8--42bd302e87a846ae940f91f2c9edc511 e7647b6ab45b4d83ad272ad3b0ec072e b6ec1b43bccf437981ac0d881e0373f8--e7647b6ab45b4d83ad272ad3b0ec072e 182452c69f634c99aa2e737aedebb82c RX(theta\u2081\u2085) e7647b6ab45b4d83ad272ad3b0ec072e--182452c69f634c99aa2e737aedebb82c 2977223c6e4c4cf194aa77d9d3cd770b RY(theta\u2081\u2089) 182452c69f634c99aa2e737aedebb82c--2977223c6e4c4cf194aa77d9d3cd770b bc89f95f9b204c80842544ea952415f6 RX(theta\u2082\u2083) 2977223c6e4c4cf194aa77d9d3cd770b--bc89f95f9b204c80842544ea952415f6 e68c7327a8b6401391586233d56e2822 X bc89f95f9b204c80842544ea952415f6--e68c7327a8b6401391586233d56e2822 e68c7327a8b6401391586233d56e2822--5f605fb9baef47eb912af489befca9aa 005f58f5232047b2bc8ad3c003e8b376 e68c7327a8b6401391586233d56e2822--005f58f5232047b2bc8ad3c003e8b376 005f58f5232047b2bc8ad3c003e8b376--174b1d7c14554b15bc35871253e2c372 <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_defef0696faf499da9a0825459f76b3f Obs. cluster_c96bb275c72f4af9a6454805ff79dba2 cluster_a9c1a8db7de5470e8ebefa039860df88 HEA 3e85aa99042445c0b1390ad3a426d073 0 5e5a1fd1f6fc438f91c5129278c08e61 RX(theta\u2080) 3e85aa99042445c0b1390ad3a426d073--5e5a1fd1f6fc438f91c5129278c08e61 4ae3d8e442844aec8f5f39cf0726d90a 1 4342554cee654af09a50a85cd8833789 RY(theta\u2083) 5e5a1fd1f6fc438f91c5129278c08e61--4342554cee654af09a50a85cd8833789 4c417ecb661e447a8dc9d8b4e1ee180f RX(theta\u2086) 4342554cee654af09a50a85cd8833789--4c417ecb661e447a8dc9d8b4e1ee180f ec43b9244cf34bbfb1f46a695c143a19 4c417ecb661e447a8dc9d8b4e1ee180f--ec43b9244cf34bbfb1f46a695c143a19 0e2dafe59b3f4fe28cec79ff4fbd23e3 ec43b9244cf34bbfb1f46a695c143a19--0e2dafe59b3f4fe28cec79ff4fbd23e3 ce18a0f321de4702b1208b3d30b3c74d RX(theta\u2089) 0e2dafe59b3f4fe28cec79ff4fbd23e3--ce18a0f321de4702b1208b3d30b3c74d fe35e0936f884d6abf5538a939bec1cd RY(theta\u2081\u2082) ce18a0f321de4702b1208b3d30b3c74d--fe35e0936f884d6abf5538a939bec1cd d6c2979f80d94c869b3ff7a088404bea RX(theta\u2081\u2085) fe35e0936f884d6abf5538a939bec1cd--d6c2979f80d94c869b3ff7a088404bea 7c67c515039947f6a5b0843acbc87e79 d6c2979f80d94c869b3ff7a088404bea--7c67c515039947f6a5b0843acbc87e79 6863fb89ec5b4e17a8a0591d7d9e0e00 7c67c515039947f6a5b0843acbc87e79--6863fb89ec5b4e17a8a0591d7d9e0e00 17a73e65e2564f7cb4832f3067edde58 6863fb89ec5b4e17a8a0591d7d9e0e00--17a73e65e2564f7cb4832f3067edde58 f4afbbabaf4e4cbdbbda98be908dbd1c 17a73e65e2564f7cb4832f3067edde58--f4afbbabaf4e4cbdbbda98be908dbd1c d857c876383c456fbaaa8ca83fd8df22 bb5b62ab4e6d4b8d9500696b65fe2875 RX(theta\u2081) 4ae3d8e442844aec8f5f39cf0726d90a--bb5b62ab4e6d4b8d9500696b65fe2875 0346801779d34e10ab2a1eeb43a903ad 2 e32bf6d8f1b34fe388a913e27d61c566 RY(theta\u2084) bb5b62ab4e6d4b8d9500696b65fe2875--e32bf6d8f1b34fe388a913e27d61c566 f74073b9301c42348f8f8219b519a38a RX(theta\u2087) e32bf6d8f1b34fe388a913e27d61c566--f74073b9301c42348f8f8219b519a38a 2008b43715c54277be362fe32fccc4b5 X f74073b9301c42348f8f8219b519a38a--2008b43715c54277be362fe32fccc4b5 2008b43715c54277be362fe32fccc4b5--ec43b9244cf34bbfb1f46a695c143a19 8d898797dcce4237afbc653686dfeb04 2008b43715c54277be362fe32fccc4b5--8d898797dcce4237afbc653686dfeb04 a29bc92003584136882ed65246b33558 RX(theta\u2081\u2080) 8d898797dcce4237afbc653686dfeb04--a29bc92003584136882ed65246b33558 ab2132bc10ab45f38f782a150b1c3f81 RY(theta\u2081\u2083) a29bc92003584136882ed65246b33558--ab2132bc10ab45f38f782a150b1c3f81 132e598bf87445e884c7d425ef818b1c RX(theta\u2081\u2086) ab2132bc10ab45f38f782a150b1c3f81--132e598bf87445e884c7d425ef818b1c 13d754a525de425e93ebcb65106ddbd9 X 132e598bf87445e884c7d425ef818b1c--13d754a525de425e93ebcb65106ddbd9 13d754a525de425e93ebcb65106ddbd9--7c67c515039947f6a5b0843acbc87e79 c17dc57001fc4e728d982577f239831c 13d754a525de425e93ebcb65106ddbd9--c17dc57001fc4e728d982577f239831c 27e64b12c0e04046b53e32388ca0aa39 AddBlock c17dc57001fc4e728d982577f239831c--27e64b12c0e04046b53e32388ca0aa39 27e64b12c0e04046b53e32388ca0aa39--d857c876383c456fbaaa8ca83fd8df22 f6c95b93c1734ed69456343b97d01486 b3ecbb3280f34923ab4bf4a9364ee038 RX(theta\u2082) 0346801779d34e10ab2a1eeb43a903ad--b3ecbb3280f34923ab4bf4a9364ee038 f565c65212ff454288b8a7724dbc77f3 RY(theta\u2085) b3ecbb3280f34923ab4bf4a9364ee038--f565c65212ff454288b8a7724dbc77f3 581f40d7b2cb4e9b9115e19b1aee92b1 RX(theta\u2088) f565c65212ff454288b8a7724dbc77f3--581f40d7b2cb4e9b9115e19b1aee92b1 c37de2f56301412a9087656716fcdb25 581f40d7b2cb4e9b9115e19b1aee92b1--c37de2f56301412a9087656716fcdb25 ca40076c4a99419aa196b891392366e2 X c37de2f56301412a9087656716fcdb25--ca40076c4a99419aa196b891392366e2 ca40076c4a99419aa196b891392366e2--8d898797dcce4237afbc653686dfeb04 35c6aeffd28746b48574770935dc25a3 RX(theta\u2081\u2081) ca40076c4a99419aa196b891392366e2--35c6aeffd28746b48574770935dc25a3 a53723c32daa47cea399331e50374edb RY(theta\u2081\u2084) 35c6aeffd28746b48574770935dc25a3--a53723c32daa47cea399331e50374edb 72a2c295e3f04b99baa7ad81178520b5 RX(theta\u2081\u2087) a53723c32daa47cea399331e50374edb--72a2c295e3f04b99baa7ad81178520b5 73a2e9485ecc40ecb9efa79e4d3e89d1 72a2c295e3f04b99baa7ad81178520b5--73a2e9485ecc40ecb9efa79e4d3e89d1 9260526207814accb20457ec7497e8a5 X 73a2e9485ecc40ecb9efa79e4d3e89d1--9260526207814accb20457ec7497e8a5 9260526207814accb20457ec7497e8a5--c17dc57001fc4e728d982577f239831c 69b44d230df9440b8c301a96a0b65788 9260526207814accb20457ec7497e8a5--69b44d230df9440b8c301a96a0b65788 69b44d230df9440b8c301a96a0b65788--f6c95b93c1734ed69456343b97d01486 <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 8723f533454241f5945a8f405df65481 0 73bfbbcb6b274b48a27f42ce920da117 8723f533454241f5945a8f405df65481--73bfbbcb6b274b48a27f42ce920da117 bd32ac0661104866a3ea245c93c59b50 1 b8c7075f79174fc3baf9315601ed9773 9fc11298d5504eee88897dbb2fd498b8 73bfbbcb6b274b48a27f42ce920da117--9fc11298d5504eee88897dbb2fd498b8 c1a6a08b6d09448d8f6ae0c59676b324 b8c7075f79174fc3baf9315601ed9773--c1a6a08b6d09448d8f6ae0c59676b324 18652ffdc33745679ce5abe07b9344db ddd1200c63e24b71a16b5c515c4b8d0a c1a6a08b6d09448d8f6ae0c59676b324--ddd1200c63e24b71a16b5c515c4b8d0a 863c057beee948039686314d6d86698c 18652ffdc33745679ce5abe07b9344db--863c057beee948039686314d6d86698c eb254374ad944bcfab757fdc6cd3988f b12401848f114f979ca6baa0ff506b12 bd32ac0661104866a3ea245c93c59b50--b12401848f114f979ca6baa0ff506b12 d4150eb2de6641478a9b35aa5a391305 2 b12401848f114f979ca6baa0ff506b12--b8c7075f79174fc3baf9315601ed9773 80a5e0d5e40e4882a11f5671ab01d260 9fc11298d5504eee88897dbb2fd498b8--80a5e0d5e40e4882a11f5671ab01d260 0d83751bad0a4311b2126a470912891e 80a5e0d5e40e4882a11f5671ab01d260--0d83751bad0a4311b2126a470912891e 0d83751bad0a4311b2126a470912891e--eb254374ad944bcfab757fdc6cd3988f 9a5610ec76594617b70ba95a9a537175 3e591ebd40b14ffdba7a81fe082e1b16 d4150eb2de6641478a9b35aa5a391305--3e591ebd40b14ffdba7a81fe082e1b16 291151e2b73f44d6a8d0827ae19b5d70 3 42fa41f59daf4a3089d2eddee98f990b 3e591ebd40b14ffdba7a81fe082e1b16--42fa41f59daf4a3089d2eddee98f990b 4be45a0b610c4610a5a5b865f91ac210 42fa41f59daf4a3089d2eddee98f990b--4be45a0b610c4610a5a5b865f91ac210 706de203aca04b9db409247c6d14e85c 4be45a0b610c4610a5a5b865f91ac210--706de203aca04b9db409247c6d14e85c 706de203aca04b9db409247c6d14e85c--9a5610ec76594617b70ba95a9a537175 587c0b7eace24fd096003a1a2277c522 0dceaebd0afb46b18147e95249b86814 291151e2b73f44d6a8d0827ae19b5d70--0dceaebd0afb46b18147e95249b86814 775dff0a58c94b998612e094e9cd6d21 0dceaebd0afb46b18147e95249b86814--775dff0a58c94b998612e094e9cd6d21 ac2a771db5d94fe0b8ce9fe60c88bbca 775dff0a58c94b998612e094e9cd6d21--ac2a771db5d94fe0b8ce9fe60c88bbca ac2a771db5d94fe0b8ce9fe60c88bbca--18652ffdc33745679ce5abe07b9344db ddd1200c63e24b71a16b5c515c4b8d0a--587c0b7eace24fd096003a1a2277c522 <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 eea1771e398e408b8b9c2351299cfee9 0 52283658a5d14e1887c571ec752863ed eea1771e398e408b8b9c2351299cfee9--52283658a5d14e1887c571ec752863ed b392162242054b7dbf32faa8e8e82808 1 f32c54d4b6e844ad9bcdf2aabaa17776 52283658a5d14e1887c571ec752863ed--f32c54d4b6e844ad9bcdf2aabaa17776 d36c7923d4fc4acb95715988d5694fb7 f32c54d4b6e844ad9bcdf2aabaa17776--d36c7923d4fc4acb95715988d5694fb7 dad103426bcc4586b33286198180cd4b d36c7923d4fc4acb95715988d5694fb7--dad103426bcc4586b33286198180cd4b f32a205279ce4b1c97ecb7aaea12eef0 1836f970264e4eb9ab6b9dd3f87c866b PHASE(0.5) b392162242054b7dbf32faa8e8e82808--1836f970264e4eb9ab6b9dd3f87c866b bf22556641b5496cbb8bbfad7788604b 2 1836f970264e4eb9ab6b9dd3f87c866b--52283658a5d14e1887c571ec752863ed 21ce957bd4974f81a6b59fe5c7e7c8f8 1836f970264e4eb9ab6b9dd3f87c866b--21ce957bd4974f81a6b59fe5c7e7c8f8 0d97ca2b54c342928d06c5e84c7c0cef 21ce957bd4974f81a6b59fe5c7e7c8f8--0d97ca2b54c342928d06c5e84c7c0cef 0d97ca2b54c342928d06c5e84c7c0cef--f32a205279ce4b1c97ecb7aaea12eef0 12dbba37f5a24e95be4cac8bc0663a48 7041079bc9214e008d00714f311fa5c8 bf22556641b5496cbb8bbfad7788604b--7041079bc9214e008d00714f311fa5c8 bc713b8cd67f48c7aea46fbd4792b58a 3 944c0bfbecd84812bda53d6830224387 PHASE(0.5) 7041079bc9214e008d00714f311fa5c8--944c0bfbecd84812bda53d6830224387 944c0bfbecd84812bda53d6830224387--f32c54d4b6e844ad9bcdf2aabaa17776 af342944d1804ddc91d2e166285c56cd 944c0bfbecd84812bda53d6830224387--af342944d1804ddc91d2e166285c56cd af342944d1804ddc91d2e166285c56cd--12dbba37f5a24e95be4cac8bc0663a48 bab3e9ef21a44dbeae212b5135e8b02d afbc2d57014c48708df654f3deeccf47 bc713b8cd67f48c7aea46fbd4792b58a--afbc2d57014c48708df654f3deeccf47 4bbc55d807264f3f9581ad521455f66e afbc2d57014c48708df654f3deeccf47--4bbc55d807264f3f9581ad521455f66e e0c5c464201240478849837889523770 PHASE(0.5) 4bbc55d807264f3f9581ad521455f66e--e0c5c464201240478849837889523770 e0c5c464201240478849837889523770--d36c7923d4fc4acb95715988d5694fb7 e0c5c464201240478849837889523770--bab3e9ef21a44dbeae212b5135e8b02d"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from qadence import AnalogRot, PI\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = PI, # [rad/\u03bcs]\n    delta = PI, # [rad/\u03bcs]\n    phase = PI, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run, PI\nfrom qadence.analog.constants import C6_DICT\nfrom math import cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = PI\ndelta = PI\nphase = PI\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run, PI\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = PI\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>AnalogInteraction</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, AnalogInteraction, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = AnalogInteraction(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction, PI\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * PI * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * PI * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice, PI\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = PI)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>AnalogInteraction</code> operation initializes an <code>InteractionBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = QubitSupportType.GLOBAL</code>. However, composing blocks using <code>kron</code> with local qubit supports and different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, AnalogInteraction\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    AnalogInteraction(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    AnalogInteraction(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    AnalogInteraction(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2024-02-06T10:21:32.386125 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook, we solve a quadratic unconstrained binary optimization (QUBO) problem with Qadence. QUBOs are very popular combinatorial optimization problems with a wide range of applications. Here, we solve the problem using the QAOA <sup>1</sup> variational algorithm by embedding the QUBO problem weights onto a register as standard for neutral atom quantum devices.</p> <p>Additional background information on QUBOs can be found here, directly solved using the pulse-level interface Pulser.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: optimal register coordinates for embedding the QUBO problem <p>A basic ingredient for solving a QUBO problem with a neutral atom device is to embed the problem onto the atomic register. In short, embedding algorithms cast the problem onto a graph mapped onto the register by optimally finding atomic coordinates. A discussion on the embedding algorithms is beyond the scope of this tutorial and a simplified version taken from here is added below.</p> <p><pre><code>import numpy as np\nimport numpy.typing as npt\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom qadence import RydbergDevice\n\ndef qubo_register_coords(Q: np.ndarray, device: RydbergDevice) -&gt; list:\n    \"\"\"Compute coordinates for register.\"\"\"\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        interaction_coeff = device.rydberg_level\n        new_Q = squareform(interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <p>With the embedding routine under our belt, let's start by adding the required imports and ensure the reproducibility of this tutorial.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRX, AnalogRZ, chain\nfrom qadence.ml_tools import train_gradient_free, TrainConfig, num_parameters\nimport nevergrad as ng\nimport matplotlib.pyplot as plt\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted edges and a cost function to be optimized. The weighted edges are represented by a real-valued symmetric matrix <code>Q</code> which is used throughout the tutorial.</p> <pre><code># QUBO problem weights (real-value symmetric matrix)\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n\ndef loss(model: QuantumModel, *args) -&gt; tuple[float, dict]:\n    to_arr_fn = lambda bitstring: np.array(list(bitstring), dtype=int)\n    cost_fn = lambda arr: arr.T @ Q @ arr\n    samples = model.sample({}, n_shots=1000)[0]  # extract samples\n    cost_fn = sum(samples[key] * cost_fn(to_arr_fn(key)) for key in samples)\n    return cost_fn / sum(samples.values()), {}  # We return an optional metrics dict\n</code></pre> <p>The QAOA algorithm needs a variational quantum circuit with optimizable parameters. For that purpose, we use a fully analog circuit composed of two global rotations per layer on different axes of the Bloch sphere. The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian <sup>1</sup>. In this setting, the embedding is realized by the appropriate register coordinates and the resulting qubit interaction.</p> Rydberg level <p>The Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in the original tutorial, and set the device specifications with the updated Rydberg level.</p> <pre><code># Device specification and atomic register\ndevice = RydbergDevice(rydberg_level=70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q, device), device_specs=device\n)\n\n# Analog variational quantum circuit\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\ncircuit = QuantumCircuit(reg, block)\n</code></pre> <pre><code>\n</code></pre> <p>By feeding the circuit to a <code>QuantumModel</code> we can check the initial counts where no clear solution can be found:</p> <pre><code>model = QuantumModel(circuit)\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'01000': 197, '00001': 193, '00010': 189, '00100': 174, '10000': 169, '00000': 78})\n</code></pre> <p>Finally, we can proceed with the variational optimization. The cost function defined above is derived from bitstring computations and therefore non differentiable. We use Qadence ML facilities to run gradient-free optimizations using the <code>nevergrad</code> library.</p> <pre><code>config = TrainConfig(max_iter=100)\noptimizer = ng.optimizers.NGOpt(\n    budget=config.max_iter, parametrization=num_parameters(model)\n)\ntrain_gradient_free(model, None, optimizer, config, loss)\n\noptimal_counts = model.sample({}, n_shots=1000)[0]\n</code></pre>   optimal_count = Counter({'00100': 191, '10000': 190, '00001': 183, '01000': 181, '00010': 163, '00000': 92})    <p>Finally, let's plot the solution. The expected bitstrings are marked in red.</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings = [\"01011\", \"00111\"]\n\ndef plot_distribution(C, ax, title):\n    C = dict(sorted(C.items(), key=lambda item: item[1], reverse=True))\n    indexes = solution_bitstrings # QUBO solutions\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in C}\n    ax.set_xlabel(\"bitstrings\")\n    ax.set_ylabel(\"counts\")\n    ax.set_xticks([i for i in range(len(C.keys()))], C.keys(), rotation=90)\n    ax.bar(list(C.keys())[:20], list(C.values())[:20])\n    ax.set_title(title)\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 4))\nplot_distribution(initial_counts, axs[0], \"Initial counts\")\nplot_distribution(optimal_counts, axs[1], \"Optimal counts\")\n</code></pre> 2024-02-06T10:21:34.239671 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/#references","title":"References","text":"<ol> <li> <p>Edward Farhi, Jeffrey Goldstone, Sam Gutmann, A Quantum Approximate Optimization Algorithm, arXiv:1411.4028 (2014) \u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo, PI\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = PI\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=PI,            # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_b1b0c63780884ce39c150db34a8cec3c cluster_b9de7238ff3046a8be84768bc7613706 cluster_10c11f4a7f0a48b6b743fea1c9ed518f cluster_7f7c95aa6b8444d597b53f6be1912207 cluster_8c4470169d6d4cac98e530c91c5ae8d7 cluster_c2659657e30043028ebfc69dd0a1250f cluster_dc15e917e1db49aeb017040a0493b530 fdc731fbbaa2455fabdd15ed49a9fa5e 0 c11df9201f5e4d92bbf246e815298dd7 HamEvo fdc731fbbaa2455fabdd15ed49a9fa5e--c11df9201f5e4d92bbf246e815298dd7 dd35438c0fab4003b1987e6840899bfd 1 edf60e58f1c44bccbf93dbaa2b94b146 HamEvo c11df9201f5e4d92bbf246e815298dd7--edf60e58f1c44bccbf93dbaa2b94b146 1bd299fee9e64ae5b8b8c6b0366c8b90 HamEvo edf60e58f1c44bccbf93dbaa2b94b146--1bd299fee9e64ae5b8b8c6b0366c8b90 9d672628646d4d9fb1d854a87cc6e262 X 1bd299fee9e64ae5b8b8c6b0366c8b90--9d672628646d4d9fb1d854a87cc6e262 8b599f37181b47e28e0d446ed0e65801 HamEvo 9d672628646d4d9fb1d854a87cc6e262--8b599f37181b47e28e0d446ed0e65801 7999c8ad58474eb0871a84ac75372b8c HamEvo 8b599f37181b47e28e0d446ed0e65801--7999c8ad58474eb0871a84ac75372b8c 0174956f34af49818362859fc3f80b6b X 7999c8ad58474eb0871a84ac75372b8c--0174956f34af49818362859fc3f80b6b 68e0a4ebb0c348b69c52f77595588ebe 0174956f34af49818362859fc3f80b6b--68e0a4ebb0c348b69c52f77595588ebe 826f6e1d54f44c8bae374a3c04e05bed HamEvo 68e0a4ebb0c348b69c52f77595588ebe--826f6e1d54f44c8bae374a3c04e05bed 326bfaefeeca4838bd4e918f3ce5038e HamEvo 826f6e1d54f44c8bae374a3c04e05bed--326bfaefeeca4838bd4e918f3ce5038e c704c83898dd4a729ee4e7b7f2ca1c1e 326bfaefeeca4838bd4e918f3ce5038e--c704c83898dd4a729ee4e7b7f2ca1c1e b25d684220564d4b84e1dadea5a5dc95 c704c83898dd4a729ee4e7b7f2ca1c1e--b25d684220564d4b84e1dadea5a5dc95 66e64a82b4204464954f004635bbaec3 a8e8191cde90474ea73b54df0472c40f t = -3.142 dd35438c0fab4003b1987e6840899bfd--a8e8191cde90474ea73b54df0472c40f d0b3ec80e3ce461eb64ee0be67890f7e 2 ec4650a2419148c9b75084e250860cae t = 3.142 a8e8191cde90474ea73b54df0472c40f--ec4650a2419148c9b75084e250860cae 169e1aedbf4d460f8136582135b7bbaf t = -3.142 ec4650a2419148c9b75084e250860cae--169e1aedbf4d460f8136582135b7bbaf b89085d90ffd4bcd948ed8736613babc 169e1aedbf4d460f8136582135b7bbaf--b89085d90ffd4bcd948ed8736613babc 4b7ce1ad23b74555ba512afccb91f3cf t = 1.571 b89085d90ffd4bcd948ed8736613babc--4b7ce1ad23b74555ba512afccb91f3cf eb3a61a5091040018eda8a5696525d70 t = 1.571 4b7ce1ad23b74555ba512afccb91f3cf--eb3a61a5091040018eda8a5696525d70 a8e146d6e3664a09bfd8cd061a8ec0d7 eb3a61a5091040018eda8a5696525d70--a8e146d6e3664a09bfd8cd061a8ec0d7 5c83d2168482480aab37ea4bccd8b1c0 X a8e146d6e3664a09bfd8cd061a8ec0d7--5c83d2168482480aab37ea4bccd8b1c0 8326811fb1264f4a9757656a73f1f3fb t = 1.571 5c83d2168482480aab37ea4bccd8b1c0--8326811fb1264f4a9757656a73f1f3fb 87063616b86949718f9c0dd4829e9599 t = 1.571 8326811fb1264f4a9757656a73f1f3fb--87063616b86949718f9c0dd4829e9599 b2ba016f6dc1473db6ae2b5064b1ee40 X 87063616b86949718f9c0dd4829e9599--b2ba016f6dc1473db6ae2b5064b1ee40 b2ba016f6dc1473db6ae2b5064b1ee40--66e64a82b4204464954f004635bbaec3 2627fe5fb5e144a09b943f526ae211bd 9fd41f4bfc274af8ab1c7902503ce804 d0b3ec80e3ce461eb64ee0be67890f7e--9fd41f4bfc274af8ab1c7902503ce804 fd910b7cdda14b769edc4af5f97092c8 9fd41f4bfc274af8ab1c7902503ce804--fd910b7cdda14b769edc4af5f97092c8 6ff21a8273514d1b9095166fb1c870e5 fd910b7cdda14b769edc4af5f97092c8--6ff21a8273514d1b9095166fb1c870e5 a704cb43d0484cfdb3f4b6d1a03fff54 X 6ff21a8273514d1b9095166fb1c870e5--a704cb43d0484cfdb3f4b6d1a03fff54 0941c401f60a4e60bbefb4e0d6f62422 a704cb43d0484cfdb3f4b6d1a03fff54--0941c401f60a4e60bbefb4e0d6f62422 3b3b8853ab3243a5920c321fa2feb482 0941c401f60a4e60bbefb4e0d6f62422--3b3b8853ab3243a5920c321fa2feb482 cf18f2cbdaf742a7a9242b61dfd67d8c X 3b3b8853ab3243a5920c321fa2feb482--cf18f2cbdaf742a7a9242b61dfd67d8c 79058d4115d44f2aa3157933b2a929f0 X cf18f2cbdaf742a7a9242b61dfd67d8c--79058d4115d44f2aa3157933b2a929f0 e4fd5b09a1aa432684e499764fe81827 79058d4115d44f2aa3157933b2a929f0--e4fd5b09a1aa432684e499764fe81827 8d11ab4667104abaab62e439d3b4e900 e4fd5b09a1aa432684e499764fe81827--8d11ab4667104abaab62e439d3b4e900 4c3935f8c79e414faeb3c6a4f6ac0bd9 X 8d11ab4667104abaab62e439d3b4e900--4c3935f8c79e414faeb3c6a4f6ac0bd9 4c3935f8c79e414faeb3c6a4f6ac0bd9--2627fe5fb5e144a09b943f526ae211bd <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_eec7f5899c1a4f6f9519a77d8b095b50 cluster_5f10146429c24346bd35401f4fb1b99e 92bb0dbe362d4aff96a7d0c4305672aa 0 dc2c1f6672bf4cb99d2ec7905e390f8d X 92bb0dbe362d4aff96a7d0c4305672aa--dc2c1f6672bf4cb99d2ec7905e390f8d 0bde85751d664b34868bba62d02e33e5 1 b9580d5ecc054a28a336efd3bbf2619c HamEvo dc2c1f6672bf4cb99d2ec7905e390f8d--b9580d5ecc054a28a336efd3bbf2619c 4224e65b81d848c3a77d7e77b5c914fd X b9580d5ecc054a28a336efd3bbf2619c--4224e65b81d848c3a77d7e77b5c914fd 75cf661d89f24f52a8b0662fde92a841 4224e65b81d848c3a77d7e77b5c914fd--75cf661d89f24f52a8b0662fde92a841 22cb15f4796c49458100f1b730e3f463 HamEvo 75cf661d89f24f52a8b0662fde92a841--22cb15f4796c49458100f1b730e3f463 a3437d61e6c54730a588b23ed4f3fcf9 22cb15f4796c49458100f1b730e3f463--a3437d61e6c54730a588b23ed4f3fcf9 a6163ee7ecc64aeca735e5699490e03b a3437d61e6c54730a588b23ed4f3fcf9--a6163ee7ecc64aeca735e5699490e03b a40ca1f239fc4244b6e795e67c210bd7 fb6ab31a5a0349b7ab586ce10a2b4a98 0bde85751d664b34868bba62d02e33e5--fb6ab31a5a0349b7ab586ce10a2b4a98 f261cb1cff5644abb4579d085110f641 2 c52dea8c2a6146f19acf61a672de4103 t = -0.500 fb6ab31a5a0349b7ab586ce10a2b4a98--c52dea8c2a6146f19acf61a672de4103 e2bdd5c4786546278a6ffc8b9d801e98 c52dea8c2a6146f19acf61a672de4103--e2bdd5c4786546278a6ffc8b9d801e98 99a5c17f79c846dbaa98ab7760c22676 X e2bdd5c4786546278a6ffc8b9d801e98--99a5c17f79c846dbaa98ab7760c22676 1d8996c637554691b76f4e71a5ec2a98 t = -0.500 99a5c17f79c846dbaa98ab7760c22676--1d8996c637554691b76f4e71a5ec2a98 e130d28407f0430782a91699ca4c7b40 X 1d8996c637554691b76f4e71a5ec2a98--e130d28407f0430782a91699ca4c7b40 e130d28407f0430782a91699ca4c7b40--a40ca1f239fc4244b6e795e67c210bd7 621de07c6c30431c847196f3ec571801 b45217683a024b74804be78aa8777425 X f261cb1cff5644abb4579d085110f641--b45217683a024b74804be78aa8777425 8ebf2040339445a284e9941e720d2e1b b45217683a024b74804be78aa8777425--8ebf2040339445a284e9941e720d2e1b d4b9ef39ca754af8be71c17c73af76af X 8ebf2040339445a284e9941e720d2e1b--d4b9ef39ca754af8be71c17c73af76af c0a7f1ce4c8e4e70b483d636e9cb6b6b X d4b9ef39ca754af8be71c17c73af76af--c0a7f1ce4c8e4e70b483d636e9cb6b6b 858823c922224e8d898aec924422e504 c0a7f1ce4c8e4e70b483d636e9cb6b6b--858823c922224e8d898aec924422e504 04b4de1ea5074c6c923e6f2b113b81d5 X 858823c922224e8d898aec924422e504--04b4de1ea5074c6c923e6f2b113b81d5 04b4de1ea5074c6c923e6f2b113b81d5--621de07c6c30431c847196f3ec571801 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_007e3773471c4d79abc37ddd02091193 cluster_d78f1b6f96694ab38e46068cfc6d60c1 924337f9bf8a45fa8cbacd2240506cbe 0 6dcbe5ce880c42b08889594f08480318 X 924337f9bf8a45fa8cbacd2240506cbe--6dcbe5ce880c42b08889594f08480318 69fd345c8ac342368d34e35e713d26c1 1 73eaee3906cb43febee2ad6d0526ae53 HamEvo 6dcbe5ce880c42b08889594f08480318--73eaee3906cb43febee2ad6d0526ae53 c4edf6283203425e8d639a80030a73f2 X 73eaee3906cb43febee2ad6d0526ae53--c4edf6283203425e8d639a80030a73f2 88c9306312fc436baf1d5978dde9a29f c4edf6283203425e8d639a80030a73f2--88c9306312fc436baf1d5978dde9a29f aae31adce6954e408c8d7d0b1fe374d0 HamEvo 88c9306312fc436baf1d5978dde9a29f--aae31adce6954e408c8d7d0b1fe374d0 f04a3c8eec834b5fbbdb9f9802700994 aae31adce6954e408c8d7d0b1fe374d0--f04a3c8eec834b5fbbdb9f9802700994 81e97a9cbba94cc690a85980ffbbf730 f04a3c8eec834b5fbbdb9f9802700994--81e97a9cbba94cc690a85980ffbbf730 d6f60d281354405ca44ea8b80292453c 51704b0710b4471bb1a7ab233e711a8a 69fd345c8ac342368d34e35e713d26c1--51704b0710b4471bb1a7ab233e711a8a a3cdfab532ed469b8a567b86f2422945 2 03d2cd272777414a8f48634af9508cc4 t = -500.000000000000 51704b0710b4471bb1a7ab233e711a8a--03d2cd272777414a8f48634af9508cc4 aec886b2e5e847a886839408f947870a 03d2cd272777414a8f48634af9508cc4--aec886b2e5e847a886839408f947870a 6da7fb5bc0ae468b8d6eeead1a46ebf8 X aec886b2e5e847a886839408f947870a--6da7fb5bc0ae468b8d6eeead1a46ebf8 148d2687af5541219688be92cabf915d t = -500.000000000000 6da7fb5bc0ae468b8d6eeead1a46ebf8--148d2687af5541219688be92cabf915d d47a90daa1524113b55a94f954727792 X 148d2687af5541219688be92cabf915d--d47a90daa1524113b55a94f954727792 d47a90daa1524113b55a94f954727792--d6f60d281354405ca44ea8b80292453c 916eefa767a44b169455379dee6dacdf 283011f0f51949baa90d8b7a3b9b543f X a3cdfab532ed469b8a567b86f2422945--283011f0f51949baa90d8b7a3b9b543f bd74e8d35e734a0a9197e9bc3b9feb35 283011f0f51949baa90d8b7a3b9b543f--bd74e8d35e734a0a9197e9bc3b9feb35 a85f796199c7441490ead9a1f1318725 X bd74e8d35e734a0a9197e9bc3b9feb35--a85f796199c7441490ead9a1f1318725 ea7a32b59f484e4a9109647fc29920b7 X a85f796199c7441490ead9a1f1318725--ea7a32b59f484e4a9109647fc29920b7 2cde2afacfbe466eaa7dd0c91118de83 ea7a32b59f484e4a9109647fc29920b7--2cde2afacfbe466eaa7dd0c91118de83 ba305e9bada848edaf8f34cd6b314463 X 2cde2afacfbe466eaa7dd0c91118de83--ba305e9bada848edaf8f34cd6b314463 ba305e9bada848edaf8f34cd6b314463--916eefa767a44b169455379dee6dacdf <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>AnalogInteraction</code> An idle block to to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.19153186677421175, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel, PI\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 30, '11': 20})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2024-02-06T10:21:34.760452 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2024-02-06T10:21:34.882145 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 21, '10': 2})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>AnalogInteraction</code> and <code>AnalogRY</code> blocks together with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, AnalogInteraction\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-PI / 2),\n        AnalogInteraction(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([PI / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2024-02-06T10:21:35.353758 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(PI/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2024-02-06T10:21:35.468764 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n    PI\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.0100])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.0106])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(PI)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.6974]) The trained function value:  tensor([[0.6974]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>InteractionBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, AnalogInteraction\n\nb = chain(AnalogInteraction(200), AnalogInteraction(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), AnalogInteraction(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `InteractionBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, AnalogInteraction\n\n    b = chain(AnalogInteraction(200), AnalogInteraction(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), AnalogInteraction(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.InteractionBlock","title":"<code>InteractionBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Free-evolution for the Hamiltonian interaction term of a register of qubits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct, use the <code>AnalogInteraction</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG, device=torch.device('cpu'))</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1205+0.2779j, -0.4028-0.5196j, -0.6412+0.0323j, -0.2348-0.0933j],\n         [-0.1532-0.2579j,  0.3364+0.4789j, -0.6311-0.0889j, -0.3710+0.1539j],\n         [-0.2295-0.6436j, -0.0058-0.3170j,  0.1553+0.2692j, -0.3819-0.4360j],\n         [-0.0921-0.5856j, -0.2621-0.2365j, -0.1598-0.2440j,  0.4385+0.4966j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n    device: torch.device = torch.device(\"cpu\"),\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block,\n            embed(ps, values),\n            qubit_support,\n            use_full_support,\n            endianness=endianness,\n            device=device,\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * PI),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | Callable | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | Callable | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        if callable(interaction):\n            int_fn = interaction\n            try:\n                if not block_is_qubit_hamiltonian(interaction(0, 1)):\n                    raise ValueError(\"Custom interactions must be composed of Pauli operators.\")\n            except TypeError:\n                raise TypeError(\n                    \"Please use a custom interaction function signed with two integer parameters.\"\n                )\n        else:\n            int_fn = INTERACTION_DICT.get(interaction, None)  # type: ignore [arg-type]\n            if int_fn is None:\n                raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * PI / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fecef84f520&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fecefef3250&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    if isinstance(model, DataParallel):\n        model = model.module.to(device)\n    else:\n        model = model.to(device)\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.3026, 0.2765]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n[tensor([0.6595, 0.0538, 0.8660, 0.8650, 0.0394]), tensor([0.2900, 0.3294, 0.6735, 0.3359, 0.2816]), tensor([0.4227, 0.3033, 0.5571, 0.8693, 0.4491])]\n[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run, PI\nimport torch\nhevo = HamEvo(generator=RX(0, PI), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1384-3.6270e-17j, -0.5441+1.7335e-17j],\n        [ 1.2545-5.3697e-17j, -0.7574+3.2421e-17j]])\ntensor([[1.5091-0.7780j, 0.5771-0.9542j],\n        [1.4106-0.5384j, 0.5040-0.6605j]])\n</code></pre> Source code in <code>qadence/operations/ham_evo.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations/ham_evo.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * PI / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * PI / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-PI / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = PI\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogInteraction","title":"<code>AnalogInteraction(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Evolution of the interaction term for a register of qubits.</p> <p>Constructs a <code>InteractionBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to evolve the interaction for in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>InteractionBlock</code> is applied to. Can be either <code>\"global\"</code> to evolve the interaction block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>InteractionBlock</code> <p>a <code>InteractionBlock</code></p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogInteraction(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; InteractionBlock:\n    \"\"\"Evolution of the interaction term for a register of qubits.\n\n    Constructs a [`InteractionBlock`][qadence.blocks.analog.InteractionBlock].\n\n    Arguments:\n        duration: Time to evolve the interaction for in nanoseconds.\n        qubit_support: Qubits the `InteractionBlock` is applied to. Can be either\n            `\"global\"` to evolve the interaction block to all qubits or a tuple of integers.\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        a `InteractionBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return InteractionBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['8d71bd0f-387c-4221-8050-69d8573c4953', 'a79b83a1-8544-40fe-af70-33ff2bbd6791'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.9859993654159114\ntheta: trainable=True value=2.0\nexpr=x*y : {x, y}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.6903893734503416\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('79c0e426-528a-412b-b9ff-f05bc78baafe', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.6398639069137206'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('49780c5a-e1ad-4590-a5e2-8e1ddfd45a03', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.4276945815961849'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b0825feb-204e-4297-a341-f967e837e6f6', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.8742892845567309'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b6200e97-60bc-459a-a3ca-7097d7f64bb5', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.41919975377010965'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5bb53eec-d8e8-4887-8241-c38da3694247', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6109177287180888'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('58df3d9c-b2d1-438f-aaa9-aaf08dbf3895', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.37421788716051174'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3277d35d-eca6-415b-86a4-d666813c6ed1', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9806087614373826'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('dc01c257-fe3b-4521-a468-2b850ed15b9d', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1191298453974663'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('efeb3d60-49d2-448c-8573-8002f170b121', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.2908857259376022'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('bbff62ba-957e-40c8-9574-9cc579d3f177', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.43496561975352277'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e9ac95f0-f01f-441b-9dac-7cb7beecba24', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.13952221070351867'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a42c3751-bd66-43bb-b90b-39729bdcf154', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.230873635340905'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>01111010\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3881-0.1329j,  0.2745-0.3881j, -0.2080+0.2140j,  0.6633-0.2767j]])\ntensor([[0.5596+0.0000j, 0.0000-0.5618j, 0.0000+0.4300j, 0.4316+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGINTERACTION","title":"<code>ANALOGINTERACTION = 'AnalogInteraction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog interaction operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANGLE","title":"<code>ENTANGLE = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 78, '1000': 8, '0010': 5, '0100': 4, '0001': 1, '0101': 1, '1010': 1, '1101': 1, '1110': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[-0.0018],\n        [-0.0004],\n        [ 0.0510],\n        [ 0.0049],\n        [ 0.0771],\n        [ 0.0133],\n        [-0.0328],\n        [-0.0192],\n        [ 0.0395],\n        [-0.0323]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4053],\n        [0.9018],\n        [0.9084],\n        [0.2606],\n        [0.9428]]), tensor([[0.3943],\n        [0.7844],\n        [0.7885],\n        [0.2577],\n        [0.8092]])], 'y2': [tensor([[0.4695],\n        [0.1881],\n        [0.6359],\n        [0.7454],\n        [0.2043]]), tensor([[0.4524],\n        [0.1870],\n        [0.5939],\n        [0.6783],\n        [0.2029]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2024-02-06T10:21:57.704844 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2024-02-06T10:21:58.287528 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_365e2c5573a740af9041d24982b987ac mixing cluster_4d0238556c5641d081ea41e6dbf06bbb cost cluster_2978fbcc0bdc49e1a17b49537bdb4f5b mixing cluster_6936bf3d34434b0099d082a90041dced cost 7cfc1207ac504833b308a49faed0acbb 0 84a617bd09634b13a0e50f94921ffdc5 7cfc1207ac504833b308a49faed0acbb--84a617bd09634b13a0e50f94921ffdc5 07a322b7a50e4c65821ec8d57246da6a 1 326b604f97ea49dda42631d8b64f0532 84a617bd09634b13a0e50f94921ffdc5--326b604f97ea49dda42631d8b64f0532 0f6af5ae7e274b2e8a46387b2876346e 326b604f97ea49dda42631d8b64f0532--0f6af5ae7e274b2e8a46387b2876346e ca9f95e45a9745328a13f51812c36fc0 0f6af5ae7e274b2e8a46387b2876346e--ca9f95e45a9745328a13f51812c36fc0 671832f07c7d41c498ab6fc9254e2461 ca9f95e45a9745328a13f51812c36fc0--671832f07c7d41c498ab6fc9254e2461 c1b72f89502342f982f52b1d04e944f5 671832f07c7d41c498ab6fc9254e2461--c1b72f89502342f982f52b1d04e944f5 12d56b793f6a4546bfc3f69bb49d5945 c1b72f89502342f982f52b1d04e944f5--12d56b793f6a4546bfc3f69bb49d5945 5a142f3c04c740d3a5be8839d3c45e8f 12d56b793f6a4546bfc3f69bb49d5945--5a142f3c04c740d3a5be8839d3c45e8f 0d0c5a024c244382bb2636aa86e26fbc 5a142f3c04c740d3a5be8839d3c45e8f--0d0c5a024c244382bb2636aa86e26fbc 5360abd882824367a07d9b6d755a2618 0d0c5a024c244382bb2636aa86e26fbc--5360abd882824367a07d9b6d755a2618 5a317a34cfe04a4a82c713071047a0bc 5360abd882824367a07d9b6d755a2618--5a317a34cfe04a4a82c713071047a0bc 3377cf1f99444ca7a21595c138434de3 5a317a34cfe04a4a82c713071047a0bc--3377cf1f99444ca7a21595c138434de3 11aef8bbfc2840528b54a037532a68b0 3377cf1f99444ca7a21595c138434de3--11aef8bbfc2840528b54a037532a68b0 c4a0328ef6f04e7e9bdbdd9c9e7fc2ec 11aef8bbfc2840528b54a037532a68b0--c4a0328ef6f04e7e9bdbdd9c9e7fc2ec f55a531366cd48ccaab81d510b7cce1e c4a0328ef6f04e7e9bdbdd9c9e7fc2ec--f55a531366cd48ccaab81d510b7cce1e cdf8b70c5d5f4b8181a4d81c0c4f2257 f55a531366cd48ccaab81d510b7cce1e--cdf8b70c5d5f4b8181a4d81c0c4f2257 005e8ce2f75b47769572d77a5371aa33 cdf8b70c5d5f4b8181a4d81c0c4f2257--005e8ce2f75b47769572d77a5371aa33 6803f25f3d064c789ebfa426ad7a3ad7 005e8ce2f75b47769572d77a5371aa33--6803f25f3d064c789ebfa426ad7a3ad7 0d2dfc7fdbcb418b87fb6f2cb4d394ad 6803f25f3d064c789ebfa426ad7a3ad7--0d2dfc7fdbcb418b87fb6f2cb4d394ad 5ebbe88667e54cb69dc1ca05dd0deab1 0d2dfc7fdbcb418b87fb6f2cb4d394ad--5ebbe88667e54cb69dc1ca05dd0deab1 41e4a0aa1b8841a88976ac7f1cfb23c2 5ebbe88667e54cb69dc1ca05dd0deab1--41e4a0aa1b8841a88976ac7f1cfb23c2 91dd6fdf03f14019b451665d943016b9 41e4a0aa1b8841a88976ac7f1cfb23c2--91dd6fdf03f14019b451665d943016b9 87c5311cb40c4309a767107692009a01 91dd6fdf03f14019b451665d943016b9--87c5311cb40c4309a767107692009a01 b259ec9da7ea48de87e064c17949a743 87c5311cb40c4309a767107692009a01--b259ec9da7ea48de87e064c17949a743 d502056f1a76499394f79622af8df3bf b259ec9da7ea48de87e064c17949a743--d502056f1a76499394f79622af8df3bf 313871a24a814929b4537a9a05317039 d502056f1a76499394f79622af8df3bf--313871a24a814929b4537a9a05317039 aa9df760c3f44cc1b42dcbc4f0cdf445 313871a24a814929b4537a9a05317039--aa9df760c3f44cc1b42dcbc4f0cdf445 b9ac0fd65bb54ea08bd1e0578538bcb6 aa9df760c3f44cc1b42dcbc4f0cdf445--b9ac0fd65bb54ea08bd1e0578538bcb6 54e466acf5444bc6922f27ea4af161db b9ac0fd65bb54ea08bd1e0578538bcb6--54e466acf5444bc6922f27ea4af161db 364a66dc3e6c460293f190f75098de92 54e466acf5444bc6922f27ea4af161db--364a66dc3e6c460293f190f75098de92 9fd2f32a859f409eb21717b80e6989f3 364a66dc3e6c460293f190f75098de92--9fd2f32a859f409eb21717b80e6989f3 949a41d0513f4035b2845965db977e52 9fd2f32a859f409eb21717b80e6989f3--949a41d0513f4035b2845965db977e52 ccf995ad942c468f8d2912cf29e930ab 949a41d0513f4035b2845965db977e52--ccf995ad942c468f8d2912cf29e930ab 11659330ab284a6fa3e5a2c2fa9fd70d ccf995ad942c468f8d2912cf29e930ab--11659330ab284a6fa3e5a2c2fa9fd70d 994a11e341f74c5583b88128a6da7ce0 11659330ab284a6fa3e5a2c2fa9fd70d--994a11e341f74c5583b88128a6da7ce0 21cca7006d07456092ec76674183f25b 994a11e341f74c5583b88128a6da7ce0--21cca7006d07456092ec76674183f25b c902ddaa71b94c4ca35251b50d938d17 21cca7006d07456092ec76674183f25b--c902ddaa71b94c4ca35251b50d938d17 7e826257049f49d1899871e5e4e8fb28 c902ddaa71b94c4ca35251b50d938d17--7e826257049f49d1899871e5e4e8fb28 9731660020854cfc8c248633f5216ea0 7e826257049f49d1899871e5e4e8fb28--9731660020854cfc8c248633f5216ea0 c3a206852d92409c9241e330e6d07a0b 9731660020854cfc8c248633f5216ea0--c3a206852d92409c9241e330e6d07a0b 2ee31763d7f44137b6c8f75d272d0cc2 c3a206852d92409c9241e330e6d07a0b--2ee31763d7f44137b6c8f75d272d0cc2 b12decad8dd24fafaa6194e152cd529b 2ee31763d7f44137b6c8f75d272d0cc2--b12decad8dd24fafaa6194e152cd529b 6b5deb1169a14be78c46664e1494e2b8 b12decad8dd24fafaa6194e152cd529b--6b5deb1169a14be78c46664e1494e2b8 0409ff8ea0f74016be28bd50e74cf260 6b5deb1169a14be78c46664e1494e2b8--0409ff8ea0f74016be28bd50e74cf260 b01eb0f3983d490c9c48af2dec1b473e 0409ff8ea0f74016be28bd50e74cf260--b01eb0f3983d490c9c48af2dec1b473e cac3b479c71440018a9ccac9494fff54 b01eb0f3983d490c9c48af2dec1b473e--cac3b479c71440018a9ccac9494fff54 ec160399ec604d35b8b45f1d33035b5b cac3b479c71440018a9ccac9494fff54--ec160399ec604d35b8b45f1d33035b5b bca2369f19e0406bac69b08689706030 ec160399ec604d35b8b45f1d33035b5b--bca2369f19e0406bac69b08689706030 0946ba87862540b2b9a9ae18f2d24fee bca2369f19e0406bac69b08689706030--0946ba87862540b2b9a9ae18f2d24fee 51531466c069449ca8ffa3f0554b92cd 0946ba87862540b2b9a9ae18f2d24fee--51531466c069449ca8ffa3f0554b92cd c1278d385e554ae8bfc82dadfad114a3 51531466c069449ca8ffa3f0554b92cd--c1278d385e554ae8bfc82dadfad114a3 0180befccfe0434bae716e3c093fa3b9 c1278d385e554ae8bfc82dadfad114a3--0180befccfe0434bae716e3c093fa3b9 215d18d030734f4982d766b4ffe26519 0180befccfe0434bae716e3c093fa3b9--215d18d030734f4982d766b4ffe26519 75e39f60e039464892f4e00ab882b57f 215d18d030734f4982d766b4ffe26519--75e39f60e039464892f4e00ab882b57f 029b81ddb5b84176b404b2f85be5d88f 75e39f60e039464892f4e00ab882b57f--029b81ddb5b84176b404b2f85be5d88f 9de14c51f1b2400e9edcdccfa8920c9e 029b81ddb5b84176b404b2f85be5d88f--9de14c51f1b2400e9edcdccfa8920c9e f2a59e74aeb945eeb5a9e62def873aaf 9de14c51f1b2400e9edcdccfa8920c9e--f2a59e74aeb945eeb5a9e62def873aaf f460d61a9758458f93f93aef9e2170d7 f2a59e74aeb945eeb5a9e62def873aaf--f460d61a9758458f93f93aef9e2170d7 7f77fcfaa97d4b13b8aad42dc28e1a8f f460d61a9758458f93f93aef9e2170d7--7f77fcfaa97d4b13b8aad42dc28e1a8f ad64c41d902e4f23ae36e7ce9515db80 7f77fcfaa97d4b13b8aad42dc28e1a8f--ad64c41d902e4f23ae36e7ce9515db80 2bc7a91a92344fb4a00429300d731ebf ad64c41d902e4f23ae36e7ce9515db80--2bc7a91a92344fb4a00429300d731ebf a59210e822eb4e7792a2a0e0b36b8578 2bc7a91a92344fb4a00429300d731ebf--a59210e822eb4e7792a2a0e0b36b8578 635b55631b6f443aa4564907ee0646b8 a59210e822eb4e7792a2a0e0b36b8578--635b55631b6f443aa4564907ee0646b8 15096ddb5e604388bf116520959489c2 635b55631b6f443aa4564907ee0646b8--15096ddb5e604388bf116520959489c2 50493c6129d64c76b2909a37e87b341f 15096ddb5e604388bf116520959489c2--50493c6129d64c76b2909a37e87b341f 1acd90c4f9b9478caa3c275a12f6320f 50493c6129d64c76b2909a37e87b341f--1acd90c4f9b9478caa3c275a12f6320f 26d72d2788504ac6a5f8ac72338b27a8 1acd90c4f9b9478caa3c275a12f6320f--26d72d2788504ac6a5f8ac72338b27a8 bb0a9fbf946045e1b3a496d290215ce6 26d72d2788504ac6a5f8ac72338b27a8--bb0a9fbf946045e1b3a496d290215ce6 9c48ff94b74b4105b3ee9a21bfb91910 bb0a9fbf946045e1b3a496d290215ce6--9c48ff94b74b4105b3ee9a21bfb91910 ff42291396614b1ea3d626935690edc2 9c48ff94b74b4105b3ee9a21bfb91910--ff42291396614b1ea3d626935690edc2 bffc4aece69c4583a30c72ac9cfcba81 ff42291396614b1ea3d626935690edc2--bffc4aece69c4583a30c72ac9cfcba81 fe9a24fbb43943fa9fb33054befa8ac1 bffc4aece69c4583a30c72ac9cfcba81--fe9a24fbb43943fa9fb33054befa8ac1 e1545d68133347719cd95001e008fe93 fe9a24fbb43943fa9fb33054befa8ac1--e1545d68133347719cd95001e008fe93 617a6eabaed94886a82013365ea93b3d e1545d68133347719cd95001e008fe93--617a6eabaed94886a82013365ea93b3d 1d84390f07904f46b497bb9d4b608e07 617a6eabaed94886a82013365ea93b3d--1d84390f07904f46b497bb9d4b608e07 c8f76ed2108b44f095df28c912e946ac 1d84390f07904f46b497bb9d4b608e07--c8f76ed2108b44f095df28c912e946ac 7d7b1143dfec40a2bd8d73a533d8d35d c8f76ed2108b44f095df28c912e946ac--7d7b1143dfec40a2bd8d73a533d8d35d 11b93051edc64bddadafb8ef2d27c2ec 7d7b1143dfec40a2bd8d73a533d8d35d--11b93051edc64bddadafb8ef2d27c2ec 0add513f4c684eb6b2f3cf4404f0c6e2 11b93051edc64bddadafb8ef2d27c2ec--0add513f4c684eb6b2f3cf4404f0c6e2 1035e903421742dbb7d0656e3b156f00 0add513f4c684eb6b2f3cf4404f0c6e2--1035e903421742dbb7d0656e3b156f00 3787e7b7890342978bf39de2f1861502 1035e903421742dbb7d0656e3b156f00--3787e7b7890342978bf39de2f1861502 cce7bb3302c64873926f290966ed87e0 3787e7b7890342978bf39de2f1861502--cce7bb3302c64873926f290966ed87e0 92dcc93338d74562b7d15ebd9833d493 cce7bb3302c64873926f290966ed87e0--92dcc93338d74562b7d15ebd9833d493 d2228e0794984478bd7709143424af93 92dcc93338d74562b7d15ebd9833d493--d2228e0794984478bd7709143424af93 7439e02c81b84872b90d3ff2f3c78d3d d2228e0794984478bd7709143424af93--7439e02c81b84872b90d3ff2f3c78d3d 367635d69a854b479a2f90789ee72fb7 7439e02c81b84872b90d3ff2f3c78d3d--367635d69a854b479a2f90789ee72fb7 581fdc6f100940a6ac6f11a7bf831e90 367635d69a854b479a2f90789ee72fb7--581fdc6f100940a6ac6f11a7bf831e90 d536595d12a94ea9a5cadd2fdeac81bb 581fdc6f100940a6ac6f11a7bf831e90--d536595d12a94ea9a5cadd2fdeac81bb c34f5e9eeb314aa680ebc452aa6da566 d536595d12a94ea9a5cadd2fdeac81bb--c34f5e9eeb314aa680ebc452aa6da566 acaf04f5afd04687a4999af7397f3f27 c34f5e9eeb314aa680ebc452aa6da566--acaf04f5afd04687a4999af7397f3f27 5b0d6011f37a44b58242a88a075448e0 acaf04f5afd04687a4999af7397f3f27--5b0d6011f37a44b58242a88a075448e0 2b57798e720e453b905bb287dbd19ea6 5b0d6011f37a44b58242a88a075448e0--2b57798e720e453b905bb287dbd19ea6 16a1688b74474febb538a6311088c08c 2b57798e720e453b905bb287dbd19ea6--16a1688b74474febb538a6311088c08c 7b8a2c6fc5054f12ab195797501ddf48 16a1688b74474febb538a6311088c08c--7b8a2c6fc5054f12ab195797501ddf48 0da89005da2d4c57b63c38ee2b4b49f6 7b8a2c6fc5054f12ab195797501ddf48--0da89005da2d4c57b63c38ee2b4b49f6 c366a86b398c4490b929b32484ccfd7c 0da89005da2d4c57b63c38ee2b4b49f6--c366a86b398c4490b929b32484ccfd7c f842d0003c9a4f8da169f2a7f58f0604 c366a86b398c4490b929b32484ccfd7c--f842d0003c9a4f8da169f2a7f58f0604 c3f8aa617b86466f8aeebcf596441194 f842d0003c9a4f8da169f2a7f58f0604--c3f8aa617b86466f8aeebcf596441194 7812b811449247bfbab70b8edf242110 c3f8aa617b86466f8aeebcf596441194--7812b811449247bfbab70b8edf242110 0ec246f1149944498ab909005f6d37a0 7812b811449247bfbab70b8edf242110--0ec246f1149944498ab909005f6d37a0 0d10b24b0f474a1f9153fc14b7337d11 0ec246f1149944498ab909005f6d37a0--0d10b24b0f474a1f9153fc14b7337d11 d885899993eb486393ddaf152eaebd44 0d10b24b0f474a1f9153fc14b7337d11--d885899993eb486393ddaf152eaebd44 606077ab145b4f3d883d51c7c7793c07 d885899993eb486393ddaf152eaebd44--606077ab145b4f3d883d51c7c7793c07 09f3990ffc6a41a8876d276a552d719d 606077ab145b4f3d883d51c7c7793c07--09f3990ffc6a41a8876d276a552d719d c3c8704a22d447cd98368a0d516c3130 09f3990ffc6a41a8876d276a552d719d--c3c8704a22d447cd98368a0d516c3130 9b27e5c64e71447883d26833ac353419 c3c8704a22d447cd98368a0d516c3130--9b27e5c64e71447883d26833ac353419 c7a1946a6b5e40e7a2f69613901bb31c 9b27e5c64e71447883d26833ac353419--c7a1946a6b5e40e7a2f69613901bb31c e1f9850f38c04225a0584d1d5dea4741 c7a1946a6b5e40e7a2f69613901bb31c--e1f9850f38c04225a0584d1d5dea4741 fef1e56fd9ad4d75ab2262198b42e462 e1f9850f38c04225a0584d1d5dea4741--fef1e56fd9ad4d75ab2262198b42e462 d7e566e28de940338872fd1e322d1608 fef1e56fd9ad4d75ab2262198b42e462--d7e566e28de940338872fd1e322d1608 484fabbdaecb407f9440cef437360e5a d7e566e28de940338872fd1e322d1608--484fabbdaecb407f9440cef437360e5a 54a98444ef1947ab802170510a340432 484fabbdaecb407f9440cef437360e5a--54a98444ef1947ab802170510a340432 b93d2e20add745f49ca8e0a4a05d7b8f 54a98444ef1947ab802170510a340432--b93d2e20add745f49ca8e0a4a05d7b8f bf089da853bd42fc94e54b758337fc13 b93d2e20add745f49ca8e0a4a05d7b8f--bf089da853bd42fc94e54b758337fc13 cb77cd8094f44653b53a06772b0a5be7 bf089da853bd42fc94e54b758337fc13--cb77cd8094f44653b53a06772b0a5be7 5c84c45493804bf69f7d55c9f3a209c0 cb77cd8094f44653b53a06772b0a5be7--5c84c45493804bf69f7d55c9f3a209c0 5564db97dd1f4bc3bfa306cbc92515ba 5c84c45493804bf69f7d55c9f3a209c0--5564db97dd1f4bc3bfa306cbc92515ba bef1621498344e578a06be0ba32fbed1 5564db97dd1f4bc3bfa306cbc92515ba--bef1621498344e578a06be0ba32fbed1 fe48a54b595d4b4896bae0a814b6e6d1 bef1621498344e578a06be0ba32fbed1--fe48a54b595d4b4896bae0a814b6e6d1 8c7bd1b869ae443baf7169847998a3ec fe48a54b595d4b4896bae0a814b6e6d1--8c7bd1b869ae443baf7169847998a3ec a198a408f4d24895a97d0b5c3a322f7f 8c7bd1b869ae443baf7169847998a3ec--a198a408f4d24895a97d0b5c3a322f7f 3144c4cf60a547dc88019502c48a2258 a198a408f4d24895a97d0b5c3a322f7f--3144c4cf60a547dc88019502c48a2258 fb1bfb40c3cd4ce39c9c37432ca6c930 3144c4cf60a547dc88019502c48a2258--fb1bfb40c3cd4ce39c9c37432ca6c930 f13844a944fe449d8b82e1f2de6184c3 fb1bfb40c3cd4ce39c9c37432ca6c930--f13844a944fe449d8b82e1f2de6184c3 f12970ca57934b3fad7defba2183c9b0 f13844a944fe449d8b82e1f2de6184c3--f12970ca57934b3fad7defba2183c9b0 7d95352bfbb1468ba4fbbbb54e32ece2 f12970ca57934b3fad7defba2183c9b0--7d95352bfbb1468ba4fbbbb54e32ece2 951eb8c971f64a78b80953b0ca0bb7b4 7d95352bfbb1468ba4fbbbb54e32ece2--951eb8c971f64a78b80953b0ca0bb7b4 95f4b8b4c6fb47f28eee5fc765364be2 951eb8c971f64a78b80953b0ca0bb7b4--95f4b8b4c6fb47f28eee5fc765364be2 96f190fb5a2c49f59a8f8a4988a21017 RX(b00) 95f4b8b4c6fb47f28eee5fc765364be2--96f190fb5a2c49f59a8f8a4988a21017 e31e3253da0e443a97ddafbfa2f922ad 96f190fb5a2c49f59a8f8a4988a21017--e31e3253da0e443a97ddafbfa2f922ad dbe016ab73ca4ca69aea53bb2f734bcc e31e3253da0e443a97ddafbfa2f922ad--dbe016ab73ca4ca69aea53bb2f734bcc ad3b8a989e324fbaa68848cbf31c7760 dbe016ab73ca4ca69aea53bb2f734bcc--ad3b8a989e324fbaa68848cbf31c7760 1f36931f78344719a56da07640657a8a ad3b8a989e324fbaa68848cbf31c7760--1f36931f78344719a56da07640657a8a 9b0610e884af4bb481fcf524b427f66c 1f36931f78344719a56da07640657a8a--9b0610e884af4bb481fcf524b427f66c e55aac7c81ae421787b8609187d00c0a 9b0610e884af4bb481fcf524b427f66c--e55aac7c81ae421787b8609187d00c0a b65e41b8966c4267ab4d3c42c9f595e1 e55aac7c81ae421787b8609187d00c0a--b65e41b8966c4267ab4d3c42c9f595e1 bff83745e2c144ff96cb34462a2fdb36 b65e41b8966c4267ab4d3c42c9f595e1--bff83745e2c144ff96cb34462a2fdb36 a57470e47bcf40e9829189e7afd7dc37 bff83745e2c144ff96cb34462a2fdb36--a57470e47bcf40e9829189e7afd7dc37 5fa6a9510350406aa47696945a715588 a57470e47bcf40e9829189e7afd7dc37--5fa6a9510350406aa47696945a715588 8823c81416324b34b4f8bae8ff54faea 5fa6a9510350406aa47696945a715588--8823c81416324b34b4f8bae8ff54faea d5e090a1022a4a0780da85861d2d34e8 8823c81416324b34b4f8bae8ff54faea--d5e090a1022a4a0780da85861d2d34e8 2e74252c181841429329c190e6d90d8a d5e090a1022a4a0780da85861d2d34e8--2e74252c181841429329c190e6d90d8a 58c539824cbc4e91b0197323f1153e54 2e74252c181841429329c190e6d90d8a--58c539824cbc4e91b0197323f1153e54 15d25618a3c0470c9b398d12b735458b 58c539824cbc4e91b0197323f1153e54--15d25618a3c0470c9b398d12b735458b 14503a34af0d418cba0b9aff3f3661e8 15d25618a3c0470c9b398d12b735458b--14503a34af0d418cba0b9aff3f3661e8 133522ad532d4ca0a7562ecb0cae0353 14503a34af0d418cba0b9aff3f3661e8--133522ad532d4ca0a7562ecb0cae0353 f51f467e1cf04077b8e58417f3ef76cd 133522ad532d4ca0a7562ecb0cae0353--f51f467e1cf04077b8e58417f3ef76cd 48bd45639f184776af1d8c74b14a6c22 f51f467e1cf04077b8e58417f3ef76cd--48bd45639f184776af1d8c74b14a6c22 593f399b2795406e866dc3ea9f3200cd 48bd45639f184776af1d8c74b14a6c22--593f399b2795406e866dc3ea9f3200cd 09574cc736cb408ba5c7f6d7268b1cc3 593f399b2795406e866dc3ea9f3200cd--09574cc736cb408ba5c7f6d7268b1cc3 1a170ac6e045429ca9f2d36de9cdbf05 09574cc736cb408ba5c7f6d7268b1cc3--1a170ac6e045429ca9f2d36de9cdbf05 c0bda59fdd994968b6d299e0678a424a 1a170ac6e045429ca9f2d36de9cdbf05--c0bda59fdd994968b6d299e0678a424a 630364d5a45c4aceab779bd5a1f5b495 c0bda59fdd994968b6d299e0678a424a--630364d5a45c4aceab779bd5a1f5b495 3ee4e2960e0840c9929ae0ccbf542bb3 630364d5a45c4aceab779bd5a1f5b495--3ee4e2960e0840c9929ae0ccbf542bb3 f01b6183d1824fbfa2994b435cc267e1 3ee4e2960e0840c9929ae0ccbf542bb3--f01b6183d1824fbfa2994b435cc267e1 d9cb53a577604dcc9a0c93f330354201 f01b6183d1824fbfa2994b435cc267e1--d9cb53a577604dcc9a0c93f330354201 01683b51a9de4bb1a4f31b90b2fe5fe0 d9cb53a577604dcc9a0c93f330354201--01683b51a9de4bb1a4f31b90b2fe5fe0 dc9c915d8fa6406ab354b3837428ae10 01683b51a9de4bb1a4f31b90b2fe5fe0--dc9c915d8fa6406ab354b3837428ae10 c332d78f2894431291116e2e66d01929 dc9c915d8fa6406ab354b3837428ae10--c332d78f2894431291116e2e66d01929 d5bb82348c6b4d369024761245756055 c332d78f2894431291116e2e66d01929--d5bb82348c6b4d369024761245756055 f2e8ecfaf33c40e4b4ca1133b2a508e2 d5bb82348c6b4d369024761245756055--f2e8ecfaf33c40e4b4ca1133b2a508e2 2ee2c21af4d445d1909a18cae0943f6c f2e8ecfaf33c40e4b4ca1133b2a508e2--2ee2c21af4d445d1909a18cae0943f6c f5c8e1e068f74b3498a8b81edd83c73b 2ee2c21af4d445d1909a18cae0943f6c--f5c8e1e068f74b3498a8b81edd83c73b 3439d756ec44409a9455883862d74fad f5c8e1e068f74b3498a8b81edd83c73b--3439d756ec44409a9455883862d74fad a1f4ddb24c66423da48b31637f944b61 3439d756ec44409a9455883862d74fad--a1f4ddb24c66423da48b31637f944b61 19b4722864454dffb4a42d1fb828c011 a1f4ddb24c66423da48b31637f944b61--19b4722864454dffb4a42d1fb828c011 15fdcddcca7b41568271a1410fe1adfe 19b4722864454dffb4a42d1fb828c011--15fdcddcca7b41568271a1410fe1adfe f05abf19d9e24c5a8aa16f6e77fc4ce5 15fdcddcca7b41568271a1410fe1adfe--f05abf19d9e24c5a8aa16f6e77fc4ce5 e215babecf734d62b251fad12109e1a8 f05abf19d9e24c5a8aa16f6e77fc4ce5--e215babecf734d62b251fad12109e1a8 81e0232e99544adb9d6ab3f4c801a5b5 e215babecf734d62b251fad12109e1a8--81e0232e99544adb9d6ab3f4c801a5b5 3b3d19a2f6964439a49d80ddf43e68d7 81e0232e99544adb9d6ab3f4c801a5b5--3b3d19a2f6964439a49d80ddf43e68d7 5aa25f1e239a4446afbdff90ef743bf2 3b3d19a2f6964439a49d80ddf43e68d7--5aa25f1e239a4446afbdff90ef743bf2 ca0d43df0cfc4f9580a2b89a3248d927 5aa25f1e239a4446afbdff90ef743bf2--ca0d43df0cfc4f9580a2b89a3248d927 db8eca6350854d139216498244e385c2 ca0d43df0cfc4f9580a2b89a3248d927--db8eca6350854d139216498244e385c2 da02f6997b5f4c83872c2d38482dfd71 db8eca6350854d139216498244e385c2--da02f6997b5f4c83872c2d38482dfd71 ef398f4497864f5cb96ed944b9e6143d da02f6997b5f4c83872c2d38482dfd71--ef398f4497864f5cb96ed944b9e6143d e2a4b42e0c2543b1bab2755ff31c6992 ef398f4497864f5cb96ed944b9e6143d--e2a4b42e0c2543b1bab2755ff31c6992 d2ce701470d84177902c9b9bb4727a85 e2a4b42e0c2543b1bab2755ff31c6992--d2ce701470d84177902c9b9bb4727a85 60daa01db63144f98a9bf01090ae341b d2ce701470d84177902c9b9bb4727a85--60daa01db63144f98a9bf01090ae341b 0b6554a0e4414970bccf9ce03156fb89 60daa01db63144f98a9bf01090ae341b--0b6554a0e4414970bccf9ce03156fb89 ca18faf44d2f44e4b4b56ceb9f3fbd85 0b6554a0e4414970bccf9ce03156fb89--ca18faf44d2f44e4b4b56ceb9f3fbd85 d19b864eabd945218c9ef0896aa3a6d4 ca18faf44d2f44e4b4b56ceb9f3fbd85--d19b864eabd945218c9ef0896aa3a6d4 2dd35367e90e489da0f7fc35767ea72b d19b864eabd945218c9ef0896aa3a6d4--2dd35367e90e489da0f7fc35767ea72b 7bdc26ef8d244edea7e494c7469b9a60 2dd35367e90e489da0f7fc35767ea72b--7bdc26ef8d244edea7e494c7469b9a60 fe23c0a2ff19432685424f476486724f 7bdc26ef8d244edea7e494c7469b9a60--fe23c0a2ff19432685424f476486724f 33c634b840674e4aa70ac40fc70137bc fe23c0a2ff19432685424f476486724f--33c634b840674e4aa70ac40fc70137bc 683193f2226047c389626504a08b98ae 33c634b840674e4aa70ac40fc70137bc--683193f2226047c389626504a08b98ae 6112c2920eef4baebd2837d656e6a807 683193f2226047c389626504a08b98ae--6112c2920eef4baebd2837d656e6a807 0a6c4711f0054d31b4ac0ae674146865 6112c2920eef4baebd2837d656e6a807--0a6c4711f0054d31b4ac0ae674146865 3f63021700b4499498e74c83f3ebe798 0a6c4711f0054d31b4ac0ae674146865--3f63021700b4499498e74c83f3ebe798 a9749356b85545cf9da8520b8d65fbea 3f63021700b4499498e74c83f3ebe798--a9749356b85545cf9da8520b8d65fbea fb2e7c14cc894415a536c99d35b49979 a9749356b85545cf9da8520b8d65fbea--fb2e7c14cc894415a536c99d35b49979 abd9b917846d4209a25ebd06aa743123 fb2e7c14cc894415a536c99d35b49979--abd9b917846d4209a25ebd06aa743123 a71db450b94940728b737cc7414177c3 abd9b917846d4209a25ebd06aa743123--a71db450b94940728b737cc7414177c3 1ceb78950d4643ffb91950618d436035 a71db450b94940728b737cc7414177c3--1ceb78950d4643ffb91950618d436035 65d988f9fe6b491dbc1b391ed5d96bdc 1ceb78950d4643ffb91950618d436035--65d988f9fe6b491dbc1b391ed5d96bdc 8266dc90b28f478aa3972182b358fbc6 65d988f9fe6b491dbc1b391ed5d96bdc--8266dc90b28f478aa3972182b358fbc6 884718ed95814465a04904015ffa3adf 8266dc90b28f478aa3972182b358fbc6--884718ed95814465a04904015ffa3adf c955d8f2ccd04d1e985692211ef7b907 884718ed95814465a04904015ffa3adf--c955d8f2ccd04d1e985692211ef7b907 fd261dc9aedd46819ec6e9b2a30678ca c955d8f2ccd04d1e985692211ef7b907--fd261dc9aedd46819ec6e9b2a30678ca aa5290f0809c4b5099bb222e2cdd25fd fd261dc9aedd46819ec6e9b2a30678ca--aa5290f0809c4b5099bb222e2cdd25fd e0c557d53bbe49d4b342c6eac8b25b68 aa5290f0809c4b5099bb222e2cdd25fd--e0c557d53bbe49d4b342c6eac8b25b68 67b652d2151f4aecb2c292332fa588c3 e0c557d53bbe49d4b342c6eac8b25b68--67b652d2151f4aecb2c292332fa588c3 3bd4639136304ecfa3f3566f9aa92712 67b652d2151f4aecb2c292332fa588c3--3bd4639136304ecfa3f3566f9aa92712 4fb5e0f50498402e9e75a0a1cb8a5d28 3bd4639136304ecfa3f3566f9aa92712--4fb5e0f50498402e9e75a0a1cb8a5d28 eafb1bb196f54481a15f7e74e0e1a770 4fb5e0f50498402e9e75a0a1cb8a5d28--eafb1bb196f54481a15f7e74e0e1a770 d57cd802475a427495309662ffbf73b0 eafb1bb196f54481a15f7e74e0e1a770--d57cd802475a427495309662ffbf73b0 3943f42ff4a7400db869f2245723bb6e d57cd802475a427495309662ffbf73b0--3943f42ff4a7400db869f2245723bb6e 3c8168c4f5344809bc16740d77ac0ccc 3943f42ff4a7400db869f2245723bb6e--3c8168c4f5344809bc16740d77ac0ccc f87d8f8dc81446ceb8f73c655924e7a4 3c8168c4f5344809bc16740d77ac0ccc--f87d8f8dc81446ceb8f73c655924e7a4 583cf7e5f3fa4920a59591e5b5a01229 f87d8f8dc81446ceb8f73c655924e7a4--583cf7e5f3fa4920a59591e5b5a01229 b73978d315384ae78d4121f42d0914d2 583cf7e5f3fa4920a59591e5b5a01229--b73978d315384ae78d4121f42d0914d2 c55edc248cc5488b9f7ed96c8fa5c6c0 b73978d315384ae78d4121f42d0914d2--c55edc248cc5488b9f7ed96c8fa5c6c0 66d9266e756048fc8b7d86d26f1702cb c55edc248cc5488b9f7ed96c8fa5c6c0--66d9266e756048fc8b7d86d26f1702cb 48e9c064f8e84c94a94e3a3778d33c83 66d9266e756048fc8b7d86d26f1702cb--48e9c064f8e84c94a94e3a3778d33c83 a6109ca2ac7447418ce5f428fd6b2e06 48e9c064f8e84c94a94e3a3778d33c83--a6109ca2ac7447418ce5f428fd6b2e06 83760ee678144c20af01a8315421979d a6109ca2ac7447418ce5f428fd6b2e06--83760ee678144c20af01a8315421979d a9e8d27516b3445aae990bea2fd5059b 83760ee678144c20af01a8315421979d--a9e8d27516b3445aae990bea2fd5059b b63150853b5a451e95a4cb8ea53d5ebd a9e8d27516b3445aae990bea2fd5059b--b63150853b5a451e95a4cb8ea53d5ebd d69edc2f48284a54b02ec39e980cf35c b63150853b5a451e95a4cb8ea53d5ebd--d69edc2f48284a54b02ec39e980cf35c 3e2c366df2e44f8da9828072cd6a01cb d69edc2f48284a54b02ec39e980cf35c--3e2c366df2e44f8da9828072cd6a01cb 982d7372cc454878ac0bbbd2c40539c5 3e2c366df2e44f8da9828072cd6a01cb--982d7372cc454878ac0bbbd2c40539c5 71060effd4f746ea87e0a7fa2068f062 982d7372cc454878ac0bbbd2c40539c5--71060effd4f746ea87e0a7fa2068f062 bb1f642af38a43b8a6b5330a8537c245 71060effd4f746ea87e0a7fa2068f062--bb1f642af38a43b8a6b5330a8537c245 16e35fa93ff44b8e9c859b8508ac1b8a bb1f642af38a43b8a6b5330a8537c245--16e35fa93ff44b8e9c859b8508ac1b8a 6d60990639b8410b8149b24d15a00edd 16e35fa93ff44b8e9c859b8508ac1b8a--6d60990639b8410b8149b24d15a00edd 246740e3bb12415e9bcdc0719c42453e 6d60990639b8410b8149b24d15a00edd--246740e3bb12415e9bcdc0719c42453e f11c9430d45f4d70bbbbbdeece02d959 246740e3bb12415e9bcdc0719c42453e--f11c9430d45f4d70bbbbbdeece02d959 659aa4515086404baa6d97003129f9c8 f11c9430d45f4d70bbbbbdeece02d959--659aa4515086404baa6d97003129f9c8 2bcf85ab61914ddab9e3e349164e82b0 659aa4515086404baa6d97003129f9c8--2bcf85ab61914ddab9e3e349164e82b0 2935a48565534995b0ff6659f9cfa97e 2bcf85ab61914ddab9e3e349164e82b0--2935a48565534995b0ff6659f9cfa97e 6f7ef09a277d4f38beb189ad1f093925 2935a48565534995b0ff6659f9cfa97e--6f7ef09a277d4f38beb189ad1f093925 39930a78ce03475ca92311591d5d6da1 6f7ef09a277d4f38beb189ad1f093925--39930a78ce03475ca92311591d5d6da1 c84a666a42474ad6b839126060b8d0d2 39930a78ce03475ca92311591d5d6da1--c84a666a42474ad6b839126060b8d0d2 fefe40ab815d4f3a860ce0306882c3ac c84a666a42474ad6b839126060b8d0d2--fefe40ab815d4f3a860ce0306882c3ac 1a52e77d82c444a4a3d5793836e63077 fefe40ab815d4f3a860ce0306882c3ac--1a52e77d82c444a4a3d5793836e63077 c393262829194562a03320f80f4c5957 1a52e77d82c444a4a3d5793836e63077--c393262829194562a03320f80f4c5957 a7c33e7e71ff421d8a50d9776d3f7265 c393262829194562a03320f80f4c5957--a7c33e7e71ff421d8a50d9776d3f7265 e6a680d8dafb4109a7ecf387c888f236 a7c33e7e71ff421d8a50d9776d3f7265--e6a680d8dafb4109a7ecf387c888f236 8d2f5cd1c1244a1c92fd66183adbc206 e6a680d8dafb4109a7ecf387c888f236--8d2f5cd1c1244a1c92fd66183adbc206 73126824290a4926991347a189436797 8d2f5cd1c1244a1c92fd66183adbc206--73126824290a4926991347a189436797 194bf32d3f6d4aa3b00f0661aa61eccf 73126824290a4926991347a189436797--194bf32d3f6d4aa3b00f0661aa61eccf db8e35b392d440edbfabfe1b56a20031 194bf32d3f6d4aa3b00f0661aa61eccf--db8e35b392d440edbfabfe1b56a20031 a02dd71909504dffa8a52c52765612bd db8e35b392d440edbfabfe1b56a20031--a02dd71909504dffa8a52c52765612bd c539293cded8473aadb1a92c45d11d25 a02dd71909504dffa8a52c52765612bd--c539293cded8473aadb1a92c45d11d25 475112f62d394cbfa3cadce1eddbc22c c539293cded8473aadb1a92c45d11d25--475112f62d394cbfa3cadce1eddbc22c 03fdc76db41146c1a99eeb059bf3bd9c 475112f62d394cbfa3cadce1eddbc22c--03fdc76db41146c1a99eeb059bf3bd9c bc3fb2f4104645c7a99e54b5d8f36810 03fdc76db41146c1a99eeb059bf3bd9c--bc3fb2f4104645c7a99e54b5d8f36810 d186b9033dce42f29fbaf2111503b475 bc3fb2f4104645c7a99e54b5d8f36810--d186b9033dce42f29fbaf2111503b475 731a479d4e144553812499b99ab924fc d186b9033dce42f29fbaf2111503b475--731a479d4e144553812499b99ab924fc fdd8d5f089b049bd8197ea46ae5d0fc7 731a479d4e144553812499b99ab924fc--fdd8d5f089b049bd8197ea46ae5d0fc7 2ecefc602ed94c2db18d0256e1fdb9e1 fdd8d5f089b049bd8197ea46ae5d0fc7--2ecefc602ed94c2db18d0256e1fdb9e1 9486d6a9f7fe4b318a475653de12bf76 2ecefc602ed94c2db18d0256e1fdb9e1--9486d6a9f7fe4b318a475653de12bf76 1db4b3848dcb45689ef9bd1325e64b4d 9486d6a9f7fe4b318a475653de12bf76--1db4b3848dcb45689ef9bd1325e64b4d 375d74096c054695956f787fadeb59b3 1db4b3848dcb45689ef9bd1325e64b4d--375d74096c054695956f787fadeb59b3 84865d6f2a7548d0829c374ab7ffb308 375d74096c054695956f787fadeb59b3--84865d6f2a7548d0829c374ab7ffb308 eebed4d22b0f4410a223c98a824a1a8a 84865d6f2a7548d0829c374ab7ffb308--eebed4d22b0f4410a223c98a824a1a8a d84b0650f0534baca9fef12190d4df54 RX(b10) eebed4d22b0f4410a223c98a824a1a8a--d84b0650f0534baca9fef12190d4df54 a2b5648e6cb3424ebf9068cd2ef33d02 d84b0650f0534baca9fef12190d4df54--a2b5648e6cb3424ebf9068cd2ef33d02 a94056a040624592b99e8ca2f3008d5b 8ab516243c83417b880287a2d2da5754 X 07a322b7a50e4c65821ec8d57246da6a--8ab516243c83417b880287a2d2da5754 a53e7217252247fb99c93a14ce590a22 2 8ab516243c83417b880287a2d2da5754--84a617bd09634b13a0e50f94921ffdc5 6cc7201313074b058f4fb8fdd869c610 8ab516243c83417b880287a2d2da5754--6cc7201313074b058f4fb8fdd869c610 427d1bde1a334e51a8f675aeedde4e22 6cc7201313074b058f4fb8fdd869c610--427d1bde1a334e51a8f675aeedde4e22 47eddbded018418f81c001866a993591 427d1bde1a334e51a8f675aeedde4e22--47eddbded018418f81c001866a993591 28af8c66de4f47b58e1c179b1398412f 47eddbded018418f81c001866a993591--28af8c66de4f47b58e1c179b1398412f 8a527861da984f77a64393e49bd00898 28af8c66de4f47b58e1c179b1398412f--8a527861da984f77a64393e49bd00898 932eb21056084895a1f2f4923c6eb1b0 8a527861da984f77a64393e49bd00898--932eb21056084895a1f2f4923c6eb1b0 37ee93ef2aa04762a6e1686a000e730d 932eb21056084895a1f2f4923c6eb1b0--37ee93ef2aa04762a6e1686a000e730d 54e27b630fd24322bbe0cc1ff34de779 37ee93ef2aa04762a6e1686a000e730d--54e27b630fd24322bbe0cc1ff34de779 1f33e9b51f0b4e2982e3e176d88ea513 54e27b630fd24322bbe0cc1ff34de779--1f33e9b51f0b4e2982e3e176d88ea513 98c1af5af66e4615b69b61b3436beee1 1f33e9b51f0b4e2982e3e176d88ea513--98c1af5af66e4615b69b61b3436beee1 3a77c57b58a84d72b0b4a39816732d95 98c1af5af66e4615b69b61b3436beee1--3a77c57b58a84d72b0b4a39816732d95 cc5dd08e126c48fb89af6c8893fd16df 3a77c57b58a84d72b0b4a39816732d95--cc5dd08e126c48fb89af6c8893fd16df 3086f469a6e04bc0ba558024c06e5d27 cc5dd08e126c48fb89af6c8893fd16df--3086f469a6e04bc0ba558024c06e5d27 200b95a7aee74de184aec556983f25cb X 3086f469a6e04bc0ba558024c06e5d27--200b95a7aee74de184aec556983f25cb 200b95a7aee74de184aec556983f25cb--f55a531366cd48ccaab81d510b7cce1e ed973ecbbf7449abb159cad961ee2680 X 200b95a7aee74de184aec556983f25cb--ed973ecbbf7449abb159cad961ee2680 ed973ecbbf7449abb159cad961ee2680--cdf8b70c5d5f4b8181a4d81c0c4f2257 c02ed4f9eea4423b83141c38ed2ed485 RZ(-1.0*g0) ed973ecbbf7449abb159cad961ee2680--c02ed4f9eea4423b83141c38ed2ed485 22b3fdd90b6b447d82fcf9444b109dd0 X c02ed4f9eea4423b83141c38ed2ed485--22b3fdd90b6b447d82fcf9444b109dd0 22b3fdd90b6b447d82fcf9444b109dd0--6803f25f3d064c789ebfa426ad7a3ad7 ece4e2656d4142ada81b259a8add43f5 X 22b3fdd90b6b447d82fcf9444b109dd0--ece4e2656d4142ada81b259a8add43f5 ece4e2656d4142ada81b259a8add43f5--0d2dfc7fdbcb418b87fb6f2cb4d394ad 3c18e7c78f0a4fa08a40105d4d4844e0 ece4e2656d4142ada81b259a8add43f5--3c18e7c78f0a4fa08a40105d4d4844e0 c67e90b9f77a40f497fb95cc5422a0c5 3c18e7c78f0a4fa08a40105d4d4844e0--c67e90b9f77a40f497fb95cc5422a0c5 cf25988739bd424ca8303915d6cebb0c c67e90b9f77a40f497fb95cc5422a0c5--cf25988739bd424ca8303915d6cebb0c c428c1ad9e5a4d538469ee4b83a1876f X cf25988739bd424ca8303915d6cebb0c--c428c1ad9e5a4d538469ee4b83a1876f c428c1ad9e5a4d538469ee4b83a1876f--87c5311cb40c4309a767107692009a01 aa88fbedb8be4112b17ceae9d0554299 X c428c1ad9e5a4d538469ee4b83a1876f--aa88fbedb8be4112b17ceae9d0554299 aa88fbedb8be4112b17ceae9d0554299--b259ec9da7ea48de87e064c17949a743 ff7be409a5844d2f8baee7705850eb2b aa88fbedb8be4112b17ceae9d0554299--ff7be409a5844d2f8baee7705850eb2b dc603490ce49462fb4d26346bd4bcb6a ff7be409a5844d2f8baee7705850eb2b--dc603490ce49462fb4d26346bd4bcb6a 1daa10b63ece40179bcfe8d7a697f005 dc603490ce49462fb4d26346bd4bcb6a--1daa10b63ece40179bcfe8d7a697f005 0fd7ecda5f4e419ba9f58430dbc105db 1daa10b63ece40179bcfe8d7a697f005--0fd7ecda5f4e419ba9f58430dbc105db 8e548d7394bd415293ba72b46fb56904 0fd7ecda5f4e419ba9f58430dbc105db--8e548d7394bd415293ba72b46fb56904 a512d182de16447bba9ce8b48f70bc02 X 8e548d7394bd415293ba72b46fb56904--a512d182de16447bba9ce8b48f70bc02 a512d182de16447bba9ce8b48f70bc02--364a66dc3e6c460293f190f75098de92 f90b67e6a2e3490587e6b557e510e8fe X a512d182de16447bba9ce8b48f70bc02--f90b67e6a2e3490587e6b557e510e8fe f90b67e6a2e3490587e6b557e510e8fe--9fd2f32a859f409eb21717b80e6989f3 bff13f5e426e4e7396208b0b5a8909e0 f90b67e6a2e3490587e6b557e510e8fe--bff13f5e426e4e7396208b0b5a8909e0 debd37fa40324f13806c4c10bd22eabf bff13f5e426e4e7396208b0b5a8909e0--debd37fa40324f13806c4c10bd22eabf e04fb3875e7a41ec84e54d2db3a48285 debd37fa40324f13806c4c10bd22eabf--e04fb3875e7a41ec84e54d2db3a48285 e937693026184aa4966bb8386c0382d0 e04fb3875e7a41ec84e54d2db3a48285--e937693026184aa4966bb8386c0382d0 1f6a2abae77c438f8081761d8035bc0e e937693026184aa4966bb8386c0382d0--1f6a2abae77c438f8081761d8035bc0e 84fbc3bfd20542af951183a3594e5757 1f6a2abae77c438f8081761d8035bc0e--84fbc3bfd20542af951183a3594e5757 30e629a10af94fd583f03b617f75ec02 84fbc3bfd20542af951183a3594e5757--30e629a10af94fd583f03b617f75ec02 58423ec1aeb344acabb0483cb1102afe X 30e629a10af94fd583f03b617f75ec02--58423ec1aeb344acabb0483cb1102afe 58423ec1aeb344acabb0483cb1102afe--9731660020854cfc8c248633f5216ea0 f489cf08eedb42fea93e2604a14c4654 X 58423ec1aeb344acabb0483cb1102afe--f489cf08eedb42fea93e2604a14c4654 f489cf08eedb42fea93e2604a14c4654--c3a206852d92409c9241e330e6d07a0b 1385c2658acb41e1ab5fbf0630821e25 f489cf08eedb42fea93e2604a14c4654--1385c2658acb41e1ab5fbf0630821e25 c01ebd7602bd4915b1b74df63a42be09 1385c2658acb41e1ab5fbf0630821e25--c01ebd7602bd4915b1b74df63a42be09 cda7ae1db53946f881fbc90482382fba c01ebd7602bd4915b1b74df63a42be09--cda7ae1db53946f881fbc90482382fba d60f76fc6e8648c6b56441940624d537 cda7ae1db53946f881fbc90482382fba--d60f76fc6e8648c6b56441940624d537 e799bebe07e54b0ba0fa6eefbf858abd d60f76fc6e8648c6b56441940624d537--e799bebe07e54b0ba0fa6eefbf858abd 71e0be30ee4b4dedb85d69c7aa460974 e799bebe07e54b0ba0fa6eefbf858abd--71e0be30ee4b4dedb85d69c7aa460974 0b44cd289f2b4d669e54542f0d274dd0 71e0be30ee4b4dedb85d69c7aa460974--0b44cd289f2b4d669e54542f0d274dd0 e0a8f6e0a6d54dde897e0081885b0112 0b44cd289f2b4d669e54542f0d274dd0--e0a8f6e0a6d54dde897e0081885b0112 18838d0810cb496f938308b33256b148 e0a8f6e0a6d54dde897e0081885b0112--18838d0810cb496f938308b33256b148 f340b5938e04469ab0b03b643b5c7c92 18838d0810cb496f938308b33256b148--f340b5938e04469ab0b03b643b5c7c92 b486b112cfa04e18ab95a055fa803e0f f340b5938e04469ab0b03b643b5c7c92--b486b112cfa04e18ab95a055fa803e0f 442d7a7206b7485ba8ecc44f23ddbbc2 X b486b112cfa04e18ab95a055fa803e0f--442d7a7206b7485ba8ecc44f23ddbbc2 442d7a7206b7485ba8ecc44f23ddbbc2--0180befccfe0434bae716e3c093fa3b9 578c804ac0a14c38b69bc87273b4fd33 X 442d7a7206b7485ba8ecc44f23ddbbc2--578c804ac0a14c38b69bc87273b4fd33 578c804ac0a14c38b69bc87273b4fd33--215d18d030734f4982d766b4ffe26519 52cb296ba7f64f2dbc4c6df73d65eb50 578c804ac0a14c38b69bc87273b4fd33--52cb296ba7f64f2dbc4c6df73d65eb50 b4cd594bcbad40499088ed484049e62f 52cb296ba7f64f2dbc4c6df73d65eb50--b4cd594bcbad40499088ed484049e62f f14ca9f112ec45f3b4c6de27f7125ff2 b4cd594bcbad40499088ed484049e62f--f14ca9f112ec45f3b4c6de27f7125ff2 ea8b58e8674d411083ed3b16a78d1d33 f14ca9f112ec45f3b4c6de27f7125ff2--ea8b58e8674d411083ed3b16a78d1d33 2d6964f022da4ada8b83731962c9cbaf ea8b58e8674d411083ed3b16a78d1d33--2d6964f022da4ada8b83731962c9cbaf c41120d8897d493c8706bb7fc2ea3612 2d6964f022da4ada8b83731962c9cbaf--c41120d8897d493c8706bb7fc2ea3612 e15e6c7c93c6422997c27c4683d1add2 c41120d8897d493c8706bb7fc2ea3612--e15e6c7c93c6422997c27c4683d1add2 f2558cf9ad1b48de96a0c67bcdaa4eaa e15e6c7c93c6422997c27c4683d1add2--f2558cf9ad1b48de96a0c67bcdaa4eaa 16dfd543383a43b3a9a2e096c55d908f f2558cf9ad1b48de96a0c67bcdaa4eaa--16dfd543383a43b3a9a2e096c55d908f 462b21bd0c064108be103e5cedd85b95 16dfd543383a43b3a9a2e096c55d908f--462b21bd0c064108be103e5cedd85b95 59323cf36208454ab564939d9c66fb18 462b21bd0c064108be103e5cedd85b95--59323cf36208454ab564939d9c66fb18 d51c423eed2749ad90da69e8e4e2db75 59323cf36208454ab564939d9c66fb18--d51c423eed2749ad90da69e8e4e2db75 3ba042b83d99482f9a2e2f550c975380 d51c423eed2749ad90da69e8e4e2db75--3ba042b83d99482f9a2e2f550c975380 a03ca73a74c34567ab1f373e78013b38 X 3ba042b83d99482f9a2e2f550c975380--a03ca73a74c34567ab1f373e78013b38 a03ca73a74c34567ab1f373e78013b38--26d72d2788504ac6a5f8ac72338b27a8 7614ec1beadb465dbd367a393ed22892 a03ca73a74c34567ab1f373e78013b38--7614ec1beadb465dbd367a393ed22892 ecc6e60241984bf380de2a1c4234a2bd 7614ec1beadb465dbd367a393ed22892--ecc6e60241984bf380de2a1c4234a2bd 503e41ca7fc7474a92ad2b2ef200e5d6 ecc6e60241984bf380de2a1c4234a2bd--503e41ca7fc7474a92ad2b2ef200e5d6 abff53e4a8ef4009b1b847049d91d68a 503e41ca7fc7474a92ad2b2ef200e5d6--abff53e4a8ef4009b1b847049d91d68a 09a25ecb98c4477b9bbd8aaf798a74ce abff53e4a8ef4009b1b847049d91d68a--09a25ecb98c4477b9bbd8aaf798a74ce 96f1f27f98b84456a201728f171c9031 09a25ecb98c4477b9bbd8aaf798a74ce--96f1f27f98b84456a201728f171c9031 2a8aee03401a485a89ecaf93a699d274 96f1f27f98b84456a201728f171c9031--2a8aee03401a485a89ecaf93a699d274 29c40ce79b654382bdf0164907e6d88d 2a8aee03401a485a89ecaf93a699d274--29c40ce79b654382bdf0164907e6d88d acdd047babaf44f18e56336be971cf96 29c40ce79b654382bdf0164907e6d88d--acdd047babaf44f18e56336be971cf96 af359ea9a3384016a3a7778aa631ed20 acdd047babaf44f18e56336be971cf96--af359ea9a3384016a3a7778aa631ed20 fb2a59c8b1a8430bb609166801737b37 af359ea9a3384016a3a7778aa631ed20--fb2a59c8b1a8430bb609166801737b37 3df46c4d458247f1803a3c5178e28963 fb2a59c8b1a8430bb609166801737b37--3df46c4d458247f1803a3c5178e28963 5081c8a2d3d3464ab824a8ac9f3b86aa 3df46c4d458247f1803a3c5178e28963--5081c8a2d3d3464ab824a8ac9f3b86aa 08f5943c9a53467c8089304919b8fa13 5081c8a2d3d3464ab824a8ac9f3b86aa--08f5943c9a53467c8089304919b8fa13 cc3a1affc7814f0c8a8062ab883b0536 08f5943c9a53467c8089304919b8fa13--cc3a1affc7814f0c8a8062ab883b0536 2f4b8de693584ffabcc04c0d4b9f3961 cc3a1affc7814f0c8a8062ab883b0536--2f4b8de693584ffabcc04c0d4b9f3961 b6d662dabfed45feb53cad7412aed04e 2f4b8de693584ffabcc04c0d4b9f3961--b6d662dabfed45feb53cad7412aed04e b15e40ee297241fa812cc2c610cb18f9 b6d662dabfed45feb53cad7412aed04e--b15e40ee297241fa812cc2c610cb18f9 ab61a84534fb4575874ae45b9dcb9143 b15e40ee297241fa812cc2c610cb18f9--ab61a84534fb4575874ae45b9dcb9143 a05f4e6aea8743539089ca84af2379e9 ab61a84534fb4575874ae45b9dcb9143--a05f4e6aea8743539089ca84af2379e9 365531f10e5544989b7dc5eb71f64512 a05f4e6aea8743539089ca84af2379e9--365531f10e5544989b7dc5eb71f64512 8fe6f26999cb424baed2834903909fea 365531f10e5544989b7dc5eb71f64512--8fe6f26999cb424baed2834903909fea ed55b228f76943fea1c4f4790e5cb775 8fe6f26999cb424baed2834903909fea--ed55b228f76943fea1c4f4790e5cb775 151f311ebcde48c49b6edbb8e2d418f1 ed55b228f76943fea1c4f4790e5cb775--151f311ebcde48c49b6edbb8e2d418f1 ccb87b09daf7488b87090766d649081d 151f311ebcde48c49b6edbb8e2d418f1--ccb87b09daf7488b87090766d649081d d1322d0d09fb4685a27ef0b975e91b7e ccb87b09daf7488b87090766d649081d--d1322d0d09fb4685a27ef0b975e91b7e f2f0055e13494b54a5124fd9d321b512 d1322d0d09fb4685a27ef0b975e91b7e--f2f0055e13494b54a5124fd9d321b512 9c820a41df7349218780f12c625b9c23 f2f0055e13494b54a5124fd9d321b512--9c820a41df7349218780f12c625b9c23 ade5168800964e50953573783884e81d 9c820a41df7349218780f12c625b9c23--ade5168800964e50953573783884e81d 77ae4ad658644b75ba24bdcb8aacc37d ade5168800964e50953573783884e81d--77ae4ad658644b75ba24bdcb8aacc37d a9f478a91f06474ead5fd6b6ac738008 77ae4ad658644b75ba24bdcb8aacc37d--a9f478a91f06474ead5fd6b6ac738008 3f8f81b0acfa4ca0a2a60b0f82876433 a9f478a91f06474ead5fd6b6ac738008--3f8f81b0acfa4ca0a2a60b0f82876433 735b8533234845389ac3894b2077e1f8 3f8f81b0acfa4ca0a2a60b0f82876433--735b8533234845389ac3894b2077e1f8 3e8442b844524b4fa1ddd625b8500f56 735b8533234845389ac3894b2077e1f8--3e8442b844524b4fa1ddd625b8500f56 d94348201d0d4fbca2d86ce7be1dd5f6 3e8442b844524b4fa1ddd625b8500f56--d94348201d0d4fbca2d86ce7be1dd5f6 17056c284fa3469c994a442c64873e58 d94348201d0d4fbca2d86ce7be1dd5f6--17056c284fa3469c994a442c64873e58 28f1c93c53ba4bdf9057626d794f6110 17056c284fa3469c994a442c64873e58--28f1c93c53ba4bdf9057626d794f6110 d3bca77443f348b9888307ef4bd7b489 28f1c93c53ba4bdf9057626d794f6110--d3bca77443f348b9888307ef4bd7b489 5b50dbcc6518446287ad0070f6c114ac d3bca77443f348b9888307ef4bd7b489--5b50dbcc6518446287ad0070f6c114ac 4a3bbe0b70034a4388347da61fd69aa7 5b50dbcc6518446287ad0070f6c114ac--4a3bbe0b70034a4388347da61fd69aa7 3a1dd348db5645e2972731f6ec724e96 4a3bbe0b70034a4388347da61fd69aa7--3a1dd348db5645e2972731f6ec724e96 1aba25ff6f87406aacd5843a7214dc58 3a1dd348db5645e2972731f6ec724e96--1aba25ff6f87406aacd5843a7214dc58 a07107a497b44c33acb74db9e600bcf8 1aba25ff6f87406aacd5843a7214dc58--a07107a497b44c33acb74db9e600bcf8 616cb00e99714366b0ca6b162d4a385d a07107a497b44c33acb74db9e600bcf8--616cb00e99714366b0ca6b162d4a385d 1c337faeff964d8f954695923c7f3116 616cb00e99714366b0ca6b162d4a385d--1c337faeff964d8f954695923c7f3116 254be6f21e004c4bba54b5e6afb7fb31 1c337faeff964d8f954695923c7f3116--254be6f21e004c4bba54b5e6afb7fb31 468240e50dd34a08ad6fde3e9a3442a5 254be6f21e004c4bba54b5e6afb7fb31--468240e50dd34a08ad6fde3e9a3442a5 00768a169d83446183e5299c119c01fd 468240e50dd34a08ad6fde3e9a3442a5--00768a169d83446183e5299c119c01fd a66ad15db2494e72919094aedd8a1950 00768a169d83446183e5299c119c01fd--a66ad15db2494e72919094aedd8a1950 81a3a7cf9d5c448586246c53a84930be a66ad15db2494e72919094aedd8a1950--81a3a7cf9d5c448586246c53a84930be fddd5ffd1750448a9c16cda3673990e8 81a3a7cf9d5c448586246c53a84930be--fddd5ffd1750448a9c16cda3673990e8 888c48d4f1cb4a29a2163d03eda66fe2 fddd5ffd1750448a9c16cda3673990e8--888c48d4f1cb4a29a2163d03eda66fe2 3a83725362b041fea8ba3bd1d3abe8e3 888c48d4f1cb4a29a2163d03eda66fe2--3a83725362b041fea8ba3bd1d3abe8e3 f27673cd3b9948a5a80db1304024d3fa 3a83725362b041fea8ba3bd1d3abe8e3--f27673cd3b9948a5a80db1304024d3fa 046d4d816724443fb6f7d915cc212e0a f27673cd3b9948a5a80db1304024d3fa--046d4d816724443fb6f7d915cc212e0a c0109628cf804dc29c94046abcec79f1 046d4d816724443fb6f7d915cc212e0a--c0109628cf804dc29c94046abcec79f1 512fc69eccf14d8189d3d8813b51afa7 c0109628cf804dc29c94046abcec79f1--512fc69eccf14d8189d3d8813b51afa7 e3c01772430f4261be3e303699ed227d 512fc69eccf14d8189d3d8813b51afa7--e3c01772430f4261be3e303699ed227d b59c8ae1c9624d90b04ba57ffcbfb8ae e3c01772430f4261be3e303699ed227d--b59c8ae1c9624d90b04ba57ffcbfb8ae 025f2990c50c44afb4742c159d30e05a b59c8ae1c9624d90b04ba57ffcbfb8ae--025f2990c50c44afb4742c159d30e05a 822547630f354fb58f883a636e341ea5 025f2990c50c44afb4742c159d30e05a--822547630f354fb58f883a636e341ea5 1171f6033d2547418ed51f70df02354a RX(b01) 822547630f354fb58f883a636e341ea5--1171f6033d2547418ed51f70df02354a 7158f230e7c04c9289096a4b91567af9 X 1171f6033d2547418ed51f70df02354a--7158f230e7c04c9289096a4b91567af9 7158f230e7c04c9289096a4b91567af9--e31e3253da0e443a97ddafbfa2f922ad 185a03c0a956470a9557b7682adeb007 7158f230e7c04c9289096a4b91567af9--185a03c0a956470a9557b7682adeb007 01fc2ceb577940de820b8beacd324a66 185a03c0a956470a9557b7682adeb007--01fc2ceb577940de820b8beacd324a66 558503a47b3a46b298f08a032d252561 01fc2ceb577940de820b8beacd324a66--558503a47b3a46b298f08a032d252561 9d2c74ee94254b6f99a0bfe7fa67d95c 558503a47b3a46b298f08a032d252561--9d2c74ee94254b6f99a0bfe7fa67d95c 8c705dc7d7e442928a6a8f2962239612 9d2c74ee94254b6f99a0bfe7fa67d95c--8c705dc7d7e442928a6a8f2962239612 5ee9035a056a41e9b7b4645e6fd412e7 8c705dc7d7e442928a6a8f2962239612--5ee9035a056a41e9b7b4645e6fd412e7 ed3b8c2b51d94c7789918bc1b1e1f0d8 5ee9035a056a41e9b7b4645e6fd412e7--ed3b8c2b51d94c7789918bc1b1e1f0d8 235c0cd28a2740f3a51adad8a877b368 ed3b8c2b51d94c7789918bc1b1e1f0d8--235c0cd28a2740f3a51adad8a877b368 5346bb7929fd46ccb4395a6c98399d9c 235c0cd28a2740f3a51adad8a877b368--5346bb7929fd46ccb4395a6c98399d9c 3bf54b5e4e2c4c23a13eaa4c0b6fef27 5346bb7929fd46ccb4395a6c98399d9c--3bf54b5e4e2c4c23a13eaa4c0b6fef27 f201b14ef68142919cfaac9eb64db267 3bf54b5e4e2c4c23a13eaa4c0b6fef27--f201b14ef68142919cfaac9eb64db267 9177762c416d4976bcfabfc5352f02aa f201b14ef68142919cfaac9eb64db267--9177762c416d4976bcfabfc5352f02aa 5df72fd78c5f43af9e3ba47b87724d20 9177762c416d4976bcfabfc5352f02aa--5df72fd78c5f43af9e3ba47b87724d20 a9038446ae7c485cb48b7927565d7b8a X 5df72fd78c5f43af9e3ba47b87724d20--a9038446ae7c485cb48b7927565d7b8a a9038446ae7c485cb48b7927565d7b8a--15d25618a3c0470c9b398d12b735458b 339d867259854d9fb6b89f66099ee0e5 X a9038446ae7c485cb48b7927565d7b8a--339d867259854d9fb6b89f66099ee0e5 339d867259854d9fb6b89f66099ee0e5--14503a34af0d418cba0b9aff3f3661e8 891403a22f864560a60e392f4b34f2d9 RZ(-1.0*g1) 339d867259854d9fb6b89f66099ee0e5--891403a22f864560a60e392f4b34f2d9 202405cf1e64411198fe3be9e6ea1605 X 891403a22f864560a60e392f4b34f2d9--202405cf1e64411198fe3be9e6ea1605 202405cf1e64411198fe3be9e6ea1605--f51f467e1cf04077b8e58417f3ef76cd 54f3b3b5baa0402c93987da1654f2491 X 202405cf1e64411198fe3be9e6ea1605--54f3b3b5baa0402c93987da1654f2491 54f3b3b5baa0402c93987da1654f2491--48bd45639f184776af1d8c74b14a6c22 6b81d74070b642788fa77bae549c3ffd 54f3b3b5baa0402c93987da1654f2491--6b81d74070b642788fa77bae549c3ffd ec59c436acaa4acd84bc49c805ae79d3 6b81d74070b642788fa77bae549c3ffd--ec59c436acaa4acd84bc49c805ae79d3 3854f8e6a82441cfab15ab8571bba81a ec59c436acaa4acd84bc49c805ae79d3--3854f8e6a82441cfab15ab8571bba81a eb84b75750a446239019bc52f0df46aa X 3854f8e6a82441cfab15ab8571bba81a--eb84b75750a446239019bc52f0df46aa eb84b75750a446239019bc52f0df46aa--c0bda59fdd994968b6d299e0678a424a 1dea5505062742609dcf8a130bf5adbc X eb84b75750a446239019bc52f0df46aa--1dea5505062742609dcf8a130bf5adbc 1dea5505062742609dcf8a130bf5adbc--630364d5a45c4aceab779bd5a1f5b495 c5be052fff5f42069f9ff42f7f567ff5 1dea5505062742609dcf8a130bf5adbc--c5be052fff5f42069f9ff42f7f567ff5 a03011560560466698289a0cc4c7a246 c5be052fff5f42069f9ff42f7f567ff5--a03011560560466698289a0cc4c7a246 3eae7113e81d4c69a190ef1ce0ac9595 a03011560560466698289a0cc4c7a246--3eae7113e81d4c69a190ef1ce0ac9595 685d857da5784b7aa757e0336ef5ca59 3eae7113e81d4c69a190ef1ce0ac9595--685d857da5784b7aa757e0336ef5ca59 ce287f4f82964ebd81302846cc0eb460 685d857da5784b7aa757e0336ef5ca59--ce287f4f82964ebd81302846cc0eb460 70309aee9c2e4b938f19bed3ef4ff29b X ce287f4f82964ebd81302846cc0eb460--70309aee9c2e4b938f19bed3ef4ff29b 70309aee9c2e4b938f19bed3ef4ff29b--c332d78f2894431291116e2e66d01929 2ca167273fb04a8faf9b82ae6f597782 X 70309aee9c2e4b938f19bed3ef4ff29b--2ca167273fb04a8faf9b82ae6f597782 2ca167273fb04a8faf9b82ae6f597782--d5bb82348c6b4d369024761245756055 8d81f1bd911a41bfbf58c4474bc7d33d 2ca167273fb04a8faf9b82ae6f597782--8d81f1bd911a41bfbf58c4474bc7d33d af4236314e1646668edb799ef5c9a59d 8d81f1bd911a41bfbf58c4474bc7d33d--af4236314e1646668edb799ef5c9a59d c150e0baba784072836493cf6def5c23 af4236314e1646668edb799ef5c9a59d--c150e0baba784072836493cf6def5c23 2b6d3dd642e944bc895685bf3cbc7174 c150e0baba784072836493cf6def5c23--2b6d3dd642e944bc895685bf3cbc7174 0500bf4d35ee4768ab9136319668bdf2 2b6d3dd642e944bc895685bf3cbc7174--0500bf4d35ee4768ab9136319668bdf2 29d6774a2fa14d37a70f844e1c159307 0500bf4d35ee4768ab9136319668bdf2--29d6774a2fa14d37a70f844e1c159307 90dd876230b84360bfbad78fdaa7bc80 29d6774a2fa14d37a70f844e1c159307--90dd876230b84360bfbad78fdaa7bc80 a51307b929ad485d8f0715765f603f28 X 90dd876230b84360bfbad78fdaa7bc80--a51307b929ad485d8f0715765f603f28 a51307b929ad485d8f0715765f603f28--f05abf19d9e24c5a8aa16f6e77fc4ce5 66592716a0454ac899e8081e7b37979f X a51307b929ad485d8f0715765f603f28--66592716a0454ac899e8081e7b37979f 66592716a0454ac899e8081e7b37979f--e215babecf734d62b251fad12109e1a8 76df01a89d6743dd83749dffd7c17553 66592716a0454ac899e8081e7b37979f--76df01a89d6743dd83749dffd7c17553 915088abaea34455b657db65ec805cce 76df01a89d6743dd83749dffd7c17553--915088abaea34455b657db65ec805cce 30a163c8822c45bc9b78a6622a37ea28 915088abaea34455b657db65ec805cce--30a163c8822c45bc9b78a6622a37ea28 b2eb9f6d513c4137943b94027092afe2 30a163c8822c45bc9b78a6622a37ea28--b2eb9f6d513c4137943b94027092afe2 cc6d6449930746cea58c36f43533f45d b2eb9f6d513c4137943b94027092afe2--cc6d6449930746cea58c36f43533f45d 6517ecd9ee0649eba656a19fc10b0d51 cc6d6449930746cea58c36f43533f45d--6517ecd9ee0649eba656a19fc10b0d51 05971ea2a78a418d97bc82208ebdaabf 6517ecd9ee0649eba656a19fc10b0d51--05971ea2a78a418d97bc82208ebdaabf 19f96c3696ff4595bb71bba86ac4f065 05971ea2a78a418d97bc82208ebdaabf--19f96c3696ff4595bb71bba86ac4f065 de5df10e1352488aabf208394878af1c 19f96c3696ff4595bb71bba86ac4f065--de5df10e1352488aabf208394878af1c 9be2880e234a476ca2a641323cf8c412 de5df10e1352488aabf208394878af1c--9be2880e234a476ca2a641323cf8c412 594ce9816069476db1b77e6ab600c702 9be2880e234a476ca2a641323cf8c412--594ce9816069476db1b77e6ab600c702 548845eda8fa41bbbc5738c7902fcdba X 594ce9816069476db1b77e6ab600c702--548845eda8fa41bbbc5738c7902fcdba 548845eda8fa41bbbc5738c7902fcdba--ca18faf44d2f44e4b4b56ceb9f3fbd85 bc810eb278794e558cfb3deeb4636e40 X 548845eda8fa41bbbc5738c7902fcdba--bc810eb278794e558cfb3deeb4636e40 bc810eb278794e558cfb3deeb4636e40--d19b864eabd945218c9ef0896aa3a6d4 f3b5ceb94fc54079a586fb219ecfab4c bc810eb278794e558cfb3deeb4636e40--f3b5ceb94fc54079a586fb219ecfab4c 43e0818f18064c83b26442ed23f7bfb0 f3b5ceb94fc54079a586fb219ecfab4c--43e0818f18064c83b26442ed23f7bfb0 89ba1f659fec42f0a81faf3d423ef36c 43e0818f18064c83b26442ed23f7bfb0--89ba1f659fec42f0a81faf3d423ef36c 0516026ac9ab4ac0a6fb433bc39653b2 89ba1f659fec42f0a81faf3d423ef36c--0516026ac9ab4ac0a6fb433bc39653b2 fc744134024b48fb9815c730dbed84ad 0516026ac9ab4ac0a6fb433bc39653b2--fc744134024b48fb9815c730dbed84ad 53ee621754d14f7abb915b55f7979f88 fc744134024b48fb9815c730dbed84ad--53ee621754d14f7abb915b55f7979f88 1b62f3dbb7e0484693202b7e02974eca 53ee621754d14f7abb915b55f7979f88--1b62f3dbb7e0484693202b7e02974eca e5419bdc4e884c7fa1eecad0c116720b 1b62f3dbb7e0484693202b7e02974eca--e5419bdc4e884c7fa1eecad0c116720b ecf4e119980a4d7586624c34f53cab49 e5419bdc4e884c7fa1eecad0c116720b--ecf4e119980a4d7586624c34f53cab49 56ca20f9df14403cb846f77eb7ee66a4 ecf4e119980a4d7586624c34f53cab49--56ca20f9df14403cb846f77eb7ee66a4 0cc8401ec829415d89eafcf5c00a6fb4 56ca20f9df14403cb846f77eb7ee66a4--0cc8401ec829415d89eafcf5c00a6fb4 c5d0e97eaec449f7983196eb8e1cd707 0cc8401ec829415d89eafcf5c00a6fb4--c5d0e97eaec449f7983196eb8e1cd707 8b8bc2fb10d34779982d410c406d78e1 c5d0e97eaec449f7983196eb8e1cd707--8b8bc2fb10d34779982d410c406d78e1 364dfcebf1254ff8bd20749235893717 X 8b8bc2fb10d34779982d410c406d78e1--364dfcebf1254ff8bd20749235893717 364dfcebf1254ff8bd20749235893717--65d988f9fe6b491dbc1b391ed5d96bdc f4376c474fde478a8d34d37aa483b3fb 364dfcebf1254ff8bd20749235893717--f4376c474fde478a8d34d37aa483b3fb 7cc8d0129eaf4402be9cfb32a811c565 f4376c474fde478a8d34d37aa483b3fb--7cc8d0129eaf4402be9cfb32a811c565 d194da6f716d4946872b65cbe69f7f1e 7cc8d0129eaf4402be9cfb32a811c565--d194da6f716d4946872b65cbe69f7f1e b8f8c74728a648948555071ce4e56bc1 d194da6f716d4946872b65cbe69f7f1e--b8f8c74728a648948555071ce4e56bc1 2bff4dbdfac04ec381220d740b592a49 b8f8c74728a648948555071ce4e56bc1--2bff4dbdfac04ec381220d740b592a49 f0c8780a75404f28952bf8844e986700 2bff4dbdfac04ec381220d740b592a49--f0c8780a75404f28952bf8844e986700 c469dfd36069466b82b4c8ae11602199 f0c8780a75404f28952bf8844e986700--c469dfd36069466b82b4c8ae11602199 f965412a35c44e38ba0fd30cf734ce34 c469dfd36069466b82b4c8ae11602199--f965412a35c44e38ba0fd30cf734ce34 979019386ab549e98569a1e8ad243d03 f965412a35c44e38ba0fd30cf734ce34--979019386ab549e98569a1e8ad243d03 0ba79584bff744f8827560febdabafce 979019386ab549e98569a1e8ad243d03--0ba79584bff744f8827560febdabafce 812092b453684c7ab85b70b4e6f02dd9 0ba79584bff744f8827560febdabafce--812092b453684c7ab85b70b4e6f02dd9 127dc2819b654e35b4b84e5833ad3373 812092b453684c7ab85b70b4e6f02dd9--127dc2819b654e35b4b84e5833ad3373 17d4bbe3f84146918097236cc96e6d0b 127dc2819b654e35b4b84e5833ad3373--17d4bbe3f84146918097236cc96e6d0b 0bfea47f814a4e3382d1172ab592b931 17d4bbe3f84146918097236cc96e6d0b--0bfea47f814a4e3382d1172ab592b931 2e81ffdc4e03435abb807fe5bb2954c6 0bfea47f814a4e3382d1172ab592b931--2e81ffdc4e03435abb807fe5bb2954c6 de916ab8a60247f48c71399f6ed889a4 2e81ffdc4e03435abb807fe5bb2954c6--de916ab8a60247f48c71399f6ed889a4 0034d744f84b4523a3d23377d5df733f de916ab8a60247f48c71399f6ed889a4--0034d744f84b4523a3d23377d5df733f e2d01e56cfda4d7288553699f8d49ae2 0034d744f84b4523a3d23377d5df733f--e2d01e56cfda4d7288553699f8d49ae2 209502e561ad4861b1575a8561b415ec e2d01e56cfda4d7288553699f8d49ae2--209502e561ad4861b1575a8561b415ec 5cccfe34c5eb401eafee2673043c86f1 209502e561ad4861b1575a8561b415ec--5cccfe34c5eb401eafee2673043c86f1 5caed1ab7de84708a2b62836d9fea710 5cccfe34c5eb401eafee2673043c86f1--5caed1ab7de84708a2b62836d9fea710 89a178b3f70d47de8e30b784592a2d0f 5caed1ab7de84708a2b62836d9fea710--89a178b3f70d47de8e30b784592a2d0f 630fc0920edc47918a1381f76148a665 89a178b3f70d47de8e30b784592a2d0f--630fc0920edc47918a1381f76148a665 fcbf4f9efb064cf7ab82bd5e7f35b6ee 630fc0920edc47918a1381f76148a665--fcbf4f9efb064cf7ab82bd5e7f35b6ee eb705bcf30d14c87b19c27131b92126e fcbf4f9efb064cf7ab82bd5e7f35b6ee--eb705bcf30d14c87b19c27131b92126e e0e9591bc34743648507fbe309e10cf9 eb705bcf30d14c87b19c27131b92126e--e0e9591bc34743648507fbe309e10cf9 12e56b5b174046de8961354c088f0624 e0e9591bc34743648507fbe309e10cf9--12e56b5b174046de8961354c088f0624 0ab2c36988f84dadae5a97bb81560720 12e56b5b174046de8961354c088f0624--0ab2c36988f84dadae5a97bb81560720 01bb975d534f4252910c8c5018f1c796 0ab2c36988f84dadae5a97bb81560720--01bb975d534f4252910c8c5018f1c796 ddcb04ffcb104aedaaccb0c61258aa44 01bb975d534f4252910c8c5018f1c796--ddcb04ffcb104aedaaccb0c61258aa44 3522a7aec65e4769b5a4a16842106763 ddcb04ffcb104aedaaccb0c61258aa44--3522a7aec65e4769b5a4a16842106763 1fede6648b6e4ecdb42ee4b4833803fb 3522a7aec65e4769b5a4a16842106763--1fede6648b6e4ecdb42ee4b4833803fb 613ae5748eb940209afbc9ce095222fa 1fede6648b6e4ecdb42ee4b4833803fb--613ae5748eb940209afbc9ce095222fa c32b6ed5a4734c078fe9c6bf6a0066d6 613ae5748eb940209afbc9ce095222fa--c32b6ed5a4734c078fe9c6bf6a0066d6 824f858c45bc4580b5eda81550114490 c32b6ed5a4734c078fe9c6bf6a0066d6--824f858c45bc4580b5eda81550114490 3c430c8292af45a0b954f4b7f2df6f55 824f858c45bc4580b5eda81550114490--3c430c8292af45a0b954f4b7f2df6f55 32aeb08578bb4c30a500f9dbd5876315 3c430c8292af45a0b954f4b7f2df6f55--32aeb08578bb4c30a500f9dbd5876315 097409fe0ec142079814b21650bee20e 32aeb08578bb4c30a500f9dbd5876315--097409fe0ec142079814b21650bee20e d42357be15ea4b9789dacd5504ff44d3 097409fe0ec142079814b21650bee20e--d42357be15ea4b9789dacd5504ff44d3 8a735407c096413ca85facedac057ce0 d42357be15ea4b9789dacd5504ff44d3--8a735407c096413ca85facedac057ce0 373d6eacd8444684bf2f63e78fa65316 8a735407c096413ca85facedac057ce0--373d6eacd8444684bf2f63e78fa65316 35c0cd3c17dc4610af93861d7f8ed915 373d6eacd8444684bf2f63e78fa65316--35c0cd3c17dc4610af93861d7f8ed915 2f250af2fe6b4a438143cf4e2a9c4c19 35c0cd3c17dc4610af93861d7f8ed915--2f250af2fe6b4a438143cf4e2a9c4c19 98132460355e453b85457ddeb1dfbe11 2f250af2fe6b4a438143cf4e2a9c4c19--98132460355e453b85457ddeb1dfbe11 cd1eee8101154ec397b217f11afbc86d 98132460355e453b85457ddeb1dfbe11--cd1eee8101154ec397b217f11afbc86d cbc2e529cd2041d8b27d7860a663b748 cd1eee8101154ec397b217f11afbc86d--cbc2e529cd2041d8b27d7860a663b748 e0bcbc01f0844a3492961eb7cbbd4ab3 cbc2e529cd2041d8b27d7860a663b748--e0bcbc01f0844a3492961eb7cbbd4ab3 bde734d9804a4be88e1666ed5419075d e0bcbc01f0844a3492961eb7cbbd4ab3--bde734d9804a4be88e1666ed5419075d f2df1a60319c4caf961ac273710c96ba bde734d9804a4be88e1666ed5419075d--f2df1a60319c4caf961ac273710c96ba a243bc8577d3467187612f9ba9e04936 f2df1a60319c4caf961ac273710c96ba--a243bc8577d3467187612f9ba9e04936 396cfe29abba4f46a63b2f46d8779b58 a243bc8577d3467187612f9ba9e04936--396cfe29abba4f46a63b2f46d8779b58 2c05e2b896334491a39a49d80ac2f88c 396cfe29abba4f46a63b2f46d8779b58--2c05e2b896334491a39a49d80ac2f88c 606ef1d84dcb456db9aab6ec4d92b625 2c05e2b896334491a39a49d80ac2f88c--606ef1d84dcb456db9aab6ec4d92b625 a0f0c336bc7144e28fea6aba8fba6e9c 606ef1d84dcb456db9aab6ec4d92b625--a0f0c336bc7144e28fea6aba8fba6e9c 4c1702df36804ec6b0f1054d7c11e354 a0f0c336bc7144e28fea6aba8fba6e9c--4c1702df36804ec6b0f1054d7c11e354 aa13dc26cfbd4166b0797f5ae51dcc24 4c1702df36804ec6b0f1054d7c11e354--aa13dc26cfbd4166b0797f5ae51dcc24 b3241fbd20924c9b883fe43fc7cfd7a6 aa13dc26cfbd4166b0797f5ae51dcc24--b3241fbd20924c9b883fe43fc7cfd7a6 df72e12926ab41f6a318f2d94c47c135 b3241fbd20924c9b883fe43fc7cfd7a6--df72e12926ab41f6a318f2d94c47c135 11fef1f276b64c1697c0a9bd61a28828 df72e12926ab41f6a318f2d94c47c135--11fef1f276b64c1697c0a9bd61a28828 6cff4d8727ca48c498e193647ab0752c 11fef1f276b64c1697c0a9bd61a28828--6cff4d8727ca48c498e193647ab0752c 08da2b00fe284b92b735a70bc0abad08 6cff4d8727ca48c498e193647ab0752c--08da2b00fe284b92b735a70bc0abad08 aad03792ca134e1fbecc4df9a8b2ed8c RX(b11) 08da2b00fe284b92b735a70bc0abad08--aad03792ca134e1fbecc4df9a8b2ed8c aad03792ca134e1fbecc4df9a8b2ed8c--a94056a040624592b99e8ca2f3008d5b 5486a85050af4146aa072fdb22aee4d7 fea88860a28e4c7abee2d73938086b4b a53e7217252247fb99c93a14ce590a22--fea88860a28e4c7abee2d73938086b4b 49809377e98e4c4fbc67835a86dd04a2 3 74183e32f54e4c8d86541561536087fc X fea88860a28e4c7abee2d73938086b4b--74183e32f54e4c8d86541561536087fc 74183e32f54e4c8d86541561536087fc--6cc7201313074b058f4fb8fdd869c610 8886b11a91da4c38b00a8591badea641 74183e32f54e4c8d86541561536087fc--8886b11a91da4c38b00a8591badea641 d979a995041e4b7990b9d19d5362192e 8886b11a91da4c38b00a8591badea641--d979a995041e4b7990b9d19d5362192e fac99b081c3943f29b16190307c28ec5 d979a995041e4b7990b9d19d5362192e--fac99b081c3943f29b16190307c28ec5 a4bb756de7f2472fa4d04d438ca75cd2 fac99b081c3943f29b16190307c28ec5--a4bb756de7f2472fa4d04d438ca75cd2 282ca8cdabba42b39f2d2a15654ebc96 a4bb756de7f2472fa4d04d438ca75cd2--282ca8cdabba42b39f2d2a15654ebc96 a9a861e53e764ad286b7e391563aa3b2 282ca8cdabba42b39f2d2a15654ebc96--a9a861e53e764ad286b7e391563aa3b2 3b47ed6da883428483810db6465dc54b a9a861e53e764ad286b7e391563aa3b2--3b47ed6da883428483810db6465dc54b 6e36651258684f18bf9a6d99b6cd0b18 3b47ed6da883428483810db6465dc54b--6e36651258684f18bf9a6d99b6cd0b18 1c6f3fe302a4463ebf59b6c728931889 6e36651258684f18bf9a6d99b6cd0b18--1c6f3fe302a4463ebf59b6c728931889 26c953d5796045d29f2c0858861d87f4 1c6f3fe302a4463ebf59b6c728931889--26c953d5796045d29f2c0858861d87f4 43e65ac5a16440459a2ee4fca6d566b2 26c953d5796045d29f2c0858861d87f4--43e65ac5a16440459a2ee4fca6d566b2 9da5d96574ee46d0a237d68163d2e569 X 43e65ac5a16440459a2ee4fca6d566b2--9da5d96574ee46d0a237d68163d2e569 9da5d96574ee46d0a237d68163d2e569--3086f469a6e04bc0ba558024c06e5d27 87a44188ed71482c9babc3265e475fba 9da5d96574ee46d0a237d68163d2e569--87a44188ed71482c9babc3265e475fba 7242d8e2c97c44df974a08ef81d0f896 87a44188ed71482c9babc3265e475fba--7242d8e2c97c44df974a08ef81d0f896 a20bbcd214ac40f2aa73cd7a7bea6101 7242d8e2c97c44df974a08ef81d0f896--a20bbcd214ac40f2aa73cd7a7bea6101 31fdaf724ca54b919fd8b06cab912e6a a20bbcd214ac40f2aa73cd7a7bea6101--31fdaf724ca54b919fd8b06cab912e6a e2399383c29443ff9c9f879b20c983da 31fdaf724ca54b919fd8b06cab912e6a--e2399383c29443ff9c9f879b20c983da db6c3e489e0b49e680f68852fb256271 X e2399383c29443ff9c9f879b20c983da--db6c3e489e0b49e680f68852fb256271 db6c3e489e0b49e680f68852fb256271--3c18e7c78f0a4fa08a40105d4d4844e0 c80ed6a0163d4800a007a44bb3779fda RZ(-1.0*g0) db6c3e489e0b49e680f68852fb256271--c80ed6a0163d4800a007a44bb3779fda 924393dcc7af4547805a9d19ac58d01b X c80ed6a0163d4800a007a44bb3779fda--924393dcc7af4547805a9d19ac58d01b 924393dcc7af4547805a9d19ac58d01b--cf25988739bd424ca8303915d6cebb0c 1a869e5355c241be89cffd3c08cee2ce 924393dcc7af4547805a9d19ac58d01b--1a869e5355c241be89cffd3c08cee2ce e190cf4926734519baf085a5ca254381 1a869e5355c241be89cffd3c08cee2ce--e190cf4926734519baf085a5ca254381 18b21fc827ac480e9eb441278e5fc38d X e190cf4926734519baf085a5ca254381--18b21fc827ac480e9eb441278e5fc38d 18b21fc827ac480e9eb441278e5fc38d--ff7be409a5844d2f8baee7705850eb2b bed85418211e41d6b8d8161c83d1cb5c 18b21fc827ac480e9eb441278e5fc38d--bed85418211e41d6b8d8161c83d1cb5c bf3f38c3c03c491c8c1dc7f97a0122f3 bed85418211e41d6b8d8161c83d1cb5c--bf3f38c3c03c491c8c1dc7f97a0122f3 1fd424c0966d417aa2b4c30c43d739f4 bf3f38c3c03c491c8c1dc7f97a0122f3--1fd424c0966d417aa2b4c30c43d739f4 1518289f22364ddcafca120bbc2a092c X 1fd424c0966d417aa2b4c30c43d739f4--1518289f22364ddcafca120bbc2a092c 1518289f22364ddcafca120bbc2a092c--8e548d7394bd415293ba72b46fb56904 96e033bdb35b4a3fb90ea7a2f5582b33 1518289f22364ddcafca120bbc2a092c--96e033bdb35b4a3fb90ea7a2f5582b33 b29ec51c90484e268daf74e992152bc8 96e033bdb35b4a3fb90ea7a2f5582b33--b29ec51c90484e268daf74e992152bc8 db4b16123da94dc5812692aa4ebea178 X b29ec51c90484e268daf74e992152bc8--db4b16123da94dc5812692aa4ebea178 db4b16123da94dc5812692aa4ebea178--bff13f5e426e4e7396208b0b5a8909e0 a0ea338c7a2148d9af654fed35a5efe7 db4b16123da94dc5812692aa4ebea178--a0ea338c7a2148d9af654fed35a5efe7 7a2200e80d9042f79568c8736c5ea78b a0ea338c7a2148d9af654fed35a5efe7--7a2200e80d9042f79568c8736c5ea78b 7b4d415a99514277bfa760696aff8253 7a2200e80d9042f79568c8736c5ea78b--7b4d415a99514277bfa760696aff8253 648abe31536e4f76af22b5cdd7a72f7d 7b4d415a99514277bfa760696aff8253--648abe31536e4f76af22b5cdd7a72f7d 8f751f05a66c46ba8c2255e5fc36de86 648abe31536e4f76af22b5cdd7a72f7d--8f751f05a66c46ba8c2255e5fc36de86 17404abd2e4840eb979904d9876574de X 8f751f05a66c46ba8c2255e5fc36de86--17404abd2e4840eb979904d9876574de 17404abd2e4840eb979904d9876574de--30e629a10af94fd583f03b617f75ec02 5e70a6742f55438e85fe7804e5aa2506 17404abd2e4840eb979904d9876574de--5e70a6742f55438e85fe7804e5aa2506 983acdf8b61d4001b0e6266f2a40e5f3 5e70a6742f55438e85fe7804e5aa2506--983acdf8b61d4001b0e6266f2a40e5f3 c4e2409bb502401eb1341ba203d85cca X 983acdf8b61d4001b0e6266f2a40e5f3--c4e2409bb502401eb1341ba203d85cca c4e2409bb502401eb1341ba203d85cca--1385c2658acb41e1ab5fbf0630821e25 0786bb6550c344aa8bc19182fb7b9b9d c4e2409bb502401eb1341ba203d85cca--0786bb6550c344aa8bc19182fb7b9b9d 8aa58bebdbcf4fb5aae996e4f2fff3b8 0786bb6550c344aa8bc19182fb7b9b9d--8aa58bebdbcf4fb5aae996e4f2fff3b8 e2fceef26517451c8f859074c712fb80 8aa58bebdbcf4fb5aae996e4f2fff3b8--e2fceef26517451c8f859074c712fb80 609c50fa3ccd4619a3fbf8fb36491068 e2fceef26517451c8f859074c712fb80--609c50fa3ccd4619a3fbf8fb36491068 31b9cdeede7341e9bbbd33f763c1cc3e 609c50fa3ccd4619a3fbf8fb36491068--31b9cdeede7341e9bbbd33f763c1cc3e 4c25fa041acf4e2ba923fad8f1db287c 31b9cdeede7341e9bbbd33f763c1cc3e--4c25fa041acf4e2ba923fad8f1db287c 94dd0dc9e13b4aa4956f6a52664585ce 4c25fa041acf4e2ba923fad8f1db287c--94dd0dc9e13b4aa4956f6a52664585ce b8246352aea8460cba764d3f08258007 94dd0dc9e13b4aa4956f6a52664585ce--b8246352aea8460cba764d3f08258007 4a4e6586d8094b6b83f5d15bbb366c3f b8246352aea8460cba764d3f08258007--4a4e6586d8094b6b83f5d15bbb366c3f 06958a2eee0342b19480a079b1e95ee7 X 4a4e6586d8094b6b83f5d15bbb366c3f--06958a2eee0342b19480a079b1e95ee7 06958a2eee0342b19480a079b1e95ee7--b486b112cfa04e18ab95a055fa803e0f 4aaf063f38ac4129b0b55be9e86ccbc8 06958a2eee0342b19480a079b1e95ee7--4aaf063f38ac4129b0b55be9e86ccbc8 51f6f9be78394a648afc65b1be466910 4aaf063f38ac4129b0b55be9e86ccbc8--51f6f9be78394a648afc65b1be466910 a70aa9b98d05406ab9c6c2dcfbf054cb X 51f6f9be78394a648afc65b1be466910--a70aa9b98d05406ab9c6c2dcfbf054cb a70aa9b98d05406ab9c6c2dcfbf054cb--52cb296ba7f64f2dbc4c6df73d65eb50 99f72c4691ee492db07ac46d1ea5e93f a70aa9b98d05406ab9c6c2dcfbf054cb--99f72c4691ee492db07ac46d1ea5e93f 8a54b7b87c92483d857e985d51cdcabc 99f72c4691ee492db07ac46d1ea5e93f--8a54b7b87c92483d857e985d51cdcabc bbda96b3370b4eaca695ff5aa2b4c415 8a54b7b87c92483d857e985d51cdcabc--bbda96b3370b4eaca695ff5aa2b4c415 97a70595b8dd4b6c8cfcd8424b966ea7 bbda96b3370b4eaca695ff5aa2b4c415--97a70595b8dd4b6c8cfcd8424b966ea7 92c760a4c54c4457960f87803c289dab 97a70595b8dd4b6c8cfcd8424b966ea7--92c760a4c54c4457960f87803c289dab ec40561455ff4c97b7bd068a137b01ff 92c760a4c54c4457960f87803c289dab--ec40561455ff4c97b7bd068a137b01ff e85586e1051a4d549ce9a51bf5b3469e ec40561455ff4c97b7bd068a137b01ff--e85586e1051a4d549ce9a51bf5b3469e 379b5888d4984812ae6fe3f934e88e72 e85586e1051a4d549ce9a51bf5b3469e--379b5888d4984812ae6fe3f934e88e72 c838037df3b14852a0b4ac7d3480009e 379b5888d4984812ae6fe3f934e88e72--c838037df3b14852a0b4ac7d3480009e a1d9f9c0dcec440dbea8d88ff8e9cc60 c838037df3b14852a0b4ac7d3480009e--a1d9f9c0dcec440dbea8d88ff8e9cc60 bf3494a53e7d405d919aa4a3e933cc9a a1d9f9c0dcec440dbea8d88ff8e9cc60--bf3494a53e7d405d919aa4a3e933cc9a afda52f77f784101bfe51b0ba7925a2c X bf3494a53e7d405d919aa4a3e933cc9a--afda52f77f784101bfe51b0ba7925a2c afda52f77f784101bfe51b0ba7925a2c--3ba042b83d99482f9a2e2f550c975380 3c23f008bee84b3693d7d289c79f38ff afda52f77f784101bfe51b0ba7925a2c--3c23f008bee84b3693d7d289c79f38ff 5283f915575645359d1be4bf149a6918 X 3c23f008bee84b3693d7d289c79f38ff--5283f915575645359d1be4bf149a6918 5283f915575645359d1be4bf149a6918--7614ec1beadb465dbd367a393ed22892 308f357d3e924b5d88231048215dd389 RZ(-1.0*g0) 5283f915575645359d1be4bf149a6918--308f357d3e924b5d88231048215dd389 c9aa51bf226d447e8f25ed9cc6d92b05 X 308f357d3e924b5d88231048215dd389--c9aa51bf226d447e8f25ed9cc6d92b05 c9aa51bf226d447e8f25ed9cc6d92b05--503e41ca7fc7474a92ad2b2ef200e5d6 1fb70c1f78864dddae50f76e95226782 X c9aa51bf226d447e8f25ed9cc6d92b05--1fb70c1f78864dddae50f76e95226782 1fb70c1f78864dddae50f76e95226782--abff53e4a8ef4009b1b847049d91d68a 0e6f21f7317b46f4b3fc1f6a8c9f3a48 1fb70c1f78864dddae50f76e95226782--0e6f21f7317b46f4b3fc1f6a8c9f3a48 81b6a0e1ce6f41fd8df646cc96e0e99f 0e6f21f7317b46f4b3fc1f6a8c9f3a48--81b6a0e1ce6f41fd8df646cc96e0e99f 54fa276e2ae648d8bf48b81407432a4b 81b6a0e1ce6f41fd8df646cc96e0e99f--54fa276e2ae648d8bf48b81407432a4b b4bc2f811f464a7b8679cfb7ce234332 X 54fa276e2ae648d8bf48b81407432a4b--b4bc2f811f464a7b8679cfb7ce234332 b4bc2f811f464a7b8679cfb7ce234332--29c40ce79b654382bdf0164907e6d88d d87297a4b4be4b77a2acb73426014c2f X b4bc2f811f464a7b8679cfb7ce234332--d87297a4b4be4b77a2acb73426014c2f d87297a4b4be4b77a2acb73426014c2f--acdd047babaf44f18e56336be971cf96 aa68cadee75a4e808168b85cafbbbb9a d87297a4b4be4b77a2acb73426014c2f--aa68cadee75a4e808168b85cafbbbb9a 20cb65f21860416dab34221b6f2b414a aa68cadee75a4e808168b85cafbbbb9a--20cb65f21860416dab34221b6f2b414a 9fc93532e6eb42a7910a8bad6e5b5630 20cb65f21860416dab34221b6f2b414a--9fc93532e6eb42a7910a8bad6e5b5630 761e552668f74b0985a7d819698b680a 9fc93532e6eb42a7910a8bad6e5b5630--761e552668f74b0985a7d819698b680a 92ce1cff710147939ccc1c2810529944 761e552668f74b0985a7d819698b680a--92ce1cff710147939ccc1c2810529944 b15bb3adc6134a7f8142f896b5a8b7e8 92ce1cff710147939ccc1c2810529944--b15bb3adc6134a7f8142f896b5a8b7e8 3afe01f4f3cb4cbb8e82b8802ad70c94 b15bb3adc6134a7f8142f896b5a8b7e8--3afe01f4f3cb4cbb8e82b8802ad70c94 353085a91b67441e8e53322796b51c5d X 3afe01f4f3cb4cbb8e82b8802ad70c94--353085a91b67441e8e53322796b51c5d 353085a91b67441e8e53322796b51c5d--b6d662dabfed45feb53cad7412aed04e 445d06bf31a2471cb8437dc847be6f13 X 353085a91b67441e8e53322796b51c5d--445d06bf31a2471cb8437dc847be6f13 445d06bf31a2471cb8437dc847be6f13--b15e40ee297241fa812cc2c610cb18f9 bd3d410dc9b94ee08c219ef8fc919147 445d06bf31a2471cb8437dc847be6f13--bd3d410dc9b94ee08c219ef8fc919147 83864cdd9ee045d0abe08c82bbc3c514 bd3d410dc9b94ee08c219ef8fc919147--83864cdd9ee045d0abe08c82bbc3c514 009d51b629f94886a6f9437a3afb6067 83864cdd9ee045d0abe08c82bbc3c514--009d51b629f94886a6f9437a3afb6067 7e1826f2b75542bb88faaee1eb6d0c1b 009d51b629f94886a6f9437a3afb6067--7e1826f2b75542bb88faaee1eb6d0c1b fc458376b82b44748cfa91981c09541d 7e1826f2b75542bb88faaee1eb6d0c1b--fc458376b82b44748cfa91981c09541d ff5d11fbc1c64db0895f4fa3d8e275df fc458376b82b44748cfa91981c09541d--ff5d11fbc1c64db0895f4fa3d8e275df 45667031b65248c0a5e03e992b8a0324 ff5d11fbc1c64db0895f4fa3d8e275df--45667031b65248c0a5e03e992b8a0324 bfb868cbfdc34f50921d0ed36f9c0025 45667031b65248c0a5e03e992b8a0324--bfb868cbfdc34f50921d0ed36f9c0025 ac680b5aaf864daa803c1af366f7c4a7 bfb868cbfdc34f50921d0ed36f9c0025--ac680b5aaf864daa803c1af366f7c4a7 0f1636051aad434686f2f5662c5e4bb8 X ac680b5aaf864daa803c1af366f7c4a7--0f1636051aad434686f2f5662c5e4bb8 0f1636051aad434686f2f5662c5e4bb8--9c820a41df7349218780f12c625b9c23 7262ddf70b7c4120be5943e14d3ec68d 0f1636051aad434686f2f5662c5e4bb8--7262ddf70b7c4120be5943e14d3ec68d c61a43d40ade4102ab9dc5b2d8f7055b 7262ddf70b7c4120be5943e14d3ec68d--c61a43d40ade4102ab9dc5b2d8f7055b 6f301040a2ef4590a0bd403f53833d65 c61a43d40ade4102ab9dc5b2d8f7055b--6f301040a2ef4590a0bd403f53833d65 e3dd6651e2944a65ad89ed696b2e7619 6f301040a2ef4590a0bd403f53833d65--e3dd6651e2944a65ad89ed696b2e7619 be0301fe5e6b4ac5ac3a2cf1c6201af1 e3dd6651e2944a65ad89ed696b2e7619--be0301fe5e6b4ac5ac3a2cf1c6201af1 45e0fbf932264b24a95750a14cce241e be0301fe5e6b4ac5ac3a2cf1c6201af1--45e0fbf932264b24a95750a14cce241e 497a93084b5446309951776d468fc2c2 45e0fbf932264b24a95750a14cce241e--497a93084b5446309951776d468fc2c2 389c8357effe464cb7af1465cbe0c8fd 497a93084b5446309951776d468fc2c2--389c8357effe464cb7af1465cbe0c8fd 0fb35ac429364791849a105d6af44416 389c8357effe464cb7af1465cbe0c8fd--0fb35ac429364791849a105d6af44416 ee71b9212f4c403ab55f0abb71b3cbb5 0fb35ac429364791849a105d6af44416--ee71b9212f4c403ab55f0abb71b3cbb5 3cb00a472a1748cf8db1b818e6c789c5 ee71b9212f4c403ab55f0abb71b3cbb5--3cb00a472a1748cf8db1b818e6c789c5 143085b754264b40bb010ff909c4a057 3cb00a472a1748cf8db1b818e6c789c5--143085b754264b40bb010ff909c4a057 289357539367473bb33a21e3d9e15f3b 143085b754264b40bb010ff909c4a057--289357539367473bb33a21e3d9e15f3b 019abc52aba149df984520a82c3356fb 289357539367473bb33a21e3d9e15f3b--019abc52aba149df984520a82c3356fb 7f15698653f0446d96ce3f2e56e8005a 019abc52aba149df984520a82c3356fb--7f15698653f0446d96ce3f2e56e8005a 0010f6897b4841e6a37c33c645aae3c1 7f15698653f0446d96ce3f2e56e8005a--0010f6897b4841e6a37c33c645aae3c1 16c630354921490ea8b7e54e5d047fb4 0010f6897b4841e6a37c33c645aae3c1--16c630354921490ea8b7e54e5d047fb4 dfd927bac72d493aa915be821bdebdd2 16c630354921490ea8b7e54e5d047fb4--dfd927bac72d493aa915be821bdebdd2 02623c691484456d8aa3b3ac7657620a dfd927bac72d493aa915be821bdebdd2--02623c691484456d8aa3b3ac7657620a c3ed2583810d4c8696b430fb2d15878f 02623c691484456d8aa3b3ac7657620a--c3ed2583810d4c8696b430fb2d15878f bcad4f532c7f4672a5ca1f278040051e c3ed2583810d4c8696b430fb2d15878f--bcad4f532c7f4672a5ca1f278040051e 1573e08103534e2887cd963f3193c66d bcad4f532c7f4672a5ca1f278040051e--1573e08103534e2887cd963f3193c66d 60cd852c1b724939b96665971b6d1232 1573e08103534e2887cd963f3193c66d--60cd852c1b724939b96665971b6d1232 debdd7ce290e48c5b40089e6ecbce99b 60cd852c1b724939b96665971b6d1232--debdd7ce290e48c5b40089e6ecbce99b 2d8b2016caed4683a922424065feee6b debdd7ce290e48c5b40089e6ecbce99b--2d8b2016caed4683a922424065feee6b 03deb492d89c4e31bddfad25c5ae0961 2d8b2016caed4683a922424065feee6b--03deb492d89c4e31bddfad25c5ae0961 30a4e209171c4850b4da85bce3fc8eb3 03deb492d89c4e31bddfad25c5ae0961--30a4e209171c4850b4da85bce3fc8eb3 95b766f367a748828e7543b00cb58c47 30a4e209171c4850b4da85bce3fc8eb3--95b766f367a748828e7543b00cb58c47 43bb49300b834ee58872e9b7c10dce4e 95b766f367a748828e7543b00cb58c47--43bb49300b834ee58872e9b7c10dce4e d88a41203996486992848fed61e8c743 43bb49300b834ee58872e9b7c10dce4e--d88a41203996486992848fed61e8c743 da40c6d144c14f6eb69aa2a1498d03e3 d88a41203996486992848fed61e8c743--da40c6d144c14f6eb69aa2a1498d03e3 44545b9324354d8690eaeeea678cfc31 da40c6d144c14f6eb69aa2a1498d03e3--44545b9324354d8690eaeeea678cfc31 d8901cde50c541e2ba3da1ffb62d6a23 44545b9324354d8690eaeeea678cfc31--d8901cde50c541e2ba3da1ffb62d6a23 1fa11c1f1aae4947a8afe9d80fca5abc RX(b02) d8901cde50c541e2ba3da1ffb62d6a23--1fa11c1f1aae4947a8afe9d80fca5abc 9911745bd106440a83ad02b34ce0f409 1fa11c1f1aae4947a8afe9d80fca5abc--9911745bd106440a83ad02b34ce0f409 fd919d8ee9ff4620a7f8e44fbd1a6ece X 9911745bd106440a83ad02b34ce0f409--fd919d8ee9ff4620a7f8e44fbd1a6ece fd919d8ee9ff4620a7f8e44fbd1a6ece--185a03c0a956470a9557b7682adeb007 e2c79d982d554f56a63a8691a7a576e7 fd919d8ee9ff4620a7f8e44fbd1a6ece--e2c79d982d554f56a63a8691a7a576e7 1bb22645a6894df09571580f9c7b74ca e2c79d982d554f56a63a8691a7a576e7--1bb22645a6894df09571580f9c7b74ca a9a68b5c478244e4b8d623c123136d75 1bb22645a6894df09571580f9c7b74ca--a9a68b5c478244e4b8d623c123136d75 be32f22bc0124eafb01b897be9e47d8b a9a68b5c478244e4b8d623c123136d75--be32f22bc0124eafb01b897be9e47d8b 76ea9b6d050c4b129982f1cdb9362baa be32f22bc0124eafb01b897be9e47d8b--76ea9b6d050c4b129982f1cdb9362baa abb21a7ba2bb40119764052828bf53b5 76ea9b6d050c4b129982f1cdb9362baa--abb21a7ba2bb40119764052828bf53b5 2cbb6be6d5f1449f8f577521d4a16006 abb21a7ba2bb40119764052828bf53b5--2cbb6be6d5f1449f8f577521d4a16006 2c48d434ab344d6194430c3affa94d63 2cbb6be6d5f1449f8f577521d4a16006--2c48d434ab344d6194430c3affa94d63 82fd20cad90548b4ba5c978bd65bd40f 2c48d434ab344d6194430c3affa94d63--82fd20cad90548b4ba5c978bd65bd40f 59aedbe3d45e480bb8447c5e95b5602f 82fd20cad90548b4ba5c978bd65bd40f--59aedbe3d45e480bb8447c5e95b5602f cdf2c939fe564dfc8a0221491d4c1df2 59aedbe3d45e480bb8447c5e95b5602f--cdf2c939fe564dfc8a0221491d4c1df2 0fb89089e03c4838b7c609f631649bf9 X cdf2c939fe564dfc8a0221491d4c1df2--0fb89089e03c4838b7c609f631649bf9 0fb89089e03c4838b7c609f631649bf9--5df72fd78c5f43af9e3ba47b87724d20 4bf7be3abb1e4a7b819a8654811306a2 0fb89089e03c4838b7c609f631649bf9--4bf7be3abb1e4a7b819a8654811306a2 6a01755b280e4a15aa0d8068c1bdd49b 4bf7be3abb1e4a7b819a8654811306a2--6a01755b280e4a15aa0d8068c1bdd49b e4350ab7c1204e128b9bc96bc29b3d01 6a01755b280e4a15aa0d8068c1bdd49b--e4350ab7c1204e128b9bc96bc29b3d01 edefc4e011c542119120155ce13c63d8 e4350ab7c1204e128b9bc96bc29b3d01--edefc4e011c542119120155ce13c63d8 8192935f936d438f8a4853613c101473 edefc4e011c542119120155ce13c63d8--8192935f936d438f8a4853613c101473 69eef338fa804fe487fb3ca809822b63 X 8192935f936d438f8a4853613c101473--69eef338fa804fe487fb3ca809822b63 69eef338fa804fe487fb3ca809822b63--6b81d74070b642788fa77bae549c3ffd e2ca5d3bc1b04149b5317729eac95ed3 RZ(-1.0*g1) 69eef338fa804fe487fb3ca809822b63--e2ca5d3bc1b04149b5317729eac95ed3 733befc3dd53435fa4dfe950c5c1472b X e2ca5d3bc1b04149b5317729eac95ed3--733befc3dd53435fa4dfe950c5c1472b 733befc3dd53435fa4dfe950c5c1472b--3854f8e6a82441cfab15ab8571bba81a d717fbb2d85345ca99eaedfa0da664cf 733befc3dd53435fa4dfe950c5c1472b--d717fbb2d85345ca99eaedfa0da664cf 5ec2b28c376d43259924baa008d37f6f d717fbb2d85345ca99eaedfa0da664cf--5ec2b28c376d43259924baa008d37f6f 2c7831901f7b4432bd630e91a17dc5bc X 5ec2b28c376d43259924baa008d37f6f--2c7831901f7b4432bd630e91a17dc5bc 2c7831901f7b4432bd630e91a17dc5bc--c5be052fff5f42069f9ff42f7f567ff5 f7f3d54091f545e89f3577d2a7debdae 2c7831901f7b4432bd630e91a17dc5bc--f7f3d54091f545e89f3577d2a7debdae 032b2850e53f4d579b56f750296e5a55 f7f3d54091f545e89f3577d2a7debdae--032b2850e53f4d579b56f750296e5a55 042e82080faa45759df160ba98f7a5d0 032b2850e53f4d579b56f750296e5a55--042e82080faa45759df160ba98f7a5d0 7112ea1cf6884d77b421a97b13b04d90 X 042e82080faa45759df160ba98f7a5d0--7112ea1cf6884d77b421a97b13b04d90 7112ea1cf6884d77b421a97b13b04d90--ce287f4f82964ebd81302846cc0eb460 4b60a6ea2d344056b0a0c085217b84c4 7112ea1cf6884d77b421a97b13b04d90--4b60a6ea2d344056b0a0c085217b84c4 a36fbc118e144cf9bbb639424edc4fb1 4b60a6ea2d344056b0a0c085217b84c4--a36fbc118e144cf9bbb639424edc4fb1 42b030d9e93642bab143367becd00cc1 X a36fbc118e144cf9bbb639424edc4fb1--42b030d9e93642bab143367becd00cc1 42b030d9e93642bab143367becd00cc1--8d81f1bd911a41bfbf58c4474bc7d33d c37ffb5727c14885a94d56e9afd8fcc7 42b030d9e93642bab143367becd00cc1--c37ffb5727c14885a94d56e9afd8fcc7 782a42455a8146889de4a41fb24cc0ca c37ffb5727c14885a94d56e9afd8fcc7--782a42455a8146889de4a41fb24cc0ca e40ddf2ec5d3412584a3f101e303990d 782a42455a8146889de4a41fb24cc0ca--e40ddf2ec5d3412584a3f101e303990d c1a614d418194e13a73778338b13913c e40ddf2ec5d3412584a3f101e303990d--c1a614d418194e13a73778338b13913c 4d53630d7515466e968d0e2444f91261 c1a614d418194e13a73778338b13913c--4d53630d7515466e968d0e2444f91261 be6bf3b05bc447969b5bbed57341f113 X 4d53630d7515466e968d0e2444f91261--be6bf3b05bc447969b5bbed57341f113 be6bf3b05bc447969b5bbed57341f113--90dd876230b84360bfbad78fdaa7bc80 4d631cf5fed54026836b4c649e89eeed be6bf3b05bc447969b5bbed57341f113--4d631cf5fed54026836b4c649e89eeed 5deace21773d476494e1b5489b75210d 4d631cf5fed54026836b4c649e89eeed--5deace21773d476494e1b5489b75210d ddb7b074b29340e0a2e4ce56e6216fda X 5deace21773d476494e1b5489b75210d--ddb7b074b29340e0a2e4ce56e6216fda ddb7b074b29340e0a2e4ce56e6216fda--76df01a89d6743dd83749dffd7c17553 80205d72229a418ba3c8d87349f07fa7 ddb7b074b29340e0a2e4ce56e6216fda--80205d72229a418ba3c8d87349f07fa7 6ff4a37bc2db42ee8d8c30e6e1034b40 80205d72229a418ba3c8d87349f07fa7--6ff4a37bc2db42ee8d8c30e6e1034b40 7f2181c4a8cc4e3ba46726c8dbd8736b 6ff4a37bc2db42ee8d8c30e6e1034b40--7f2181c4a8cc4e3ba46726c8dbd8736b 5414e8e76603428985ed163e539cb788 7f2181c4a8cc4e3ba46726c8dbd8736b--5414e8e76603428985ed163e539cb788 65f0941cd2f441a0a4d639e452305b59 5414e8e76603428985ed163e539cb788--65f0941cd2f441a0a4d639e452305b59 4827539aa61644be901193bd3cca7236 65f0941cd2f441a0a4d639e452305b59--4827539aa61644be901193bd3cca7236 f71499cda0694ae0872c3890d28092ca 4827539aa61644be901193bd3cca7236--f71499cda0694ae0872c3890d28092ca 9d839980934b4f238441e5357460f565 f71499cda0694ae0872c3890d28092ca--9d839980934b4f238441e5357460f565 fdec6d7f93bd4555a5e898863dc5bf03 9d839980934b4f238441e5357460f565--fdec6d7f93bd4555a5e898863dc5bf03 cd396a2dae4f42d19096f33baf88980c X fdec6d7f93bd4555a5e898863dc5bf03--cd396a2dae4f42d19096f33baf88980c cd396a2dae4f42d19096f33baf88980c--594ce9816069476db1b77e6ab600c702 1d6f01e0303848c199f2f9b0fd5111cd cd396a2dae4f42d19096f33baf88980c--1d6f01e0303848c199f2f9b0fd5111cd 76b77a8e64db45b7af3a30ad9fa709b2 1d6f01e0303848c199f2f9b0fd5111cd--76b77a8e64db45b7af3a30ad9fa709b2 8f205e36faa045fdbfbf57c98bf046ce X 76b77a8e64db45b7af3a30ad9fa709b2--8f205e36faa045fdbfbf57c98bf046ce 8f205e36faa045fdbfbf57c98bf046ce--f3b5ceb94fc54079a586fb219ecfab4c cb15762fedb44b2781bc17ac5a3364f2 8f205e36faa045fdbfbf57c98bf046ce--cb15762fedb44b2781bc17ac5a3364f2 e2a4947b046f412396c5cf1f6890a66f cb15762fedb44b2781bc17ac5a3364f2--e2a4947b046f412396c5cf1f6890a66f 8b41ec1210314240a44451a97efc5b5a e2a4947b046f412396c5cf1f6890a66f--8b41ec1210314240a44451a97efc5b5a 17b10994564d4750a480dbca5c9e81c1 8b41ec1210314240a44451a97efc5b5a--17b10994564d4750a480dbca5c9e81c1 3a8eb558bf7740a7a8b79aa35d4ac2aa 17b10994564d4750a480dbca5c9e81c1--3a8eb558bf7740a7a8b79aa35d4ac2aa 9f0d05db199641fa947b594d8b8f3873 3a8eb558bf7740a7a8b79aa35d4ac2aa--9f0d05db199641fa947b594d8b8f3873 5b94b850cf4e409781ae4ce367c62a95 9f0d05db199641fa947b594d8b8f3873--5b94b850cf4e409781ae4ce367c62a95 4f8b099c68324dd18ce3fb654b11d895 5b94b850cf4e409781ae4ce367c62a95--4f8b099c68324dd18ce3fb654b11d895 18947dc672844c00a6224dcfd1b8d89d 4f8b099c68324dd18ce3fb654b11d895--18947dc672844c00a6224dcfd1b8d89d 4cba12d1587e4df991c39a02b2bf1e81 18947dc672844c00a6224dcfd1b8d89d--4cba12d1587e4df991c39a02b2bf1e81 012fc558dca145fba7dd681c4fa7ccea 4cba12d1587e4df991c39a02b2bf1e81--012fc558dca145fba7dd681c4fa7ccea 79c0da581f4b4e659214a1958e8be810 X 012fc558dca145fba7dd681c4fa7ccea--79c0da581f4b4e659214a1958e8be810 79c0da581f4b4e659214a1958e8be810--8b8bc2fb10d34779982d410c406d78e1 3fe0bb17126f439ab3b5e34de52363d9 79c0da581f4b4e659214a1958e8be810--3fe0bb17126f439ab3b5e34de52363d9 c80b61702fdc49d3a0522f13d319d16a X 3fe0bb17126f439ab3b5e34de52363d9--c80b61702fdc49d3a0522f13d319d16a c80b61702fdc49d3a0522f13d319d16a--f4376c474fde478a8d34d37aa483b3fb 7e5e3522a2b749f4b6165ea45af55dc4 RZ(-1.0*g1) c80b61702fdc49d3a0522f13d319d16a--7e5e3522a2b749f4b6165ea45af55dc4 da297f405d2f40adbde0cde45048b476 X 7e5e3522a2b749f4b6165ea45af55dc4--da297f405d2f40adbde0cde45048b476 da297f405d2f40adbde0cde45048b476--d194da6f716d4946872b65cbe69f7f1e 8597d01bfdc443d58862174ced624449 X da297f405d2f40adbde0cde45048b476--8597d01bfdc443d58862174ced624449 8597d01bfdc443d58862174ced624449--b8f8c74728a648948555071ce4e56bc1 c83c085699df458b82fbc30bdb0ee9d0 8597d01bfdc443d58862174ced624449--c83c085699df458b82fbc30bdb0ee9d0 b4f815c76081423c9c0b14ab861a4cd9 c83c085699df458b82fbc30bdb0ee9d0--b4f815c76081423c9c0b14ab861a4cd9 a6b737195e8c4586b53e10b2482861a1 b4f815c76081423c9c0b14ab861a4cd9--a6b737195e8c4586b53e10b2482861a1 7963b5c946154045819f2b22dabe61f5 X a6b737195e8c4586b53e10b2482861a1--7963b5c946154045819f2b22dabe61f5 7963b5c946154045819f2b22dabe61f5--f965412a35c44e38ba0fd30cf734ce34 72fcd6b5b87b424d9ebe07cf931696c0 X 7963b5c946154045819f2b22dabe61f5--72fcd6b5b87b424d9ebe07cf931696c0 72fcd6b5b87b424d9ebe07cf931696c0--979019386ab549e98569a1e8ad243d03 839815e8911c42ceb20561d448c59a43 72fcd6b5b87b424d9ebe07cf931696c0--839815e8911c42ceb20561d448c59a43 4970db94c70c46799b61191a92f8c1cb 839815e8911c42ceb20561d448c59a43--4970db94c70c46799b61191a92f8c1cb 885bf8812f654946bd2cd8da3d6a20b3 4970db94c70c46799b61191a92f8c1cb--885bf8812f654946bd2cd8da3d6a20b3 daaa2494b290449da48b70d3f8e23d2f 885bf8812f654946bd2cd8da3d6a20b3--daaa2494b290449da48b70d3f8e23d2f 52013e70147d49d6b73b90ab422e1988 daaa2494b290449da48b70d3f8e23d2f--52013e70147d49d6b73b90ab422e1988 12fb34e8a154452ea774c8398c117440 52013e70147d49d6b73b90ab422e1988--12fb34e8a154452ea774c8398c117440 0a9700bf3d954037a16731f02e75ac75 12fb34e8a154452ea774c8398c117440--0a9700bf3d954037a16731f02e75ac75 c81a399277a74c41bca8d25d8dfdd59f X 0a9700bf3d954037a16731f02e75ac75--c81a399277a74c41bca8d25d8dfdd59f c81a399277a74c41bca8d25d8dfdd59f--0034d744f84b4523a3d23377d5df733f 1e469af5aece49bfb45435e3019839f5 X c81a399277a74c41bca8d25d8dfdd59f--1e469af5aece49bfb45435e3019839f5 1e469af5aece49bfb45435e3019839f5--e2d01e56cfda4d7288553699f8d49ae2 0675755234ab4e5c914feea9c530fdb0 1e469af5aece49bfb45435e3019839f5--0675755234ab4e5c914feea9c530fdb0 41f699c2e92448129270a5458541cadc 0675755234ab4e5c914feea9c530fdb0--41f699c2e92448129270a5458541cadc 9dd776723a7848869d4268748ee2500a 41f699c2e92448129270a5458541cadc--9dd776723a7848869d4268748ee2500a 3a810013f0c9442b952a218c5d20b292 9dd776723a7848869d4268748ee2500a--3a810013f0c9442b952a218c5d20b292 07079cb6eae344c3b0e9332aa392471a 3a810013f0c9442b952a218c5d20b292--07079cb6eae344c3b0e9332aa392471a 908489d011cc47ed9f629b4054c5f6ab 07079cb6eae344c3b0e9332aa392471a--908489d011cc47ed9f629b4054c5f6ab c32be11689a040c194fbbaf041c9a6c1 908489d011cc47ed9f629b4054c5f6ab--c32be11689a040c194fbbaf041c9a6c1 d06862a8c1b248ad8ff8caba5dc2ca0d c32be11689a040c194fbbaf041c9a6c1--d06862a8c1b248ad8ff8caba5dc2ca0d 8884c173ffaf477ea511f03e75420bd7 d06862a8c1b248ad8ff8caba5dc2ca0d--8884c173ffaf477ea511f03e75420bd7 3d1514e1fe9b427ab85ed9e20b8c2c04 X 8884c173ffaf477ea511f03e75420bd7--3d1514e1fe9b427ab85ed9e20b8c2c04 3d1514e1fe9b427ab85ed9e20b8c2c04--0ab2c36988f84dadae5a97bb81560720 a759ed71d6334b5baae66e256b279cc5 3d1514e1fe9b427ab85ed9e20b8c2c04--a759ed71d6334b5baae66e256b279cc5 61ee4d784d444bc18f842d4b6c9bf76d a759ed71d6334b5baae66e256b279cc5--61ee4d784d444bc18f842d4b6c9bf76d 0ad7aa5ba46f45dba750d4d59ddb3830 61ee4d784d444bc18f842d4b6c9bf76d--0ad7aa5ba46f45dba750d4d59ddb3830 19ee98a379c945dcaa27216ea3282bcb 0ad7aa5ba46f45dba750d4d59ddb3830--19ee98a379c945dcaa27216ea3282bcb b2e881d88f5e410ba8f37d0b9318f188 19ee98a379c945dcaa27216ea3282bcb--b2e881d88f5e410ba8f37d0b9318f188 c7f9f2c09f914e40be468aadb748e79d b2e881d88f5e410ba8f37d0b9318f188--c7f9f2c09f914e40be468aadb748e79d 6b807c293e9448c1a4e64140785ad704 c7f9f2c09f914e40be468aadb748e79d--6b807c293e9448c1a4e64140785ad704 7fdf2b75496c4827a58b76400ca83747 6b807c293e9448c1a4e64140785ad704--7fdf2b75496c4827a58b76400ca83747 71d540016812494eae88d1a99a82b45a 7fdf2b75496c4827a58b76400ca83747--71d540016812494eae88d1a99a82b45a de333c69f8744e5592b50388db5f1dd3 71d540016812494eae88d1a99a82b45a--de333c69f8744e5592b50388db5f1dd3 717d56ca23914de6a99d740a7d8bfd1a de333c69f8744e5592b50388db5f1dd3--717d56ca23914de6a99d740a7d8bfd1a 044b905bcab444f1bf9fd92a475a6b33 717d56ca23914de6a99d740a7d8bfd1a--044b905bcab444f1bf9fd92a475a6b33 b12dbcfa6497485496dea6741c280023 044b905bcab444f1bf9fd92a475a6b33--b12dbcfa6497485496dea6741c280023 d745d8aba2434da19068b2b33a524a0c b12dbcfa6497485496dea6741c280023--d745d8aba2434da19068b2b33a524a0c d5d673cb492740d5944d39667dd91e7b d745d8aba2434da19068b2b33a524a0c--d5d673cb492740d5944d39667dd91e7b f7c472fe528a4b7290dc92d7179fcbea d5d673cb492740d5944d39667dd91e7b--f7c472fe528a4b7290dc92d7179fcbea 9928f3df7d644955949ffdd67f4ad8aa f7c472fe528a4b7290dc92d7179fcbea--9928f3df7d644955949ffdd67f4ad8aa ad792e8aacd84212a05e7775b18e0be0 9928f3df7d644955949ffdd67f4ad8aa--ad792e8aacd84212a05e7775b18e0be0 2aacf98fae914de48649fd30a11d92c8 ad792e8aacd84212a05e7775b18e0be0--2aacf98fae914de48649fd30a11d92c8 87037cd7280d4b5d9a1acc5c3af6c759 2aacf98fae914de48649fd30a11d92c8--87037cd7280d4b5d9a1acc5c3af6c759 9dc15c0aa77a457d8d2b658d6082d583 87037cd7280d4b5d9a1acc5c3af6c759--9dc15c0aa77a457d8d2b658d6082d583 a1dfbe7a24ca4740bb1d980fd55bde5a 9dc15c0aa77a457d8d2b658d6082d583--a1dfbe7a24ca4740bb1d980fd55bde5a 8ba263f29df6480687a8d47c9beeefe2 a1dfbe7a24ca4740bb1d980fd55bde5a--8ba263f29df6480687a8d47c9beeefe2 4c52b50aaa824b0a88e7508020a4d561 8ba263f29df6480687a8d47c9beeefe2--4c52b50aaa824b0a88e7508020a4d561 6d7542640d04428996703a1791ebc9e1 4c52b50aaa824b0a88e7508020a4d561--6d7542640d04428996703a1791ebc9e1 2d09f416e12b43b29a99960e64a99075 6d7542640d04428996703a1791ebc9e1--2d09f416e12b43b29a99960e64a99075 e041eafdd7d440b08c65964e247cee1c 2d09f416e12b43b29a99960e64a99075--e041eafdd7d440b08c65964e247cee1c 1eaff0e0050f493c88b8f5df93299c80 e041eafdd7d440b08c65964e247cee1c--1eaff0e0050f493c88b8f5df93299c80 532007bea5b64188b04ed89a7026069e 1eaff0e0050f493c88b8f5df93299c80--532007bea5b64188b04ed89a7026069e 9b032d8e575d42a28e47f511a688064e 532007bea5b64188b04ed89a7026069e--9b032d8e575d42a28e47f511a688064e 69b843251dd545ac9b53f6f688883351 9b032d8e575d42a28e47f511a688064e--69b843251dd545ac9b53f6f688883351 497d1750dcb241839f987f1f5bc5ca75 69b843251dd545ac9b53f6f688883351--497d1750dcb241839f987f1f5bc5ca75 a9c00fae4cc84ff9885f46635f2e7351 497d1750dcb241839f987f1f5bc5ca75--a9c00fae4cc84ff9885f46635f2e7351 377ff07d4aef4ec0b53869a755b7458d RX(b12) a9c00fae4cc84ff9885f46635f2e7351--377ff07d4aef4ec0b53869a755b7458d 377ff07d4aef4ec0b53869a755b7458d--5486a85050af4146aa072fdb22aee4d7 fd196c6052f542eca09232f41fcd6d8c 904170ad211e46b0a9c666d1e3b790c3 49809377e98e4c4fbc67835a86dd04a2--904170ad211e46b0a9c666d1e3b790c3 b216b5c5f0e7433ab8290e715e3dd6b3 4 6249f067a3234455b6d44a5cb08f605a 904170ad211e46b0a9c666d1e3b790c3--6249f067a3234455b6d44a5cb08f605a 358ae53ec1c9402d802c42711397d64e X 6249f067a3234455b6d44a5cb08f605a--358ae53ec1c9402d802c42711397d64e 358ae53ec1c9402d802c42711397d64e--8886b11a91da4c38b00a8591badea641 74e5f08f916048f496dd86fbbec26d56 358ae53ec1c9402d802c42711397d64e--74e5f08f916048f496dd86fbbec26d56 6db35999cedd4d9191de74478e16b358 74e5f08f916048f496dd86fbbec26d56--6db35999cedd4d9191de74478e16b358 4dee12dcffc44216ab6ebb0db55402de 6db35999cedd4d9191de74478e16b358--4dee12dcffc44216ab6ebb0db55402de fa526d7c55464d6a9585559ee619fb89 4dee12dcffc44216ab6ebb0db55402de--fa526d7c55464d6a9585559ee619fb89 44fd6a524535490eb0293048bb64766f fa526d7c55464d6a9585559ee619fb89--44fd6a524535490eb0293048bb64766f 4c6c6126c71d4d4b9978a38a7554328e 44fd6a524535490eb0293048bb64766f--4c6c6126c71d4d4b9978a38a7554328e 04bb8900a3c84840b4b14cea61f313a1 4c6c6126c71d4d4b9978a38a7554328e--04bb8900a3c84840b4b14cea61f313a1 dbe73bd8c5524247895b5997970ec11a 04bb8900a3c84840b4b14cea61f313a1--dbe73bd8c5524247895b5997970ec11a 04d0216b9e734c1cb1d78c491cbf08c0 dbe73bd8c5524247895b5997970ec11a--04d0216b9e734c1cb1d78c491cbf08c0 1b0c2055154149c4b1201c1fe2fafefb X 04d0216b9e734c1cb1d78c491cbf08c0--1b0c2055154149c4b1201c1fe2fafefb 1b0c2055154149c4b1201c1fe2fafefb--43e65ac5a16440459a2ee4fca6d566b2 ac683774c34648e5ab51b5ede9c6ffd1 1b0c2055154149c4b1201c1fe2fafefb--ac683774c34648e5ab51b5ede9c6ffd1 8ef5abf9570a434c9902eef351273697 ac683774c34648e5ab51b5ede9c6ffd1--8ef5abf9570a434c9902eef351273697 c9e2051054db4d3e82f33ef794c36efe 8ef5abf9570a434c9902eef351273697--c9e2051054db4d3e82f33ef794c36efe 41f49633bb094c3fa2b21e0a9d78becc c9e2051054db4d3e82f33ef794c36efe--41f49633bb094c3fa2b21e0a9d78becc 572bd18a450f4dc38f079f74f73a9604 41f49633bb094c3fa2b21e0a9d78becc--572bd18a450f4dc38f079f74f73a9604 08ce09309bc942ca80117c495efcf7ea 572bd18a450f4dc38f079f74f73a9604--08ce09309bc942ca80117c495efcf7ea c14a06c5aa404ce8b57375bc39e4ee0f 08ce09309bc942ca80117c495efcf7ea--c14a06c5aa404ce8b57375bc39e4ee0f e555a5f1e99147ecab404f919834654a c14a06c5aa404ce8b57375bc39e4ee0f--e555a5f1e99147ecab404f919834654a 631ce572461147f7a522b5c59345187d e555a5f1e99147ecab404f919834654a--631ce572461147f7a522b5c59345187d 7fed721998dd49518fad7d0d0cc1fe5d 631ce572461147f7a522b5c59345187d--7fed721998dd49518fad7d0d0cc1fe5d 6f3907ef9e184911a2e80127e05c465c 7fed721998dd49518fad7d0d0cc1fe5d--6f3907ef9e184911a2e80127e05c465c 1413736dcf8e4739ab7cc2587a5ac7f5 6f3907ef9e184911a2e80127e05c465c--1413736dcf8e4739ab7cc2587a5ac7f5 bb9c80b5d5b240ac891843b2bd971d4d X 1413736dcf8e4739ab7cc2587a5ac7f5--bb9c80b5d5b240ac891843b2bd971d4d bb9c80b5d5b240ac891843b2bd971d4d--bed85418211e41d6b8d8161c83d1cb5c 5576facbd5794d91a7c9c0a9a6d4dc73 RZ(-1.0*g0) bb9c80b5d5b240ac891843b2bd971d4d--5576facbd5794d91a7c9c0a9a6d4dc73 7bebe4c3f1104e73b4369149ac77fb23 X 5576facbd5794d91a7c9c0a9a6d4dc73--7bebe4c3f1104e73b4369149ac77fb23 7bebe4c3f1104e73b4369149ac77fb23--1fd424c0966d417aa2b4c30c43d739f4 a58a71dd72e646578f0f8020385e1dc8 7bebe4c3f1104e73b4369149ac77fb23--a58a71dd72e646578f0f8020385e1dc8 581df2b58c9f45f6a5e5ac660d495c26 a58a71dd72e646578f0f8020385e1dc8--581df2b58c9f45f6a5e5ac660d495c26 49a0f9dd528f4cb5842be94780d74dbd 581df2b58c9f45f6a5e5ac660d495c26--49a0f9dd528f4cb5842be94780d74dbd cb51510eeae54acfb4ad03552d0edebb 49a0f9dd528f4cb5842be94780d74dbd--cb51510eeae54acfb4ad03552d0edebb 832a69b63eb74d669d24fa628189712c X cb51510eeae54acfb4ad03552d0edebb--832a69b63eb74d669d24fa628189712c 832a69b63eb74d669d24fa628189712c--a0ea338c7a2148d9af654fed35a5efe7 28aec6a9b6a440f79bb30f5dbd0ad3ab 832a69b63eb74d669d24fa628189712c--28aec6a9b6a440f79bb30f5dbd0ad3ab fec564c9e6ab40cb99af4fab480bbe55 28aec6a9b6a440f79bb30f5dbd0ad3ab--fec564c9e6ab40cb99af4fab480bbe55 70a483a884bc431fb03014814f3bfa72 fec564c9e6ab40cb99af4fab480bbe55--70a483a884bc431fb03014814f3bfa72 30d9e6642c7b4b0f9bc84427d04f7402 X 70a483a884bc431fb03014814f3bfa72--30d9e6642c7b4b0f9bc84427d04f7402 30d9e6642c7b4b0f9bc84427d04f7402--8f751f05a66c46ba8c2255e5fc36de86 13beca0115da47ed8d3e8695ac798747 30d9e6642c7b4b0f9bc84427d04f7402--13beca0115da47ed8d3e8695ac798747 8964d99ca3c746538ffba1895945efe8 13beca0115da47ed8d3e8695ac798747--8964d99ca3c746538ffba1895945efe8 fd1213dcb3d1462cb4dff78b232ee64d 8964d99ca3c746538ffba1895945efe8--fd1213dcb3d1462cb4dff78b232ee64d 3705ed4c39464e74b4cf05ffabdf82b9 fd1213dcb3d1462cb4dff78b232ee64d--3705ed4c39464e74b4cf05ffabdf82b9 cd84e6d3834d479bad3b39f353654322 X 3705ed4c39464e74b4cf05ffabdf82b9--cd84e6d3834d479bad3b39f353654322 cd84e6d3834d479bad3b39f353654322--0786bb6550c344aa8bc19182fb7b9b9d 94a8965776b94e19983d4bcedccd4977 cd84e6d3834d479bad3b39f353654322--94a8965776b94e19983d4bcedccd4977 b2ab07ab6f83448d93e59bf91887178e 94a8965776b94e19983d4bcedccd4977--b2ab07ab6f83448d93e59bf91887178e 520323ba947645b2a4201b3316426963 b2ab07ab6f83448d93e59bf91887178e--520323ba947645b2a4201b3316426963 918e5efa3e444da484ff4caf8cc15bd6 520323ba947645b2a4201b3316426963--918e5efa3e444da484ff4caf8cc15bd6 ef450248843e4be9964eeb8dd93b71e9 918e5efa3e444da484ff4caf8cc15bd6--ef450248843e4be9964eeb8dd93b71e9 b8a6c4c0bacc44189f49e177f9b6fc2b ef450248843e4be9964eeb8dd93b71e9--b8a6c4c0bacc44189f49e177f9b6fc2b 21af2bf51189453c8d703f8af566f4df b8a6c4c0bacc44189f49e177f9b6fc2b--21af2bf51189453c8d703f8af566f4df 9492c4f5ca004738a7d8cfe24a986fbd X 21af2bf51189453c8d703f8af566f4df--9492c4f5ca004738a7d8cfe24a986fbd 9492c4f5ca004738a7d8cfe24a986fbd--4a4e6586d8094b6b83f5d15bbb366c3f 936e56de476840919c8e4a85613172f3 9492c4f5ca004738a7d8cfe24a986fbd--936e56de476840919c8e4a85613172f3 35a4e2d7feca4d8bb0b39408e537bb31 936e56de476840919c8e4a85613172f3--35a4e2d7feca4d8bb0b39408e537bb31 e538ad4705bd466abc6002ef1ebf6f1d 35a4e2d7feca4d8bb0b39408e537bb31--e538ad4705bd466abc6002ef1ebf6f1d a3493644671c4a9d8a1100c242ae368b e538ad4705bd466abc6002ef1ebf6f1d--a3493644671c4a9d8a1100c242ae368b b6ee2a87c2204f0786e484276fd51382 X a3493644671c4a9d8a1100c242ae368b--b6ee2a87c2204f0786e484276fd51382 b6ee2a87c2204f0786e484276fd51382--99f72c4691ee492db07ac46d1ea5e93f 0cfad0a744194e3792ef3c1d978130b1 b6ee2a87c2204f0786e484276fd51382--0cfad0a744194e3792ef3c1d978130b1 d2a2dfa0ab38400591b731671e0e4967 0cfad0a744194e3792ef3c1d978130b1--d2a2dfa0ab38400591b731671e0e4967 99b17706344443c2829f58803152f79d d2a2dfa0ab38400591b731671e0e4967--99b17706344443c2829f58803152f79d 14905e6c83fc4af0b2483e12d897c2e8 99b17706344443c2829f58803152f79d--14905e6c83fc4af0b2483e12d897c2e8 3ac7b919d7cd41af863af9296d50216c 14905e6c83fc4af0b2483e12d897c2e8--3ac7b919d7cd41af863af9296d50216c d2bca77746914d94a2598bc16b545ff6 3ac7b919d7cd41af863af9296d50216c--d2bca77746914d94a2598bc16b545ff6 c6b51c1370584d3e9e534296eaf31837 d2bca77746914d94a2598bc16b545ff6--c6b51c1370584d3e9e534296eaf31837 dc78bfc2e8ec4b22ac455f15fecb2ac8 c6b51c1370584d3e9e534296eaf31837--dc78bfc2e8ec4b22ac455f15fecb2ac8 d58642d0fd8d41c6a9ea9fc9af6db6ee dc78bfc2e8ec4b22ac455f15fecb2ac8--d58642d0fd8d41c6a9ea9fc9af6db6ee ed837645c23349af973a95ce40c1123b X d58642d0fd8d41c6a9ea9fc9af6db6ee--ed837645c23349af973a95ce40c1123b ed837645c23349af973a95ce40c1123b--bf3494a53e7d405d919aa4a3e933cc9a 6c2a80d35ce34610b5af0592b47bdf0e ed837645c23349af973a95ce40c1123b--6c2a80d35ce34610b5af0592b47bdf0e 7800e4282323422a86638c7e9093f7cf 6c2a80d35ce34610b5af0592b47bdf0e--7800e4282323422a86638c7e9093f7cf 5971674c41d74b5da9cc72286523a214 7800e4282323422a86638c7e9093f7cf--5971674c41d74b5da9cc72286523a214 329ebff532b1445b9398dcf9cb6a6e24 5971674c41d74b5da9cc72286523a214--329ebff532b1445b9398dcf9cb6a6e24 da3bc5af5f26452caf46c8b8bbb8e93a 329ebff532b1445b9398dcf9cb6a6e24--da3bc5af5f26452caf46c8b8bbb8e93a 479c2255def241199307f7b296c851e3 da3bc5af5f26452caf46c8b8bbb8e93a--479c2255def241199307f7b296c851e3 28e87d60f4144402a722b45978050c3d X 479c2255def241199307f7b296c851e3--28e87d60f4144402a722b45978050c3d 28e87d60f4144402a722b45978050c3d--0e6f21f7317b46f4b3fc1f6a8c9f3a48 1c220fc99b814346ae27ea738b02c38a RZ(-1.0*g0) 28e87d60f4144402a722b45978050c3d--1c220fc99b814346ae27ea738b02c38a d99e8d66608f430a8359e501ca15199a X 1c220fc99b814346ae27ea738b02c38a--d99e8d66608f430a8359e501ca15199a d99e8d66608f430a8359e501ca15199a--54fa276e2ae648d8bf48b81407432a4b 7826c1451a844928844525523eb63101 d99e8d66608f430a8359e501ca15199a--7826c1451a844928844525523eb63101 2654cbc7a6bd4f03bc4c62a88b340690 7826c1451a844928844525523eb63101--2654cbc7a6bd4f03bc4c62a88b340690 40f508d099df40d487f2121834b7ab82 X 2654cbc7a6bd4f03bc4c62a88b340690--40f508d099df40d487f2121834b7ab82 40f508d099df40d487f2121834b7ab82--aa68cadee75a4e808168b85cafbbbb9a e578cd9fe4eb449188421ea3ab91d9c6 40f508d099df40d487f2121834b7ab82--e578cd9fe4eb449188421ea3ab91d9c6 b739005092ca4bc7bca2974b1365be6e e578cd9fe4eb449188421ea3ab91d9c6--b739005092ca4bc7bca2974b1365be6e f85c8903df4245aeb960a1aa5f2d73a9 b739005092ca4bc7bca2974b1365be6e--f85c8903df4245aeb960a1aa5f2d73a9 0bde34b241854c21898664eecccc4650 f85c8903df4245aeb960a1aa5f2d73a9--0bde34b241854c21898664eecccc4650 b10167d33a2340a8ba2a6418ba8dd346 0bde34b241854c21898664eecccc4650--b10167d33a2340a8ba2a6418ba8dd346 3c6f063af58742d78a14d0fddcb5a157 X b10167d33a2340a8ba2a6418ba8dd346--3c6f063af58742d78a14d0fddcb5a157 3c6f063af58742d78a14d0fddcb5a157--3afe01f4f3cb4cbb8e82b8802ad70c94 90dd83e632df43759c7db30d522e1c19 3c6f063af58742d78a14d0fddcb5a157--90dd83e632df43759c7db30d522e1c19 7be549094dae4a77ad1aecce105834bb 90dd83e632df43759c7db30d522e1c19--7be549094dae4a77ad1aecce105834bb ec0592b3a61643618229c1d8845d02fd X 7be549094dae4a77ad1aecce105834bb--ec0592b3a61643618229c1d8845d02fd ec0592b3a61643618229c1d8845d02fd--bd3d410dc9b94ee08c219ef8fc919147 a07ff7de71c34b0c851bc230ebd7e7f6 ec0592b3a61643618229c1d8845d02fd--a07ff7de71c34b0c851bc230ebd7e7f6 a32d922f7bbd44ffa7cf4f526f27203a a07ff7de71c34b0c851bc230ebd7e7f6--a32d922f7bbd44ffa7cf4f526f27203a 1c0ba8a08a944efdb2eb16e9c81638e0 a32d922f7bbd44ffa7cf4f526f27203a--1c0ba8a08a944efdb2eb16e9c81638e0 39ad99ae3c6b4111874f469c564f6e8b 1c0ba8a08a944efdb2eb16e9c81638e0--39ad99ae3c6b4111874f469c564f6e8b 3eee4f4513d24ff4832b213333de12b1 39ad99ae3c6b4111874f469c564f6e8b--3eee4f4513d24ff4832b213333de12b1 41423722406f4eb9af557abee3bc05c1 3eee4f4513d24ff4832b213333de12b1--41423722406f4eb9af557abee3bc05c1 8b1c595e067744ccbb8eb6c63b76a23c 41423722406f4eb9af557abee3bc05c1--8b1c595e067744ccbb8eb6c63b76a23c 397df1397be44de4a5010a99be32fb27 X 8b1c595e067744ccbb8eb6c63b76a23c--397df1397be44de4a5010a99be32fb27 397df1397be44de4a5010a99be32fb27--ac680b5aaf864daa803c1af366f7c4a7 32a6aa7c3bda4a9e8521a0ad1720434e 397df1397be44de4a5010a99be32fb27--32a6aa7c3bda4a9e8521a0ad1720434e 0aea5f49018042348a40f11ef4dcada5 X 32a6aa7c3bda4a9e8521a0ad1720434e--0aea5f49018042348a40f11ef4dcada5 0aea5f49018042348a40f11ef4dcada5--7262ddf70b7c4120be5943e14d3ec68d c2381d419ba64726951a6cb2107d4649 0aea5f49018042348a40f11ef4dcada5--c2381d419ba64726951a6cb2107d4649 01722f97ebe640ce85375287f52996a6 c2381d419ba64726951a6cb2107d4649--01722f97ebe640ce85375287f52996a6 7645a6e6cd0442e9a6bf7655b274a0b5 01722f97ebe640ce85375287f52996a6--7645a6e6cd0442e9a6bf7655b274a0b5 f75a2b6a39ca43449bf1112384fdd655 X 7645a6e6cd0442e9a6bf7655b274a0b5--f75a2b6a39ca43449bf1112384fdd655 f75a2b6a39ca43449bf1112384fdd655--be0301fe5e6b4ac5ac3a2cf1c6201af1 95f7b6d230d645e191c0afff001638e8 X f75a2b6a39ca43449bf1112384fdd655--95f7b6d230d645e191c0afff001638e8 95f7b6d230d645e191c0afff001638e8--45e0fbf932264b24a95750a14cce241e c8c2a15c0a7a46e98d6917754ed7c323 95f7b6d230d645e191c0afff001638e8--c8c2a15c0a7a46e98d6917754ed7c323 a95a2c46f67b4c24a8a9723ea36f80b5 c8c2a15c0a7a46e98d6917754ed7c323--a95a2c46f67b4c24a8a9723ea36f80b5 ca4a791897b7428ab2f1669200018f77 a95a2c46f67b4c24a8a9723ea36f80b5--ca4a791897b7428ab2f1669200018f77 6f0114c8e41e48619711891d1407cd53 ca4a791897b7428ab2f1669200018f77--6f0114c8e41e48619711891d1407cd53 32c9e6dfd39f4d80932569bd72ad02cf 6f0114c8e41e48619711891d1407cd53--32c9e6dfd39f4d80932569bd72ad02cf bbd76963dcf540f1bc094500ab2f9bfe 32c9e6dfd39f4d80932569bd72ad02cf--bbd76963dcf540f1bc094500ab2f9bfe 03298bf2757348799d04eedce4e16b2c bbd76963dcf540f1bc094500ab2f9bfe--03298bf2757348799d04eedce4e16b2c e627028185f9453cae41026a83360789 03298bf2757348799d04eedce4e16b2c--e627028185f9453cae41026a83360789 397ca12e60334d9aba0f804af4679afd e627028185f9453cae41026a83360789--397ca12e60334d9aba0f804af4679afd 29632546a7394074b195aac590445261 X 397ca12e60334d9aba0f804af4679afd--29632546a7394074b195aac590445261 29632546a7394074b195aac590445261--0010f6897b4841e6a37c33c645aae3c1 1f3e0a5b379240daa0f456310848d7b3 29632546a7394074b195aac590445261--1f3e0a5b379240daa0f456310848d7b3 2d1c80b9b2cf4bd0bee4d63deffb350e 1f3e0a5b379240daa0f456310848d7b3--2d1c80b9b2cf4bd0bee4d63deffb350e d222731c0cbf4f89b6d7af5836de693e 2d1c80b9b2cf4bd0bee4d63deffb350e--d222731c0cbf4f89b6d7af5836de693e 29d5f1bc9e8c47e8ae5474691795722b d222731c0cbf4f89b6d7af5836de693e--29d5f1bc9e8c47e8ae5474691795722b e27d13bab0de480e89ad7041192cdac1 29d5f1bc9e8c47e8ae5474691795722b--e27d13bab0de480e89ad7041192cdac1 08cf19cabb1d4703a7426ff1f62eb335 e27d13bab0de480e89ad7041192cdac1--08cf19cabb1d4703a7426ff1f62eb335 6196a0b6c2ef44cbaa961be37454d171 08cf19cabb1d4703a7426ff1f62eb335--6196a0b6c2ef44cbaa961be37454d171 ed3f09c0497649539a82f0c0f0e0e858 6196a0b6c2ef44cbaa961be37454d171--ed3f09c0497649539a82f0c0f0e0e858 132659b77f7b4d0eaafe2f5c4752faac ed3f09c0497649539a82f0c0f0e0e858--132659b77f7b4d0eaafe2f5c4752faac 07e30b6db30144efbc37b5c70fe26275 132659b77f7b4d0eaafe2f5c4752faac--07e30b6db30144efbc37b5c70fe26275 eda208ac04534f1fb405d059ad3fbe10 07e30b6db30144efbc37b5c70fe26275--eda208ac04534f1fb405d059ad3fbe10 c07302a58e2f45d296689ec35ba83323 eda208ac04534f1fb405d059ad3fbe10--c07302a58e2f45d296689ec35ba83323 9f2c51c95e4c4a03a4d573b7971b49c2 c07302a58e2f45d296689ec35ba83323--9f2c51c95e4c4a03a4d573b7971b49c2 fbcd1376cf474891ab3c992e2e4fddcd 9f2c51c95e4c4a03a4d573b7971b49c2--fbcd1376cf474891ab3c992e2e4fddcd d0adceb4b7c84a389cbfdcdfc75afb9a fbcd1376cf474891ab3c992e2e4fddcd--d0adceb4b7c84a389cbfdcdfc75afb9a 9d5ab35fde5546678ec2c0b1c34f82cc d0adceb4b7c84a389cbfdcdfc75afb9a--9d5ab35fde5546678ec2c0b1c34f82cc 00ae95cb65164f9bbf90139fab132531 9d5ab35fde5546678ec2c0b1c34f82cc--00ae95cb65164f9bbf90139fab132531 a50fc416ae164d968fb10b8e27c8222a RX(b03) 00ae95cb65164f9bbf90139fab132531--a50fc416ae164d968fb10b8e27c8222a 90df7d004a864878b6568085d01b558a a50fc416ae164d968fb10b8e27c8222a--90df7d004a864878b6568085d01b558a 788c63c5b02145e4870c5673b2e3458a 90df7d004a864878b6568085d01b558a--788c63c5b02145e4870c5673b2e3458a 4e3eef3dff784cb8bbda009f96ac86f2 X 788c63c5b02145e4870c5673b2e3458a--4e3eef3dff784cb8bbda009f96ac86f2 4e3eef3dff784cb8bbda009f96ac86f2--e2c79d982d554f56a63a8691a7a576e7 80c1a940d0114abfb76c394a1b2809c4 4e3eef3dff784cb8bbda009f96ac86f2--80c1a940d0114abfb76c394a1b2809c4 321e149d5f284fe69d6980a8884291fd 80c1a940d0114abfb76c394a1b2809c4--321e149d5f284fe69d6980a8884291fd 4dc127b1a4d944f3aacfb3638d3b7b15 321e149d5f284fe69d6980a8884291fd--4dc127b1a4d944f3aacfb3638d3b7b15 ab02830518c4452e86d369e5e4ab5516 4dc127b1a4d944f3aacfb3638d3b7b15--ab02830518c4452e86d369e5e4ab5516 f4147cec35264b75b2bad3e1c40a5056 ab02830518c4452e86d369e5e4ab5516--f4147cec35264b75b2bad3e1c40a5056 35d8934517c545e8a1c167dc81e0c81c f4147cec35264b75b2bad3e1c40a5056--35d8934517c545e8a1c167dc81e0c81c e9f3f30847064597abbf42e8f66f3524 35d8934517c545e8a1c167dc81e0c81c--e9f3f30847064597abbf42e8f66f3524 ca3769e489a74a7f9f7fd9736a894e83 e9f3f30847064597abbf42e8f66f3524--ca3769e489a74a7f9f7fd9736a894e83 1fe214a6fd3e4419ad6210ece2dceb2d ca3769e489a74a7f9f7fd9736a894e83--1fe214a6fd3e4419ad6210ece2dceb2d 25ebc6ab394448c2bc710ef73d0e82e6 X 1fe214a6fd3e4419ad6210ece2dceb2d--25ebc6ab394448c2bc710ef73d0e82e6 25ebc6ab394448c2bc710ef73d0e82e6--cdf2c939fe564dfc8a0221491d4c1df2 93620635db1f441c84fb15710569c7f7 25ebc6ab394448c2bc710ef73d0e82e6--93620635db1f441c84fb15710569c7f7 870409d77bf2486da6d4f5874c2dbc6e 93620635db1f441c84fb15710569c7f7--870409d77bf2486da6d4f5874c2dbc6e 9de5504f1e7146018994b42f984e9e6d 870409d77bf2486da6d4f5874c2dbc6e--9de5504f1e7146018994b42f984e9e6d f56ca50bf1c0493aa95a3079a6555acd 9de5504f1e7146018994b42f984e9e6d--f56ca50bf1c0493aa95a3079a6555acd 840a4d7bb8ba4caba1cd19386060057c f56ca50bf1c0493aa95a3079a6555acd--840a4d7bb8ba4caba1cd19386060057c aae01274b70445b7b9384ab499c3e00a 840a4d7bb8ba4caba1cd19386060057c--aae01274b70445b7b9384ab499c3e00a aa934f10b6b34ad39efe3a8a53198bbb aae01274b70445b7b9384ab499c3e00a--aa934f10b6b34ad39efe3a8a53198bbb a1d688667ef64a299c8dedab0cadc1f1 aa934f10b6b34ad39efe3a8a53198bbb--a1d688667ef64a299c8dedab0cadc1f1 85e5da62f9084e2f97d702818a7159a6 a1d688667ef64a299c8dedab0cadc1f1--85e5da62f9084e2f97d702818a7159a6 4577ae91d08b4837bc2a3048d1cf6998 85e5da62f9084e2f97d702818a7159a6--4577ae91d08b4837bc2a3048d1cf6998 6735ab5328f542b1bff1f2bf08b2743a 4577ae91d08b4837bc2a3048d1cf6998--6735ab5328f542b1bff1f2bf08b2743a 3fa686ba44b34dc4ad136e324abee50f 6735ab5328f542b1bff1f2bf08b2743a--3fa686ba44b34dc4ad136e324abee50f eaf1680d822c4d4eb9b983cb7fb8a226 X 3fa686ba44b34dc4ad136e324abee50f--eaf1680d822c4d4eb9b983cb7fb8a226 eaf1680d822c4d4eb9b983cb7fb8a226--f7f3d54091f545e89f3577d2a7debdae 089f857d109e44b68fa7d56206bc54af RZ(-1.0*g1) eaf1680d822c4d4eb9b983cb7fb8a226--089f857d109e44b68fa7d56206bc54af 64de840bf8874ca192275e6a45ca9f4e X 089f857d109e44b68fa7d56206bc54af--64de840bf8874ca192275e6a45ca9f4e 64de840bf8874ca192275e6a45ca9f4e--042e82080faa45759df160ba98f7a5d0 79e75e3bee8c489bbe65fb13dbcadc39 64de840bf8874ca192275e6a45ca9f4e--79e75e3bee8c489bbe65fb13dbcadc39 f14ae55fa3884a89b3a0d56ae48155c9 79e75e3bee8c489bbe65fb13dbcadc39--f14ae55fa3884a89b3a0d56ae48155c9 6966372e5d2a4f50b34c21546fb7ba08 f14ae55fa3884a89b3a0d56ae48155c9--6966372e5d2a4f50b34c21546fb7ba08 0a2382acf9fa4afba3782b4191650aa0 6966372e5d2a4f50b34c21546fb7ba08--0a2382acf9fa4afba3782b4191650aa0 e8706e29abe4462996c3cc20ba565b3e X 0a2382acf9fa4afba3782b4191650aa0--e8706e29abe4462996c3cc20ba565b3e e8706e29abe4462996c3cc20ba565b3e--c37ffb5727c14885a94d56e9afd8fcc7 a914a15d1d604843bda987e86f20010a e8706e29abe4462996c3cc20ba565b3e--a914a15d1d604843bda987e86f20010a eca9ba43471d471097d44eb687927b06 a914a15d1d604843bda987e86f20010a--eca9ba43471d471097d44eb687927b06 ba7903091ee14cc9b591885a0436d572 eca9ba43471d471097d44eb687927b06--ba7903091ee14cc9b591885a0436d572 68b5d3b78c0a40308d5762a167efec60 X ba7903091ee14cc9b591885a0436d572--68b5d3b78c0a40308d5762a167efec60 68b5d3b78c0a40308d5762a167efec60--4d53630d7515466e968d0e2444f91261 3273125ce1884a6ea570fd2c84d789b7 68b5d3b78c0a40308d5762a167efec60--3273125ce1884a6ea570fd2c84d789b7 4e3d7320f2bc4825acf2e3950cbe1f27 3273125ce1884a6ea570fd2c84d789b7--4e3d7320f2bc4825acf2e3950cbe1f27 9c59843f5897419680bb059248ef7400 4e3d7320f2bc4825acf2e3950cbe1f27--9c59843f5897419680bb059248ef7400 7ef00f1cb3bb4c10889e6bab020991ba 9c59843f5897419680bb059248ef7400--7ef00f1cb3bb4c10889e6bab020991ba 1b835eba54ea4cd78cb7259fe6993ad6 X 7ef00f1cb3bb4c10889e6bab020991ba--1b835eba54ea4cd78cb7259fe6993ad6 1b835eba54ea4cd78cb7259fe6993ad6--80205d72229a418ba3c8d87349f07fa7 7aceb34a81e140148c50b0a2fabca49d 1b835eba54ea4cd78cb7259fe6993ad6--7aceb34a81e140148c50b0a2fabca49d f238903525fe4aac9907ab742360051b 7aceb34a81e140148c50b0a2fabca49d--f238903525fe4aac9907ab742360051b 0cb4594ccc4c4ad3b5651d886de68dc6 f238903525fe4aac9907ab742360051b--0cb4594ccc4c4ad3b5651d886de68dc6 4ae888c863b0487a89b7978a694ef997 0cb4594ccc4c4ad3b5651d886de68dc6--4ae888c863b0487a89b7978a694ef997 d21de489d8e34bd790c205e34cb64398 4ae888c863b0487a89b7978a694ef997--d21de489d8e34bd790c205e34cb64398 cd68d26b286048e3a4fcb2c598d3ab3e d21de489d8e34bd790c205e34cb64398--cd68d26b286048e3a4fcb2c598d3ab3e 2bceb6d343824ccaba7728083e14e95d cd68d26b286048e3a4fcb2c598d3ab3e--2bceb6d343824ccaba7728083e14e95d a4d73c68eb0b452299d329ee1d97411d X 2bceb6d343824ccaba7728083e14e95d--a4d73c68eb0b452299d329ee1d97411d a4d73c68eb0b452299d329ee1d97411d--fdec6d7f93bd4555a5e898863dc5bf03 a6d8a7cd7fad4e63bbac967983dbeac3 a4d73c68eb0b452299d329ee1d97411d--a6d8a7cd7fad4e63bbac967983dbeac3 596c3fda99044e67a37857c70ea6083a a6d8a7cd7fad4e63bbac967983dbeac3--596c3fda99044e67a37857c70ea6083a ec4612f42e5a4af0b046b3b3952c744a 596c3fda99044e67a37857c70ea6083a--ec4612f42e5a4af0b046b3b3952c744a a869df8c5c934c5dbc34335337b18ac8 ec4612f42e5a4af0b046b3b3952c744a--a869df8c5c934c5dbc34335337b18ac8 d2d09843473c471f924dded45f7faa02 X a869df8c5c934c5dbc34335337b18ac8--d2d09843473c471f924dded45f7faa02 d2d09843473c471f924dded45f7faa02--cb15762fedb44b2781bc17ac5a3364f2 73fdabf5e1024201b82bf225e62c1dd5 d2d09843473c471f924dded45f7faa02--73fdabf5e1024201b82bf225e62c1dd5 bc3342cbe3fc48248a19eddb9f3e0e6f 73fdabf5e1024201b82bf225e62c1dd5--bc3342cbe3fc48248a19eddb9f3e0e6f 0d4d0c8e1e0c463c9851267fc90d8057 bc3342cbe3fc48248a19eddb9f3e0e6f--0d4d0c8e1e0c463c9851267fc90d8057 0f43e540229f401caf0a1d1aded97da3 0d4d0c8e1e0c463c9851267fc90d8057--0f43e540229f401caf0a1d1aded97da3 e3d67ed457b24adf9269199d7abef980 0f43e540229f401caf0a1d1aded97da3--e3d67ed457b24adf9269199d7abef980 8db69d54e5c447558a4cdc35e95b6fff e3d67ed457b24adf9269199d7abef980--8db69d54e5c447558a4cdc35e95b6fff a86b1e8b777d447fb7252ed5bbe71e4d 8db69d54e5c447558a4cdc35e95b6fff--a86b1e8b777d447fb7252ed5bbe71e4d f6ee9029fa424969b120f259b2872334 a86b1e8b777d447fb7252ed5bbe71e4d--f6ee9029fa424969b120f259b2872334 4eefefd3808e425d86edde08e55f6903 f6ee9029fa424969b120f259b2872334--4eefefd3808e425d86edde08e55f6903 813b351b59f848968d5701f365e8fb35 X 4eefefd3808e425d86edde08e55f6903--813b351b59f848968d5701f365e8fb35 813b351b59f848968d5701f365e8fb35--012fc558dca145fba7dd681c4fa7ccea 5c0c86990dbb488683ab3a6c51fcbe40 813b351b59f848968d5701f365e8fb35--5c0c86990dbb488683ab3a6c51fcbe40 46d1f0d62aeb4fc49f445fefc42e2a77 5c0c86990dbb488683ab3a6c51fcbe40--46d1f0d62aeb4fc49f445fefc42e2a77 6863ad24cde1443d8964afaf93b6c1b1 46d1f0d62aeb4fc49f445fefc42e2a77--6863ad24cde1443d8964afaf93b6c1b1 65fbba92b6b447b7a07d60843bc85ab6 6863ad24cde1443d8964afaf93b6c1b1--65fbba92b6b447b7a07d60843bc85ab6 fa4f7cec7f254476a445e7033b44cda1 65fbba92b6b447b7a07d60843bc85ab6--fa4f7cec7f254476a445e7033b44cda1 b407374a146b4267b62636ff44ebf48e fa4f7cec7f254476a445e7033b44cda1--b407374a146b4267b62636ff44ebf48e 5a4d4cd53b2a40fca4cbf8ed910e0fc8 X b407374a146b4267b62636ff44ebf48e--5a4d4cd53b2a40fca4cbf8ed910e0fc8 5a4d4cd53b2a40fca4cbf8ed910e0fc8--c83c085699df458b82fbc30bdb0ee9d0 0786709f0625418d94c15c3bfd9e953d RZ(-1.0*g1) 5a4d4cd53b2a40fca4cbf8ed910e0fc8--0786709f0625418d94c15c3bfd9e953d 8984344590d04f329fd6a03d00d85d8e X 0786709f0625418d94c15c3bfd9e953d--8984344590d04f329fd6a03d00d85d8e 8984344590d04f329fd6a03d00d85d8e--a6b737195e8c4586b53e10b2482861a1 715118174a8f4651b4677e340b5da3eb 8984344590d04f329fd6a03d00d85d8e--715118174a8f4651b4677e340b5da3eb 02cddce049254f4d9edbd1d0e8466be4 715118174a8f4651b4677e340b5da3eb--02cddce049254f4d9edbd1d0e8466be4 5dd760fe869a4f968b6cbf58213fe222 X 02cddce049254f4d9edbd1d0e8466be4--5dd760fe869a4f968b6cbf58213fe222 5dd760fe869a4f968b6cbf58213fe222--839815e8911c42ceb20561d448c59a43 a2c8c2f09c824fbbac0cbc67a0c99b51 5dd760fe869a4f968b6cbf58213fe222--a2c8c2f09c824fbbac0cbc67a0c99b51 119b40b3e4c34c5aaf6ebf05fe909504 a2c8c2f09c824fbbac0cbc67a0c99b51--119b40b3e4c34c5aaf6ebf05fe909504 6f98f5f1db7a44e2a7785fb5ec9328d1 119b40b3e4c34c5aaf6ebf05fe909504--6f98f5f1db7a44e2a7785fb5ec9328d1 397cfee0607444609d21572ff40cbd5d 6f98f5f1db7a44e2a7785fb5ec9328d1--397cfee0607444609d21572ff40cbd5d fcc15e0d95844638a4311de5f2053100 397cfee0607444609d21572ff40cbd5d--fcc15e0d95844638a4311de5f2053100 bb395b6a7b2647f496daf46a265fe8c8 X fcc15e0d95844638a4311de5f2053100--bb395b6a7b2647f496daf46a265fe8c8 bb395b6a7b2647f496daf46a265fe8c8--0a9700bf3d954037a16731f02e75ac75 f2dcc74fb0dc482aadfac371cf114c74 bb395b6a7b2647f496daf46a265fe8c8--f2dcc74fb0dc482aadfac371cf114c74 deaecaaf8d84478ca6b8114c504b47d0 f2dcc74fb0dc482aadfac371cf114c74--deaecaaf8d84478ca6b8114c504b47d0 5d7a9b76c3cf412cbcd86bf658bf64f2 X deaecaaf8d84478ca6b8114c504b47d0--5d7a9b76c3cf412cbcd86bf658bf64f2 5d7a9b76c3cf412cbcd86bf658bf64f2--0675755234ab4e5c914feea9c530fdb0 b7651bf4f7974c41b244184e4e707605 5d7a9b76c3cf412cbcd86bf658bf64f2--b7651bf4f7974c41b244184e4e707605 49df27a154fc45b5b7223063e2e672c9 b7651bf4f7974c41b244184e4e707605--49df27a154fc45b5b7223063e2e672c9 22fbb3efa9444033b45fe6b9f1f37985 49df27a154fc45b5b7223063e2e672c9--22fbb3efa9444033b45fe6b9f1f37985 ae716fd5f1954e7ea02076f6cc9abc9e 22fbb3efa9444033b45fe6b9f1f37985--ae716fd5f1954e7ea02076f6cc9abc9e 367739f693924624b010b129541e99ea ae716fd5f1954e7ea02076f6cc9abc9e--367739f693924624b010b129541e99ea fc89eac6d5ee4ad0bf9d9c867b422dae 367739f693924624b010b129541e99ea--fc89eac6d5ee4ad0bf9d9c867b422dae 13ac6f1c2bde4e0e88f9500b39472e91 fc89eac6d5ee4ad0bf9d9c867b422dae--13ac6f1c2bde4e0e88f9500b39472e91 fd3da9ed65c145e68d438f81c9302422 X 13ac6f1c2bde4e0e88f9500b39472e91--fd3da9ed65c145e68d438f81c9302422 fd3da9ed65c145e68d438f81c9302422--8884c173ffaf477ea511f03e75420bd7 8fb0c08661624d069f13e65ec1d11ef4 fd3da9ed65c145e68d438f81c9302422--8fb0c08661624d069f13e65ec1d11ef4 457400ab507b46ab9f231c0dcaafc526 X 8fb0c08661624d069f13e65ec1d11ef4--457400ab507b46ab9f231c0dcaafc526 457400ab507b46ab9f231c0dcaafc526--a759ed71d6334b5baae66e256b279cc5 fea3b23fc8b04aa9be27a82b893ac374 457400ab507b46ab9f231c0dcaafc526--fea3b23fc8b04aa9be27a82b893ac374 e15e8d70d75e484eb456ebcfdec6b1c2 fea3b23fc8b04aa9be27a82b893ac374--e15e8d70d75e484eb456ebcfdec6b1c2 787079d1b85d49f0924bb581912b8c41 e15e8d70d75e484eb456ebcfdec6b1c2--787079d1b85d49f0924bb581912b8c41 179cb29bfbf1408f81516a657dc2d8d1 X 787079d1b85d49f0924bb581912b8c41--179cb29bfbf1408f81516a657dc2d8d1 179cb29bfbf1408f81516a657dc2d8d1--b2e881d88f5e410ba8f37d0b9318f188 a4e780d9b705442a954b874fc106a2d5 X 179cb29bfbf1408f81516a657dc2d8d1--a4e780d9b705442a954b874fc106a2d5 a4e780d9b705442a954b874fc106a2d5--c7f9f2c09f914e40be468aadb748e79d d11545906c2947cda2e833f422fcc517 a4e780d9b705442a954b874fc106a2d5--d11545906c2947cda2e833f422fcc517 bc2c5432cdb24223b58a736d6aff7377 d11545906c2947cda2e833f422fcc517--bc2c5432cdb24223b58a736d6aff7377 390b96cc29474a84ae097c71d98d4c63 bc2c5432cdb24223b58a736d6aff7377--390b96cc29474a84ae097c71d98d4c63 c74dbdb548134a16a4d425ccd5b6c08c 390b96cc29474a84ae097c71d98d4c63--c74dbdb548134a16a4d425ccd5b6c08c d08eda323995461e8624e397cf0ba0a4 c74dbdb548134a16a4d425ccd5b6c08c--d08eda323995461e8624e397cf0ba0a4 feac64a32b264d7ca66ca09596751b22 d08eda323995461e8624e397cf0ba0a4--feac64a32b264d7ca66ca09596751b22 ca016e31d55e4ff3a9a1d3f61d3098dd feac64a32b264d7ca66ca09596751b22--ca016e31d55e4ff3a9a1d3f61d3098dd 3a62e5220b2444a0803241280948c894 ca016e31d55e4ff3a9a1d3f61d3098dd--3a62e5220b2444a0803241280948c894 34b4445c16274c9288b1c4e0baa7785e 3a62e5220b2444a0803241280948c894--34b4445c16274c9288b1c4e0baa7785e caecff459129439b9cacec46b11271c3 X 34b4445c16274c9288b1c4e0baa7785e--caecff459129439b9cacec46b11271c3 caecff459129439b9cacec46b11271c3--f7c472fe528a4b7290dc92d7179fcbea 9d5227be51a14781a771df66b130c14a caecff459129439b9cacec46b11271c3--9d5227be51a14781a771df66b130c14a 1c2985b4f7f645f7b7cd5123a7d7fd5d 9d5227be51a14781a771df66b130c14a--1c2985b4f7f645f7b7cd5123a7d7fd5d 3f056a83b8b043c3b9c43775e79efd19 1c2985b4f7f645f7b7cd5123a7d7fd5d--3f056a83b8b043c3b9c43775e79efd19 a49d6cb7e1fe48bbb5dc62369bb3b6dd 3f056a83b8b043c3b9c43775e79efd19--a49d6cb7e1fe48bbb5dc62369bb3b6dd ead95d0353e04f30917cc1824ee96310 a49d6cb7e1fe48bbb5dc62369bb3b6dd--ead95d0353e04f30917cc1824ee96310 e0029c676e614dca93e35e0a2679724e ead95d0353e04f30917cc1824ee96310--e0029c676e614dca93e35e0a2679724e 9e1bc6e98c674f80a28bc7d37c6e155c e0029c676e614dca93e35e0a2679724e--9e1bc6e98c674f80a28bc7d37c6e155c 79a472b86f4d46bdb712f1d56bd320b6 9e1bc6e98c674f80a28bc7d37c6e155c--79a472b86f4d46bdb712f1d56bd320b6 c6d4263d015d459a9041e750f91d6ee7 79a472b86f4d46bdb712f1d56bd320b6--c6d4263d015d459a9041e750f91d6ee7 a52bd38864874e0ebbacccfcb5ba2dba c6d4263d015d459a9041e750f91d6ee7--a52bd38864874e0ebbacccfcb5ba2dba 12c69f5394944101b3930b613da68fec a52bd38864874e0ebbacccfcb5ba2dba--12c69f5394944101b3930b613da68fec 19286706bdd64010b4bd79052da6f76e 12c69f5394944101b3930b613da68fec--19286706bdd64010b4bd79052da6f76e e26be46aefb54b18bffd2ec48711e187 19286706bdd64010b4bd79052da6f76e--e26be46aefb54b18bffd2ec48711e187 f9c06a9019c645b0bc806f3a224b40ae e26be46aefb54b18bffd2ec48711e187--f9c06a9019c645b0bc806f3a224b40ae 5ef8180b721e495b87d3b7a01ee2a257 f9c06a9019c645b0bc806f3a224b40ae--5ef8180b721e495b87d3b7a01ee2a257 5b27a99bdc9a450a870d42d4b6c95c96 5ef8180b721e495b87d3b7a01ee2a257--5b27a99bdc9a450a870d42d4b6c95c96 ee6e8b15a48c4c0f88af277459c68b15 5b27a99bdc9a450a870d42d4b6c95c96--ee6e8b15a48c4c0f88af277459c68b15 aeb5c3ea05784f11929db4c6813a6042 RX(b13) ee6e8b15a48c4c0f88af277459c68b15--aeb5c3ea05784f11929db4c6813a6042 aeb5c3ea05784f11929db4c6813a6042--fd196c6052f542eca09232f41fcd6d8c 37bd554896c64e1980ea3b8012506c2f 6747b3a9ea824a6b90d1dfa0b31ed181 b216b5c5f0e7433ab8290e715e3dd6b3--6747b3a9ea824a6b90d1dfa0b31ed181 dbea92f6179240859bb5837c61e84eac 5 8528c29a29bc4e8b8835830b631e463c 6747b3a9ea824a6b90d1dfa0b31ed181--8528c29a29bc4e8b8835830b631e463c 29e2b35729fa4ed0b58a32a748672e2b 8528c29a29bc4e8b8835830b631e463c--29e2b35729fa4ed0b58a32a748672e2b 721fd78d821a4fadb4db3007d678b843 X 29e2b35729fa4ed0b58a32a748672e2b--721fd78d821a4fadb4db3007d678b843 721fd78d821a4fadb4db3007d678b843--74e5f08f916048f496dd86fbbec26d56 9a25a3b6caef41acb9670037193f9c9b 721fd78d821a4fadb4db3007d678b843--9a25a3b6caef41acb9670037193f9c9b e02a851527fc4396b95c34f02b27f23a 9a25a3b6caef41acb9670037193f9c9b--e02a851527fc4396b95c34f02b27f23a ce6bfb6ba11b48e49223582a0d0304bf e02a851527fc4396b95c34f02b27f23a--ce6bfb6ba11b48e49223582a0d0304bf a6e752896a814035b546629949fa4025 ce6bfb6ba11b48e49223582a0d0304bf--a6e752896a814035b546629949fa4025 08616e9b98de42269cbec69a36091c9f a6e752896a814035b546629949fa4025--08616e9b98de42269cbec69a36091c9f bb83fc3e2aa341a4b918c0f0178d4007 08616e9b98de42269cbec69a36091c9f--bb83fc3e2aa341a4b918c0f0178d4007 919bcd3a51a0435fb27de1cf89e523f3 bb83fc3e2aa341a4b918c0f0178d4007--919bcd3a51a0435fb27de1cf89e523f3 8a33d494ecca4ad991be48f6bf91dc92 X 919bcd3a51a0435fb27de1cf89e523f3--8a33d494ecca4ad991be48f6bf91dc92 8a33d494ecca4ad991be48f6bf91dc92--04d0216b9e734c1cb1d78c491cbf08c0 bbb7c1025a1f4dc89d3db03fa8ae9f76 8a33d494ecca4ad991be48f6bf91dc92--bbb7c1025a1f4dc89d3db03fa8ae9f76 468f4823e8c54647a254b56031e04353 bbb7c1025a1f4dc89d3db03fa8ae9f76--468f4823e8c54647a254b56031e04353 8797bc07001344e390f95dc8291185f9 468f4823e8c54647a254b56031e04353--8797bc07001344e390f95dc8291185f9 f969161ed6464b0e8471f8f89e55ab8b 8797bc07001344e390f95dc8291185f9--f969161ed6464b0e8471f8f89e55ab8b a7804dbfb9204a75929ac3017bc49f49 f969161ed6464b0e8471f8f89e55ab8b--a7804dbfb9204a75929ac3017bc49f49 94c62fb92fd4480d895c2707f71ac32c a7804dbfb9204a75929ac3017bc49f49--94c62fb92fd4480d895c2707f71ac32c 4b176be9639548a096022d50a4de1186 94c62fb92fd4480d895c2707f71ac32c--4b176be9639548a096022d50a4de1186 7047e67f37f14345a19e04e4bb0e5f0c 4b176be9639548a096022d50a4de1186--7047e67f37f14345a19e04e4bb0e5f0c 1facafb06dd844659e6b0273b29bdb0d 7047e67f37f14345a19e04e4bb0e5f0c--1facafb06dd844659e6b0273b29bdb0d 10b25d08424748d281eac4a07bdd1abe 1facafb06dd844659e6b0273b29bdb0d--10b25d08424748d281eac4a07bdd1abe 6d09ea30599d452d9d9d48fccd2df134 10b25d08424748d281eac4a07bdd1abe--6d09ea30599d452d9d9d48fccd2df134 876802a61a50470ca024d0f957146ce4 6d09ea30599d452d9d9d48fccd2df134--876802a61a50470ca024d0f957146ce4 625fc11e81fc4a6583d63394f4e9f47b 876802a61a50470ca024d0f957146ce4--625fc11e81fc4a6583d63394f4e9f47b 39986499a0b14331934a48cbda105744 625fc11e81fc4a6583d63394f4e9f47b--39986499a0b14331934a48cbda105744 4d5a741b652b4bb0b7144cc205d631a6 39986499a0b14331934a48cbda105744--4d5a741b652b4bb0b7144cc205d631a6 c1c73b173eaf41ceb6a0dee393df4908 4d5a741b652b4bb0b7144cc205d631a6--c1c73b173eaf41ceb6a0dee393df4908 d4648923f0e445169906aa8489ea67c2 c1c73b173eaf41ceb6a0dee393df4908--d4648923f0e445169906aa8489ea67c2 e20235c6dc4446c9959483f44c4d4648 d4648923f0e445169906aa8489ea67c2--e20235c6dc4446c9959483f44c4d4648 114f58183ef044109fc0643fa18fc429 e20235c6dc4446c9959483f44c4d4648--114f58183ef044109fc0643fa18fc429 6a6f34b7bbdf4966b5efe5b7f27981b5 114f58183ef044109fc0643fa18fc429--6a6f34b7bbdf4966b5efe5b7f27981b5 5253ae7033c24f24b2916e2789459a14 6a6f34b7bbdf4966b5efe5b7f27981b5--5253ae7033c24f24b2916e2789459a14 01796cea08914a2a9694ec3afd76fcb8 X 5253ae7033c24f24b2916e2789459a14--01796cea08914a2a9694ec3afd76fcb8 01796cea08914a2a9694ec3afd76fcb8--28aec6a9b6a440f79bb30f5dbd0ad3ab 21e0091143fd4b64bc43c95d258762ed RZ(-1.0*g0) 01796cea08914a2a9694ec3afd76fcb8--21e0091143fd4b64bc43c95d258762ed c649effad0384eb9aef67505d8594dd0 X 21e0091143fd4b64bc43c95d258762ed--c649effad0384eb9aef67505d8594dd0 c649effad0384eb9aef67505d8594dd0--70a483a884bc431fb03014814f3bfa72 4edb27bd1aef449390af4c500a662fde c649effad0384eb9aef67505d8594dd0--4edb27bd1aef449390af4c500a662fde adb451fc14474f5a80623d7fa0ec5053 4edb27bd1aef449390af4c500a662fde--adb451fc14474f5a80623d7fa0ec5053 f744d3192a784bd8887cf5a22efeb0a0 adb451fc14474f5a80623d7fa0ec5053--f744d3192a784bd8887cf5a22efeb0a0 a3a1050ba8a142efbd8bd65de84d2fd6 f744d3192a784bd8887cf5a22efeb0a0--a3a1050ba8a142efbd8bd65de84d2fd6 1edf34da9e964012ba19953a940af828 a3a1050ba8a142efbd8bd65de84d2fd6--1edf34da9e964012ba19953a940af828 950c09ade31e48358da2c4bb67819800 1edf34da9e964012ba19953a940af828--950c09ade31e48358da2c4bb67819800 b896b8cfcdf5419f8456efcba3214265 X 950c09ade31e48358da2c4bb67819800--b896b8cfcdf5419f8456efcba3214265 b896b8cfcdf5419f8456efcba3214265--94a8965776b94e19983d4bcedccd4977 b9ec4192872f4db9afd039415c8b8a2b b896b8cfcdf5419f8456efcba3214265--b9ec4192872f4db9afd039415c8b8a2b b973545cd1524d47b3997241d662318b b9ec4192872f4db9afd039415c8b8a2b--b973545cd1524d47b3997241d662318b c8635d8737784591ae9cfb85c7369f02 b973545cd1524d47b3997241d662318b--c8635d8737784591ae9cfb85c7369f02 27f9b8be8d5d47c9ae0df0630d804a65 c8635d8737784591ae9cfb85c7369f02--27f9b8be8d5d47c9ae0df0630d804a65 686f7482d5ee42929b028eff9943723c 27f9b8be8d5d47c9ae0df0630d804a65--686f7482d5ee42929b028eff9943723c cc7e06d9db104662b333e3a91bd56fe4 X 686f7482d5ee42929b028eff9943723c--cc7e06d9db104662b333e3a91bd56fe4 cc7e06d9db104662b333e3a91bd56fe4--21af2bf51189453c8d703f8af566f4df cdf55dc4a35c48ba96bd9cc34010aa3e cc7e06d9db104662b333e3a91bd56fe4--cdf55dc4a35c48ba96bd9cc34010aa3e 8bf21ba500aa437d98cb56b0f68a1395 cdf55dc4a35c48ba96bd9cc34010aa3e--8bf21ba500aa437d98cb56b0f68a1395 fd6a6305092a4b5f95e360a142b3416d 8bf21ba500aa437d98cb56b0f68a1395--fd6a6305092a4b5f95e360a142b3416d 97d6616b4fd8458eb6758e3b465f188a fd6a6305092a4b5f95e360a142b3416d--97d6616b4fd8458eb6758e3b465f188a d6241d8afac64c46a61c890233cfe3be 97d6616b4fd8458eb6758e3b465f188a--d6241d8afac64c46a61c890233cfe3be cb1c9020db5a40baae501a903288065f d6241d8afac64c46a61c890233cfe3be--cb1c9020db5a40baae501a903288065f 4dea3617361d4974a57d274e7918f43c X cb1c9020db5a40baae501a903288065f--4dea3617361d4974a57d274e7918f43c 4dea3617361d4974a57d274e7918f43c--0cfad0a744194e3792ef3c1d978130b1 39a600f349c24aee90991e2d3d62ca13 4dea3617361d4974a57d274e7918f43c--39a600f349c24aee90991e2d3d62ca13 9d1ee407590947fab88eb56a09806624 39a600f349c24aee90991e2d3d62ca13--9d1ee407590947fab88eb56a09806624 4b5d1d2c11824c0a8e63d057432dbd27 9d1ee407590947fab88eb56a09806624--4b5d1d2c11824c0a8e63d057432dbd27 567fbb34583b456286a77ee622691ff6 4b5d1d2c11824c0a8e63d057432dbd27--567fbb34583b456286a77ee622691ff6 891fa3ec252a4027b87df3c9029342a2 567fbb34583b456286a77ee622691ff6--891fa3ec252a4027b87df3c9029342a2 fe1b1fb6491d46c48c1ed86eb624e24d 891fa3ec252a4027b87df3c9029342a2--fe1b1fb6491d46c48c1ed86eb624e24d da8e3f4446da4e668df325533fa0f56c fe1b1fb6491d46c48c1ed86eb624e24d--da8e3f4446da4e668df325533fa0f56c 45f3ba66a4274de7a1f37b488ae978b8 X da8e3f4446da4e668df325533fa0f56c--45f3ba66a4274de7a1f37b488ae978b8 45f3ba66a4274de7a1f37b488ae978b8--d58642d0fd8d41c6a9ea9fc9af6db6ee d2565c7c861c4c69aabe25b53b23ee4b 45f3ba66a4274de7a1f37b488ae978b8--d2565c7c861c4c69aabe25b53b23ee4b 9e9c403ade5d4f61adbf75efaccaf8db d2565c7c861c4c69aabe25b53b23ee4b--9e9c403ade5d4f61adbf75efaccaf8db 4db63e619f254a82aacfbfc9d572b565 9e9c403ade5d4f61adbf75efaccaf8db--4db63e619f254a82aacfbfc9d572b565 769bc47f10b84ddba83a5f95d248cd4f 4db63e619f254a82aacfbfc9d572b565--769bc47f10b84ddba83a5f95d248cd4f 34bd34bf843b47c092b46966a0c6c024 769bc47f10b84ddba83a5f95d248cd4f--34bd34bf843b47c092b46966a0c6c024 95d4ac3ca72e4ed2aade7bfe1ee46c06 34bd34bf843b47c092b46966a0c6c024--95d4ac3ca72e4ed2aade7bfe1ee46c06 ed89cd6d032c466384f6c0487f6e7cbf 95d4ac3ca72e4ed2aade7bfe1ee46c06--ed89cd6d032c466384f6c0487f6e7cbf af1e4ad90bc64339b19ad72cb81d85fa ed89cd6d032c466384f6c0487f6e7cbf--af1e4ad90bc64339b19ad72cb81d85fa 16e6ce0ce3fd448d9d2b29fe24cbc5e4 af1e4ad90bc64339b19ad72cb81d85fa--16e6ce0ce3fd448d9d2b29fe24cbc5e4 d0b2f7581143437f8d19271a3bd33855 16e6ce0ce3fd448d9d2b29fe24cbc5e4--d0b2f7581143437f8d19271a3bd33855 a444b604848a46099d4f29bfe26009bf d0b2f7581143437f8d19271a3bd33855--a444b604848a46099d4f29bfe26009bf ebc17f7dfc384c4594db0bebdd413e13 a444b604848a46099d4f29bfe26009bf--ebc17f7dfc384c4594db0bebdd413e13 e61d734f2bdf47bc99333b6b9c39b929 ebc17f7dfc384c4594db0bebdd413e13--e61d734f2bdf47bc99333b6b9c39b929 00d6b13058e843d78a564894dd4724b5 X e61d734f2bdf47bc99333b6b9c39b929--00d6b13058e843d78a564894dd4724b5 00d6b13058e843d78a564894dd4724b5--e578cd9fe4eb449188421ea3ab91d9c6 a238d18aac2d4d14826737c6d48e4fcd 00d6b13058e843d78a564894dd4724b5--a238d18aac2d4d14826737c6d48e4fcd e3dca25d0db840b0ad9c90d401b61320 a238d18aac2d4d14826737c6d48e4fcd--e3dca25d0db840b0ad9c90d401b61320 187ee13a72974b1b99752fd143717f1c e3dca25d0db840b0ad9c90d401b61320--187ee13a72974b1b99752fd143717f1c 5cfabcdd31404ee9b505d20eaf639bda X 187ee13a72974b1b99752fd143717f1c--5cfabcdd31404ee9b505d20eaf639bda 5cfabcdd31404ee9b505d20eaf639bda--b10167d33a2340a8ba2a6418ba8dd346 d4d72e4c22834b82b4c047c20eedf5e5 5cfabcdd31404ee9b505d20eaf639bda--d4d72e4c22834b82b4c047c20eedf5e5 7a55f08c79bb41cdb23c053782bd380c d4d72e4c22834b82b4c047c20eedf5e5--7a55f08c79bb41cdb23c053782bd380c e123461264f84a4397cf10788f7c18d5 7a55f08c79bb41cdb23c053782bd380c--e123461264f84a4397cf10788f7c18d5 4797c258fe2b4aaab3803fcaeb189c0f e123461264f84a4397cf10788f7c18d5--4797c258fe2b4aaab3803fcaeb189c0f c2d9fbba7b6f4cb682db8d21486a5c51 X 4797c258fe2b4aaab3803fcaeb189c0f--c2d9fbba7b6f4cb682db8d21486a5c51 c2d9fbba7b6f4cb682db8d21486a5c51--a07ff7de71c34b0c851bc230ebd7e7f6 a7e12c781b7748e3894d4065d968319a c2d9fbba7b6f4cb682db8d21486a5c51--a7e12c781b7748e3894d4065d968319a 9cf97a5e483948a7b94e8d02c7899cce a7e12c781b7748e3894d4065d968319a--9cf97a5e483948a7b94e8d02c7899cce f699aa674ac04a4dafc48a0634789b1e 9cf97a5e483948a7b94e8d02c7899cce--f699aa674ac04a4dafc48a0634789b1e 923d27cddaac4f58a6e7dd0eeb0174a8 f699aa674ac04a4dafc48a0634789b1e--923d27cddaac4f58a6e7dd0eeb0174a8 17df66296c07432992c7b9bf1f4a25ff 923d27cddaac4f58a6e7dd0eeb0174a8--17df66296c07432992c7b9bf1f4a25ff 83f4d972bae74eaf8cfa63c3af3fb62f X 17df66296c07432992c7b9bf1f4a25ff--83f4d972bae74eaf8cfa63c3af3fb62f 83f4d972bae74eaf8cfa63c3af3fb62f--8b1c595e067744ccbb8eb6c63b76a23c ccf2a7ef10dd458f8b227b6d6076245b 83f4d972bae74eaf8cfa63c3af3fb62f--ccf2a7ef10dd458f8b227b6d6076245b 5846353999cf4e8ab843fabaef68d90b ccf2a7ef10dd458f8b227b6d6076245b--5846353999cf4e8ab843fabaef68d90b c86b9ac71f154c1aa82323e6d34b8d2f 5846353999cf4e8ab843fabaef68d90b--c86b9ac71f154c1aa82323e6d34b8d2f e3a8932c9a2346c8b0232a478d1cbe18 X c86b9ac71f154c1aa82323e6d34b8d2f--e3a8932c9a2346c8b0232a478d1cbe18 e3a8932c9a2346c8b0232a478d1cbe18--c2381d419ba64726951a6cb2107d4649 5c8ba2d4f6d84d6092b0987e49ccb9da RZ(-1.0*g0) e3a8932c9a2346c8b0232a478d1cbe18--5c8ba2d4f6d84d6092b0987e49ccb9da 35c34be055ef474c851c01ed8395bc32 X 5c8ba2d4f6d84d6092b0987e49ccb9da--35c34be055ef474c851c01ed8395bc32 35c34be055ef474c851c01ed8395bc32--7645a6e6cd0442e9a6bf7655b274a0b5 f5005a1ad8a94c8395ece0093cbe99e6 35c34be055ef474c851c01ed8395bc32--f5005a1ad8a94c8395ece0093cbe99e6 f066a5cb03694cbd801ce3e2e22f9499 f5005a1ad8a94c8395ece0093cbe99e6--f066a5cb03694cbd801ce3e2e22f9499 4967a81389f04cc0b6fb856b2d0a7b1a X f066a5cb03694cbd801ce3e2e22f9499--4967a81389f04cc0b6fb856b2d0a7b1a 4967a81389f04cc0b6fb856b2d0a7b1a--c8c2a15c0a7a46e98d6917754ed7c323 244ffa2c6e8e436c8d4ade28460ed7c1 4967a81389f04cc0b6fb856b2d0a7b1a--244ffa2c6e8e436c8d4ade28460ed7c1 6d0a89ff67814b3dba99388e466b9d5d 244ffa2c6e8e436c8d4ade28460ed7c1--6d0a89ff67814b3dba99388e466b9d5d bf6ec6a15c2b43f6939bee50e53985cf 6d0a89ff67814b3dba99388e466b9d5d--bf6ec6a15c2b43f6939bee50e53985cf 346ff692d097452f8639e2f713df996d bf6ec6a15c2b43f6939bee50e53985cf--346ff692d097452f8639e2f713df996d fe7a154c05ab482eabe7c0ebbe12d7fe 346ff692d097452f8639e2f713df996d--fe7a154c05ab482eabe7c0ebbe12d7fe 94bfa6d1fa884bf6a0ca774e49a88624 fe7a154c05ab482eabe7c0ebbe12d7fe--94bfa6d1fa884bf6a0ca774e49a88624 8a6d3aa1a6024e759be9eb2284e36b46 94bfa6d1fa884bf6a0ca774e49a88624--8a6d3aa1a6024e759be9eb2284e36b46 eadf306b07e649098151ca79da71b95b X 8a6d3aa1a6024e759be9eb2284e36b46--eadf306b07e649098151ca79da71b95b eadf306b07e649098151ca79da71b95b--397ca12e60334d9aba0f804af4679afd 612fb83c721d46c9bf2e36f32fe6c2c7 eadf306b07e649098151ca79da71b95b--612fb83c721d46c9bf2e36f32fe6c2c7 8aa6f605a4f842628782c73e8aa46a0d X 612fb83c721d46c9bf2e36f32fe6c2c7--8aa6f605a4f842628782c73e8aa46a0d 8aa6f605a4f842628782c73e8aa46a0d--1f3e0a5b379240daa0f456310848d7b3 34c3ac379f784d0fb56784ebba81cff3 8aa6f605a4f842628782c73e8aa46a0d--34c3ac379f784d0fb56784ebba81cff3 257001086f634f0f9b3cc798bed52fd1 34c3ac379f784d0fb56784ebba81cff3--257001086f634f0f9b3cc798bed52fd1 7124db2481c344ec99e8480146612896 257001086f634f0f9b3cc798bed52fd1--7124db2481c344ec99e8480146612896 09ff18c5368946a7a2f23a19673ace40 7124db2481c344ec99e8480146612896--09ff18c5368946a7a2f23a19673ace40 ca2751c2bff941c3b1a359c639c7047e 09ff18c5368946a7a2f23a19673ace40--ca2751c2bff941c3b1a359c639c7047e 5468afa7ddf94662b1d50c650f7c0920 ca2751c2bff941c3b1a359c639c7047e--5468afa7ddf94662b1d50c650f7c0920 b4cf916215fc4caaac58642b2606ea57 5468afa7ddf94662b1d50c650f7c0920--b4cf916215fc4caaac58642b2606ea57 b51895d9f2de4a54a413ec076b6289e1 X b4cf916215fc4caaac58642b2606ea57--b51895d9f2de4a54a413ec076b6289e1 b51895d9f2de4a54a413ec076b6289e1--132659b77f7b4d0eaafe2f5c4752faac 453f00d5d7b54f5b9b26f996f1c6c2c0 b51895d9f2de4a54a413ec076b6289e1--453f00d5d7b54f5b9b26f996f1c6c2c0 58ef36c233a34d93bea530f55624116f 453f00d5d7b54f5b9b26f996f1c6c2c0--58ef36c233a34d93bea530f55624116f 193f737988a94552a9726fef5a406253 58ef36c233a34d93bea530f55624116f--193f737988a94552a9726fef5a406253 7a16d05504184f75a49acc46394d6d4c 193f737988a94552a9726fef5a406253--7a16d05504184f75a49acc46394d6d4c 2833a2e2002f4d918f920c5278c93647 7a16d05504184f75a49acc46394d6d4c--2833a2e2002f4d918f920c5278c93647 48b54ef06aab4b1ca9f8189bbaab5473 2833a2e2002f4d918f920c5278c93647--48b54ef06aab4b1ca9f8189bbaab5473 caac4193138c43b2aba83558e7a4674d 48b54ef06aab4b1ca9f8189bbaab5473--caac4193138c43b2aba83558e7a4674d a6ba148e13d94b72a2f13ae2dc4c72d7 caac4193138c43b2aba83558e7a4674d--a6ba148e13d94b72a2f13ae2dc4c72d7 a5b7809bd889447baa742ad0c3bf257e RX(b04) a6ba148e13d94b72a2f13ae2dc4c72d7--a5b7809bd889447baa742ad0c3bf257e f4704228dcfe41b5a3fbb0d8dad209a6 a5b7809bd889447baa742ad0c3bf257e--f4704228dcfe41b5a3fbb0d8dad209a6 1538fde1e8524a8586309593500fc611 f4704228dcfe41b5a3fbb0d8dad209a6--1538fde1e8524a8586309593500fc611 986a33bfc13847558bd68b1a638950b7 1538fde1e8524a8586309593500fc611--986a33bfc13847558bd68b1a638950b7 bdc787c269384ab6b8d90e98f2d22640 X 986a33bfc13847558bd68b1a638950b7--bdc787c269384ab6b8d90e98f2d22640 bdc787c269384ab6b8d90e98f2d22640--80c1a940d0114abfb76c394a1b2809c4 8909d9f882294b1eaea9ba30e12789ef bdc787c269384ab6b8d90e98f2d22640--8909d9f882294b1eaea9ba30e12789ef 8db09cf0594e459e86e7b05826219d68 8909d9f882294b1eaea9ba30e12789ef--8db09cf0594e459e86e7b05826219d68 123e0e0b61fe4750839e48170b03a8d1 8db09cf0594e459e86e7b05826219d68--123e0e0b61fe4750839e48170b03a8d1 df0990ddad794f12800f27146f70b8d8 123e0e0b61fe4750839e48170b03a8d1--df0990ddad794f12800f27146f70b8d8 64251bb06ada4e5b82a90129e62b4056 df0990ddad794f12800f27146f70b8d8--64251bb06ada4e5b82a90129e62b4056 00ce6c356b0a4d6eb704067a1dae5f0f 64251bb06ada4e5b82a90129e62b4056--00ce6c356b0a4d6eb704067a1dae5f0f ba155d53c37c4c1791deb06743b0326c 00ce6c356b0a4d6eb704067a1dae5f0f--ba155d53c37c4c1791deb06743b0326c 03c0fbb40731440caa5bcaf6928babab X ba155d53c37c4c1791deb06743b0326c--03c0fbb40731440caa5bcaf6928babab 03c0fbb40731440caa5bcaf6928babab--1fe214a6fd3e4419ad6210ece2dceb2d 6467274ee14942c3a472b27a2ab254be 03c0fbb40731440caa5bcaf6928babab--6467274ee14942c3a472b27a2ab254be dae07a7ccea24ced93432b3299e5027c 6467274ee14942c3a472b27a2ab254be--dae07a7ccea24ced93432b3299e5027c 048e38fc226a4b7c8e032446eda95b2a dae07a7ccea24ced93432b3299e5027c--048e38fc226a4b7c8e032446eda95b2a 9b087da5c3a445b29f4f8f27e0ba22f8 048e38fc226a4b7c8e032446eda95b2a--9b087da5c3a445b29f4f8f27e0ba22f8 ac23149a5c444985a3cc50f2ce367bef 9b087da5c3a445b29f4f8f27e0ba22f8--ac23149a5c444985a3cc50f2ce367bef ac804384dce044e9b180ff87cb509094 ac23149a5c444985a3cc50f2ce367bef--ac804384dce044e9b180ff87cb509094 c795bfa563724e07b7d26ae8effe76fd ac804384dce044e9b180ff87cb509094--c795bfa563724e07b7d26ae8effe76fd 383e69fcbd954bcaae4788dbd7a0d427 c795bfa563724e07b7d26ae8effe76fd--383e69fcbd954bcaae4788dbd7a0d427 ea13ab2605124f329bfc93ef0c63c4a8 383e69fcbd954bcaae4788dbd7a0d427--ea13ab2605124f329bfc93ef0c63c4a8 525ab678dd984d40862a441ae4fdc7fa ea13ab2605124f329bfc93ef0c63c4a8--525ab678dd984d40862a441ae4fdc7fa 633f3e8b43e142098dfbc8ab67b3142a 525ab678dd984d40862a441ae4fdc7fa--633f3e8b43e142098dfbc8ab67b3142a 25eef3f79d8a4e42a81877637673537e 633f3e8b43e142098dfbc8ab67b3142a--25eef3f79d8a4e42a81877637673537e 39e5286be0ac47e6bea6e458337c5561 25eef3f79d8a4e42a81877637673537e--39e5286be0ac47e6bea6e458337c5561 574dcd67356f4196bd155a43466b74b7 39e5286be0ac47e6bea6e458337c5561--574dcd67356f4196bd155a43466b74b7 3ca13773f14447919aa2c48a62b61a44 574dcd67356f4196bd155a43466b74b7--3ca13773f14447919aa2c48a62b61a44 5f37a5ec5f444c85af002ee846b9f538 3ca13773f14447919aa2c48a62b61a44--5f37a5ec5f444c85af002ee846b9f538 e129ba7bd47a433dacfaa1ef2775692d 5f37a5ec5f444c85af002ee846b9f538--e129ba7bd47a433dacfaa1ef2775692d e5657b1d14414a04bd1faaf0564b1087 e129ba7bd47a433dacfaa1ef2775692d--e5657b1d14414a04bd1faaf0564b1087 adbee8d169544f9b822e243c6709fe78 e5657b1d14414a04bd1faaf0564b1087--adbee8d169544f9b822e243c6709fe78 16f842d2a58e44ee97b71d883af20cf9 adbee8d169544f9b822e243c6709fe78--16f842d2a58e44ee97b71d883af20cf9 20c97608d7014089be1e5207aa103c8a 16f842d2a58e44ee97b71d883af20cf9--20c97608d7014089be1e5207aa103c8a ceb15859cf424d9685ed75fc2568efdb X 20c97608d7014089be1e5207aa103c8a--ceb15859cf424d9685ed75fc2568efdb ceb15859cf424d9685ed75fc2568efdb--a914a15d1d604843bda987e86f20010a 96fa182236f544a0897380e02e3340f9 RZ(-1.0*g1) ceb15859cf424d9685ed75fc2568efdb--96fa182236f544a0897380e02e3340f9 27af374cb4b844109e53cc8f38489f8a X 96fa182236f544a0897380e02e3340f9--27af374cb4b844109e53cc8f38489f8a 27af374cb4b844109e53cc8f38489f8a--ba7903091ee14cc9b591885a0436d572 c9f1653d20c242308675edb037ac93f3 27af374cb4b844109e53cc8f38489f8a--c9f1653d20c242308675edb037ac93f3 a3eb19a924494c47b54a58d8668213fb c9f1653d20c242308675edb037ac93f3--a3eb19a924494c47b54a58d8668213fb d39b1c6cffcd40de807b9f411c0f494a a3eb19a924494c47b54a58d8668213fb--d39b1c6cffcd40de807b9f411c0f494a a77fc868e5384cde9c01b42a4089967f d39b1c6cffcd40de807b9f411c0f494a--a77fc868e5384cde9c01b42a4089967f c62a688a8eb34e4f804334bc0d1dca43 a77fc868e5384cde9c01b42a4089967f--c62a688a8eb34e4f804334bc0d1dca43 d9e74008cba54cd0987bfba9499b2a17 c62a688a8eb34e4f804334bc0d1dca43--d9e74008cba54cd0987bfba9499b2a17 e2e0b7e5c04c404a93cea75cf9be7b5e X d9e74008cba54cd0987bfba9499b2a17--e2e0b7e5c04c404a93cea75cf9be7b5e e2e0b7e5c04c404a93cea75cf9be7b5e--7aceb34a81e140148c50b0a2fabca49d 0291c8ebe28a41749a902cb2734dc734 e2e0b7e5c04c404a93cea75cf9be7b5e--0291c8ebe28a41749a902cb2734dc734 faf7f2fdd27c4b81aca7afd841c8912f 0291c8ebe28a41749a902cb2734dc734--faf7f2fdd27c4b81aca7afd841c8912f 314f5feae22d4f20913a4f5b1bead3d0 faf7f2fdd27c4b81aca7afd841c8912f--314f5feae22d4f20913a4f5b1bead3d0 82f77e560bf241d4af9b0aef58a87a81 314f5feae22d4f20913a4f5b1bead3d0--82f77e560bf241d4af9b0aef58a87a81 2de71b6d4f0145de899cf217ac79f104 82f77e560bf241d4af9b0aef58a87a81--2de71b6d4f0145de899cf217ac79f104 37335b216f8e47d482dfdc288c4f8be9 X 2de71b6d4f0145de899cf217ac79f104--37335b216f8e47d482dfdc288c4f8be9 37335b216f8e47d482dfdc288c4f8be9--2bceb6d343824ccaba7728083e14e95d 1379838293e0406d8d08f357b5a0c3de 37335b216f8e47d482dfdc288c4f8be9--1379838293e0406d8d08f357b5a0c3de 78e2c26b71144ee5835f3c3ed38042c4 1379838293e0406d8d08f357b5a0c3de--78e2c26b71144ee5835f3c3ed38042c4 d6ea09d35c91422f832460a825399869 78e2c26b71144ee5835f3c3ed38042c4--d6ea09d35c91422f832460a825399869 aba1a91ef494498c8d4dd87f1b96ed8d d6ea09d35c91422f832460a825399869--aba1a91ef494498c8d4dd87f1b96ed8d 2a36cf82e9964e55a04d9dac67397b58 aba1a91ef494498c8d4dd87f1b96ed8d--2a36cf82e9964e55a04d9dac67397b58 dce628ffd5634af4bb76ff271b1ae36f 2a36cf82e9964e55a04d9dac67397b58--dce628ffd5634af4bb76ff271b1ae36f 4928992640864091a2948715b7524120 X dce628ffd5634af4bb76ff271b1ae36f--4928992640864091a2948715b7524120 4928992640864091a2948715b7524120--73fdabf5e1024201b82bf225e62c1dd5 d41e4a318baa47818c24190d97969265 4928992640864091a2948715b7524120--d41e4a318baa47818c24190d97969265 9d0db2dd81ee45e5b859f77afcfa01ed d41e4a318baa47818c24190d97969265--9d0db2dd81ee45e5b859f77afcfa01ed d92d6f0fb56445fd9e584ea2ab7c2e58 9d0db2dd81ee45e5b859f77afcfa01ed--d92d6f0fb56445fd9e584ea2ab7c2e58 83f280f08cb34a3f850ee9ebfc5d4716 d92d6f0fb56445fd9e584ea2ab7c2e58--83f280f08cb34a3f850ee9ebfc5d4716 dab62c518a9d467bb1d5efd0c8c8d02d 83f280f08cb34a3f850ee9ebfc5d4716--dab62c518a9d467bb1d5efd0c8c8d02d ff07882ec64342a9a8370781b6d1b7f4 dab62c518a9d467bb1d5efd0c8c8d02d--ff07882ec64342a9a8370781b6d1b7f4 f4528a3a8668423a8a4fa47d928e6bd9 ff07882ec64342a9a8370781b6d1b7f4--f4528a3a8668423a8a4fa47d928e6bd9 8c4d2f2d704e450ba81a1f83d69c8343 X f4528a3a8668423a8a4fa47d928e6bd9--8c4d2f2d704e450ba81a1f83d69c8343 8c4d2f2d704e450ba81a1f83d69c8343--4eefefd3808e425d86edde08e55f6903 3a319b85d914414987efabe9e353bf0a 8c4d2f2d704e450ba81a1f83d69c8343--3a319b85d914414987efabe9e353bf0a 278f215f01f34315a27f02dfa664e082 3a319b85d914414987efabe9e353bf0a--278f215f01f34315a27f02dfa664e082 c43a4b91012847c1a0d3c3fc31a36d28 278f215f01f34315a27f02dfa664e082--c43a4b91012847c1a0d3c3fc31a36d28 91edce6d8bed49689906e990d2dc43d5 c43a4b91012847c1a0d3c3fc31a36d28--91edce6d8bed49689906e990d2dc43d5 63be45ce6f0f4057924490d3690feb81 91edce6d8bed49689906e990d2dc43d5--63be45ce6f0f4057924490d3690feb81 5d8672d24ede4e44bd8bcb256ea52e4e 63be45ce6f0f4057924490d3690feb81--5d8672d24ede4e44bd8bcb256ea52e4e 883219e9de6e4cc6998c33a5686b3a50 5d8672d24ede4e44bd8bcb256ea52e4e--883219e9de6e4cc6998c33a5686b3a50 2c3ec6bec21e4e7792c4f3c0ae5a854c 883219e9de6e4cc6998c33a5686b3a50--2c3ec6bec21e4e7792c4f3c0ae5a854c 810f3bd0536342608f4e1b43d581678d 2c3ec6bec21e4e7792c4f3c0ae5a854c--810f3bd0536342608f4e1b43d581678d 76f058c65ac346cb92a064b9f7c491f3 810f3bd0536342608f4e1b43d581678d--76f058c65ac346cb92a064b9f7c491f3 46a5188c196a4bdf959a7d02d21fee6d 76f058c65ac346cb92a064b9f7c491f3--46a5188c196a4bdf959a7d02d21fee6d 72c48e23f08e42b98b437c934ab14f84 46a5188c196a4bdf959a7d02d21fee6d--72c48e23f08e42b98b437c934ab14f84 1b13d8bdc681424cbbf469306fe9a108 72c48e23f08e42b98b437c934ab14f84--1b13d8bdc681424cbbf469306fe9a108 4df6e0de026044aaad6a16e2ddbb5c01 X 1b13d8bdc681424cbbf469306fe9a108--4df6e0de026044aaad6a16e2ddbb5c01 4df6e0de026044aaad6a16e2ddbb5c01--a2c8c2f09c824fbbac0cbc67a0c99b51 21f8a28931a0425dbfacc564b98fca99 4df6e0de026044aaad6a16e2ddbb5c01--21f8a28931a0425dbfacc564b98fca99 3a655716c3cd4f83971f65f7abeca21a 21f8a28931a0425dbfacc564b98fca99--3a655716c3cd4f83971f65f7abeca21a 37968655c14540d0a68a3cf54dbada4b 3a655716c3cd4f83971f65f7abeca21a--37968655c14540d0a68a3cf54dbada4b a3d5d04832b0420c8c82390dd048a56e X 37968655c14540d0a68a3cf54dbada4b--a3d5d04832b0420c8c82390dd048a56e a3d5d04832b0420c8c82390dd048a56e--fcc15e0d95844638a4311de5f2053100 bb43b0d1a3bf43228be5ef3a4c6b306a a3d5d04832b0420c8c82390dd048a56e--bb43b0d1a3bf43228be5ef3a4c6b306a 8fcdce15973444b7bf01debe720680cd bb43b0d1a3bf43228be5ef3a4c6b306a--8fcdce15973444b7bf01debe720680cd ed72d8ee60a9436da9deededbeb0228a 8fcdce15973444b7bf01debe720680cd--ed72d8ee60a9436da9deededbeb0228a 1f6f66f7ac824a9d8bcf772fd37039c5 ed72d8ee60a9436da9deededbeb0228a--1f6f66f7ac824a9d8bcf772fd37039c5 c4dd8cb5c7c5431d9dff26a711e899cd X 1f6f66f7ac824a9d8bcf772fd37039c5--c4dd8cb5c7c5431d9dff26a711e899cd c4dd8cb5c7c5431d9dff26a711e899cd--b7651bf4f7974c41b244184e4e707605 a2a5ddbd752d4dffa56b149c1820dffe c4dd8cb5c7c5431d9dff26a711e899cd--a2a5ddbd752d4dffa56b149c1820dffe cb36ed5980114f06bacc5080525afbf3 a2a5ddbd752d4dffa56b149c1820dffe--cb36ed5980114f06bacc5080525afbf3 5fa8270bfb6e47c5bcc6506cb39d8bca cb36ed5980114f06bacc5080525afbf3--5fa8270bfb6e47c5bcc6506cb39d8bca f8654e3dd26d450186dd577a626cdc50 5fa8270bfb6e47c5bcc6506cb39d8bca--f8654e3dd26d450186dd577a626cdc50 b2b42e7cb03a407494e2a493bc1569c0 f8654e3dd26d450186dd577a626cdc50--b2b42e7cb03a407494e2a493bc1569c0 1477529e750f410cb94e1a9bbdf95040 X b2b42e7cb03a407494e2a493bc1569c0--1477529e750f410cb94e1a9bbdf95040 1477529e750f410cb94e1a9bbdf95040--13ac6f1c2bde4e0e88f9500b39472e91 f1863979a4014e4d8eb7913674f4c4d0 1477529e750f410cb94e1a9bbdf95040--f1863979a4014e4d8eb7913674f4c4d0 62d7f42fd396446bb263d10d799d6c16 f1863979a4014e4d8eb7913674f4c4d0--62d7f42fd396446bb263d10d799d6c16 78eebd3e0b844778a8a57556362776ff 62d7f42fd396446bb263d10d799d6c16--78eebd3e0b844778a8a57556362776ff be9d45d4300a41a183b1ab4567999adc X 78eebd3e0b844778a8a57556362776ff--be9d45d4300a41a183b1ab4567999adc be9d45d4300a41a183b1ab4567999adc--fea3b23fc8b04aa9be27a82b893ac374 e6a84090c0d64767b6129401a0b006de RZ(-1.0*g1) be9d45d4300a41a183b1ab4567999adc--e6a84090c0d64767b6129401a0b006de 759379f7c83f4d70978431e5112f81f6 X e6a84090c0d64767b6129401a0b006de--759379f7c83f4d70978431e5112f81f6 759379f7c83f4d70978431e5112f81f6--787079d1b85d49f0924bb581912b8c41 b63c05bd9079423485f7c330b68ab082 759379f7c83f4d70978431e5112f81f6--b63c05bd9079423485f7c330b68ab082 5faeb7e0bfcf475aa85e6f4254eca021 b63c05bd9079423485f7c330b68ab082--5faeb7e0bfcf475aa85e6f4254eca021 4e04aac70fa44185bfbacf4f5329c02a X 5faeb7e0bfcf475aa85e6f4254eca021--4e04aac70fa44185bfbacf4f5329c02a 4e04aac70fa44185bfbacf4f5329c02a--d11545906c2947cda2e833f422fcc517 057e175314d143c3aa8ddb2e08a7003b 4e04aac70fa44185bfbacf4f5329c02a--057e175314d143c3aa8ddb2e08a7003b 46656dcf4e254b43aade45310c43ce1a 057e175314d143c3aa8ddb2e08a7003b--46656dcf4e254b43aade45310c43ce1a ec866fb8a9b040dab4b90679780b589f 46656dcf4e254b43aade45310c43ce1a--ec866fb8a9b040dab4b90679780b589f 4413b250d47f4973a6377a362792d9c8 ec866fb8a9b040dab4b90679780b589f--4413b250d47f4973a6377a362792d9c8 939b354baf3642869d753b3aa4090f38 4413b250d47f4973a6377a362792d9c8--939b354baf3642869d753b3aa4090f38 6c17ee7363ee4acfb9b41a64e342223e 939b354baf3642869d753b3aa4090f38--6c17ee7363ee4acfb9b41a64e342223e fc770751ab7f45c0ab52702405931cdd 6c17ee7363ee4acfb9b41a64e342223e--fc770751ab7f45c0ab52702405931cdd 1af505989283434dbc34759dc1df82ec X fc770751ab7f45c0ab52702405931cdd--1af505989283434dbc34759dc1df82ec 1af505989283434dbc34759dc1df82ec--34b4445c16274c9288b1c4e0baa7785e 72a608acfc6a43468fa75fb0da36af38 1af505989283434dbc34759dc1df82ec--72a608acfc6a43468fa75fb0da36af38 07d1452e9aad411b941e30625db0eca1 X 72a608acfc6a43468fa75fb0da36af38--07d1452e9aad411b941e30625db0eca1 07d1452e9aad411b941e30625db0eca1--9d5227be51a14781a771df66b130c14a fc03734927194c9aa64ae99ff53994b4 07d1452e9aad411b941e30625db0eca1--fc03734927194c9aa64ae99ff53994b4 7e7561d7a07a4201ace6e7f6179858c8 fc03734927194c9aa64ae99ff53994b4--7e7561d7a07a4201ace6e7f6179858c8 ca88f4a5c4784ee697a4f359726e57c1 7e7561d7a07a4201ace6e7f6179858c8--ca88f4a5c4784ee697a4f359726e57c1 abe0fe4aabcc47ea85d830eab40104bf ca88f4a5c4784ee697a4f359726e57c1--abe0fe4aabcc47ea85d830eab40104bf c2c000c962c942ca8fdc7468549b0eab abe0fe4aabcc47ea85d830eab40104bf--c2c000c962c942ca8fdc7468549b0eab 1aae4733abe04632b4b2cdf0d41518a8 c2c000c962c942ca8fdc7468549b0eab--1aae4733abe04632b4b2cdf0d41518a8 94fdb4a8621a417bbed2bdd122cd2150 1aae4733abe04632b4b2cdf0d41518a8--94fdb4a8621a417bbed2bdd122cd2150 1c19b41662f443048af5386623c9cd49 X 94fdb4a8621a417bbed2bdd122cd2150--1c19b41662f443048af5386623c9cd49 1c19b41662f443048af5386623c9cd49--c6d4263d015d459a9041e750f91d6ee7 5f6d33a89ce344578d27e6b5c5112473 1c19b41662f443048af5386623c9cd49--5f6d33a89ce344578d27e6b5c5112473 93ce279053cc472ebfcd97debb328d93 5f6d33a89ce344578d27e6b5c5112473--93ce279053cc472ebfcd97debb328d93 5939fe8d8e7a4a9daa80dd35e16b54a1 93ce279053cc472ebfcd97debb328d93--5939fe8d8e7a4a9daa80dd35e16b54a1 bb6e413123d34659a0953d411813b981 5939fe8d8e7a4a9daa80dd35e16b54a1--bb6e413123d34659a0953d411813b981 9558e3d4c668490db213da2f70be68e1 bb6e413123d34659a0953d411813b981--9558e3d4c668490db213da2f70be68e1 5b8f5da82b1f44bfb166488dcc0b368f 9558e3d4c668490db213da2f70be68e1--5b8f5da82b1f44bfb166488dcc0b368f c3a50cb8f55f4677adbcc429b165e2ed 5b8f5da82b1f44bfb166488dcc0b368f--c3a50cb8f55f4677adbcc429b165e2ed 6679bd0c07c64e9b9d1f8aba5f557be7 c3a50cb8f55f4677adbcc429b165e2ed--6679bd0c07c64e9b9d1f8aba5f557be7 8eaff5fbacad4525a863885ae02abf4a RX(b14) 6679bd0c07c64e9b9d1f8aba5f557be7--8eaff5fbacad4525a863885ae02abf4a 8eaff5fbacad4525a863885ae02abf4a--37bd554896c64e1980ea3b8012506c2f 6b03800386644bdb92468972ca956e1a aa3d6a9feb72414bb8e3df4d861085b5 dbea92f6179240859bb5837c61e84eac--aa3d6a9feb72414bb8e3df4d861085b5 65da79fcd7004fce88da04ee6953410f 6 444b838dde6a4a2a9776a88cc3661fe4 aa3d6a9feb72414bb8e3df4d861085b5--444b838dde6a4a2a9776a88cc3661fe4 24ceff976d634f60849574661855c291 444b838dde6a4a2a9776a88cc3661fe4--24ceff976d634f60849574661855c291 a35d10a35f0947e884229e24e26126f8 24ceff976d634f60849574661855c291--a35d10a35f0947e884229e24e26126f8 a853fda43c82411584ba20f19b843612 X a35d10a35f0947e884229e24e26126f8--a853fda43c82411584ba20f19b843612 a853fda43c82411584ba20f19b843612--9a25a3b6caef41acb9670037193f9c9b 666d9d37729f47b09d14c7b4261c266d a853fda43c82411584ba20f19b843612--666d9d37729f47b09d14c7b4261c266d beca3580ed94437399e2f0bb1c15462f 666d9d37729f47b09d14c7b4261c266d--beca3580ed94437399e2f0bb1c15462f 82cc608a220f426bb7c7eb89ec140c97 beca3580ed94437399e2f0bb1c15462f--82cc608a220f426bb7c7eb89ec140c97 366986c4478d41528da94c74fadd3907 82cc608a220f426bb7c7eb89ec140c97--366986c4478d41528da94c74fadd3907 28d65a298a1047ee92cef8d5c51f1aaa 366986c4478d41528da94c74fadd3907--28d65a298a1047ee92cef8d5c51f1aaa 95bf06a81d5b42019195d34d53403296 X 28d65a298a1047ee92cef8d5c51f1aaa--95bf06a81d5b42019195d34d53403296 95bf06a81d5b42019195d34d53403296--919bcd3a51a0435fb27de1cf89e523f3 6d185b82374841149201b260be79f0dd 95bf06a81d5b42019195d34d53403296--6d185b82374841149201b260be79f0dd 40c737157b6a493e9ba86c0ae9f2d50d 6d185b82374841149201b260be79f0dd--40c737157b6a493e9ba86c0ae9f2d50d 7bcc434b3cb5414683f28d628b62c237 40c737157b6a493e9ba86c0ae9f2d50d--7bcc434b3cb5414683f28d628b62c237 bdec2cb527ae4e068b5ddeb730b2428d 7bcc434b3cb5414683f28d628b62c237--bdec2cb527ae4e068b5ddeb730b2428d 7a8a87681a28468e8b2ff851cd860c0e bdec2cb527ae4e068b5ddeb730b2428d--7a8a87681a28468e8b2ff851cd860c0e 09d4bee0a043450e9b38ebfef4ac44f8 7a8a87681a28468e8b2ff851cd860c0e--09d4bee0a043450e9b38ebfef4ac44f8 e9f493eff5a24b33b6df35edaccdc8a2 09d4bee0a043450e9b38ebfef4ac44f8--e9f493eff5a24b33b6df35edaccdc8a2 961e42dd3aca48e791a9a8dd12800ba1 e9f493eff5a24b33b6df35edaccdc8a2--961e42dd3aca48e791a9a8dd12800ba1 1311f1f52fe0441ea6ee9910533ae10d 961e42dd3aca48e791a9a8dd12800ba1--1311f1f52fe0441ea6ee9910533ae10d 91202cb4d11a461fa3333d2e529a5307 1311f1f52fe0441ea6ee9910533ae10d--91202cb4d11a461fa3333d2e529a5307 6614d1e8ca924d428be96a80b7840c68 91202cb4d11a461fa3333d2e529a5307--6614d1e8ca924d428be96a80b7840c68 046f69eee5ae4d4ab090bbc3146e642f 6614d1e8ca924d428be96a80b7840c68--046f69eee5ae4d4ab090bbc3146e642f caf67f28d4654df3a5b1c158f290063e 046f69eee5ae4d4ab090bbc3146e642f--caf67f28d4654df3a5b1c158f290063e 04d69c3eb6164b7fa9cafd956c8be409 caf67f28d4654df3a5b1c158f290063e--04d69c3eb6164b7fa9cafd956c8be409 4e740c67dfe045cfbfdd6a639abac615 04d69c3eb6164b7fa9cafd956c8be409--4e740c67dfe045cfbfdd6a639abac615 3bc5c947e95d4c6e9b396b7e430fb894 4e740c67dfe045cfbfdd6a639abac615--3bc5c947e95d4c6e9b396b7e430fb894 86f3dcdc062a4cb5b8da5b7cf0878219 3bc5c947e95d4c6e9b396b7e430fb894--86f3dcdc062a4cb5b8da5b7cf0878219 62f22b08e7094f0088f82a88ecdc70ce 86f3dcdc062a4cb5b8da5b7cf0878219--62f22b08e7094f0088f82a88ecdc70ce 521b2f176977480f862b873781862577 62f22b08e7094f0088f82a88ecdc70ce--521b2f176977480f862b873781862577 ffb10bed85ca4157a572b1676bc8a811 521b2f176977480f862b873781862577--ffb10bed85ca4157a572b1676bc8a811 3aeccf7b7e0044a491bd7076135614c3 ffb10bed85ca4157a572b1676bc8a811--3aeccf7b7e0044a491bd7076135614c3 1f8b907cb50e47cb87302dd4aefd2bcf 3aeccf7b7e0044a491bd7076135614c3--1f8b907cb50e47cb87302dd4aefd2bcf 738b1e7dc9114143b0a0f42961e09465 1f8b907cb50e47cb87302dd4aefd2bcf--738b1e7dc9114143b0a0f42961e09465 fbb52920ab7948e7b24e5455673603d4 738b1e7dc9114143b0a0f42961e09465--fbb52920ab7948e7b24e5455673603d4 3c159890fb904d55b973f10706de12d6 fbb52920ab7948e7b24e5455673603d4--3c159890fb904d55b973f10706de12d6 7e12e92fdc644202a735dcd2b11fc576 3c159890fb904d55b973f10706de12d6--7e12e92fdc644202a735dcd2b11fc576 5bb96b5ad2044f39a95cf240fa18588f 7e12e92fdc644202a735dcd2b11fc576--5bb96b5ad2044f39a95cf240fa18588f dc4815eb7be34fdcb1945c650c9fd19d 5bb96b5ad2044f39a95cf240fa18588f--dc4815eb7be34fdcb1945c650c9fd19d 9e21dcd97b7047f0abd2e99d9eaf1f14 dc4815eb7be34fdcb1945c650c9fd19d--9e21dcd97b7047f0abd2e99d9eaf1f14 0c8064acfbfb4836bef62bb760e0aa6e 9e21dcd97b7047f0abd2e99d9eaf1f14--0c8064acfbfb4836bef62bb760e0aa6e c21e518636f34641a9e6857a25eab603 0c8064acfbfb4836bef62bb760e0aa6e--c21e518636f34641a9e6857a25eab603 79f4f52c53764bdd8959a1f10e369f08 c21e518636f34641a9e6857a25eab603--79f4f52c53764bdd8959a1f10e369f08 2ff1a33a3f93428f895c35a744ec2292 X 79f4f52c53764bdd8959a1f10e369f08--2ff1a33a3f93428f895c35a744ec2292 2ff1a33a3f93428f895c35a744ec2292--b9ec4192872f4db9afd039415c8b8a2b b78c1909dfe84e5ebdd805f3a699e11f 2ff1a33a3f93428f895c35a744ec2292--b78c1909dfe84e5ebdd805f3a699e11f f2aa932c3f364209a49a3eba9e2bf386 b78c1909dfe84e5ebdd805f3a699e11f--f2aa932c3f364209a49a3eba9e2bf386 2af864c02b434856a25d950b7a9a8189 f2aa932c3f364209a49a3eba9e2bf386--2af864c02b434856a25d950b7a9a8189 8613607d38324b71a18360514e18d349 X 2af864c02b434856a25d950b7a9a8189--8613607d38324b71a18360514e18d349 8613607d38324b71a18360514e18d349--686f7482d5ee42929b028eff9943723c f45150c3a4f243da95352f424350cbcb 8613607d38324b71a18360514e18d349--f45150c3a4f243da95352f424350cbcb df457f2376144a7db28a2c609ca19a17 f45150c3a4f243da95352f424350cbcb--df457f2376144a7db28a2c609ca19a17 2d999d9cf5634f6cb766b50cff06c002 df457f2376144a7db28a2c609ca19a17--2d999d9cf5634f6cb766b50cff06c002 bead29c1516b4d3ba7ec111f17c0dcb1 2d999d9cf5634f6cb766b50cff06c002--bead29c1516b4d3ba7ec111f17c0dcb1 e0db09ad02f84435887eca83f0f432bd bead29c1516b4d3ba7ec111f17c0dcb1--e0db09ad02f84435887eca83f0f432bd 0840f253b9134f8aa26970c82e9489cb e0db09ad02f84435887eca83f0f432bd--0840f253b9134f8aa26970c82e9489cb ee4126279dd24dc8badc9773839e6316 0840f253b9134f8aa26970c82e9489cb--ee4126279dd24dc8badc9773839e6316 e71fb758d3bd4e8b86538ff366683167 ee4126279dd24dc8badc9773839e6316--e71fb758d3bd4e8b86538ff366683167 65c53c1e454743868857de262b556357 X e71fb758d3bd4e8b86538ff366683167--65c53c1e454743868857de262b556357 65c53c1e454743868857de262b556357--39a600f349c24aee90991e2d3d62ca13 f4097401d6704ef391e91e4be6f70fa0 65c53c1e454743868857de262b556357--f4097401d6704ef391e91e4be6f70fa0 5686a82fb8e5402db87c996bb983d2a1 f4097401d6704ef391e91e4be6f70fa0--5686a82fb8e5402db87c996bb983d2a1 36cf6c636f814bca8731963d995c016e 5686a82fb8e5402db87c996bb983d2a1--36cf6c636f814bca8731963d995c016e 8f3fc74540174d179fc983bb087e8cd2 36cf6c636f814bca8731963d995c016e--8f3fc74540174d179fc983bb087e8cd2 f7cbbff8bdd3439a9bcc9567cac7f894 8f3fc74540174d179fc983bb087e8cd2--f7cbbff8bdd3439a9bcc9567cac7f894 5fa9638545d54a1eae745023e3f251c7 X f7cbbff8bdd3439a9bcc9567cac7f894--5fa9638545d54a1eae745023e3f251c7 5fa9638545d54a1eae745023e3f251c7--da8e3f4446da4e668df325533fa0f56c 2249dbb3e2f34e0985c71e01a1372062 5fa9638545d54a1eae745023e3f251c7--2249dbb3e2f34e0985c71e01a1372062 14ad3a3d75f9403699806ffa2968598e 2249dbb3e2f34e0985c71e01a1372062--14ad3a3d75f9403699806ffa2968598e bfdf4f0c885440cfbbf0e5db231f059c 14ad3a3d75f9403699806ffa2968598e--bfdf4f0c885440cfbbf0e5db231f059c dd0112c5d09d463883595303c8b7112f bfdf4f0c885440cfbbf0e5db231f059c--dd0112c5d09d463883595303c8b7112f 497ba450f65b4dd999f376729ea38bff dd0112c5d09d463883595303c8b7112f--497ba450f65b4dd999f376729ea38bff f3138d103a444748a1c867e03510525f 497ba450f65b4dd999f376729ea38bff--f3138d103a444748a1c867e03510525f 2005f6edb328470b997e0ebd6f780f7b f3138d103a444748a1c867e03510525f--2005f6edb328470b997e0ebd6f780f7b 89d48ac65b1b434ab92bd903f66e7b3b 2005f6edb328470b997e0ebd6f780f7b--89d48ac65b1b434ab92bd903f66e7b3b da6e9e805a2648c692d26b5ed7aab244 89d48ac65b1b434ab92bd903f66e7b3b--da6e9e805a2648c692d26b5ed7aab244 7eb3ede2f532423f803d2cfbb8460fa4 da6e9e805a2648c692d26b5ed7aab244--7eb3ede2f532423f803d2cfbb8460fa4 dbf3f54162c047238b1eeb22f1ed48b5 7eb3ede2f532423f803d2cfbb8460fa4--dbf3f54162c047238b1eeb22f1ed48b5 09c43fbf9d70440989a39441d9638576 dbf3f54162c047238b1eeb22f1ed48b5--09c43fbf9d70440989a39441d9638576 e4705b618e5643fd996c78c0ab5f3f6b 09c43fbf9d70440989a39441d9638576--e4705b618e5643fd996c78c0ab5f3f6b 54138ce134674541bbcce55f47760bdb e4705b618e5643fd996c78c0ab5f3f6b--54138ce134674541bbcce55f47760bdb 8e3be311031045c5a817c0adf9593003 54138ce134674541bbcce55f47760bdb--8e3be311031045c5a817c0adf9593003 899278416db949acbd7927e6d2388fa9 X 8e3be311031045c5a817c0adf9593003--899278416db949acbd7927e6d2388fa9 899278416db949acbd7927e6d2388fa9--a238d18aac2d4d14826737c6d48e4fcd d7562c47d38e40bcb4036c912caf7c39 RZ(-1.0*g0) 899278416db949acbd7927e6d2388fa9--d7562c47d38e40bcb4036c912caf7c39 1d3f741ede694817ae102e3b841bcbd5 X d7562c47d38e40bcb4036c912caf7c39--1d3f741ede694817ae102e3b841bcbd5 1d3f741ede694817ae102e3b841bcbd5--187ee13a72974b1b99752fd143717f1c 0f6968c82ea443a39a5f955b5f370e7d 1d3f741ede694817ae102e3b841bcbd5--0f6968c82ea443a39a5f955b5f370e7d cc7006839931420d83d16bf9d05689ea 0f6968c82ea443a39a5f955b5f370e7d--cc7006839931420d83d16bf9d05689ea b89ed0bf69934107a8f4153740f60ff8 cc7006839931420d83d16bf9d05689ea--b89ed0bf69934107a8f4153740f60ff8 38e512016d0446ee8c8276748f600677 b89ed0bf69934107a8f4153740f60ff8--38e512016d0446ee8c8276748f600677 b015789edf2542668fdab6640475d08c 38e512016d0446ee8c8276748f600677--b015789edf2542668fdab6640475d08c 5c7ddb83cb2641d0b48995285a4bcc96 b015789edf2542668fdab6640475d08c--5c7ddb83cb2641d0b48995285a4bcc96 26f1ce581d794db6a79767adb640a1de X 5c7ddb83cb2641d0b48995285a4bcc96--26f1ce581d794db6a79767adb640a1de 26f1ce581d794db6a79767adb640a1de--a7e12c781b7748e3894d4065d968319a 8c5a372e78044a7790e5bb609e76815d 26f1ce581d794db6a79767adb640a1de--8c5a372e78044a7790e5bb609e76815d a3dcbd4991b84fceb347cbbc83a6c06e 8c5a372e78044a7790e5bb609e76815d--a3dcbd4991b84fceb347cbbc83a6c06e f8d48b09220d433697c00c4f57dcad87 a3dcbd4991b84fceb347cbbc83a6c06e--f8d48b09220d433697c00c4f57dcad87 712ae23f3a4844408487f2e7a4ed29e1 X f8d48b09220d433697c00c4f57dcad87--712ae23f3a4844408487f2e7a4ed29e1 712ae23f3a4844408487f2e7a4ed29e1--17df66296c07432992c7b9bf1f4a25ff 0000c70b47a34fb2b3f8c2b546970b64 712ae23f3a4844408487f2e7a4ed29e1--0000c70b47a34fb2b3f8c2b546970b64 0324f6d73ff54234b3d4e3e42a676c42 0000c70b47a34fb2b3f8c2b546970b64--0324f6d73ff54234b3d4e3e42a676c42 2b78878004c34eab9cbed3c640613bb6 0324f6d73ff54234b3d4e3e42a676c42--2b78878004c34eab9cbed3c640613bb6 3c813d543c5145a48f12e96f9401d9b2 2b78878004c34eab9cbed3c640613bb6--3c813d543c5145a48f12e96f9401d9b2 ce04e76e4214443cb6ac36fbddb9215e 3c813d543c5145a48f12e96f9401d9b2--ce04e76e4214443cb6ac36fbddb9215e 4a64c0a743964560a9dd9c6be69e7a8d ce04e76e4214443cb6ac36fbddb9215e--4a64c0a743964560a9dd9c6be69e7a8d 090abad9b4c948d1bdbaa0ab4db31caf 4a64c0a743964560a9dd9c6be69e7a8d--090abad9b4c948d1bdbaa0ab4db31caf 4fba9e6581c941a49c797afb2e6f25ef 090abad9b4c948d1bdbaa0ab4db31caf--4fba9e6581c941a49c797afb2e6f25ef 24026d108f8047bdbaf1cffe5ada4e87 4fba9e6581c941a49c797afb2e6f25ef--24026d108f8047bdbaf1cffe5ada4e87 d77ba06eca3947cd9613de7d64374579 24026d108f8047bdbaf1cffe5ada4e87--d77ba06eca3947cd9613de7d64374579 def26b6506604e599eac6cf8d40815c0 X d77ba06eca3947cd9613de7d64374579--def26b6506604e599eac6cf8d40815c0 def26b6506604e599eac6cf8d40815c0--244ffa2c6e8e436c8d4ade28460ed7c1 20bfd019eefb4c418f144fbc0e5b5fa4 def26b6506604e599eac6cf8d40815c0--20bfd019eefb4c418f144fbc0e5b5fa4 05a0437e2e164e04819ab2fe6d41b79a 20bfd019eefb4c418f144fbc0e5b5fa4--05a0437e2e164e04819ab2fe6d41b79a 8dd91c80e4734affb6d4e80306000fa6 05a0437e2e164e04819ab2fe6d41b79a--8dd91c80e4734affb6d4e80306000fa6 0811f55270b047fb9092b9ae7cf79bcc 8dd91c80e4734affb6d4e80306000fa6--0811f55270b047fb9092b9ae7cf79bcc 3a0c8795a24549f2ab5e97390a7e1e56 0811f55270b047fb9092b9ae7cf79bcc--3a0c8795a24549f2ab5e97390a7e1e56 d9376d59cf49472a9a5d4cbff5459308 X 3a0c8795a24549f2ab5e97390a7e1e56--d9376d59cf49472a9a5d4cbff5459308 d9376d59cf49472a9a5d4cbff5459308--8a6d3aa1a6024e759be9eb2284e36b46 20ee87ea081245879c3ea7ed5634102f d9376d59cf49472a9a5d4cbff5459308--20ee87ea081245879c3ea7ed5634102f d17edc4198e74206a7cadb7125d4e87a 20ee87ea081245879c3ea7ed5634102f--d17edc4198e74206a7cadb7125d4e87a 1df1990a1aeb47beb94b76282bc27fd5 d17edc4198e74206a7cadb7125d4e87a--1df1990a1aeb47beb94b76282bc27fd5 4f9e232c362c49adac7a07a6281d8cec X 1df1990a1aeb47beb94b76282bc27fd5--4f9e232c362c49adac7a07a6281d8cec 4f9e232c362c49adac7a07a6281d8cec--34c3ac379f784d0fb56784ebba81cff3 475771e1ce37498f81bf95bd41476e0a 4f9e232c362c49adac7a07a6281d8cec--475771e1ce37498f81bf95bd41476e0a 90a2a79465d14e58926198861e904e15 475771e1ce37498f81bf95bd41476e0a--90a2a79465d14e58926198861e904e15 e30f2e249756403a962b264aba7fc2a8 90a2a79465d14e58926198861e904e15--e30f2e249756403a962b264aba7fc2a8 0c88acb6690a4775b4a9c958f0106d63 e30f2e249756403a962b264aba7fc2a8--0c88acb6690a4775b4a9c958f0106d63 bb0c0c1bf509465fa3d8d11e52d6a4c0 0c88acb6690a4775b4a9c958f0106d63--bb0c0c1bf509465fa3d8d11e52d6a4c0 e3bc8fe19d164a2c8165c13317b30740 X bb0c0c1bf509465fa3d8d11e52d6a4c0--e3bc8fe19d164a2c8165c13317b30740 e3bc8fe19d164a2c8165c13317b30740--b4cf916215fc4caaac58642b2606ea57 c4a2b08d595c4246aeb522b8382e20cd e3bc8fe19d164a2c8165c13317b30740--c4a2b08d595c4246aeb522b8382e20cd e93347eea7a84b1a940708c2a3a470f3 X c4a2b08d595c4246aeb522b8382e20cd--e93347eea7a84b1a940708c2a3a470f3 e93347eea7a84b1a940708c2a3a470f3--453f00d5d7b54f5b9b26f996f1c6c2c0 56d30a2804ef46c08e9c0123ceb56e17 e93347eea7a84b1a940708c2a3a470f3--56d30a2804ef46c08e9c0123ceb56e17 03943b76eebb4575ae035d4d44b58383 56d30a2804ef46c08e9c0123ceb56e17--03943b76eebb4575ae035d4d44b58383 d5168f538b7d4b6fbfb235e9efbbe826 03943b76eebb4575ae035d4d44b58383--d5168f538b7d4b6fbfb235e9efbbe826 ac8c5a08b20a4a3a8293556a8e5b52ac X d5168f538b7d4b6fbfb235e9efbbe826--ac8c5a08b20a4a3a8293556a8e5b52ac ac8c5a08b20a4a3a8293556a8e5b52ac--2833a2e2002f4d918f920c5278c93647 d174c69325d14f7280d3d94d5d41d621 ac8c5a08b20a4a3a8293556a8e5b52ac--d174c69325d14f7280d3d94d5d41d621 becd56edbaec4a1d98d0ae4583c32e68 d174c69325d14f7280d3d94d5d41d621--becd56edbaec4a1d98d0ae4583c32e68 0bc7c95a6bb34391ba4a5844bc6b3a9c becd56edbaec4a1d98d0ae4583c32e68--0bc7c95a6bb34391ba4a5844bc6b3a9c d46c769cde404ca88840d59defdca148 RX(b05) 0bc7c95a6bb34391ba4a5844bc6b3a9c--d46c769cde404ca88840d59defdca148 35fb781ce4e249349393af2d386ca5da d46c769cde404ca88840d59defdca148--35fb781ce4e249349393af2d386ca5da 88ecc5319f7042dcb6bf8b71316bde94 35fb781ce4e249349393af2d386ca5da--88ecc5319f7042dcb6bf8b71316bde94 fc21beecd65f4d8d8e1eedd2c40275fd 88ecc5319f7042dcb6bf8b71316bde94--fc21beecd65f4d8d8e1eedd2c40275fd 2ba575a7c76742348ce6de088bea8fe4 fc21beecd65f4d8d8e1eedd2c40275fd--2ba575a7c76742348ce6de088bea8fe4 4d53b89f767e407d82388c58a7cf93dc X 2ba575a7c76742348ce6de088bea8fe4--4d53b89f767e407d82388c58a7cf93dc 4d53b89f767e407d82388c58a7cf93dc--8909d9f882294b1eaea9ba30e12789ef 900edea14f5643fdb35d0dfe165716a3 4d53b89f767e407d82388c58a7cf93dc--900edea14f5643fdb35d0dfe165716a3 4865f77ca5c94e669c00c7d778341187 900edea14f5643fdb35d0dfe165716a3--4865f77ca5c94e669c00c7d778341187 0e86dcd0d4fe452a99c6824c7b2a049d 4865f77ca5c94e669c00c7d778341187--0e86dcd0d4fe452a99c6824c7b2a049d 25393b473d0d4e5d84069ed920e721a0 0e86dcd0d4fe452a99c6824c7b2a049d--25393b473d0d4e5d84069ed920e721a0 7d6b24d06e3e470a8fc2af1dee6ebb08 25393b473d0d4e5d84069ed920e721a0--7d6b24d06e3e470a8fc2af1dee6ebb08 83e2cb83e1bf4922a1cfd502476ee17f X 7d6b24d06e3e470a8fc2af1dee6ebb08--83e2cb83e1bf4922a1cfd502476ee17f 83e2cb83e1bf4922a1cfd502476ee17f--ba155d53c37c4c1791deb06743b0326c 8067db0a34294374858f229aa37d6735 83e2cb83e1bf4922a1cfd502476ee17f--8067db0a34294374858f229aa37d6735 3c1d85ca3dfb4783bf134e2a60f7c3fc 8067db0a34294374858f229aa37d6735--3c1d85ca3dfb4783bf134e2a60f7c3fc f58cd379d6bd409db9365c8c31224bb9 3c1d85ca3dfb4783bf134e2a60f7c3fc--f58cd379d6bd409db9365c8c31224bb9 80e7bb9be87f4bffa325229c4c6a729b f58cd379d6bd409db9365c8c31224bb9--80e7bb9be87f4bffa325229c4c6a729b 5cc16fdffb7a4bdfbb3c04b8f50af42f 80e7bb9be87f4bffa325229c4c6a729b--5cc16fdffb7a4bdfbb3c04b8f50af42f 96f3c045e3594c8c919ebd1505b1ae0d 5cc16fdffb7a4bdfbb3c04b8f50af42f--96f3c045e3594c8c919ebd1505b1ae0d 1e4390449d2b4ffbbfc23ff0e6bd9d01 96f3c045e3594c8c919ebd1505b1ae0d--1e4390449d2b4ffbbfc23ff0e6bd9d01 d795b79d092a4d23a75f10a99a887bd1 1e4390449d2b4ffbbfc23ff0e6bd9d01--d795b79d092a4d23a75f10a99a887bd1 6a6b4624b3e340da9aa6a63ad32a77ea d795b79d092a4d23a75f10a99a887bd1--6a6b4624b3e340da9aa6a63ad32a77ea 452e120f684a42a2b7faa8ad2a50ec76 6a6b4624b3e340da9aa6a63ad32a77ea--452e120f684a42a2b7faa8ad2a50ec76 1625de6663e54d47808cc7e2fdc069cc 452e120f684a42a2b7faa8ad2a50ec76--1625de6663e54d47808cc7e2fdc069cc 62a36c577159460bb3e75cc8f39c3d19 1625de6663e54d47808cc7e2fdc069cc--62a36c577159460bb3e75cc8f39c3d19 c76a2aba718c47a2b51fbe59bdd840aa 62a36c577159460bb3e75cc8f39c3d19--c76a2aba718c47a2b51fbe59bdd840aa e8d7e7bf92664d909ff2905467b1ab0d c76a2aba718c47a2b51fbe59bdd840aa--e8d7e7bf92664d909ff2905467b1ab0d 114390d1d4704050819700f57edcfac6 e8d7e7bf92664d909ff2905467b1ab0d--114390d1d4704050819700f57edcfac6 ff4326d3feda4149b651c240607437bf 114390d1d4704050819700f57edcfac6--ff4326d3feda4149b651c240607437bf d8039ab0c8044df98a9c3362accb244d ff4326d3feda4149b651c240607437bf--d8039ab0c8044df98a9c3362accb244d 0a1c9ad783b94b0688fbe2d043f19266 d8039ab0c8044df98a9c3362accb244d--0a1c9ad783b94b0688fbe2d043f19266 b63fe396ed3f4869be8785dc83387949 0a1c9ad783b94b0688fbe2d043f19266--b63fe396ed3f4869be8785dc83387949 743c6477b00d45bf9f9b3a6c087f4a54 b63fe396ed3f4869be8785dc83387949--743c6477b00d45bf9f9b3a6c087f4a54 2564e313c5d84af6b7361e3056cc7b36 743c6477b00d45bf9f9b3a6c087f4a54--2564e313c5d84af6b7361e3056cc7b36 53e81e8adc714966a165c6f6e14fad80 2564e313c5d84af6b7361e3056cc7b36--53e81e8adc714966a165c6f6e14fad80 818c797346304d668629e4963cea43bd 53e81e8adc714966a165c6f6e14fad80--818c797346304d668629e4963cea43bd a18b87dac0e443c4b60a17fa6207dfa9 818c797346304d668629e4963cea43bd--a18b87dac0e443c4b60a17fa6207dfa9 6eb4337447284d10959ee46118a13bfd a18b87dac0e443c4b60a17fa6207dfa9--6eb4337447284d10959ee46118a13bfd d2c4f3325f0b4f8784ba0af49a1c59d4 6eb4337447284d10959ee46118a13bfd--d2c4f3325f0b4f8784ba0af49a1c59d4 97a3849db0e44e20bd4fbc70b6ff160e d2c4f3325f0b4f8784ba0af49a1c59d4--97a3849db0e44e20bd4fbc70b6ff160e 94b445a15b4f432fac729f8c30bbd31c 97a3849db0e44e20bd4fbc70b6ff160e--94b445a15b4f432fac729f8c30bbd31c 4f3c685232f640fdb4c8e3261f08a011 94b445a15b4f432fac729f8c30bbd31c--4f3c685232f640fdb4c8e3261f08a011 5cddd614e9f2407aa8918c9771811bd6 4f3c685232f640fdb4c8e3261f08a011--5cddd614e9f2407aa8918c9771811bd6 42cf2ca4b37c45cebd5762474aa629de 5cddd614e9f2407aa8918c9771811bd6--42cf2ca4b37c45cebd5762474aa629de 6105ad7c62e74de6a36033845128b4cc 42cf2ca4b37c45cebd5762474aa629de--6105ad7c62e74de6a36033845128b4cc 2fcbec05eff541e3a46d9850c469506f X 6105ad7c62e74de6a36033845128b4cc--2fcbec05eff541e3a46d9850c469506f 2fcbec05eff541e3a46d9850c469506f--0291c8ebe28a41749a902cb2734dc734 6a9ca7b080a941bab39a36de1686919c 2fcbec05eff541e3a46d9850c469506f--6a9ca7b080a941bab39a36de1686919c 0330e8b2a8ba40758fe50f8c705e9ae4 6a9ca7b080a941bab39a36de1686919c--0330e8b2a8ba40758fe50f8c705e9ae4 289bbd7b56484a608d5dec52aea38f46 0330e8b2a8ba40758fe50f8c705e9ae4--289bbd7b56484a608d5dec52aea38f46 22c37f7f3bd24a78b265fdd48346fcd4 X 289bbd7b56484a608d5dec52aea38f46--22c37f7f3bd24a78b265fdd48346fcd4 22c37f7f3bd24a78b265fdd48346fcd4--2de71b6d4f0145de899cf217ac79f104 8ae4f09d66654deeb0412c65e5dd58aa 22c37f7f3bd24a78b265fdd48346fcd4--8ae4f09d66654deeb0412c65e5dd58aa b4b671a9b1194c43a106adbe6ff0a7d3 8ae4f09d66654deeb0412c65e5dd58aa--b4b671a9b1194c43a106adbe6ff0a7d3 0b01a4cb5cc041aca2dcd416ff80cb4b b4b671a9b1194c43a106adbe6ff0a7d3--0b01a4cb5cc041aca2dcd416ff80cb4b 3640107b77c948398bbd40c411cf1bd3 0b01a4cb5cc041aca2dcd416ff80cb4b--3640107b77c948398bbd40c411cf1bd3 c342c4f3b90744ac97cca19aa6b87670 3640107b77c948398bbd40c411cf1bd3--c342c4f3b90744ac97cca19aa6b87670 a43c14b0ef4b4407b41c203863f977b2 c342c4f3b90744ac97cca19aa6b87670--a43c14b0ef4b4407b41c203863f977b2 cdfdf24f877c4e878e06db8b7afc8138 a43c14b0ef4b4407b41c203863f977b2--cdfdf24f877c4e878e06db8b7afc8138 09d534977c6d488388c574183d19c178 cdfdf24f877c4e878e06db8b7afc8138--09d534977c6d488388c574183d19c178 3ffdc246ef684624aa94e71145a94024 X 09d534977c6d488388c574183d19c178--3ffdc246ef684624aa94e71145a94024 3ffdc246ef684624aa94e71145a94024--d41e4a318baa47818c24190d97969265 d68b60c8b45a4d1f916b36dd0a6adedc 3ffdc246ef684624aa94e71145a94024--d68b60c8b45a4d1f916b36dd0a6adedc 7f2ca94b94f2433496488a45beccbd1d d68b60c8b45a4d1f916b36dd0a6adedc--7f2ca94b94f2433496488a45beccbd1d cd077c2073b24c0186f1c4f80e5aae49 7f2ca94b94f2433496488a45beccbd1d--cd077c2073b24c0186f1c4f80e5aae49 ababa83fdc934c25b6c89caf7853618d cd077c2073b24c0186f1c4f80e5aae49--ababa83fdc934c25b6c89caf7853618d 73bcf8286870464ebc1c5a731f2dfe95 ababa83fdc934c25b6c89caf7853618d--73bcf8286870464ebc1c5a731f2dfe95 ef0eb08b99134448bd07c53116a524a0 X 73bcf8286870464ebc1c5a731f2dfe95--ef0eb08b99134448bd07c53116a524a0 ef0eb08b99134448bd07c53116a524a0--f4528a3a8668423a8a4fa47d928e6bd9 74b01b57ab974d7ba3c08c41a5d30851 ef0eb08b99134448bd07c53116a524a0--74b01b57ab974d7ba3c08c41a5d30851 3400ada671ea4b87811445c23cdf5f5c 74b01b57ab974d7ba3c08c41a5d30851--3400ada671ea4b87811445c23cdf5f5c feb4d3d795034c3b851be5e714dab630 3400ada671ea4b87811445c23cdf5f5c--feb4d3d795034c3b851be5e714dab630 dfc31ca7b7f94a92905e79ed3be46ebb feb4d3d795034c3b851be5e714dab630--dfc31ca7b7f94a92905e79ed3be46ebb 3b3d176d8ddb4f3fabe90133bd5caa47 dfc31ca7b7f94a92905e79ed3be46ebb--3b3d176d8ddb4f3fabe90133bd5caa47 dda4c3ea74d24cb1951d59eb96135cd1 3b3d176d8ddb4f3fabe90133bd5caa47--dda4c3ea74d24cb1951d59eb96135cd1 8b25c1e1e811482cb4438554263fbfaa dda4c3ea74d24cb1951d59eb96135cd1--8b25c1e1e811482cb4438554263fbfaa 47e520a5135c4115af2b6eae124bd97e 8b25c1e1e811482cb4438554263fbfaa--47e520a5135c4115af2b6eae124bd97e 3952e1361bf84e3cb809ca380528d940 47e520a5135c4115af2b6eae124bd97e--3952e1361bf84e3cb809ca380528d940 638f2f4d791a4dcf83039549acbde173 3952e1361bf84e3cb809ca380528d940--638f2f4d791a4dcf83039549acbde173 50ef830921684999a04fc5f2f06a347c 638f2f4d791a4dcf83039549acbde173--50ef830921684999a04fc5f2f06a347c eafec72b4907417f85d194bc62df685a 50ef830921684999a04fc5f2f06a347c--eafec72b4907417f85d194bc62df685a 5c57d5053b13479a92fa8f3df9536af7 eafec72b4907417f85d194bc62df685a--5c57d5053b13479a92fa8f3df9536af7 e71315511ece42c1bb827336a5acee23 5c57d5053b13479a92fa8f3df9536af7--e71315511ece42c1bb827336a5acee23 221e844902944a3ab2f1305d789d83c8 e71315511ece42c1bb827336a5acee23--221e844902944a3ab2f1305d789d83c8 c44fa91eda574944a906a5fecb24b754 X 221e844902944a3ab2f1305d789d83c8--c44fa91eda574944a906a5fecb24b754 c44fa91eda574944a906a5fecb24b754--21f8a28931a0425dbfacc564b98fca99 04dc9ea5c6cb4f22afb2fc9dc9465678 RZ(-1.0*g1) c44fa91eda574944a906a5fecb24b754--04dc9ea5c6cb4f22afb2fc9dc9465678 f03eb0508f4e4f598163e356ae395035 X 04dc9ea5c6cb4f22afb2fc9dc9465678--f03eb0508f4e4f598163e356ae395035 f03eb0508f4e4f598163e356ae395035--37968655c14540d0a68a3cf54dbada4b 5e9263e52b974f33ba3fa26e99569ba0 f03eb0508f4e4f598163e356ae395035--5e9263e52b974f33ba3fa26e99569ba0 9c34af29e17a43c1a922a44447c8e782 5e9263e52b974f33ba3fa26e99569ba0--9c34af29e17a43c1a922a44447c8e782 7c2831d8edc8477dad78c8a342d6c74f 9c34af29e17a43c1a922a44447c8e782--7c2831d8edc8477dad78c8a342d6c74f 5609de11796b4dd2967ca99fd884fb84 7c2831d8edc8477dad78c8a342d6c74f--5609de11796b4dd2967ca99fd884fb84 f4b95a754ab444e7b15a249ed813d6e7 5609de11796b4dd2967ca99fd884fb84--f4b95a754ab444e7b15a249ed813d6e7 790a0ac8f49547e99cc6ae20260c4f54 f4b95a754ab444e7b15a249ed813d6e7--790a0ac8f49547e99cc6ae20260c4f54 875f1527a678442ab53048555ceb83c0 X 790a0ac8f49547e99cc6ae20260c4f54--875f1527a678442ab53048555ceb83c0 875f1527a678442ab53048555ceb83c0--a2a5ddbd752d4dffa56b149c1820dffe 06d30412445845e08974fc3cbeb26648 875f1527a678442ab53048555ceb83c0--06d30412445845e08974fc3cbeb26648 d49c54fbfdbb43579f44f70e83a720f7 06d30412445845e08974fc3cbeb26648--d49c54fbfdbb43579f44f70e83a720f7 571027d26e4044a29cda4492205140d7 d49c54fbfdbb43579f44f70e83a720f7--571027d26e4044a29cda4492205140d7 1c1619887440494ea7d111cc59495e2f X 571027d26e4044a29cda4492205140d7--1c1619887440494ea7d111cc59495e2f 1c1619887440494ea7d111cc59495e2f--b2b42e7cb03a407494e2a493bc1569c0 276c8e37e11b487bb37deb607b4fe365 1c1619887440494ea7d111cc59495e2f--276c8e37e11b487bb37deb607b4fe365 dd43da82bf8e4c13b6be5f60c526749d 276c8e37e11b487bb37deb607b4fe365--dd43da82bf8e4c13b6be5f60c526749d e3aacd01ac0445b48b436b3d81cdcb30 dd43da82bf8e4c13b6be5f60c526749d--e3aacd01ac0445b48b436b3d81cdcb30 1d1eb54fb7874203bd391463adca11a8 e3aacd01ac0445b48b436b3d81cdcb30--1d1eb54fb7874203bd391463adca11a8 8f61c230ddc048d58d0f95517aade033 1d1eb54fb7874203bd391463adca11a8--8f61c230ddc048d58d0f95517aade033 f0110664b39f473eb11de9619613d7e8 8f61c230ddc048d58d0f95517aade033--f0110664b39f473eb11de9619613d7e8 67c62dd517cf45ad96e00b4c657123d3 f0110664b39f473eb11de9619613d7e8--67c62dd517cf45ad96e00b4c657123d3 a6227015c5cd4f9aa79994cf6fb7c87d 67c62dd517cf45ad96e00b4c657123d3--a6227015c5cd4f9aa79994cf6fb7c87d 6f7214752ca8439b9192896186d70951 a6227015c5cd4f9aa79994cf6fb7c87d--6f7214752ca8439b9192896186d70951 04ca7b99a679479c98a591064b1fcf99 6f7214752ca8439b9192896186d70951--04ca7b99a679479c98a591064b1fcf99 e13f1001256b4d0ca0c7e6a6f20817dd X 04ca7b99a679479c98a591064b1fcf99--e13f1001256b4d0ca0c7e6a6f20817dd e13f1001256b4d0ca0c7e6a6f20817dd--057e175314d143c3aa8ddb2e08a7003b 79648a1ae4a7472693964011127ef0fc e13f1001256b4d0ca0c7e6a6f20817dd--79648a1ae4a7472693964011127ef0fc 88b96918360947d7a587cbb35814d02f 79648a1ae4a7472693964011127ef0fc--88b96918360947d7a587cbb35814d02f 49445039b536446a89f2fd05c861bf47 88b96918360947d7a587cbb35814d02f--49445039b536446a89f2fd05c861bf47 1ec15338f18145b9a0332f2611428376 49445039b536446a89f2fd05c861bf47--1ec15338f18145b9a0332f2611428376 b88b0546b3954366b6304822020ef13a 1ec15338f18145b9a0332f2611428376--b88b0546b3954366b6304822020ef13a d5d6fd66cbfd4095b88a32a2eab84bcd X b88b0546b3954366b6304822020ef13a--d5d6fd66cbfd4095b88a32a2eab84bcd d5d6fd66cbfd4095b88a32a2eab84bcd--fc770751ab7f45c0ab52702405931cdd bea030e2ffb24b678ceffa5fc23e5005 d5d6fd66cbfd4095b88a32a2eab84bcd--bea030e2ffb24b678ceffa5fc23e5005 95bd4b64847544e290543e21c6338977 bea030e2ffb24b678ceffa5fc23e5005--95bd4b64847544e290543e21c6338977 e97348b58845400c9dadfb50e4375eb1 95bd4b64847544e290543e21c6338977--e97348b58845400c9dadfb50e4375eb1 15ef0eff68dd4d6da0be33f21112d6c4 X e97348b58845400c9dadfb50e4375eb1--15ef0eff68dd4d6da0be33f21112d6c4 15ef0eff68dd4d6da0be33f21112d6c4--fc03734927194c9aa64ae99ff53994b4 84955fb8dd354c8e9e0d057e18b300e0 15ef0eff68dd4d6da0be33f21112d6c4--84955fb8dd354c8e9e0d057e18b300e0 d83e92fd6dc44b9ba5523920600bd152 84955fb8dd354c8e9e0d057e18b300e0--d83e92fd6dc44b9ba5523920600bd152 aa5c7cd7f27e43b59edec4a0f6f18b86 d83e92fd6dc44b9ba5523920600bd152--aa5c7cd7f27e43b59edec4a0f6f18b86 f584cb8f4cc14fa782a980a499f2f98f aa5c7cd7f27e43b59edec4a0f6f18b86--f584cb8f4cc14fa782a980a499f2f98f 8cb06c57fde04cd98484f6593d855ced f584cb8f4cc14fa782a980a499f2f98f--8cb06c57fde04cd98484f6593d855ced 630bf01dc9a340b1846b67297c3d4716 X 8cb06c57fde04cd98484f6593d855ced--630bf01dc9a340b1846b67297c3d4716 630bf01dc9a340b1846b67297c3d4716--94fdb4a8621a417bbed2bdd122cd2150 68743149a0294f378e4d4392bfbf2eed 630bf01dc9a340b1846b67297c3d4716--68743149a0294f378e4d4392bfbf2eed c55c52eea9604516983db17dcc4f6539 X 68743149a0294f378e4d4392bfbf2eed--c55c52eea9604516983db17dcc4f6539 c55c52eea9604516983db17dcc4f6539--5f6d33a89ce344578d27e6b5c5112473 d83477c4a6b442b1902a20e0b88103a0 c55c52eea9604516983db17dcc4f6539--d83477c4a6b442b1902a20e0b88103a0 61e6d7b3876c4043aa4cb21a45152a8d d83477c4a6b442b1902a20e0b88103a0--61e6d7b3876c4043aa4cb21a45152a8d a030b72735d447718cc21274c7530dde 61e6d7b3876c4043aa4cb21a45152a8d--a030b72735d447718cc21274c7530dde 1c6a359c7eac4aa3bbb083f832245a36 X a030b72735d447718cc21274c7530dde--1c6a359c7eac4aa3bbb083f832245a36 1c6a359c7eac4aa3bbb083f832245a36--9558e3d4c668490db213da2f70be68e1 bea1d982569543c5bf2143f324b2fc71 1c6a359c7eac4aa3bbb083f832245a36--bea1d982569543c5bf2143f324b2fc71 8c31964ae1d94151b62409de27fb3270 bea1d982569543c5bf2143f324b2fc71--8c31964ae1d94151b62409de27fb3270 1c45e79393c84ed69ccbaee5ff10aa11 8c31964ae1d94151b62409de27fb3270--1c45e79393c84ed69ccbaee5ff10aa11 c406908f8e174e2fa3d450fbfe7ed112 RX(b15) 1c45e79393c84ed69ccbaee5ff10aa11--c406908f8e174e2fa3d450fbfe7ed112 c406908f8e174e2fa3d450fbfe7ed112--6b03800386644bdb92468972ca956e1a 6cbb043172374956b553845714e6c889 170f4c56ef7e42e89d24f26907827be3 65da79fcd7004fce88da04ee6953410f--170f4c56ef7e42e89d24f26907827be3 9110ac26ee9e47c49f6423968d16d060 7 a76ab3e8f4b44a4fa25e5aed32a2efc9 170f4c56ef7e42e89d24f26907827be3--a76ab3e8f4b44a4fa25e5aed32a2efc9 2a9f7ddda68a48b5b76216616ac9178a a76ab3e8f4b44a4fa25e5aed32a2efc9--2a9f7ddda68a48b5b76216616ac9178a 16419ccd1271497a92065dd5ca2ec74c 2a9f7ddda68a48b5b76216616ac9178a--16419ccd1271497a92065dd5ca2ec74c 92debe40aced42cca16717ee8fbe26bb 16419ccd1271497a92065dd5ca2ec74c--92debe40aced42cca16717ee8fbe26bb 97e225481a524fa2bbcd81aaaf467368 X 92debe40aced42cca16717ee8fbe26bb--97e225481a524fa2bbcd81aaaf467368 97e225481a524fa2bbcd81aaaf467368--666d9d37729f47b09d14c7b4261c266d 770e3c8df49145a69cb8c2c92441ceb8 97e225481a524fa2bbcd81aaaf467368--770e3c8df49145a69cb8c2c92441ceb8 337ed49ef8e1491ebafac3ecd299fdab 770e3c8df49145a69cb8c2c92441ceb8--337ed49ef8e1491ebafac3ecd299fdab cd6f4df19bb94bd0952bf17ca02d0a5b 337ed49ef8e1491ebafac3ecd299fdab--cd6f4df19bb94bd0952bf17ca02d0a5b c2038b8634a4424babd383fae1cd0df3 X cd6f4df19bb94bd0952bf17ca02d0a5b--c2038b8634a4424babd383fae1cd0df3 c2038b8634a4424babd383fae1cd0df3--28d65a298a1047ee92cef8d5c51f1aaa f575243fa8174570807478f747aeb3d6 c2038b8634a4424babd383fae1cd0df3--f575243fa8174570807478f747aeb3d6 c1c237fbb20548bea566204c97dfa151 f575243fa8174570807478f747aeb3d6--c1c237fbb20548bea566204c97dfa151 9f90c68e41c8484baa49ae2544a5b751 c1c237fbb20548bea566204c97dfa151--9f90c68e41c8484baa49ae2544a5b751 9ca296172f274611a922bb18c465fe00 9f90c68e41c8484baa49ae2544a5b751--9ca296172f274611a922bb18c465fe00 b11f192e2f654e138076e268d318884a 9ca296172f274611a922bb18c465fe00--b11f192e2f654e138076e268d318884a 14d608c4c5c9459b9aced2764ed571a6 b11f192e2f654e138076e268d318884a--14d608c4c5c9459b9aced2764ed571a6 24027547673d430fb614c40d2e51585f 14d608c4c5c9459b9aced2764ed571a6--24027547673d430fb614c40d2e51585f 76c5d0f610a54aed93bfd0f92b3f55a9 24027547673d430fb614c40d2e51585f--76c5d0f610a54aed93bfd0f92b3f55a9 2811c046d4f2429ea13f6bfb17c44138 76c5d0f610a54aed93bfd0f92b3f55a9--2811c046d4f2429ea13f6bfb17c44138 4d2a4c3357b84ae4a644205011f07b72 2811c046d4f2429ea13f6bfb17c44138--4d2a4c3357b84ae4a644205011f07b72 9a4c5d22e4b5421d91c131167c592921 4d2a4c3357b84ae4a644205011f07b72--9a4c5d22e4b5421d91c131167c592921 9aeed0661c9e4386bc2f23d06ab5365d 9a4c5d22e4b5421d91c131167c592921--9aeed0661c9e4386bc2f23d06ab5365d 75d37aa08391402aae4357bd32c4273c 9aeed0661c9e4386bc2f23d06ab5365d--75d37aa08391402aae4357bd32c4273c 8281ca58e0584a8498ef0e4f80fad6ce 75d37aa08391402aae4357bd32c4273c--8281ca58e0584a8498ef0e4f80fad6ce baff55a7df4549ba8705f3eea7182a65 8281ca58e0584a8498ef0e4f80fad6ce--baff55a7df4549ba8705f3eea7182a65 efe8a500f17f4459bd0024b9060f2dc3 baff55a7df4549ba8705f3eea7182a65--efe8a500f17f4459bd0024b9060f2dc3 4b04a8b51c4f498eb84ac7aff4d743d2 efe8a500f17f4459bd0024b9060f2dc3--4b04a8b51c4f498eb84ac7aff4d743d2 c00807d229ad459e9c95041e4d69520b 4b04a8b51c4f498eb84ac7aff4d743d2--c00807d229ad459e9c95041e4d69520b 1bb4986be6ae4959a6440409f887f523 c00807d229ad459e9c95041e4d69520b--1bb4986be6ae4959a6440409f887f523 353729337e864bfea83f46317a02db09 1bb4986be6ae4959a6440409f887f523--353729337e864bfea83f46317a02db09 67587eda50c24d2aab525eb845a034ff 353729337e864bfea83f46317a02db09--67587eda50c24d2aab525eb845a034ff fc231855149d49a19ebdda9f6d07f188 67587eda50c24d2aab525eb845a034ff--fc231855149d49a19ebdda9f6d07f188 51c52dd940ff4e86b45cd8b2980bcc80 fc231855149d49a19ebdda9f6d07f188--51c52dd940ff4e86b45cd8b2980bcc80 4d7a81d6971e48a49737cef5cd05bb48 51c52dd940ff4e86b45cd8b2980bcc80--4d7a81d6971e48a49737cef5cd05bb48 32753d67cf6c4d279bad043b5810f404 4d7a81d6971e48a49737cef5cd05bb48--32753d67cf6c4d279bad043b5810f404 7c40e77d43ad44c5844d0edb98ee3258 32753d67cf6c4d279bad043b5810f404--7c40e77d43ad44c5844d0edb98ee3258 fe58d145ef4d4380bf6ffdb27bc389be 7c40e77d43ad44c5844d0edb98ee3258--fe58d145ef4d4380bf6ffdb27bc389be 546ebee2d0704c9e9207fa963024baa8 fe58d145ef4d4380bf6ffdb27bc389be--546ebee2d0704c9e9207fa963024baa8 fe1cd9b73a174bd5854d05f8f26dfabb 546ebee2d0704c9e9207fa963024baa8--fe1cd9b73a174bd5854d05f8f26dfabb 5c229baeb9ea4919a43e643443fccee7 fe1cd9b73a174bd5854d05f8f26dfabb--5c229baeb9ea4919a43e643443fccee7 7cc1664a6a08457cbbd61ff2473ed0a0 5c229baeb9ea4919a43e643443fccee7--7cc1664a6a08457cbbd61ff2473ed0a0 85538b355bec4a1384a9954ccfd315b5 7cc1664a6a08457cbbd61ff2473ed0a0--85538b355bec4a1384a9954ccfd315b5 a44c10c0a6c64032b25c621a3fa628d3 85538b355bec4a1384a9954ccfd315b5--a44c10c0a6c64032b25c621a3fa628d3 929b48c7073740aeae1bfdc060ed5712 a44c10c0a6c64032b25c621a3fa628d3--929b48c7073740aeae1bfdc060ed5712 498bb0f201324e1ea1c60e5031fb106a X 929b48c7073740aeae1bfdc060ed5712--498bb0f201324e1ea1c60e5031fb106a 498bb0f201324e1ea1c60e5031fb106a--b78c1909dfe84e5ebdd805f3a699e11f b0a48bdd3e48485a9a80ee9954d661aa RZ(-1.0*g0) 498bb0f201324e1ea1c60e5031fb106a--b0a48bdd3e48485a9a80ee9954d661aa dd29532fe26b485c91f986477e32de81 X b0a48bdd3e48485a9a80ee9954d661aa--dd29532fe26b485c91f986477e32de81 dd29532fe26b485c91f986477e32de81--2af864c02b434856a25d950b7a9a8189 1b4e8d8083fe4f72bb38d032d9bb10a2 dd29532fe26b485c91f986477e32de81--1b4e8d8083fe4f72bb38d032d9bb10a2 ae0b81c5cf2b4bd29bdb5202b7914580 1b4e8d8083fe4f72bb38d032d9bb10a2--ae0b81c5cf2b4bd29bdb5202b7914580 b494efdc9eb64519bf6ea4bef9e23f18 ae0b81c5cf2b4bd29bdb5202b7914580--b494efdc9eb64519bf6ea4bef9e23f18 a9c8cb6601b54e38a635e574a403d732 b494efdc9eb64519bf6ea4bef9e23f18--a9c8cb6601b54e38a635e574a403d732 d88f0f65b9a4408ba8c86af8a910249d a9c8cb6601b54e38a635e574a403d732--d88f0f65b9a4408ba8c86af8a910249d 1dd5a5ca2c46444bb153a3ed9fdaedde d88f0f65b9a4408ba8c86af8a910249d--1dd5a5ca2c46444bb153a3ed9fdaedde 63821d9262954b7dab8e460db9d733d6 1dd5a5ca2c46444bb153a3ed9fdaedde--63821d9262954b7dab8e460db9d733d6 42c15f868f1d4d358565108bc3a9f6ad 63821d9262954b7dab8e460db9d733d6--42c15f868f1d4d358565108bc3a9f6ad 195b28b2eba146a9961d7e4a73667aa9 42c15f868f1d4d358565108bc3a9f6ad--195b28b2eba146a9961d7e4a73667aa9 063443534ae44a8199ec024d83235a7c 195b28b2eba146a9961d7e4a73667aa9--063443534ae44a8199ec024d83235a7c 12dfc7b3c45841208b08d9c16f1e740b X 063443534ae44a8199ec024d83235a7c--12dfc7b3c45841208b08d9c16f1e740b 12dfc7b3c45841208b08d9c16f1e740b--f4097401d6704ef391e91e4be6f70fa0 b4cb351e2c014a7dbc842b395d358431 12dfc7b3c45841208b08d9c16f1e740b--b4cb351e2c014a7dbc842b395d358431 82432434e5ff41dcba7a57da78aeb15f b4cb351e2c014a7dbc842b395d358431--82432434e5ff41dcba7a57da78aeb15f 5784627150f1461e884e14b36e19c35b 82432434e5ff41dcba7a57da78aeb15f--5784627150f1461e884e14b36e19c35b 9533ad38547d4e23baaa1c809b943061 X 5784627150f1461e884e14b36e19c35b--9533ad38547d4e23baaa1c809b943061 9533ad38547d4e23baaa1c809b943061--f7cbbff8bdd3439a9bcc9567cac7f894 1d2cf0af97e24b6fa404b471e6e5ba9d 9533ad38547d4e23baaa1c809b943061--1d2cf0af97e24b6fa404b471e6e5ba9d 3ac57823da994028bc32a351fc5f2ae8 1d2cf0af97e24b6fa404b471e6e5ba9d--3ac57823da994028bc32a351fc5f2ae8 9e6bfa5f78c4496cb0efd80c8c021cb5 3ac57823da994028bc32a351fc5f2ae8--9e6bfa5f78c4496cb0efd80c8c021cb5 45b4946f2c2e4a32a266050cb726151c 9e6bfa5f78c4496cb0efd80c8c021cb5--45b4946f2c2e4a32a266050cb726151c 4d8e715f66c649ac9c94b2dd56e2c0eb 45b4946f2c2e4a32a266050cb726151c--4d8e715f66c649ac9c94b2dd56e2c0eb 6f3ec9ae963e4ba08e1a2eadfcf5c627 4d8e715f66c649ac9c94b2dd56e2c0eb--6f3ec9ae963e4ba08e1a2eadfcf5c627 7e1c7183367542588065f8b36d4e90c9 6f3ec9ae963e4ba08e1a2eadfcf5c627--7e1c7183367542588065f8b36d4e90c9 6a142fb9383243dc81a39521c9ae825f 7e1c7183367542588065f8b36d4e90c9--6a142fb9383243dc81a39521c9ae825f 68f20cc4941040bdbfa504dc2adaa10a 6a142fb9383243dc81a39521c9ae825f--68f20cc4941040bdbfa504dc2adaa10a 7eda9f919efa4b25a2e9fab96a8a93a2 68f20cc4941040bdbfa504dc2adaa10a--7eda9f919efa4b25a2e9fab96a8a93a2 7543a2c85d1548e6a22014e66bb69854 7eda9f919efa4b25a2e9fab96a8a93a2--7543a2c85d1548e6a22014e66bb69854 2c222a871d2b48b69ca8c3e7fec4307a 7543a2c85d1548e6a22014e66bb69854--2c222a871d2b48b69ca8c3e7fec4307a 76cb70ed93af419996040865996a5beb 2c222a871d2b48b69ca8c3e7fec4307a--76cb70ed93af419996040865996a5beb 1da24b43633841528a01455229ba8c6b 76cb70ed93af419996040865996a5beb--1da24b43633841528a01455229ba8c6b 444df612210a436fad4bc5622ea25caa 1da24b43633841528a01455229ba8c6b--444df612210a436fad4bc5622ea25caa 5a48eec86d9941a88679fd36dfa87496 444df612210a436fad4bc5622ea25caa--5a48eec86d9941a88679fd36dfa87496 944c93e1c5484af596b45f002fdbc4ec 5a48eec86d9941a88679fd36dfa87496--944c93e1c5484af596b45f002fdbc4ec e5b7c8ca25084b96833a3f23fdfcc85f 944c93e1c5484af596b45f002fdbc4ec--e5b7c8ca25084b96833a3f23fdfcc85f c87815b4bbd34946b7d90aa1a202bf4f e5b7c8ca25084b96833a3f23fdfcc85f--c87815b4bbd34946b7d90aa1a202bf4f dd4171eed62d4dfb9603da1502c76ac9 c87815b4bbd34946b7d90aa1a202bf4f--dd4171eed62d4dfb9603da1502c76ac9 8266a1394a834d0bbe4f77390acdfadf dd4171eed62d4dfb9603da1502c76ac9--8266a1394a834d0bbe4f77390acdfadf 555a760eab554baebc8de087c08646a2 8266a1394a834d0bbe4f77390acdfadf--555a760eab554baebc8de087c08646a2 9af974f6a03642ba9f9aef4ec7002b09 555a760eab554baebc8de087c08646a2--9af974f6a03642ba9f9aef4ec7002b09 d687f9d3761f4afe8151dc20a8aaa7a9 9af974f6a03642ba9f9aef4ec7002b09--d687f9d3761f4afe8151dc20a8aaa7a9 5d57a803ebde42a6ad5ab6fa07f1e134 d687f9d3761f4afe8151dc20a8aaa7a9--5d57a803ebde42a6ad5ab6fa07f1e134 60f6354a196f4cd09f8ec6cfaedd58ba 5d57a803ebde42a6ad5ab6fa07f1e134--60f6354a196f4cd09f8ec6cfaedd58ba d40e2d35702a446c8b47ed240012486a X 60f6354a196f4cd09f8ec6cfaedd58ba--d40e2d35702a446c8b47ed240012486a d40e2d35702a446c8b47ed240012486a--8c5a372e78044a7790e5bb609e76815d f4964d0ccdc943df900b926a25babf3d RZ(-1.0*g0) d40e2d35702a446c8b47ed240012486a--f4964d0ccdc943df900b926a25babf3d 433e0da6a54649338dda0b3b3ec05cbb X f4964d0ccdc943df900b926a25babf3d--433e0da6a54649338dda0b3b3ec05cbb 433e0da6a54649338dda0b3b3ec05cbb--f8d48b09220d433697c00c4f57dcad87 6c77d36910ef4feeba6598bdf3c0ecd1 433e0da6a54649338dda0b3b3ec05cbb--6c77d36910ef4feeba6598bdf3c0ecd1 2c9d81d0f40f4510ac5d8ed7a403f955 6c77d36910ef4feeba6598bdf3c0ecd1--2c9d81d0f40f4510ac5d8ed7a403f955 3a1fe764f29e4669ab245f9a09cf5f71 2c9d81d0f40f4510ac5d8ed7a403f955--3a1fe764f29e4669ab245f9a09cf5f71 7bcf6cf53bdf4d3cb3a26ddd29526ebc 3a1fe764f29e4669ab245f9a09cf5f71--7bcf6cf53bdf4d3cb3a26ddd29526ebc c8f5b14d4b804b72b6fa17142991a214 7bcf6cf53bdf4d3cb3a26ddd29526ebc--c8f5b14d4b804b72b6fa17142991a214 c638406cd82f4170ac678fce4d9e2a7a c8f5b14d4b804b72b6fa17142991a214--c638406cd82f4170ac678fce4d9e2a7a 66f97404ab584fe2828ccf023aaa80e7 c638406cd82f4170ac678fce4d9e2a7a--66f97404ab584fe2828ccf023aaa80e7 7ba2e687df75443ca7658d7f7829003d 66f97404ab584fe2828ccf023aaa80e7--7ba2e687df75443ca7658d7f7829003d c0442931103e42c680eaab914a006e75 7ba2e687df75443ca7658d7f7829003d--c0442931103e42c680eaab914a006e75 a73207cbeb6f4a2389ef04be57bf05cd c0442931103e42c680eaab914a006e75--a73207cbeb6f4a2389ef04be57bf05cd f45fd384ba4d462dacbe95b85a67cbdb a73207cbeb6f4a2389ef04be57bf05cd--f45fd384ba4d462dacbe95b85a67cbdb f4f2afa143c64815b9826f3d62701f18 f45fd384ba4d462dacbe95b85a67cbdb--f4f2afa143c64815b9826f3d62701f18 19640f3f025c47379bd49c82e9da8f0e X f4f2afa143c64815b9826f3d62701f18--19640f3f025c47379bd49c82e9da8f0e 19640f3f025c47379bd49c82e9da8f0e--20bfd019eefb4c418f144fbc0e5b5fa4 1f8d5c9c12954ad68b6bd482acaf2743 19640f3f025c47379bd49c82e9da8f0e--1f8d5c9c12954ad68b6bd482acaf2743 69b79f15ee4a4c2ea63646f9817c1d35 1f8d5c9c12954ad68b6bd482acaf2743--69b79f15ee4a4c2ea63646f9817c1d35 63d9c5fc39bf497caefe64d25d71da1a 69b79f15ee4a4c2ea63646f9817c1d35--63d9c5fc39bf497caefe64d25d71da1a 0bbb814d0816410c83b499d9a283a0f9 X 63d9c5fc39bf497caefe64d25d71da1a--0bbb814d0816410c83b499d9a283a0f9 0bbb814d0816410c83b499d9a283a0f9--3a0c8795a24549f2ab5e97390a7e1e56 b5c78c527b5840d28d64c9a9fc6520d5 0bbb814d0816410c83b499d9a283a0f9--b5c78c527b5840d28d64c9a9fc6520d5 02eb207a191942db9447e193152a19fd b5c78c527b5840d28d64c9a9fc6520d5--02eb207a191942db9447e193152a19fd eb822d581d7f42e68c443d992e4dda2f 02eb207a191942db9447e193152a19fd--eb822d581d7f42e68c443d992e4dda2f 75e78df305534fe0984c7bca4c68946a eb822d581d7f42e68c443d992e4dda2f--75e78df305534fe0984c7bca4c68946a 9fe203ba044c436a9862067ebe6a04ef 75e78df305534fe0984c7bca4c68946a--9fe203ba044c436a9862067ebe6a04ef 78b2d8e10f6e45caa254fd6758c319e8 X 9fe203ba044c436a9862067ebe6a04ef--78b2d8e10f6e45caa254fd6758c319e8 78b2d8e10f6e45caa254fd6758c319e8--475771e1ce37498f81bf95bd41476e0a c1d65eb9b55c4a1b81828a7bba26f4a0 78b2d8e10f6e45caa254fd6758c319e8--c1d65eb9b55c4a1b81828a7bba26f4a0 b0066b177a2f42b885f7d9ed8a5b5598 c1d65eb9b55c4a1b81828a7bba26f4a0--b0066b177a2f42b885f7d9ed8a5b5598 20c22d09edde42afb49fa9a34e0dfde9 b0066b177a2f42b885f7d9ed8a5b5598--20c22d09edde42afb49fa9a34e0dfde9 c6def27ed4c84e7da975dad2a351c7b7 X 20c22d09edde42afb49fa9a34e0dfde9--c6def27ed4c84e7da975dad2a351c7b7 c6def27ed4c84e7da975dad2a351c7b7--bb0c0c1bf509465fa3d8d11e52d6a4c0 bbcbe72ab9b94e718ac5381dee95332d c6def27ed4c84e7da975dad2a351c7b7--bbcbe72ab9b94e718ac5381dee95332d a0952c49aa7747e6a1f8fec751d72760 bbcbe72ab9b94e718ac5381dee95332d--a0952c49aa7747e6a1f8fec751d72760 a43d8dbd5d62458493924d57bb950d2f a0952c49aa7747e6a1f8fec751d72760--a43d8dbd5d62458493924d57bb950d2f 5178b1931ab14213a8b939ecbba7eb06 X a43d8dbd5d62458493924d57bb950d2f--5178b1931ab14213a8b939ecbba7eb06 5178b1931ab14213a8b939ecbba7eb06--56d30a2804ef46c08e9c0123ceb56e17 6a2310859e0f4712816c2edbc0717292 RZ(-1.0*g0) 5178b1931ab14213a8b939ecbba7eb06--6a2310859e0f4712816c2edbc0717292 821867553cb443e5b98af80d54636a87 X 6a2310859e0f4712816c2edbc0717292--821867553cb443e5b98af80d54636a87 821867553cb443e5b98af80d54636a87--d5168f538b7d4b6fbfb235e9efbbe826 1fc8ea74cee3416390257f244959e1e9 821867553cb443e5b98af80d54636a87--1fc8ea74cee3416390257f244959e1e9 59db8af7e436429495b2f64cd69db945 X 1fc8ea74cee3416390257f244959e1e9--59db8af7e436429495b2f64cd69db945 59db8af7e436429495b2f64cd69db945--d174c69325d14f7280d3d94d5d41d621 25bc2e0c9fa7419a9b39042a4a315cc1 RZ(-1.0*g0) 59db8af7e436429495b2f64cd69db945--25bc2e0c9fa7419a9b39042a4a315cc1 91cb1ee8c6df47d9bf068c9a5cc71a93 X 25bc2e0c9fa7419a9b39042a4a315cc1--91cb1ee8c6df47d9bf068c9a5cc71a93 91cb1ee8c6df47d9bf068c9a5cc71a93--0bc7c95a6bb34391ba4a5844bc6b3a9c 104f5850604b40418355cd3dfcf1387b RX(b06) 91cb1ee8c6df47d9bf068c9a5cc71a93--104f5850604b40418355cd3dfcf1387b 515d8d83c70c495d92f89985e326924a 104f5850604b40418355cd3dfcf1387b--515d8d83c70c495d92f89985e326924a ba610fe829ed4ae79a59dda886d00a20 515d8d83c70c495d92f89985e326924a--ba610fe829ed4ae79a59dda886d00a20 55b1a6a0222f4d729f5d9e12b10e0596 ba610fe829ed4ae79a59dda886d00a20--55b1a6a0222f4d729f5d9e12b10e0596 ab9aa4ed6dfa404a81d4524269e04f9a 55b1a6a0222f4d729f5d9e12b10e0596--ab9aa4ed6dfa404a81d4524269e04f9a e4d013895ccb4ef88226a8cc06430577 ab9aa4ed6dfa404a81d4524269e04f9a--e4d013895ccb4ef88226a8cc06430577 a6774241ca1041a1a884a71bd68a032e X e4d013895ccb4ef88226a8cc06430577--a6774241ca1041a1a884a71bd68a032e a6774241ca1041a1a884a71bd68a032e--900edea14f5643fdb35d0dfe165716a3 0ceb33540be841a7bce2445c856c4150 a6774241ca1041a1a884a71bd68a032e--0ceb33540be841a7bce2445c856c4150 58a3c7b4661c402ba611180378f6b021 0ceb33540be841a7bce2445c856c4150--58a3c7b4661c402ba611180378f6b021 010fc3e617af44bf8866c3a247e98ab6 58a3c7b4661c402ba611180378f6b021--010fc3e617af44bf8866c3a247e98ab6 8be0c415d49a4792b1ee434b399e716a X 010fc3e617af44bf8866c3a247e98ab6--8be0c415d49a4792b1ee434b399e716a 8be0c415d49a4792b1ee434b399e716a--7d6b24d06e3e470a8fc2af1dee6ebb08 53466d9b0ecf4755b4bf06e0b59ff1e3 8be0c415d49a4792b1ee434b399e716a--53466d9b0ecf4755b4bf06e0b59ff1e3 5dcfaf8a78f4483289bbe0ad1e64587b 53466d9b0ecf4755b4bf06e0b59ff1e3--5dcfaf8a78f4483289bbe0ad1e64587b c2fb564def8641da8fea5f5038fd6302 5dcfaf8a78f4483289bbe0ad1e64587b--c2fb564def8641da8fea5f5038fd6302 d92722a46adb4bfaaa83544a8c723951 c2fb564def8641da8fea5f5038fd6302--d92722a46adb4bfaaa83544a8c723951 1fc02a4987ad4576b176d3b73fbcee65 d92722a46adb4bfaaa83544a8c723951--1fc02a4987ad4576b176d3b73fbcee65 6dcb493306ea47f097c05b8f0ce17b34 1fc02a4987ad4576b176d3b73fbcee65--6dcb493306ea47f097c05b8f0ce17b34 6dc8ea76d24b40959740bf3f2d0bb933 6dcb493306ea47f097c05b8f0ce17b34--6dc8ea76d24b40959740bf3f2d0bb933 c153fad2cde04db19954f599e3a967ee 6dc8ea76d24b40959740bf3f2d0bb933--c153fad2cde04db19954f599e3a967ee 624c02cf467a4c62a4b6ed082b67ea09 c153fad2cde04db19954f599e3a967ee--624c02cf467a4c62a4b6ed082b67ea09 9d4515c1cc054698a23d9df25dc8904a 624c02cf467a4c62a4b6ed082b67ea09--9d4515c1cc054698a23d9df25dc8904a bc7ffc688b9d4070b7736efd58ef452c 9d4515c1cc054698a23d9df25dc8904a--bc7ffc688b9d4070b7736efd58ef452c b6a7a5c052f24f1fa5961756856d2c2a bc7ffc688b9d4070b7736efd58ef452c--b6a7a5c052f24f1fa5961756856d2c2a d483441060f14caca1acd2c59f5b58e8 b6a7a5c052f24f1fa5961756856d2c2a--d483441060f14caca1acd2c59f5b58e8 4b61206581db478eb5b069e21eed3115 d483441060f14caca1acd2c59f5b58e8--4b61206581db478eb5b069e21eed3115 63b0505eeb4746819c8f55c47e5caf51 4b61206581db478eb5b069e21eed3115--63b0505eeb4746819c8f55c47e5caf51 d7e24b5749cd47ba8ed74371c3884905 63b0505eeb4746819c8f55c47e5caf51--d7e24b5749cd47ba8ed74371c3884905 1ef4849549aa4e90a8aadbba4def35ab d7e24b5749cd47ba8ed74371c3884905--1ef4849549aa4e90a8aadbba4def35ab ba52bf100af64036a981d80b91f38d69 1ef4849549aa4e90a8aadbba4def35ab--ba52bf100af64036a981d80b91f38d69 17dbf1148cd248b09b5d00c0e5949c92 ba52bf100af64036a981d80b91f38d69--17dbf1148cd248b09b5d00c0e5949c92 1f156ea21a07430d8884b2a9d99addbe 17dbf1148cd248b09b5d00c0e5949c92--1f156ea21a07430d8884b2a9d99addbe b099f692a95d4bbea4d71ba90357817d 1f156ea21a07430d8884b2a9d99addbe--b099f692a95d4bbea4d71ba90357817d 93e3892161b64c2bace21cd861650246 b099f692a95d4bbea4d71ba90357817d--93e3892161b64c2bace21cd861650246 b5886c8ee3534ac7aa67db51773205fe 93e3892161b64c2bace21cd861650246--b5886c8ee3534ac7aa67db51773205fe 766b38aceda74b698cb540ed9f2bac50 b5886c8ee3534ac7aa67db51773205fe--766b38aceda74b698cb540ed9f2bac50 af01d1821494412e826d154b7d694382 766b38aceda74b698cb540ed9f2bac50--af01d1821494412e826d154b7d694382 0cee7819941a4728bf1d7c47a8b1a7e0 af01d1821494412e826d154b7d694382--0cee7819941a4728bf1d7c47a8b1a7e0 7910d6621ee84f1ca78c7141b439f343 0cee7819941a4728bf1d7c47a8b1a7e0--7910d6621ee84f1ca78c7141b439f343 413fb00a79114a51bd5b7d2190ff0d9c 7910d6621ee84f1ca78c7141b439f343--413fb00a79114a51bd5b7d2190ff0d9c 9cffe4d73bdd435a9a2cb7e7d2810ed8 413fb00a79114a51bd5b7d2190ff0d9c--9cffe4d73bdd435a9a2cb7e7d2810ed8 31540c75668f47899bd1d80b60f8f9a9 9cffe4d73bdd435a9a2cb7e7d2810ed8--31540c75668f47899bd1d80b60f8f9a9 6e4b154464c04690b95813d8cd0ae8b9 31540c75668f47899bd1d80b60f8f9a9--6e4b154464c04690b95813d8cd0ae8b9 566f4e325a89412998d70e454266af4d 6e4b154464c04690b95813d8cd0ae8b9--566f4e325a89412998d70e454266af4d c6960eb10cbf4f41b4bc58225b06304d 566f4e325a89412998d70e454266af4d--c6960eb10cbf4f41b4bc58225b06304d 63af94d68c9d4e5f9829437a0b325d73 c6960eb10cbf4f41b4bc58225b06304d--63af94d68c9d4e5f9829437a0b325d73 1a32cd96c78b40a0b38681a6e55fd95c X 63af94d68c9d4e5f9829437a0b325d73--1a32cd96c78b40a0b38681a6e55fd95c 1a32cd96c78b40a0b38681a6e55fd95c--6a9ca7b080a941bab39a36de1686919c 72c2f2cbccdd421abbd53a1d6599ed70 RZ(-1.0*g1) 1a32cd96c78b40a0b38681a6e55fd95c--72c2f2cbccdd421abbd53a1d6599ed70 324c7505ddeb4a0cb290b8aeb7a70a9e X 72c2f2cbccdd421abbd53a1d6599ed70--324c7505ddeb4a0cb290b8aeb7a70a9e 324c7505ddeb4a0cb290b8aeb7a70a9e--289bbd7b56484a608d5dec52aea38f46 47256eb3cb8941d9a87ab814dddccc85 324c7505ddeb4a0cb290b8aeb7a70a9e--47256eb3cb8941d9a87ab814dddccc85 fd97c74632094db5abdd061340bc3e1b 47256eb3cb8941d9a87ab814dddccc85--fd97c74632094db5abdd061340bc3e1b 74fdadd0bf274fb3b2bb4026135ac4af fd97c74632094db5abdd061340bc3e1b--74fdadd0bf274fb3b2bb4026135ac4af b712156b641f41c58cadd9f108a8851e 74fdadd0bf274fb3b2bb4026135ac4af--b712156b641f41c58cadd9f108a8851e 460c0778d75c40859cf2449a657d2e15 b712156b641f41c58cadd9f108a8851e--460c0778d75c40859cf2449a657d2e15 73d994fc28d64edd8adcc8a4ca5ef845 460c0778d75c40859cf2449a657d2e15--73d994fc28d64edd8adcc8a4ca5ef845 bc38ab1e1c4c487e8ef94dea28955357 73d994fc28d64edd8adcc8a4ca5ef845--bc38ab1e1c4c487e8ef94dea28955357 4d1ec6b8c40c4043aa66b1db170463d6 bc38ab1e1c4c487e8ef94dea28955357--4d1ec6b8c40c4043aa66b1db170463d6 09a8524d9a034236aeb0dc9fd3e53a47 4d1ec6b8c40c4043aa66b1db170463d6--09a8524d9a034236aeb0dc9fd3e53a47 c72031a0236b499f9f9f053e3495a437 09a8524d9a034236aeb0dc9fd3e53a47--c72031a0236b499f9f9f053e3495a437 a9ec36cd43224ffd9140af91161a31f0 X c72031a0236b499f9f9f053e3495a437--a9ec36cd43224ffd9140af91161a31f0 a9ec36cd43224ffd9140af91161a31f0--d68b60c8b45a4d1f916b36dd0a6adedc 133263870e7f422ab6678749a0513b94 a9ec36cd43224ffd9140af91161a31f0--133263870e7f422ab6678749a0513b94 58aecafc986e48abb868c7d12264c72f 133263870e7f422ab6678749a0513b94--58aecafc986e48abb868c7d12264c72f 4d00733b385f4f9eae8122897eb7442a 58aecafc986e48abb868c7d12264c72f--4d00733b385f4f9eae8122897eb7442a cda12ebe7b1b4846ab000b3f031c6eeb X 4d00733b385f4f9eae8122897eb7442a--cda12ebe7b1b4846ab000b3f031c6eeb cda12ebe7b1b4846ab000b3f031c6eeb--73bcf8286870464ebc1c5a731f2dfe95 32c36ce3b2164176ae79d8fedd634946 cda12ebe7b1b4846ab000b3f031c6eeb--32c36ce3b2164176ae79d8fedd634946 4b8f9d2a1d534f3eb675b83844ce7e25 32c36ce3b2164176ae79d8fedd634946--4b8f9d2a1d534f3eb675b83844ce7e25 afe4d7f92e294dc7a4f5e05783f40065 4b8f9d2a1d534f3eb675b83844ce7e25--afe4d7f92e294dc7a4f5e05783f40065 4730527081ce4f9a93876189bde167ad afe4d7f92e294dc7a4f5e05783f40065--4730527081ce4f9a93876189bde167ad 01a3d180fb0048e48502a3f749e84fde 4730527081ce4f9a93876189bde167ad--01a3d180fb0048e48502a3f749e84fde edd3ef8ffa0241149a50aa8671810b21 01a3d180fb0048e48502a3f749e84fde--edd3ef8ffa0241149a50aa8671810b21 f4f4a0afcd264ee79d0aa2063015d437 edd3ef8ffa0241149a50aa8671810b21--f4f4a0afcd264ee79d0aa2063015d437 93de71d8f4ab4744b942bbecf9f41aa7 f4f4a0afcd264ee79d0aa2063015d437--93de71d8f4ab4744b942bbecf9f41aa7 20edcb847aa5425ebb858a603b6d5fa9 93de71d8f4ab4744b942bbecf9f41aa7--20edcb847aa5425ebb858a603b6d5fa9 0a36fc7e72f94936b58afdba31acaeec 20edcb847aa5425ebb858a603b6d5fa9--0a36fc7e72f94936b58afdba31acaeec a9960bd1bfce4f55b5171da622c2319a 0a36fc7e72f94936b58afdba31acaeec--a9960bd1bfce4f55b5171da622c2319a 029334dafec346eeaa47d246cc9f1923 a9960bd1bfce4f55b5171da622c2319a--029334dafec346eeaa47d246cc9f1923 5381dc0c297b4ed880da29d80d98a957 029334dafec346eeaa47d246cc9f1923--5381dc0c297b4ed880da29d80d98a957 6f4f25eee86c45e2be6d6314d58f3093 5381dc0c297b4ed880da29d80d98a957--6f4f25eee86c45e2be6d6314d58f3093 66042b4ec5784d089bad803801f206bc 6f4f25eee86c45e2be6d6314d58f3093--66042b4ec5784d089bad803801f206bc 0f59ca8ef1c34c04b8dbd87858017f7e 66042b4ec5784d089bad803801f206bc--0f59ca8ef1c34c04b8dbd87858017f7e 83a02820dbe547fd8acd628b56103724 0f59ca8ef1c34c04b8dbd87858017f7e--83a02820dbe547fd8acd628b56103724 08ec1fca6e6648c2950f4b35bc1a468a 83a02820dbe547fd8acd628b56103724--08ec1fca6e6648c2950f4b35bc1a468a c36807bc29e146c8ad001ce3a9ea1909 08ec1fca6e6648c2950f4b35bc1a468a--c36807bc29e146c8ad001ce3a9ea1909 f99db70bc11f48998716c283a954a954 c36807bc29e146c8ad001ce3a9ea1909--f99db70bc11f48998716c283a954a954 448878db9bfe485ea15a7191aaeb9a40 f99db70bc11f48998716c283a954a954--448878db9bfe485ea15a7191aaeb9a40 ba721f6adad04e9d910ce71d23ddfccb 448878db9bfe485ea15a7191aaeb9a40--ba721f6adad04e9d910ce71d23ddfccb 54deb6458dbe4e78abf4c5c45b527499 ba721f6adad04e9d910ce71d23ddfccb--54deb6458dbe4e78abf4c5c45b527499 ada024f6376049bbbd823fac567a6d61 54deb6458dbe4e78abf4c5c45b527499--ada024f6376049bbbd823fac567a6d61 2678e880a3d44d029e8f64503a6838c9 ada024f6376049bbbd823fac567a6d61--2678e880a3d44d029e8f64503a6838c9 a9dfaa06254942818c6e423a0eb1bd75 2678e880a3d44d029e8f64503a6838c9--a9dfaa06254942818c6e423a0eb1bd75 160244c4a73a4d0b9ab31ebf809bc728 X a9dfaa06254942818c6e423a0eb1bd75--160244c4a73a4d0b9ab31ebf809bc728 160244c4a73a4d0b9ab31ebf809bc728--06d30412445845e08974fc3cbeb26648 7d8f4c81b93f4b29a0104c15275f24d5 RZ(-1.0*g1) 160244c4a73a4d0b9ab31ebf809bc728--7d8f4c81b93f4b29a0104c15275f24d5 ecb98b0902914d95b3a51f83684a0f14 X 7d8f4c81b93f4b29a0104c15275f24d5--ecb98b0902914d95b3a51f83684a0f14 ecb98b0902914d95b3a51f83684a0f14--571027d26e4044a29cda4492205140d7 49455e0aedb141049440eb69584a76f5 ecb98b0902914d95b3a51f83684a0f14--49455e0aedb141049440eb69584a76f5 0dc46f52e104473cb3e7e07b17baedaf 49455e0aedb141049440eb69584a76f5--0dc46f52e104473cb3e7e07b17baedaf 5db7f983051144709237732af46979a5 0dc46f52e104473cb3e7e07b17baedaf--5db7f983051144709237732af46979a5 d62e9c6df35a459d87f74c8b5abcdf25 5db7f983051144709237732af46979a5--d62e9c6df35a459d87f74c8b5abcdf25 ad89912dfc4a477b94da6ec9d8ece629 d62e9c6df35a459d87f74c8b5abcdf25--ad89912dfc4a477b94da6ec9d8ece629 bba2a3fa9def46d3a0b74cd367a509b9 ad89912dfc4a477b94da6ec9d8ece629--bba2a3fa9def46d3a0b74cd367a509b9 a0b4f9c7a1704b90a37bfa4166aafb0f bba2a3fa9def46d3a0b74cd367a509b9--a0b4f9c7a1704b90a37bfa4166aafb0f 3f0ae0d7dd0b425e9fa2d2430ea30c8a a0b4f9c7a1704b90a37bfa4166aafb0f--3f0ae0d7dd0b425e9fa2d2430ea30c8a fcd78e291ae9474dac71bc5edab1283a 3f0ae0d7dd0b425e9fa2d2430ea30c8a--fcd78e291ae9474dac71bc5edab1283a b0cafa28257a47afbd04bd917144731f fcd78e291ae9474dac71bc5edab1283a--b0cafa28257a47afbd04bd917144731f 981694e68c694a96bd8f219f14e9a642 b0cafa28257a47afbd04bd917144731f--981694e68c694a96bd8f219f14e9a642 fb3e33f8fd8c4deaa90b8dfed296001e 981694e68c694a96bd8f219f14e9a642--fb3e33f8fd8c4deaa90b8dfed296001e abcc0da6652f4a30b3b25bf8e93c4ca9 X fb3e33f8fd8c4deaa90b8dfed296001e--abcc0da6652f4a30b3b25bf8e93c4ca9 abcc0da6652f4a30b3b25bf8e93c4ca9--79648a1ae4a7472693964011127ef0fc 4bace98d488b41e6a8c6349fda3dcf8f abcc0da6652f4a30b3b25bf8e93c4ca9--4bace98d488b41e6a8c6349fda3dcf8f e05d3522f31b4e1f963eacd0fd7732c1 4bace98d488b41e6a8c6349fda3dcf8f--e05d3522f31b4e1f963eacd0fd7732c1 bd738e0157c44ec2befe5ca3f46198df e05d3522f31b4e1f963eacd0fd7732c1--bd738e0157c44ec2befe5ca3f46198df ba72e24c393442d6968f7a28495744b6 X bd738e0157c44ec2befe5ca3f46198df--ba72e24c393442d6968f7a28495744b6 ba72e24c393442d6968f7a28495744b6--b88b0546b3954366b6304822020ef13a 96373c20b3cd40f0902a5b920d7553ab ba72e24c393442d6968f7a28495744b6--96373c20b3cd40f0902a5b920d7553ab 35848dc3a6ae4a7c9017789587b7ce14 96373c20b3cd40f0902a5b920d7553ab--35848dc3a6ae4a7c9017789587b7ce14 05120f38f9ae447a9c95c16016b6f219 35848dc3a6ae4a7c9017789587b7ce14--05120f38f9ae447a9c95c16016b6f219 3766cce619ec488680f91db7d7826bf1 05120f38f9ae447a9c95c16016b6f219--3766cce619ec488680f91db7d7826bf1 3f1b80c9e6d5476496f28bc98a1ea3f3 3766cce619ec488680f91db7d7826bf1--3f1b80c9e6d5476496f28bc98a1ea3f3 28daaf5a9dcd4bc78e29812d7efb517d X 3f1b80c9e6d5476496f28bc98a1ea3f3--28daaf5a9dcd4bc78e29812d7efb517d 28daaf5a9dcd4bc78e29812d7efb517d--84955fb8dd354c8e9e0d057e18b300e0 a0cca6a65d774540aba120623c1a0f09 28daaf5a9dcd4bc78e29812d7efb517d--a0cca6a65d774540aba120623c1a0f09 29cf53ea64f1475abfebbe3525c22163 a0cca6a65d774540aba120623c1a0f09--29cf53ea64f1475abfebbe3525c22163 5de0d522f8454c89bf34ff9191d96a68 29cf53ea64f1475abfebbe3525c22163--5de0d522f8454c89bf34ff9191d96a68 a4e9d286ba0d4a3e87f919760211cbce X 5de0d522f8454c89bf34ff9191d96a68--a4e9d286ba0d4a3e87f919760211cbce a4e9d286ba0d4a3e87f919760211cbce--8cb06c57fde04cd98484f6593d855ced bdc7c2ce62f043b2b09d4b31f03f25c3 a4e9d286ba0d4a3e87f919760211cbce--bdc7c2ce62f043b2b09d4b31f03f25c3 e70d5c11e86d4bc4a20a1951a9e32150 bdc7c2ce62f043b2b09d4b31f03f25c3--e70d5c11e86d4bc4a20a1951a9e32150 c38128a3f0484593b2018bfdf427bf96 e70d5c11e86d4bc4a20a1951a9e32150--c38128a3f0484593b2018bfdf427bf96 c32649210f914892ae68144ef7a1629e X c38128a3f0484593b2018bfdf427bf96--c32649210f914892ae68144ef7a1629e c32649210f914892ae68144ef7a1629e--d83477c4a6b442b1902a20e0b88103a0 002cd6059a66404ead483eb7d62a31a0 RZ(-1.0*g1) c32649210f914892ae68144ef7a1629e--002cd6059a66404ead483eb7d62a31a0 7b68d8ebe82e4735b15796acbdc89619 X 002cd6059a66404ead483eb7d62a31a0--7b68d8ebe82e4735b15796acbdc89619 7b68d8ebe82e4735b15796acbdc89619--a030b72735d447718cc21274c7530dde 00ee07b7fa3b490498661f204a43e932 7b68d8ebe82e4735b15796acbdc89619--00ee07b7fa3b490498661f204a43e932 afb92ac871544fcc801552e218c9cfb5 X 00ee07b7fa3b490498661f204a43e932--afb92ac871544fcc801552e218c9cfb5 afb92ac871544fcc801552e218c9cfb5--bea1d982569543c5bf2143f324b2fc71 b539e01f83484cc9a3805dddd26492ba RZ(-1.0*g1) afb92ac871544fcc801552e218c9cfb5--b539e01f83484cc9a3805dddd26492ba 59ae0327206c4a4a864b86b20ae1c88e X b539e01f83484cc9a3805dddd26492ba--59ae0327206c4a4a864b86b20ae1c88e 59ae0327206c4a4a864b86b20ae1c88e--1c45e79393c84ed69ccbaee5ff10aa11 4091f2b579ea4766b9513f56208ab006 RX(b16) 59ae0327206c4a4a864b86b20ae1c88e--4091f2b579ea4766b9513f56208ab006 4091f2b579ea4766b9513f56208ab006--6cbb043172374956b553845714e6c889 9dbf730242a643b8a50b5bbc7c430f3d 58760b47e22d477b87f25a71ea3f1534 9110ac26ee9e47c49f6423968d16d060--58760b47e22d477b87f25a71ea3f1534 63f802a26eb141dd9e37a46252d8db73 58760b47e22d477b87f25a71ea3f1534--63f802a26eb141dd9e37a46252d8db73 7f6c4ce145434f06b981cde973e68028 63f802a26eb141dd9e37a46252d8db73--7f6c4ce145434f06b981cde973e68028 d678b925261f4b288c4f558160e8e5a1 7f6c4ce145434f06b981cde973e68028--d678b925261f4b288c4f558160e8e5a1 fcb5cdb7a32140af9d6747fd5d0f219d d678b925261f4b288c4f558160e8e5a1--fcb5cdb7a32140af9d6747fd5d0f219d 5022ac9c4847496eb54b91da6b1bc017 fcb5cdb7a32140af9d6747fd5d0f219d--5022ac9c4847496eb54b91da6b1bc017 8b847189640a48d3b382d78f045a5c5f X 5022ac9c4847496eb54b91da6b1bc017--8b847189640a48d3b382d78f045a5c5f 8b847189640a48d3b382d78f045a5c5f--770e3c8df49145a69cb8c2c92441ceb8 971b087564ed427ba24809cd0cb64145 RZ(1.0*g0) 8b847189640a48d3b382d78f045a5c5f--971b087564ed427ba24809cd0cb64145 cb5d1d50297e4a87a704ea98a9ec87f4 X 971b087564ed427ba24809cd0cb64145--cb5d1d50297e4a87a704ea98a9ec87f4 cb5d1d50297e4a87a704ea98a9ec87f4--cd6f4df19bb94bd0952bf17ca02d0a5b 3d763a14adc945cb9b60f04372fe6f9b cb5d1d50297e4a87a704ea98a9ec87f4--3d763a14adc945cb9b60f04372fe6f9b 84af3221406e4d0d91fd34d92531a97f 3d763a14adc945cb9b60f04372fe6f9b--84af3221406e4d0d91fd34d92531a97f bd3e88732e8c403aaeb6412e85c99afc 84af3221406e4d0d91fd34d92531a97f--bd3e88732e8c403aaeb6412e85c99afc 1082519eecff40f5bf45ca345965ec50 bd3e88732e8c403aaeb6412e85c99afc--1082519eecff40f5bf45ca345965ec50 ca8c83ffcd09462493db36bd75278b48 1082519eecff40f5bf45ca345965ec50--ca8c83ffcd09462493db36bd75278b48 94b92871965e4baf9951517dc2e4a3b0 ca8c83ffcd09462493db36bd75278b48--94b92871965e4baf9951517dc2e4a3b0 bbc6d0db6a2f44e2b02c5e47a26588d3 94b92871965e4baf9951517dc2e4a3b0--bbc6d0db6a2f44e2b02c5e47a26588d3 79d3aaf389f24f53b1340c5a12bce728 bbc6d0db6a2f44e2b02c5e47a26588d3--79d3aaf389f24f53b1340c5a12bce728 c83e84c114bd45178a3a880dde9fd5ad 79d3aaf389f24f53b1340c5a12bce728--c83e84c114bd45178a3a880dde9fd5ad 1ae32eabc79d4a20b8c8877c05f0be83 c83e84c114bd45178a3a880dde9fd5ad--1ae32eabc79d4a20b8c8877c05f0be83 056631c97a6c46dab3b0ae33786ef8e9 1ae32eabc79d4a20b8c8877c05f0be83--056631c97a6c46dab3b0ae33786ef8e9 f8412cc3f9934e2fbce6cf17d97193d2 056631c97a6c46dab3b0ae33786ef8e9--f8412cc3f9934e2fbce6cf17d97193d2 964ba3a0e8624e75ad7ad50a355efb75 f8412cc3f9934e2fbce6cf17d97193d2--964ba3a0e8624e75ad7ad50a355efb75 0d5c168744384a78977aa22d70eedc2d 964ba3a0e8624e75ad7ad50a355efb75--0d5c168744384a78977aa22d70eedc2d a85250b1731d4ff9a634a483005ac27c 0d5c168744384a78977aa22d70eedc2d--a85250b1731d4ff9a634a483005ac27c f3704b6a111d4b34b2e38f6388b04e85 a85250b1731d4ff9a634a483005ac27c--f3704b6a111d4b34b2e38f6388b04e85 8e9d94180edd43b5b672174ca36da1cd f3704b6a111d4b34b2e38f6388b04e85--8e9d94180edd43b5b672174ca36da1cd 6014ab7c5248454897e303d861150400 8e9d94180edd43b5b672174ca36da1cd--6014ab7c5248454897e303d861150400 05dc52790ac44ea69472c85de72a4623 6014ab7c5248454897e303d861150400--05dc52790ac44ea69472c85de72a4623 bba692fba3b04e3b96d9cde7856c8657 05dc52790ac44ea69472c85de72a4623--bba692fba3b04e3b96d9cde7856c8657 aa360f933a154ae18ac37ca7f3032929 bba692fba3b04e3b96d9cde7856c8657--aa360f933a154ae18ac37ca7f3032929 5e294ec998b34c26b4fc774400591f11 aa360f933a154ae18ac37ca7f3032929--5e294ec998b34c26b4fc774400591f11 89694764d59e4ce08d86f31c46b11720 5e294ec998b34c26b4fc774400591f11--89694764d59e4ce08d86f31c46b11720 11d76731519e4fa286dd0c13a96ac445 89694764d59e4ce08d86f31c46b11720--11d76731519e4fa286dd0c13a96ac445 86438246129746bf80c66653a571ff23 11d76731519e4fa286dd0c13a96ac445--86438246129746bf80c66653a571ff23 a48970cd782c49ff977ec71da6cc4680 86438246129746bf80c66653a571ff23--a48970cd782c49ff977ec71da6cc4680 e9563ce8db4740b58c72de70557c3745 a48970cd782c49ff977ec71da6cc4680--e9563ce8db4740b58c72de70557c3745 caadd15cb8584fc7b0fbb3717b6bbe7b e9563ce8db4740b58c72de70557c3745--caadd15cb8584fc7b0fbb3717b6bbe7b 3088130e9fb84c4595e068259a2aa2a4 caadd15cb8584fc7b0fbb3717b6bbe7b--3088130e9fb84c4595e068259a2aa2a4 395788d7db054ad0b7a7c24c9bb06009 3088130e9fb84c4595e068259a2aa2a4--395788d7db054ad0b7a7c24c9bb06009 adcbe2b0c0994dd9a11f6bb3a1d248c9 395788d7db054ad0b7a7c24c9bb06009--adcbe2b0c0994dd9a11f6bb3a1d248c9 276f45d17d2f4db089134b8af4ceed4f adcbe2b0c0994dd9a11f6bb3a1d248c9--276f45d17d2f4db089134b8af4ceed4f 2895502ed5944a348d983b39eef5da86 276f45d17d2f4db089134b8af4ceed4f--2895502ed5944a348d983b39eef5da86 13a0a30962aa46fc97411bf2d6b46c51 2895502ed5944a348d983b39eef5da86--13a0a30962aa46fc97411bf2d6b46c51 75431669fd694a9cbf02f135efc677d6 13a0a30962aa46fc97411bf2d6b46c51--75431669fd694a9cbf02f135efc677d6 50e599882fe14ad281901d50ede60810 75431669fd694a9cbf02f135efc677d6--50e599882fe14ad281901d50ede60810 8bce2e670ede4a18a14ef39d5b33e8c4 50e599882fe14ad281901d50ede60810--8bce2e670ede4a18a14ef39d5b33e8c4 879405ad2036415b93236b3a80544958 8bce2e670ede4a18a14ef39d5b33e8c4--879405ad2036415b93236b3a80544958 16d5ca7914cc4d08b03a4af8403ab3d5 879405ad2036415b93236b3a80544958--16d5ca7914cc4d08b03a4af8403ab3d5 f0171dac4d834e73b55420044ca8d139 16d5ca7914cc4d08b03a4af8403ab3d5--f0171dac4d834e73b55420044ca8d139 6cf1be807f304c7492e37d6e3d386bfa f0171dac4d834e73b55420044ca8d139--6cf1be807f304c7492e37d6e3d386bfa 619c74acb35545579fd2c751f81d1fc7 6cf1be807f304c7492e37d6e3d386bfa--619c74acb35545579fd2c751f81d1fc7 45736f42999f4670a8ad6af4ce7b206a 619c74acb35545579fd2c751f81d1fc7--45736f42999f4670a8ad6af4ce7b206a 73d845eb2e454f6f8130ca1c9ed34679 45736f42999f4670a8ad6af4ce7b206a--73d845eb2e454f6f8130ca1c9ed34679 48b7eb766fb34300b49a39f3599de591 73d845eb2e454f6f8130ca1c9ed34679--48b7eb766fb34300b49a39f3599de591 6239e96964e04b4f973cb6938d910c21 48b7eb766fb34300b49a39f3599de591--6239e96964e04b4f973cb6938d910c21 a8e0cb60fc2b4799a6aeff6196b70035 6239e96964e04b4f973cb6938d910c21--a8e0cb60fc2b4799a6aeff6196b70035 ff489f1151c94a0885be9f9ae57c489f a8e0cb60fc2b4799a6aeff6196b70035--ff489f1151c94a0885be9f9ae57c489f 849e04d709e14a1cb0065a0a692e36ac ff489f1151c94a0885be9f9ae57c489f--849e04d709e14a1cb0065a0a692e36ac 668afe5a05964d46ba03e9598aa0e746 X 849e04d709e14a1cb0065a0a692e36ac--668afe5a05964d46ba03e9598aa0e746 668afe5a05964d46ba03e9598aa0e746--b4cb351e2c014a7dbc842b395d358431 1bdfc0a532474994bf9d1b4ad9fe4e4f RZ(-1.0*g0) 668afe5a05964d46ba03e9598aa0e746--1bdfc0a532474994bf9d1b4ad9fe4e4f 66a4327c745e44b9b1c78217f4ae1b0a X 1bdfc0a532474994bf9d1b4ad9fe4e4f--66a4327c745e44b9b1c78217f4ae1b0a 66a4327c745e44b9b1c78217f4ae1b0a--5784627150f1461e884e14b36e19c35b 4bb4ea09e13444fb8427853aac03249f 66a4327c745e44b9b1c78217f4ae1b0a--4bb4ea09e13444fb8427853aac03249f db6ecd989ce64e8381e345a3826d0413 4bb4ea09e13444fb8427853aac03249f--db6ecd989ce64e8381e345a3826d0413 8b7a7ef718de46f4ba2d7645f6df46c1 db6ecd989ce64e8381e345a3826d0413--8b7a7ef718de46f4ba2d7645f6df46c1 49c683979f8f4f6e92971b6c0e8a2b51 8b7a7ef718de46f4ba2d7645f6df46c1--49c683979f8f4f6e92971b6c0e8a2b51 e1a3a9b21dcf4a12875d7a4d64eead25 49c683979f8f4f6e92971b6c0e8a2b51--e1a3a9b21dcf4a12875d7a4d64eead25 df49737b98234d60b560fdb6b5e05b64 e1a3a9b21dcf4a12875d7a4d64eead25--df49737b98234d60b560fdb6b5e05b64 9c15ab2260ba44a896dffff313baa76a df49737b98234d60b560fdb6b5e05b64--9c15ab2260ba44a896dffff313baa76a 4ccf116d71bb4da4a4aced5bd6f21733 9c15ab2260ba44a896dffff313baa76a--4ccf116d71bb4da4a4aced5bd6f21733 0ebb1df369c548199fd11e8a68a5df8e 4ccf116d71bb4da4a4aced5bd6f21733--0ebb1df369c548199fd11e8a68a5df8e fd4aab5bcc824577ab529c4ba32f4e5e 0ebb1df369c548199fd11e8a68a5df8e--fd4aab5bcc824577ab529c4ba32f4e5e 4cce70f9406e4c9e9a6a77a11953e185 fd4aab5bcc824577ab529c4ba32f4e5e--4cce70f9406e4c9e9a6a77a11953e185 aa5cdd0dc3544b2c966b686867fbca83 4cce70f9406e4c9e9a6a77a11953e185--aa5cdd0dc3544b2c966b686867fbca83 cd7d3e3d894341998d98a4356dd7b6d7 aa5cdd0dc3544b2c966b686867fbca83--cd7d3e3d894341998d98a4356dd7b6d7 bf3f3141683f49ad94511082afdbad6b cd7d3e3d894341998d98a4356dd7b6d7--bf3f3141683f49ad94511082afdbad6b ac91a65ba7a84d7db595f7dd8a3613f4 bf3f3141683f49ad94511082afdbad6b--ac91a65ba7a84d7db595f7dd8a3613f4 3df19877c0174919adc919d251359a2c ac91a65ba7a84d7db595f7dd8a3613f4--3df19877c0174919adc919d251359a2c aaf85a531d0a4cdea7eb9ce65645c031 3df19877c0174919adc919d251359a2c--aaf85a531d0a4cdea7eb9ce65645c031 b054cd7fdf434b5983d38b2040d58a5a aaf85a531d0a4cdea7eb9ce65645c031--b054cd7fdf434b5983d38b2040d58a5a 77cbac4ae1cd4e1a9471e59978d90679 b054cd7fdf434b5983d38b2040d58a5a--77cbac4ae1cd4e1a9471e59978d90679 81089c94f44448c78ab095c3438d2921 77cbac4ae1cd4e1a9471e59978d90679--81089c94f44448c78ab095c3438d2921 f97fe104b962433bbe7a1961aab8f996 81089c94f44448c78ab095c3438d2921--f97fe104b962433bbe7a1961aab8f996 b73a875b354541e181e7abdebc1e7caa f97fe104b962433bbe7a1961aab8f996--b73a875b354541e181e7abdebc1e7caa ef5f84e3dbc947d283d6128dadbbcff9 b73a875b354541e181e7abdebc1e7caa--ef5f84e3dbc947d283d6128dadbbcff9 e5b315aa5bc94d2c961c6af0b15278e4 ef5f84e3dbc947d283d6128dadbbcff9--e5b315aa5bc94d2c961c6af0b15278e4 de1d09d9deae40ec868f4f77874f7bbf e5b315aa5bc94d2c961c6af0b15278e4--de1d09d9deae40ec868f4f77874f7bbf e957dc8dd79c4bb6820f3c31c02183ac de1d09d9deae40ec868f4f77874f7bbf--e957dc8dd79c4bb6820f3c31c02183ac 0c3f402fffeb447a9c20e4ea215a5aff e957dc8dd79c4bb6820f3c31c02183ac--0c3f402fffeb447a9c20e4ea215a5aff 1e34dc12bdef46f4ab453523f2ade060 0c3f402fffeb447a9c20e4ea215a5aff--1e34dc12bdef46f4ab453523f2ade060 a7dd18cd67ce4c33b17f0fb02f56cdba 1e34dc12bdef46f4ab453523f2ade060--a7dd18cd67ce4c33b17f0fb02f56cdba 98bc63076375498cb4ed80d33f5bf054 a7dd18cd67ce4c33b17f0fb02f56cdba--98bc63076375498cb4ed80d33f5bf054 2c088002614649918e22fc37aa42f71f 98bc63076375498cb4ed80d33f5bf054--2c088002614649918e22fc37aa42f71f 25930162b8d84a739708517227f6a12f 2c088002614649918e22fc37aa42f71f--25930162b8d84a739708517227f6a12f 2d3028a2ed9d466abd62eed5b82281ca 25930162b8d84a739708517227f6a12f--2d3028a2ed9d466abd62eed5b82281ca bdf6c730005a47548d61c46e5083bc8c 2d3028a2ed9d466abd62eed5b82281ca--bdf6c730005a47548d61c46e5083bc8c ce31e0df1477418c80fcbf498aedd937 bdf6c730005a47548d61c46e5083bc8c--ce31e0df1477418c80fcbf498aedd937 1fc147fa520f48aa9d3bacc023818bcb ce31e0df1477418c80fcbf498aedd937--1fc147fa520f48aa9d3bacc023818bcb b6a2262239854860899f8fb218554022 1fc147fa520f48aa9d3bacc023818bcb--b6a2262239854860899f8fb218554022 d301a30b5a2a426f8aa6ed6ca2b2f396 b6a2262239854860899f8fb218554022--d301a30b5a2a426f8aa6ed6ca2b2f396 61f432c78f8345fb9654875afb9af9fd d301a30b5a2a426f8aa6ed6ca2b2f396--61f432c78f8345fb9654875afb9af9fd a548a260fbb047c8b0a4e2487be9cf13 61f432c78f8345fb9654875afb9af9fd--a548a260fbb047c8b0a4e2487be9cf13 e99aa82b10c84f7a8c9fe26a25839f51 a548a260fbb047c8b0a4e2487be9cf13--e99aa82b10c84f7a8c9fe26a25839f51 0c4bf224c7374f0ba2cc4c85086a576e e99aa82b10c84f7a8c9fe26a25839f51--0c4bf224c7374f0ba2cc4c85086a576e 3111a626762c4ba2b4d1254f2b88cb9d 0c4bf224c7374f0ba2cc4c85086a576e--3111a626762c4ba2b4d1254f2b88cb9d bae7f9d8232844d6b2514f326442d0aa X 3111a626762c4ba2b4d1254f2b88cb9d--bae7f9d8232844d6b2514f326442d0aa bae7f9d8232844d6b2514f326442d0aa--1f8d5c9c12954ad68b6bd482acaf2743 a0ec63c95d23410d826123f29c5aff71 RZ(-1.0*g0) bae7f9d8232844d6b2514f326442d0aa--a0ec63c95d23410d826123f29c5aff71 3ea7b90fe0d042baa24ce344c02cb94b X a0ec63c95d23410d826123f29c5aff71--3ea7b90fe0d042baa24ce344c02cb94b 3ea7b90fe0d042baa24ce344c02cb94b--63d9c5fc39bf497caefe64d25d71da1a b564cdbc93bc4d4187dea3993fe55e2c 3ea7b90fe0d042baa24ce344c02cb94b--b564cdbc93bc4d4187dea3993fe55e2c cedde8548db748c4be7323196c9e705b b564cdbc93bc4d4187dea3993fe55e2c--cedde8548db748c4be7323196c9e705b d9d1b0809e144b8e8533f8c4c58aa4eb cedde8548db748c4be7323196c9e705b--d9d1b0809e144b8e8533f8c4c58aa4eb 64a80e3664924675918d596b48462db3 d9d1b0809e144b8e8533f8c4c58aa4eb--64a80e3664924675918d596b48462db3 247e163306894c34b0885a6f70b28463 64a80e3664924675918d596b48462db3--247e163306894c34b0885a6f70b28463 7a989503a8c6402bbdd588c7394c6f07 247e163306894c34b0885a6f70b28463--7a989503a8c6402bbdd588c7394c6f07 73dad57ae5844a0ead1e5202017c7d4e 7a989503a8c6402bbdd588c7394c6f07--73dad57ae5844a0ead1e5202017c7d4e fa4d1eb9990245b9a77a1dd82dcc4f39 X 73dad57ae5844a0ead1e5202017c7d4e--fa4d1eb9990245b9a77a1dd82dcc4f39 fa4d1eb9990245b9a77a1dd82dcc4f39--c1d65eb9b55c4a1b81828a7bba26f4a0 f83fb11f46a347fcbbf113a130f4f4b0 RZ(-1.0*g0) fa4d1eb9990245b9a77a1dd82dcc4f39--f83fb11f46a347fcbbf113a130f4f4b0 c43f522a55d74081988c8cb50097f6bb X f83fb11f46a347fcbbf113a130f4f4b0--c43f522a55d74081988c8cb50097f6bb c43f522a55d74081988c8cb50097f6bb--20c22d09edde42afb49fa9a34e0dfde9 d381363807034ddfb259209d6b9a7bf7 c43f522a55d74081988c8cb50097f6bb--d381363807034ddfb259209d6b9a7bf7 b1d3bf68805946f189e614b4e9dfc0ee d381363807034ddfb259209d6b9a7bf7--b1d3bf68805946f189e614b4e9dfc0ee 988267423b6141159d0df1736ccd673a b1d3bf68805946f189e614b4e9dfc0ee--988267423b6141159d0df1736ccd673a b1db76dda4cf460b98b5b5c8fa4efe5b 988267423b6141159d0df1736ccd673a--b1db76dda4cf460b98b5b5c8fa4efe5b e9b11ee6bad64853a5e2d52bad46e806 b1db76dda4cf460b98b5b5c8fa4efe5b--e9b11ee6bad64853a5e2d52bad46e806 e820fdecf6894ab68daf17fec2638aec e9b11ee6bad64853a5e2d52bad46e806--e820fdecf6894ab68daf17fec2638aec 6aa5fcb3c61b4851ab6539cfa85a6e55 e820fdecf6894ab68daf17fec2638aec--6aa5fcb3c61b4851ab6539cfa85a6e55 6ad420894cc544a7bbb21fdb350089c2 6aa5fcb3c61b4851ab6539cfa85a6e55--6ad420894cc544a7bbb21fdb350089c2 67fb126d4f9341aab13a9428e4cff23d 6ad420894cc544a7bbb21fdb350089c2--67fb126d4f9341aab13a9428e4cff23d 7f2178ef6d5f4d93bc49fb92452a2f40 67fb126d4f9341aab13a9428e4cff23d--7f2178ef6d5f4d93bc49fb92452a2f40 3380e9b5983e4a33ba8017c2cc616d24 7f2178ef6d5f4d93bc49fb92452a2f40--3380e9b5983e4a33ba8017c2cc616d24 eeebb56590de4971b0a11d281e41badb RX(b07) 3380e9b5983e4a33ba8017c2cc616d24--eeebb56590de4971b0a11d281e41badb d61ee066dcee4d47b28d145be3c60720 eeebb56590de4971b0a11d281e41badb--d61ee066dcee4d47b28d145be3c60720 b80521d70f364379baadb7700e86a779 d61ee066dcee4d47b28d145be3c60720--b80521d70f364379baadb7700e86a779 c3801419d9f04bf4b85d650cd8809dee b80521d70f364379baadb7700e86a779--c3801419d9f04bf4b85d650cd8809dee 6092073f42dc49a0b11567d1f9becab6 c3801419d9f04bf4b85d650cd8809dee--6092073f42dc49a0b11567d1f9becab6 e530e520f73b440899bd7cd649ba665a 6092073f42dc49a0b11567d1f9becab6--e530e520f73b440899bd7cd649ba665a 6ffff09a183442c69ab5f0f9b95d9efb e530e520f73b440899bd7cd649ba665a--6ffff09a183442c69ab5f0f9b95d9efb e1292dc2eefc488ea2c99a8e93cdf755 X 6ffff09a183442c69ab5f0f9b95d9efb--e1292dc2eefc488ea2c99a8e93cdf755 e1292dc2eefc488ea2c99a8e93cdf755--0ceb33540be841a7bce2445c856c4150 f92e81495b4f4fc7a107d7cec0e8e915 RZ(1.0*g1) e1292dc2eefc488ea2c99a8e93cdf755--f92e81495b4f4fc7a107d7cec0e8e915 900dbbf3042148148f8fafc5c948ed9e X f92e81495b4f4fc7a107d7cec0e8e915--900dbbf3042148148f8fafc5c948ed9e 900dbbf3042148148f8fafc5c948ed9e--010fc3e617af44bf8866c3a247e98ab6 26255c89ca894535b029768a23691dc0 900dbbf3042148148f8fafc5c948ed9e--26255c89ca894535b029768a23691dc0 d1694d6716f84fdd9a251b70064a0108 26255c89ca894535b029768a23691dc0--d1694d6716f84fdd9a251b70064a0108 ecbe9a342bab40148669e5a902bf1939 d1694d6716f84fdd9a251b70064a0108--ecbe9a342bab40148669e5a902bf1939 9a033d14467149ec92ec8794fb30123b ecbe9a342bab40148669e5a902bf1939--9a033d14467149ec92ec8794fb30123b e3d85269d6214e8b8c7bd7e92ab5c8db 9a033d14467149ec92ec8794fb30123b--e3d85269d6214e8b8c7bd7e92ab5c8db 849cd53e14cb470b9a69f44889754528 e3d85269d6214e8b8c7bd7e92ab5c8db--849cd53e14cb470b9a69f44889754528 a8c1ded25e4c4ecb9a8b1c26d48ac43a 849cd53e14cb470b9a69f44889754528--a8c1ded25e4c4ecb9a8b1c26d48ac43a 0c3b2510ee3b445fa03a73d4c7e26d32 a8c1ded25e4c4ecb9a8b1c26d48ac43a--0c3b2510ee3b445fa03a73d4c7e26d32 7944859ce4164421b874de1c1fc25905 0c3b2510ee3b445fa03a73d4c7e26d32--7944859ce4164421b874de1c1fc25905 56f7a8bc3b03461ea31de02e78c63117 7944859ce4164421b874de1c1fc25905--56f7a8bc3b03461ea31de02e78c63117 edc910c99800425b9563d797c839f161 56f7a8bc3b03461ea31de02e78c63117--edc910c99800425b9563d797c839f161 6de3aa9e6b304c488786160dc50b5405 edc910c99800425b9563d797c839f161--6de3aa9e6b304c488786160dc50b5405 bf0d2a52d6574845b7d5a46914761aea 6de3aa9e6b304c488786160dc50b5405--bf0d2a52d6574845b7d5a46914761aea ec39e3775f374356a4b614ff7612b080 bf0d2a52d6574845b7d5a46914761aea--ec39e3775f374356a4b614ff7612b080 ba6c1cde6f5c46469840b5a439897731 ec39e3775f374356a4b614ff7612b080--ba6c1cde6f5c46469840b5a439897731 22b6bba51f894d9c860bc88dfb69a1f0 ba6c1cde6f5c46469840b5a439897731--22b6bba51f894d9c860bc88dfb69a1f0 f5a4765bb1db458d813fde510e376936 22b6bba51f894d9c860bc88dfb69a1f0--f5a4765bb1db458d813fde510e376936 4f9e2e0444da416e86f148372e65e569 f5a4765bb1db458d813fde510e376936--4f9e2e0444da416e86f148372e65e569 4e2335e3595f485c8e9f34ea274437a4 4f9e2e0444da416e86f148372e65e569--4e2335e3595f485c8e9f34ea274437a4 fb51b66a00ef4786bc4ee6f54b845921 4e2335e3595f485c8e9f34ea274437a4--fb51b66a00ef4786bc4ee6f54b845921 84f8e77c544f499fab15cd17b923187a fb51b66a00ef4786bc4ee6f54b845921--84f8e77c544f499fab15cd17b923187a ecf57f8ce5984ccd9669f134ec9736b5 84f8e77c544f499fab15cd17b923187a--ecf57f8ce5984ccd9669f134ec9736b5 08a7279c02b942908dcc2bd8b7697354 ecf57f8ce5984ccd9669f134ec9736b5--08a7279c02b942908dcc2bd8b7697354 666b62c7c44748e1a37208e7a0f24de0 08a7279c02b942908dcc2bd8b7697354--666b62c7c44748e1a37208e7a0f24de0 f7b702ca7b11417a93d7387026c8c610 666b62c7c44748e1a37208e7a0f24de0--f7b702ca7b11417a93d7387026c8c610 e3c092006bbe41e2b1a198fdb2e6f261 f7b702ca7b11417a93d7387026c8c610--e3c092006bbe41e2b1a198fdb2e6f261 4ab6b43fc62f41738080557949e1cd31 e3c092006bbe41e2b1a198fdb2e6f261--4ab6b43fc62f41738080557949e1cd31 468c50b88eff47c1b6d6f73f2524af72 4ab6b43fc62f41738080557949e1cd31--468c50b88eff47c1b6d6f73f2524af72 8f24fe91aeb847768e7cf5572308b3a0 468c50b88eff47c1b6d6f73f2524af72--8f24fe91aeb847768e7cf5572308b3a0 9bf66290f9b343b6bd38c6088249d919 8f24fe91aeb847768e7cf5572308b3a0--9bf66290f9b343b6bd38c6088249d919 801e426b995444beae54ef170fb5d9af 9bf66290f9b343b6bd38c6088249d919--801e426b995444beae54ef170fb5d9af 45dc545d8f994fc3b0ca7aa20ca4818d 801e426b995444beae54ef170fb5d9af--45dc545d8f994fc3b0ca7aa20ca4818d ec779d1a8e214184b5b57a54b51cbf0d 45dc545d8f994fc3b0ca7aa20ca4818d--ec779d1a8e214184b5b57a54b51cbf0d eed52e1041cb4a899312668417b86ec5 ec779d1a8e214184b5b57a54b51cbf0d--eed52e1041cb4a899312668417b86ec5 4de641e39ee94dfcb65a3d1144147dee eed52e1041cb4a899312668417b86ec5--4de641e39ee94dfcb65a3d1144147dee 4062a1ba874b4130b73b0907fa0305ba 4de641e39ee94dfcb65a3d1144147dee--4062a1ba874b4130b73b0907fa0305ba 2d5b0d01526d497e9457766b6e4f0efb 4062a1ba874b4130b73b0907fa0305ba--2d5b0d01526d497e9457766b6e4f0efb 5a93275045d24478b490a4f92a2fba64 2d5b0d01526d497e9457766b6e4f0efb--5a93275045d24478b490a4f92a2fba64 6b285c9c22874e5bb888b122ac8ff6ec 5a93275045d24478b490a4f92a2fba64--6b285c9c22874e5bb888b122ac8ff6ec fb21d5ed0f294f69bf6801c837240d9d 6b285c9c22874e5bb888b122ac8ff6ec--fb21d5ed0f294f69bf6801c837240d9d 456d1b41a9ac4ffdbf91c1acef1639bb fb21d5ed0f294f69bf6801c837240d9d--456d1b41a9ac4ffdbf91c1acef1639bb a69422f72251411da285a537699124f1 456d1b41a9ac4ffdbf91c1acef1639bb--a69422f72251411da285a537699124f1 7b14358dc4884b5c85c30f9dbc55fdbd a69422f72251411da285a537699124f1--7b14358dc4884b5c85c30f9dbc55fdbd 88342ad986ac4394b46d113cf3d460e9 7b14358dc4884b5c85c30f9dbc55fdbd--88342ad986ac4394b46d113cf3d460e9 c4cd78666460405fb9ae1f3c64d2ff8e 88342ad986ac4394b46d113cf3d460e9--c4cd78666460405fb9ae1f3c64d2ff8e 5eca180fb6cd45db80eb58687fbdb671 c4cd78666460405fb9ae1f3c64d2ff8e--5eca180fb6cd45db80eb58687fbdb671 532410c61f314b6391f5ecad384fb068 5eca180fb6cd45db80eb58687fbdb671--532410c61f314b6391f5ecad384fb068 90d9b65b1cdd4c088d98e05eac1be055 532410c61f314b6391f5ecad384fb068--90d9b65b1cdd4c088d98e05eac1be055 e495bab379294f9ba66f18b8c6e72f4e 90d9b65b1cdd4c088d98e05eac1be055--e495bab379294f9ba66f18b8c6e72f4e ea52bddbbe054e95b23c58cffbf7cfa4 X e495bab379294f9ba66f18b8c6e72f4e--ea52bddbbe054e95b23c58cffbf7cfa4 ea52bddbbe054e95b23c58cffbf7cfa4--133263870e7f422ab6678749a0513b94 cc13de8b5caa4c68a11ead9bb2dff761 RZ(-1.0*g1) ea52bddbbe054e95b23c58cffbf7cfa4--cc13de8b5caa4c68a11ead9bb2dff761 932c6208f1f64d8093bbdebd2c3792a7 X cc13de8b5caa4c68a11ead9bb2dff761--932c6208f1f64d8093bbdebd2c3792a7 932c6208f1f64d8093bbdebd2c3792a7--4d00733b385f4f9eae8122897eb7442a 89f3f298fd864dcfa16cbb48c3097a7b 932c6208f1f64d8093bbdebd2c3792a7--89f3f298fd864dcfa16cbb48c3097a7b acfc1269c5094d5088c78e4d203005b1 89f3f298fd864dcfa16cbb48c3097a7b--acfc1269c5094d5088c78e4d203005b1 8a1bb97c2e7d4ca59d84322011970dfa acfc1269c5094d5088c78e4d203005b1--8a1bb97c2e7d4ca59d84322011970dfa 08d4888ce05046dfa38d7469fcbff020 8a1bb97c2e7d4ca59d84322011970dfa--08d4888ce05046dfa38d7469fcbff020 77a26660b4fd403882336d979fb48f9e 08d4888ce05046dfa38d7469fcbff020--77a26660b4fd403882336d979fb48f9e 5dd930ef84fa4edeb2fe158f8af554b5 77a26660b4fd403882336d979fb48f9e--5dd930ef84fa4edeb2fe158f8af554b5 4761a73c02924e339321709bc0732ef9 5dd930ef84fa4edeb2fe158f8af554b5--4761a73c02924e339321709bc0732ef9 d209c77137854954946de501cdc1d5fb 4761a73c02924e339321709bc0732ef9--d209c77137854954946de501cdc1d5fb 940d05abbfcb424d951b959e59428270 d209c77137854954946de501cdc1d5fb--940d05abbfcb424d951b959e59428270 2ef3baa6798a4e1686b9e649cec52bd7 940d05abbfcb424d951b959e59428270--2ef3baa6798a4e1686b9e649cec52bd7 bc023aa2629b43a9ad3f450ea13ff381 2ef3baa6798a4e1686b9e649cec52bd7--bc023aa2629b43a9ad3f450ea13ff381 0ff2c9baebe8428fb1ce36f1244a1141 bc023aa2629b43a9ad3f450ea13ff381--0ff2c9baebe8428fb1ce36f1244a1141 617c2895e2524686ae821e79873ca65e 0ff2c9baebe8428fb1ce36f1244a1141--617c2895e2524686ae821e79873ca65e 06f4b9fab5dc49e79a38df0ff1653d5c 617c2895e2524686ae821e79873ca65e--06f4b9fab5dc49e79a38df0ff1653d5c a470f052be9241afb48b607dba47154f 06f4b9fab5dc49e79a38df0ff1653d5c--a470f052be9241afb48b607dba47154f 329cf4d0c117414f8785e80ae95fb757 a470f052be9241afb48b607dba47154f--329cf4d0c117414f8785e80ae95fb757 db14bc5c4a7b40ca9ec9706da3c888c4 329cf4d0c117414f8785e80ae95fb757--db14bc5c4a7b40ca9ec9706da3c888c4 cdae27aad9234759ae57d6632361ffdd db14bc5c4a7b40ca9ec9706da3c888c4--cdae27aad9234759ae57d6632361ffdd 5934da8827914a139ec5541a90f7582e cdae27aad9234759ae57d6632361ffdd--5934da8827914a139ec5541a90f7582e 3a16523828b64f21a3b3ecfe43b143ca 5934da8827914a139ec5541a90f7582e--3a16523828b64f21a3b3ecfe43b143ca 1c66a55089464152b704275f8287a0e5 3a16523828b64f21a3b3ecfe43b143ca--1c66a55089464152b704275f8287a0e5 de19fcc4ad0445cab7669c4ef1a4ed6c 1c66a55089464152b704275f8287a0e5--de19fcc4ad0445cab7669c4ef1a4ed6c 284ab51b8d8147f6a52250593e0db97b de19fcc4ad0445cab7669c4ef1a4ed6c--284ab51b8d8147f6a52250593e0db97b 87196ec0915c4b2b92da8a76b66a1626 284ab51b8d8147f6a52250593e0db97b--87196ec0915c4b2b92da8a76b66a1626 a9893089eedd4552ab5f5b6cfe7fb593 87196ec0915c4b2b92da8a76b66a1626--a9893089eedd4552ab5f5b6cfe7fb593 9c19046338404486a1d335f1c20a61a7 a9893089eedd4552ab5f5b6cfe7fb593--9c19046338404486a1d335f1c20a61a7 8115ba70be804168a69c928a98af278e 9c19046338404486a1d335f1c20a61a7--8115ba70be804168a69c928a98af278e f01fa348753e44ebaccada531dcb3d4f 8115ba70be804168a69c928a98af278e--f01fa348753e44ebaccada531dcb3d4f e38668375b4c4cea8311361fb13f6b05 f01fa348753e44ebaccada531dcb3d4f--e38668375b4c4cea8311361fb13f6b05 4dcec415f07043c08551d5ea2ad1f8f6 e38668375b4c4cea8311361fb13f6b05--4dcec415f07043c08551d5ea2ad1f8f6 5bbbf247843044f08e518a8e41259d90 4dcec415f07043c08551d5ea2ad1f8f6--5bbbf247843044f08e518a8e41259d90 1871a525b82a43409b67569f9a008a03 5bbbf247843044f08e518a8e41259d90--1871a525b82a43409b67569f9a008a03 d8c5c58bffaa4744959801250b982d23 1871a525b82a43409b67569f9a008a03--d8c5c58bffaa4744959801250b982d23 a75e631928d74c998b81892778f0f3d3 d8c5c58bffaa4744959801250b982d23--a75e631928d74c998b81892778f0f3d3 f60d63f7326b4d05bdc2efb04a44a04e a75e631928d74c998b81892778f0f3d3--f60d63f7326b4d05bdc2efb04a44a04e 10912c81131b4399bf480f6ac6fc692c f60d63f7326b4d05bdc2efb04a44a04e--10912c81131b4399bf480f6ac6fc692c cb9ab9e1ced44ef389549217c078deeb 10912c81131b4399bf480f6ac6fc692c--cb9ab9e1ced44ef389549217c078deeb ede9fbcaf30b4583a796a3aef4d71370 cb9ab9e1ced44ef389549217c078deeb--ede9fbcaf30b4583a796a3aef4d71370 838f9b225ac941b2b7e49a0578051434 ede9fbcaf30b4583a796a3aef4d71370--838f9b225ac941b2b7e49a0578051434 7b5cbfd1d32c4739906ecebf883a1a6e 838f9b225ac941b2b7e49a0578051434--7b5cbfd1d32c4739906ecebf883a1a6e 0704fa94d4d543ad8a239c2d436bc5a8 7b5cbfd1d32c4739906ecebf883a1a6e--0704fa94d4d543ad8a239c2d436bc5a8 083dbaf6aeed407880a775595d6a6861 0704fa94d4d543ad8a239c2d436bc5a8--083dbaf6aeed407880a775595d6a6861 188f722280c74732a1c9d375a3cfdf0e 083dbaf6aeed407880a775595d6a6861--188f722280c74732a1c9d375a3cfdf0e 27007f714f22480c81db61310fa3bbaa X 188f722280c74732a1c9d375a3cfdf0e--27007f714f22480c81db61310fa3bbaa 27007f714f22480c81db61310fa3bbaa--4bace98d488b41e6a8c6349fda3dcf8f fb86d41a1a50471195d8291040c93c51 RZ(-1.0*g1) 27007f714f22480c81db61310fa3bbaa--fb86d41a1a50471195d8291040c93c51 acdfd7c5b04a43a58d32317968018416 X fb86d41a1a50471195d8291040c93c51--acdfd7c5b04a43a58d32317968018416 acdfd7c5b04a43a58d32317968018416--bd738e0157c44ec2befe5ca3f46198df b8f5dc271c894ad3b2603e1d3bd6d949 acdfd7c5b04a43a58d32317968018416--b8f5dc271c894ad3b2603e1d3bd6d949 73c40c3d2c6b432f96775202b9a82432 b8f5dc271c894ad3b2603e1d3bd6d949--73c40c3d2c6b432f96775202b9a82432 3e4992607e244393bb48415d63d123b3 73c40c3d2c6b432f96775202b9a82432--3e4992607e244393bb48415d63d123b3 24af0fb8aa2742d4bffc575f6b5db7b9 3e4992607e244393bb48415d63d123b3--24af0fb8aa2742d4bffc575f6b5db7b9 4942b795d4a64f7484f46fae1c9a0a58 24af0fb8aa2742d4bffc575f6b5db7b9--4942b795d4a64f7484f46fae1c9a0a58 2e4c52c67fcd41ae89d68eca74c80c0a 4942b795d4a64f7484f46fae1c9a0a58--2e4c52c67fcd41ae89d68eca74c80c0a e4cf2098ac774805b0b542573409c51f 2e4c52c67fcd41ae89d68eca74c80c0a--e4cf2098ac774805b0b542573409c51f 64a2624b7f1342978822e735a8659bcd X e4cf2098ac774805b0b542573409c51f--64a2624b7f1342978822e735a8659bcd 64a2624b7f1342978822e735a8659bcd--a0cca6a65d774540aba120623c1a0f09 90d0aa21f05f49ed8c533a1dcc02e60a RZ(-1.0*g1) 64a2624b7f1342978822e735a8659bcd--90d0aa21f05f49ed8c533a1dcc02e60a 35146ea72ddf4cd7ba8eef0032c2f49d X 90d0aa21f05f49ed8c533a1dcc02e60a--35146ea72ddf4cd7ba8eef0032c2f49d 35146ea72ddf4cd7ba8eef0032c2f49d--5de0d522f8454c89bf34ff9191d96a68 6c863f81009e4922803f5f45863b7112 35146ea72ddf4cd7ba8eef0032c2f49d--6c863f81009e4922803f5f45863b7112 95d03c203ca8488f9427e519438efe66 6c863f81009e4922803f5f45863b7112--95d03c203ca8488f9427e519438efe66 3cc9d3dbd09447d7a7521252898a1fe5 95d03c203ca8488f9427e519438efe66--3cc9d3dbd09447d7a7521252898a1fe5 fa77e2feb6d94edba16322434a6639ee 3cc9d3dbd09447d7a7521252898a1fe5--fa77e2feb6d94edba16322434a6639ee 0880caac9f3244f39974378243119fd2 fa77e2feb6d94edba16322434a6639ee--0880caac9f3244f39974378243119fd2 a72eb58c26b548bcbe2d6155fcd33056 0880caac9f3244f39974378243119fd2--a72eb58c26b548bcbe2d6155fcd33056 a8c3700a3fd544998d84a735debbfd7f a72eb58c26b548bcbe2d6155fcd33056--a8c3700a3fd544998d84a735debbfd7f 3967be4c01cf43c5bf4a22a849b24c5a a8c3700a3fd544998d84a735debbfd7f--3967be4c01cf43c5bf4a22a849b24c5a 165207b7ee4a4b1eae7785fff89ec50f 3967be4c01cf43c5bf4a22a849b24c5a--165207b7ee4a4b1eae7785fff89ec50f b30241b4ee71474595780174c5061f64 165207b7ee4a4b1eae7785fff89ec50f--b30241b4ee71474595780174c5061f64 6c10aa5bf5a840898b563be394cf14de b30241b4ee71474595780174c5061f64--6c10aa5bf5a840898b563be394cf14de f02f79a3053d47d6b99a580497ba3a5e RX(b17) 6c10aa5bf5a840898b563be394cf14de--f02f79a3053d47d6b99a580497ba3a5e f02f79a3053d47d6b99a580497ba3a5e--9dbf730242a643b8a50b5bbc7c430f3d"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.5749407062625895\nMaxCut cost at iteration 10: 10.6361656506765\nMaxCut cost at iteration 20: 10.967224127652628\nMaxCut cost at iteration 30: 10.97020457759689\nMaxCut cost at iteration 40: 10.992350487901202\nMaxCut cost at iteration 50: 10.99916287303813\nMaxCut cost at iteration 60: 10.999941894031517\nMaxCut cost at iteration 70: 10.999996086742724\nMaxCut cost at iteration 80: 10.999999731345598\nMaxCut cost at iteration 90: 10.999999979401364\nMaxCut cost at iteration 100: 10.999999997613443\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01001011  2024-02-06T10:22:06.199465 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2024-02-06T10:22:10.459293 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_5c70203a38b440fdb7e2974c3a415273 Constant Chebyshev FM cluster_2cedec270a5f4115bb1d90cc5c1d69f2 Constant Fourier FM ea505bffe54544fab9baa0905f786a47 0 f8a21633ad6047d19049c061e6ac8843 RX(phi) ea505bffe54544fab9baa0905f786a47--f8a21633ad6047d19049c061e6ac8843 2ef71dfef42c4089851166a38cccd2a1 1 187ffe8d2ae841a49d2f9c567d7836f6 RX(acos(phi)) f8a21633ad6047d19049c061e6ac8843--187ffe8d2ae841a49d2f9c567d7836f6 97578b7955d94c5c84faa6497f446ccc 187ffe8d2ae841a49d2f9c567d7836f6--97578b7955d94c5c84faa6497f446ccc 77252cfd677b42cc82d6073b75a3c353 65b13f058931410281f1082225019dc7 RX(phi) 2ef71dfef42c4089851166a38cccd2a1--65b13f058931410281f1082225019dc7 bc65a22f875945dea03e3e4960c458c9 2 01a40e6d1562415ca6af918d5eef055e RX(acos(phi)) 65b13f058931410281f1082225019dc7--01a40e6d1562415ca6af918d5eef055e 01a40e6d1562415ca6af918d5eef055e--77252cfd677b42cc82d6073b75a3c353 c325f8919a974bd79d000af81c477b7c f4c992d127294db39a9e37c80fa15857 RX(phi) bc65a22f875945dea03e3e4960c458c9--f4c992d127294db39a9e37c80fa15857 361c983820534f24ad8de5e4d7319a88 RX(acos(phi)) f4c992d127294db39a9e37c80fa15857--361c983820534f24ad8de5e4d7319a88 361c983820534f24ad8de5e4d7319a88--c325f8919a974bd79d000af81c477b7c <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_589f775eb2604e6fbdb7d7705028c5f5 Constant &lt;function custom_fn at 0x7fecef0d4ca0&gt; FM cluster_f7d296942af9441d8c2d817e24624024 Constant asin FM 5d79d648ad4c4d44b18531c186a897db 0 db5c6e7d11294722a0ee5c64efcea43e RX(asin(phi)) 5d79d648ad4c4d44b18531c186a897db--db5c6e7d11294722a0ee5c64efcea43e eca95f9ccff94ed98a5cb1beecae7724 1 7d1f7f1da0704d0b86dee2054d9652ef RX(phi**2 + asin(phi)) db5c6e7d11294722a0ee5c64efcea43e--7d1f7f1da0704d0b86dee2054d9652ef 87372cc95be94cde9fdbbc0e4128c35f 7d1f7f1da0704d0b86dee2054d9652ef--87372cc95be94cde9fdbbc0e4128c35f 517d5454a8a44a45a5ae78633ab98156 d4eeae19acdf4ad0a8ea576cafbcf27a RX(asin(phi)) eca95f9ccff94ed98a5cb1beecae7724--d4eeae19acdf4ad0a8ea576cafbcf27a 3d500a727dd04731a7a6ade0ba89d4af 2 cd3555da493e45babe829dfa01b78495 RX(phi**2 + asin(phi)) d4eeae19acdf4ad0a8ea576cafbcf27a--cd3555da493e45babe829dfa01b78495 cd3555da493e45babe829dfa01b78495--517d5454a8a44a45a5ae78633ab98156 e9fb0c6be05a4fb6a654ba31dfcf15e2 76f0dc2f41684c89b6f066e191923ef2 RX(asin(phi)) 3d500a727dd04731a7a6ade0ba89d4af--76f0dc2f41684c89b6f066e191923ef2 a161250775e14392a75cf7d7f164cb59 RX(phi**2 + asin(phi)) 76f0dc2f41684c89b6f066e191923ef2--a161250775e14392a75cf7d7f164cb59 a161250775e14392a75cf7d7f164cb59--e9fb0c6be05a4fb6a654ba31dfcf15e2 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_d9f4544c4cc54665b9d18198784cf2b5 Exponential Fourier FM cluster_1b670f2c703e4fa1b85849b869c2c702 Constant Fourier FM cluster_5136af7b4921406ca192e0a024268c81 Tower Fourier FM 5d5c149a9e6b41718b78b1950a8656ce 0 9f5601b03c434300ac9fa29a206d0bde RX(phi) 5d5c149a9e6b41718b78b1950a8656ce--9f5601b03c434300ac9fa29a206d0bde b0a5e6ef387748e4a565dc2cf225cd2a 1 7bc7fc3a5e4d46db943e31ae1fc3c3c1 RX(1.0*phi) 9f5601b03c434300ac9fa29a206d0bde--7bc7fc3a5e4d46db943e31ae1fc3c3c1 99376cf0eede439eb65dbc74311bdb34 RX(1.0*phi) 7bc7fc3a5e4d46db943e31ae1fc3c3c1--99376cf0eede439eb65dbc74311bdb34 3702040814fa4b5c9349869f8a250e78 99376cf0eede439eb65dbc74311bdb34--3702040814fa4b5c9349869f8a250e78 3cddc88da48a4feb8e54b91cb3d24595 6f2e3431fdbf459d84833fe77d899d12 RX(phi) b0a5e6ef387748e4a565dc2cf225cd2a--6f2e3431fdbf459d84833fe77d899d12 735c6b6486dd4c428b57174476dac2e9 2 c4062a2096b94cfca0cab398e893a491 RX(2.0*phi) 6f2e3431fdbf459d84833fe77d899d12--c4062a2096b94cfca0cab398e893a491 350c5caa7286427b94c443df60dcf252 RX(2.0*phi) c4062a2096b94cfca0cab398e893a491--350c5caa7286427b94c443df60dcf252 350c5caa7286427b94c443df60dcf252--3cddc88da48a4feb8e54b91cb3d24595 e5a1ca073e22486fbf0156d7096dde27 abc5501e85e64b1bb1863489b06f2934 RX(phi) 735c6b6486dd4c428b57174476dac2e9--abc5501e85e64b1bb1863489b06f2934 408a5ccb901d440fac56ac42f7a3e910 3 38eab0dc5be2492d802e4a0e539ff48f RX(3.0*phi) abc5501e85e64b1bb1863489b06f2934--38eab0dc5be2492d802e4a0e539ff48f 6378d0a3e52648bab8585b2586bbf84b RX(4.0*phi) 38eab0dc5be2492d802e4a0e539ff48f--6378d0a3e52648bab8585b2586bbf84b 6378d0a3e52648bab8585b2586bbf84b--e5a1ca073e22486fbf0156d7096dde27 28f71930e32f49849b8e7e474386f870 cdcc10edc2f7417aa39dba4d838316e3 RX(phi) 408a5ccb901d440fac56ac42f7a3e910--cdcc10edc2f7417aa39dba4d838316e3 b770336c4ebc43a8a49d1d827767413e 4 3b71fe69b821444fa00a4beb216944ed RX(4.0*phi) cdcc10edc2f7417aa39dba4d838316e3--3b71fe69b821444fa00a4beb216944ed e10d285226f441d692823e3eb06fd9a3 RX(8.0*phi) 3b71fe69b821444fa00a4beb216944ed--e10d285226f441d692823e3eb06fd9a3 e10d285226f441d692823e3eb06fd9a3--28f71930e32f49849b8e7e474386f870 1d70894c7d8743b6902529281d53ec83 727e1684e8114e989a770db04bead0f6 RX(phi) b770336c4ebc43a8a49d1d827767413e--727e1684e8114e989a770db04bead0f6 5b6a19ce4a4d48d7a87f25fcf49976aa RX(5.0*phi) 727e1684e8114e989a770db04bead0f6--5b6a19ce4a4d48d7a87f25fcf49976aa a91a59a07a3349a287a63611e4ac5602 RX(16.0*phi) 5b6a19ce4a4d48d7a87f25fcf49976aa--a91a59a07a3349a287a63611e4ac5602 a91a59a07a3349a287a63611e4ac5602--1d70894c7d8743b6902529281d53ec83 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 2eeda0cdff014b0c85e4ba6aeb297056 0 0478b34ad4a34b099813efe0d94f0594 RX(1.0*acos(phi)) 2eeda0cdff014b0c85e4ba6aeb297056--0478b34ad4a34b099813efe0d94f0594 79821e27808e43b286ea2e57a5ac9031 1 e3835c64b169406ab3a23f02a6240bcc 0478b34ad4a34b099813efe0d94f0594--e3835c64b169406ab3a23f02a6240bcc edf428b203e746419c01e885a1583a3b e1c3f671631e4890aaa52c0c95a498ad RX(1.414*acos(phi)) 79821e27808e43b286ea2e57a5ac9031--e1c3f671631e4890aaa52c0c95a498ad bff7e400b606401d905260bf505a3cda 2 e1c3f671631e4890aaa52c0c95a498ad--edf428b203e746419c01e885a1583a3b b581ba358c674a4881939dc8b705d8a5 a357e86215b94c659e0d1088baf1e174 RX(1.732*acos(phi)) bff7e400b606401d905260bf505a3cda--a357e86215b94c659e0d1088baf1e174 072b7080cf704bf0a36cb3109ee51018 3 a357e86215b94c659e0d1088baf1e174--b581ba358c674a4881939dc8b705d8a5 9cd56c4fd3ff4127b8b8b7ee643474ba f8be9b02b40e456dbf44e123158210f9 RX(2.0*acos(phi)) 072b7080cf704bf0a36cb3109ee51018--f8be9b02b40e456dbf44e123158210f9 565d30e986b34ffc9087dcb45bf9e751 4 f8be9b02b40e456dbf44e123158210f9--9cd56c4fd3ff4127b8b8b7ee643474ba c55e847e061747c881e09b1c8280eff1 b458774c23f841d2b2453e02dc354989 RX(2.236*acos(phi)) 565d30e986b34ffc9087dcb45bf9e751--b458774c23f841d2b2453e02dc354989 b458774c23f841d2b2453e02dc354989--c55e847e061747c881e09b1c8280eff1 <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 ce7967c36034467a85246699d21b7cac 0 b77850ed2f7c40e9b01ba4aa0f6e4c4c RX(1.0*phi*w\u2080) ce7967c36034467a85246699d21b7cac--b77850ed2f7c40e9b01ba4aa0f6e4c4c 03d8e7711c264570ab0f03b462cc47d9 1 095517f10ed74338b052c5b33eada868 b77850ed2f7c40e9b01ba4aa0f6e4c4c--095517f10ed74338b052c5b33eada868 33dab809ff2e43a88e963ab1e4155fec 27914081f97f475b9bf5ab0b637a68ae RX(2.0*phi*w\u2081) 03d8e7711c264570ab0f03b462cc47d9--27914081f97f475b9bf5ab0b637a68ae e87617b60c4a4d43be48a58f07880b33 2 27914081f97f475b9bf5ab0b637a68ae--33dab809ff2e43a88e963ab1e4155fec 1800d50d45e94630a35ec85ede6c6bf6 267107d578bd4be3b912bac68da55e82 RX(4.0*phi*w\u2082) e87617b60c4a4d43be48a58f07880b33--267107d578bd4be3b912bac68da55e82 28a03efaa34c4ff7a543ef02b073f301 3 267107d578bd4be3b912bac68da55e82--1800d50d45e94630a35ec85ede6c6bf6 b6bf9762938d425698ad8baec9330903 1029b8726177475a9efdb367b8d1c8be RX(8.0*phi*w\u2083) 28a03efaa34c4ff7a543ef02b073f301--1029b8726177475a9efdb367b8d1c8be 64c8aaf3fc374c7a8399cdfe5e83de7b 4 1029b8726177475a9efdb367b8d1c8be--b6bf9762938d425698ad8baec9330903 653ba054632647abaaa92b2ec175d232 3d3114a44363483f99199944fd10f61a RX(16.0*phi*w\u2084) 64c8aaf3fc374c7a8399cdfe5e83de7b--3d3114a44363483f99199944fd10f61a 3d3114a44363483f99199944fd10f61a--653ba054632647abaaa92b2ec175d232 <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 0b155500e70c4806931d18ee2f5fe29a 0 8bbb7ace60034d8bbcd5aefd2281f9b5 RY(80.0*acos(w\u2084*(0.667*x + 1.667))) 0b155500e70c4806931d18ee2f5fe29a--8bbb7ace60034d8bbcd5aefd2281f9b5 63262c2f8e8f4da38e30abfc9420a3fc 1 7af8dac6577f41c29d8a9849d6235e20 8bbb7ace60034d8bbcd5aefd2281f9b5--7af8dac6577f41c29d8a9849d6235e20 57a06886c5bf420789b0d91177821abd 2f0af56323dd453f87baa4b471eea22b RY(40.0*acos(w\u2083*(0.667*x + 1.667))) 63262c2f8e8f4da38e30abfc9420a3fc--2f0af56323dd453f87baa4b471eea22b 65e7bfd6c7bb4ce6aecbf185a9fded98 2 2f0af56323dd453f87baa4b471eea22b--57a06886c5bf420789b0d91177821abd 0fd2b78d7a7a4c3c922f690299ba2f29 cb16d5e0adaa43a79b9c80c29fd9e527 RY(20.0*acos(w\u2082*(0.667*x + 1.667))) 65e7bfd6c7bb4ce6aecbf185a9fded98--cb16d5e0adaa43a79b9c80c29fd9e527 9d3411b6994d4b18831026aba5b8dc38 3 cb16d5e0adaa43a79b9c80c29fd9e527--0fd2b78d7a7a4c3c922f690299ba2f29 5d288f1bd15d491c80f6f9db07c07f0a c1d3cf4677644da4a9e85d12f4fc7ea7 RY(10.0*acos(w\u2081*(0.667*x + 1.667))) 9d3411b6994d4b18831026aba5b8dc38--c1d3cf4677644da4a9e85d12f4fc7ea7 6c27aafeff274cd2913d67425a438c91 4 c1d3cf4677644da4a9e85d12f4fc7ea7--5d288f1bd15d491c80f6f9db07c07f0a 06e8d786ba4c4479a1bbfb00ce5cfbae 486b54916a674290afd7fd0b5294ee47 RY(5.0*acos(w\u2080*(0.667*x + 1.667))) 6c27aafeff274cd2913d67425a438c91--486b54916a674290afd7fd0b5294ee47 486b54916a674290afd7fd0b5294ee47--06e8d786ba4c4479a1bbfb00ce5cfbae"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 03f3b915c1d443beb9c821113f0e89a8 0 5a948e63e972402ba3cb5f0ea4b419f0 RX(theta\u2080) 03f3b915c1d443beb9c821113f0e89a8--5a948e63e972402ba3cb5f0ea4b419f0 23f5505879d647798f1a578803061488 1 26b83d078e574a1d9450c6f6ba71cd5b RY(theta\u2083) 5a948e63e972402ba3cb5f0ea4b419f0--26b83d078e574a1d9450c6f6ba71cd5b 3a4ee1cade024746a56fe54b9b8fd862 RX(theta\u2086) 26b83d078e574a1d9450c6f6ba71cd5b--3a4ee1cade024746a56fe54b9b8fd862 559ccbc1965849f68f2e8a265b752617 3a4ee1cade024746a56fe54b9b8fd862--559ccbc1965849f68f2e8a265b752617 5a0b7db070d748f6aed3f03425a289e2 559ccbc1965849f68f2e8a265b752617--5a0b7db070d748f6aed3f03425a289e2 37cd33ce84be49fbbf15ac37cddda2c7 RX(theta\u2089) 5a0b7db070d748f6aed3f03425a289e2--37cd33ce84be49fbbf15ac37cddda2c7 3dca33cef3b548868daa7e8f1476556c RY(theta\u2081\u2082) 37cd33ce84be49fbbf15ac37cddda2c7--3dca33cef3b548868daa7e8f1476556c dda8b93111774e50a6a48a1ea16c0cca RX(theta\u2081\u2085) 3dca33cef3b548868daa7e8f1476556c--dda8b93111774e50a6a48a1ea16c0cca 1d3fa77abaf84d2c95d7e7af550c93cb dda8b93111774e50a6a48a1ea16c0cca--1d3fa77abaf84d2c95d7e7af550c93cb 33fc8996b0ae4509af0df8d35d964de5 1d3fa77abaf84d2c95d7e7af550c93cb--33fc8996b0ae4509af0df8d35d964de5 fc00316c56a2433fbe7cfc256887771e 33fc8996b0ae4509af0df8d35d964de5--fc00316c56a2433fbe7cfc256887771e a2697a64056e4f06bbc5b9e39474d41c cb74a92b94ec40a5912944a6a3c9d621 RX(theta\u2081) 23f5505879d647798f1a578803061488--cb74a92b94ec40a5912944a6a3c9d621 87143886a2d74274b07d7e957b028b10 2 89f859e827ec46bc9a31e2e76229c6a1 RY(theta\u2084) cb74a92b94ec40a5912944a6a3c9d621--89f859e827ec46bc9a31e2e76229c6a1 2de5f0c39e0241d984de3a325c889f19 RX(theta\u2087) 89f859e827ec46bc9a31e2e76229c6a1--2de5f0c39e0241d984de3a325c889f19 eef85756640041e6b7be790ccfde570c X 2de5f0c39e0241d984de3a325c889f19--eef85756640041e6b7be790ccfde570c eef85756640041e6b7be790ccfde570c--559ccbc1965849f68f2e8a265b752617 0a5a265c32894619b5223df3d7247ebc eef85756640041e6b7be790ccfde570c--0a5a265c32894619b5223df3d7247ebc 9e0e08fa470e4fb68a335ac60b4eea39 RX(theta\u2081\u2080) 0a5a265c32894619b5223df3d7247ebc--9e0e08fa470e4fb68a335ac60b4eea39 f34c43dd29a145ba8db17b72e75663d2 RY(theta\u2081\u2083) 9e0e08fa470e4fb68a335ac60b4eea39--f34c43dd29a145ba8db17b72e75663d2 dc46e36bf5654502a4ce170623831286 RX(theta\u2081\u2086) f34c43dd29a145ba8db17b72e75663d2--dc46e36bf5654502a4ce170623831286 2ad9cd902dfd43daba193ebe1644568b X dc46e36bf5654502a4ce170623831286--2ad9cd902dfd43daba193ebe1644568b 2ad9cd902dfd43daba193ebe1644568b--1d3fa77abaf84d2c95d7e7af550c93cb 93520e41425e45998c6cf2e185e3a522 2ad9cd902dfd43daba193ebe1644568b--93520e41425e45998c6cf2e185e3a522 93520e41425e45998c6cf2e185e3a522--a2697a64056e4f06bbc5b9e39474d41c e1203bdc23dc4be3a76d0bd2835336ab 353c9aa872df49a99c57b175a66cb133 RX(theta\u2082) 87143886a2d74274b07d7e957b028b10--353c9aa872df49a99c57b175a66cb133 8a8b84a5934d4ace87b10b9470720a89 RY(theta\u2085) 353c9aa872df49a99c57b175a66cb133--8a8b84a5934d4ace87b10b9470720a89 17f2262cbc914c5785be760976eb3349 RX(theta\u2088) 8a8b84a5934d4ace87b10b9470720a89--17f2262cbc914c5785be760976eb3349 f338f790c83e4651b7f4fc981121f34f 17f2262cbc914c5785be760976eb3349--f338f790c83e4651b7f4fc981121f34f e7dfeefd658f4d05862e0ba5eea85d71 X f338f790c83e4651b7f4fc981121f34f--e7dfeefd658f4d05862e0ba5eea85d71 e7dfeefd658f4d05862e0ba5eea85d71--0a5a265c32894619b5223df3d7247ebc f9ee0ed87f10411eb72bb57454b08959 RX(theta\u2081\u2081) e7dfeefd658f4d05862e0ba5eea85d71--f9ee0ed87f10411eb72bb57454b08959 74943319d08b4f578490e3288b18c113 RY(theta\u2081\u2084) f9ee0ed87f10411eb72bb57454b08959--74943319d08b4f578490e3288b18c113 794c5d15b1404156ba100e1485fc39df RX(theta\u2081\u2087) 74943319d08b4f578490e3288b18c113--794c5d15b1404156ba100e1485fc39df 1b6e2eb913754cf39e5b4478ff28b5c3 794c5d15b1404156ba100e1485fc39df--1b6e2eb913754cf39e5b4478ff28b5c3 ef55b27d08ce47aa889eec2b7dff88b8 X 1b6e2eb913754cf39e5b4478ff28b5c3--ef55b27d08ce47aa889eec2b7dff88b8 ef55b27d08ce47aa889eec2b7dff88b8--93520e41425e45998c6cf2e185e3a522 ef55b27d08ce47aa889eec2b7dff88b8--e1203bdc23dc4be3a76d0bd2835336ab <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 e50d7c006574483cbc77838a7d76466d 0 a45021a7b5b1498a85ce08ed3448749f RX(phi\u2080) e50d7c006574483cbc77838a7d76466d--a45021a7b5b1498a85ce08ed3448749f 1dcb4f36bb07491cbf0468845041e581 1 625b697fe71346fbbdc5cf468d4627c9 RY(phi\u2083) a45021a7b5b1498a85ce08ed3448749f--625b697fe71346fbbdc5cf468d4627c9 4489c47672bf494ab0dc18fcc7148444 RX(phi\u2086) 625b697fe71346fbbdc5cf468d4627c9--4489c47672bf494ab0dc18fcc7148444 52a510cd03b04a8d991227a939701dcc 4489c47672bf494ab0dc18fcc7148444--52a510cd03b04a8d991227a939701dcc a22c98572bf04646b440b2841f64f1e4 52a510cd03b04a8d991227a939701dcc--a22c98572bf04646b440b2841f64f1e4 68ca5f3e93f44f37b0c386105ba37a0d RX(phi\u2089) a22c98572bf04646b440b2841f64f1e4--68ca5f3e93f44f37b0c386105ba37a0d ef001592bb4c4dfdb4e289cf204f3002 RY(phi\u2081\u2082) 68ca5f3e93f44f37b0c386105ba37a0d--ef001592bb4c4dfdb4e289cf204f3002 c3b286668bb6452ca44cc4618e030251 RX(phi\u2081\u2085) ef001592bb4c4dfdb4e289cf204f3002--c3b286668bb6452ca44cc4618e030251 e5e57002ba334d92a8cf9eee49e575c9 c3b286668bb6452ca44cc4618e030251--e5e57002ba334d92a8cf9eee49e575c9 50c9125a38da4475915704ab73a87c3b e5e57002ba334d92a8cf9eee49e575c9--50c9125a38da4475915704ab73a87c3b 9382198af0d047f4a2b9069344454a3d 50c9125a38da4475915704ab73a87c3b--9382198af0d047f4a2b9069344454a3d 529d07caba1d4e3782cc75eb9f6c6385 dffb17aee28d4da88474b8bf6cebc876 RX(phi\u2081) 1dcb4f36bb07491cbf0468845041e581--dffb17aee28d4da88474b8bf6cebc876 e32e22c1c7e1472b80bc0b38a75bf925 2 7fe466e6df9f46908dbda6fe2157d525 RY(phi\u2084) dffb17aee28d4da88474b8bf6cebc876--7fe466e6df9f46908dbda6fe2157d525 55308131d6f14553b2b5cd0d71dd64ef RX(phi\u2087) 7fe466e6df9f46908dbda6fe2157d525--55308131d6f14553b2b5cd0d71dd64ef ee6b7080e12540208f8d99ff8f90ad90 PHASE(phi_ent\u2080) 55308131d6f14553b2b5cd0d71dd64ef--ee6b7080e12540208f8d99ff8f90ad90 ee6b7080e12540208f8d99ff8f90ad90--52a510cd03b04a8d991227a939701dcc 46d372ae8b28439e93b66e71a2c23f36 ee6b7080e12540208f8d99ff8f90ad90--46d372ae8b28439e93b66e71a2c23f36 3d73f36065854717b3415641ef4606df RX(phi\u2081\u2080) 46d372ae8b28439e93b66e71a2c23f36--3d73f36065854717b3415641ef4606df 62d274c5fefb4c2baba92561755929c7 RY(phi\u2081\u2083) 3d73f36065854717b3415641ef4606df--62d274c5fefb4c2baba92561755929c7 6a2473effd8448aebab4ec59c85b310c RX(phi\u2081\u2086) 62d274c5fefb4c2baba92561755929c7--6a2473effd8448aebab4ec59c85b310c 527054975ce947458c064c63f374d369 PHASE(phi_ent\u2082) 6a2473effd8448aebab4ec59c85b310c--527054975ce947458c064c63f374d369 527054975ce947458c064c63f374d369--e5e57002ba334d92a8cf9eee49e575c9 994dc68fbab94c728433f15a7b56c049 527054975ce947458c064c63f374d369--994dc68fbab94c728433f15a7b56c049 994dc68fbab94c728433f15a7b56c049--529d07caba1d4e3782cc75eb9f6c6385 e364730f708c4a6f83ba9bc30ae1145b c1a68d9abf3f4fb68bc8ebb30eac1243 RX(phi\u2082) e32e22c1c7e1472b80bc0b38a75bf925--c1a68d9abf3f4fb68bc8ebb30eac1243 434b1bd112034c7d9f33b9f01c392238 RY(phi\u2085) c1a68d9abf3f4fb68bc8ebb30eac1243--434b1bd112034c7d9f33b9f01c392238 9a816da942c944ce8910993a295ea66e RX(phi\u2088) 434b1bd112034c7d9f33b9f01c392238--9a816da942c944ce8910993a295ea66e 65e37e3d66ed4e05887178bc2a0275dd 9a816da942c944ce8910993a295ea66e--65e37e3d66ed4e05887178bc2a0275dd 017c720856434958a6942e9976f464c9 PHASE(phi_ent\u2081) 65e37e3d66ed4e05887178bc2a0275dd--017c720856434958a6942e9976f464c9 017c720856434958a6942e9976f464c9--46d372ae8b28439e93b66e71a2c23f36 d6e3e881da15422fb433801b0cd29814 RX(phi\u2081\u2081) 017c720856434958a6942e9976f464c9--d6e3e881da15422fb433801b0cd29814 f8bc7a83970746bb807ed67f549f0d18 RY(phi\u2081\u2084) d6e3e881da15422fb433801b0cd29814--f8bc7a83970746bb807ed67f549f0d18 d4508104586f4eefa77f19c612876131 RX(phi\u2081\u2087) f8bc7a83970746bb807ed67f549f0d18--d4508104586f4eefa77f19c612876131 5286c2d1fd974f6d9dff5e2de0d13186 d4508104586f4eefa77f19c612876131--5286c2d1fd974f6d9dff5e2de0d13186 5d4362c4f9624ca3af6f429e4b64ba56 PHASE(phi_ent\u2083) 5286c2d1fd974f6d9dff5e2de0d13186--5d4362c4f9624ca3af6f429e4b64ba56 5d4362c4f9624ca3af6f429e4b64ba56--994dc68fbab94c728433f15a7b56c049 5d4362c4f9624ca3af6f429e4b64ba56--e364730f708c4a6f83ba9bc30ae1145b <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_9437d01b051746a1a8164f6102a3a8df cluster_b1e87b5d3f2042748225a6cdc5bfc4c1 d727d5a3890948f99e0a7c7ce5cdba4c 0 9bc365bde4fa450b9c1c040cc4d974d5 RX(theta\u2080) d727d5a3890948f99e0a7c7ce5cdba4c--9bc365bde4fa450b9c1c040cc4d974d5 170efd53b1414b4cb72dad74c902775b 1 84e062804c4443d490059bb3ce3bdcef RY(theta\u2083) 9bc365bde4fa450b9c1c040cc4d974d5--84e062804c4443d490059bb3ce3bdcef b2613470c27043abb8c465d831cf165d RX(theta\u2086) 84e062804c4443d490059bb3ce3bdcef--b2613470c27043abb8c465d831cf165d e4451a2e0add4d52a0c8d6d351ec5a1e HamEvo b2613470c27043abb8c465d831cf165d--e4451a2e0add4d52a0c8d6d351ec5a1e 9d3c9853ab9b442e8b7ac28daf23cba7 RX(theta\u2089) e4451a2e0add4d52a0c8d6d351ec5a1e--9d3c9853ab9b442e8b7ac28daf23cba7 b365ea91cccc49618a24a095e44e118a RY(theta\u2081\u2082) 9d3c9853ab9b442e8b7ac28daf23cba7--b365ea91cccc49618a24a095e44e118a 5444352afffd4c1eb963283f8d486720 RX(theta\u2081\u2085) b365ea91cccc49618a24a095e44e118a--5444352afffd4c1eb963283f8d486720 f20246e61a62400aad0f206ba28302fa HamEvo 5444352afffd4c1eb963283f8d486720--f20246e61a62400aad0f206ba28302fa 7e3a1f161b7844d5ad0b1d693855d3fb f20246e61a62400aad0f206ba28302fa--7e3a1f161b7844d5ad0b1d693855d3fb 5c6ed5ca9e654df8ab5c2bb85f60854f 886a6415f350419da3e3b9957fc300a8 RX(theta\u2081) 170efd53b1414b4cb72dad74c902775b--886a6415f350419da3e3b9957fc300a8 957657e2c0674f468a061e1d97927255 2 cbdd5af119204694a5939341d970c26b RY(theta\u2084) 886a6415f350419da3e3b9957fc300a8--cbdd5af119204694a5939341d970c26b 6b39887c16814ecd929760bb1cd84aab RX(theta\u2087) cbdd5af119204694a5939341d970c26b--6b39887c16814ecd929760bb1cd84aab 903d2074eadf441cae045975cdd95626 t = theta_t\u2080 6b39887c16814ecd929760bb1cd84aab--903d2074eadf441cae045975cdd95626 e18cddae2e504da6af9c7aac2daa22aa RX(theta\u2081\u2080) 903d2074eadf441cae045975cdd95626--e18cddae2e504da6af9c7aac2daa22aa 32f397880f72404f8af2d45e8e6b8bdf RY(theta\u2081\u2083) e18cddae2e504da6af9c7aac2daa22aa--32f397880f72404f8af2d45e8e6b8bdf 7f62250db340467f96f6cadad03b7a4d RX(theta\u2081\u2086) 32f397880f72404f8af2d45e8e6b8bdf--7f62250db340467f96f6cadad03b7a4d f309ab9d95604b26912575a7992fc935 t = theta_t\u2081 7f62250db340467f96f6cadad03b7a4d--f309ab9d95604b26912575a7992fc935 f309ab9d95604b26912575a7992fc935--5c6ed5ca9e654df8ab5c2bb85f60854f 4cf65befd20d426cb0b1e4d8ec203eea d811ced16f3d4fce8ec5aaa333ab62e1 RX(theta\u2082) 957657e2c0674f468a061e1d97927255--d811ced16f3d4fce8ec5aaa333ab62e1 8bbf0e216adc4b9da7527769c7cef55d RY(theta\u2085) d811ced16f3d4fce8ec5aaa333ab62e1--8bbf0e216adc4b9da7527769c7cef55d 518ada3e68fa41538c8ecf0eeaf94cac RX(theta\u2088) 8bbf0e216adc4b9da7527769c7cef55d--518ada3e68fa41538c8ecf0eeaf94cac ea1bb130f1b64977aae5d87276e7c22a 518ada3e68fa41538c8ecf0eeaf94cac--ea1bb130f1b64977aae5d87276e7c22a 3c91706bf3c84163aa08a9258205d3e5 RX(theta\u2081\u2081) ea1bb130f1b64977aae5d87276e7c22a--3c91706bf3c84163aa08a9258205d3e5 9c207348fc034ea2832c1ae9c1a25a32 RY(theta\u2081\u2084) 3c91706bf3c84163aa08a9258205d3e5--9c207348fc034ea2832c1ae9c1a25a32 bd38913191f548d08070873ef483d635 RX(theta\u2081\u2087) 9c207348fc034ea2832c1ae9c1a25a32--bd38913191f548d08070873ef483d635 63c86534237e4c8ab61f7b7d13c8f22b bd38913191f548d08070873ef483d635--63c86534237e4c8ab61f7b7d13c8f22b 63c86534237e4c8ab61f7b7d13c8f22b--4cf65befd20d426cb0b1e4d8ec203eea <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_799098771b864d0b8573686dfcfd930f cluster_c20c878438014180be4f9fe2e9356f15 222c1ccbeff7458998dc38d109396be8 0 9f9301d2ad4944398ed83bb0fc46923e RX(theta\u2080) 222c1ccbeff7458998dc38d109396be8--9f9301d2ad4944398ed83bb0fc46923e b71d2d20f7a7448ba8314745f8ed2708 1 5a7294947a7342fa9f6f890c23bb8205 RY(theta\u2086) 9f9301d2ad4944398ed83bb0fc46923e--5a7294947a7342fa9f6f890c23bb8205 365be5496ff847d7a841b1ae1bc689d7 RX(theta\u2081\u2082) 5a7294947a7342fa9f6f890c23bb8205--365be5496ff847d7a841b1ae1bc689d7 4d2867f266934cffb768aaca69377fda 365be5496ff847d7a841b1ae1bc689d7--4d2867f266934cffb768aaca69377fda 9d47eb8e44414937833762bbe45744b2 RX(theta\u2081\u2088) 4d2867f266934cffb768aaca69377fda--9d47eb8e44414937833762bbe45744b2 0ce0714676a14964bcc609c5131e5360 RY(theta\u2082\u2084) 9d47eb8e44414937833762bbe45744b2--0ce0714676a14964bcc609c5131e5360 49babe43e7f3473fbd53557179060c11 RX(theta\u2083\u2080) 0ce0714676a14964bcc609c5131e5360--49babe43e7f3473fbd53557179060c11 f153b1c468ec4319a846c07392f14a88 49babe43e7f3473fbd53557179060c11--f153b1c468ec4319a846c07392f14a88 a9ce1e1f8512497180fe490849f49480 f153b1c468ec4319a846c07392f14a88--a9ce1e1f8512497180fe490849f49480 52f05be0841246cf9ab7a2136feefa1f fddee5d8feb54b7590aa7781c4196452 RX(theta\u2081) b71d2d20f7a7448ba8314745f8ed2708--fddee5d8feb54b7590aa7781c4196452 d7ff7b61d2e64476b7ce39b505239ce3 2 04d74393f55c401d96961d2af181ee77 RY(theta\u2087) fddee5d8feb54b7590aa7781c4196452--04d74393f55c401d96961d2af181ee77 df7b2e6573cb4a98a1570064158d877a RX(theta\u2081\u2083) 04d74393f55c401d96961d2af181ee77--df7b2e6573cb4a98a1570064158d877a 65c207ac59df4aa8a1241aee9aaa1cb1 df7b2e6573cb4a98a1570064158d877a--65c207ac59df4aa8a1241aee9aaa1cb1 823a2cf3d4de494dbdb6148d199546ef RX(theta\u2081\u2089) 65c207ac59df4aa8a1241aee9aaa1cb1--823a2cf3d4de494dbdb6148d199546ef 2f8219a2be4a4100abc481473a083398 RY(theta\u2082\u2085) 823a2cf3d4de494dbdb6148d199546ef--2f8219a2be4a4100abc481473a083398 cebfa87f6e37442b8793f5e729b1d4d6 RX(theta\u2083\u2081) 2f8219a2be4a4100abc481473a083398--cebfa87f6e37442b8793f5e729b1d4d6 744534cbb7ab4cf2bbee46a9497555f0 cebfa87f6e37442b8793f5e729b1d4d6--744534cbb7ab4cf2bbee46a9497555f0 744534cbb7ab4cf2bbee46a9497555f0--52f05be0841246cf9ab7a2136feefa1f 4960dc2e62f94c9881ec7e27e3408f0b 7eff08bc313040579f28216de1196eb6 RX(theta\u2082) d7ff7b61d2e64476b7ce39b505239ce3--7eff08bc313040579f28216de1196eb6 e4de8855ee2a429a9804d2c9cdc9e084 3 890b940d004b46a1a0a7cfe82ad6f560 RY(theta\u2088) 7eff08bc313040579f28216de1196eb6--890b940d004b46a1a0a7cfe82ad6f560 fd6d4d33bf4e477b9443231b6c3a5d4d RX(theta\u2081\u2084) 890b940d004b46a1a0a7cfe82ad6f560--fd6d4d33bf4e477b9443231b6c3a5d4d 6fb94e284c384991bf1c5c83bffce2ad HamEvo fd6d4d33bf4e477b9443231b6c3a5d4d--6fb94e284c384991bf1c5c83bffce2ad 003bbe36374c46599cfb49c479cb326a RX(theta\u2082\u2080) 6fb94e284c384991bf1c5c83bffce2ad--003bbe36374c46599cfb49c479cb326a dd41768ffe3d49f0b5891d703e111d95 RY(theta\u2082\u2086) 003bbe36374c46599cfb49c479cb326a--dd41768ffe3d49f0b5891d703e111d95 9a6cd5b2e39442faa9b637456c9d51f6 RX(theta\u2083\u2082) dd41768ffe3d49f0b5891d703e111d95--9a6cd5b2e39442faa9b637456c9d51f6 e26536d12ba14c6aa499faf8185710fe HamEvo 9a6cd5b2e39442faa9b637456c9d51f6--e26536d12ba14c6aa499faf8185710fe e26536d12ba14c6aa499faf8185710fe--4960dc2e62f94c9881ec7e27e3408f0b 41ddfca4ea2142978ef865ec06eed7c6 160a972bf8834b50a811485a9f02525d RX(theta\u2083) e4de8855ee2a429a9804d2c9cdc9e084--160a972bf8834b50a811485a9f02525d 5dcce922555d4ce189f461f8ed538e9e 4 f9add111ef1143ec9715bd4423f07f70 RY(theta\u2089) 160a972bf8834b50a811485a9f02525d--f9add111ef1143ec9715bd4423f07f70 84c51ced39e64ba38ad5fc6082c3173b RX(theta\u2081\u2085) f9add111ef1143ec9715bd4423f07f70--84c51ced39e64ba38ad5fc6082c3173b 6d09ce9544d04627aa1ec63738c88cbd t = theta_t\u2080 84c51ced39e64ba38ad5fc6082c3173b--6d09ce9544d04627aa1ec63738c88cbd 57c3d73a5c304f779717b336b409da01 RX(theta\u2082\u2081) 6d09ce9544d04627aa1ec63738c88cbd--57c3d73a5c304f779717b336b409da01 12ee995a137a42caa74fb443ff992d5f RY(theta\u2082\u2087) 57c3d73a5c304f779717b336b409da01--12ee995a137a42caa74fb443ff992d5f c5b5ce75eb4e4f3e863ddb5b9c8b6de5 RX(theta\u2083\u2083) 12ee995a137a42caa74fb443ff992d5f--c5b5ce75eb4e4f3e863ddb5b9c8b6de5 cef4009ef120415b9b9874a60ef2cfe5 t = theta_t\u2081 c5b5ce75eb4e4f3e863ddb5b9c8b6de5--cef4009ef120415b9b9874a60ef2cfe5 cef4009ef120415b9b9874a60ef2cfe5--41ddfca4ea2142978ef865ec06eed7c6 f9becd16ae724cc995bd1000f6896999 13e1337d67da4dbf892a4db13fb016a1 RX(theta\u2084) 5dcce922555d4ce189f461f8ed538e9e--13e1337d67da4dbf892a4db13fb016a1 a3f41178e4074844b0841a0442f9e548 5 9a0bf35931914feab46cf0ed2be5d75d RY(theta\u2081\u2080) 13e1337d67da4dbf892a4db13fb016a1--9a0bf35931914feab46cf0ed2be5d75d 53889f84e69949e6bcddd493110d747d RX(theta\u2081\u2086) 9a0bf35931914feab46cf0ed2be5d75d--53889f84e69949e6bcddd493110d747d f99da17e03674a44ab10a6240c4fe5a3 53889f84e69949e6bcddd493110d747d--f99da17e03674a44ab10a6240c4fe5a3 c4c195e2da5445d0984e9b65a5a01080 RX(theta\u2082\u2082) f99da17e03674a44ab10a6240c4fe5a3--c4c195e2da5445d0984e9b65a5a01080 32b9435707ce4fba976f427075c2b16c RY(theta\u2082\u2088) c4c195e2da5445d0984e9b65a5a01080--32b9435707ce4fba976f427075c2b16c fc10f359895d42b1956d39767c54d89b RX(theta\u2083\u2084) 32b9435707ce4fba976f427075c2b16c--fc10f359895d42b1956d39767c54d89b 54541a12e8864fe09098006d5b01294a fc10f359895d42b1956d39767c54d89b--54541a12e8864fe09098006d5b01294a 54541a12e8864fe09098006d5b01294a--f9becd16ae724cc995bd1000f6896999 297d7f68342d428697d27562c6723afd 486312cf5a7143e78a267fa10e823120 RX(theta\u2085) a3f41178e4074844b0841a0442f9e548--486312cf5a7143e78a267fa10e823120 8a656eebc43b478dbf48a9693cc2db36 RY(theta\u2081\u2081) 486312cf5a7143e78a267fa10e823120--8a656eebc43b478dbf48a9693cc2db36 cee97b7aa0e14ef89f9fa9a2477b8332 RX(theta\u2081\u2087) 8a656eebc43b478dbf48a9693cc2db36--cee97b7aa0e14ef89f9fa9a2477b8332 7eb0787408734db0959e5be4aa366998 cee97b7aa0e14ef89f9fa9a2477b8332--7eb0787408734db0959e5be4aa366998 f940f8cf1cc44fbda9775d763837f922 RX(theta\u2082\u2083) 7eb0787408734db0959e5be4aa366998--f940f8cf1cc44fbda9775d763837f922 65e7e57f2d984ec4bd11b9a6d5957514 RY(theta\u2082\u2089) f940f8cf1cc44fbda9775d763837f922--65e7e57f2d984ec4bd11b9a6d5957514 eb2ec088d62b4e9f92971a8665f86e79 RX(theta\u2083\u2085) 65e7e57f2d984ec4bd11b9a6d5957514--eb2ec088d62b4e9f92971a8665f86e79 0fc4bab208e44f3f8fd0dc631f579a83 eb2ec088d62b4e9f92971a8665f86e79--0fc4bab208e44f3f8fd0dc631f579a83 0fc4bab208e44f3f8fd0dc631f579a83--297d7f68342d428697d27562c6723afd"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_52924742cea5413c949229035a22298d BPMA-1 cluster_2b1e1597aa3c46699c4c3d5304ba3382 BPMA-0 77e5fe03b77c45eb8c4d07d69cca4474 0 75baad560499479f812cb3132b6d4b47 RX(iia_\u03b1\u2080\u2080) 77e5fe03b77c45eb8c4d07d69cca4474--75baad560499479f812cb3132b6d4b47 8272bdae5cef40a8aa9a7b2e7134e889 1 bccad5578d6c48dd999af3b51bbd853f RY(iia_\u03b1\u2080\u2083) 75baad560499479f812cb3132b6d4b47--bccad5578d6c48dd999af3b51bbd853f 895195cbc4be4d74bf3938bab5da8f51 bccad5578d6c48dd999af3b51bbd853f--895195cbc4be4d74bf3938bab5da8f51 00b76c95f8b346ff843418dc0cb7fdf5 895195cbc4be4d74bf3938bab5da8f51--00b76c95f8b346ff843418dc0cb7fdf5 7915c55d4053401b82592fb764583d6c RX(iia_\u03b3\u2080\u2080) 00b76c95f8b346ff843418dc0cb7fdf5--7915c55d4053401b82592fb764583d6c ac694491773d4aa4a8fa5998a92a4857 7915c55d4053401b82592fb764583d6c--ac694491773d4aa4a8fa5998a92a4857 1008c6afabaf41a3ab37ba87c328b42e ac694491773d4aa4a8fa5998a92a4857--1008c6afabaf41a3ab37ba87c328b42e 77d108714838424ebaf77fc2b98236f0 RY(iia_\u03b2\u2080\u2083) 1008c6afabaf41a3ab37ba87c328b42e--77d108714838424ebaf77fc2b98236f0 e6acefe50f7f4957a1e5979bb27de5cb RX(iia_\u03b2\u2080\u2080) 77d108714838424ebaf77fc2b98236f0--e6acefe50f7f4957a1e5979bb27de5cb 00d1e2840dc84720883b4d088b9fd685 RX(iia_\u03b1\u2081\u2080) e6acefe50f7f4957a1e5979bb27de5cb--00d1e2840dc84720883b4d088b9fd685 0717f9c953d445d3a2caf2c474462de6 RY(iia_\u03b1\u2081\u2083) 00d1e2840dc84720883b4d088b9fd685--0717f9c953d445d3a2caf2c474462de6 cfba46016ee94cd38a805ed56367aea1 0717f9c953d445d3a2caf2c474462de6--cfba46016ee94cd38a805ed56367aea1 dd39745ab32346e2a99e34d4708e0bbb cfba46016ee94cd38a805ed56367aea1--dd39745ab32346e2a99e34d4708e0bbb 82138f77868241459a17e04f7e02cd5b RX(iia_\u03b3\u2081\u2080) dd39745ab32346e2a99e34d4708e0bbb--82138f77868241459a17e04f7e02cd5b 58e87efa79c248d0bade8afd2afb3a90 82138f77868241459a17e04f7e02cd5b--58e87efa79c248d0bade8afd2afb3a90 21e9e7d85a7847cea82d2eca30236d9e 58e87efa79c248d0bade8afd2afb3a90--21e9e7d85a7847cea82d2eca30236d9e bf051a495b6e43b7b168be268572de6b RY(iia_\u03b2\u2081\u2083) 21e9e7d85a7847cea82d2eca30236d9e--bf051a495b6e43b7b168be268572de6b 2eacabb209fc48d3a1f90d052bc7826d RX(iia_\u03b2\u2081\u2080) bf051a495b6e43b7b168be268572de6b--2eacabb209fc48d3a1f90d052bc7826d 9098b4a8afae44468e0275e0af4b1db0 2eacabb209fc48d3a1f90d052bc7826d--9098b4a8afae44468e0275e0af4b1db0 5337cb7857044907be4a6d44927c6bdf c3f9a39de78b41419e3f7d7e2d444b6a RX(iia_\u03b1\u2080\u2081) 8272bdae5cef40a8aa9a7b2e7134e889--c3f9a39de78b41419e3f7d7e2d444b6a 7283e650ac40423280a4d095944b5576 2 31550d214a3c4b99b33301eb29890f92 RY(iia_\u03b1\u2080\u2084) c3f9a39de78b41419e3f7d7e2d444b6a--31550d214a3c4b99b33301eb29890f92 b35a1dc54d1244538b5a23b307fd6325 X 31550d214a3c4b99b33301eb29890f92--b35a1dc54d1244538b5a23b307fd6325 b35a1dc54d1244538b5a23b307fd6325--895195cbc4be4d74bf3938bab5da8f51 f78200e809e3466e98ab7418dcb521dd b35a1dc54d1244538b5a23b307fd6325--f78200e809e3466e98ab7418dcb521dd 2a17d23620924113ae4f5105d8896cd3 RX(iia_\u03b3\u2080\u2081) f78200e809e3466e98ab7418dcb521dd--2a17d23620924113ae4f5105d8896cd3 579a5c71035e40078e84cd0895bc4912 2a17d23620924113ae4f5105d8896cd3--579a5c71035e40078e84cd0895bc4912 77a15a0900814723aabb7990be30da64 X 579a5c71035e40078e84cd0895bc4912--77a15a0900814723aabb7990be30da64 77a15a0900814723aabb7990be30da64--1008c6afabaf41a3ab37ba87c328b42e 660978d6d6214b05b840a63e32bfbb56 RY(iia_\u03b2\u2080\u2084) 77a15a0900814723aabb7990be30da64--660978d6d6214b05b840a63e32bfbb56 7d6d439ae70b4b9898685f2db56d917b RX(iia_\u03b2\u2080\u2081) 660978d6d6214b05b840a63e32bfbb56--7d6d439ae70b4b9898685f2db56d917b a10442ecc223473291bfb98fb1ed7eab RX(iia_\u03b1\u2081\u2081) 7d6d439ae70b4b9898685f2db56d917b--a10442ecc223473291bfb98fb1ed7eab 02be1f4d07db461ba56e8008a9668ca2 RY(iia_\u03b1\u2081\u2084) a10442ecc223473291bfb98fb1ed7eab--02be1f4d07db461ba56e8008a9668ca2 a31124fee9bf458980660950b5464e5b X 02be1f4d07db461ba56e8008a9668ca2--a31124fee9bf458980660950b5464e5b a31124fee9bf458980660950b5464e5b--cfba46016ee94cd38a805ed56367aea1 e3773b72f21145d892f36c51fbaea97a a31124fee9bf458980660950b5464e5b--e3773b72f21145d892f36c51fbaea97a a146076c4dd04165b3c65164bc17627a RX(iia_\u03b3\u2081\u2081) e3773b72f21145d892f36c51fbaea97a--a146076c4dd04165b3c65164bc17627a b0d7667439a3435aa4682dc382de310d a146076c4dd04165b3c65164bc17627a--b0d7667439a3435aa4682dc382de310d 7bcf744ccf524ea5867604474b2220ad X b0d7667439a3435aa4682dc382de310d--7bcf744ccf524ea5867604474b2220ad 7bcf744ccf524ea5867604474b2220ad--21e9e7d85a7847cea82d2eca30236d9e 299a4515427d4ff58db83d64c31b0b1b RY(iia_\u03b2\u2081\u2084) 7bcf744ccf524ea5867604474b2220ad--299a4515427d4ff58db83d64c31b0b1b 4fd95697e6b641e9b80c314ae3683e89 RX(iia_\u03b2\u2081\u2081) 299a4515427d4ff58db83d64c31b0b1b--4fd95697e6b641e9b80c314ae3683e89 4fd95697e6b641e9b80c314ae3683e89--5337cb7857044907be4a6d44927c6bdf e534a2a9e4b54941ac97abcdc8f78963 d3df0557537e4e349364c402367e239c RX(iia_\u03b1\u2080\u2082) 7283e650ac40423280a4d095944b5576--d3df0557537e4e349364c402367e239c 686fcdbe61564a81b168c0768981c4aa RY(iia_\u03b1\u2080\u2085) d3df0557537e4e349364c402367e239c--686fcdbe61564a81b168c0768981c4aa 704b63b663f74e24a3bebe51c098d098 686fcdbe61564a81b168c0768981c4aa--704b63b663f74e24a3bebe51c098d098 676cb9f9157348d383c75958d4517eff X 704b63b663f74e24a3bebe51c098d098--676cb9f9157348d383c75958d4517eff 676cb9f9157348d383c75958d4517eff--f78200e809e3466e98ab7418dcb521dd d46bcea9317040819ad7fee6e7b9b471 RX(iia_\u03b3\u2080\u2082) 676cb9f9157348d383c75958d4517eff--d46bcea9317040819ad7fee6e7b9b471 af5923e02eb14b42adf97ba92b945e96 X d46bcea9317040819ad7fee6e7b9b471--af5923e02eb14b42adf97ba92b945e96 af5923e02eb14b42adf97ba92b945e96--579a5c71035e40078e84cd0895bc4912 a4090b422d424bb899ca7931b30fadd5 af5923e02eb14b42adf97ba92b945e96--a4090b422d424bb899ca7931b30fadd5 9769922e82364316b4a1d22280d18a4f RY(iia_\u03b2\u2080\u2085) a4090b422d424bb899ca7931b30fadd5--9769922e82364316b4a1d22280d18a4f 4cf26797e73b42d2b30e0b9843dcd9b3 RX(iia_\u03b2\u2080\u2082) 9769922e82364316b4a1d22280d18a4f--4cf26797e73b42d2b30e0b9843dcd9b3 13ddc61f0839475ba69fd853d73a705b RX(iia_\u03b1\u2081\u2082) 4cf26797e73b42d2b30e0b9843dcd9b3--13ddc61f0839475ba69fd853d73a705b aab50f5bd7974f05ac6501a3770dd3f1 RY(iia_\u03b1\u2081\u2085) 13ddc61f0839475ba69fd853d73a705b--aab50f5bd7974f05ac6501a3770dd3f1 ee779eaee02a43b09e4f1b4cb1c9fcba aab50f5bd7974f05ac6501a3770dd3f1--ee779eaee02a43b09e4f1b4cb1c9fcba 290e4d26bc3e4553a017cd19fc035c80 X ee779eaee02a43b09e4f1b4cb1c9fcba--290e4d26bc3e4553a017cd19fc035c80 290e4d26bc3e4553a017cd19fc035c80--e3773b72f21145d892f36c51fbaea97a 8c6f9524de94469f83b8666eb8b6edea RX(iia_\u03b3\u2081\u2082) 290e4d26bc3e4553a017cd19fc035c80--8c6f9524de94469f83b8666eb8b6edea e6e4f25d8e1d41c496bae818174cfaef X 8c6f9524de94469f83b8666eb8b6edea--e6e4f25d8e1d41c496bae818174cfaef e6e4f25d8e1d41c496bae818174cfaef--b0d7667439a3435aa4682dc382de310d 34639c64fb8046a5afe62434ddd75463 e6e4f25d8e1d41c496bae818174cfaef--34639c64fb8046a5afe62434ddd75463 52690da2a13d48a2a46814821521c6a0 RY(iia_\u03b2\u2081\u2085) 34639c64fb8046a5afe62434ddd75463--52690da2a13d48a2a46814821521c6a0 de94addb692d4f4596f1b6b62c7ab71e RX(iia_\u03b2\u2081\u2082) 52690da2a13d48a2a46814821521c6a0--de94addb692d4f4596f1b6b62c7ab71e de94addb692d4f4596f1b6b62c7ab71e--e534a2a9e4b54941ac97abcdc8f78963"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[0.7950]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9718]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': c7c600b6-37f1-4a02-82b3-4a837c7d193d, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': abeada92-6b83-4fd0-98e1-5d3d0b858abb, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 8118dc8f-f544-4e85-8579-a297e5c1dc9f, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c7f1b588-9912-4591-89a6-d82f73419db6, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 4943da6c-bc82-403c-8e1d-532331ae7be1, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 33f8b783-5683-41e1-b5b3-9e0cca045832, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 1a09a6dd-4ba6-4f37-b74d-fbbb84778483, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 3d4bd636-8bbc-4626-be1e-243329c24f86, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b32e8bda-a879-4149-8978-3bdba42a2b35, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b8a834eb-7fdf-4649-b27a-064bd7817589, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 76de441a-6eee-4b43-94b5-e05b548f516e, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_1: tensor([0.1037], requires_grad=True)\n  theta_7: tensor([0.0871], requires_grad=True)\n  theta_6: tensor([0.6515], requires_grad=True)\n  theta_8: tensor([0.4130], requires_grad=True)\n  theta_4: tensor([0.0048], requires_grad=True)\n  theta_5: tensor([0.6525], requires_grad=True)\n  theta_2: tensor([0.0253], requires_grad=True)\n  theta_3: tensor([0.1998], requires_grad=True)\n  theta_0: tensor([0.4202], requires_grad=True)\n}\nembedded = {\n  c7c600b6-37f1-4a02-82b3-4a837c7d193d: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  abeada92-6b83-4fd0-98e1-5d3d0b858abb: tensor([2., 2.])\n  8118dc8f-f544-4e85-8579-a297e5c1dc9f: tensor([0.4202], grad_fn=&lt;ViewBackward0&gt;)\n  c7f1b588-9912-4591-89a6-d82f73419db6: tensor([0.1037], grad_fn=&lt;ViewBackward0&gt;)\n  4943da6c-bc82-403c-8e1d-532331ae7be1: tensor([0.0253], grad_fn=&lt;ViewBackward0&gt;)\n  33f8b783-5683-41e1-b5b3-9e0cca045832: tensor([0.1998], grad_fn=&lt;ViewBackward0&gt;)\n  1a09a6dd-4ba6-4f37-b74d-fbbb84778483: tensor([0.0048], grad_fn=&lt;ViewBackward0&gt;)\n  3d4bd636-8bbc-4626-be1e-243329c24f86: tensor([0.6525], grad_fn=&lt;ViewBackward0&gt;)\n  b32e8bda-a879-4149-8978-3bdba42a2b35: tensor([0.6515], grad_fn=&lt;ViewBackward0&gt;)\n  b8a834eb-7fdf-4649-b27a-064bd7817589: tensor([0.0871], grad_fn=&lt;ViewBackward0&gt;)\n  76de441a-6eee-4b43-94b5-e05b548f516e: tensor([0.4130], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  y: tensor([2., 2.])\n  theta_1: tensor([0.1037], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.4130], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.0871], grad_fn=&lt;ViewBackward0&gt;)\n  theta_6: tensor([0.6515], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.6525], grad_fn=&lt;ViewBackward0&gt;)\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.0048], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.1998], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.0253], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.4202], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.0700-3.6374e-02j,  0.0175-2.6802e-02j,  0.0365+1.8930e-01j,\n         -0.1506+4.5069e-01j, -0.6863-3.8708e-01j, -0.3197-1.3397e-04j,\n         -0.0128+2.8051e-02j, -0.0615+4.4707e-02j],\n        [ 0.0700-3.6374e-02j,  0.0175-2.6802e-02j,  0.0365+1.8930e-01j,\n         -0.1506+4.5069e-01j, -0.6863-3.8708e-01j, -0.3197-1.3397e-04j,\n         -0.0128+2.8051e-02j, -0.0615+4.4707e-02j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 247, '111': 165, '011': 147, '100': 139, '001': 105, '110': 72, '010': 66, '101': 59})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(c7c600b6-37f1-4a02-82b3-4a837c7d193d)-C----------------------------------------Rx(8118dc8f-f544-4e85-8579-a297e5c1dc9f)-Ry(33f8b783-5683-41e1-b5b3-9e0cca045832)-Rx(b32e8bda-a879-4149-8978-3bdba42a2b35)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(abeada92-6b83-4fd0-98e1-5d3d0b858abb)-X----------------------------------------Rx(c7f1b588-9912-4591-89a6-d82f73419db6)-Ry(1a09a6dd-4ba6-4f37-b74d-fbbb84778483)-Rx(b8a834eb-7fdf-4649-b27a-064bd7817589)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(4943da6c-bc82-403c-8e1d-532331ae7be1)-Ry(3d4bd636-8bbc-4626-be1e-243329c24f86)-Rx(76de441a-6eee-4b43-94b5-e05b548f516e)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [1a09a6dd-4ba6-4f37-b74d-fbbb84778483, 33f8b783-5683-41e1-b5b3-9e0cca045832, 3d4bd636-8bbc-4626-be1e-243329c24f86, 4943da6c-bc82-403c-8e1d-532331ae7be1, 76de441a-6eee-4b43-94b5-e05b548f516e, 8118dc8f-f544-4e85-8579-a297e5c1dc9f, abeada92-6b83-4fd0-98e1-5d3d0b858abb, b32e8bda-a879-4149-8978-3bdba42a2b35, b8a834eb-7fdf-4649-b27a-064bd7817589, c7c600b6-37f1-4a02-82b3-4a837c7d193d, c7f1b588-9912-4591-89a6-d82f73419db6].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(0.94)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.42)-DEPO(0.1)-Ry(0.20)-DEPO(0.1)-Rx(0.65)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.08)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.10)-DEPO(0.1)-Ry(0.00)-DEPO(0.1)-Rx(0.09)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.65)-DEPO(0.1)-Rx(0.41)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 117159dde83c415392a4bd4e6e8c6fb0 0 561e550aa22e4c24b91f1f60545674b0 X 117159dde83c415392a4bd4e6e8c6fb0--561e550aa22e4c24b91f1f60545674b0 da1a2c95626b4e43a8711cda4f0117d4 1 6deaafc4e06a41e58e39c332df006567 561e550aa22e4c24b91f1f60545674b0--6deaafc4e06a41e58e39c332df006567 c2275550cc45455ab6589c9ba9737844 377547ec5ca641b593c397035c8274a5 Y da1a2c95626b4e43a8711cda4f0117d4--377547ec5ca641b593c397035c8274a5 377547ec5ca641b593c397035c8274a5--c2275550cc45455ab6589c9ba9737844 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 73bf5c2821974e4aaedfcddc40cea47b 0 4b246d1b84aa4921b748e6b9b0d2052d RX(0.5) 73bf5c2821974e4aaedfcddc40cea47b--4b246d1b84aa4921b748e6b9b0d2052d 6a4d52b249d44c3e9cc8665c230021eb 4b246d1b84aa4921b748e6b9b0d2052d--6a4d52b249d44c3e9cc8665c230021eb <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 3e141753b85545eb8e40383370de7090 0 6840bef67c324965a0c5fd2363828048 3e141753b85545eb8e40383370de7090--6840bef67c324965a0c5fd2363828048 5c56250817904968af508c96102b26f3 1 ce695c1da8924ebcb06ff85dd842f70d 6840bef67c324965a0c5fd2363828048--ce695c1da8924ebcb06ff85dd842f70d fd7f5b40603b416e9c4897b2c67624aa 3d7239c0367b4e9a80c7856b3ead8428 X 5c56250817904968af508c96102b26f3--3d7239c0367b4e9a80c7856b3ead8428 3d7239c0367b4e9a80c7856b3ead8428--6840bef67c324965a0c5fd2363828048 3d7239c0367b4e9a80c7856b3ead8428--fd7f5b40603b416e9c4897b2c67624aa <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 6798bcde565c4275b50573470ef01922 0 e57b52ed3d3940439249ffd44b206a1d X 6798bcde565c4275b50573470ef01922--e57b52ed3d3940439249ffd44b206a1d 95c69825fda747c2bdcebb6851481f45 X e57b52ed3d3940439249ffd44b206a1d--95c69825fda747c2bdcebb6851481f45 5cfb3ae6c2f14ccf90484173b5e99a22 95c69825fda747c2bdcebb6851481f45--5cfb3ae6c2f14ccf90484173b5e99a22 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 20ab084fc1ed41dba6f5efe39a0345da 0 0a181324272b410b82ce0f91f58420b8 X 20ab084fc1ed41dba6f5efe39a0345da--0a181324272b410b82ce0f91f58420b8 c6730b8c91124834880a9e41a51fe4ad 1 84486706cac04bbab6680dc92b0799d5 0a181324272b410b82ce0f91f58420b8--84486706cac04bbab6680dc92b0799d5 f21f0e4f93a84c1c95d7f9523428b251 84486706cac04bbab6680dc92b0799d5--f21f0e4f93a84c1c95d7f9523428b251 6e4b848dc12247728bc9d34014f21181 4a145e17ba8c4a0cb5dc7f8dbdeeb2f9 c6730b8c91124834880a9e41a51fe4ad--4a145e17ba8c4a0cb5dc7f8dbdeeb2f9 750a965c62fc4ed4a0892338fce6ac20 X 4a145e17ba8c4a0cb5dc7f8dbdeeb2f9--750a965c62fc4ed4a0892338fce6ac20 750a965c62fc4ed4a0892338fce6ac20--6e4b848dc12247728bc9d34014f21181 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 b26d51fde4ed4c5584aea0a3b2e8531b 0 4f0ba6d36cc04ac6a0260c3a19882825 X b26d51fde4ed4c5584aea0a3b2e8531b--4f0ba6d36cc04ac6a0260c3a19882825 58b60af36b0e462c914be704de54e760 1 0b4c6c4cdeb74a93a481b12e268d25ae 4f0ba6d36cc04ac6a0260c3a19882825--0b4c6c4cdeb74a93a481b12e268d25ae 55dec08f8b6f4545ac5f7d24ad867c5e aab5b58f6de948e7be218188a0c1cf04 X 58b60af36b0e462c914be704de54e760--aab5b58f6de948e7be218188a0c1cf04 aab5b58f6de948e7be218188a0c1cf04--55dec08f8b6f4545ac5f7d24ad867c5e <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_2c6d40fce7764a21abbc5329ed338cf7 subblock cluster_a287b1ec9e0c40129b1b09899e058764 subblock b19d903f812b4c87a66569ba4ee169f4 0 28a3f460359a4add8469a6f3fa2cd605 X b19d903f812b4c87a66569ba4ee169f4--28a3f460359a4add8469a6f3fa2cd605 f213574df08e438f8051afd04e641948 1 7bb9e3ae081547f8976461672edb2a81 X 28a3f460359a4add8469a6f3fa2cd605--7bb9e3ae081547f8976461672edb2a81 af682277d49843b3a2b58adf3c17d9a4 7bb9e3ae081547f8976461672edb2a81--af682277d49843b3a2b58adf3c17d9a4 8021b6d978a7481b97a344adfef6208a 535d21384a1949288224a45299a5f668 Y f213574df08e438f8051afd04e641948--535d21384a1949288224a45299a5f668 06bde84afc2f44869aa13707f1113010 2 b385783fcf4640b881902acaab664815 Y 535d21384a1949288224a45299a5f668--b385783fcf4640b881902acaab664815 b385783fcf4640b881902acaab664815--8021b6d978a7481b97a344adfef6208a 3d16d221cc5e4614b6ece69422ff2aaf 76176980f82c489b8ce51c9a7b894990 06bde84afc2f44869aa13707f1113010--76176980f82c489b8ce51c9a7b894990 938b9b9711d84e019508c128b2a5cfd8 3 03cbc5ea099c441193bee87905d2e6c4 76176980f82c489b8ce51c9a7b894990--03cbc5ea099c441193bee87905d2e6c4 03cbc5ea099c441193bee87905d2e6c4--3d16d221cc5e4614b6ece69422ff2aaf 04d64f9db108470292af6708228f1644 3dd8a0e4aa6641d699931a8391e27831 938b9b9711d84e019508c128b2a5cfd8--3dd8a0e4aa6641d699931a8391e27831 fcb9d0800b394e81aa5d7d1adba8f303 4 09948d8e2301485fac4b956204087dce 3dd8a0e4aa6641d699931a8391e27831--09948d8e2301485fac4b956204087dce 09948d8e2301485fac4b956204087dce--04d64f9db108470292af6708228f1644 e58737aca3f547d3aec80ab8a04de369 62d1de21474b407e9ac31cb4f573c74d X fcb9d0800b394e81aa5d7d1adba8f303--62d1de21474b407e9ac31cb4f573c74d 62d1de21474b407e9ac31cb4f573c74d--3dd8a0e4aa6641d699931a8391e27831 205841ee58f54472b948690bb030332b X 62d1de21474b407e9ac31cb4f573c74d--205841ee58f54472b948690bb030332b 205841ee58f54472b948690bb030332b--09948d8e2301485fac4b956204087dce 205841ee58f54472b948690bb030332b--e58737aca3f547d3aec80ab8a04de369"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'01': 283, '11': 247, '10': 241, '00': 229})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'000': 29, '010': 29, '110': 27, '100': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Alternatively, a custom interaction function can also be defined. The input should be two integer indices \\(i\\) and \\(j\\) and it should return a composition of pauli terms representing the interaction between qubits \\(i\\) and \\(j\\):</p> <pre><code>def custom_int(i: int, j: int):\n    return X(i) @ X(j) + Y(i) @ Y(j)\n\nn_qubits = 2\n\nhamilt = hamiltonian_factory(n_qubits, interaction=custom_int)\n</code></pre> <pre><code>AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 AddBlock(0,1)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u251c\u2500\u2500 X(0)\n        \u2502   \u2514\u2500\u2500 X(1)\n        \u2514\u2500\u2500 KronBlock(0,1)\n            \u251c\u2500\u2500 Y(0)\n            \u2514\u2500\u2500 Y(1)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(1)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import numpy as np\nfrom torch import tensor\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea, PI\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": tensor([PI / 2, PI])}\nvalues_ket = {\"psi\": tensor([PI / 2, PI])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2618, 0.0050],\n        [0.0076, 0.0072]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from qadence import RX, run, PI\n\n# Let's use a torch type.\nblock = RX(0, PI)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9882+0.0000j, 0.0000-0.1531j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8785+0.0000j, 0.0000-0.4778j],\n        [0.9538+0.0000j, 0.0000-0.3006j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5500+0.0000j, 0.5257+0.0000j, 0.0000-0.4691j, 0.0000-0.4484j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_559ec1fee5d0486aa382468362721754 [* 2] cluster_5d0a07efb16e44ddb57d428d3d16f84d Rotations c30b5c6539af40479cf8773fe319cc2c 0 903a942877bf483b94668b55a2a210ec RX(phi/theta) c30b5c6539af40479cf8773fe319cc2c--903a942877bf483b94668b55a2a210ec 80989f5ba95d4bf0a1e3b6d8528e5802 1 2886e0c972ee48c0a29cb59219989c6e RX(phi) 903a942877bf483b94668b55a2a210ec--2886e0c972ee48c0a29cb59219989c6e 70aa189dadd648b7922721d8c17426b1 RX(phi) 2886e0c972ee48c0a29cb59219989c6e--70aa189dadd648b7922721d8c17426b1 9477c394b8734315a7136730e7c7853b RX(phi + theta) 70aa189dadd648b7922721d8c17426b1--9477c394b8734315a7136730e7c7853b 3bfa28ca8652486bb402c9d425cf55d5 9477c394b8734315a7136730e7c7853b--3bfa28ca8652486bb402c9d425cf55d5 db77057bd4424a0d9867959168183600 3bfa28ca8652486bb402c9d425cf55d5--db77057bd4424a0d9867959168183600 39a5507ee16b4292b4731ae3cb07903f Z db77057bd4424a0d9867959168183600--39a5507ee16b4292b4731ae3cb07903f b6689e875a6e44d391e2fedd4370e10c 39a5507ee16b4292b4731ae3cb07903f--b6689e875a6e44d391e2fedd4370e10c a3da77012249468aa2f58e3feb21bc4c ae3f693ea7e24281951cd8c671605caf RY(2*theta) 80989f5ba95d4bf0a1e3b6d8528e5802--ae3f693ea7e24281951cd8c671605caf 488417e627e04fd8a8e88905947f6002 2 a0b7ced4105046368508ef9a6a27b4af RY(theta) ae3f693ea7e24281951cd8c671605caf--a0b7ced4105046368508ef9a6a27b4af 58007a42bb8644a7ac756c1781839d3b RY(theta) a0b7ced4105046368508ef9a6a27b4af--58007a42bb8644a7ac756c1781839d3b e5fe89a84e4940a9ac4a75bcb437d203 RY(theta**2) 58007a42bb8644a7ac756c1781839d3b--e5fe89a84e4940a9ac4a75bcb437d203 cdcf462c27b64d74be0cd12e676e03d6 X e5fe89a84e4940a9ac4a75bcb437d203--cdcf462c27b64d74be0cd12e676e03d6 cdcf462c27b64d74be0cd12e676e03d6--3bfa28ca8652486bb402c9d425cf55d5 b254f68dc8e84199ae94e040c29680be cdcf462c27b64d74be0cd12e676e03d6--b254f68dc8e84199ae94e040c29680be 074c27171fe14297960c6dd9c69c9caa Z b254f68dc8e84199ae94e040c29680be--074c27171fe14297960c6dd9c69c9caa 074c27171fe14297960c6dd9c69c9caa--a3da77012249468aa2f58e3feb21bc4c 9808a70884684e5b9ed5f8e24cf0c572 a07d04b8617a4b90aff20517d349eecb RZ(cos(phi)) 488417e627e04fd8a8e88905947f6002--a07d04b8617a4b90aff20517d349eecb 4a97454e94244756bd8487395f3b9dee RZ(phi) a07d04b8617a4b90aff20517d349eecb--4a97454e94244756bd8487395f3b9dee e0f361a72d3349f188bff699d61bf5d8 RZ(phi) 4a97454e94244756bd8487395f3b9dee--e0f361a72d3349f188bff699d61bf5d8 92bf9ec7494d430fbffd442c31ccb727 RZ(cos(phi)) e0f361a72d3349f188bff699d61bf5d8--92bf9ec7494d430fbffd442c31ccb727 552801dd6bcf4679a31bce0cc99e9868 92bf9ec7494d430fbffd442c31ccb727--552801dd6bcf4679a31bce0cc99e9868 cebcce79dce84d55bb0c8f761facaac1 X 552801dd6bcf4679a31bce0cc99e9868--cebcce79dce84d55bb0c8f761facaac1 cebcce79dce84d55bb0c8f761facaac1--b254f68dc8e84199ae94e040c29680be 8198f56e6200414eb15e22c3c4e44d46 Z cebcce79dce84d55bb0c8f761facaac1--8198f56e6200414eb15e22c3c4e44d46 8198f56e6200414eb15e22c3c4e44d46--9808a70884684e5b9ed5f8e24cf0c572 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.2054]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9677+0.0000j, 0.1768+0.0000j, 0.0000-0.1768j, 0.0000-0.0323j],\n        [0.9856+0.0000j, 0.1193+0.0000j, 0.0000-0.1193j, 0.0000-0.0144j],\n        [0.8356+0.0000j, 0.3706+0.0000j, 0.0000-0.3706j, 0.0000-0.1644j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 6e7f701245604659920199544c8d0e4f 0 ef2bb48c6d074f8fa2672469f497fc05 RX(theta\u2080) 6e7f701245604659920199544c8d0e4f--ef2bb48c6d074f8fa2672469f497fc05 96b8ef4546f94302973275d3a9be5d3c 1 413efb5d8f904b319178cd5b4153f30f RY(theta\u2084) ef2bb48c6d074f8fa2672469f497fc05--413efb5d8f904b319178cd5b4153f30f 41d9ded83fd348809c72f29f236099f8 RX(theta\u2088) 413efb5d8f904b319178cd5b4153f30f--41d9ded83fd348809c72f29f236099f8 a7cddb091ac54311bf34f3fa2e449a47 41d9ded83fd348809c72f29f236099f8--a7cddb091ac54311bf34f3fa2e449a47 e21a56260b1f433ba929fe15d9ebeb5a a7cddb091ac54311bf34f3fa2e449a47--e21a56260b1f433ba929fe15d9ebeb5a 9c8caa7b27bd43dcb1470fdac9bb836a RX(theta\u2081\u2082) e21a56260b1f433ba929fe15d9ebeb5a--9c8caa7b27bd43dcb1470fdac9bb836a fcf92eea8cae4a2e9fcb555252036669 RY(theta\u2081\u2086) 9c8caa7b27bd43dcb1470fdac9bb836a--fcf92eea8cae4a2e9fcb555252036669 c37677c8cca24723aafa852b79d2b775 RX(theta\u2082\u2080) fcf92eea8cae4a2e9fcb555252036669--c37677c8cca24723aafa852b79d2b775 0df632881f9b46028f09037d9d93be8c c37677c8cca24723aafa852b79d2b775--0df632881f9b46028f09037d9d93be8c e9ab2de8bb6f488c8ccaf7949c93aa7b 0df632881f9b46028f09037d9d93be8c--e9ab2de8bb6f488c8ccaf7949c93aa7b 200cb08649204cd6a5f746596cf0c623 e9ab2de8bb6f488c8ccaf7949c93aa7b--200cb08649204cd6a5f746596cf0c623 1402c4f452904c24b7c3cecff947fe35 9c07f4e278ad44bdb1efba5fe94dea36 RX(theta\u2081) 96b8ef4546f94302973275d3a9be5d3c--9c07f4e278ad44bdb1efba5fe94dea36 3e326ac7b70b47a6a82195b6c2b56cd9 2 5de92e93a57b481ebde0ca97882a4f4e RY(theta\u2085) 9c07f4e278ad44bdb1efba5fe94dea36--5de92e93a57b481ebde0ca97882a4f4e 3eed2287badd4e4ebd050a44fc4511a4 RX(theta\u2089) 5de92e93a57b481ebde0ca97882a4f4e--3eed2287badd4e4ebd050a44fc4511a4 8e109500b65c48eab3b7d94f95687327 X 3eed2287badd4e4ebd050a44fc4511a4--8e109500b65c48eab3b7d94f95687327 8e109500b65c48eab3b7d94f95687327--a7cddb091ac54311bf34f3fa2e449a47 5be5165f2ac0489daeea8fee029d9fc5 8e109500b65c48eab3b7d94f95687327--5be5165f2ac0489daeea8fee029d9fc5 3b52a88ee9f24933a9401294772d4060 RX(theta\u2081\u2083) 5be5165f2ac0489daeea8fee029d9fc5--3b52a88ee9f24933a9401294772d4060 99fea065c9d14e3891915071c8cc5320 RY(theta\u2081\u2087) 3b52a88ee9f24933a9401294772d4060--99fea065c9d14e3891915071c8cc5320 b00a85210101456b86db45dffd545a9d RX(theta\u2082\u2081) 99fea065c9d14e3891915071c8cc5320--b00a85210101456b86db45dffd545a9d 635863a0c70147bda7915d5f9a5b44d5 X b00a85210101456b86db45dffd545a9d--635863a0c70147bda7915d5f9a5b44d5 635863a0c70147bda7915d5f9a5b44d5--0df632881f9b46028f09037d9d93be8c 3f06cd5adeb44bb4bc41f8fb7d2bf897 635863a0c70147bda7915d5f9a5b44d5--3f06cd5adeb44bb4bc41f8fb7d2bf897 3f06cd5adeb44bb4bc41f8fb7d2bf897--1402c4f452904c24b7c3cecff947fe35 2b1340933301473fb4cdb551f85e152b 2b7ccfbf23e14f5e8e7735808ceaea8b RX(theta\u2082) 3e326ac7b70b47a6a82195b6c2b56cd9--2b7ccfbf23e14f5e8e7735808ceaea8b db55188a0e48450894dbf4cf0ae5e88b 3 b729a67733164a89b4fe4045d01ef3a2 RY(theta\u2086) 2b7ccfbf23e14f5e8e7735808ceaea8b--b729a67733164a89b4fe4045d01ef3a2 4165d159bf5c47cf906a09cda53f274c RX(theta\u2081\u2080) b729a67733164a89b4fe4045d01ef3a2--4165d159bf5c47cf906a09cda53f274c 0977bb1f46ee41639fcaa14f83cc7b5e 4165d159bf5c47cf906a09cda53f274c--0977bb1f46ee41639fcaa14f83cc7b5e 567f0ec561a64c7a933dc5da501ccc80 X 0977bb1f46ee41639fcaa14f83cc7b5e--567f0ec561a64c7a933dc5da501ccc80 567f0ec561a64c7a933dc5da501ccc80--5be5165f2ac0489daeea8fee029d9fc5 4676c4529e7d466ebc97a2e81b0ff49b RX(theta\u2081\u2084) 567f0ec561a64c7a933dc5da501ccc80--4676c4529e7d466ebc97a2e81b0ff49b a2f584e10b714c48a42ad153db0fa4ec RY(theta\u2081\u2088) 4676c4529e7d466ebc97a2e81b0ff49b--a2f584e10b714c48a42ad153db0fa4ec 83997d6590a0428497ed88c05936f8d5 RX(theta\u2082\u2082) a2f584e10b714c48a42ad153db0fa4ec--83997d6590a0428497ed88c05936f8d5 5d12576d8f904bad9c8f44d487cd76cd 83997d6590a0428497ed88c05936f8d5--5d12576d8f904bad9c8f44d487cd76cd dcce7e69eca34140b0a1179cb446e750 X 5d12576d8f904bad9c8f44d487cd76cd--dcce7e69eca34140b0a1179cb446e750 dcce7e69eca34140b0a1179cb446e750--3f06cd5adeb44bb4bc41f8fb7d2bf897 dcce7e69eca34140b0a1179cb446e750--2b1340933301473fb4cdb551f85e152b bc506d9e86cd4a1699c5aba3d2f938f8 ef119d0cd865458ba81ee2e3c6ec6c0c RX(theta\u2083) db55188a0e48450894dbf4cf0ae5e88b--ef119d0cd865458ba81ee2e3c6ec6c0c ddb0d6c9a5044fd38c7230379c16b0a0 RY(theta\u2087) ef119d0cd865458ba81ee2e3c6ec6c0c--ddb0d6c9a5044fd38c7230379c16b0a0 d156f7f228624e7c909776b036204f1e RX(theta\u2081\u2081) ddb0d6c9a5044fd38c7230379c16b0a0--d156f7f228624e7c909776b036204f1e 559cff64e5b441079067ca6d93c934e2 X d156f7f228624e7c909776b036204f1e--559cff64e5b441079067ca6d93c934e2 559cff64e5b441079067ca6d93c934e2--0977bb1f46ee41639fcaa14f83cc7b5e 55d7da69818d480e86cfd169f653a9f3 559cff64e5b441079067ca6d93c934e2--55d7da69818d480e86cfd169f653a9f3 e83d34ea2fdb4bcda4b87fb2053fbbae RX(theta\u2081\u2085) 55d7da69818d480e86cfd169f653a9f3--e83d34ea2fdb4bcda4b87fb2053fbbae 0e707a2c9d004f27baf6dfc17da6b3e3 RY(theta\u2081\u2089) e83d34ea2fdb4bcda4b87fb2053fbbae--0e707a2c9d004f27baf6dfc17da6b3e3 ef6d50f4be6a402a83c04753c3af7bd6 RX(theta\u2082\u2083) 0e707a2c9d004f27baf6dfc17da6b3e3--ef6d50f4be6a402a83c04753c3af7bd6 25beecc1e74c4470ba84173607010cb1 X ef6d50f4be6a402a83c04753c3af7bd6--25beecc1e74c4470ba84173607010cb1 25beecc1e74c4470ba84173607010cb1--5d12576d8f904bad9c8f44d487cd76cd be85450b17e7476caa4fa3d683bcc275 25beecc1e74c4470ba84173607010cb1--be85450b17e7476caa4fa3d683bcc275 be85450b17e7476caa4fa3d683bcc275--bc506d9e86cd4a1699c5aba3d2f938f8 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_c8139b7ebe1845fbb7186c3e58aebd5e HEA cluster_db294071b9754bfcbeb5943448badd0b HEA 7ce7b5e5f38848d687836dfcded9963d 0 a0222b86fd804907b2a427e0735293b7 RX(theta\u2080) 7ce7b5e5f38848d687836dfcded9963d--a0222b86fd804907b2a427e0735293b7 1bfcfaa0f22b498d9c280fa694999741 1 b727667de13648829d3c47921dae7683 RY(theta\u2084) a0222b86fd804907b2a427e0735293b7--b727667de13648829d3c47921dae7683 0098ccfbede64771b31e6a7736f797e3 RX(theta\u2088) b727667de13648829d3c47921dae7683--0098ccfbede64771b31e6a7736f797e3 ed9069e72edc412fb6744e22b8dc1488 0098ccfbede64771b31e6a7736f797e3--ed9069e72edc412fb6744e22b8dc1488 10fc3e41c51148bbbeb7127164453e11 ed9069e72edc412fb6744e22b8dc1488--10fc3e41c51148bbbeb7127164453e11 03b2f6b7ce6f4e178cfbcefe703c8f8f RX(theta\u2081\u2082) 10fc3e41c51148bbbeb7127164453e11--03b2f6b7ce6f4e178cfbcefe703c8f8f fde9627d9b634481ac97c626b0676b68 RY(theta\u2081\u2086) 03b2f6b7ce6f4e178cfbcefe703c8f8f--fde9627d9b634481ac97c626b0676b68 ac1223b0283d46789337b809508c52dd RX(theta\u2082\u2080) fde9627d9b634481ac97c626b0676b68--ac1223b0283d46789337b809508c52dd f0f996326eab4347aaf29d24e4e3a5a2 ac1223b0283d46789337b809508c52dd--f0f996326eab4347aaf29d24e4e3a5a2 f523257a95654228907eb9f2b8ec9159 f0f996326eab4347aaf29d24e4e3a5a2--f523257a95654228907eb9f2b8ec9159 7921c6d6e7d14610b379cdbc25e1353f RX(theta\u2080) f523257a95654228907eb9f2b8ec9159--7921c6d6e7d14610b379cdbc25e1353f 4fb15f384abc4901940666e7364cd738 RY(theta\u2084) 7921c6d6e7d14610b379cdbc25e1353f--4fb15f384abc4901940666e7364cd738 7a1b5786f8444e718620b62099b19630 RX(theta\u2088) 4fb15f384abc4901940666e7364cd738--7a1b5786f8444e718620b62099b19630 caedea7311c04124a28e68b4c884c3c3 7a1b5786f8444e718620b62099b19630--caedea7311c04124a28e68b4c884c3c3 3d8d01097fda48608947c6b71294e26b caedea7311c04124a28e68b4c884c3c3--3d8d01097fda48608947c6b71294e26b 9ff1a04f2afb4454b43e02eefdd578f7 RX(theta\u2081\u2082) 3d8d01097fda48608947c6b71294e26b--9ff1a04f2afb4454b43e02eefdd578f7 56b7803b3e194cef98e36b956ba011bd RY(theta\u2081\u2086) 9ff1a04f2afb4454b43e02eefdd578f7--56b7803b3e194cef98e36b956ba011bd 50717fa6cdc44a098269223f87b1b2a7 RX(theta\u2082\u2080) 56b7803b3e194cef98e36b956ba011bd--50717fa6cdc44a098269223f87b1b2a7 ea124af3bced462fa5f7c818f4d16ad7 50717fa6cdc44a098269223f87b1b2a7--ea124af3bced462fa5f7c818f4d16ad7 f1d73603239f447289c5d080c94f274a ea124af3bced462fa5f7c818f4d16ad7--f1d73603239f447289c5d080c94f274a 8651e85591014b0380f632583f04e4d6 f1d73603239f447289c5d080c94f274a--8651e85591014b0380f632583f04e4d6 2f59d1ff5a1845308310cffd03e2049c 0c70f0791c8d483080064b4c91c6a30b RX(theta\u2081) 1bfcfaa0f22b498d9c280fa694999741--0c70f0791c8d483080064b4c91c6a30b 5e8b265a4135447792e1d9774f7e61b7 2 9647be543b17432f9cd4377bf1faf62a RY(theta\u2085) 0c70f0791c8d483080064b4c91c6a30b--9647be543b17432f9cd4377bf1faf62a 2bca0506fd6247328d4121339a9baea4 RX(theta\u2089) 9647be543b17432f9cd4377bf1faf62a--2bca0506fd6247328d4121339a9baea4 9d3d34670c3e478bb3037266ec836f9b X 2bca0506fd6247328d4121339a9baea4--9d3d34670c3e478bb3037266ec836f9b 9d3d34670c3e478bb3037266ec836f9b--ed9069e72edc412fb6744e22b8dc1488 e5cfff0b511644afb5fadbbc8d6d1114 9d3d34670c3e478bb3037266ec836f9b--e5cfff0b511644afb5fadbbc8d6d1114 ee932b54c83b41c8bb3831cda374748a RX(theta\u2081\u2083) e5cfff0b511644afb5fadbbc8d6d1114--ee932b54c83b41c8bb3831cda374748a 0946363fd4aa42a7843eb9740eebc7f2 RY(theta\u2081\u2087) ee932b54c83b41c8bb3831cda374748a--0946363fd4aa42a7843eb9740eebc7f2 d60fcbaa2e064580863e9ad8e90286c3 RX(theta\u2082\u2081) 0946363fd4aa42a7843eb9740eebc7f2--d60fcbaa2e064580863e9ad8e90286c3 0843a93210914ef0b6480a6912d1b9ce X d60fcbaa2e064580863e9ad8e90286c3--0843a93210914ef0b6480a6912d1b9ce 0843a93210914ef0b6480a6912d1b9ce--f0f996326eab4347aaf29d24e4e3a5a2 bbce6c11d0a943bb82433e3f3751d212 0843a93210914ef0b6480a6912d1b9ce--bbce6c11d0a943bb82433e3f3751d212 815774493b3b457ba25bd92a14fc982c RX(theta\u2081) bbce6c11d0a943bb82433e3f3751d212--815774493b3b457ba25bd92a14fc982c 0a713a3da454449d9b5716142c923bf0 RY(theta\u2085) 815774493b3b457ba25bd92a14fc982c--0a713a3da454449d9b5716142c923bf0 0f70135ae10642f3a29814d738d303df RX(theta\u2089) 0a713a3da454449d9b5716142c923bf0--0f70135ae10642f3a29814d738d303df 35267998bbcb4ea39ba844d00b028ea0 X 0f70135ae10642f3a29814d738d303df--35267998bbcb4ea39ba844d00b028ea0 35267998bbcb4ea39ba844d00b028ea0--caedea7311c04124a28e68b4c884c3c3 8a284660216a423b836038d65ae4abe2 35267998bbcb4ea39ba844d00b028ea0--8a284660216a423b836038d65ae4abe2 c0755abbe14649f2b0694a02cb90d82a RX(theta\u2081\u2083) 8a284660216a423b836038d65ae4abe2--c0755abbe14649f2b0694a02cb90d82a d3dedbbef0924043a7381a1fdb6077c4 RY(theta\u2081\u2087) c0755abbe14649f2b0694a02cb90d82a--d3dedbbef0924043a7381a1fdb6077c4 745f510f03c84bae974d34aafad62846 RX(theta\u2082\u2081) d3dedbbef0924043a7381a1fdb6077c4--745f510f03c84bae974d34aafad62846 63ed5c075c23489aa339ab023276f73e X 745f510f03c84bae974d34aafad62846--63ed5c075c23489aa339ab023276f73e 63ed5c075c23489aa339ab023276f73e--ea124af3bced462fa5f7c818f4d16ad7 562e430ba5d648ddad29caa0d846d41a 63ed5c075c23489aa339ab023276f73e--562e430ba5d648ddad29caa0d846d41a 562e430ba5d648ddad29caa0d846d41a--2f59d1ff5a1845308310cffd03e2049c aef02ad274ad48f9b4825b836fb0c0f5 55366394078e439e8be3ef580a5ba804 RX(theta\u2082) 5e8b265a4135447792e1d9774f7e61b7--55366394078e439e8be3ef580a5ba804 1962874f50914503803c8c9a25aa90c1 3 7c6fb63b13e84247a49431f6eb4f1fa4 RY(theta\u2086) 55366394078e439e8be3ef580a5ba804--7c6fb63b13e84247a49431f6eb4f1fa4 79953dc182a241ccafbd0029a6f55560 RX(theta\u2081\u2080) 7c6fb63b13e84247a49431f6eb4f1fa4--79953dc182a241ccafbd0029a6f55560 3576bcb553704016a0c7ad5a208b2992 79953dc182a241ccafbd0029a6f55560--3576bcb553704016a0c7ad5a208b2992 b9d36adfc1934d86a593db68167f1686 X 3576bcb553704016a0c7ad5a208b2992--b9d36adfc1934d86a593db68167f1686 b9d36adfc1934d86a593db68167f1686--e5cfff0b511644afb5fadbbc8d6d1114 48aba6745e5d47e285582d3f710d0a66 RX(theta\u2081\u2084) b9d36adfc1934d86a593db68167f1686--48aba6745e5d47e285582d3f710d0a66 c05d4d09b6b74d53a8b7d2b92f2522c8 RY(theta\u2081\u2088) 48aba6745e5d47e285582d3f710d0a66--c05d4d09b6b74d53a8b7d2b92f2522c8 cabea945f1354893ad8fa4c0ee1ac10c RX(theta\u2082\u2082) c05d4d09b6b74d53a8b7d2b92f2522c8--cabea945f1354893ad8fa4c0ee1ac10c afe51805afbe4f99a254b5f008feafa6 cabea945f1354893ad8fa4c0ee1ac10c--afe51805afbe4f99a254b5f008feafa6 96facf7f20c64949bf6ea6faebee2ef5 X afe51805afbe4f99a254b5f008feafa6--96facf7f20c64949bf6ea6faebee2ef5 96facf7f20c64949bf6ea6faebee2ef5--bbce6c11d0a943bb82433e3f3751d212 8a9c10662d8c4e4c9f5d017e91f9b906 RX(theta\u2082) 96facf7f20c64949bf6ea6faebee2ef5--8a9c10662d8c4e4c9f5d017e91f9b906 6bf28e9fd77140dcb6f17641199f81c1 RY(theta\u2086) 8a9c10662d8c4e4c9f5d017e91f9b906--6bf28e9fd77140dcb6f17641199f81c1 12a65145ab9449e497d24b96a670995d RX(theta\u2081\u2080) 6bf28e9fd77140dcb6f17641199f81c1--12a65145ab9449e497d24b96a670995d f8aaa182fede4612bbe3105142b7a53e 12a65145ab9449e497d24b96a670995d--f8aaa182fede4612bbe3105142b7a53e 478e27a778c6435cae6c5c1be0c20ef0 X f8aaa182fede4612bbe3105142b7a53e--478e27a778c6435cae6c5c1be0c20ef0 478e27a778c6435cae6c5c1be0c20ef0--8a284660216a423b836038d65ae4abe2 3e17e54e7e9e4d118390b3972f02325b RX(theta\u2081\u2084) 478e27a778c6435cae6c5c1be0c20ef0--3e17e54e7e9e4d118390b3972f02325b 21d1627964f7407bb5f0bbb82bf42310 RY(theta\u2081\u2088) 3e17e54e7e9e4d118390b3972f02325b--21d1627964f7407bb5f0bbb82bf42310 d61b371cfa2142dbb123c29100cf26ab RX(theta\u2082\u2082) 21d1627964f7407bb5f0bbb82bf42310--d61b371cfa2142dbb123c29100cf26ab a6fd281cb00f4298b4a25def1cbe5dbd d61b371cfa2142dbb123c29100cf26ab--a6fd281cb00f4298b4a25def1cbe5dbd 313e27a3ddf442aa80d7d516e436a098 X a6fd281cb00f4298b4a25def1cbe5dbd--313e27a3ddf442aa80d7d516e436a098 313e27a3ddf442aa80d7d516e436a098--562e430ba5d648ddad29caa0d846d41a 313e27a3ddf442aa80d7d516e436a098--aef02ad274ad48f9b4825b836fb0c0f5 f57a8989b17749418cd17c242bb69915 847ea011d24c441c8dc4b9adb5eb75df RX(theta\u2083) 1962874f50914503803c8c9a25aa90c1--847ea011d24c441c8dc4b9adb5eb75df 5d06374e6d5345dc9800924cd480a138 RY(theta\u2087) 847ea011d24c441c8dc4b9adb5eb75df--5d06374e6d5345dc9800924cd480a138 2c178661913a40cbb55a8d46538f0982 RX(theta\u2081\u2081) 5d06374e6d5345dc9800924cd480a138--2c178661913a40cbb55a8d46538f0982 9c7ede1c1ae94cfebaf49d983da720c8 X 2c178661913a40cbb55a8d46538f0982--9c7ede1c1ae94cfebaf49d983da720c8 9c7ede1c1ae94cfebaf49d983da720c8--3576bcb553704016a0c7ad5a208b2992 f786cbb658624b288c674e05ccd8bf90 9c7ede1c1ae94cfebaf49d983da720c8--f786cbb658624b288c674e05ccd8bf90 9429a381f7384c3f9a5a7d91e898c797 RX(theta\u2081\u2085) f786cbb658624b288c674e05ccd8bf90--9429a381f7384c3f9a5a7d91e898c797 e3f440e81064469dba9d0d481b8fafe1 RY(theta\u2081\u2089) 9429a381f7384c3f9a5a7d91e898c797--e3f440e81064469dba9d0d481b8fafe1 62703112c20a4b44bde6052946c4696a RX(theta\u2082\u2083) e3f440e81064469dba9d0d481b8fafe1--62703112c20a4b44bde6052946c4696a a6cc02ac1c064eee95f1363572202e63 X 62703112c20a4b44bde6052946c4696a--a6cc02ac1c064eee95f1363572202e63 a6cc02ac1c064eee95f1363572202e63--afe51805afbe4f99a254b5f008feafa6 7264aed1ce874d57ad4dea2c13a871fe a6cc02ac1c064eee95f1363572202e63--7264aed1ce874d57ad4dea2c13a871fe 2423361eb25c455aa5a1b445d327ea52 RX(theta\u2083) 7264aed1ce874d57ad4dea2c13a871fe--2423361eb25c455aa5a1b445d327ea52 4f4e93649035461da1765314b9d1c939 RY(theta\u2087) 2423361eb25c455aa5a1b445d327ea52--4f4e93649035461da1765314b9d1c939 0757dd11df8a483b821cf73c5b2f8c75 RX(theta\u2081\u2081) 4f4e93649035461da1765314b9d1c939--0757dd11df8a483b821cf73c5b2f8c75 ff73a9a7734d4d2487cdbd04d3842b80 X 0757dd11df8a483b821cf73c5b2f8c75--ff73a9a7734d4d2487cdbd04d3842b80 ff73a9a7734d4d2487cdbd04d3842b80--f8aaa182fede4612bbe3105142b7a53e 5983a074acd6483eaa92b4f3ba6a27ca ff73a9a7734d4d2487cdbd04d3842b80--5983a074acd6483eaa92b4f3ba6a27ca 590166f457e64da4b9ecfe68b1a2169e RX(theta\u2081\u2085) 5983a074acd6483eaa92b4f3ba6a27ca--590166f457e64da4b9ecfe68b1a2169e 4bc7bf3fff764b44ab84110673fed300 RY(theta\u2081\u2089) 590166f457e64da4b9ecfe68b1a2169e--4bc7bf3fff764b44ab84110673fed300 3e8ede703fcd4d259ad16c286302a465 RX(theta\u2082\u2083) 4bc7bf3fff764b44ab84110673fed300--3e8ede703fcd4d259ad16c286302a465 073f568de5614285a1a7ff961f58cfb8 X 3e8ede703fcd4d259ad16c286302a465--073f568de5614285a1a7ff961f58cfb8 073f568de5614285a1a7ff961f58cfb8--a6fd281cb00f4298b4a25def1cbe5dbd 8fb6a0a9c0e64bde84664629fef38de3 073f568de5614285a1a7ff961f58cfb8--8fb6a0a9c0e64bde84664629fef38de3 8fb6a0a9c0e64bde84664629fef38de3--f57a8989b17749418cd17c242bb69915 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_9b91e9e2b4454082bd00c374480b2c92 HEA cluster_8e34a3fe841349158e2dc59afd1c2158 HEA 8304756f566b420f914907806c688bad 0 3054d9909874442cb053ba82801441fa RX(p1\u2080) 8304756f566b420f914907806c688bad--3054d9909874442cb053ba82801441fa 32b05dfd07eb4856a54a9d84739408de 1 cce1f42bcae04e69aba09e11e3ef6dbd RY(p1\u2084) 3054d9909874442cb053ba82801441fa--cce1f42bcae04e69aba09e11e3ef6dbd 2e981a163bd747ee909ea385ff37c41f RX(p1\u2088) cce1f42bcae04e69aba09e11e3ef6dbd--2e981a163bd747ee909ea385ff37c41f a73a7fd1bb0c47a5b4ca739f65ceb6d0 2e981a163bd747ee909ea385ff37c41f--a73a7fd1bb0c47a5b4ca739f65ceb6d0 bcb3cc0c4d5b49de9f3f52e9358b0ca1 a73a7fd1bb0c47a5b4ca739f65ceb6d0--bcb3cc0c4d5b49de9f3f52e9358b0ca1 40e60bfb595a4dcdbc86d05add8ce069 RX(p1\u2081\u2082) bcb3cc0c4d5b49de9f3f52e9358b0ca1--40e60bfb595a4dcdbc86d05add8ce069 88613fd8d8854680a0dd2c3099388bcf RY(p1\u2081\u2086) 40e60bfb595a4dcdbc86d05add8ce069--88613fd8d8854680a0dd2c3099388bcf 3fb04fbc2643439591a515ed796e4f5b RX(p1\u2082\u2080) 88613fd8d8854680a0dd2c3099388bcf--3fb04fbc2643439591a515ed796e4f5b 2c0d89e653704b5090fc86cf0c7dd30a 3fb04fbc2643439591a515ed796e4f5b--2c0d89e653704b5090fc86cf0c7dd30a e5d2baf1d8724aec9f78c3319402a720 2c0d89e653704b5090fc86cf0c7dd30a--e5d2baf1d8724aec9f78c3319402a720 e276c25bf56f4ecd8ad59bad3d76fd10 RX(p2\u2080) e5d2baf1d8724aec9f78c3319402a720--e276c25bf56f4ecd8ad59bad3d76fd10 76510de484ff4d399dbe6f763d1d4b39 RY(p2\u2084) e276c25bf56f4ecd8ad59bad3d76fd10--76510de484ff4d399dbe6f763d1d4b39 2e660ce221c84945b47d69a766ea77cf RX(p2\u2088) 76510de484ff4d399dbe6f763d1d4b39--2e660ce221c84945b47d69a766ea77cf be3a824e0e23444a902946f60acecdcc 2e660ce221c84945b47d69a766ea77cf--be3a824e0e23444a902946f60acecdcc f616efdca9a24548bc0b1fcc9b389927 be3a824e0e23444a902946f60acecdcc--f616efdca9a24548bc0b1fcc9b389927 0c245e067f364b349d7237ab0b54cbcd RX(p2\u2081\u2082) f616efdca9a24548bc0b1fcc9b389927--0c245e067f364b349d7237ab0b54cbcd de40a9e0fd4c43edafe21e1981583346 RY(p2\u2081\u2086) 0c245e067f364b349d7237ab0b54cbcd--de40a9e0fd4c43edafe21e1981583346 7f0f676ab1e24ff8a1dd1a983ab57f14 RX(p2\u2082\u2080) de40a9e0fd4c43edafe21e1981583346--7f0f676ab1e24ff8a1dd1a983ab57f14 8db0461187524be9ba5edbcdc924141e 7f0f676ab1e24ff8a1dd1a983ab57f14--8db0461187524be9ba5edbcdc924141e dae82a70e50d4a5b9de30e452d5b8165 8db0461187524be9ba5edbcdc924141e--dae82a70e50d4a5b9de30e452d5b8165 78d184e4e77545ac9b50116d8da8b6b8 dae82a70e50d4a5b9de30e452d5b8165--78d184e4e77545ac9b50116d8da8b6b8 dad1326bb9d34368aed5c6e2d72c942a 16e5d9b9fce24cfe9d5a430761f5a366 RX(p1\u2081) 32b05dfd07eb4856a54a9d84739408de--16e5d9b9fce24cfe9d5a430761f5a366 65729cca1b894c7bb8d5d8301185bbf3 2 c4a9f3bd889e40c586e79c97f3efb485 RY(p1\u2085) 16e5d9b9fce24cfe9d5a430761f5a366--c4a9f3bd889e40c586e79c97f3efb485 1b9b9626d0b641eb876e3232f662068d RX(p1\u2089) c4a9f3bd889e40c586e79c97f3efb485--1b9b9626d0b641eb876e3232f662068d 8cb0a56304e341e483366f8383b86061 X 1b9b9626d0b641eb876e3232f662068d--8cb0a56304e341e483366f8383b86061 8cb0a56304e341e483366f8383b86061--a73a7fd1bb0c47a5b4ca739f65ceb6d0 12da4fbf66164a7daf0353edf799e49e 8cb0a56304e341e483366f8383b86061--12da4fbf66164a7daf0353edf799e49e bb43a468b2b941b8abc962024ef3130d RX(p1\u2081\u2083) 12da4fbf66164a7daf0353edf799e49e--bb43a468b2b941b8abc962024ef3130d 330b24bf1eff4756b192929e48324f64 RY(p1\u2081\u2087) bb43a468b2b941b8abc962024ef3130d--330b24bf1eff4756b192929e48324f64 651ef5d5f3f644c1a7e2b0adc171c6de RX(p1\u2082\u2081) 330b24bf1eff4756b192929e48324f64--651ef5d5f3f644c1a7e2b0adc171c6de ea2feb04fb704936ab6c06e763f93107 X 651ef5d5f3f644c1a7e2b0adc171c6de--ea2feb04fb704936ab6c06e763f93107 ea2feb04fb704936ab6c06e763f93107--2c0d89e653704b5090fc86cf0c7dd30a 66d49b58dbe94f8093254acc28a6af1a ea2feb04fb704936ab6c06e763f93107--66d49b58dbe94f8093254acc28a6af1a ad7e1523f0bf42608c310ee909dbea25 RX(p2\u2081) 66d49b58dbe94f8093254acc28a6af1a--ad7e1523f0bf42608c310ee909dbea25 d6585a4c9a3e446da199bf552c9a7cef RY(p2\u2085) ad7e1523f0bf42608c310ee909dbea25--d6585a4c9a3e446da199bf552c9a7cef ccb9fb05738444dfa6865bb760090b8d RX(p2\u2089) d6585a4c9a3e446da199bf552c9a7cef--ccb9fb05738444dfa6865bb760090b8d ff2c492b0629409b888d59979944ef3a X ccb9fb05738444dfa6865bb760090b8d--ff2c492b0629409b888d59979944ef3a ff2c492b0629409b888d59979944ef3a--be3a824e0e23444a902946f60acecdcc 11e7eb7ce05745eab2d27026dcfbb5dc ff2c492b0629409b888d59979944ef3a--11e7eb7ce05745eab2d27026dcfbb5dc 06dacc034ff7488b9d29c66c89fad6b7 RX(p2\u2081\u2083) 11e7eb7ce05745eab2d27026dcfbb5dc--06dacc034ff7488b9d29c66c89fad6b7 d409cdf1349a411da921ed8c7b7757f6 RY(p2\u2081\u2087) 06dacc034ff7488b9d29c66c89fad6b7--d409cdf1349a411da921ed8c7b7757f6 ff39600b18b640cc93288eefc861a17f RX(p2\u2082\u2081) d409cdf1349a411da921ed8c7b7757f6--ff39600b18b640cc93288eefc861a17f 3803ebec343c484fab3728171e8b355b X ff39600b18b640cc93288eefc861a17f--3803ebec343c484fab3728171e8b355b 3803ebec343c484fab3728171e8b355b--8db0461187524be9ba5edbcdc924141e 5818d9f7e1164e60bb87bb898fc30e59 3803ebec343c484fab3728171e8b355b--5818d9f7e1164e60bb87bb898fc30e59 5818d9f7e1164e60bb87bb898fc30e59--dad1326bb9d34368aed5c6e2d72c942a 6928dbd111dc4b128b58ced0a33a18a5 03c226385670410faf76be7d9feedb16 RX(p1\u2082) 65729cca1b894c7bb8d5d8301185bbf3--03c226385670410faf76be7d9feedb16 92b6feb5cdb54ad99cd05cfb6e456c21 3 a575decbcb314eb0af1032fad5ca0d46 RY(p1\u2086) 03c226385670410faf76be7d9feedb16--a575decbcb314eb0af1032fad5ca0d46 1752b912b4bd4ee3ba0b9f0a72484bb7 RX(p1\u2081\u2080) a575decbcb314eb0af1032fad5ca0d46--1752b912b4bd4ee3ba0b9f0a72484bb7 7de02805dc494511be3855db12afe661 1752b912b4bd4ee3ba0b9f0a72484bb7--7de02805dc494511be3855db12afe661 1dd3c6c3e27848068f8c14511dc16693 X 7de02805dc494511be3855db12afe661--1dd3c6c3e27848068f8c14511dc16693 1dd3c6c3e27848068f8c14511dc16693--12da4fbf66164a7daf0353edf799e49e db44313b97c640caa68213f4bfebc72b RX(p1\u2081\u2084) 1dd3c6c3e27848068f8c14511dc16693--db44313b97c640caa68213f4bfebc72b 877f92bfbd604c7682ee88036a910e48 RY(p1\u2081\u2088) db44313b97c640caa68213f4bfebc72b--877f92bfbd604c7682ee88036a910e48 d86c9d5933974f7092792b2e4fe6d6af RX(p1\u2082\u2082) 877f92bfbd604c7682ee88036a910e48--d86c9d5933974f7092792b2e4fe6d6af 32fe0215636a47d18559bf38db38480b d86c9d5933974f7092792b2e4fe6d6af--32fe0215636a47d18559bf38db38480b 85305cdde89d49948570ebe8af85f2e3 X 32fe0215636a47d18559bf38db38480b--85305cdde89d49948570ebe8af85f2e3 85305cdde89d49948570ebe8af85f2e3--66d49b58dbe94f8093254acc28a6af1a 4ec6878357fb41eba5252cabf7b87bfa RX(p2\u2082) 85305cdde89d49948570ebe8af85f2e3--4ec6878357fb41eba5252cabf7b87bfa 91f6ee77142d4a0893ee3cb599e4f406 RY(p2\u2086) 4ec6878357fb41eba5252cabf7b87bfa--91f6ee77142d4a0893ee3cb599e4f406 e704f7d51f6544d582e347653138f643 RX(p2\u2081\u2080) 91f6ee77142d4a0893ee3cb599e4f406--e704f7d51f6544d582e347653138f643 fe93ab4777b14802a358d968443d725e e704f7d51f6544d582e347653138f643--fe93ab4777b14802a358d968443d725e 50c575af2cae430ba65b03f6b011af6b X fe93ab4777b14802a358d968443d725e--50c575af2cae430ba65b03f6b011af6b 50c575af2cae430ba65b03f6b011af6b--11e7eb7ce05745eab2d27026dcfbb5dc 2098c58033d44d6db57c9c3c87b61dc3 RX(p2\u2081\u2084) 50c575af2cae430ba65b03f6b011af6b--2098c58033d44d6db57c9c3c87b61dc3 5c1e4b48ce124d279fb1473cb88bba61 RY(p2\u2081\u2088) 2098c58033d44d6db57c9c3c87b61dc3--5c1e4b48ce124d279fb1473cb88bba61 1bcabce3da65429a9985b11c0532324c RX(p2\u2082\u2082) 5c1e4b48ce124d279fb1473cb88bba61--1bcabce3da65429a9985b11c0532324c 6ac750e784b34903889880a920bbc8a4 1bcabce3da65429a9985b11c0532324c--6ac750e784b34903889880a920bbc8a4 972f41e353a747b2a0b4e01f3e09631e X 6ac750e784b34903889880a920bbc8a4--972f41e353a747b2a0b4e01f3e09631e 972f41e353a747b2a0b4e01f3e09631e--5818d9f7e1164e60bb87bb898fc30e59 972f41e353a747b2a0b4e01f3e09631e--6928dbd111dc4b128b58ced0a33a18a5 25a62ddf00e0433ea5f8676f8808a4b4 53053510554e45bb8f3812011426b8a6 RX(p1\u2083) 92b6feb5cdb54ad99cd05cfb6e456c21--53053510554e45bb8f3812011426b8a6 b2707e1f668a4cf09483377c06cc7446 RY(p1\u2087) 53053510554e45bb8f3812011426b8a6--b2707e1f668a4cf09483377c06cc7446 a8788bc80e984573a6f4b7a490ca8201 RX(p1\u2081\u2081) b2707e1f668a4cf09483377c06cc7446--a8788bc80e984573a6f4b7a490ca8201 54b616c3a9c146b39d3d1460ad0951bd X a8788bc80e984573a6f4b7a490ca8201--54b616c3a9c146b39d3d1460ad0951bd 54b616c3a9c146b39d3d1460ad0951bd--7de02805dc494511be3855db12afe661 29163736ecd142f19e6446acf8273c14 54b616c3a9c146b39d3d1460ad0951bd--29163736ecd142f19e6446acf8273c14 606ee81b30e945d3b13fc86e0abea0a9 RX(p1\u2081\u2085) 29163736ecd142f19e6446acf8273c14--606ee81b30e945d3b13fc86e0abea0a9 8602bd745e89401ca1aa4d7ba62923f6 RY(p1\u2081\u2089) 606ee81b30e945d3b13fc86e0abea0a9--8602bd745e89401ca1aa4d7ba62923f6 07f99fbf6f124ac8bd8b42c4f84c0f5e RX(p1\u2082\u2083) 8602bd745e89401ca1aa4d7ba62923f6--07f99fbf6f124ac8bd8b42c4f84c0f5e a7d8948050454ff7a56d908a74974824 X 07f99fbf6f124ac8bd8b42c4f84c0f5e--a7d8948050454ff7a56d908a74974824 a7d8948050454ff7a56d908a74974824--32fe0215636a47d18559bf38db38480b d8bcc79825c04efa88282f8348eb0e50 a7d8948050454ff7a56d908a74974824--d8bcc79825c04efa88282f8348eb0e50 853ba29b2ea74ad3b6422b948e48ac74 RX(p2\u2083) d8bcc79825c04efa88282f8348eb0e50--853ba29b2ea74ad3b6422b948e48ac74 c5ace3c659bf4f2aa1f851b01ad6a21e RY(p2\u2087) 853ba29b2ea74ad3b6422b948e48ac74--c5ace3c659bf4f2aa1f851b01ad6a21e 39f3ad907f904644ae7e3d2d36254572 RX(p2\u2081\u2081) c5ace3c659bf4f2aa1f851b01ad6a21e--39f3ad907f904644ae7e3d2d36254572 359509964f444ec89f70b29bd3525a42 X 39f3ad907f904644ae7e3d2d36254572--359509964f444ec89f70b29bd3525a42 359509964f444ec89f70b29bd3525a42--fe93ab4777b14802a358d968443d725e 71ccb02778a74396b62dd589efa12429 359509964f444ec89f70b29bd3525a42--71ccb02778a74396b62dd589efa12429 d25baf1d81854d5f9c9269df94c0fbde RX(p2\u2081\u2085) 71ccb02778a74396b62dd589efa12429--d25baf1d81854d5f9c9269df94c0fbde c76539bd1f384d43912538bbac54cb69 RY(p2\u2081\u2089) d25baf1d81854d5f9c9269df94c0fbde--c76539bd1f384d43912538bbac54cb69 9a2b622cf2d94af4a4cb80dd067c070e RX(p2\u2082\u2083) c76539bd1f384d43912538bbac54cb69--9a2b622cf2d94af4a4cb80dd067c070e 60f8f2feb5174757b8cdd63ccd1d4cb0 X 9a2b622cf2d94af4a4cb80dd067c070e--60f8f2feb5174757b8cdd63ccd1d4cb0 60f8f2feb5174757b8cdd63ccd1d4cb0--6ac750e784b34903889880a920bbc8a4 b8a7c0a1590647e5bc8417a0a28778d5 60f8f2feb5174757b8cdd63ccd1d4cb0--b8a7c0a1590647e5bc8417a0a28778d5 b8a7c0a1590647e5bc8417a0a28778d5--25a62ddf00e0433ea5f8676f8808a4b4 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.4060])), ('theta_0', tensor([0.7295])), ('theta_1', tensor([0.4842])), ('theta_10', tensor([0.2934])), ('theta_11', tensor([0.9087])), ('theta_12', tensor([0.5591])), ('theta_13', tensor([0.2918])), ('theta_14', tensor([0.6196])), ('theta_15', tensor([0.0873])), ('theta_16', tensor([0.7099])), ('theta_17', tensor([0.5362])), ('theta_18', tensor([0.3060])), ('theta_19', tensor([0.0122])), ('theta_2', tensor([0.4173])), ('theta_20', tensor([0.5521])), ('theta_21', tensor([0.0399])), ('theta_22', tensor([0.4448])), ('theta_23', tensor([0.8476])), ('theta_3', tensor([0.6639])), ('theta_4', tensor([0.6974])), ('theta_5', tensor([0.1438])), ('theta_6', tensor([0.6251])), ('theta_7', tensor([0.3880])), ('theta_8', tensor([0.2627])), ('theta_9', tensor([0.4693]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.4050])), ('theta_0', tensor([0.7285])), ('theta_1', tensor([0.4832])), ('theta_10', tensor([0.2944])), ('theta_11', tensor([0.9097])), ('theta_12', tensor([0.5601])), ('theta_13', tensor([0.2908])), ('theta_14', tensor([0.6186])), ('theta_15', tensor([0.0883])), ('theta_16', tensor([0.7109])), ('theta_17', tensor([0.5372])), ('theta_18', tensor([0.3070])), ('theta_19', tensor([0.0112])), ('theta_2', tensor([0.4183])), ('theta_20', tensor([0.5531])), ('theta_21', tensor([0.0389])), ('theta_22', tensor([0.4438])), ('theta_23', tensor([0.8486])), ('theta_3', tensor([0.6649])), ('theta_4', tensor([0.6984])), ('theta_5', tensor([0.1448])), ('theta_6', tensor([0.6261])), ('theta_7', tensor([0.3870])), ('theta_8', tensor([0.2617])), ('theta_9', tensor([0.4683]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9842+0.0000j,  0.0000-0.1246j,  0.0000-0.1246j, -0.0158+0.0000j],\n        [ 0.7807+0.0000j,  0.0000-0.4137j,  0.0000-0.4137j, -0.2193+0.0000j],\n        [ 0.8637+0.0000j,  0.0000-0.3431j,  0.0000-0.3431j, -0.1363+0.0000j]])\nxs = [Counter({'00': 99, '01': 1}), Counter({'00': 63, '10': 19, '01': 15, '11': 3}), Counter({'00': 73, '01': 16, '10': 9, '11': 2})]\nex = tensor([[0.9684],\n        [0.5615],\n        [0.7273]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9684, 0.9684],\n        [0.5615, 0.5615],\n        [0.7273, 0.7273]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2024-02-06T10:22:48.007733 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register, PI\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*PI, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2024-02-06T10:22:48.371753 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 56, '10': 44})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample, PI\n\n# RX(PI/4) on qubit 1\nn_qubits = 2\nop = RX(1, PI/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 79, '01': 21})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [0.89529433+0.33257402j 0.10320625-0.27783278j 0.        +0.j\n 0.        +0.j        ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_c6e3d92a428c4d56b6481f1926fc0dec Circuit block cluster_f37fe3e7a62d4269a2bafb39e3b67b72 Prep block 3ba56a1b3b294fcc89834314ad1068d7 0 eaa8c1006bd44622b3e2dcccbe2ebbb7 3ba56a1b3b294fcc89834314ad1068d7--eaa8c1006bd44622b3e2dcccbe2ebbb7 bbab1633be104ecba0db3b14c334999d 1 4ea81152a7e3479eb2b56f5b9ec87a35 RX(theta\u2080) eaa8c1006bd44622b3e2dcccbe2ebbb7--4ea81152a7e3479eb2b56f5b9ec87a35 e196f9d88c3f46a4ba80ed4878ed05bd RY(theta\u2084) 4ea81152a7e3479eb2b56f5b9ec87a35--e196f9d88c3f46a4ba80ed4878ed05bd 57390375b81b4d43a5788590be49edf2 RX(theta\u2088) e196f9d88c3f46a4ba80ed4878ed05bd--57390375b81b4d43a5788590be49edf2 8401ac79550b45e9bcc8ecb50fcd440b 57390375b81b4d43a5788590be49edf2--8401ac79550b45e9bcc8ecb50fcd440b c229a8c831b043c5b4ffd74e56c25bfb 8401ac79550b45e9bcc8ecb50fcd440b--c229a8c831b043c5b4ffd74e56c25bfb 4f103a809d004984a8c8ae271d21efe6 RX(theta\u2081\u2082) c229a8c831b043c5b4ffd74e56c25bfb--4f103a809d004984a8c8ae271d21efe6 3dea88a50caf48beacb6de940b95f6ea RY(theta\u2081\u2086) 4f103a809d004984a8c8ae271d21efe6--3dea88a50caf48beacb6de940b95f6ea 2e57c68de40246759a49401973ee39ae RX(theta\u2082\u2080) 3dea88a50caf48beacb6de940b95f6ea--2e57c68de40246759a49401973ee39ae 4ef6fdda9bec4305811e94eedcf1db82 2e57c68de40246759a49401973ee39ae--4ef6fdda9bec4305811e94eedcf1db82 5ac0a13558f64e9dad8358e4019cb5e9 4ef6fdda9bec4305811e94eedcf1db82--5ac0a13558f64e9dad8358e4019cb5e9 1bdf2c04e5704802be801facead05510 5ac0a13558f64e9dad8358e4019cb5e9--1bdf2c04e5704802be801facead05510 261b6373776c46a2884d481df5ef664a 0f2a64550608432b9e05d0da929941bd bbab1633be104ecba0db3b14c334999d--0f2a64550608432b9e05d0da929941bd a7fd7bfba5a643b7820d35bc345013cd 2 07fbe7fbbaf540638cb82f091cb16ebd RX(theta\u2081) 0f2a64550608432b9e05d0da929941bd--07fbe7fbbaf540638cb82f091cb16ebd 1ad9c0fa876340a59cfcd571e0560359 RY(theta\u2085) 07fbe7fbbaf540638cb82f091cb16ebd--1ad9c0fa876340a59cfcd571e0560359 fc0094f8709d4dbfb9b0f538449c6d22 RX(theta\u2089) 1ad9c0fa876340a59cfcd571e0560359--fc0094f8709d4dbfb9b0f538449c6d22 c221dccb773a4afaaabbe613c126305e X fc0094f8709d4dbfb9b0f538449c6d22--c221dccb773a4afaaabbe613c126305e c221dccb773a4afaaabbe613c126305e--8401ac79550b45e9bcc8ecb50fcd440b 3e2b7fe4d486438baa79b733d5d226a3 c221dccb773a4afaaabbe613c126305e--3e2b7fe4d486438baa79b733d5d226a3 85b073a8df784cffb0d35eb2e13a6cb1 RX(theta\u2081\u2083) 3e2b7fe4d486438baa79b733d5d226a3--85b073a8df784cffb0d35eb2e13a6cb1 35cd634b77c441828048768a72c8f3e6 RY(theta\u2081\u2087) 85b073a8df784cffb0d35eb2e13a6cb1--35cd634b77c441828048768a72c8f3e6 6e035472dfad4f84a5dda612c71fa5d0 RX(theta\u2082\u2081) 35cd634b77c441828048768a72c8f3e6--6e035472dfad4f84a5dda612c71fa5d0 8fe20ddd22eb40bdba4721a96195a0bc X 6e035472dfad4f84a5dda612c71fa5d0--8fe20ddd22eb40bdba4721a96195a0bc 8fe20ddd22eb40bdba4721a96195a0bc--4ef6fdda9bec4305811e94eedcf1db82 54ace213bed74eaf9fc26c45452a3cf0 8fe20ddd22eb40bdba4721a96195a0bc--54ace213bed74eaf9fc26c45452a3cf0 54ace213bed74eaf9fc26c45452a3cf0--261b6373776c46a2884d481df5ef664a cf76aa06b6c44dbaa6e12e0dfcfbf188 63d9cc8f71e94af08c19f4132f587955 a7fd7bfba5a643b7820d35bc345013cd--63d9cc8f71e94af08c19f4132f587955 5a408b691bcd4af1830850629a7edfba 3 2a36b9ca00d8439e893bd263e0b598e7 RX(theta\u2082) 63d9cc8f71e94af08c19f4132f587955--2a36b9ca00d8439e893bd263e0b598e7 183febb7cc434a4fbcfc8b4433a5d81b RY(theta\u2086) 2a36b9ca00d8439e893bd263e0b598e7--183febb7cc434a4fbcfc8b4433a5d81b b71e451c09504b3ea226b8792d50ba2c RX(theta\u2081\u2080) 183febb7cc434a4fbcfc8b4433a5d81b--b71e451c09504b3ea226b8792d50ba2c 18ff83dc2fad41cf886470277a32461a b71e451c09504b3ea226b8792d50ba2c--18ff83dc2fad41cf886470277a32461a bbb41dd3276248eda2d1059aebd02395 X 18ff83dc2fad41cf886470277a32461a--bbb41dd3276248eda2d1059aebd02395 bbb41dd3276248eda2d1059aebd02395--3e2b7fe4d486438baa79b733d5d226a3 1fa55d3af5b64d0eb96f3d181e325515 RX(theta\u2081\u2084) bbb41dd3276248eda2d1059aebd02395--1fa55d3af5b64d0eb96f3d181e325515 b3c08827b18848d5a959f8f00a91f1fc RY(theta\u2081\u2088) 1fa55d3af5b64d0eb96f3d181e325515--b3c08827b18848d5a959f8f00a91f1fc 9b876644176b4fe590012c200b8b4ff8 RX(theta\u2082\u2082) b3c08827b18848d5a959f8f00a91f1fc--9b876644176b4fe590012c200b8b4ff8 6a6e014fed964e0d85d5d16ca631309b 9b876644176b4fe590012c200b8b4ff8--6a6e014fed964e0d85d5d16ca631309b 73453fcf3d98488ba0cc4cfccd16c66a X 6a6e014fed964e0d85d5d16ca631309b--73453fcf3d98488ba0cc4cfccd16c66a 73453fcf3d98488ba0cc4cfccd16c66a--54ace213bed74eaf9fc26c45452a3cf0 73453fcf3d98488ba0cc4cfccd16c66a--cf76aa06b6c44dbaa6e12e0dfcfbf188 526c12ae59444b0aaafc2efa8e536a8a 5522c16a739242a7a6594ae9493c2a25 X 5a408b691bcd4af1830850629a7edfba--5522c16a739242a7a6594ae9493c2a25 f1ff059629ce4f8cb921af7c3f747fab RX(theta\u2083) 5522c16a739242a7a6594ae9493c2a25--f1ff059629ce4f8cb921af7c3f747fab be8074aa56174efc92adc934dc638625 RY(theta\u2087) f1ff059629ce4f8cb921af7c3f747fab--be8074aa56174efc92adc934dc638625 d237be3dde094f278414953667cfbbc6 RX(theta\u2081\u2081) be8074aa56174efc92adc934dc638625--d237be3dde094f278414953667cfbbc6 14ac4c22757e4b78b7204b471cdcffbe X d237be3dde094f278414953667cfbbc6--14ac4c22757e4b78b7204b471cdcffbe 14ac4c22757e4b78b7204b471cdcffbe--18ff83dc2fad41cf886470277a32461a bde2eb7e3cff47239e8835cb9e3d0bd8 14ac4c22757e4b78b7204b471cdcffbe--bde2eb7e3cff47239e8835cb9e3d0bd8 a759e6d806954247a3d28f81df203599 RX(theta\u2081\u2085) bde2eb7e3cff47239e8835cb9e3d0bd8--a759e6d806954247a3d28f81df203599 86337e3702c64a979c31762d695e0a8e RY(theta\u2081\u2089) a759e6d806954247a3d28f81df203599--86337e3702c64a979c31762d695e0a8e c17ecece75a24510a47e853f8ae0105e RX(theta\u2082\u2083) 86337e3702c64a979c31762d695e0a8e--c17ecece75a24510a47e853f8ae0105e 42e4874bd64c41c7a8c71bc084a72e71 X c17ecece75a24510a47e853f8ae0105e--42e4874bd64c41c7a8c71bc084a72e71 42e4874bd64c41c7a8c71bc084a72e71--6a6e014fed964e0d85d5d16ca631309b f5661f5ae8984ef99d5ceee8f367908d 42e4874bd64c41c7a8c71bc084a72e71--f5661f5ae8984ef99d5ceee8f367908d f5661f5ae8984ef99d5ceee8f367908d--526c12ae59444b0aaafc2efa8e536a8a  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[-0.1413-0.0314j,  0.4271+0.0558j,  0.1211-0.0650j, -0.2887-0.3458j,\n          0.1520-0.5908j, -0.2196-0.1824j,  0.0992-0.2272j,  0.2243+0.0795j],\n        [ 0.3506+0.1673j,  0.0850-0.2147j, -0.0631+0.6737j,  0.0306+0.2123j,\n          0.3492+0.2833j,  0.0531-0.1610j,  0.1590-0.0134j,  0.1670+0.0875j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}