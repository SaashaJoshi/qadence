{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from torch import pi\nfrom qadence import X, Y, HamEvo, Register, product_state, sample, add\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = pi/(2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from torch import pi\nfrom qadence import Register, AnalogRX, sample\n\n# Global analog RX block.\nblock = AnalogRX(pi)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(pi))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'00': 36, '01': 32, '10': 32})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@misc{qadence2023pasqal,\n  url = {https://github.com/pasqal-io/qadence},\n  title = {Qadence: {A} {D}igital-analog quantum programming interface.},\n  year = {2023}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available with PyQTorch backend</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> backend is selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the GPSR differentiation engine can be selected by passing <code>diff_mode=\"gpsr\"</code> or, equivalently, <code>diff_mode=DiffMode.GPSR</code> to a <code>QuantumModel</code> instance. The code in the box below shows how to create <code>QuantumModel</code> instances with both AD and GPSR engines.</p> <pre><code>from qadence import (FeatureParameter, HamEvo, X, I, Z,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# define differentiation parameter\nx = FeatureParameter(\"x\")\n\n# define generator and HamEvo block\ngenerator = X(0) + X(1) + 0.2 * (Z(0) + I(1)) * (I(0) + Z(1))\nblock = HamEvo(generator, x)\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# generate value for circuit's parameter\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2023-12-12T14:24:11.311254 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> </ol>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, WaitBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self._hamiltonian = lambda x: hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 e6d40a3026404d4295380fd2f295fdfb 0 05234c35a4664b6591303fdff859406e X e6d40a3026404d4295380fd2f295fdfb--05234c35a4664b6591303fdff859406e cfc7aea46a2645d6bd95953ff5327916 1 975b4f40af51479fa98246d73fa25259 05234c35a4664b6591303fdff859406e--975b4f40af51479fa98246d73fa25259 482a3834c06f45faba41045b8f50cb6c 074ac93a596746029581509a7979f940 Y cfc7aea46a2645d6bd95953ff5327916--074ac93a596746029581509a7979f940 074ac93a596746029581509a7979f940--482a3834c06f45faba41045b8f50cb6c <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 425155f2f19447dcb3b74015303c7c0a 0 9ee56c35c8084a7a81d5b2f8a600db9a X 425155f2f19447dcb3b74015303c7c0a--9ee56c35c8084a7a81d5b2f8a600db9a db79cc553d7746f39e7d76a6b0810597 Y 9ee56c35c8084a7a81d5b2f8a600db9a--db79cc553d7746f39e7d76a6b0810597 7370f7fd71844d55a15fb359dd874e72 db79cc553d7746f39e7d76a6b0810597--7370f7fd71844d55a15fb359dd874e72 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 e5b119bb368c4c1691fad98d9323c6f4 0 fb4ad30a0dba4420870aec72f564d9d1 X e5b119bb368c4c1691fad98d9323c6f4--fb4ad30a0dba4420870aec72f564d9d1 d9510ebf6d7f456ea56dcdfe98b37a0e 1 ffac6ec75afc42e59574f5ed0b57c1a0 fb4ad30a0dba4420870aec72f564d9d1--ffac6ec75afc42e59574f5ed0b57c1a0 0d98d85426ed421c9f36fd07ab1a60de ffac6ec75afc42e59574f5ed0b57c1a0--0d98d85426ed421c9f36fd07ab1a60de 18464b2938df4ea3aa30e127e7ee6666 8cd43809c48042999d2bf2ffa61ac3b2 d9510ebf6d7f456ea56dcdfe98b37a0e--8cd43809c48042999d2bf2ffa61ac3b2 b710a8cdfdad4bddac08e4e09dd979da Y 8cd43809c48042999d2bf2ffa61ac3b2--b710a8cdfdad4bddac08e4e09dd979da b710a8cdfdad4bddac08e4e09dd979da--18464b2938df4ea3aa30e127e7ee6666 <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_9fa0cbc2994945b786ac6774db8dc838 e2dfe2c0910b46fc8d41e99860a2607b 0 a948e6125c994234bbc3aed2147308a1 e2dfe2c0910b46fc8d41e99860a2607b--a948e6125c994234bbc3aed2147308a1 30ba00e8b692461aa3b0a2e0577b98bb 1 f55e59cf547646f78230316b91dc3f9f a948e6125c994234bbc3aed2147308a1--f55e59cf547646f78230316b91dc3f9f 18371e1e7aec4a2e979eb31c0a5ab01e fe747e3bff9149b28216774aaa1411bf AddBlock 30ba00e8b692461aa3b0a2e0577b98bb--fe747e3bff9149b28216774aaa1411bf d621947fe40841f5a4e0e46d07dae5bb 2 fe747e3bff9149b28216774aaa1411bf--18371e1e7aec4a2e979eb31c0a5ab01e 4237ddd22058482c8e7a07d044440047 0c1561a69c0e471e9c3b035cd35bb4c3 d621947fe40841f5a4e0e46d07dae5bb--0c1561a69c0e471e9c3b035cd35bb4c3 0c1561a69c0e471e9c3b035cd35bb4c3--4237ddd22058482c8e7a07d044440047 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_6ee223de4ed141a5abfa528f8bc602d3 cluster_95f26a76bb6a4501b08272e9b3f20fd1 rx b6fee3a32c204bf591cced3752d46b83 0 2beedcc3143a4c3facd41070ded79324 X b6fee3a32c204bf591cced3752d46b83--2beedcc3143a4c3facd41070ded79324 7c81cbabe87246f19bbbd3d5bf473aa6 1 383d914313b34636be1695fa1bcc3d5a 2beedcc3143a4c3facd41070ded79324--383d914313b34636be1695fa1bcc3d5a 1a63c7f7c6a7425f878c0434cf5027a8 383d914313b34636be1695fa1bcc3d5a--1a63c7f7c6a7425f878c0434cf5027a8 a5fe5bf51f9b4b19b5f6cbd2961348a6 1a63c7f7c6a7425f878c0434cf5027a8--a5fe5bf51f9b4b19b5f6cbd2961348a6 b9c572492b8a45a4b07d1cb8314f4928 629052a78cfa4e58a5b4276a5a3a41ce Y 7c81cbabe87246f19bbbd3d5bf473aa6--629052a78cfa4e58a5b4276a5a3a41ce 73a08a2cfc534883925015ac0c70d784 2 8278f168948544bfa3cdf5ae94a82e10 629052a78cfa4e58a5b4276a5a3a41ce--8278f168948544bfa3cdf5ae94a82e10 03ceef123a2045e7a34cdbc699fe12ea HamEvo 8278f168948544bfa3cdf5ae94a82e10--03ceef123a2045e7a34cdbc699fe12ea 03ceef123a2045e7a34cdbc699fe12ea--b9c572492b8a45a4b07d1cb8314f4928 0c935486b42c4614a15c96ac3c32d588 7caccbf0b3d54c0bb417a9dd33772a60 RX(x) 73a08a2cfc534883925015ac0c70d784--7caccbf0b3d54c0bb417a9dd33772a60 2956c04d00e740c7bf7a4df66c65e028 3 ad51a170724940cd830e99b4234f6787 7caccbf0b3d54c0bb417a9dd33772a60--ad51a170724940cd830e99b4234f6787 76b538bc45684976bd52151058842999 t = 10 ad51a170724940cd830e99b4234f6787--76b538bc45684976bd52151058842999 76b538bc45684976bd52151058842999--0c935486b42c4614a15c96ac3c32d588 fd296df0527e42e380d5d66064f5075a 69229d44e2184834ad50d665c42b661e RX(0.5) 2956c04d00e740c7bf7a4df66c65e028--69229d44e2184834ad50d665c42b661e 012c21c236954369be85354f2c28ee61 X 69229d44e2184834ad50d665c42b661e--012c21c236954369be85354f2c28ee61 012c21c236954369be85354f2c28ee61--ad51a170724940cd830e99b4234f6787 a7d3e46c1bcb47fba9716a7da5cf6ec7 012c21c236954369be85354f2c28ee61--a7d3e46c1bcb47fba9716a7da5cf6ec7 a7d3e46c1bcb47fba9716a7da5cf6ec7--fd296df0527e42e380d5d66064f5075a <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_c2914d9af53f44d39be2a4ea1de94ced HEA cluster_6178bc5296634925990e8ce2e4cd9b8e Tower Fourier FM b2c2a2e0fedf485d8dc3e297e960319e 0 2ef756c8b71e4455ab610cccb0e7c024 RX(1.0*phi) b2c2a2e0fedf485d8dc3e297e960319e--2ef756c8b71e4455ab610cccb0e7c024 388e62b4ce9f4133940aab37fccac26f 1 458aa578fdb44d8dad4624e662c0441a RX(theta\u2080) 2ef756c8b71e4455ab610cccb0e7c024--458aa578fdb44d8dad4624e662c0441a 4fe418525e3948da95b4c31834c089f1 RY(theta\u2084) 458aa578fdb44d8dad4624e662c0441a--4fe418525e3948da95b4c31834c089f1 d109e01ab40e46249d59f67ea5164b0f RX(theta\u2088) 4fe418525e3948da95b4c31834c089f1--d109e01ab40e46249d59f67ea5164b0f 5377da87db2a4b41aa56848a98af9fae d109e01ab40e46249d59f67ea5164b0f--5377da87db2a4b41aa56848a98af9fae c2ef26792cb044558055610b12f44bca 5377da87db2a4b41aa56848a98af9fae--c2ef26792cb044558055610b12f44bca 60e0f25b5a8e477ca1fb4a0ac0f82f72 RX(theta\u2081\u2082) c2ef26792cb044558055610b12f44bca--60e0f25b5a8e477ca1fb4a0ac0f82f72 ea938ec1fbe1431a975c2b9c894b913e RY(theta\u2081\u2086) 60e0f25b5a8e477ca1fb4a0ac0f82f72--ea938ec1fbe1431a975c2b9c894b913e e419df563dd7420eb0b3f161c10a2af7 RX(theta\u2082\u2080) ea938ec1fbe1431a975c2b9c894b913e--e419df563dd7420eb0b3f161c10a2af7 b483ea6034ce48d0b836be8906f59deb e419df563dd7420eb0b3f161c10a2af7--b483ea6034ce48d0b836be8906f59deb 555c1a5625004943937424c404f71177 b483ea6034ce48d0b836be8906f59deb--555c1a5625004943937424c404f71177 8851e2e445a9491a875db54798b0a205 555c1a5625004943937424c404f71177--8851e2e445a9491a875db54798b0a205 3782932e17f34f798193e3f7df93746d 33d46b82ea414e05aa1aaf31df38a91e RX(2.0*phi) 388e62b4ce9f4133940aab37fccac26f--33d46b82ea414e05aa1aaf31df38a91e 1f83d5a5351c48ec9afabd1b9ca83ca8 2 0dd311a3ed054078a6745f370e3567bf RX(theta\u2081) 33d46b82ea414e05aa1aaf31df38a91e--0dd311a3ed054078a6745f370e3567bf f8afda0e686a44fbb9b3ff2b8a00efdc RY(theta\u2085) 0dd311a3ed054078a6745f370e3567bf--f8afda0e686a44fbb9b3ff2b8a00efdc 58af76b5482a403c8458242dce7397be RX(theta\u2089) f8afda0e686a44fbb9b3ff2b8a00efdc--58af76b5482a403c8458242dce7397be 07ad9897c1a847d381d7cc7e67c04b71 X 58af76b5482a403c8458242dce7397be--07ad9897c1a847d381d7cc7e67c04b71 07ad9897c1a847d381d7cc7e67c04b71--5377da87db2a4b41aa56848a98af9fae 9895faffb3aa4b2a8e6c7ffa88ff8392 07ad9897c1a847d381d7cc7e67c04b71--9895faffb3aa4b2a8e6c7ffa88ff8392 0b8314d0fbc246478087d56519e1c08b RX(theta\u2081\u2083) 9895faffb3aa4b2a8e6c7ffa88ff8392--0b8314d0fbc246478087d56519e1c08b a3d14caba3024aab896d2a66b99a0ee4 RY(theta\u2081\u2087) 0b8314d0fbc246478087d56519e1c08b--a3d14caba3024aab896d2a66b99a0ee4 4288fff5633a44b2803fafa3a6dde32f RX(theta\u2082\u2081) a3d14caba3024aab896d2a66b99a0ee4--4288fff5633a44b2803fafa3a6dde32f 106b6112191b4e95b9ecb0c941a58f2d X 4288fff5633a44b2803fafa3a6dde32f--106b6112191b4e95b9ecb0c941a58f2d 106b6112191b4e95b9ecb0c941a58f2d--b483ea6034ce48d0b836be8906f59deb efe15a6fcb1e4819ac0b2422e4d3f870 106b6112191b4e95b9ecb0c941a58f2d--efe15a6fcb1e4819ac0b2422e4d3f870 efe15a6fcb1e4819ac0b2422e4d3f870--3782932e17f34f798193e3f7df93746d 735e4fadfef54af08c778d2ce9f31bd9 f4236f1d3a7b4c2e88e8de99f97fe914 RX(3.0*phi) 1f83d5a5351c48ec9afabd1b9ca83ca8--f4236f1d3a7b4c2e88e8de99f97fe914 0d72202f9e41479696a53fea99764fd6 3 12b709cced524e8e842648aced817807 RX(theta\u2082) f4236f1d3a7b4c2e88e8de99f97fe914--12b709cced524e8e842648aced817807 f3ac773d9e8a45dd9a5c3c0e23e927b6 RY(theta\u2086) 12b709cced524e8e842648aced817807--f3ac773d9e8a45dd9a5c3c0e23e927b6 3a796a0fb1714cf092304162c1f758e3 RX(theta\u2081\u2080) f3ac773d9e8a45dd9a5c3c0e23e927b6--3a796a0fb1714cf092304162c1f758e3 c72e38cb9dde4616966e665cd2a1be82 3a796a0fb1714cf092304162c1f758e3--c72e38cb9dde4616966e665cd2a1be82 7948608efde3483ab61fbbb83e461f4f X c72e38cb9dde4616966e665cd2a1be82--7948608efde3483ab61fbbb83e461f4f 7948608efde3483ab61fbbb83e461f4f--9895faffb3aa4b2a8e6c7ffa88ff8392 8d225be714034991a37cc3f0f2ffa66f RX(theta\u2081\u2084) 7948608efde3483ab61fbbb83e461f4f--8d225be714034991a37cc3f0f2ffa66f 6cb8f2132a2a4f2ab2649a4693b47409 RY(theta\u2081\u2088) 8d225be714034991a37cc3f0f2ffa66f--6cb8f2132a2a4f2ab2649a4693b47409 5a9d7da8cd71401e9201b6730fed5c75 RX(theta\u2082\u2082) 6cb8f2132a2a4f2ab2649a4693b47409--5a9d7da8cd71401e9201b6730fed5c75 629bb65d53f8428eba5ddcdc6ef9d2c3 5a9d7da8cd71401e9201b6730fed5c75--629bb65d53f8428eba5ddcdc6ef9d2c3 fa3118beb7d4490180dc7391d7dd304d X 629bb65d53f8428eba5ddcdc6ef9d2c3--fa3118beb7d4490180dc7391d7dd304d fa3118beb7d4490180dc7391d7dd304d--efe15a6fcb1e4819ac0b2422e4d3f870 fa3118beb7d4490180dc7391d7dd304d--735e4fadfef54af08c778d2ce9f31bd9 c770a365ff3f486ba2d36792856d9de5 1163abb52d524d3baca0e079c7ae15fa RX(4.0*phi) 0d72202f9e41479696a53fea99764fd6--1163abb52d524d3baca0e079c7ae15fa b14aaaf7bf074a149f37bb804877deae RX(theta\u2083) 1163abb52d524d3baca0e079c7ae15fa--b14aaaf7bf074a149f37bb804877deae a55a07a09d7142a3af4886dc046e18bc RY(theta\u2087) b14aaaf7bf074a149f37bb804877deae--a55a07a09d7142a3af4886dc046e18bc b4ef16ebcbbd419aaba9460409fcf088 RX(theta\u2081\u2081) a55a07a09d7142a3af4886dc046e18bc--b4ef16ebcbbd419aaba9460409fcf088 a8e5b54b6ca643c8bf753d20fb25ef19 X b4ef16ebcbbd419aaba9460409fcf088--a8e5b54b6ca643c8bf753d20fb25ef19 a8e5b54b6ca643c8bf753d20fb25ef19--c72e38cb9dde4616966e665cd2a1be82 9abad9326db14dd3a1a5a8a15fada04e a8e5b54b6ca643c8bf753d20fb25ef19--9abad9326db14dd3a1a5a8a15fada04e 8fec0dadc52a42a2ae14c535f326cf72 RX(theta\u2081\u2085) 9abad9326db14dd3a1a5a8a15fada04e--8fec0dadc52a42a2ae14c535f326cf72 075f862c33834bbb976883dc084ba379 RY(theta\u2081\u2089) 8fec0dadc52a42a2ae14c535f326cf72--075f862c33834bbb976883dc084ba379 21ada74f3b87466d865993d9d0ca9712 RX(theta\u2082\u2083) 075f862c33834bbb976883dc084ba379--21ada74f3b87466d865993d9d0ca9712 462f98a659904e7a91298941341b986a X 21ada74f3b87466d865993d9d0ca9712--462f98a659904e7a91298941341b986a 462f98a659904e7a91298941341b986a--629bb65d53f8428eba5ddcdc6ef9d2c3 9440249c92044ea0b667229869275215 462f98a659904e7a91298941341b986a--9440249c92044ea0b667229869275215 9440249c92044ea0b667229869275215--c770a365ff3f486ba2d36792856d9de5 <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_ce5370f6c3e141c487172c5454be66fc Obs. cluster_3b5a386594ee42e8840fff19e519826b cluster_37367fcc718d4f50bae916fbd5f5f9bf HEA 69fa5e88f62a4b60a4ef9ce8f67543c0 0 89f94770aae948768705b498afe7ff29 RX(theta\u2080) 69fa5e88f62a4b60a4ef9ce8f67543c0--89f94770aae948768705b498afe7ff29 0c4f8fa692674f41bc9239ce77462d90 1 cfeca51c0f9843dab38c4eec240e3383 RY(theta\u2083) 89f94770aae948768705b498afe7ff29--cfeca51c0f9843dab38c4eec240e3383 709979591a9446829539223db2d87e6d RX(theta\u2086) cfeca51c0f9843dab38c4eec240e3383--709979591a9446829539223db2d87e6d ad50a5514b3648ec875d16682a0738fb 709979591a9446829539223db2d87e6d--ad50a5514b3648ec875d16682a0738fb c4831f7e2d974cdd80307c396766ed7a ad50a5514b3648ec875d16682a0738fb--c4831f7e2d974cdd80307c396766ed7a 81bed86c6f4f433c8b86fca5cfa8e147 RX(theta\u2089) c4831f7e2d974cdd80307c396766ed7a--81bed86c6f4f433c8b86fca5cfa8e147 2d0c8e257e9e433cb6def377183efd59 RY(theta\u2081\u2082) 81bed86c6f4f433c8b86fca5cfa8e147--2d0c8e257e9e433cb6def377183efd59 96067eb196534579b4cbba6d25980873 RX(theta\u2081\u2085) 2d0c8e257e9e433cb6def377183efd59--96067eb196534579b4cbba6d25980873 3012b482f93249c9a407428484743d17 96067eb196534579b4cbba6d25980873--3012b482f93249c9a407428484743d17 b6a393a9444d431c910e1c7edbc36377 3012b482f93249c9a407428484743d17--b6a393a9444d431c910e1c7edbc36377 627c6e924f604b309c20066d694d89cf b6a393a9444d431c910e1c7edbc36377--627c6e924f604b309c20066d694d89cf d85a34347ffc4dbe87da9c15d7452b06 627c6e924f604b309c20066d694d89cf--d85a34347ffc4dbe87da9c15d7452b06 ec573aed98ca4113806794fc8711a916 8e2ab98b713d4ddeabc945acb925b84c RX(theta\u2081) 0c4f8fa692674f41bc9239ce77462d90--8e2ab98b713d4ddeabc945acb925b84c a633131c8f4d4ebc953dd9f9176f674d 2 3b99f228ff3845da86124b79ff82e3a8 RY(theta\u2084) 8e2ab98b713d4ddeabc945acb925b84c--3b99f228ff3845da86124b79ff82e3a8 8b6b58d78ba14f21aa6407536cf118b7 RX(theta\u2087) 3b99f228ff3845da86124b79ff82e3a8--8b6b58d78ba14f21aa6407536cf118b7 e7ea43f231524ee0ac175ae27417db7b X 8b6b58d78ba14f21aa6407536cf118b7--e7ea43f231524ee0ac175ae27417db7b e7ea43f231524ee0ac175ae27417db7b--ad50a5514b3648ec875d16682a0738fb cec4bec0d03b438e82924f0c0e094e66 e7ea43f231524ee0ac175ae27417db7b--cec4bec0d03b438e82924f0c0e094e66 4f6e358f81124ca6918d6e380accafbe RX(theta\u2081\u2080) cec4bec0d03b438e82924f0c0e094e66--4f6e358f81124ca6918d6e380accafbe 88f32a80d6ba40dd9ab50370a5ededee RY(theta\u2081\u2083) 4f6e358f81124ca6918d6e380accafbe--88f32a80d6ba40dd9ab50370a5ededee 866f7d8318264c55b97bde49cf2d347d RX(theta\u2081\u2086) 88f32a80d6ba40dd9ab50370a5ededee--866f7d8318264c55b97bde49cf2d347d e8ef3556ae72452e8500d60430839004 X 866f7d8318264c55b97bde49cf2d347d--e8ef3556ae72452e8500d60430839004 e8ef3556ae72452e8500d60430839004--3012b482f93249c9a407428484743d17 07b4eca7e8224cb6ac94bd3774453630 e8ef3556ae72452e8500d60430839004--07b4eca7e8224cb6ac94bd3774453630 439dc097a52f4046ab407d35bbf9747a AddBlock 07b4eca7e8224cb6ac94bd3774453630--439dc097a52f4046ab407d35bbf9747a 439dc097a52f4046ab407d35bbf9747a--ec573aed98ca4113806794fc8711a916 d6f99cb4e4744089a6687eedfcb5d9fb 891fd14527e24af4bc823e378b1fbc8e RX(theta\u2082) a633131c8f4d4ebc953dd9f9176f674d--891fd14527e24af4bc823e378b1fbc8e aeb5bef205474daea4a13ea81330bb22 RY(theta\u2085) 891fd14527e24af4bc823e378b1fbc8e--aeb5bef205474daea4a13ea81330bb22 d253c3d2813e49df9fcf262f5e4629a8 RX(theta\u2088) aeb5bef205474daea4a13ea81330bb22--d253c3d2813e49df9fcf262f5e4629a8 bd2c098005534d69af44167ffd34343f d253c3d2813e49df9fcf262f5e4629a8--bd2c098005534d69af44167ffd34343f d747ad5e9a33439689b30fed702984bc X bd2c098005534d69af44167ffd34343f--d747ad5e9a33439689b30fed702984bc d747ad5e9a33439689b30fed702984bc--cec4bec0d03b438e82924f0c0e094e66 ca5936fa68ae40fd9c7a5b368da0655c RX(theta\u2081\u2081) d747ad5e9a33439689b30fed702984bc--ca5936fa68ae40fd9c7a5b368da0655c 6ab268667ec5487f83c297788af5c694 RY(theta\u2081\u2084) ca5936fa68ae40fd9c7a5b368da0655c--6ab268667ec5487f83c297788af5c694 1feb39484db746b6b406953106b1554b RX(theta\u2081\u2087) 6ab268667ec5487f83c297788af5c694--1feb39484db746b6b406953106b1554b 30dfb3267c554d1dbd14fd4cb22b5857 1feb39484db746b6b406953106b1554b--30dfb3267c554d1dbd14fd4cb22b5857 ddef5a4796b14ddaa8e4699215125724 X 30dfb3267c554d1dbd14fd4cb22b5857--ddef5a4796b14ddaa8e4699215125724 ddef5a4796b14ddaa8e4699215125724--07b4eca7e8224cb6ac94bd3774453630 044c13aa2ac94a43a72cd8d4613c43db ddef5a4796b14ddaa8e4699215125724--044c13aa2ac94a43a72cd8d4613c43db 044c13aa2ac94a43a72cd8d4613c43db--d6f99cb4e4744089a6687eedfcb5d9fb <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 cb266945888e40e89814e13d29cf1954 0 2a0830b724d64ab6b189bd36cb71fbb6 cb266945888e40e89814e13d29cf1954--2a0830b724d64ab6b189bd36cb71fbb6 8f4e3cd724ad47b9a90d0f3d6ec42fd4 1 64d0713b0ddc4d18aad77688cecbcc3f 9c62f97b9ae747f38dfc2a36cad4b13b 2a0830b724d64ab6b189bd36cb71fbb6--9c62f97b9ae747f38dfc2a36cad4b13b ce69b5789c314f1ba04899a2464737cd 64d0713b0ddc4d18aad77688cecbcc3f--ce69b5789c314f1ba04899a2464737cd c310fb82832a46bdb0b1409de7c4b21e 2aaee117e08a4fa9884c3a8bf99a50f5 ce69b5789c314f1ba04899a2464737cd--2aaee117e08a4fa9884c3a8bf99a50f5 6ce30b714b3f43678fe382ce2c38a71d c310fb82832a46bdb0b1409de7c4b21e--6ce30b714b3f43678fe382ce2c38a71d 5cff159ea9b3431d887d5057604e2417 14fb6690414d43beaf373218b8f99da9 8f4e3cd724ad47b9a90d0f3d6ec42fd4--14fb6690414d43beaf373218b8f99da9 7ff40b466a4a4214824e1e919b585bc0 2 14fb6690414d43beaf373218b8f99da9--64d0713b0ddc4d18aad77688cecbcc3f 0396969e232e426284e2b009acf88c51 9c62f97b9ae747f38dfc2a36cad4b13b--0396969e232e426284e2b009acf88c51 9ab4f98abbee4fc4b7ba60ea5ada3ea9 0396969e232e426284e2b009acf88c51--9ab4f98abbee4fc4b7ba60ea5ada3ea9 9ab4f98abbee4fc4b7ba60ea5ada3ea9--5cff159ea9b3431d887d5057604e2417 ba799220abc3433ea6021f8b0ba73004 390d2324b5164957b3d722e8be264824 7ff40b466a4a4214824e1e919b585bc0--390d2324b5164957b3d722e8be264824 9d12ebc22a45419192a3c14bc0e36202 3 106428dadb16411c89d424e1e474d94f 390d2324b5164957b3d722e8be264824--106428dadb16411c89d424e1e474d94f 8168183ae3864c18b904aac05417b2b1 106428dadb16411c89d424e1e474d94f--8168183ae3864c18b904aac05417b2b1 819958cfe6b3440786c63e26aadf47f8 8168183ae3864c18b904aac05417b2b1--819958cfe6b3440786c63e26aadf47f8 819958cfe6b3440786c63e26aadf47f8--ba799220abc3433ea6021f8b0ba73004 337949b6a9d3489c8f62cec518c9479d db473e14d1214b42b556fcb06432c280 9d12ebc22a45419192a3c14bc0e36202--db473e14d1214b42b556fcb06432c280 eac22a124d5d4a55bd9c03d284403dec db473e14d1214b42b556fcb06432c280--eac22a124d5d4a55bd9c03d284403dec b4e2829e413d4a18b1453a1b533a869d eac22a124d5d4a55bd9c03d284403dec--b4e2829e413d4a18b1453a1b533a869d b4e2829e413d4a18b1453a1b533a869d--c310fb82832a46bdb0b1409de7c4b21e 2aaee117e08a4fa9884c3a8bf99a50f5--337949b6a9d3489c8f62cec518c9479d <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 c9ed1fb306554c398e962dea1d913c6d 0 38b0ec2416ca42d29a36332a47ae418a c9ed1fb306554c398e962dea1d913c6d--38b0ec2416ca42d29a36332a47ae418a 94dcd5313cf14884956765144f347ef1 1 46c269f29eed4e1db0a902e3606b793f 38b0ec2416ca42d29a36332a47ae418a--46c269f29eed4e1db0a902e3606b793f 703f5957890d44a6978c8316c52d90d0 46c269f29eed4e1db0a902e3606b793f--703f5957890d44a6978c8316c52d90d0 691ba7ad6e0a499e8c9387e551175d6f 703f5957890d44a6978c8316c52d90d0--691ba7ad6e0a499e8c9387e551175d6f cff5f819664a46beb1fb63bdf8f1a238 b1a1dddf241f46af9e37757bfa8325ac PHASE(0.5) 94dcd5313cf14884956765144f347ef1--b1a1dddf241f46af9e37757bfa8325ac e54465c53c254573aff12b562d6ba547 2 b1a1dddf241f46af9e37757bfa8325ac--38b0ec2416ca42d29a36332a47ae418a d83f9791920a4e9a8b0a3cfdf575b91c b1a1dddf241f46af9e37757bfa8325ac--d83f9791920a4e9a8b0a3cfdf575b91c 9507734916714217bd107ac74e1453e8 d83f9791920a4e9a8b0a3cfdf575b91c--9507734916714217bd107ac74e1453e8 9507734916714217bd107ac74e1453e8--cff5f819664a46beb1fb63bdf8f1a238 14a9fac5cdd248bfa19854320d6b76b7 658faf84d588420cadedb17c43a07afa e54465c53c254573aff12b562d6ba547--658faf84d588420cadedb17c43a07afa f17fdfd4b8d04fd5a299bd1087eb0aa6 3 e9b4ed01ceef4675b5dfcee61c050082 PHASE(0.5) 658faf84d588420cadedb17c43a07afa--e9b4ed01ceef4675b5dfcee61c050082 e9b4ed01ceef4675b5dfcee61c050082--46c269f29eed4e1db0a902e3606b793f cd5be69409f54cd6b9d4039eb340104b e9b4ed01ceef4675b5dfcee61c050082--cd5be69409f54cd6b9d4039eb340104b cd5be69409f54cd6b9d4039eb340104b--14a9fac5cdd248bfa19854320d6b76b7 7abf396465ef4c9b9cc00374d7a267b6 e129c3bbe382423084649bf06d8bd0ac f17fdfd4b8d04fd5a299bd1087eb0aa6--e129c3bbe382423084649bf06d8bd0ac 9c056be35be54417a96fcb11863c9b94 e129c3bbe382423084649bf06d8bd0ac--9c056be35be54417a96fcb11863c9b94 49f2ffeb23744e6ca962444c102b8183 PHASE(0.5) 9c056be35be54417a96fcb11863c9b94--49f2ffeb23744e6ca962444c102b8183 49f2ffeb23744e6ca962444c102b8183--703f5957890d44a6978c8316c52d90d0 49f2ffeb23744e6ca962444c102b8183--7abf396465ef4c9b9cc00374d7a267b6"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from math import pi\nfrom qadence import AnalogRot\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = pi, # [rad/\u03bcs]\n    delta = pi, # [rad/\u03bcs]\n    phase = pi, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run\nfrom qadence.analog.constants import C6_DICT\nfrom math import pi, cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = pi\ndelta = pi\nphase = pi\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run\nfrom math import pi\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = pi\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>wait</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, wait, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = wait(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction\nfrom math import pi\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * pi * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * pi * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice\nfrom math import pi\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = pi)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all the Analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>wait</code> operation initializes a <code>WaitBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = \"global\"</code>. However, the blocks do support local qubit supports, with some constraints. The main constraint is that using <code>kron</code> on operators with different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, wait\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    wait(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    wait(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    wait(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2023-12-12T14:24:15.010605 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>Warning</p> <p>Tutorial to be updated</p> <p>In this notebook we solve a quadratic unconstrained optimization problem with Qadence emulated analog interface using the QAOA variational algorithm. The problem is detailed in the Pulser documentation here.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: construct QUBO register <p>Before we start we have to define a register that fits into our device. <pre><code>import torch\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\n\nfrom pulser.devices import Chadoq2\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n\n\ndef qubo_register_coords(Q):\n    \"\"\"Compute coordinates for register.\"\"\"\n    bitstrings = [np.binary_repr(i, len(Q)) for i in range(len(Q) ** 2)]\n    costs = []\n    # this takes exponential time with the dimension of the QUBO\n    for b in bitstrings:\n        z = np.array(list(b), dtype=int)\n        cost = z.T @ Q @ z\n        costs.append(cost)\n    zipped = zip(bitstrings, costs)\n    sort_zipped = sorted(zipped, key=lambda x: x[1])\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        new_Q = squareform(Chadoq2.interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    costs = []\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport torch\n\nfrom qadence import chain\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRZ, AnalogRX\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted connections <code>Q</code> and a cost function.</p> <pre><code>def cost_colouring(bitstring, Q):\n    z = np.array(list(bitstring), dtype=int)\n    cost = z.T @ Q @ z\n    return cost\n\n# Cost function.\ndef cost_fn(counter, Q):\n    cost = sum(counter[key] * cost_colouring(key, Q) for key in counter)\n    return cost / sum(counter.values())  # Divide by total samples\n\n\n# Weights.\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n</code></pre> <p>The analog circuit is composed of two global rotations per layer.  The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian in the QAOA algorithm. Subsequently, there is an Ising interaction term to emulate the analog circuit. Please note that the Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in Pulser, and set the device specs with the updated Rydberg level.</p> <pre><code># Register with device specs\ndevice = RydbergDevice(rydberg_level = 70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q),\n    device_specs = device\n)\n\n# Analog circuit\nlayers = 2\n\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\n</code></pre> <pre><code>\n</code></pre> <p>Next, an initial solution is computed by sampling the model:</p> <pre><code>model = QuantumModel(\n    QuantumCircuit(reg, block),\n    backend=\"pyqtorch\", diff_mode='gpsr')\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'00000': 101, '10000': 87, '01000': 75, '00110': 72, '00100': 70, '01010': 64, '01001': 62, '00101': 53, '00010': 51, '00011': 48, '01011': 46, '00001': 45, '10010': 45, '00111': 38, '10001': 34, '11000': 29, '10100': 18, '01100': 14, '01110': 11, '01111': 10, '10110': 7, '11001': 7, '11010': 6, '01101': 4, '10101': 2, '10011': 1})\n</code></pre> <p>Then, the loss function is defined by averaging over the evaluated bitstrings.</p> <pre><code>def loss(param, *args):\n    Q = args[0]\n    param = torch.tensor(param)\n    model.reset_vparams(param)\n    C = model.sample({}, n_shots=1000)[0]\n    return cost_fn(C, Q)\n</code></pre> <p>And a gradient-free optimization loop is used to compute the optimal solution.</p> <pre><code># Optimization loop.\nfor i in range(20):\n    res = minimize(\n        loss,\n        args=Q,\n        x0=np.random.uniform(1, 10, size=2 * layers),\n        method=\"COBYLA\",\n        tol=1e-8,\n        options={\"maxiter\": 20},\n    )\n\n# Sample and visualize the optimal solution.\nmodel.reset_vparams(res.x)\noptimal_count = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>optimal_count = Counter({'00111': 233, '01011': 208, '00000': 104, '01001': 85, '00100': 75, '00110': 71, '01000': 70, '00101': 33, '00010': 27, '00001': 26, '01010': 24, '00011': 15, '10011': 11, '10000': 10, '01100': 3, '10101': 2, '01111': 1, '10100': 1, '10110': 1})\n</code></pre> <p>Finally, plot the solution:</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings=[\"01011\", \"00111\"]\n</code></pre> 2023-12-12T14:24:16.959241 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = torch.pi\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=torch.pi,      # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_160cf212883841cb9789e2f4b4de3e18 cluster_dea7aa47f08345829b093e138b51f6f2 cluster_b6cd4cf8c4ce4ce79fb248a7344f12be cluster_06653cf508a6441381f9de52ffd129af cluster_e6eec4fc985c483db64eb3ba6feaf3aa cluster_22690af367764f2db9e39d3af1717bfd cluster_d1b6e658d3404d6b8d2c70b43c990648 4c4b9739cd5e4f5497f38c46d9e3c789 0 d61f302029414e47a41215caeaee5a86 HamEvo 4c4b9739cd5e4f5497f38c46d9e3c789--d61f302029414e47a41215caeaee5a86 df693a01c520492ea67014afbd6d09c7 1 a247bde89a5e48a2a8fe59c465da599f HamEvo d61f302029414e47a41215caeaee5a86--a247bde89a5e48a2a8fe59c465da599f fd28ecd5ca5540309d80f717f5b0dcc1 HamEvo a247bde89a5e48a2a8fe59c465da599f--fd28ecd5ca5540309d80f717f5b0dcc1 0120a01a8b6141f18300176d4ad40dc9 X fd28ecd5ca5540309d80f717f5b0dcc1--0120a01a8b6141f18300176d4ad40dc9 06640f36db36422d8f6f9d02f7acee66 HamEvo 0120a01a8b6141f18300176d4ad40dc9--06640f36db36422d8f6f9d02f7acee66 242d16f0222542699a6237087914d646 HamEvo 06640f36db36422d8f6f9d02f7acee66--242d16f0222542699a6237087914d646 9147188f8c33468eacc7f8693a080891 X 242d16f0222542699a6237087914d646--9147188f8c33468eacc7f8693a080891 c01b27cafc1c46e8a8f6b577eb95280f 9147188f8c33468eacc7f8693a080891--c01b27cafc1c46e8a8f6b577eb95280f fc0880b776084c0aa5997a85d0514f4c HamEvo c01b27cafc1c46e8a8f6b577eb95280f--fc0880b776084c0aa5997a85d0514f4c 8a21f191084849bfbe664c06af0bbca0 HamEvo fc0880b776084c0aa5997a85d0514f4c--8a21f191084849bfbe664c06af0bbca0 40724a238f424891b006672ed71482a9 8a21f191084849bfbe664c06af0bbca0--40724a238f424891b006672ed71482a9 ccc12e1abf62469ab357764c34b05b25 40724a238f424891b006672ed71482a9--ccc12e1abf62469ab357764c34b05b25 5c9b73fb24034dbfa51f5e2c8da0d830 077897c409554491afa960521427e1a0 t = -3.142 df693a01c520492ea67014afbd6d09c7--077897c409554491afa960521427e1a0 14d214cbb7cd4632b10b79bbe9718001 2 cccad2214d3e4e1e8a7c6e35ce267688 t = 3.142 077897c409554491afa960521427e1a0--cccad2214d3e4e1e8a7c6e35ce267688 55c5f68362624d21bf1a0373b62d96c7 t = -3.142 cccad2214d3e4e1e8a7c6e35ce267688--55c5f68362624d21bf1a0373b62d96c7 958e86d34a544b16a3d1bbf3d79eb667 55c5f68362624d21bf1a0373b62d96c7--958e86d34a544b16a3d1bbf3d79eb667 193d3237f04c45d5b8348bf3da75a8a3 t = 1.571 958e86d34a544b16a3d1bbf3d79eb667--193d3237f04c45d5b8348bf3da75a8a3 ea6e1ca332494a8a95a5594a407f662d t = 1.571 193d3237f04c45d5b8348bf3da75a8a3--ea6e1ca332494a8a95a5594a407f662d 7f07e5d926b94d739c2c8e3c5b71f2c5 ea6e1ca332494a8a95a5594a407f662d--7f07e5d926b94d739c2c8e3c5b71f2c5 151633c1f4aa468f82a9d44b7c8f5b98 X 7f07e5d926b94d739c2c8e3c5b71f2c5--151633c1f4aa468f82a9d44b7c8f5b98 30448eeafc334617a980bf4fea6ee61b t = 1.571 151633c1f4aa468f82a9d44b7c8f5b98--30448eeafc334617a980bf4fea6ee61b 87d40aec06774ed8940e898779901d46 t = 1.571 30448eeafc334617a980bf4fea6ee61b--87d40aec06774ed8940e898779901d46 d88cca2e3a7d4598a9de161ded044b35 X 87d40aec06774ed8940e898779901d46--d88cca2e3a7d4598a9de161ded044b35 d88cca2e3a7d4598a9de161ded044b35--5c9b73fb24034dbfa51f5e2c8da0d830 60527d65ab3542ccbac2dcfe5930322b a6faf7b0a3f148a5851facc64f355d0a 14d214cbb7cd4632b10b79bbe9718001--a6faf7b0a3f148a5851facc64f355d0a 6369d9fec4244a2e95c4736d015a3a20 a6faf7b0a3f148a5851facc64f355d0a--6369d9fec4244a2e95c4736d015a3a20 95fd19d49ae3419e828939f5147075fe 6369d9fec4244a2e95c4736d015a3a20--95fd19d49ae3419e828939f5147075fe 6348fe5a362f482ca9fa3b77e443eba4 X 95fd19d49ae3419e828939f5147075fe--6348fe5a362f482ca9fa3b77e443eba4 8d11ce555f6b4bdfba2bf62a410c2beb 6348fe5a362f482ca9fa3b77e443eba4--8d11ce555f6b4bdfba2bf62a410c2beb f0beabf80b2642eabc4d370d08b2555a 8d11ce555f6b4bdfba2bf62a410c2beb--f0beabf80b2642eabc4d370d08b2555a 92a2c02aea5f4a978ddc32f9ec41fa72 X f0beabf80b2642eabc4d370d08b2555a--92a2c02aea5f4a978ddc32f9ec41fa72 36862515c3aa4000815525b878ab31dc X 92a2c02aea5f4a978ddc32f9ec41fa72--36862515c3aa4000815525b878ab31dc b36ae90edd044d6b81a1b6486b72e273 36862515c3aa4000815525b878ab31dc--b36ae90edd044d6b81a1b6486b72e273 c7648e35dc2143ebb605849debb5958b b36ae90edd044d6b81a1b6486b72e273--c7648e35dc2143ebb605849debb5958b f7bafc4652784875a40a86bd41a81030 X c7648e35dc2143ebb605849debb5958b--f7bafc4652784875a40a86bd41a81030 f7bafc4652784875a40a86bd41a81030--60527d65ab3542ccbac2dcfe5930322b <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_d7e69e7bc1224a5fa5cfc26d82b6b2d0 cluster_e6192fe94d6b47b7a58f36cc684c95ca 3e4b930fb6fe4fe1b576085a1daff7d3 0 f6bd6e2fa9b6446395ca9b2b6fe55d9a X 3e4b930fb6fe4fe1b576085a1daff7d3--f6bd6e2fa9b6446395ca9b2b6fe55d9a ca1fec7a79704c289c6a4c90f2e30094 1 10480688a17e49ff90a1fb1300466642 HamEvo f6bd6e2fa9b6446395ca9b2b6fe55d9a--10480688a17e49ff90a1fb1300466642 6c24f59dc63149889a72f0bdd1ba4e8f X 10480688a17e49ff90a1fb1300466642--6c24f59dc63149889a72f0bdd1ba4e8f 88222ffad5114f88905ada8b5a7b5d46 6c24f59dc63149889a72f0bdd1ba4e8f--88222ffad5114f88905ada8b5a7b5d46 06c6cf67dc62440ebc87dd3d8415a39f HamEvo 88222ffad5114f88905ada8b5a7b5d46--06c6cf67dc62440ebc87dd3d8415a39f e8fa14ac43b04bc09689e7aac948728f 06c6cf67dc62440ebc87dd3d8415a39f--e8fa14ac43b04bc09689e7aac948728f e0cc1d4712fd4041a2cd6ecaa32b10ea e8fa14ac43b04bc09689e7aac948728f--e0cc1d4712fd4041a2cd6ecaa32b10ea c1585a84b752440c97dfa73770885104 e3cb272687e54a5d86409f45e1796a40 ca1fec7a79704c289c6a4c90f2e30094--e3cb272687e54a5d86409f45e1796a40 e066e4962d9c4adabbd7cbb8eeda6711 2 2517e0748ef54c77b730dd1097d7ef75 t = -0.500 e3cb272687e54a5d86409f45e1796a40--2517e0748ef54c77b730dd1097d7ef75 5cb3b0ad1e4c44df8474c1d8171e9be8 2517e0748ef54c77b730dd1097d7ef75--5cb3b0ad1e4c44df8474c1d8171e9be8 481d112fbfb44c6e88e0801244b29964 X 5cb3b0ad1e4c44df8474c1d8171e9be8--481d112fbfb44c6e88e0801244b29964 a5656cb69057411682ba83ff74b21d8c t = -0.500 481d112fbfb44c6e88e0801244b29964--a5656cb69057411682ba83ff74b21d8c 6698eaa824ad4c3fa4abfc0099402151 X a5656cb69057411682ba83ff74b21d8c--6698eaa824ad4c3fa4abfc0099402151 6698eaa824ad4c3fa4abfc0099402151--c1585a84b752440c97dfa73770885104 bf5c8af3eb6b4431ba00c3f8360b8487 9340ba929a4d43479ec63ec606daa4dc X e066e4962d9c4adabbd7cbb8eeda6711--9340ba929a4d43479ec63ec606daa4dc 39e8182365f34270b4f5f3ff47e6c247 9340ba929a4d43479ec63ec606daa4dc--39e8182365f34270b4f5f3ff47e6c247 93b595b9a61d498bbc2bdc00c6ddb72e X 39e8182365f34270b4f5f3ff47e6c247--93b595b9a61d498bbc2bdc00c6ddb72e e548d9c0eb124896a946f1f3f5ae7aec X 93b595b9a61d498bbc2bdc00c6ddb72e--e548d9c0eb124896a946f1f3f5ae7aec 40ca32872122489295c7db6df6e019a9 e548d9c0eb124896a946f1f3f5ae7aec--40ca32872122489295c7db6df6e019a9 c2257fccf1d646df954fe3fe77c7b06c X 40ca32872122489295c7db6df6e019a9--c2257fccf1d646df954fe3fe77c7b06c c2257fccf1d646df954fe3fe77c7b06c--bf5c8af3eb6b4431ba00c3f8360b8487 <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_d238afca6ccf47adb4c847904bdddde6 cluster_67a024a9e4df4acab8c944039be3185a a9258df3f6a3488190e51033990f8499 0 8067f574fd0d4f0c868c45fc50407bed X a9258df3f6a3488190e51033990f8499--8067f574fd0d4f0c868c45fc50407bed abd9c8d6e7a24afca78e614e21c4f339 1 bd92672970b44a97bc835b53244a9e5f HamEvo 8067f574fd0d4f0c868c45fc50407bed--bd92672970b44a97bc835b53244a9e5f 0c3ecc023b464025acf0507d5e6a53ad X bd92672970b44a97bc835b53244a9e5f--0c3ecc023b464025acf0507d5e6a53ad 3300cc24659448a8be0ab4f89d366eed 0c3ecc023b464025acf0507d5e6a53ad--3300cc24659448a8be0ab4f89d366eed c4ad68851d494de9964b73488c005162 HamEvo 3300cc24659448a8be0ab4f89d366eed--c4ad68851d494de9964b73488c005162 d082537e8c814c138bcb6e6c3f4927f9 c4ad68851d494de9964b73488c005162--d082537e8c814c138bcb6e6c3f4927f9 9a71316605874dbca1860b1a4ae0c07f d082537e8c814c138bcb6e6c3f4927f9--9a71316605874dbca1860b1a4ae0c07f 286507f16bae4659ab1d3cdd695e4ebb 8618e50401ef452f89810589b557fa38 abd9c8d6e7a24afca78e614e21c4f339--8618e50401ef452f89810589b557fa38 24745435525542daa0c72ee9d7937500 2 c0dd33165f1341bd89a9ca2d5e25d00f t = -500.000000000000 8618e50401ef452f89810589b557fa38--c0dd33165f1341bd89a9ca2d5e25d00f 378a5969e7874474b3e977fb3b05b055 c0dd33165f1341bd89a9ca2d5e25d00f--378a5969e7874474b3e977fb3b05b055 433c09878ebc48e18a9ea893bc11fc90 X 378a5969e7874474b3e977fb3b05b055--433c09878ebc48e18a9ea893bc11fc90 adb14c7676994dd5ae5f1e94849d539c t = -500.000000000000 433c09878ebc48e18a9ea893bc11fc90--adb14c7676994dd5ae5f1e94849d539c c0c6ec86908449aca18a0ab33d3ddd55 X adb14c7676994dd5ae5f1e94849d539c--c0c6ec86908449aca18a0ab33d3ddd55 c0c6ec86908449aca18a0ab33d3ddd55--286507f16bae4659ab1d3cdd695e4ebb f9fa1c6fa22b4d21aa3578ee0cc22f1d 8bebb7b97c9040ff805f60fa3c9e502e X 24745435525542daa0c72ee9d7937500--8bebb7b97c9040ff805f60fa3c9e502e e55cacf8d7d1412396007da0c41261a0 8bebb7b97c9040ff805f60fa3c9e502e--e55cacf8d7d1412396007da0c41261a0 4070a193a79b44bba6585f4104eb0bdd X e55cacf8d7d1412396007da0c41261a0--4070a193a79b44bba6585f4104eb0bdd 54bf57ca3e9c468186729cac2b695807 X 4070a193a79b44bba6585f4104eb0bdd--54bf57ca3e9c468186729cac2b695807 e018febe484e488183827a4ef6d25192 54bf57ca3e9c468186729cac2b695807--e018febe484e488183827a4ef6d25192 a90ca523cd2c4e9e9434276fe27f7ad1 X e018febe484e488183827a4ef6d25192--a90ca523cd2c4e9e9434276fe27f7ad1 a90ca523cd2c4e9e9434276fe27f7ad1--f9fa1c6fa22b4d21aa3578ee0cc22f1d <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>wait</code> An idle block to wait for the system to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.847190727211437, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 27, '11': 23})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2023-12-12T14:24:17.500317 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2023-12-12T14:24:17.625467 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*torch.pi/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 23})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>wait</code> and <code>AnalogRY</code> blocks and appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, wait\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-torch.pi / 2),\n        wait(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([torch.pi / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2023-12-12T14:24:18.352532 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(torch.pi/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2023-12-12T14:24:18.514794 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.2723])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.2742])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(torch.pi)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.1391]) The trained function value:  tensor([[0.1391]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>WaitBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, wait\n\nb = chain(wait(200), wait(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), wait(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `WaitBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, wait\n\n    b = chain(wait(200), wait(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), wait(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.WaitBlock","title":"<code>WaitBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Waits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct this block, use the <code>wait</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG)</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.3978-0.0938j, -0.7308-0.5009j, -0.1796-0.0595j,  0.0092+0.1104j],\n         [ 0.6745-0.4435j,  0.3860+0.1615j, -0.2943-0.2427j, -0.1161-0.1194j],\n         [ 0.0071-0.3775j, -0.0791-0.1563j,  0.7486-0.2045j,  0.0188-0.4734j],\n         [-0.1418-0.1366j,  0.0787-0.0558j, -0.0827-0.4578j,  0.8310+0.2120j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block, embed(ps, values), qubit_support, use_full_support, endianness=endianness\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * pi),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | type[Function] | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data is assumed to come from.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | type[Function] | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data is assumed to come from.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*pi).\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    transformed_feature = fm_parameter(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    # Backwards compatibility\n    if fm_type == \"tower\":\n        logger.warning(\"Forcing reupload scaling strategy to TOWER\")\n        reupload_scaling = ReuploadScaling.TOWER\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    for i, qubit in enumerate(support):\n        op_list.append(op(qubit, multiplier * rs_func(i) * transformed_feature))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        int_fn = INTERACTION_DICT.get(interaction, None)\n        if int_fn is None:\n            raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * np.pi / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fdd35e001f0&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7fdd35e00700&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device='cpu', optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, None)\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    data = data_to_device(next(dl_iter), device)  # type: ignore[arg-type]\n                    loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.8553, 0.4821]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n[tensor([0.8860, 0.1588, 0.1412, 0.8215, 0.9256]), tensor([0.6628, 0.0107, 0.0522, 0.5735, 0.7052]), tensor([0.0385, 0.0183, 0.7463, 0.0388, 0.6066])]\n[tensor([0.0584, 0.0124, 0.3985, 0.7267, 0.4795]), tensor([0.2762, 0.3432, 0.2289, 0.4323, 0.2156]), tensor([0.1925, 0.1755, 0.1534, 0.1746, 0.5921])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run\nimport torch\nhevo = HamEvo(generator=RX(0, torch.pi), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.0448-1.9079e-17j, -0.3027+5.5272e-18j],\n        [ 1.0892-2.7965e-17j, -0.4317+1.1084e-17j]])\ntensor([[1.5334-1.1262j, 0.9423-0.6638j],\n        [1.2765-0.4016j, 0.4069-0.1863j]])\n</code></pre> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * np.pi / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * np.pi / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-np.pi / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = np.pi\n    duration = alpha / delta * 1000\n    ps = ParamMap(alpha=alpha, duration=duration, omega=0, delta=delta, phase=0.0)\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration=1000.0, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>1000.0</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter = 1000.0,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    alpha = duration * sympy.sqrt(omega**2 + delta**2) / 1000\n    ps = ParamMap(alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase)\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.wait","title":"<code>wait(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Constructs a <code>WaitBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to wait in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>WaitBlock</code> is applied to. Can be either <code>\"global\"</code> to apply the wait block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>WaitBlock</code> <p>a <code>WaitBlock</code></p> Source code in <code>qadence/operations.py</code> <pre><code>def wait(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; WaitBlock:\n    \"\"\"Constructs a [`WaitBlock`][qadence.blocks.analog.WaitBlock].\n\n    Arguments:\n        duration: Time to wait in nanoseconds.\n        qubit_support: Qubits the `WaitBlock` is applied to. Can be either\n            `\"global\"` to apply the wait block to all qubits or a tuple of integers.\n\n    Returns:\n        a `WaitBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return WaitBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['6bc0a1d1-8473-4da9-aa06-86a6ce858f90', '2031e54b-df3b-4fe2-9672-83f53f58b9c2'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.7262773469971591\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.450972795899503\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('5f349b06-5105-4d08-bbf4-319444de6427', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.3978401946895035'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('8d738df9-df4d-442d-bd22-b21545738bd2', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.5107891929577533'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('fcac8e5e-9aff-4865-a70e-892d73692845', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.16650538174477025'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e7a50541-24e3-4cb4-a581-5de63b460807', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.42675966503419094'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('c59c246c-7743-47eb-9703-044b9724a8fc', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6686059935634905'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('50fbb69c-9bf6-4325-9489-4c8d1031e504', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.2969019264041437'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('606d31e2-3fe7-4433-9123-a11e5bca3329', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.657268166920075'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('eb2aff5f-9563-4767-9d39-53d2bf3e7a53', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.9040698059531549'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2cbb1192-1b07-4bcf-a5c7-db00d773ff2d', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.11147726187362894'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('65d05145-2457-4b37-916e-e5cd5ce3dd89', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.3319225908813115'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('61ffb3fe-7bb1-4928-970b-b982c8d9c1e2', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.732528137502527'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('818c22f1-6e52-4f8a-a3d8-4adfa732e75d', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.6009734758603325'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>00101110\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.0972+0.0300j,  0.7390-0.0408j,  0.2991-0.5066j, -0.2463-0.1876j]])\ntensor([[0.4628-0.3520j, 0.0000+0.0000j, 0.4926+0.6475j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANG","title":"<code>ENTANG = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.WAIT","title":"<code>WAIT = 'wait'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The wait operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 91, '0010': 3, '0001': 2, '0100': 2, '1000': 2})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[0.1102],\n        [0.0714],\n        [0.1501],\n        [0.0039],\n        [0.0344],\n        [0.1196],\n        [0.0958],\n        [0.1658],\n        [0.0453],\n        [0.1395]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 2.8360, -0.3155, -0.3298, -0.1653, -0.2689, -0.3334, -0.3288, -0.3244,\n        -0.2874, -0.3322], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4482],\n        [0.2437],\n        [0.1200],\n        [0.5725],\n        [0.5203]]), tensor([[0.4334],\n        [0.2413],\n        [0.1197],\n        [0.5417],\n        [0.4971]])], 'y2': [tensor([[0.0801],\n        [0.4220],\n        [0.5646],\n        [0.1147],\n        [0.5553]]), tensor([[0.0800],\n        [0.4096],\n        [0.5351],\n        [0.1144],\n        [0.5272]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2023-12-12T14:24:41.016307 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2023-12-12T14:24:41.561193 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_05156b173c464bb6adfee51f6a3cd69d mixing cluster_76a7070d72884612b61b168bca897c49 cost cluster_6d19ebc6e99d4d46b1b856a64f89d8c9 mixing cluster_b63f4dcde21c47a09aee604e101d5e3d cost fb4a4315289247ae95c9b7d971aa3a2a 0 7e46f2dacfa94e14b94c8a0e6f7ab881 fb4a4315289247ae95c9b7d971aa3a2a--7e46f2dacfa94e14b94c8a0e6f7ab881 ada4148778644684bc4850ad0b641386 1 83879d92a03347d29ede69e5ddb728b5 7e46f2dacfa94e14b94c8a0e6f7ab881--83879d92a03347d29ede69e5ddb728b5 6a443be7e6a540b4b5d8f93a347082d7 83879d92a03347d29ede69e5ddb728b5--6a443be7e6a540b4b5d8f93a347082d7 779eb3ddaeb84998a15790027a2c56c4 6a443be7e6a540b4b5d8f93a347082d7--779eb3ddaeb84998a15790027a2c56c4 281b34d18edf4a1d9cd848b1b83d7074 779eb3ddaeb84998a15790027a2c56c4--281b34d18edf4a1d9cd848b1b83d7074 ef7d3fae326e45fe84f52f9832afddbd 281b34d18edf4a1d9cd848b1b83d7074--ef7d3fae326e45fe84f52f9832afddbd 6f0a469096dc42e294043988e5fe6b17 ef7d3fae326e45fe84f52f9832afddbd--6f0a469096dc42e294043988e5fe6b17 fe95ad956d164f4faadd7b0371b0a7a1 6f0a469096dc42e294043988e5fe6b17--fe95ad956d164f4faadd7b0371b0a7a1 89d9324e4b3b49f6bf30e32e98184f20 fe95ad956d164f4faadd7b0371b0a7a1--89d9324e4b3b49f6bf30e32e98184f20 27eb963bce914795bd9d3ec702d74653 89d9324e4b3b49f6bf30e32e98184f20--27eb963bce914795bd9d3ec702d74653 c1e2d996c2f441219ce9906a0614680c 27eb963bce914795bd9d3ec702d74653--c1e2d996c2f441219ce9906a0614680c 28713a583189456b81bb0a734d92415a c1e2d996c2f441219ce9906a0614680c--28713a583189456b81bb0a734d92415a 8bf45ff3902e4954a8634e3d4c27fe64 28713a583189456b81bb0a734d92415a--8bf45ff3902e4954a8634e3d4c27fe64 ec6c8b3e43d94afe87870c9e881124c0 8bf45ff3902e4954a8634e3d4c27fe64--ec6c8b3e43d94afe87870c9e881124c0 862559b812f04c8db2c6d225895e7253 ec6c8b3e43d94afe87870c9e881124c0--862559b812f04c8db2c6d225895e7253 39457dbf464a49b0a31d455777ded197 862559b812f04c8db2c6d225895e7253--39457dbf464a49b0a31d455777ded197 d30281ab39dc4372913e93a5e0412127 39457dbf464a49b0a31d455777ded197--d30281ab39dc4372913e93a5e0412127 31613a69cf894a06a100419738a0fa50 d30281ab39dc4372913e93a5e0412127--31613a69cf894a06a100419738a0fa50 3661e39a0f5d47f4b2cffcd936edaf03 31613a69cf894a06a100419738a0fa50--3661e39a0f5d47f4b2cffcd936edaf03 572b9c78b2f541289e0f26250f9efaf4 3661e39a0f5d47f4b2cffcd936edaf03--572b9c78b2f541289e0f26250f9efaf4 98a1a2fd4dbd4c1bbd84c0b381be6c77 572b9c78b2f541289e0f26250f9efaf4--98a1a2fd4dbd4c1bbd84c0b381be6c77 0ae3c32594be49fea9e718ccce5e754c 98a1a2fd4dbd4c1bbd84c0b381be6c77--0ae3c32594be49fea9e718ccce5e754c 58723ed2b8a04263a8ce4a26fb44e892 0ae3c32594be49fea9e718ccce5e754c--58723ed2b8a04263a8ce4a26fb44e892 26d141393a344382af4e2dae5c4cfc1d 58723ed2b8a04263a8ce4a26fb44e892--26d141393a344382af4e2dae5c4cfc1d d60c24a117c74501855a3cf01f12f061 26d141393a344382af4e2dae5c4cfc1d--d60c24a117c74501855a3cf01f12f061 384c474e87ca47babff3bc3f23d46d55 d60c24a117c74501855a3cf01f12f061--384c474e87ca47babff3bc3f23d46d55 1071dc292dc94ce6af4955bedc4c4477 384c474e87ca47babff3bc3f23d46d55--1071dc292dc94ce6af4955bedc4c4477 40ac04b7efa045fe88ca73c07018d581 1071dc292dc94ce6af4955bedc4c4477--40ac04b7efa045fe88ca73c07018d581 8b5cb592b53940cbb696457f85037201 40ac04b7efa045fe88ca73c07018d581--8b5cb592b53940cbb696457f85037201 ad8e01501afe4eaebd1598d264ef4cb5 8b5cb592b53940cbb696457f85037201--ad8e01501afe4eaebd1598d264ef4cb5 6c55e90a6f1440e28601d0fe0110eaca ad8e01501afe4eaebd1598d264ef4cb5--6c55e90a6f1440e28601d0fe0110eaca 541068c44c154b3685c566f758f815b0 6c55e90a6f1440e28601d0fe0110eaca--541068c44c154b3685c566f758f815b0 13df7f1b922a450990595177748caa1b 541068c44c154b3685c566f758f815b0--13df7f1b922a450990595177748caa1b 03f2318cef0e4452b345f85fad0b0fcb 13df7f1b922a450990595177748caa1b--03f2318cef0e4452b345f85fad0b0fcb 93e90e95699947f7a77701d430211e57 03f2318cef0e4452b345f85fad0b0fcb--93e90e95699947f7a77701d430211e57 af2e0b5e35cf42ffb44a845ead4e6f44 93e90e95699947f7a77701d430211e57--af2e0b5e35cf42ffb44a845ead4e6f44 0f122623c14141a6a29ea903a438de22 af2e0b5e35cf42ffb44a845ead4e6f44--0f122623c14141a6a29ea903a438de22 4ddd740b6ad74c6d94995a80fe200e7b 0f122623c14141a6a29ea903a438de22--4ddd740b6ad74c6d94995a80fe200e7b c6027f3c95424fb790c74c9013761fe9 4ddd740b6ad74c6d94995a80fe200e7b--c6027f3c95424fb790c74c9013761fe9 19f77b9678214c468d3ef1e47197bc0a c6027f3c95424fb790c74c9013761fe9--19f77b9678214c468d3ef1e47197bc0a ce2356eaec344fa18977fbb396e41fbe 19f77b9678214c468d3ef1e47197bc0a--ce2356eaec344fa18977fbb396e41fbe 19e80aab684041a9b6368b644812ee32 ce2356eaec344fa18977fbb396e41fbe--19e80aab684041a9b6368b644812ee32 b0f2c25db2c14b65ac089b167b07c070 19e80aab684041a9b6368b644812ee32--b0f2c25db2c14b65ac089b167b07c070 2d10e339cf0b456290ffca2606bb0bcb b0f2c25db2c14b65ac089b167b07c070--2d10e339cf0b456290ffca2606bb0bcb 23ec2fb083664b608b1cbeb02a6cdd71 2d10e339cf0b456290ffca2606bb0bcb--23ec2fb083664b608b1cbeb02a6cdd71 102e2101ec414502895591e2b3bbd135 23ec2fb083664b608b1cbeb02a6cdd71--102e2101ec414502895591e2b3bbd135 1249de836fde41e995a4021a094d863c 102e2101ec414502895591e2b3bbd135--1249de836fde41e995a4021a094d863c 338f6c48737f4086b99c93a7398e398a 1249de836fde41e995a4021a094d863c--338f6c48737f4086b99c93a7398e398a e12a1e63cecd46f4acfe1e0ef3d127dd 338f6c48737f4086b99c93a7398e398a--e12a1e63cecd46f4acfe1e0ef3d127dd 57e78cd7c44c444191590da4dc7793ef e12a1e63cecd46f4acfe1e0ef3d127dd--57e78cd7c44c444191590da4dc7793ef d743b950a8a2474290b1fe1f15b4f127 57e78cd7c44c444191590da4dc7793ef--d743b950a8a2474290b1fe1f15b4f127 90280e32c9634678b01d656ef5b03886 d743b950a8a2474290b1fe1f15b4f127--90280e32c9634678b01d656ef5b03886 bd4a4ef212ec4cf99acf11c34caa2c59 90280e32c9634678b01d656ef5b03886--bd4a4ef212ec4cf99acf11c34caa2c59 3578ff192210406d9bff8bab5b681c3b bd4a4ef212ec4cf99acf11c34caa2c59--3578ff192210406d9bff8bab5b681c3b 282c36e9542d46ab9c8d15798ebe6b7d 3578ff192210406d9bff8bab5b681c3b--282c36e9542d46ab9c8d15798ebe6b7d c05af95b4bc04861be667ccf15dc141c 282c36e9542d46ab9c8d15798ebe6b7d--c05af95b4bc04861be667ccf15dc141c f1f2f27d1356463ebbca92d27c884aa5 c05af95b4bc04861be667ccf15dc141c--f1f2f27d1356463ebbca92d27c884aa5 712c5e960b0f4b39ba0f3ffa0fdfb5dd f1f2f27d1356463ebbca92d27c884aa5--712c5e960b0f4b39ba0f3ffa0fdfb5dd fba37124980f4989836c9f7a6e70a41f 712c5e960b0f4b39ba0f3ffa0fdfb5dd--fba37124980f4989836c9f7a6e70a41f 9fda3d7beb1849cbabf204b1f3075b1f fba37124980f4989836c9f7a6e70a41f--9fda3d7beb1849cbabf204b1f3075b1f 87e6de619f724d04bf286456f6739aaa 9fda3d7beb1849cbabf204b1f3075b1f--87e6de619f724d04bf286456f6739aaa 51fc2c9419564da6b9e95008e9147758 87e6de619f724d04bf286456f6739aaa--51fc2c9419564da6b9e95008e9147758 b4d8d0bb44e04d87959aa043ce9bc82a 51fc2c9419564da6b9e95008e9147758--b4d8d0bb44e04d87959aa043ce9bc82a 22703890899b40babb34dd5924c59e93 b4d8d0bb44e04d87959aa043ce9bc82a--22703890899b40babb34dd5924c59e93 0dc59bc0257845f1bdc8c4f5dcdbe924 22703890899b40babb34dd5924c59e93--0dc59bc0257845f1bdc8c4f5dcdbe924 4aa8af1d72534c028638dfea8938acc0 0dc59bc0257845f1bdc8c4f5dcdbe924--4aa8af1d72534c028638dfea8938acc0 7750913e4a2345a183a2c1fc565b1c27 4aa8af1d72534c028638dfea8938acc0--7750913e4a2345a183a2c1fc565b1c27 2f74d5317dec48b0b042b8f5ed3dc543 7750913e4a2345a183a2c1fc565b1c27--2f74d5317dec48b0b042b8f5ed3dc543 327c2c11902d4559bd694b54d1535c03 2f74d5317dec48b0b042b8f5ed3dc543--327c2c11902d4559bd694b54d1535c03 2833a9202f1446e2abd6e95e1013755e 327c2c11902d4559bd694b54d1535c03--2833a9202f1446e2abd6e95e1013755e 25425099b9fe4f0a971bf457ea7a7928 2833a9202f1446e2abd6e95e1013755e--25425099b9fe4f0a971bf457ea7a7928 0b22a82620924b82aa8ba51bac568665 25425099b9fe4f0a971bf457ea7a7928--0b22a82620924b82aa8ba51bac568665 466507dd3e50463ca85ea13a29cfc6bf 0b22a82620924b82aa8ba51bac568665--466507dd3e50463ca85ea13a29cfc6bf 13948abcea634c80bdd999cb96d6862e 466507dd3e50463ca85ea13a29cfc6bf--13948abcea634c80bdd999cb96d6862e f7130071280e4ad086f2ed4ff86ef822 13948abcea634c80bdd999cb96d6862e--f7130071280e4ad086f2ed4ff86ef822 bfaa5671a621471c974df7a02c77982f f7130071280e4ad086f2ed4ff86ef822--bfaa5671a621471c974df7a02c77982f 957fe7fc98534cc88328d4b09991e944 bfaa5671a621471c974df7a02c77982f--957fe7fc98534cc88328d4b09991e944 a4842855fd644988b296f7bf38743443 957fe7fc98534cc88328d4b09991e944--a4842855fd644988b296f7bf38743443 f2ffaa8c1dd9408bbf64e4bf2610a46c a4842855fd644988b296f7bf38743443--f2ffaa8c1dd9408bbf64e4bf2610a46c 91cd0eecce4c4a938302f9b87494fd42 f2ffaa8c1dd9408bbf64e4bf2610a46c--91cd0eecce4c4a938302f9b87494fd42 fd6aa4d63cc7489682481bb509854d41 91cd0eecce4c4a938302f9b87494fd42--fd6aa4d63cc7489682481bb509854d41 149bfda9900c49d0b6d3d6ab3470b740 fd6aa4d63cc7489682481bb509854d41--149bfda9900c49d0b6d3d6ab3470b740 5b6f5a1f116c4edd907820c1d0598bf4 149bfda9900c49d0b6d3d6ab3470b740--5b6f5a1f116c4edd907820c1d0598bf4 7b8adfac1513412d9b57a6d33b168865 5b6f5a1f116c4edd907820c1d0598bf4--7b8adfac1513412d9b57a6d33b168865 e6e5812af8184c1e9ade43bbc232872f 7b8adfac1513412d9b57a6d33b168865--e6e5812af8184c1e9ade43bbc232872f 8d015326a4714c8c9991298942d83a24 e6e5812af8184c1e9ade43bbc232872f--8d015326a4714c8c9991298942d83a24 ca6df51dee6c4898a8a0761ec75d0575 8d015326a4714c8c9991298942d83a24--ca6df51dee6c4898a8a0761ec75d0575 3c9ede6a53a84d6cb4d26492687934af ca6df51dee6c4898a8a0761ec75d0575--3c9ede6a53a84d6cb4d26492687934af d153d3db071245f1ab7846462b3027a2 3c9ede6a53a84d6cb4d26492687934af--d153d3db071245f1ab7846462b3027a2 35018da81f7845eab600c9bbf7037407 d153d3db071245f1ab7846462b3027a2--35018da81f7845eab600c9bbf7037407 b279f7f0b50a480c835faef918b18bdb 35018da81f7845eab600c9bbf7037407--b279f7f0b50a480c835faef918b18bdb de1f5a1062dd4a6e9ea15f261382d1a2 b279f7f0b50a480c835faef918b18bdb--de1f5a1062dd4a6e9ea15f261382d1a2 4e4e0f19a4eb405a8743db72af04f5ba de1f5a1062dd4a6e9ea15f261382d1a2--4e4e0f19a4eb405a8743db72af04f5ba dacb867eaf0943a1b6d9226de15bf01e 4e4e0f19a4eb405a8743db72af04f5ba--dacb867eaf0943a1b6d9226de15bf01e ebb9c6555e3b436881b2505fce63cb95 dacb867eaf0943a1b6d9226de15bf01e--ebb9c6555e3b436881b2505fce63cb95 6ce39e82a12c4cceac42005f88e47b8f ebb9c6555e3b436881b2505fce63cb95--6ce39e82a12c4cceac42005f88e47b8f 2168016a8e2245c4abc0a2fd46fbcfb6 6ce39e82a12c4cceac42005f88e47b8f--2168016a8e2245c4abc0a2fd46fbcfb6 ce380fe93ed64a38929bcb5b0179d304 2168016a8e2245c4abc0a2fd46fbcfb6--ce380fe93ed64a38929bcb5b0179d304 bcf87d5a502b41779b75cee9363316a6 ce380fe93ed64a38929bcb5b0179d304--bcf87d5a502b41779b75cee9363316a6 4252a8cdd07d4ce49f020e3e1a859184 bcf87d5a502b41779b75cee9363316a6--4252a8cdd07d4ce49f020e3e1a859184 61d70099934d40faaa67fed9123ac95c 4252a8cdd07d4ce49f020e3e1a859184--61d70099934d40faaa67fed9123ac95c 2e0adbfa2cbe457587d7c17ff1f69687 61d70099934d40faaa67fed9123ac95c--2e0adbfa2cbe457587d7c17ff1f69687 e0cb173f55e647a586e4e4f100eee5fb 2e0adbfa2cbe457587d7c17ff1f69687--e0cb173f55e647a586e4e4f100eee5fb ecdeefa643d744e0969bc699cf85d134 e0cb173f55e647a586e4e4f100eee5fb--ecdeefa643d744e0969bc699cf85d134 e65b73ead2464c7b879b232c2bcc74d0 ecdeefa643d744e0969bc699cf85d134--e65b73ead2464c7b879b232c2bcc74d0 0f326b007e4f4a8997f1519b889084ed e65b73ead2464c7b879b232c2bcc74d0--0f326b007e4f4a8997f1519b889084ed 0c6cd2eb39a74ada80a8a2a2f1351616 0f326b007e4f4a8997f1519b889084ed--0c6cd2eb39a74ada80a8a2a2f1351616 cd98d04316bf45079117890668df4221 0c6cd2eb39a74ada80a8a2a2f1351616--cd98d04316bf45079117890668df4221 74d11838724142a9951daadb8a7faa4c cd98d04316bf45079117890668df4221--74d11838724142a9951daadb8a7faa4c 536e81d2229947bfba301d62302ce500 74d11838724142a9951daadb8a7faa4c--536e81d2229947bfba301d62302ce500 1f312e6b0d2d4c1c9d098a386fc332d1 536e81d2229947bfba301d62302ce500--1f312e6b0d2d4c1c9d098a386fc332d1 cf1e22eaf3954f9dbb57353a342e3223 1f312e6b0d2d4c1c9d098a386fc332d1--cf1e22eaf3954f9dbb57353a342e3223 e2f0bb2c93ed4ce2aac12b8407b1212e cf1e22eaf3954f9dbb57353a342e3223--e2f0bb2c93ed4ce2aac12b8407b1212e 28d6aa0c86874349bad54d0444fe281b e2f0bb2c93ed4ce2aac12b8407b1212e--28d6aa0c86874349bad54d0444fe281b 766e023341fe4a638dab0823de902222 28d6aa0c86874349bad54d0444fe281b--766e023341fe4a638dab0823de902222 a6abe7f19f0946c5aa09aac44c0a1a32 766e023341fe4a638dab0823de902222--a6abe7f19f0946c5aa09aac44c0a1a32 bffa9b959cb249b287735fa65bec5991 a6abe7f19f0946c5aa09aac44c0a1a32--bffa9b959cb249b287735fa65bec5991 6e70121767844310a47b7ef87ba86c7c bffa9b959cb249b287735fa65bec5991--6e70121767844310a47b7ef87ba86c7c ba00a0c437b14789a836fd578553262f RX(b00) 6e70121767844310a47b7ef87ba86c7c--ba00a0c437b14789a836fd578553262f 66cbfaf04ede4349b4b20ad560354209 ba00a0c437b14789a836fd578553262f--66cbfaf04ede4349b4b20ad560354209 3d5ca82f21c4453f8d21ed8781e40545 66cbfaf04ede4349b4b20ad560354209--3d5ca82f21c4453f8d21ed8781e40545 8c95b165241e4174b06e322b4dea5411 3d5ca82f21c4453f8d21ed8781e40545--8c95b165241e4174b06e322b4dea5411 aa4cb159c5cf4612a08c342e523b0595 8c95b165241e4174b06e322b4dea5411--aa4cb159c5cf4612a08c342e523b0595 04494fe1656a419280aec5db9ec43edf aa4cb159c5cf4612a08c342e523b0595--04494fe1656a419280aec5db9ec43edf ad2b706e358144659cb9b73734a86600 04494fe1656a419280aec5db9ec43edf--ad2b706e358144659cb9b73734a86600 c0bcbf18dcb743908b6b8348f8f10ca0 ad2b706e358144659cb9b73734a86600--c0bcbf18dcb743908b6b8348f8f10ca0 4eda2550d0884c9ea62be9f78b6e29e5 c0bcbf18dcb743908b6b8348f8f10ca0--4eda2550d0884c9ea62be9f78b6e29e5 431ba143f27d452eab89146aa0101d83 4eda2550d0884c9ea62be9f78b6e29e5--431ba143f27d452eab89146aa0101d83 05472c1c855140c58ce83ebdcacc975c 431ba143f27d452eab89146aa0101d83--05472c1c855140c58ce83ebdcacc975c b9ed3ba53314421b874e856461d1cfac 05472c1c855140c58ce83ebdcacc975c--b9ed3ba53314421b874e856461d1cfac e2f751d8587f42feb9b7e8e7c9db8fe2 b9ed3ba53314421b874e856461d1cfac--e2f751d8587f42feb9b7e8e7c9db8fe2 c47fb6b6c7ac4c3bbeb56df2f309b539 e2f751d8587f42feb9b7e8e7c9db8fe2--c47fb6b6c7ac4c3bbeb56df2f309b539 b958d1e02f07448daa329dfd41b06894 c47fb6b6c7ac4c3bbeb56df2f309b539--b958d1e02f07448daa329dfd41b06894 50b59b21f6b84af3879653b9391fa59a b958d1e02f07448daa329dfd41b06894--50b59b21f6b84af3879653b9391fa59a aaa8963e1b8f4320823e6a8ff6d26d31 50b59b21f6b84af3879653b9391fa59a--aaa8963e1b8f4320823e6a8ff6d26d31 16b9da879bb749b483c735fd7bcb3624 aaa8963e1b8f4320823e6a8ff6d26d31--16b9da879bb749b483c735fd7bcb3624 2be4a46e7df8475db0a39206741127fc 16b9da879bb749b483c735fd7bcb3624--2be4a46e7df8475db0a39206741127fc ef5ef25a5779447ea789be43c53c2812 2be4a46e7df8475db0a39206741127fc--ef5ef25a5779447ea789be43c53c2812 8bc6dfedd6a243b3ac0dc9b184d0f2c7 ef5ef25a5779447ea789be43c53c2812--8bc6dfedd6a243b3ac0dc9b184d0f2c7 a3d554fa3e84439fa71e733cee4ed237 8bc6dfedd6a243b3ac0dc9b184d0f2c7--a3d554fa3e84439fa71e733cee4ed237 a61f8e9ffce44d34bfe156c0cad7fe56 a3d554fa3e84439fa71e733cee4ed237--a61f8e9ffce44d34bfe156c0cad7fe56 556cba21920d48cf919b90fde09fe440 a61f8e9ffce44d34bfe156c0cad7fe56--556cba21920d48cf919b90fde09fe440 9cb6b0342ae14e72b2085df2d18a9b0a 556cba21920d48cf919b90fde09fe440--9cb6b0342ae14e72b2085df2d18a9b0a 9b2128ccebe64f1b9a630972f7b9a8e8 9cb6b0342ae14e72b2085df2d18a9b0a--9b2128ccebe64f1b9a630972f7b9a8e8 17e8db96fbe64e23a042ca889fe1e442 9b2128ccebe64f1b9a630972f7b9a8e8--17e8db96fbe64e23a042ca889fe1e442 0b55fbb93ca5427684f545ee390e3187 17e8db96fbe64e23a042ca889fe1e442--0b55fbb93ca5427684f545ee390e3187 96370bba5150479692607b3a2c27268a 0b55fbb93ca5427684f545ee390e3187--96370bba5150479692607b3a2c27268a 831c37a9f6de4f549c7616b5a8f4d09d 96370bba5150479692607b3a2c27268a--831c37a9f6de4f549c7616b5a8f4d09d 3ff194e9c3454f78b667be95ffd2d047 831c37a9f6de4f549c7616b5a8f4d09d--3ff194e9c3454f78b667be95ffd2d047 a7c2fccc5b0e47fdb17b54a173537fbb 3ff194e9c3454f78b667be95ffd2d047--a7c2fccc5b0e47fdb17b54a173537fbb 4666a2f844254c77860cf811ff59ee64 a7c2fccc5b0e47fdb17b54a173537fbb--4666a2f844254c77860cf811ff59ee64 6ede44357d54460c9863ed38db8d332e 4666a2f844254c77860cf811ff59ee64--6ede44357d54460c9863ed38db8d332e bd384a11c63a4a4fa8ac12974f08d991 6ede44357d54460c9863ed38db8d332e--bd384a11c63a4a4fa8ac12974f08d991 9b272703979044c2bcca1f025aec21f2 bd384a11c63a4a4fa8ac12974f08d991--9b272703979044c2bcca1f025aec21f2 ba955c0d60a6457c90657c670b9ab2e6 9b272703979044c2bcca1f025aec21f2--ba955c0d60a6457c90657c670b9ab2e6 ab7a517efa4340d29c71de62fc9b1fb0 ba955c0d60a6457c90657c670b9ab2e6--ab7a517efa4340d29c71de62fc9b1fb0 22c2924bf32c459487df6dc36661d347 ab7a517efa4340d29c71de62fc9b1fb0--22c2924bf32c459487df6dc36661d347 addaa003667247679a7a7be4bd233f3d 22c2924bf32c459487df6dc36661d347--addaa003667247679a7a7be4bd233f3d 1ad5b046e6cf4687a12221f7ddbf112b addaa003667247679a7a7be4bd233f3d--1ad5b046e6cf4687a12221f7ddbf112b 2db7e596e4ef4874a469de81434087d0 1ad5b046e6cf4687a12221f7ddbf112b--2db7e596e4ef4874a469de81434087d0 983c89feb5c648448a32f7322ff923f5 2db7e596e4ef4874a469de81434087d0--983c89feb5c648448a32f7322ff923f5 494a16516a6a47aa977fbf59cd8d6145 983c89feb5c648448a32f7322ff923f5--494a16516a6a47aa977fbf59cd8d6145 c835ab29ebf540c1a0a7bb9ee847d2dd 494a16516a6a47aa977fbf59cd8d6145--c835ab29ebf540c1a0a7bb9ee847d2dd 1b6471735a6949c08cb34fee56faba7c c835ab29ebf540c1a0a7bb9ee847d2dd--1b6471735a6949c08cb34fee56faba7c ca39221987924278941815f9b88f3317 1b6471735a6949c08cb34fee56faba7c--ca39221987924278941815f9b88f3317 fcefaa4d034648198fddd96a0fe1c6f8 ca39221987924278941815f9b88f3317--fcefaa4d034648198fddd96a0fe1c6f8 28d995dbc35c4e779ad3e2472bb4734a fcefaa4d034648198fddd96a0fe1c6f8--28d995dbc35c4e779ad3e2472bb4734a 30766e709baa4ca194f662bed8dc4f6a 28d995dbc35c4e779ad3e2472bb4734a--30766e709baa4ca194f662bed8dc4f6a dbdc36addd1545e8964414ebb3241842 30766e709baa4ca194f662bed8dc4f6a--dbdc36addd1545e8964414ebb3241842 6357463c7ea5406e976e728a451aaba9 dbdc36addd1545e8964414ebb3241842--6357463c7ea5406e976e728a451aaba9 ae6200449bb944ebb4e04c61f73cba31 6357463c7ea5406e976e728a451aaba9--ae6200449bb944ebb4e04c61f73cba31 579d4c954b2e4b1289f6f5366141187c ae6200449bb944ebb4e04c61f73cba31--579d4c954b2e4b1289f6f5366141187c e71f998a1b184ead810b692cce33f0a4 579d4c954b2e4b1289f6f5366141187c--e71f998a1b184ead810b692cce33f0a4 5d6bfa36b22b4d2a908fa70524ab85cb e71f998a1b184ead810b692cce33f0a4--5d6bfa36b22b4d2a908fa70524ab85cb 0f846e4a26834e34aa60ff9ef60f949c 5d6bfa36b22b4d2a908fa70524ab85cb--0f846e4a26834e34aa60ff9ef60f949c 3497a130f09c4376a636cc78c7e8a8da 0f846e4a26834e34aa60ff9ef60f949c--3497a130f09c4376a636cc78c7e8a8da d4dc767452c24061af80e11ea51896b9 3497a130f09c4376a636cc78c7e8a8da--d4dc767452c24061af80e11ea51896b9 a93543ec77fb4297bf57595c64bafa1e d4dc767452c24061af80e11ea51896b9--a93543ec77fb4297bf57595c64bafa1e c77225d835b44cfcbc55c3ef70b33605 a93543ec77fb4297bf57595c64bafa1e--c77225d835b44cfcbc55c3ef70b33605 fa5e7a4ab5764f649491f2faeae2ce89 c77225d835b44cfcbc55c3ef70b33605--fa5e7a4ab5764f649491f2faeae2ce89 92375651b14341b9ab06cad7f0a8103e fa5e7a4ab5764f649491f2faeae2ce89--92375651b14341b9ab06cad7f0a8103e 37855938eeb14d17ae4a099dadd715ac 92375651b14341b9ab06cad7f0a8103e--37855938eeb14d17ae4a099dadd715ac f28ccfc0ef4845c482c69223f87e58c6 37855938eeb14d17ae4a099dadd715ac--f28ccfc0ef4845c482c69223f87e58c6 2e55cdc5ae3e43baaf53e928f10a81b8 f28ccfc0ef4845c482c69223f87e58c6--2e55cdc5ae3e43baaf53e928f10a81b8 fdfa68c5d7c74de79793a0871ed28aa8 2e55cdc5ae3e43baaf53e928f10a81b8--fdfa68c5d7c74de79793a0871ed28aa8 4bebc2290c6845b780ded3e6f7d9aeef fdfa68c5d7c74de79793a0871ed28aa8--4bebc2290c6845b780ded3e6f7d9aeef ec4795e8a10f4074b95873e9185950ed 4bebc2290c6845b780ded3e6f7d9aeef--ec4795e8a10f4074b95873e9185950ed bfdc40c0cbda4c10917929e23f5d0155 ec4795e8a10f4074b95873e9185950ed--bfdc40c0cbda4c10917929e23f5d0155 3212b123b33a46369c20e05c9e61c061 bfdc40c0cbda4c10917929e23f5d0155--3212b123b33a46369c20e05c9e61c061 d8f769532e5f4ecf8a65adf5a27a8202 3212b123b33a46369c20e05c9e61c061--d8f769532e5f4ecf8a65adf5a27a8202 61faf86b3d764a31a04fd6dea41d83f7 d8f769532e5f4ecf8a65adf5a27a8202--61faf86b3d764a31a04fd6dea41d83f7 23172994b1f140c4b3207219597e4780 61faf86b3d764a31a04fd6dea41d83f7--23172994b1f140c4b3207219597e4780 6d7f634dfea84f7db163fef94481a1d6 23172994b1f140c4b3207219597e4780--6d7f634dfea84f7db163fef94481a1d6 0fff0dacc9d1429d911d8e30570322a8 6d7f634dfea84f7db163fef94481a1d6--0fff0dacc9d1429d911d8e30570322a8 612a4408f341411a943773d7184c5655 0fff0dacc9d1429d911d8e30570322a8--612a4408f341411a943773d7184c5655 592988609b83411893340d6143f2a8df 612a4408f341411a943773d7184c5655--592988609b83411893340d6143f2a8df f3556cf2f30d4f31beaae5f1ea93e873 592988609b83411893340d6143f2a8df--f3556cf2f30d4f31beaae5f1ea93e873 9cdf692682e74e1f9eaf4bb3c88f16d7 f3556cf2f30d4f31beaae5f1ea93e873--9cdf692682e74e1f9eaf4bb3c88f16d7 2c6d566e04744472b0f968d865bba25f 9cdf692682e74e1f9eaf4bb3c88f16d7--2c6d566e04744472b0f968d865bba25f 5ffb599e8bc9478381a06ac239e73bc2 2c6d566e04744472b0f968d865bba25f--5ffb599e8bc9478381a06ac239e73bc2 3698fe63126d4427ab422ab53c1f12a0 5ffb599e8bc9478381a06ac239e73bc2--3698fe63126d4427ab422ab53c1f12a0 5c6b829743ed4a8bb646bf03bd1ab24a 3698fe63126d4427ab422ab53c1f12a0--5c6b829743ed4a8bb646bf03bd1ab24a 7704add5ff334b02b7c28e84ef5fad51 5c6b829743ed4a8bb646bf03bd1ab24a--7704add5ff334b02b7c28e84ef5fad51 acdb021bac164a29bf8264a7a8a78a76 7704add5ff334b02b7c28e84ef5fad51--acdb021bac164a29bf8264a7a8a78a76 3e879e9d142b4482be1c6a98c07819f6 acdb021bac164a29bf8264a7a8a78a76--3e879e9d142b4482be1c6a98c07819f6 29c7555ce58b4e53909b9ad3ade17255 3e879e9d142b4482be1c6a98c07819f6--29c7555ce58b4e53909b9ad3ade17255 32974b8bb035437390e43a3f528cc6b0 29c7555ce58b4e53909b9ad3ade17255--32974b8bb035437390e43a3f528cc6b0 cd40f050ecd9430bb8af5138ec28c446 32974b8bb035437390e43a3f528cc6b0--cd40f050ecd9430bb8af5138ec28c446 d46857ebc2fe4e0f960e616063761d69 cd40f050ecd9430bb8af5138ec28c446--d46857ebc2fe4e0f960e616063761d69 a98161b91ea94328bccc9192a83167bb d46857ebc2fe4e0f960e616063761d69--a98161b91ea94328bccc9192a83167bb 16ccab5130794f8b8b8409780633acfb a98161b91ea94328bccc9192a83167bb--16ccab5130794f8b8b8409780633acfb 756c98cdb5994f73b77d5b876ac00547 16ccab5130794f8b8b8409780633acfb--756c98cdb5994f73b77d5b876ac00547 d19de10caf4c42608ecc7c9cd9d97c74 756c98cdb5994f73b77d5b876ac00547--d19de10caf4c42608ecc7c9cd9d97c74 e6db52a9c89148278594b156b24417e6 d19de10caf4c42608ecc7c9cd9d97c74--e6db52a9c89148278594b156b24417e6 a5fd49a0f22740a1a54d8ce2fabe47c6 e6db52a9c89148278594b156b24417e6--a5fd49a0f22740a1a54d8ce2fabe47c6 9534976748ac40a685c541d0a652455b a5fd49a0f22740a1a54d8ce2fabe47c6--9534976748ac40a685c541d0a652455b 2bdf258976a140adb31237b0517067c9 9534976748ac40a685c541d0a652455b--2bdf258976a140adb31237b0517067c9 134fc4b621f24bfc8c0d03dade67d96b 2bdf258976a140adb31237b0517067c9--134fc4b621f24bfc8c0d03dade67d96b ac72d90dd0d440a2a76ef49158db07cb 134fc4b621f24bfc8c0d03dade67d96b--ac72d90dd0d440a2a76ef49158db07cb 59610c046c944a3c9abe379f2ab8b255 ac72d90dd0d440a2a76ef49158db07cb--59610c046c944a3c9abe379f2ab8b255 f5f80f92ab5c4194a1ec68a8d04b7227 59610c046c944a3c9abe379f2ab8b255--f5f80f92ab5c4194a1ec68a8d04b7227 469973bded9a4a2d9c29ad6082edf89b f5f80f92ab5c4194a1ec68a8d04b7227--469973bded9a4a2d9c29ad6082edf89b bb793e9ba92b49608016eab5227910c9 469973bded9a4a2d9c29ad6082edf89b--bb793e9ba92b49608016eab5227910c9 6fdb45cd2df34f35b31ff5b537c456f6 bb793e9ba92b49608016eab5227910c9--6fdb45cd2df34f35b31ff5b537c456f6 bd930a50cd304c1893cf91a36bd22d13 6fdb45cd2df34f35b31ff5b537c456f6--bd930a50cd304c1893cf91a36bd22d13 caf70be0c5184aa3ab261c8a2bac6dd1 bd930a50cd304c1893cf91a36bd22d13--caf70be0c5184aa3ab261c8a2bac6dd1 078b37f7bcd9487b820ca5ffc3fa689e caf70be0c5184aa3ab261c8a2bac6dd1--078b37f7bcd9487b820ca5ffc3fa689e 05180babf361412ca0bfdbf622d4357d 078b37f7bcd9487b820ca5ffc3fa689e--05180babf361412ca0bfdbf622d4357d de24f9ddb53b43c6b71dbf21a2c1f8da 05180babf361412ca0bfdbf622d4357d--de24f9ddb53b43c6b71dbf21a2c1f8da 64cd16f28bbd4a9a961169bdb5a317df de24f9ddb53b43c6b71dbf21a2c1f8da--64cd16f28bbd4a9a961169bdb5a317df 0896b2887c474dc68060ccf2e86e730a 64cd16f28bbd4a9a961169bdb5a317df--0896b2887c474dc68060ccf2e86e730a d3d505779dab48adb5c577b6f6c0492d 0896b2887c474dc68060ccf2e86e730a--d3d505779dab48adb5c577b6f6c0492d a70d774344c9425bb10019107b58a134 d3d505779dab48adb5c577b6f6c0492d--a70d774344c9425bb10019107b58a134 85f8489024a14c4fb7fd73eaa1486c01 a70d774344c9425bb10019107b58a134--85f8489024a14c4fb7fd73eaa1486c01 20ce9a7491844793ab3aee82a86be652 85f8489024a14c4fb7fd73eaa1486c01--20ce9a7491844793ab3aee82a86be652 1d2958b4db0a4d09825ae0fab6d0f54c 20ce9a7491844793ab3aee82a86be652--1d2958b4db0a4d09825ae0fab6d0f54c 6dc266e81d954ab68780f0d920ae4cb6 1d2958b4db0a4d09825ae0fab6d0f54c--6dc266e81d954ab68780f0d920ae4cb6 d6a666cdc2ee4144bf0dc60ef6c0a1a1 RX(b10) 6dc266e81d954ab68780f0d920ae4cb6--d6a666cdc2ee4144bf0dc60ef6c0a1a1 5fdcab2caca94860b9768e4b3316f334 d6a666cdc2ee4144bf0dc60ef6c0a1a1--5fdcab2caca94860b9768e4b3316f334 48e897f156ae4189ae9eb311b51e2dfb 76f2fd9c2fe64cc7a568b2852b4b7413 X ada4148778644684bc4850ad0b641386--76f2fd9c2fe64cc7a568b2852b4b7413 19eb02525e6741038969122bc2086f10 2 76f2fd9c2fe64cc7a568b2852b4b7413--7e46f2dacfa94e14b94c8a0e6f7ab881 2c3374e250e248049c9ef8a4b8703533 76f2fd9c2fe64cc7a568b2852b4b7413--2c3374e250e248049c9ef8a4b8703533 0b0e351598474642ba608e4955298efa 2c3374e250e248049c9ef8a4b8703533--0b0e351598474642ba608e4955298efa 855b774fc2ca465d906526f44d674acf 0b0e351598474642ba608e4955298efa--855b774fc2ca465d906526f44d674acf 87d7772e610047debb3b1249bfaaabeb 855b774fc2ca465d906526f44d674acf--87d7772e610047debb3b1249bfaaabeb 838531ea244741c1a68a7670ac38f70d 87d7772e610047debb3b1249bfaaabeb--838531ea244741c1a68a7670ac38f70d b13c790a39ad4ce18fd87721494938dd 838531ea244741c1a68a7670ac38f70d--b13c790a39ad4ce18fd87721494938dd 357b1d8a5b244bbb86d9c4fa180a3f3d b13c790a39ad4ce18fd87721494938dd--357b1d8a5b244bbb86d9c4fa180a3f3d c4cb75aafc13467a8d920c5b66a4bdec 357b1d8a5b244bbb86d9c4fa180a3f3d--c4cb75aafc13467a8d920c5b66a4bdec 320373b256894ad7b625e19fa4793ce1 c4cb75aafc13467a8d920c5b66a4bdec--320373b256894ad7b625e19fa4793ce1 7eae974a1ea0449ea101affbaec3d169 320373b256894ad7b625e19fa4793ce1--7eae974a1ea0449ea101affbaec3d169 a093b76590074836800744174c4dac8f 7eae974a1ea0449ea101affbaec3d169--a093b76590074836800744174c4dac8f 8f9133f232584628b1efb37d2a8695c1 a093b76590074836800744174c4dac8f--8f9133f232584628b1efb37d2a8695c1 03c3e725af5b4546abfb692fbdfdc9b3 8f9133f232584628b1efb37d2a8695c1--03c3e725af5b4546abfb692fbdfdc9b3 73a679bc7c0c4c53b5faa4a61f993ecb X 03c3e725af5b4546abfb692fbdfdc9b3--73a679bc7c0c4c53b5faa4a61f993ecb 73a679bc7c0c4c53b5faa4a61f993ecb--862559b812f04c8db2c6d225895e7253 44ee6833c05e4fea9f7efa20ed815fcc X 73a679bc7c0c4c53b5faa4a61f993ecb--44ee6833c05e4fea9f7efa20ed815fcc 44ee6833c05e4fea9f7efa20ed815fcc--39457dbf464a49b0a31d455777ded197 9c1eed9bddf840159b993970a398100f RZ(-1.0*g0) 44ee6833c05e4fea9f7efa20ed815fcc--9c1eed9bddf840159b993970a398100f 4b2ec3b91f274fe981835acbc1171667 X 9c1eed9bddf840159b993970a398100f--4b2ec3b91f274fe981835acbc1171667 4b2ec3b91f274fe981835acbc1171667--31613a69cf894a06a100419738a0fa50 7f65dd5e668146bca0f8a66c99fef7e6 X 4b2ec3b91f274fe981835acbc1171667--7f65dd5e668146bca0f8a66c99fef7e6 7f65dd5e668146bca0f8a66c99fef7e6--3661e39a0f5d47f4b2cffcd936edaf03 ba134ee9551b4dcb9233b72fb18c88bc 7f65dd5e668146bca0f8a66c99fef7e6--ba134ee9551b4dcb9233b72fb18c88bc c37d4233670a4e5bb09069a074a30dec ba134ee9551b4dcb9233b72fb18c88bc--c37d4233670a4e5bb09069a074a30dec 2f8c9f3935594350821b381071cf8112 c37d4233670a4e5bb09069a074a30dec--2f8c9f3935594350821b381071cf8112 3cfa55d59b35496288df80e581498f41 X 2f8c9f3935594350821b381071cf8112--3cfa55d59b35496288df80e581498f41 3cfa55d59b35496288df80e581498f41--58723ed2b8a04263a8ce4a26fb44e892 dc746e7fb4df4e8ebf793fec912f7500 X 3cfa55d59b35496288df80e581498f41--dc746e7fb4df4e8ebf793fec912f7500 dc746e7fb4df4e8ebf793fec912f7500--26d141393a344382af4e2dae5c4cfc1d 40736771b9b14953844419646b9e0011 dc746e7fb4df4e8ebf793fec912f7500--40736771b9b14953844419646b9e0011 2e673bf690ea42f592a6d57cc96f8cdd 40736771b9b14953844419646b9e0011--2e673bf690ea42f592a6d57cc96f8cdd c02b44799b8240c0b3726c0fba6bfdcf 2e673bf690ea42f592a6d57cc96f8cdd--c02b44799b8240c0b3726c0fba6bfdcf 06e60ab1ab8d4e86a959d100116425a4 c02b44799b8240c0b3726c0fba6bfdcf--06e60ab1ab8d4e86a959d100116425a4 7bc94cfa91824f06912f4ba1adbc96bd 06e60ab1ab8d4e86a959d100116425a4--7bc94cfa91824f06912f4ba1adbc96bd 0b2020f46bc748dc84452a71774980dc X 7bc94cfa91824f06912f4ba1adbc96bd--0b2020f46bc748dc84452a71774980dc 0b2020f46bc748dc84452a71774980dc--ad8e01501afe4eaebd1598d264ef4cb5 a649dbe4a3724f058043234ed444a110 X 0b2020f46bc748dc84452a71774980dc--a649dbe4a3724f058043234ed444a110 a649dbe4a3724f058043234ed444a110--6c55e90a6f1440e28601d0fe0110eaca 64486ed4ed9348a9ab1c7f82713e9901 a649dbe4a3724f058043234ed444a110--64486ed4ed9348a9ab1c7f82713e9901 672763a90bfb4a218701b1117738dcb3 64486ed4ed9348a9ab1c7f82713e9901--672763a90bfb4a218701b1117738dcb3 2319f5e1431c400bb6a9f148a185cd43 672763a90bfb4a218701b1117738dcb3--2319f5e1431c400bb6a9f148a185cd43 ea40f89017de4896b96a762dabd4ed6e 2319f5e1431c400bb6a9f148a185cd43--ea40f89017de4896b96a762dabd4ed6e 24b0ad7771fe45979a38111a4483ecf4 ea40f89017de4896b96a762dabd4ed6e--24b0ad7771fe45979a38111a4483ecf4 483d576be71b4da9a52556823f6ebd68 24b0ad7771fe45979a38111a4483ecf4--483d576be71b4da9a52556823f6ebd68 e2aad172943149b79907afe41823f36e 483d576be71b4da9a52556823f6ebd68--e2aad172943149b79907afe41823f36e 85d487c777ce41658bf1eb78a9882810 X e2aad172943149b79907afe41823f36e--85d487c777ce41658bf1eb78a9882810 85d487c777ce41658bf1eb78a9882810--c6027f3c95424fb790c74c9013761fe9 262b1020e7ec4b10ac01c0637a14ed54 85d487c777ce41658bf1eb78a9882810--262b1020e7ec4b10ac01c0637a14ed54 b1c669bc42094d92a728b23a95b5281f 262b1020e7ec4b10ac01c0637a14ed54--b1c669bc42094d92a728b23a95b5281f e99bdc0b74e74fc5966aa365c86e8c07 b1c669bc42094d92a728b23a95b5281f--e99bdc0b74e74fc5966aa365c86e8c07 f1030b469134471a8e3db49e17d648cb e99bdc0b74e74fc5966aa365c86e8c07--f1030b469134471a8e3db49e17d648cb bd69c5acad694c3ab1771f1c5d4eaec9 f1030b469134471a8e3db49e17d648cb--bd69c5acad694c3ab1771f1c5d4eaec9 dc24b56e7b0c44e6a13d490dc417d1bc bd69c5acad694c3ab1771f1c5d4eaec9--dc24b56e7b0c44e6a13d490dc417d1bc 27aa48ecb4dd47acae492f2321466c4b dc24b56e7b0c44e6a13d490dc417d1bc--27aa48ecb4dd47acae492f2321466c4b 9e64f161bd0243d19fb8103388873800 27aa48ecb4dd47acae492f2321466c4b--9e64f161bd0243d19fb8103388873800 edb3b8fed68241989e82e0ff5d881fca 9e64f161bd0243d19fb8103388873800--edb3b8fed68241989e82e0ff5d881fca 449ce4e22bc64dc4a6b79878e71baa5d edb3b8fed68241989e82e0ff5d881fca--449ce4e22bc64dc4a6b79878e71baa5d 11e4a1b9fba84f20b3cc1bcc5851a9c5 449ce4e22bc64dc4a6b79878e71baa5d--11e4a1b9fba84f20b3cc1bcc5851a9c5 5e71ee8ff7fc472280de805124fa5954 11e4a1b9fba84f20b3cc1bcc5851a9c5--5e71ee8ff7fc472280de805124fa5954 debce4d712c249aebe094a36624f00bb 5e71ee8ff7fc472280de805124fa5954--debce4d712c249aebe094a36624f00bb 6d5d2da2ca08440b9f04f2d293ec7063 debce4d712c249aebe094a36624f00bb--6d5d2da2ca08440b9f04f2d293ec7063 c1438fbc29b44caba2a345bb103a2d9e 6d5d2da2ca08440b9f04f2d293ec7063--c1438fbc29b44caba2a345bb103a2d9e f030fbf472144062b157c966dbe2455c c1438fbc29b44caba2a345bb103a2d9e--f030fbf472144062b157c966dbe2455c cfe85e34fe044f9fa9c4372bd2814eda f030fbf472144062b157c966dbe2455c--cfe85e34fe044f9fa9c4372bd2814eda ed96105b66b6413f958901ec02b7cdd2 cfe85e34fe044f9fa9c4372bd2814eda--ed96105b66b6413f958901ec02b7cdd2 7e5b04d521684aa8a3b4b877e5ebbb80 ed96105b66b6413f958901ec02b7cdd2--7e5b04d521684aa8a3b4b877e5ebbb80 a68ac748bc354e519229b7ca31f0f62b 7e5b04d521684aa8a3b4b877e5ebbb80--a68ac748bc354e519229b7ca31f0f62b a7dddf6e46c741e98962bba706164fdf a68ac748bc354e519229b7ca31f0f62b--a7dddf6e46c741e98962bba706164fdf 3f5680b05bc04502abb198d0bca428b3 a7dddf6e46c741e98962bba706164fdf--3f5680b05bc04502abb198d0bca428b3 7e65bc4c960744b69aa849bb36fa5ef5 3f5680b05bc04502abb198d0bca428b3--7e65bc4c960744b69aa849bb36fa5ef5 3b500257c16a49bd98ba561d1b12ff78 7e65bc4c960744b69aa849bb36fa5ef5--3b500257c16a49bd98ba561d1b12ff78 458a37bb025344d2ba4a482484d8255f 3b500257c16a49bd98ba561d1b12ff78--458a37bb025344d2ba4a482484d8255f 046da7d563db4f2f8711ff0a5798695d 458a37bb025344d2ba4a482484d8255f--046da7d563db4f2f8711ff0a5798695d afef088c0f7d4bcbb0341d6a057ae6f9 046da7d563db4f2f8711ff0a5798695d--afef088c0f7d4bcbb0341d6a057ae6f9 4990ea5c468f44e5932254b122ebca6d afef088c0f7d4bcbb0341d6a057ae6f9--4990ea5c468f44e5932254b122ebca6d fbc6c2e3883647759d334e4d32e6ac6b 4990ea5c468f44e5932254b122ebca6d--fbc6c2e3883647759d334e4d32e6ac6b 14cdad8747554c4aa6aee1b3f93bbe53 fbc6c2e3883647759d334e4d32e6ac6b--14cdad8747554c4aa6aee1b3f93bbe53 78379e5ff39c4a44bb32cdfb6f33ab78 14cdad8747554c4aa6aee1b3f93bbe53--78379e5ff39c4a44bb32cdfb6f33ab78 0797fa1fa44d4d659995043f12c6c0a1 78379e5ff39c4a44bb32cdfb6f33ab78--0797fa1fa44d4d659995043f12c6c0a1 ac76f062435f437f914f6e6877493db3 0797fa1fa44d4d659995043f12c6c0a1--ac76f062435f437f914f6e6877493db3 d8e114a59dd9466da7ef62eabe9422be ac76f062435f437f914f6e6877493db3--d8e114a59dd9466da7ef62eabe9422be 909c2e2c630b450186e1a7dc10bf23ba d8e114a59dd9466da7ef62eabe9422be--909c2e2c630b450186e1a7dc10bf23ba 3b27b69594d043f9ab9d1bea2144e450 909c2e2c630b450186e1a7dc10bf23ba--3b27b69594d043f9ab9d1bea2144e450 a7392b004a2648ce9f3d0efae870a717 3b27b69594d043f9ab9d1bea2144e450--a7392b004a2648ce9f3d0efae870a717 8def2652f61f4a3183b3d345a5d4a679 a7392b004a2648ce9f3d0efae870a717--8def2652f61f4a3183b3d345a5d4a679 60ab214664ac4c1a9bb1ea142857201f 8def2652f61f4a3183b3d345a5d4a679--60ab214664ac4c1a9bb1ea142857201f b31b5da58d8640b0a50babf06e21bd9d 60ab214664ac4c1a9bb1ea142857201f--b31b5da58d8640b0a50babf06e21bd9d eaf661922b1742569c23887feca4a621 b31b5da58d8640b0a50babf06e21bd9d--eaf661922b1742569c23887feca4a621 f6f9c20e07b84f7c95912d9c74948962 eaf661922b1742569c23887feca4a621--f6f9c20e07b84f7c95912d9c74948962 edf3617dd734414bbfd89c390b2d7f4c f6f9c20e07b84f7c95912d9c74948962--edf3617dd734414bbfd89c390b2d7f4c 3b5c2c14b48e4284914a7900389252bd edf3617dd734414bbfd89c390b2d7f4c--3b5c2c14b48e4284914a7900389252bd 00ca84d8d8ce453cbdb2c46b6284dbd2 3b5c2c14b48e4284914a7900389252bd--00ca84d8d8ce453cbdb2c46b6284dbd2 a313f6b501d04077809db0776536d402 00ca84d8d8ce453cbdb2c46b6284dbd2--a313f6b501d04077809db0776536d402 3e1be5f67f36408fae284e0d9a095eab a313f6b501d04077809db0776536d402--3e1be5f67f36408fae284e0d9a095eab 6a24df2a2ab443c7a2b63c779dd3cc0a 3e1be5f67f36408fae284e0d9a095eab--6a24df2a2ab443c7a2b63c779dd3cc0a 5667ca3f1e354a89b1f8bfad0a492273 6a24df2a2ab443c7a2b63c779dd3cc0a--5667ca3f1e354a89b1f8bfad0a492273 c899c3f0a2d34765b0de7d85146112da 5667ca3f1e354a89b1f8bfad0a492273--c899c3f0a2d34765b0de7d85146112da acbb7dc3d8174eb08634cb8381a42323 c899c3f0a2d34765b0de7d85146112da--acbb7dc3d8174eb08634cb8381a42323 51c5f7246df9475c8c97ad56d6d807ed acbb7dc3d8174eb08634cb8381a42323--51c5f7246df9475c8c97ad56d6d807ed 2aa07494b5104583bfddd78d7ffc146f 51c5f7246df9475c8c97ad56d6d807ed--2aa07494b5104583bfddd78d7ffc146f 3b1df989929f4f2c87afafd3c3b18e2b 2aa07494b5104583bfddd78d7ffc146f--3b1df989929f4f2c87afafd3c3b18e2b 865665dde3fa45f181f394065583ee6a 3b1df989929f4f2c87afafd3c3b18e2b--865665dde3fa45f181f394065583ee6a 5afc8f1ed1634fb6939f5067903ab52b 865665dde3fa45f181f394065583ee6a--5afc8f1ed1634fb6939f5067903ab52b d539ab2d320744f6832e838aafde46cc 5afc8f1ed1634fb6939f5067903ab52b--d539ab2d320744f6832e838aafde46cc 1ea3ea683c514487a3360dee1b39aaf5 d539ab2d320744f6832e838aafde46cc--1ea3ea683c514487a3360dee1b39aaf5 590f9540cdcd4dce85a30e0b4c8e39ba 1ea3ea683c514487a3360dee1b39aaf5--590f9540cdcd4dce85a30e0b4c8e39ba 1eeb70e9363a44ee847fe1b1ee5c0114 590f9540cdcd4dce85a30e0b4c8e39ba--1eeb70e9363a44ee847fe1b1ee5c0114 c8585cec97cb48b4a9ed65385c1cf659 1eeb70e9363a44ee847fe1b1ee5c0114--c8585cec97cb48b4a9ed65385c1cf659 f18def44633846c6afcc0f50a6a8e1e0 c8585cec97cb48b4a9ed65385c1cf659--f18def44633846c6afcc0f50a6a8e1e0 6655642d1d124c3fb52d0d0f58d42f38 f18def44633846c6afcc0f50a6a8e1e0--6655642d1d124c3fb52d0d0f58d42f38 748a71d7a02c4d33b2da4d7287d4042f 6655642d1d124c3fb52d0d0f58d42f38--748a71d7a02c4d33b2da4d7287d4042f c879eb80a4794b4ea238cbb8aadb2c9c 748a71d7a02c4d33b2da4d7287d4042f--c879eb80a4794b4ea238cbb8aadb2c9c 3b4951e226d94c27a994ea74d5825010 c879eb80a4794b4ea238cbb8aadb2c9c--3b4951e226d94c27a994ea74d5825010 77545eceab6441c0a9dd1a5b20364f29 3b4951e226d94c27a994ea74d5825010--77545eceab6441c0a9dd1a5b20364f29 d1416f4b51c141c3b22e6df94d85360b 77545eceab6441c0a9dd1a5b20364f29--d1416f4b51c141c3b22e6df94d85360b a575f0520b51450b9ae367ef516d2bf6 d1416f4b51c141c3b22e6df94d85360b--a575f0520b51450b9ae367ef516d2bf6 0a9deee885394abf9c882dc076307b6a a575f0520b51450b9ae367ef516d2bf6--0a9deee885394abf9c882dc076307b6a 2f5073c659a7486f9d4f7ccf629530a4 0a9deee885394abf9c882dc076307b6a--2f5073c659a7486f9d4f7ccf629530a4 9c3d11fdf1cd43a5b3da03978e4993c5 2f5073c659a7486f9d4f7ccf629530a4--9c3d11fdf1cd43a5b3da03978e4993c5 98508109c47240d89dba8a6fa2a6c8ea 9c3d11fdf1cd43a5b3da03978e4993c5--98508109c47240d89dba8a6fa2a6c8ea 5b279567b2354acc889c3a6155a53009 98508109c47240d89dba8a6fa2a6c8ea--5b279567b2354acc889c3a6155a53009 145b5b1c3acf42b1bfab294c88143820 5b279567b2354acc889c3a6155a53009--145b5b1c3acf42b1bfab294c88143820 62ce25488b424caa9e7c78252845a2dc 145b5b1c3acf42b1bfab294c88143820--62ce25488b424caa9e7c78252845a2dc ed418ef200f247f786daeea0494beb46 62ce25488b424caa9e7c78252845a2dc--ed418ef200f247f786daeea0494beb46 98a3b787c8ef486995f356a51e30df5d ed418ef200f247f786daeea0494beb46--98a3b787c8ef486995f356a51e30df5d 2f81827f003c49d184a4d4ac4c75923e 98a3b787c8ef486995f356a51e30df5d--2f81827f003c49d184a4d4ac4c75923e c36f38ae68fc4d4ab82f7f2e76b4b472 RX(b01) 2f81827f003c49d184a4d4ac4c75923e--c36f38ae68fc4d4ab82f7f2e76b4b472 7ed76da006624641bf1b048c00fb79e3 X c36f38ae68fc4d4ab82f7f2e76b4b472--7ed76da006624641bf1b048c00fb79e3 7ed76da006624641bf1b048c00fb79e3--66cbfaf04ede4349b4b20ad560354209 a885636b945941d18c57be9fe507023a 7ed76da006624641bf1b048c00fb79e3--a885636b945941d18c57be9fe507023a 07a77715721c4496baf9953e15f5b9bc a885636b945941d18c57be9fe507023a--07a77715721c4496baf9953e15f5b9bc c44ad29145b94be8aa21ba2ec32300cd 07a77715721c4496baf9953e15f5b9bc--c44ad29145b94be8aa21ba2ec32300cd c673d329f6d0463da631ed2e724cd901 c44ad29145b94be8aa21ba2ec32300cd--c673d329f6d0463da631ed2e724cd901 b6362ed25303471b9f5a77a17f3485b7 c673d329f6d0463da631ed2e724cd901--b6362ed25303471b9f5a77a17f3485b7 e2291ad6664444c0b88b506ba442f82b b6362ed25303471b9f5a77a17f3485b7--e2291ad6664444c0b88b506ba442f82b 7fe8899c6c684937a6ab016e6cdab90e e2291ad6664444c0b88b506ba442f82b--7fe8899c6c684937a6ab016e6cdab90e c930fe9c01494c499baa4d027a8f522b 7fe8899c6c684937a6ab016e6cdab90e--c930fe9c01494c499baa4d027a8f522b ac0931984aef44dfbe4cd6e6a5c60e75 c930fe9c01494c499baa4d027a8f522b--ac0931984aef44dfbe4cd6e6a5c60e75 1d352bb3e6674d95b431993be87790d3 ac0931984aef44dfbe4cd6e6a5c60e75--1d352bb3e6674d95b431993be87790d3 9d2222f1b176462dbc942fa95baec186 1d352bb3e6674d95b431993be87790d3--9d2222f1b176462dbc942fa95baec186 a15e3f06308544abad6018148aae89df 9d2222f1b176462dbc942fa95baec186--a15e3f06308544abad6018148aae89df dd1fd3fadc16421f993ae8c8ecad1f58 a15e3f06308544abad6018148aae89df--dd1fd3fadc16421f993ae8c8ecad1f58 b1248a24d26b47cc92c675b1aa755ba8 X dd1fd3fadc16421f993ae8c8ecad1f58--b1248a24d26b47cc92c675b1aa755ba8 b1248a24d26b47cc92c675b1aa755ba8--50b59b21f6b84af3879653b9391fa59a 144bda679dd545b4a9a5d3ca2e480ebe X b1248a24d26b47cc92c675b1aa755ba8--144bda679dd545b4a9a5d3ca2e480ebe 144bda679dd545b4a9a5d3ca2e480ebe--aaa8963e1b8f4320823e6a8ff6d26d31 7b1572c7f99947f28cd9d2b759931928 RZ(-1.0*g1) 144bda679dd545b4a9a5d3ca2e480ebe--7b1572c7f99947f28cd9d2b759931928 81223fc09b8648a3a500a8d562aac910 X 7b1572c7f99947f28cd9d2b759931928--81223fc09b8648a3a500a8d562aac910 81223fc09b8648a3a500a8d562aac910--2be4a46e7df8475db0a39206741127fc db5d5828dfa849a99a712d23579fd91d X 81223fc09b8648a3a500a8d562aac910--db5d5828dfa849a99a712d23579fd91d db5d5828dfa849a99a712d23579fd91d--ef5ef25a5779447ea789be43c53c2812 a14f0923cad142489dd5a5a5533d4422 db5d5828dfa849a99a712d23579fd91d--a14f0923cad142489dd5a5a5533d4422 b94f2ea09ebd46d39068f0064e9c3acd a14f0923cad142489dd5a5a5533d4422--b94f2ea09ebd46d39068f0064e9c3acd 91a70af5a9f047acb211a4e508d6560b b94f2ea09ebd46d39068f0064e9c3acd--91a70af5a9f047acb211a4e508d6560b db87e254a9ab42cc9e1beab1e8c18762 X 91a70af5a9f047acb211a4e508d6560b--db87e254a9ab42cc9e1beab1e8c18762 db87e254a9ab42cc9e1beab1e8c18762--556cba21920d48cf919b90fde09fe440 85825aed5a79432aafeed718d62b23b3 X db87e254a9ab42cc9e1beab1e8c18762--85825aed5a79432aafeed718d62b23b3 85825aed5a79432aafeed718d62b23b3--9cb6b0342ae14e72b2085df2d18a9b0a 739b095fe37843269144be1340e632bb 85825aed5a79432aafeed718d62b23b3--739b095fe37843269144be1340e632bb 1e74ea26b0bd43e3be787b1a76a52fe9 739b095fe37843269144be1340e632bb--1e74ea26b0bd43e3be787b1a76a52fe9 d2fef30f80ba4aa0b3b55f54054e65d2 1e74ea26b0bd43e3be787b1a76a52fe9--d2fef30f80ba4aa0b3b55f54054e65d2 b70e98cad6df434b83bc31c08469007e d2fef30f80ba4aa0b3b55f54054e65d2--b70e98cad6df434b83bc31c08469007e 4a29f42209b54c0e8cb43e4ce56d2589 b70e98cad6df434b83bc31c08469007e--4a29f42209b54c0e8cb43e4ce56d2589 b21a17f777d54deab5d1e76fe73e53de X 4a29f42209b54c0e8cb43e4ce56d2589--b21a17f777d54deab5d1e76fe73e53de b21a17f777d54deab5d1e76fe73e53de--3ff194e9c3454f78b667be95ffd2d047 a039edfbc69741959ce456cbf6f36fb3 X b21a17f777d54deab5d1e76fe73e53de--a039edfbc69741959ce456cbf6f36fb3 a039edfbc69741959ce456cbf6f36fb3--a7c2fccc5b0e47fdb17b54a173537fbb 21789785e5404801bf9e798f8c239c1f a039edfbc69741959ce456cbf6f36fb3--21789785e5404801bf9e798f8c239c1f f4aefa4c338642bba1b197a04517c999 21789785e5404801bf9e798f8c239c1f--f4aefa4c338642bba1b197a04517c999 3432833439a14cdcafa4a82b929f3be2 f4aefa4c338642bba1b197a04517c999--3432833439a14cdcafa4a82b929f3be2 13f8437ac7ab4d37a2c9ff7a15d6d015 3432833439a14cdcafa4a82b929f3be2--13f8437ac7ab4d37a2c9ff7a15d6d015 e5bdd2dd191142ec8e1be745916d06f1 13f8437ac7ab4d37a2c9ff7a15d6d015--e5bdd2dd191142ec8e1be745916d06f1 048b60c073514e84ab90645d63f6eeab e5bdd2dd191142ec8e1be745916d06f1--048b60c073514e84ab90645d63f6eeab 5197f54dd6a34432a73f2ccb3f2852c6 048b60c073514e84ab90645d63f6eeab--5197f54dd6a34432a73f2ccb3f2852c6 5033c3a7abc842d6904989e6b962491a X 5197f54dd6a34432a73f2ccb3f2852c6--5033c3a7abc842d6904989e6b962491a 5033c3a7abc842d6904989e6b962491a--addaa003667247679a7a7be4bd233f3d 4ddc0b08d52f4e08b5b25e0fe95e43c9 5033c3a7abc842d6904989e6b962491a--4ddc0b08d52f4e08b5b25e0fe95e43c9 89d6fbbc17af4e8ea709c4fa59363451 4ddc0b08d52f4e08b5b25e0fe95e43c9--89d6fbbc17af4e8ea709c4fa59363451 67c1566b136449e598767b2455d8c08e 89d6fbbc17af4e8ea709c4fa59363451--67c1566b136449e598767b2455d8c08e c11d5101d30d40ac8cde75338f697fdc 67c1566b136449e598767b2455d8c08e--c11d5101d30d40ac8cde75338f697fdc 256ccb9a72a0400a90a066d8f2977863 c11d5101d30d40ac8cde75338f697fdc--256ccb9a72a0400a90a066d8f2977863 92fc6e3ce702433d9ba832e071506460 256ccb9a72a0400a90a066d8f2977863--92fc6e3ce702433d9ba832e071506460 dd6491269bd042b5aced7476685f28d8 92fc6e3ce702433d9ba832e071506460--dd6491269bd042b5aced7476685f28d8 71b8f7b6fa714cf4b8db941d308f2b28 dd6491269bd042b5aced7476685f28d8--71b8f7b6fa714cf4b8db941d308f2b28 192951402b96476fa9886e36a6733f60 71b8f7b6fa714cf4b8db941d308f2b28--192951402b96476fa9886e36a6733f60 f290f2c75e7749e8b20cdaf090dbcb26 192951402b96476fa9886e36a6733f60--f290f2c75e7749e8b20cdaf090dbcb26 b65da113867042c383522e91602ee08e f290f2c75e7749e8b20cdaf090dbcb26--b65da113867042c383522e91602ee08e bcdfdebf74a0483ca93dda1d8c789658 b65da113867042c383522e91602ee08e--bcdfdebf74a0483ca93dda1d8c789658 8d30521d9061436ca81747e61aa88b2a bcdfdebf74a0483ca93dda1d8c789658--8d30521d9061436ca81747e61aa88b2a abe1b1d8ac124a68b4edddce2106806e 8d30521d9061436ca81747e61aa88b2a--abe1b1d8ac124a68b4edddce2106806e 97c318624a20433cbdb33dff8688cdf6 abe1b1d8ac124a68b4edddce2106806e--97c318624a20433cbdb33dff8688cdf6 029f7c0dde594024b6746fae84a5dc71 97c318624a20433cbdb33dff8688cdf6--029f7c0dde594024b6746fae84a5dc71 72ad6ceca4814d7f97eeac25d4c698eb 029f7c0dde594024b6746fae84a5dc71--72ad6ceca4814d7f97eeac25d4c698eb cb04724739634ab482989ae88dee775f 72ad6ceca4814d7f97eeac25d4c698eb--cb04724739634ab482989ae88dee775f 7d09e13a61494bbb95698dc41f845bd5 cb04724739634ab482989ae88dee775f--7d09e13a61494bbb95698dc41f845bd5 7952adf38caf43bd90703c2816bb037e 7d09e13a61494bbb95698dc41f845bd5--7952adf38caf43bd90703c2816bb037e 7efe4670e500441fb2ade8b688b85230 7952adf38caf43bd90703c2816bb037e--7efe4670e500441fb2ade8b688b85230 6c90e0e26af44cc8a0f463dc4f342485 7efe4670e500441fb2ade8b688b85230--6c90e0e26af44cc8a0f463dc4f342485 cc1936796a1a436bb631def10f564e72 6c90e0e26af44cc8a0f463dc4f342485--cc1936796a1a436bb631def10f564e72 40c31c780e564773b8a4e37d1bc5cc3d cc1936796a1a436bb631def10f564e72--40c31c780e564773b8a4e37d1bc5cc3d 8dd75029c5e64ada88b1651f768b26e5 40c31c780e564773b8a4e37d1bc5cc3d--8dd75029c5e64ada88b1651f768b26e5 4a4b04b6dff54a78a1001821c596fe6f 8dd75029c5e64ada88b1651f768b26e5--4a4b04b6dff54a78a1001821c596fe6f 75f5f343ff80473ca5f6a80ff21e69f1 4a4b04b6dff54a78a1001821c596fe6f--75f5f343ff80473ca5f6a80ff21e69f1 6ccd9561341c401cb8bd5e7e42717698 75f5f343ff80473ca5f6a80ff21e69f1--6ccd9561341c401cb8bd5e7e42717698 143e332e67b3476eb8db485fed5da1de 6ccd9561341c401cb8bd5e7e42717698--143e332e67b3476eb8db485fed5da1de 8523779734c04533b5bd290f3611804f 143e332e67b3476eb8db485fed5da1de--8523779734c04533b5bd290f3611804f 7f91644ee3fc4348b3a0ef628371bb27 8523779734c04533b5bd290f3611804f--7f91644ee3fc4348b3a0ef628371bb27 6d0e9637745e4402bddf085138a2c735 7f91644ee3fc4348b3a0ef628371bb27--6d0e9637745e4402bddf085138a2c735 ebe43b13b1c14a34ba1b147e8e3636c9 6d0e9637745e4402bddf085138a2c735--ebe43b13b1c14a34ba1b147e8e3636c9 73f3f4d288b14633a95e74354758e6f6 ebe43b13b1c14a34ba1b147e8e3636c9--73f3f4d288b14633a95e74354758e6f6 b1ef4f8a76074c7bb5ec74f4cea22e89 73f3f4d288b14633a95e74354758e6f6--b1ef4f8a76074c7bb5ec74f4cea22e89 dcab8fd46a644ccab3dd0614784f0a6a b1ef4f8a76074c7bb5ec74f4cea22e89--dcab8fd46a644ccab3dd0614784f0a6a 61193109e1c54bc8b0e09de94ddfa90b dcab8fd46a644ccab3dd0614784f0a6a--61193109e1c54bc8b0e09de94ddfa90b f6bf7560e0374d8fac1501db98a58dc8 61193109e1c54bc8b0e09de94ddfa90b--f6bf7560e0374d8fac1501db98a58dc8 adc3fc6095864c9ba7fe4e568bcc7ceb f6bf7560e0374d8fac1501db98a58dc8--adc3fc6095864c9ba7fe4e568bcc7ceb 86cbecaea42144eab771261b3995cf23 adc3fc6095864c9ba7fe4e568bcc7ceb--86cbecaea42144eab771261b3995cf23 1518e264a68b42f8b6450909f52294e4 86cbecaea42144eab771261b3995cf23--1518e264a68b42f8b6450909f52294e4 04647dd61f3e4409a9204aab96d278ff 1518e264a68b42f8b6450909f52294e4--04647dd61f3e4409a9204aab96d278ff 35f16c3ec2374d4a9f6d8ed12d85867c 04647dd61f3e4409a9204aab96d278ff--35f16c3ec2374d4a9f6d8ed12d85867c 217456c604174dcd9b5eab90ef772f84 35f16c3ec2374d4a9f6d8ed12d85867c--217456c604174dcd9b5eab90ef772f84 3b14d32d111b460d920b5c25fd753003 217456c604174dcd9b5eab90ef772f84--3b14d32d111b460d920b5c25fd753003 85557b1303e84ff581b129b3925fe8b4 3b14d32d111b460d920b5c25fd753003--85557b1303e84ff581b129b3925fe8b4 bbc8b9fb364d4427aaacc49c66bb0a1c 85557b1303e84ff581b129b3925fe8b4--bbc8b9fb364d4427aaacc49c66bb0a1c 2b02ad9d5dad46d6aa451970301248b1 bbc8b9fb364d4427aaacc49c66bb0a1c--2b02ad9d5dad46d6aa451970301248b1 94a1952ff8a24f02a908ebd8fae6f048 2b02ad9d5dad46d6aa451970301248b1--94a1952ff8a24f02a908ebd8fae6f048 1d01ac61b02d440d884cfb37cd47e3c4 94a1952ff8a24f02a908ebd8fae6f048--1d01ac61b02d440d884cfb37cd47e3c4 22646cf82afb4365a62f17c0540960e5 1d01ac61b02d440d884cfb37cd47e3c4--22646cf82afb4365a62f17c0540960e5 9b545db3c6b64d29a2a69a19fd6227b9 22646cf82afb4365a62f17c0540960e5--9b545db3c6b64d29a2a69a19fd6227b9 20cb9653b3414f25b7d43446f05ae920 9b545db3c6b64d29a2a69a19fd6227b9--20cb9653b3414f25b7d43446f05ae920 dae5c4662b5a48179bf3458a75d83bdb 20cb9653b3414f25b7d43446f05ae920--dae5c4662b5a48179bf3458a75d83bdb 6d54ac4a9968498fab1252701fde3b51 dae5c4662b5a48179bf3458a75d83bdb--6d54ac4a9968498fab1252701fde3b51 458576c61b624bd7987a2f380981d9e6 6d54ac4a9968498fab1252701fde3b51--458576c61b624bd7987a2f380981d9e6 1f309adf4a524db3bccb0bdcdd4cc17d 458576c61b624bd7987a2f380981d9e6--1f309adf4a524db3bccb0bdcdd4cc17d 797d8279bffc4c3f84afdf567ea3f57b 1f309adf4a524db3bccb0bdcdd4cc17d--797d8279bffc4c3f84afdf567ea3f57b 17654849b42b4bf99965f8490a73165c 797d8279bffc4c3f84afdf567ea3f57b--17654849b42b4bf99965f8490a73165c d09f1097d97c4c959316b5c3aa670e0c 17654849b42b4bf99965f8490a73165c--d09f1097d97c4c959316b5c3aa670e0c 8908590cbbb7418ebc17e375f421e390 d09f1097d97c4c959316b5c3aa670e0c--8908590cbbb7418ebc17e375f421e390 e25053e44d4c473d954d3f4785355caa 8908590cbbb7418ebc17e375f421e390--e25053e44d4c473d954d3f4785355caa 0e2a811d5fef4f71b9c46c2f512c9837 e25053e44d4c473d954d3f4785355caa--0e2a811d5fef4f71b9c46c2f512c9837 b98718ba00404b55991fa47b718c00b3 0e2a811d5fef4f71b9c46c2f512c9837--b98718ba00404b55991fa47b718c00b3 840c5d74e9bf4df5b223766a550bcb84 b98718ba00404b55991fa47b718c00b3--840c5d74e9bf4df5b223766a550bcb84 ff5b418b0a4c43afb6953e7f781eaa8d 840c5d74e9bf4df5b223766a550bcb84--ff5b418b0a4c43afb6953e7f781eaa8d 80750c23c20e40cc9cf70c5ec8414dc6 ff5b418b0a4c43afb6953e7f781eaa8d--80750c23c20e40cc9cf70c5ec8414dc6 54507bf583284192805f32b9ca03005b 80750c23c20e40cc9cf70c5ec8414dc6--54507bf583284192805f32b9ca03005b e302e31588ef4610a97a23b293306e83 54507bf583284192805f32b9ca03005b--e302e31588ef4610a97a23b293306e83 27e37efb250d4dceb58dad6c207fb912 e302e31588ef4610a97a23b293306e83--27e37efb250d4dceb58dad6c207fb912 d5db9cdf2a7b46f6a07e60332451ff6f 27e37efb250d4dceb58dad6c207fb912--d5db9cdf2a7b46f6a07e60332451ff6f 1e8e4548539245ff91ab025377a4cc3a d5db9cdf2a7b46f6a07e60332451ff6f--1e8e4548539245ff91ab025377a4cc3a 7d36640955d84a18b588e0be6df20abf 1e8e4548539245ff91ab025377a4cc3a--7d36640955d84a18b588e0be6df20abf f235cfc25bea479d8e0ff6f5381e78a0 7d36640955d84a18b588e0be6df20abf--f235cfc25bea479d8e0ff6f5381e78a0 dd9d52410a594d81a609cdb70ecc8559 f235cfc25bea479d8e0ff6f5381e78a0--dd9d52410a594d81a609cdb70ecc8559 acb7396f519f4be0892e63088adbc135 dd9d52410a594d81a609cdb70ecc8559--acb7396f519f4be0892e63088adbc135 81cc1a3f7d3b4eefb49e1c33e64d4ce8 acb7396f519f4be0892e63088adbc135--81cc1a3f7d3b4eefb49e1c33e64d4ce8 d35c563e541145458b7089a80b740333 81cc1a3f7d3b4eefb49e1c33e64d4ce8--d35c563e541145458b7089a80b740333 cb32825beab8480491e19d867375fda2 d35c563e541145458b7089a80b740333--cb32825beab8480491e19d867375fda2 e557935c29e94aa897bd13d599d5ef86 RX(b11) cb32825beab8480491e19d867375fda2--e557935c29e94aa897bd13d599d5ef86 e557935c29e94aa897bd13d599d5ef86--48e897f156ae4189ae9eb311b51e2dfb 30eb913ee90643f6ab081ad575a092ab f32f1e0688a04b5ebe43abd92bf8414e 19eb02525e6741038969122bc2086f10--f32f1e0688a04b5ebe43abd92bf8414e e17e544672ab4709bfa2dd6159cfef09 3 a3f2c186d2f84579bcdbb0caee5afe73 X f32f1e0688a04b5ebe43abd92bf8414e--a3f2c186d2f84579bcdbb0caee5afe73 a3f2c186d2f84579bcdbb0caee5afe73--2c3374e250e248049c9ef8a4b8703533 747a0a92b9a04d1f911df26e4ae02680 a3f2c186d2f84579bcdbb0caee5afe73--747a0a92b9a04d1f911df26e4ae02680 319363f6659e42d1ab4ba85fd1e2b160 747a0a92b9a04d1f911df26e4ae02680--319363f6659e42d1ab4ba85fd1e2b160 e1a41dac29324bafa69abc1aa1e9f59f 319363f6659e42d1ab4ba85fd1e2b160--e1a41dac29324bafa69abc1aa1e9f59f 46d11706faaf4c4e8afa030969147188 e1a41dac29324bafa69abc1aa1e9f59f--46d11706faaf4c4e8afa030969147188 61e1aadd4fca40f2863a813e7ad24250 46d11706faaf4c4e8afa030969147188--61e1aadd4fca40f2863a813e7ad24250 bdb9c37d2a944b639c4caeb2d9d45563 61e1aadd4fca40f2863a813e7ad24250--bdb9c37d2a944b639c4caeb2d9d45563 37d3950d2d5c437ea0d6be4b0bd2c695 bdb9c37d2a944b639c4caeb2d9d45563--37d3950d2d5c437ea0d6be4b0bd2c695 71262acfae1646ce80831e3e995211e8 37d3950d2d5c437ea0d6be4b0bd2c695--71262acfae1646ce80831e3e995211e8 bbf8a1b82daf4799984e8535de11d99d 71262acfae1646ce80831e3e995211e8--bbf8a1b82daf4799984e8535de11d99d 1b6c125f8dc94c998230bcca6a3ff41a bbf8a1b82daf4799984e8535de11d99d--1b6c125f8dc94c998230bcca6a3ff41a f48005a1ff9647a5b4efbb9e46ad1f3c 1b6c125f8dc94c998230bcca6a3ff41a--f48005a1ff9647a5b4efbb9e46ad1f3c 234c1352c8a94a059482067ca943e26b X f48005a1ff9647a5b4efbb9e46ad1f3c--234c1352c8a94a059482067ca943e26b 234c1352c8a94a059482067ca943e26b--03c3e725af5b4546abfb692fbdfdc9b3 68f2e66ad8d54bdb941ba76cc8763bbd 234c1352c8a94a059482067ca943e26b--68f2e66ad8d54bdb941ba76cc8763bbd e9ae7454fb9844ce808bd780315c18c0 68f2e66ad8d54bdb941ba76cc8763bbd--e9ae7454fb9844ce808bd780315c18c0 6231464afc6b413ab6d9018e02c86b75 e9ae7454fb9844ce808bd780315c18c0--6231464afc6b413ab6d9018e02c86b75 1d9a24d437d64d5baba9796b461a4df6 6231464afc6b413ab6d9018e02c86b75--1d9a24d437d64d5baba9796b461a4df6 886b3f6b3b2446d2b6233093a04274ae 1d9a24d437d64d5baba9796b461a4df6--886b3f6b3b2446d2b6233093a04274ae 71430bda47414f7c9a78105265e21bef X 886b3f6b3b2446d2b6233093a04274ae--71430bda47414f7c9a78105265e21bef 71430bda47414f7c9a78105265e21bef--ba134ee9551b4dcb9233b72fb18c88bc 0835192d465b49d1a024fed10ae78011 RZ(-1.0*g0) 71430bda47414f7c9a78105265e21bef--0835192d465b49d1a024fed10ae78011 77f7092df2c64a908ed180281c1dd2f9 X 0835192d465b49d1a024fed10ae78011--77f7092df2c64a908ed180281c1dd2f9 77f7092df2c64a908ed180281c1dd2f9--2f8c9f3935594350821b381071cf8112 062f423f06aa4e528c725082c8def7a6 77f7092df2c64a908ed180281c1dd2f9--062f423f06aa4e528c725082c8def7a6 ca9e4bb2da704da798b3787b16546895 062f423f06aa4e528c725082c8def7a6--ca9e4bb2da704da798b3787b16546895 1ee5ceacce5b4beab887008406aeb05e X ca9e4bb2da704da798b3787b16546895--1ee5ceacce5b4beab887008406aeb05e 1ee5ceacce5b4beab887008406aeb05e--40736771b9b14953844419646b9e0011 ec98e908fa0a43f3b709bbc1c9bc78ab 1ee5ceacce5b4beab887008406aeb05e--ec98e908fa0a43f3b709bbc1c9bc78ab c8bf369880f24833a06980c92f820a1b ec98e908fa0a43f3b709bbc1c9bc78ab--c8bf369880f24833a06980c92f820a1b ad405c23e09a49708e7e5a5bc2f357fb c8bf369880f24833a06980c92f820a1b--ad405c23e09a49708e7e5a5bc2f357fb d58af0da90d04c2bb26c8e34847e5bca X ad405c23e09a49708e7e5a5bc2f357fb--d58af0da90d04c2bb26c8e34847e5bca d58af0da90d04c2bb26c8e34847e5bca--7bc94cfa91824f06912f4ba1adbc96bd 5b67ba18f72049af9a6210dda7089ae6 d58af0da90d04c2bb26c8e34847e5bca--5b67ba18f72049af9a6210dda7089ae6 9a09e018fb9b4b2598b501689d10c87c 5b67ba18f72049af9a6210dda7089ae6--9a09e018fb9b4b2598b501689d10c87c c87d64a92e0045e8b721b290baeccc74 X 9a09e018fb9b4b2598b501689d10c87c--c87d64a92e0045e8b721b290baeccc74 c87d64a92e0045e8b721b290baeccc74--64486ed4ed9348a9ab1c7f82713e9901 3947976edf2b444d8b3f9c2ae5a5f614 c87d64a92e0045e8b721b290baeccc74--3947976edf2b444d8b3f9c2ae5a5f614 5bff5919d6fb487a93f0ac19914e537a 3947976edf2b444d8b3f9c2ae5a5f614--5bff5919d6fb487a93f0ac19914e537a 40c76fe0893642248f60eab159b51d58 5bff5919d6fb487a93f0ac19914e537a--40c76fe0893642248f60eab159b51d58 21005a6685e04e39906572a50b64294d 40c76fe0893642248f60eab159b51d58--21005a6685e04e39906572a50b64294d 7e7ce55ec46e419fa8aef9e9040dbe45 21005a6685e04e39906572a50b64294d--7e7ce55ec46e419fa8aef9e9040dbe45 54aa78067d244417bbabefd4087bc3b8 X 7e7ce55ec46e419fa8aef9e9040dbe45--54aa78067d244417bbabefd4087bc3b8 54aa78067d244417bbabefd4087bc3b8--e2aad172943149b79907afe41823f36e b3e9bf19acdf4ae390ce9f32147de52f 54aa78067d244417bbabefd4087bc3b8--b3e9bf19acdf4ae390ce9f32147de52f 7e151df114a04897a914f80efb58993d X b3e9bf19acdf4ae390ce9f32147de52f--7e151df114a04897a914f80efb58993d 7e151df114a04897a914f80efb58993d--262b1020e7ec4b10ac01c0637a14ed54 42bc71c914804843ac67ccdeac84d5b4 RZ(-1.0*g0) 7e151df114a04897a914f80efb58993d--42bc71c914804843ac67ccdeac84d5b4 699d10512420429d8edbe355c91bbd73 X 42bc71c914804843ac67ccdeac84d5b4--699d10512420429d8edbe355c91bbd73 699d10512420429d8edbe355c91bbd73--e99bdc0b74e74fc5966aa365c86e8c07 55b28d68b6734705b7fb103eee625fab X 699d10512420429d8edbe355c91bbd73--55b28d68b6734705b7fb103eee625fab 55b28d68b6734705b7fb103eee625fab--f1030b469134471a8e3db49e17d648cb 3b852f64307746d5be864bc20ef44be6 55b28d68b6734705b7fb103eee625fab--3b852f64307746d5be864bc20ef44be6 b5e985facd9a46e8a9800b3531b4d3b9 3b852f64307746d5be864bc20ef44be6--b5e985facd9a46e8a9800b3531b4d3b9 f28a1d27d6d54adeaafb62f599167e8b b5e985facd9a46e8a9800b3531b4d3b9--f28a1d27d6d54adeaafb62f599167e8b 5459060830e948a29be6d96458813f63 X f28a1d27d6d54adeaafb62f599167e8b--5459060830e948a29be6d96458813f63 5459060830e948a29be6d96458813f63--9e64f161bd0243d19fb8103388873800 817e4f44b8724178a4f595b901bbc140 X 5459060830e948a29be6d96458813f63--817e4f44b8724178a4f595b901bbc140 817e4f44b8724178a4f595b901bbc140--edb3b8fed68241989e82e0ff5d881fca f9cf8fa5f9bc4b8986d8ff644e538d02 817e4f44b8724178a4f595b901bbc140--f9cf8fa5f9bc4b8986d8ff644e538d02 202d731dded14d47a49ae64690a90f45 f9cf8fa5f9bc4b8986d8ff644e538d02--202d731dded14d47a49ae64690a90f45 f6ce2a6074bb46109964a82067e980c9 202d731dded14d47a49ae64690a90f45--f6ce2a6074bb46109964a82067e980c9 0ab8c1d70acf48c0ad55ce29aa76c8f5 f6ce2a6074bb46109964a82067e980c9--0ab8c1d70acf48c0ad55ce29aa76c8f5 0ab5060682254675981fe839aa3ac350 0ab8c1d70acf48c0ad55ce29aa76c8f5--0ab5060682254675981fe839aa3ac350 f64779edfcbe47b098583af43b0e2a98 0ab5060682254675981fe839aa3ac350--f64779edfcbe47b098583af43b0e2a98 65eb6436a51b4cb4abd5390ab067cca9 f64779edfcbe47b098583af43b0e2a98--65eb6436a51b4cb4abd5390ab067cca9 bc31f9ae6bb24d1686ad74492ff16302 X 65eb6436a51b4cb4abd5390ab067cca9--bc31f9ae6bb24d1686ad74492ff16302 bc31f9ae6bb24d1686ad74492ff16302--cfe85e34fe044f9fa9c4372bd2814eda d63d9f61f38b493e8fe978649c804214 X bc31f9ae6bb24d1686ad74492ff16302--d63d9f61f38b493e8fe978649c804214 d63d9f61f38b493e8fe978649c804214--ed96105b66b6413f958901ec02b7cdd2 3c19f1e442e24792b22b365cf70ce500 d63d9f61f38b493e8fe978649c804214--3c19f1e442e24792b22b365cf70ce500 b12e8ef9471b4bd68df80581d0bb8144 3c19f1e442e24792b22b365cf70ce500--b12e8ef9471b4bd68df80581d0bb8144 60b40ba474b3479786146f0c9598b5e5 b12e8ef9471b4bd68df80581d0bb8144--60b40ba474b3479786146f0c9598b5e5 b9efc1f9260c4be895c7ca50c2661c7c 60b40ba474b3479786146f0c9598b5e5--b9efc1f9260c4be895c7ca50c2661c7c 0f50304630a046d09b3805f66b1ce225 b9efc1f9260c4be895c7ca50c2661c7c--0f50304630a046d09b3805f66b1ce225 a86ecbe32e4b402c94b4a3c64ee8d4b2 0f50304630a046d09b3805f66b1ce225--a86ecbe32e4b402c94b4a3c64ee8d4b2 cd6c9ee40f664abb98dfd7b400fa71ec a86ecbe32e4b402c94b4a3c64ee8d4b2--cd6c9ee40f664abb98dfd7b400fa71ec 7250d998b4fc435da94ce660458334cf cd6c9ee40f664abb98dfd7b400fa71ec--7250d998b4fc435da94ce660458334cf 43247f05f80f4d0181b54113dafa7855 7250d998b4fc435da94ce660458334cf--43247f05f80f4d0181b54113dafa7855 a10de0ea086f4ae3a88c2de55c5e6c17 X 43247f05f80f4d0181b54113dafa7855--a10de0ea086f4ae3a88c2de55c5e6c17 a10de0ea086f4ae3a88c2de55c5e6c17--4990ea5c468f44e5932254b122ebca6d 409ac98f1ff0483388a719b70b8db920 a10de0ea086f4ae3a88c2de55c5e6c17--409ac98f1ff0483388a719b70b8db920 ec0cf3ed265f4a44a2cc4e42d08e43ca 409ac98f1ff0483388a719b70b8db920--ec0cf3ed265f4a44a2cc4e42d08e43ca d9f25a592f4945009e9a2ac5ff2178be ec0cf3ed265f4a44a2cc4e42d08e43ca--d9f25a592f4945009e9a2ac5ff2178be 6dc4604d5cee461588e32210c9a0a138 d9f25a592f4945009e9a2ac5ff2178be--6dc4604d5cee461588e32210c9a0a138 be7be44219f24bbebb5a2ce91be61f4e 6dc4604d5cee461588e32210c9a0a138--be7be44219f24bbebb5a2ce91be61f4e d96cdf4be45e4acf87f974500a0f62d2 be7be44219f24bbebb5a2ce91be61f4e--d96cdf4be45e4acf87f974500a0f62d2 1debd1cce41f4e6da450e86a79c26191 d96cdf4be45e4acf87f974500a0f62d2--1debd1cce41f4e6da450e86a79c26191 44216244c25e4d8a88f321789ab1fd65 1debd1cce41f4e6da450e86a79c26191--44216244c25e4d8a88f321789ab1fd65 2fe6b12453cc4e139dd11af23bca6319 44216244c25e4d8a88f321789ab1fd65--2fe6b12453cc4e139dd11af23bca6319 6708849f27904b61883cf44025cffe4e 2fe6b12453cc4e139dd11af23bca6319--6708849f27904b61883cf44025cffe4e 3272ea164bf94403ad3aefc3a73cb174 6708849f27904b61883cf44025cffe4e--3272ea164bf94403ad3aefc3a73cb174 c57935cf262e412a92cc3360272930b3 3272ea164bf94403ad3aefc3a73cb174--c57935cf262e412a92cc3360272930b3 d465fabb698f43b8b98f83eaf9f139c1 c57935cf262e412a92cc3360272930b3--d465fabb698f43b8b98f83eaf9f139c1 3439f99e97e04f9b8fa1e3489f4388e4 d465fabb698f43b8b98f83eaf9f139c1--3439f99e97e04f9b8fa1e3489f4388e4 034d3cdd8ad94c52a0a24471b3dde736 3439f99e97e04f9b8fa1e3489f4388e4--034d3cdd8ad94c52a0a24471b3dde736 ed0104d04f504d4c8972b13a005cf679 034d3cdd8ad94c52a0a24471b3dde736--ed0104d04f504d4c8972b13a005cf679 f1440353cb87425982854e9da024b563 ed0104d04f504d4c8972b13a005cf679--f1440353cb87425982854e9da024b563 9053eac45b714262893b560d46a1519f f1440353cb87425982854e9da024b563--9053eac45b714262893b560d46a1519f fdace6b802b14027b115c6b6e3f1fc66 9053eac45b714262893b560d46a1519f--fdace6b802b14027b115c6b6e3f1fc66 5c038712652f4bab8bc909670b8fa415 fdace6b802b14027b115c6b6e3f1fc66--5c038712652f4bab8bc909670b8fa415 439ecd7c447342829f4a82041df79889 5c038712652f4bab8bc909670b8fa415--439ecd7c447342829f4a82041df79889 c77a80d29fe149d6b9c17f9d11a75965 439ecd7c447342829f4a82041df79889--c77a80d29fe149d6b9c17f9d11a75965 1fed370a521a4315912458ab8ab0c79c c77a80d29fe149d6b9c17f9d11a75965--1fed370a521a4315912458ab8ab0c79c 6b98ee7eba7a478a95c7e07849f54115 1fed370a521a4315912458ab8ab0c79c--6b98ee7eba7a478a95c7e07849f54115 31fabdc1c09543638c4252e8f2ed840d 6b98ee7eba7a478a95c7e07849f54115--31fabdc1c09543638c4252e8f2ed840d 6ff0ff0f9e194cdcb9bc799c3c402a57 31fabdc1c09543638c4252e8f2ed840d--6ff0ff0f9e194cdcb9bc799c3c402a57 cb4268b232d94b2fbce1bcc3253752a7 6ff0ff0f9e194cdcb9bc799c3c402a57--cb4268b232d94b2fbce1bcc3253752a7 c2c52f9be5d04a849a6e84a138ca4396 cb4268b232d94b2fbce1bcc3253752a7--c2c52f9be5d04a849a6e84a138ca4396 2e85a1cb2b254e6a93e26bdd10b66bd0 c2c52f9be5d04a849a6e84a138ca4396--2e85a1cb2b254e6a93e26bdd10b66bd0 187ca9389cf74bcb9fcc154bbe9ce022 2e85a1cb2b254e6a93e26bdd10b66bd0--187ca9389cf74bcb9fcc154bbe9ce022 1af99c8c9939495cb46072872f037b6e 187ca9389cf74bcb9fcc154bbe9ce022--1af99c8c9939495cb46072872f037b6e 2fa77a02f07a4cc88fb366bb15b89924 1af99c8c9939495cb46072872f037b6e--2fa77a02f07a4cc88fb366bb15b89924 cd60fd9584144b50bfd92f489e2b2055 2fa77a02f07a4cc88fb366bb15b89924--cd60fd9584144b50bfd92f489e2b2055 6353f66797554fd9a392c6cc10a9820d cd60fd9584144b50bfd92f489e2b2055--6353f66797554fd9a392c6cc10a9820d 9a2fb0df27b24e6fbe58dfd24717a309 6353f66797554fd9a392c6cc10a9820d--9a2fb0df27b24e6fbe58dfd24717a309 f845e3c683244e21867c805ab34aa64b 9a2fb0df27b24e6fbe58dfd24717a309--f845e3c683244e21867c805ab34aa64b 334825f1ff5d45c4a1238817e54f63c5 f845e3c683244e21867c805ab34aa64b--334825f1ff5d45c4a1238817e54f63c5 2ab11d1866a44442a7c36d954b8d07c4 334825f1ff5d45c4a1238817e54f63c5--2ab11d1866a44442a7c36d954b8d07c4 87bfae3dc07e4a4486848b64c5f9df9e 2ab11d1866a44442a7c36d954b8d07c4--87bfae3dc07e4a4486848b64c5f9df9e 80c99b8578c34c2a89bb9ac6d97d6e2b 87bfae3dc07e4a4486848b64c5f9df9e--80c99b8578c34c2a89bb9ac6d97d6e2b 07387c548dc54b97912bbf8cc1f65c46 80c99b8578c34c2a89bb9ac6d97d6e2b--07387c548dc54b97912bbf8cc1f65c46 919b8fd38c65492c8938121df369566d 07387c548dc54b97912bbf8cc1f65c46--919b8fd38c65492c8938121df369566d 37e974db547148008487c57236759909 919b8fd38c65492c8938121df369566d--37e974db547148008487c57236759909 5cd113a887784f1fab96d36d2ebb1ba6 37e974db547148008487c57236759909--5cd113a887784f1fab96d36d2ebb1ba6 6cd68201273b4bd4b5917183d780fae1 5cd113a887784f1fab96d36d2ebb1ba6--6cd68201273b4bd4b5917183d780fae1 21f696643027456fa041bcbdf79ad78c 6cd68201273b4bd4b5917183d780fae1--21f696643027456fa041bcbdf79ad78c eef950a3dfa2414081a8eacd7181f859 21f696643027456fa041bcbdf79ad78c--eef950a3dfa2414081a8eacd7181f859 854afb74db5b47ecbb9e27f1bda9912b eef950a3dfa2414081a8eacd7181f859--854afb74db5b47ecbb9e27f1bda9912b ef93bf010da0486da7c903b7e640969a 854afb74db5b47ecbb9e27f1bda9912b--ef93bf010da0486da7c903b7e640969a 91f70ac9124549999764b3cd918eaab4 ef93bf010da0486da7c903b7e640969a--91f70ac9124549999764b3cd918eaab4 2203ba1079b84750be1a2bf36a346403 91f70ac9124549999764b3cd918eaab4--2203ba1079b84750be1a2bf36a346403 0e8a7386e6f442788b32968ff42f5fa6 RX(b02) 2203ba1079b84750be1a2bf36a346403--0e8a7386e6f442788b32968ff42f5fa6 b11b03f94bff448d96f91840350ddc02 0e8a7386e6f442788b32968ff42f5fa6--b11b03f94bff448d96f91840350ddc02 e839997f0bdc470194eb55701a6a53f4 X b11b03f94bff448d96f91840350ddc02--e839997f0bdc470194eb55701a6a53f4 e839997f0bdc470194eb55701a6a53f4--a885636b945941d18c57be9fe507023a c6a8db73b03d45759b093963fe3f447f e839997f0bdc470194eb55701a6a53f4--c6a8db73b03d45759b093963fe3f447f 26e96a5dd396463fb0ea92922a11a046 c6a8db73b03d45759b093963fe3f447f--26e96a5dd396463fb0ea92922a11a046 732b94c9459540689ace88e374c464de 26e96a5dd396463fb0ea92922a11a046--732b94c9459540689ace88e374c464de 1a62e5f79c9c4a43b78875b84b26b378 732b94c9459540689ace88e374c464de--1a62e5f79c9c4a43b78875b84b26b378 d1469f35edbf4b8bbff46b47237fa0f7 1a62e5f79c9c4a43b78875b84b26b378--d1469f35edbf4b8bbff46b47237fa0f7 14f123a522c74c03924c372dbd2bfa3b d1469f35edbf4b8bbff46b47237fa0f7--14f123a522c74c03924c372dbd2bfa3b ebb0fa1ff86e4445af81ab296c104a59 14f123a522c74c03924c372dbd2bfa3b--ebb0fa1ff86e4445af81ab296c104a59 404b325a8fdd4b24adf5ff77eba2f559 ebb0fa1ff86e4445af81ab296c104a59--404b325a8fdd4b24adf5ff77eba2f559 566f51fb37b2475bbc5c590fd948f013 404b325a8fdd4b24adf5ff77eba2f559--566f51fb37b2475bbc5c590fd948f013 bf1a97d541e4488e9bc160e1ec81fbe8 566f51fb37b2475bbc5c590fd948f013--bf1a97d541e4488e9bc160e1ec81fbe8 4b8cf0583de44bd3bde0716976dd0bca bf1a97d541e4488e9bc160e1ec81fbe8--4b8cf0583de44bd3bde0716976dd0bca d8477c7a88f24d8383b788d81eab8e96 X 4b8cf0583de44bd3bde0716976dd0bca--d8477c7a88f24d8383b788d81eab8e96 d8477c7a88f24d8383b788d81eab8e96--dd1fd3fadc16421f993ae8c8ecad1f58 e8e66944a8f5498c819e36735b436468 d8477c7a88f24d8383b788d81eab8e96--e8e66944a8f5498c819e36735b436468 1f86b0fb6b154205bc8f4eabb2f14836 e8e66944a8f5498c819e36735b436468--1f86b0fb6b154205bc8f4eabb2f14836 656d1b23a6b24289a73ddb160c1ed212 1f86b0fb6b154205bc8f4eabb2f14836--656d1b23a6b24289a73ddb160c1ed212 f9361b7e9e1c44969160d28d21b06da6 656d1b23a6b24289a73ddb160c1ed212--f9361b7e9e1c44969160d28d21b06da6 905e1687214d48a3bda6842aeba8c9c3 f9361b7e9e1c44969160d28d21b06da6--905e1687214d48a3bda6842aeba8c9c3 8dade410929c4417a26d60598e4b4eb0 X 905e1687214d48a3bda6842aeba8c9c3--8dade410929c4417a26d60598e4b4eb0 8dade410929c4417a26d60598e4b4eb0--a14f0923cad142489dd5a5a5533d4422 6e5138debcd54a198008ac662f579ad2 RZ(-1.0*g1) 8dade410929c4417a26d60598e4b4eb0--6e5138debcd54a198008ac662f579ad2 a83cfba5917741878b96ccd8182c0e62 X 6e5138debcd54a198008ac662f579ad2--a83cfba5917741878b96ccd8182c0e62 a83cfba5917741878b96ccd8182c0e62--91a70af5a9f047acb211a4e508d6560b 84c6009cb2c6498f87c4a40313453a75 a83cfba5917741878b96ccd8182c0e62--84c6009cb2c6498f87c4a40313453a75 494641b410644494a45ac18bc6122780 84c6009cb2c6498f87c4a40313453a75--494641b410644494a45ac18bc6122780 d8d31838fcec4ebe810870b21b4f5263 X 494641b410644494a45ac18bc6122780--d8d31838fcec4ebe810870b21b4f5263 d8d31838fcec4ebe810870b21b4f5263--739b095fe37843269144be1340e632bb 21a626d7607541988c85e853421a2f09 d8d31838fcec4ebe810870b21b4f5263--21a626d7607541988c85e853421a2f09 5584ef4803b84486bb94c9a9aeec3540 21a626d7607541988c85e853421a2f09--5584ef4803b84486bb94c9a9aeec3540 34fe8108bcff48a1a3ad910ada61c100 5584ef4803b84486bb94c9a9aeec3540--34fe8108bcff48a1a3ad910ada61c100 c744d8d1d661497c993df571110fdc09 X 34fe8108bcff48a1a3ad910ada61c100--c744d8d1d661497c993df571110fdc09 c744d8d1d661497c993df571110fdc09--4a29f42209b54c0e8cb43e4ce56d2589 0c0ce2b502b44796803b23296a565a7a c744d8d1d661497c993df571110fdc09--0c0ce2b502b44796803b23296a565a7a 3b3ca2d216f34d5aa5f8a2f9755574a1 0c0ce2b502b44796803b23296a565a7a--3b3ca2d216f34d5aa5f8a2f9755574a1 2167c89701ad45b999e02794f16b2b37 X 3b3ca2d216f34d5aa5f8a2f9755574a1--2167c89701ad45b999e02794f16b2b37 2167c89701ad45b999e02794f16b2b37--21789785e5404801bf9e798f8c239c1f 7b5c585cd3aa479298615199aab91c7c 2167c89701ad45b999e02794f16b2b37--7b5c585cd3aa479298615199aab91c7c a51908a6d34c44389839ffb568ba3921 7b5c585cd3aa479298615199aab91c7c--a51908a6d34c44389839ffb568ba3921 ce24f1b13723489fa3705c355c58b53b a51908a6d34c44389839ffb568ba3921--ce24f1b13723489fa3705c355c58b53b bb51c1425a8e4d9d97bd4c465c7d9ddc ce24f1b13723489fa3705c355c58b53b--bb51c1425a8e4d9d97bd4c465c7d9ddc 0f18cd04518a4a9d8b189c3e24303047 bb51c1425a8e4d9d97bd4c465c7d9ddc--0f18cd04518a4a9d8b189c3e24303047 f0add5843f9f4d40a44671a2efa9751e X 0f18cd04518a4a9d8b189c3e24303047--f0add5843f9f4d40a44671a2efa9751e f0add5843f9f4d40a44671a2efa9751e--5197f54dd6a34432a73f2ccb3f2852c6 1532da7b65834c3ab18ca58be79f8207 f0add5843f9f4d40a44671a2efa9751e--1532da7b65834c3ab18ca58be79f8207 b1d1d65bd981454f884b2571f1887ac6 X 1532da7b65834c3ab18ca58be79f8207--b1d1d65bd981454f884b2571f1887ac6 b1d1d65bd981454f884b2571f1887ac6--4ddc0b08d52f4e08b5b25e0fe95e43c9 32cd19047796447da53df9f57caca14b RZ(-1.0*g1) b1d1d65bd981454f884b2571f1887ac6--32cd19047796447da53df9f57caca14b d76916bf3a3f4f82a7f4547e9752ccc7 X 32cd19047796447da53df9f57caca14b--d76916bf3a3f4f82a7f4547e9752ccc7 d76916bf3a3f4f82a7f4547e9752ccc7--67c1566b136449e598767b2455d8c08e 443806ef94484771aeabf0642505bd58 X d76916bf3a3f4f82a7f4547e9752ccc7--443806ef94484771aeabf0642505bd58 443806ef94484771aeabf0642505bd58--c11d5101d30d40ac8cde75338f697fdc 47579dc7f93e4036b6050df727963df3 443806ef94484771aeabf0642505bd58--47579dc7f93e4036b6050df727963df3 ac97bf11a857420fbbfe5beb9276ab2c 47579dc7f93e4036b6050df727963df3--ac97bf11a857420fbbfe5beb9276ab2c 0663402cc7144507825154ad9d9447a7 ac97bf11a857420fbbfe5beb9276ab2c--0663402cc7144507825154ad9d9447a7 6d130115cfc4407bbe0dda0dcd6ea586 X 0663402cc7144507825154ad9d9447a7--6d130115cfc4407bbe0dda0dcd6ea586 6d130115cfc4407bbe0dda0dcd6ea586--71b8f7b6fa714cf4b8db941d308f2b28 9454e1ab9ce847799110cc68fb24b853 X 6d130115cfc4407bbe0dda0dcd6ea586--9454e1ab9ce847799110cc68fb24b853 9454e1ab9ce847799110cc68fb24b853--192951402b96476fa9886e36a6733f60 37e52604636c4794882464f18e48bf4a 9454e1ab9ce847799110cc68fb24b853--37e52604636c4794882464f18e48bf4a cc719f1400884b5e9f92ec82c980fdef 37e52604636c4794882464f18e48bf4a--cc719f1400884b5e9f92ec82c980fdef c55c6804c8444c0f8c9c16bda61fbe41 cc719f1400884b5e9f92ec82c980fdef--c55c6804c8444c0f8c9c16bda61fbe41 a5e61de7674a4ab483402ce5425bc721 c55c6804c8444c0f8c9c16bda61fbe41--a5e61de7674a4ab483402ce5425bc721 409e5fa6486845caba2b544158e63ce0 a5e61de7674a4ab483402ce5425bc721--409e5fa6486845caba2b544158e63ce0 cd63d9dd6d4047469783ab1f68a59be7 409e5fa6486845caba2b544158e63ce0--cd63d9dd6d4047469783ab1f68a59be7 fb4fba828baf460097a926595efb1309 cd63d9dd6d4047469783ab1f68a59be7--fb4fba828baf460097a926595efb1309 5ebd1f7616cc4a21955e2d65e4f63d0a X fb4fba828baf460097a926595efb1309--5ebd1f7616cc4a21955e2d65e4f63d0a 5ebd1f7616cc4a21955e2d65e4f63d0a--72ad6ceca4814d7f97eeac25d4c698eb 8eaf8137845d497185413c070a936388 X 5ebd1f7616cc4a21955e2d65e4f63d0a--8eaf8137845d497185413c070a936388 8eaf8137845d497185413c070a936388--cb04724739634ab482989ae88dee775f 5e982e123e07452fa26f057668e3bde5 8eaf8137845d497185413c070a936388--5e982e123e07452fa26f057668e3bde5 65a54c6ca66540c399f32bfd81b3468a 5e982e123e07452fa26f057668e3bde5--65a54c6ca66540c399f32bfd81b3468a 68d460c8c6234d7394f2759069d14cef 65a54c6ca66540c399f32bfd81b3468a--68d460c8c6234d7394f2759069d14cef 591316f5fd7e4c03892dbf1dfd83aa32 68d460c8c6234d7394f2759069d14cef--591316f5fd7e4c03892dbf1dfd83aa32 7f1e830727b540b9b61e6540cad364df 591316f5fd7e4c03892dbf1dfd83aa32--7f1e830727b540b9b61e6540cad364df 2b40f57436384b43851f52ee9e8eee44 7f1e830727b540b9b61e6540cad364df--2b40f57436384b43851f52ee9e8eee44 7e9be711f11f4065b39ffaa5117a5677 2b40f57436384b43851f52ee9e8eee44--7e9be711f11f4065b39ffaa5117a5677 4e028792fb764429b18071de1433abdc 7e9be711f11f4065b39ffaa5117a5677--4e028792fb764429b18071de1433abdc 6fb5948d9abb43f29277ffa84990423f 4e028792fb764429b18071de1433abdc--6fb5948d9abb43f29277ffa84990423f ed07b123481a4cf29bf652df01096eee X 6fb5948d9abb43f29277ffa84990423f--ed07b123481a4cf29bf652df01096eee ed07b123481a4cf29bf652df01096eee--6ccd9561341c401cb8bd5e7e42717698 f0d38260e1aa49ab87f28ba470a0bbb8 ed07b123481a4cf29bf652df01096eee--f0d38260e1aa49ab87f28ba470a0bbb8 325a8ba8433344ee9094ab3051f8b161 f0d38260e1aa49ab87f28ba470a0bbb8--325a8ba8433344ee9094ab3051f8b161 6dcc94246c55424eb6252fbb15f63c18 325a8ba8433344ee9094ab3051f8b161--6dcc94246c55424eb6252fbb15f63c18 1451fcec81454f34a043c0726912b097 6dcc94246c55424eb6252fbb15f63c18--1451fcec81454f34a043c0726912b097 b7839e02725649e78f703edc9cc4cc93 1451fcec81454f34a043c0726912b097--b7839e02725649e78f703edc9cc4cc93 b3a49551d6f143149d12a81b95c904e8 b7839e02725649e78f703edc9cc4cc93--b3a49551d6f143149d12a81b95c904e8 007904e57e8c4f4a8256e73ce303185e b3a49551d6f143149d12a81b95c904e8--007904e57e8c4f4a8256e73ce303185e c6f19ec826db49d68149c290a29cc8df 007904e57e8c4f4a8256e73ce303185e--c6f19ec826db49d68149c290a29cc8df 0358b2fecc614e43a42533c02652828f c6f19ec826db49d68149c290a29cc8df--0358b2fecc614e43a42533c02652828f 5ffc6720d1274f98a8dd7f3e9524817e 0358b2fecc614e43a42533c02652828f--5ffc6720d1274f98a8dd7f3e9524817e abe208483dd94ee3979323e955d89d81 5ffc6720d1274f98a8dd7f3e9524817e--abe208483dd94ee3979323e955d89d81 5712a16d70184354a21658304bb00ebc abe208483dd94ee3979323e955d89d81--5712a16d70184354a21658304bb00ebc 299440fc7d1e43feaa09d770916dbb96 5712a16d70184354a21658304bb00ebc--299440fc7d1e43feaa09d770916dbb96 58ac5b8a30444c71aa735138d42cc579 299440fc7d1e43feaa09d770916dbb96--58ac5b8a30444c71aa735138d42cc579 a7e5574934aa4b9ebfda6535f7dc51cc 58ac5b8a30444c71aa735138d42cc579--a7e5574934aa4b9ebfda6535f7dc51cc bf2f6ed6889e44d0b2bcbc721a5fab14 a7e5574934aa4b9ebfda6535f7dc51cc--bf2f6ed6889e44d0b2bcbc721a5fab14 411f1a89a2004ab8bcc428034587122b bf2f6ed6889e44d0b2bcbc721a5fab14--411f1a89a2004ab8bcc428034587122b b5cd798928544a23ad163ebe88455d45 411f1a89a2004ab8bcc428034587122b--b5cd798928544a23ad163ebe88455d45 0e3dbf4ab4844e84bd8f7c9e1eafae96 b5cd798928544a23ad163ebe88455d45--0e3dbf4ab4844e84bd8f7c9e1eafae96 54087ba17a614c12b08faacd448e0609 0e3dbf4ab4844e84bd8f7c9e1eafae96--54087ba17a614c12b08faacd448e0609 5932bec78d6d47a2bd797a58bd75cd4f 54087ba17a614c12b08faacd448e0609--5932bec78d6d47a2bd797a58bd75cd4f 601660da56364c029c64eb071cb52b64 5932bec78d6d47a2bd797a58bd75cd4f--601660da56364c029c64eb071cb52b64 ab815660300b4be5b02f743d396409f7 601660da56364c029c64eb071cb52b64--ab815660300b4be5b02f743d396409f7 465e348b4e6e4f09a1948ca5acb6cce5 ab815660300b4be5b02f743d396409f7--465e348b4e6e4f09a1948ca5acb6cce5 4bb66497dd4143bf949fc61a6b8961f5 465e348b4e6e4f09a1948ca5acb6cce5--4bb66497dd4143bf949fc61a6b8961f5 a251838c679c42208486c93bf7c03046 4bb66497dd4143bf949fc61a6b8961f5--a251838c679c42208486c93bf7c03046 ea4293a054714d5b82485db3d41517da a251838c679c42208486c93bf7c03046--ea4293a054714d5b82485db3d41517da 94893c4e002a4167aa7915ef9424386a ea4293a054714d5b82485db3d41517da--94893c4e002a4167aa7915ef9424386a 90db550949e046369e849af55533b428 94893c4e002a4167aa7915ef9424386a--90db550949e046369e849af55533b428 38f35dfaa9894955a52ff8022067b9ff 90db550949e046369e849af55533b428--38f35dfaa9894955a52ff8022067b9ff 85dc2a2853ae498bb4c3828d145696f8 38f35dfaa9894955a52ff8022067b9ff--85dc2a2853ae498bb4c3828d145696f8 1b40c21ed5184312b98fa7d1edda8a15 85dc2a2853ae498bb4c3828d145696f8--1b40c21ed5184312b98fa7d1edda8a15 28543f62956d41099ea06cc204bae2d3 1b40c21ed5184312b98fa7d1edda8a15--28543f62956d41099ea06cc204bae2d3 89a63f3de52640cb85a59ea0236c1cf8 28543f62956d41099ea06cc204bae2d3--89a63f3de52640cb85a59ea0236c1cf8 3e652b94098e4829870c65f6a42e2e5b 89a63f3de52640cb85a59ea0236c1cf8--3e652b94098e4829870c65f6a42e2e5b 329dd4ed0c57495b861ef731a8f3d1ef 3e652b94098e4829870c65f6a42e2e5b--329dd4ed0c57495b861ef731a8f3d1ef 4f43f4ef123144b7909bf24da94f46d2 329dd4ed0c57495b861ef731a8f3d1ef--4f43f4ef123144b7909bf24da94f46d2 a62ed00bccff4f8aa88d5de5731e73dd 4f43f4ef123144b7909bf24da94f46d2--a62ed00bccff4f8aa88d5de5731e73dd 15e633f1802d428bbb7727907f63f162 a62ed00bccff4f8aa88d5de5731e73dd--15e633f1802d428bbb7727907f63f162 f51098e889664447a84bcbcb1a842cd7 15e633f1802d428bbb7727907f63f162--f51098e889664447a84bcbcb1a842cd7 d96a4068b0f147ebaa2df40245b02be3 f51098e889664447a84bcbcb1a842cd7--d96a4068b0f147ebaa2df40245b02be3 498f7940c25440369b391f5a906d838f d96a4068b0f147ebaa2df40245b02be3--498f7940c25440369b391f5a906d838f 9c127fc7410f4c19b0710fc52b48a7cb 498f7940c25440369b391f5a906d838f--9c127fc7410f4c19b0710fc52b48a7cb c49e9ae62ce5423a838700bee69769eb 9c127fc7410f4c19b0710fc52b48a7cb--c49e9ae62ce5423a838700bee69769eb 9201913354384aecb5ef0ddd7be28970 c49e9ae62ce5423a838700bee69769eb--9201913354384aecb5ef0ddd7be28970 f93c0d8f4f6b48ac8788a992a8fa9e60 9201913354384aecb5ef0ddd7be28970--f93c0d8f4f6b48ac8788a992a8fa9e60 445af5ad01a84c98aa5adb30cd9400e2 f93c0d8f4f6b48ac8788a992a8fa9e60--445af5ad01a84c98aa5adb30cd9400e2 6a011577f0f6493fb0ba198de0f8f0af 445af5ad01a84c98aa5adb30cd9400e2--6a011577f0f6493fb0ba198de0f8f0af 62a4c5dafe7447dcb9d6b4509f88ab36 6a011577f0f6493fb0ba198de0f8f0af--62a4c5dafe7447dcb9d6b4509f88ab36 15fe783dc8b44cc1a147e3829ba1372f 62a4c5dafe7447dcb9d6b4509f88ab36--15fe783dc8b44cc1a147e3829ba1372f ff7f81b4e56c43bfa7d7c9be1db95bfb 15fe783dc8b44cc1a147e3829ba1372f--ff7f81b4e56c43bfa7d7c9be1db95bfb 02285cf589db43fa88f1e7700249f36f RX(b12) ff7f81b4e56c43bfa7d7c9be1db95bfb--02285cf589db43fa88f1e7700249f36f 02285cf589db43fa88f1e7700249f36f--30eb913ee90643f6ab081ad575a092ab 0596b55cf6d447d294dc6defae28ac96 e06e0d56b37e4b998b2f4cdad549eff6 e17e544672ab4709bfa2dd6159cfef09--e06e0d56b37e4b998b2f4cdad549eff6 03d3860f19974b789890ded62f0c6744 4 b5275647a6854bb49f4e6c5c41e4d200 e06e0d56b37e4b998b2f4cdad549eff6--b5275647a6854bb49f4e6c5c41e4d200 a6a4c148d1ed4c138c05ce3c488057d5 X b5275647a6854bb49f4e6c5c41e4d200--a6a4c148d1ed4c138c05ce3c488057d5 a6a4c148d1ed4c138c05ce3c488057d5--747a0a92b9a04d1f911df26e4ae02680 cf42f1941e7741849d7372a9616b9c99 a6a4c148d1ed4c138c05ce3c488057d5--cf42f1941e7741849d7372a9616b9c99 eb5f7a954a574987b3deaebc2fed7cf8 cf42f1941e7741849d7372a9616b9c99--eb5f7a954a574987b3deaebc2fed7cf8 b9f51ee6d1ea420292d398ce3af9ab08 eb5f7a954a574987b3deaebc2fed7cf8--b9f51ee6d1ea420292d398ce3af9ab08 855123ef9c2f4e6ea443191c7d68ef8a b9f51ee6d1ea420292d398ce3af9ab08--855123ef9c2f4e6ea443191c7d68ef8a 0683f821f2934e5f91b4adbd5ecba3df 855123ef9c2f4e6ea443191c7d68ef8a--0683f821f2934e5f91b4adbd5ecba3df 82e95f3b941e47bea70e8688f19a422e 0683f821f2934e5f91b4adbd5ecba3df--82e95f3b941e47bea70e8688f19a422e d732ad8b6421441bba18010b2d7e65c6 82e95f3b941e47bea70e8688f19a422e--d732ad8b6421441bba18010b2d7e65c6 4c9f9d41529349d49ae8c235d9e0d574 d732ad8b6421441bba18010b2d7e65c6--4c9f9d41529349d49ae8c235d9e0d574 68b1d86565d7442f8892b717ef515aa3 4c9f9d41529349d49ae8c235d9e0d574--68b1d86565d7442f8892b717ef515aa3 9092375779bc409bbf0b9ba9dd9d9fc3 X 68b1d86565d7442f8892b717ef515aa3--9092375779bc409bbf0b9ba9dd9d9fc3 9092375779bc409bbf0b9ba9dd9d9fc3--f48005a1ff9647a5b4efbb9e46ad1f3c 2f92d1a16e7f4dd1bb4eab316da380e4 9092375779bc409bbf0b9ba9dd9d9fc3--2f92d1a16e7f4dd1bb4eab316da380e4 f40b2178225642feb2614c3ecd578927 2f92d1a16e7f4dd1bb4eab316da380e4--f40b2178225642feb2614c3ecd578927 f30ae6e347f548e5aaf6be822c652300 f40b2178225642feb2614c3ecd578927--f30ae6e347f548e5aaf6be822c652300 5cc1cc9a12f44c299a7299c70330f0fd f30ae6e347f548e5aaf6be822c652300--5cc1cc9a12f44c299a7299c70330f0fd 6bed3d0df720452c8e25e788ba27b292 5cc1cc9a12f44c299a7299c70330f0fd--6bed3d0df720452c8e25e788ba27b292 fca2d23a6eae414184480090c3758be3 6bed3d0df720452c8e25e788ba27b292--fca2d23a6eae414184480090c3758be3 26a08247d6c841c1a89f58d18935ca73 fca2d23a6eae414184480090c3758be3--26a08247d6c841c1a89f58d18935ca73 a613e7bef0bc478dba932984fb9c5c63 26a08247d6c841c1a89f58d18935ca73--a613e7bef0bc478dba932984fb9c5c63 5cfbc5cdfb88499da9971e605cd85bf0 a613e7bef0bc478dba932984fb9c5c63--5cfbc5cdfb88499da9971e605cd85bf0 6f18e5afd05d4c1d844074625778fa14 5cfbc5cdfb88499da9971e605cd85bf0--6f18e5afd05d4c1d844074625778fa14 eb044c75b696442d9dd12caa290b77fb 6f18e5afd05d4c1d844074625778fa14--eb044c75b696442d9dd12caa290b77fb d2e895d0877649e8ab218816304080c5 eb044c75b696442d9dd12caa290b77fb--d2e895d0877649e8ab218816304080c5 918e5ef908ae4d14930a2cf7dd6e8542 X d2e895d0877649e8ab218816304080c5--918e5ef908ae4d14930a2cf7dd6e8542 918e5ef908ae4d14930a2cf7dd6e8542--ec98e908fa0a43f3b709bbc1c9bc78ab a74ae8ea6e1b4a8cb6611f5e6f29b91e RZ(-1.0*g0) 918e5ef908ae4d14930a2cf7dd6e8542--a74ae8ea6e1b4a8cb6611f5e6f29b91e b30b31103fb6410a87626406f3ea1c26 X a74ae8ea6e1b4a8cb6611f5e6f29b91e--b30b31103fb6410a87626406f3ea1c26 b30b31103fb6410a87626406f3ea1c26--ad405c23e09a49708e7e5a5bc2f357fb 48975d251d78425a808a43662f044ad0 b30b31103fb6410a87626406f3ea1c26--48975d251d78425a808a43662f044ad0 f5abec66bed742e69c5cfb994f9e4721 48975d251d78425a808a43662f044ad0--f5abec66bed742e69c5cfb994f9e4721 86e343956243438494b827904a3e1850 f5abec66bed742e69c5cfb994f9e4721--86e343956243438494b827904a3e1850 3ad77f72ad2d45cc8a460beebb5877fa 86e343956243438494b827904a3e1850--3ad77f72ad2d45cc8a460beebb5877fa 81ec8d30d82f486b9e071a9b11606f9d X 3ad77f72ad2d45cc8a460beebb5877fa--81ec8d30d82f486b9e071a9b11606f9d 81ec8d30d82f486b9e071a9b11606f9d--3947976edf2b444d8b3f9c2ae5a5f614 0a6b1b5c61e442319ba02b906469f2c4 81ec8d30d82f486b9e071a9b11606f9d--0a6b1b5c61e442319ba02b906469f2c4 fb64c35314c945baacb7801f39e87bf6 0a6b1b5c61e442319ba02b906469f2c4--fb64c35314c945baacb7801f39e87bf6 3fb7627a6f7d4013a6869093ee107efa fb64c35314c945baacb7801f39e87bf6--3fb7627a6f7d4013a6869093ee107efa 1e051d166cb742c78ac3248ea2200ff0 X 3fb7627a6f7d4013a6869093ee107efa--1e051d166cb742c78ac3248ea2200ff0 1e051d166cb742c78ac3248ea2200ff0--7e7ce55ec46e419fa8aef9e9040dbe45 ef702fa9ec8043b5bb30ef0b950cd1ea 1e051d166cb742c78ac3248ea2200ff0--ef702fa9ec8043b5bb30ef0b950cd1ea e224d7aeb92f4e0d97b20feb04267b99 ef702fa9ec8043b5bb30ef0b950cd1ea--e224d7aeb92f4e0d97b20feb04267b99 145e789d48ed4dba96d3e22513996e5f e224d7aeb92f4e0d97b20feb04267b99--145e789d48ed4dba96d3e22513996e5f 78b254b7c9ed461faf4bbe22d2dba209 145e789d48ed4dba96d3e22513996e5f--78b254b7c9ed461faf4bbe22d2dba209 a0a83161e4db473a8961466dcb157279 78b254b7c9ed461faf4bbe22d2dba209--a0a83161e4db473a8961466dcb157279 8e1f2c714ffd44838e3e3365a439c654 a0a83161e4db473a8961466dcb157279--8e1f2c714ffd44838e3e3365a439c654 19015424430945a7b5fb39594115c82e X 8e1f2c714ffd44838e3e3365a439c654--19015424430945a7b5fb39594115c82e 19015424430945a7b5fb39594115c82e--3b852f64307746d5be864bc20ef44be6 d666ba9a30cc4c398907945990258fba RZ(-1.0*g0) 19015424430945a7b5fb39594115c82e--d666ba9a30cc4c398907945990258fba e04ed0bb38194b73b5e1b06a396db99f X d666ba9a30cc4c398907945990258fba--e04ed0bb38194b73b5e1b06a396db99f e04ed0bb38194b73b5e1b06a396db99f--f28a1d27d6d54adeaafb62f599167e8b 722c24b2406d4d3eb52a93d1f5ede332 e04ed0bb38194b73b5e1b06a396db99f--722c24b2406d4d3eb52a93d1f5ede332 1c94cff2eb644888b7c71c1e08e82e52 722c24b2406d4d3eb52a93d1f5ede332--1c94cff2eb644888b7c71c1e08e82e52 a2b9eede354e4485ab5bfb895538762e X 1c94cff2eb644888b7c71c1e08e82e52--a2b9eede354e4485ab5bfb895538762e a2b9eede354e4485ab5bfb895538762e--f9cf8fa5f9bc4b8986d8ff644e538d02 bb1a3ea50ff54fb592b8631460e39c86 a2b9eede354e4485ab5bfb895538762e--bb1a3ea50ff54fb592b8631460e39c86 6a714c33a41945128f797a991f837b9b bb1a3ea50ff54fb592b8631460e39c86--6a714c33a41945128f797a991f837b9b 25f96eb00ce54979a4f8ab53fd845e17 6a714c33a41945128f797a991f837b9b--25f96eb00ce54979a4f8ab53fd845e17 90154ed18f6042a5a7320973be7b328f 25f96eb00ce54979a4f8ab53fd845e17--90154ed18f6042a5a7320973be7b328f 9be1fc5374f44460a97753a11fb60b55 90154ed18f6042a5a7320973be7b328f--9be1fc5374f44460a97753a11fb60b55 c67606e064dd4b2baa6a9e84ff017dc0 X 9be1fc5374f44460a97753a11fb60b55--c67606e064dd4b2baa6a9e84ff017dc0 c67606e064dd4b2baa6a9e84ff017dc0--65eb6436a51b4cb4abd5390ab067cca9 a6f7627474024f27bb83bfb3b4b1b842 c67606e064dd4b2baa6a9e84ff017dc0--a6f7627474024f27bb83bfb3b4b1b842 5d30b40401f74bbc9e5c860acbdfc8d8 a6f7627474024f27bb83bfb3b4b1b842--5d30b40401f74bbc9e5c860acbdfc8d8 5e2679c87651463f96afd349de584c4c X 5d30b40401f74bbc9e5c860acbdfc8d8--5e2679c87651463f96afd349de584c4c 5e2679c87651463f96afd349de584c4c--3c19f1e442e24792b22b365cf70ce500 60184879d40e4007af90fefb7a444163 5e2679c87651463f96afd349de584c4c--60184879d40e4007af90fefb7a444163 2850b5cd804540e5995caee03deaf96a 60184879d40e4007af90fefb7a444163--2850b5cd804540e5995caee03deaf96a 74aa42d5fb914d32ada06661693a5062 2850b5cd804540e5995caee03deaf96a--74aa42d5fb914d32ada06661693a5062 7eda36c99c49455b8e32b7b83a755332 74aa42d5fb914d32ada06661693a5062--7eda36c99c49455b8e32b7b83a755332 17f3232def6141fabd8553dbe2286145 7eda36c99c49455b8e32b7b83a755332--17f3232def6141fabd8553dbe2286145 4c08b6665d0247ac9259359188006219 17f3232def6141fabd8553dbe2286145--4c08b6665d0247ac9259359188006219 9c6f091753c84bbe8aebce742828bb40 4c08b6665d0247ac9259359188006219--9c6f091753c84bbe8aebce742828bb40 28f42a6cb8de4183929cb4c44242d4ab X 9c6f091753c84bbe8aebce742828bb40--28f42a6cb8de4183929cb4c44242d4ab 28f42a6cb8de4183929cb4c44242d4ab--43247f05f80f4d0181b54113dafa7855 410b71f4a94248fbb560dcdd54c0e098 28f42a6cb8de4183929cb4c44242d4ab--410b71f4a94248fbb560dcdd54c0e098 c18895d943b447f09f5dde4f2350bd10 X 410b71f4a94248fbb560dcdd54c0e098--c18895d943b447f09f5dde4f2350bd10 c18895d943b447f09f5dde4f2350bd10--409ac98f1ff0483388a719b70b8db920 7dad9282bdc54910981394c89b83abd4 RZ(-1.0*g0) c18895d943b447f09f5dde4f2350bd10--7dad9282bdc54910981394c89b83abd4 3281b81983c44f9f8841eb35dfdbf2df X 7dad9282bdc54910981394c89b83abd4--3281b81983c44f9f8841eb35dfdbf2df 3281b81983c44f9f8841eb35dfdbf2df--d9f25a592f4945009e9a2ac5ff2178be 6d8a4ed874fb441d9779422a49b35530 X 3281b81983c44f9f8841eb35dfdbf2df--6d8a4ed874fb441d9779422a49b35530 6d8a4ed874fb441d9779422a49b35530--6dc4604d5cee461588e32210c9a0a138 90735ac3b98b4f7ab919d59b53acab5d 6d8a4ed874fb441d9779422a49b35530--90735ac3b98b4f7ab919d59b53acab5d dd528380a9ad4c99ba4d594b7e00ac06 90735ac3b98b4f7ab919d59b53acab5d--dd528380a9ad4c99ba4d594b7e00ac06 2aa3953137614d57b25236fc177ce9b2 dd528380a9ad4c99ba4d594b7e00ac06--2aa3953137614d57b25236fc177ce9b2 a2fb8001ed9a4db69d6488ff76b926a7 X 2aa3953137614d57b25236fc177ce9b2--a2fb8001ed9a4db69d6488ff76b926a7 a2fb8001ed9a4db69d6488ff76b926a7--44216244c25e4d8a88f321789ab1fd65 762ab182e86141d6b1c11e5f066cffa3 X a2fb8001ed9a4db69d6488ff76b926a7--762ab182e86141d6b1c11e5f066cffa3 762ab182e86141d6b1c11e5f066cffa3--2fe6b12453cc4e139dd11af23bca6319 c44c6864d10949c8b09c0b02fbc35e62 762ab182e86141d6b1c11e5f066cffa3--c44c6864d10949c8b09c0b02fbc35e62 170e3d989dd5482aa0ae7ac5d1291f46 c44c6864d10949c8b09c0b02fbc35e62--170e3d989dd5482aa0ae7ac5d1291f46 a3cc258525c24db2a307415bfcb4e104 170e3d989dd5482aa0ae7ac5d1291f46--a3cc258525c24db2a307415bfcb4e104 000fb2b201904a67b4d902b450327361 a3cc258525c24db2a307415bfcb4e104--000fb2b201904a67b4d902b450327361 6fd1c3bb18f64f00a50b451135b2012c 000fb2b201904a67b4d902b450327361--6fd1c3bb18f64f00a50b451135b2012c b74396cfff7a4054b0ea918d778d2b6e X 6fd1c3bb18f64f00a50b451135b2012c--b74396cfff7a4054b0ea918d778d2b6e b74396cfff7a4054b0ea918d778d2b6e--034d3cdd8ad94c52a0a24471b3dde736 576bc5db41b6477d86e08625c6e92f9b X b74396cfff7a4054b0ea918d778d2b6e--576bc5db41b6477d86e08625c6e92f9b 576bc5db41b6477d86e08625c6e92f9b--ed0104d04f504d4c8972b13a005cf679 f57f39a5fb8f40afa0fa22cf72b64929 576bc5db41b6477d86e08625c6e92f9b--f57f39a5fb8f40afa0fa22cf72b64929 aef8fc589f8f4825a618f6c3961c0e19 f57f39a5fb8f40afa0fa22cf72b64929--aef8fc589f8f4825a618f6c3961c0e19 c80e2854c1eb4def82cc70a9a7809cf5 aef8fc589f8f4825a618f6c3961c0e19--c80e2854c1eb4def82cc70a9a7809cf5 a5ac281bde234635a03cfad67d30ea76 c80e2854c1eb4def82cc70a9a7809cf5--a5ac281bde234635a03cfad67d30ea76 ec46ef5186834061a0f9f15e73188812 a5ac281bde234635a03cfad67d30ea76--ec46ef5186834061a0f9f15e73188812 3a47716f875f44248a79eee7ccc3c465 ec46ef5186834061a0f9f15e73188812--3a47716f875f44248a79eee7ccc3c465 b2036aa3e6d54dd7b8db20bb420dcb75 3a47716f875f44248a79eee7ccc3c465--b2036aa3e6d54dd7b8db20bb420dcb75 ce71482b76dd43fcb83986fe69add932 X b2036aa3e6d54dd7b8db20bb420dcb75--ce71482b76dd43fcb83986fe69add932 ce71482b76dd43fcb83986fe69add932--6b98ee7eba7a478a95c7e07849f54115 2b3c8586c8a64c5f8d62b4b50002bb1e X ce71482b76dd43fcb83986fe69add932--2b3c8586c8a64c5f8d62b4b50002bb1e 2b3c8586c8a64c5f8d62b4b50002bb1e--31fabdc1c09543638c4252e8f2ed840d 476c51123aa24f699e60b888e3a5f621 2b3c8586c8a64c5f8d62b4b50002bb1e--476c51123aa24f699e60b888e3a5f621 f0647363a0e04bc1a42869ccd8e65d2a 476c51123aa24f699e60b888e3a5f621--f0647363a0e04bc1a42869ccd8e65d2a d7141e9c3480445cac5be108bd57248c f0647363a0e04bc1a42869ccd8e65d2a--d7141e9c3480445cac5be108bd57248c 103cbbb9d18e411da8c6682c49be26a8 d7141e9c3480445cac5be108bd57248c--103cbbb9d18e411da8c6682c49be26a8 1cc430c639884a588068384ebe9eed5e 103cbbb9d18e411da8c6682c49be26a8--1cc430c639884a588068384ebe9eed5e b242298c5ca44be8893166d8b0be28c3 1cc430c639884a588068384ebe9eed5e--b242298c5ca44be8893166d8b0be28c3 8406629a50cd4685bec8da01497a75be b242298c5ca44be8893166d8b0be28c3--8406629a50cd4685bec8da01497a75be aa3a93f610fb47b899e3ae9fbad3ad37 8406629a50cd4685bec8da01497a75be--aa3a93f610fb47b899e3ae9fbad3ad37 71c7f2ed8123472785655991729ec62f aa3a93f610fb47b899e3ae9fbad3ad37--71c7f2ed8123472785655991729ec62f 3a5e94b0150644f4b8a9faffb8a67189 X 71c7f2ed8123472785655991729ec62f--3a5e94b0150644f4b8a9faffb8a67189 3a5e94b0150644f4b8a9faffb8a67189--9a2fb0df27b24e6fbe58dfd24717a309 8cd50d8c91f84b0b856c2d51d470a410 3a5e94b0150644f4b8a9faffb8a67189--8cd50d8c91f84b0b856c2d51d470a410 a7d365bb9ba54ec19f23a18ccdbeb82d 8cd50d8c91f84b0b856c2d51d470a410--a7d365bb9ba54ec19f23a18ccdbeb82d 2ec1fb3a3ce84606acc647becd2a457d a7d365bb9ba54ec19f23a18ccdbeb82d--2ec1fb3a3ce84606acc647becd2a457d 78525f9a176a4fad94892d7d0930b707 2ec1fb3a3ce84606acc647becd2a457d--78525f9a176a4fad94892d7d0930b707 d1ff4f72c8f54a97afbe2ea1c7860fe9 78525f9a176a4fad94892d7d0930b707--d1ff4f72c8f54a97afbe2ea1c7860fe9 9bf5a5e59aad4ad6a6c491aeffd31526 d1ff4f72c8f54a97afbe2ea1c7860fe9--9bf5a5e59aad4ad6a6c491aeffd31526 4183c2cda53f41eabe8dd5ffac5d7299 9bf5a5e59aad4ad6a6c491aeffd31526--4183c2cda53f41eabe8dd5ffac5d7299 1df236a70a9a46d3949798704f32e548 4183c2cda53f41eabe8dd5ffac5d7299--1df236a70a9a46d3949798704f32e548 69e9b9cdd25c474f97be9e37bda965bd 1df236a70a9a46d3949798704f32e548--69e9b9cdd25c474f97be9e37bda965bd abb93f13da334e958a733df1bf2aa6f9 69e9b9cdd25c474f97be9e37bda965bd--abb93f13da334e958a733df1bf2aa6f9 02195d50f1c94fa9b11092826ad49bb1 abb93f13da334e958a733df1bf2aa6f9--02195d50f1c94fa9b11092826ad49bb1 6328ddfe482042d8afb8bdda5b8452ab 02195d50f1c94fa9b11092826ad49bb1--6328ddfe482042d8afb8bdda5b8452ab 6164c14033c645e6b629336a96dc19f0 6328ddfe482042d8afb8bdda5b8452ab--6164c14033c645e6b629336a96dc19f0 b399d593599f494e80f076f5fe4795d1 6164c14033c645e6b629336a96dc19f0--b399d593599f494e80f076f5fe4795d1 6f3994c02b604e949af98f0bf3a4c0f6 b399d593599f494e80f076f5fe4795d1--6f3994c02b604e949af98f0bf3a4c0f6 0e2b6072a07f47bd9907ad3394fca40a 6f3994c02b604e949af98f0bf3a4c0f6--0e2b6072a07f47bd9907ad3394fca40a a8633e24f60e4678bf9bf17f5304fc50 RX(b03) 0e2b6072a07f47bd9907ad3394fca40a--a8633e24f60e4678bf9bf17f5304fc50 83f975edf08d478d902549bc0bc311b0 a8633e24f60e4678bf9bf17f5304fc50--83f975edf08d478d902549bc0bc311b0 a2dc5c9e7b4f40ebbe88e6835a4bd72e 83f975edf08d478d902549bc0bc311b0--a2dc5c9e7b4f40ebbe88e6835a4bd72e 8a4fd11bbed341c38d20e02cf2b8baf2 X a2dc5c9e7b4f40ebbe88e6835a4bd72e--8a4fd11bbed341c38d20e02cf2b8baf2 8a4fd11bbed341c38d20e02cf2b8baf2--c6a8db73b03d45759b093963fe3f447f e7a0900da4d14cfd863f010098b06cc8 8a4fd11bbed341c38d20e02cf2b8baf2--e7a0900da4d14cfd863f010098b06cc8 cccf0fabff2b4df6a1e2fe28c7faaa11 e7a0900da4d14cfd863f010098b06cc8--cccf0fabff2b4df6a1e2fe28c7faaa11 f7403cf84860476780fb00eacd4d4703 cccf0fabff2b4df6a1e2fe28c7faaa11--f7403cf84860476780fb00eacd4d4703 f7c60e0f08394b72b327b46626e822f3 f7403cf84860476780fb00eacd4d4703--f7c60e0f08394b72b327b46626e822f3 0da99205c0574e9a8e1a3fc363f611a7 f7c60e0f08394b72b327b46626e822f3--0da99205c0574e9a8e1a3fc363f611a7 80bbbdb145c4484b88da620a2228fc5f 0da99205c0574e9a8e1a3fc363f611a7--80bbbdb145c4484b88da620a2228fc5f 4d4069405cfc4e7aa1c6adab33ec6e87 80bbbdb145c4484b88da620a2228fc5f--4d4069405cfc4e7aa1c6adab33ec6e87 07e7e15b8b8d41e78b6ab4cff6988e62 4d4069405cfc4e7aa1c6adab33ec6e87--07e7e15b8b8d41e78b6ab4cff6988e62 1a720d7b91574b06887f1319ce1be22c 07e7e15b8b8d41e78b6ab4cff6988e62--1a720d7b91574b06887f1319ce1be22c 8c06d9fae22c438a92f197e975b074f4 X 1a720d7b91574b06887f1319ce1be22c--8c06d9fae22c438a92f197e975b074f4 8c06d9fae22c438a92f197e975b074f4--4b8cf0583de44bd3bde0716976dd0bca 9263f3d31cc94ea0b6debb07e049713d 8c06d9fae22c438a92f197e975b074f4--9263f3d31cc94ea0b6debb07e049713d 0c818cb3bb65421681e0bed4fb7f8488 9263f3d31cc94ea0b6debb07e049713d--0c818cb3bb65421681e0bed4fb7f8488 bfeb7ba8887b45879f96552d4df99503 0c818cb3bb65421681e0bed4fb7f8488--bfeb7ba8887b45879f96552d4df99503 5c6c1ad421014754b7cde6704a259011 bfeb7ba8887b45879f96552d4df99503--5c6c1ad421014754b7cde6704a259011 38b4a4958b6f455b9a49964e086e9a9c 5c6c1ad421014754b7cde6704a259011--38b4a4958b6f455b9a49964e086e9a9c 5009cfca82884dbca324fc5021a07b16 38b4a4958b6f455b9a49964e086e9a9c--5009cfca82884dbca324fc5021a07b16 3950288ab3904208a16ca2be422f8f9b 5009cfca82884dbca324fc5021a07b16--3950288ab3904208a16ca2be422f8f9b 3fa88ae2975a4c47a648cae97c5c58cf 3950288ab3904208a16ca2be422f8f9b--3fa88ae2975a4c47a648cae97c5c58cf 5774bf0ca8d5446b9fd3309e47895b02 3fa88ae2975a4c47a648cae97c5c58cf--5774bf0ca8d5446b9fd3309e47895b02 e08e1ae777ee4dc480ce0b362e47afa1 5774bf0ca8d5446b9fd3309e47895b02--e08e1ae777ee4dc480ce0b362e47afa1 00e79d4e25534969aeacc49274534678 e08e1ae777ee4dc480ce0b362e47afa1--00e79d4e25534969aeacc49274534678 695a8ebc77904eca834b8d84c1d4760c 00e79d4e25534969aeacc49274534678--695a8ebc77904eca834b8d84c1d4760c c8efcebf337d40dd9eea7b50376eebc5 X 695a8ebc77904eca834b8d84c1d4760c--c8efcebf337d40dd9eea7b50376eebc5 c8efcebf337d40dd9eea7b50376eebc5--21a626d7607541988c85e853421a2f09 1dcf523f102f4438946538d9c82eab8d RZ(-1.0*g1) c8efcebf337d40dd9eea7b50376eebc5--1dcf523f102f4438946538d9c82eab8d 8120ccd5a3514a688bfe8438cd6612ba X 1dcf523f102f4438946538d9c82eab8d--8120ccd5a3514a688bfe8438cd6612ba 8120ccd5a3514a688bfe8438cd6612ba--34fe8108bcff48a1a3ad910ada61c100 253a3d7f7f13405ab38ba35d447b7497 8120ccd5a3514a688bfe8438cd6612ba--253a3d7f7f13405ab38ba35d447b7497 c34f9fb1fbbd448d81b2adf8a9adbcd0 253a3d7f7f13405ab38ba35d447b7497--c34f9fb1fbbd448d81b2adf8a9adbcd0 be0f32d7022d48da8e7be45c6edb9547 c34f9fb1fbbd448d81b2adf8a9adbcd0--be0f32d7022d48da8e7be45c6edb9547 b352ae64b12d438da3cf6f7f1a5e8431 be0f32d7022d48da8e7be45c6edb9547--b352ae64b12d438da3cf6f7f1a5e8431 25c54464e7fa46eaa05397cadc426aec X b352ae64b12d438da3cf6f7f1a5e8431--25c54464e7fa46eaa05397cadc426aec 25c54464e7fa46eaa05397cadc426aec--7b5c585cd3aa479298615199aab91c7c 81acb6980bf74cf5b10a6710e18814ea 25c54464e7fa46eaa05397cadc426aec--81acb6980bf74cf5b10a6710e18814ea 7ae64a7a2e3e4aaeaf8aacfd5408f387 81acb6980bf74cf5b10a6710e18814ea--7ae64a7a2e3e4aaeaf8aacfd5408f387 89a0147784e94ea5a5192972b36cd7c1 7ae64a7a2e3e4aaeaf8aacfd5408f387--89a0147784e94ea5a5192972b36cd7c1 c73641f0cdba4613bc00d8555071bbd9 X 89a0147784e94ea5a5192972b36cd7c1--c73641f0cdba4613bc00d8555071bbd9 c73641f0cdba4613bc00d8555071bbd9--0f18cd04518a4a9d8b189c3e24303047 ea01c6f14eb34d0a9defbad78b1cb400 c73641f0cdba4613bc00d8555071bbd9--ea01c6f14eb34d0a9defbad78b1cb400 bce1d519e6c04cae9e6b96f3fe32c4e2 ea01c6f14eb34d0a9defbad78b1cb400--bce1d519e6c04cae9e6b96f3fe32c4e2 f239df935bc6490c8cc18aa9584b8dc4 bce1d519e6c04cae9e6b96f3fe32c4e2--f239df935bc6490c8cc18aa9584b8dc4 497b49e45ccd42d5884b959242459125 f239df935bc6490c8cc18aa9584b8dc4--497b49e45ccd42d5884b959242459125 55d829005aad469db871e4af0b0f7c8e 497b49e45ccd42d5884b959242459125--55d829005aad469db871e4af0b0f7c8e 0d7a518e8e784d6881360d40f84dccf6 55d829005aad469db871e4af0b0f7c8e--0d7a518e8e784d6881360d40f84dccf6 4b90cf511e2d41d8885e2c7e0f2b2dc9 X 0d7a518e8e784d6881360d40f84dccf6--4b90cf511e2d41d8885e2c7e0f2b2dc9 4b90cf511e2d41d8885e2c7e0f2b2dc9--47579dc7f93e4036b6050df727963df3 d9ca6e98c1c249d8b22f455291efe5ef RZ(-1.0*g1) 4b90cf511e2d41d8885e2c7e0f2b2dc9--d9ca6e98c1c249d8b22f455291efe5ef 67104b2c83484f2c8f95a3cb66decf03 X d9ca6e98c1c249d8b22f455291efe5ef--67104b2c83484f2c8f95a3cb66decf03 67104b2c83484f2c8f95a3cb66decf03--0663402cc7144507825154ad9d9447a7 bcaeefcbd3d143b19dec9f4ddc1a241d 67104b2c83484f2c8f95a3cb66decf03--bcaeefcbd3d143b19dec9f4ddc1a241d d5bd43654e73440b9828cd435c80fbf5 bcaeefcbd3d143b19dec9f4ddc1a241d--d5bd43654e73440b9828cd435c80fbf5 01cc57d6f0e547128869335e3f5b0e86 X d5bd43654e73440b9828cd435c80fbf5--01cc57d6f0e547128869335e3f5b0e86 01cc57d6f0e547128869335e3f5b0e86--37e52604636c4794882464f18e48bf4a 5632270eae274f5b95de73f5748dca1b 01cc57d6f0e547128869335e3f5b0e86--5632270eae274f5b95de73f5748dca1b d304ce18bd4c41278438aa61db64c6b0 5632270eae274f5b95de73f5748dca1b--d304ce18bd4c41278438aa61db64c6b0 3d17577104b34954aef34759421b5ca6 d304ce18bd4c41278438aa61db64c6b0--3d17577104b34954aef34759421b5ca6 667a72760eff4b408d19a80bdc6f1a3f 3d17577104b34954aef34759421b5ca6--667a72760eff4b408d19a80bdc6f1a3f 2444bc5e6d2248b792a5088c0ec8baaf 667a72760eff4b408d19a80bdc6f1a3f--2444bc5e6d2248b792a5088c0ec8baaf 6c543f4fb707456aad3c7e66b49f6d7f X 2444bc5e6d2248b792a5088c0ec8baaf--6c543f4fb707456aad3c7e66b49f6d7f 6c543f4fb707456aad3c7e66b49f6d7f--fb4fba828baf460097a926595efb1309 07919c0bcb09425da6f1ca479ee0ce10 6c543f4fb707456aad3c7e66b49f6d7f--07919c0bcb09425da6f1ca479ee0ce10 42f16a25e2d8421b8730f37f0d9f60c3 07919c0bcb09425da6f1ca479ee0ce10--42f16a25e2d8421b8730f37f0d9f60c3 a81e9501b8aa4e0d8b59680f1acf9695 X 42f16a25e2d8421b8730f37f0d9f60c3--a81e9501b8aa4e0d8b59680f1acf9695 a81e9501b8aa4e0d8b59680f1acf9695--5e982e123e07452fa26f057668e3bde5 e964bcc9438b438fbf24261cdf2873bd a81e9501b8aa4e0d8b59680f1acf9695--e964bcc9438b438fbf24261cdf2873bd 2eed8022924f4a7e95b3dafdeb81d5b2 e964bcc9438b438fbf24261cdf2873bd--2eed8022924f4a7e95b3dafdeb81d5b2 1f02d2593d144fa0a5b7b08b3645c1e3 2eed8022924f4a7e95b3dafdeb81d5b2--1f02d2593d144fa0a5b7b08b3645c1e3 033d0f3373074c4c85f8a830ee7385bd 1f02d2593d144fa0a5b7b08b3645c1e3--033d0f3373074c4c85f8a830ee7385bd b2fa3bd2d2664c1b943bbd52f906b606 033d0f3373074c4c85f8a830ee7385bd--b2fa3bd2d2664c1b943bbd52f906b606 853682fe29494167931f014742e4b125 b2fa3bd2d2664c1b943bbd52f906b606--853682fe29494167931f014742e4b125 66f5a50810e84659a6a5a5de5011f182 853682fe29494167931f014742e4b125--66f5a50810e84659a6a5a5de5011f182 01fe7c71e68845b194e2a28b7e3e496d X 66f5a50810e84659a6a5a5de5011f182--01fe7c71e68845b194e2a28b7e3e496d 01fe7c71e68845b194e2a28b7e3e496d--6fb5948d9abb43f29277ffa84990423f 3fd2a7415e0d45d392a8ceb68ed13d77 01fe7c71e68845b194e2a28b7e3e496d--3fd2a7415e0d45d392a8ceb68ed13d77 548a19780d044e12a1092a8e6ccf8198 X 3fd2a7415e0d45d392a8ceb68ed13d77--548a19780d044e12a1092a8e6ccf8198 548a19780d044e12a1092a8e6ccf8198--f0d38260e1aa49ab87f28ba470a0bbb8 a2f011a948a74e51b0f5a2d6156f830c RZ(-1.0*g1) 548a19780d044e12a1092a8e6ccf8198--a2f011a948a74e51b0f5a2d6156f830c c8ea1495eeae4fdd9f34b379b0a9ad0d X a2f011a948a74e51b0f5a2d6156f830c--c8ea1495eeae4fdd9f34b379b0a9ad0d c8ea1495eeae4fdd9f34b379b0a9ad0d--6dcc94246c55424eb6252fbb15f63c18 e9bc020c6130497489823046846390fa X c8ea1495eeae4fdd9f34b379b0a9ad0d--e9bc020c6130497489823046846390fa e9bc020c6130497489823046846390fa--1451fcec81454f34a043c0726912b097 8d6c8249737a4333b77af431bce2e2a1 e9bc020c6130497489823046846390fa--8d6c8249737a4333b77af431bce2e2a1 99507451e63c4220a2857fdcab875c24 8d6c8249737a4333b77af431bce2e2a1--99507451e63c4220a2857fdcab875c24 9a79356126a94a1fafd1de627e1ba620 99507451e63c4220a2857fdcab875c24--9a79356126a94a1fafd1de627e1ba620 0cc5c9b5848343a1a602e115fdd5b008 X 9a79356126a94a1fafd1de627e1ba620--0cc5c9b5848343a1a602e115fdd5b008 0cc5c9b5848343a1a602e115fdd5b008--c6f19ec826db49d68149c290a29cc8df a5e5293340254b32a59e37f1fb618c00 X 0cc5c9b5848343a1a602e115fdd5b008--a5e5293340254b32a59e37f1fb618c00 a5e5293340254b32a59e37f1fb618c00--0358b2fecc614e43a42533c02652828f 8dcee6c38677417dbc2d647f5e8505a4 a5e5293340254b32a59e37f1fb618c00--8dcee6c38677417dbc2d647f5e8505a4 035250e6ee5f48beb857ebd83194a69e 8dcee6c38677417dbc2d647f5e8505a4--035250e6ee5f48beb857ebd83194a69e 1feb738b284f4cfa9537dd624c6959ff 035250e6ee5f48beb857ebd83194a69e--1feb738b284f4cfa9537dd624c6959ff 6de4a5ec791f4bd1a147abc4f9b964bf 1feb738b284f4cfa9537dd624c6959ff--6de4a5ec791f4bd1a147abc4f9b964bf d969a67126bc45cabcee25655f7ab0aa 6de4a5ec791f4bd1a147abc4f9b964bf--d969a67126bc45cabcee25655f7ab0aa c659cd35758a4413aabb2e3291cc2a1d X d969a67126bc45cabcee25655f7ab0aa--c659cd35758a4413aabb2e3291cc2a1d c659cd35758a4413aabb2e3291cc2a1d--a7e5574934aa4b9ebfda6535f7dc51cc 2a50bd8e65634a43a7f7010f15066c43 X c659cd35758a4413aabb2e3291cc2a1d--2a50bd8e65634a43a7f7010f15066c43 2a50bd8e65634a43a7f7010f15066c43--bf2f6ed6889e44d0b2bcbc721a5fab14 df9561e28150495da6c9fd08b33f03e6 2a50bd8e65634a43a7f7010f15066c43--df9561e28150495da6c9fd08b33f03e6 a86e35acdac44c3bb413e5c5e0480ed6 df9561e28150495da6c9fd08b33f03e6--a86e35acdac44c3bb413e5c5e0480ed6 bb29257994ad4047a84d6fc03e0a774f a86e35acdac44c3bb413e5c5e0480ed6--bb29257994ad4047a84d6fc03e0a774f 8ea62f4ebb53435781f2a2be71fc8a66 bb29257994ad4047a84d6fc03e0a774f--8ea62f4ebb53435781f2a2be71fc8a66 749dd4404f0e480394fb3552ac339cab 8ea62f4ebb53435781f2a2be71fc8a66--749dd4404f0e480394fb3552ac339cab e3c9c127c1124a6b9caa6a6fa855c061 749dd4404f0e480394fb3552ac339cab--e3c9c127c1124a6b9caa6a6fa855c061 aa34c530d4bf40ed83ce1af16c4125fc e3c9c127c1124a6b9caa6a6fa855c061--aa34c530d4bf40ed83ce1af16c4125fc 72abcd0798de4eba8332a2a4912b03ce X aa34c530d4bf40ed83ce1af16c4125fc--72abcd0798de4eba8332a2a4912b03ce 72abcd0798de4eba8332a2a4912b03ce--465e348b4e6e4f09a1948ca5acb6cce5 2c43ffa81abb47b5a4573923d1e6877e X 72abcd0798de4eba8332a2a4912b03ce--2c43ffa81abb47b5a4573923d1e6877e 2c43ffa81abb47b5a4573923d1e6877e--4bb66497dd4143bf949fc61a6b8961f5 569c5c68cb4f4d30921c68d305fbc5a0 2c43ffa81abb47b5a4573923d1e6877e--569c5c68cb4f4d30921c68d305fbc5a0 f65790fa4c464816af8f41b9b80d114e 569c5c68cb4f4d30921c68d305fbc5a0--f65790fa4c464816af8f41b9b80d114e 2a313889d5aa4f3596306dca129b29a7 f65790fa4c464816af8f41b9b80d114e--2a313889d5aa4f3596306dca129b29a7 b7c5c793686d4a55ad2d44a14a804248 2a313889d5aa4f3596306dca129b29a7--b7c5c793686d4a55ad2d44a14a804248 52ae5762b0f44fd7a93c0d8b69a69d50 b7c5c793686d4a55ad2d44a14a804248--52ae5762b0f44fd7a93c0d8b69a69d50 41ef0305955243ccbb1264dadfc2a44b 52ae5762b0f44fd7a93c0d8b69a69d50--41ef0305955243ccbb1264dadfc2a44b 6637691ebe5b48feae7499c36dbc4b48 41ef0305955243ccbb1264dadfc2a44b--6637691ebe5b48feae7499c36dbc4b48 5c4a4aec4c2b46418cdd31e30ad99df5 6637691ebe5b48feae7499c36dbc4b48--5c4a4aec4c2b46418cdd31e30ad99df5 e87947e218474ebea42c6e7255a20a32 5c4a4aec4c2b46418cdd31e30ad99df5--e87947e218474ebea42c6e7255a20a32 4bdb7841138143f6acfc2b989c4e52de X e87947e218474ebea42c6e7255a20a32--4bdb7841138143f6acfc2b989c4e52de 4bdb7841138143f6acfc2b989c4e52de--3e652b94098e4829870c65f6a42e2e5b d1d3960b0c1244e5bb8b2865a6e2b318 4bdb7841138143f6acfc2b989c4e52de--d1d3960b0c1244e5bb8b2865a6e2b318 715ab183212241e9bb3956c551ab1c99 d1d3960b0c1244e5bb8b2865a6e2b318--715ab183212241e9bb3956c551ab1c99 9c1599743bb64976a72a46a25b0dd823 715ab183212241e9bb3956c551ab1c99--9c1599743bb64976a72a46a25b0dd823 a74deef5d1174bc792a0640d9eecdad0 9c1599743bb64976a72a46a25b0dd823--a74deef5d1174bc792a0640d9eecdad0 719f75b2e04b480097b115fdb48aa681 a74deef5d1174bc792a0640d9eecdad0--719f75b2e04b480097b115fdb48aa681 db56b4d6721e4bcc90b0de9799a7e48c 719f75b2e04b480097b115fdb48aa681--db56b4d6721e4bcc90b0de9799a7e48c 8674e86a920b49f38b5096b2504d9b06 db56b4d6721e4bcc90b0de9799a7e48c--8674e86a920b49f38b5096b2504d9b06 c31333f3ea814f4e8c1f9d0ac7adcfda 8674e86a920b49f38b5096b2504d9b06--c31333f3ea814f4e8c1f9d0ac7adcfda 38b48bf72cd64e85836b1f6d9566f709 c31333f3ea814f4e8c1f9d0ac7adcfda--38b48bf72cd64e85836b1f6d9566f709 e1d4d882d9334b72bdc61d211340c58a 38b48bf72cd64e85836b1f6d9566f709--e1d4d882d9334b72bdc61d211340c58a 33232a08cf2c42d699ac2e5adc708924 e1d4d882d9334b72bdc61d211340c58a--33232a08cf2c42d699ac2e5adc708924 d1417c20e96b4013ba2613ed4c42fc12 33232a08cf2c42d699ac2e5adc708924--d1417c20e96b4013ba2613ed4c42fc12 d9ab746951444434a3ecad2da677c8ba d1417c20e96b4013ba2613ed4c42fc12--d9ab746951444434a3ecad2da677c8ba 0dc5ed2cbf5c4cfb9e3510bd213344e7 d9ab746951444434a3ecad2da677c8ba--0dc5ed2cbf5c4cfb9e3510bd213344e7 e7d0b54776eb458b953c18d23d393216 0dc5ed2cbf5c4cfb9e3510bd213344e7--e7d0b54776eb458b953c18d23d393216 963223636f0c44a7848f7a66934b454b e7d0b54776eb458b953c18d23d393216--963223636f0c44a7848f7a66934b454b b62806cb649a4bb383d7c2ae33092fd9 RX(b13) 963223636f0c44a7848f7a66934b454b--b62806cb649a4bb383d7c2ae33092fd9 b62806cb649a4bb383d7c2ae33092fd9--0596b55cf6d447d294dc6defae28ac96 19df6313e0e2476fbb4008fe5e4b371e bd410ff12d274ebcaa5a491c49112793 03d3860f19974b789890ded62f0c6744--bd410ff12d274ebcaa5a491c49112793 973a00bf552242888e7377394950aed0 5 78151a4a8e1046d39a1580ac8f5910df bd410ff12d274ebcaa5a491c49112793--78151a4a8e1046d39a1580ac8f5910df 25fcfe2e39c4411a9c0e7e5b86f2fe5a 78151a4a8e1046d39a1580ac8f5910df--25fcfe2e39c4411a9c0e7e5b86f2fe5a ee93e3c4aa0c46c2b93a3b357869f0b0 X 25fcfe2e39c4411a9c0e7e5b86f2fe5a--ee93e3c4aa0c46c2b93a3b357869f0b0 ee93e3c4aa0c46c2b93a3b357869f0b0--cf42f1941e7741849d7372a9616b9c99 c6f549a8f76d419ca5f91070d209234d ee93e3c4aa0c46c2b93a3b357869f0b0--c6f549a8f76d419ca5f91070d209234d 630b174a33d5475c9027087871f30ff3 c6f549a8f76d419ca5f91070d209234d--630b174a33d5475c9027087871f30ff3 e5f7b9db12014e8b98eae3fdccce31fc 630b174a33d5475c9027087871f30ff3--e5f7b9db12014e8b98eae3fdccce31fc be238b886b0940998feab0c161814a0a e5f7b9db12014e8b98eae3fdccce31fc--be238b886b0940998feab0c161814a0a d35d4213424e4822907ac51b9d72b1e2 be238b886b0940998feab0c161814a0a--d35d4213424e4822907ac51b9d72b1e2 9127d9be56ab46ebb85be5ee2d271e33 d35d4213424e4822907ac51b9d72b1e2--9127d9be56ab46ebb85be5ee2d271e33 2dd130a6512b4738b42e531b5fced766 9127d9be56ab46ebb85be5ee2d271e33--2dd130a6512b4738b42e531b5fced766 a2f1ca9a011d4beda979e8a1be7f165e X 2dd130a6512b4738b42e531b5fced766--a2f1ca9a011d4beda979e8a1be7f165e a2f1ca9a011d4beda979e8a1be7f165e--68b1d86565d7442f8892b717ef515aa3 9238293bd1784beb930dc3332264ab2a a2f1ca9a011d4beda979e8a1be7f165e--9238293bd1784beb930dc3332264ab2a cda2294c7dec4584854f663f7226f0b9 9238293bd1784beb930dc3332264ab2a--cda2294c7dec4584854f663f7226f0b9 815b41ad30cc4221b8d499ce00c0a355 cda2294c7dec4584854f663f7226f0b9--815b41ad30cc4221b8d499ce00c0a355 d4d0acedee534495816e3ef09b830cb2 815b41ad30cc4221b8d499ce00c0a355--d4d0acedee534495816e3ef09b830cb2 30ca10145095409c98ab43a936fd1e3a d4d0acedee534495816e3ef09b830cb2--30ca10145095409c98ab43a936fd1e3a 5c61218166844590ac26231368ae6bf9 30ca10145095409c98ab43a936fd1e3a--5c61218166844590ac26231368ae6bf9 df2adb0adb784763876d17b0208c4f64 5c61218166844590ac26231368ae6bf9--df2adb0adb784763876d17b0208c4f64 b653dd33cb244158821bbf1f450c0727 df2adb0adb784763876d17b0208c4f64--b653dd33cb244158821bbf1f450c0727 fb7d29feb9c84a0f95b9fa5bf8f7c7dc b653dd33cb244158821bbf1f450c0727--fb7d29feb9c84a0f95b9fa5bf8f7c7dc 057070a8648e479cb9bb2c35914f7e4c fb7d29feb9c84a0f95b9fa5bf8f7c7dc--057070a8648e479cb9bb2c35914f7e4c f19b8ef5641046549c31f2d3adc1485b 057070a8648e479cb9bb2c35914f7e4c--f19b8ef5641046549c31f2d3adc1485b 9a5b5045c09f4d1198f3ca7f95991e1f f19b8ef5641046549c31f2d3adc1485b--9a5b5045c09f4d1198f3ca7f95991e1f b7a6ba5073a84400a1aad1118935530d 9a5b5045c09f4d1198f3ca7f95991e1f--b7a6ba5073a84400a1aad1118935530d 94cc7821a3854d6291ab16ece79eaf8b b7a6ba5073a84400a1aad1118935530d--94cc7821a3854d6291ab16ece79eaf8b 7e6071d4cad042bd9b5d206f1ec8d205 94cc7821a3854d6291ab16ece79eaf8b--7e6071d4cad042bd9b5d206f1ec8d205 8d2aac45fda143f29f2e913d20ba63f9 7e6071d4cad042bd9b5d206f1ec8d205--8d2aac45fda143f29f2e913d20ba63f9 e86d2a052af24e1da77e106271df0e7d 8d2aac45fda143f29f2e913d20ba63f9--e86d2a052af24e1da77e106271df0e7d 5025e7ec06c343cd878e67d0eec42cbc e86d2a052af24e1da77e106271df0e7d--5025e7ec06c343cd878e67d0eec42cbc 2620c95055fb47ffa245324dccf429e9 5025e7ec06c343cd878e67d0eec42cbc--2620c95055fb47ffa245324dccf429e9 5995564e78a3448f8e7c44cdd8d88baa 2620c95055fb47ffa245324dccf429e9--5995564e78a3448f8e7c44cdd8d88baa 9dac560b388441d5977ed6474cedd56f 5995564e78a3448f8e7c44cdd8d88baa--9dac560b388441d5977ed6474cedd56f 11f7bcef8b9448cbbae7c1fe9ddc954e X 9dac560b388441d5977ed6474cedd56f--11f7bcef8b9448cbbae7c1fe9ddc954e 11f7bcef8b9448cbbae7c1fe9ddc954e--0a6b1b5c61e442319ba02b906469f2c4 f07f16846d6b434ea654e5fad5573a85 RZ(-1.0*g0) 11f7bcef8b9448cbbae7c1fe9ddc954e--f07f16846d6b434ea654e5fad5573a85 96323329e63f4a9c82364b48832ded1f X f07f16846d6b434ea654e5fad5573a85--96323329e63f4a9c82364b48832ded1f 96323329e63f4a9c82364b48832ded1f--3fb7627a6f7d4013a6869093ee107efa 67c84435b64c4c66ab8c98b7329fed18 96323329e63f4a9c82364b48832ded1f--67c84435b64c4c66ab8c98b7329fed18 1c53d6e28f954b2bb3a2bc043dca23b9 67c84435b64c4c66ab8c98b7329fed18--1c53d6e28f954b2bb3a2bc043dca23b9 c703f49219c1416a9e55bc5ca580c79b 1c53d6e28f954b2bb3a2bc043dca23b9--c703f49219c1416a9e55bc5ca580c79b a2e6708cee044db8aa819f4dbd2214b2 c703f49219c1416a9e55bc5ca580c79b--a2e6708cee044db8aa819f4dbd2214b2 e4fd3549bb0943ee968995fa21b7ef34 a2e6708cee044db8aa819f4dbd2214b2--e4fd3549bb0943ee968995fa21b7ef34 01dc494ea48f414cbdad1ead708db831 e4fd3549bb0943ee968995fa21b7ef34--01dc494ea48f414cbdad1ead708db831 a73b29d746ad466c99a47cd8a8649828 01dc494ea48f414cbdad1ead708db831--a73b29d746ad466c99a47cd8a8649828 99eb21f8ce594bd794bb0bf1aeb9c6f6 a73b29d746ad466c99a47cd8a8649828--99eb21f8ce594bd794bb0bf1aeb9c6f6 36711e1982984cc8979d2e32651c4b9f 99eb21f8ce594bd794bb0bf1aeb9c6f6--36711e1982984cc8979d2e32651c4b9f 4b11f5701e0344d4af3da62bdf2de8b8 36711e1982984cc8979d2e32651c4b9f--4b11f5701e0344d4af3da62bdf2de8b8 633659ff05ef4990b5edaa66b974fd6c 4b11f5701e0344d4af3da62bdf2de8b8--633659ff05ef4990b5edaa66b974fd6c 9770690ba22b4e58a3e8cae6ef5db3b8 633659ff05ef4990b5edaa66b974fd6c--9770690ba22b4e58a3e8cae6ef5db3b8 2783985d75d742aa9e29bfd5a65468c3 9770690ba22b4e58a3e8cae6ef5db3b8--2783985d75d742aa9e29bfd5a65468c3 0ff61a8edaaf4fccb12a81b3788409ab X 2783985d75d742aa9e29bfd5a65468c3--0ff61a8edaaf4fccb12a81b3788409ab 0ff61a8edaaf4fccb12a81b3788409ab--bb1a3ea50ff54fb592b8631460e39c86 64996dcefb364affb4a0628d2a40fe36 0ff61a8edaaf4fccb12a81b3788409ab--64996dcefb364affb4a0628d2a40fe36 b590bed311eb450598009ad048425465 64996dcefb364affb4a0628d2a40fe36--b590bed311eb450598009ad048425465 1ae87266b8e54594a0bc777aa026bcc9 b590bed311eb450598009ad048425465--1ae87266b8e54594a0bc777aa026bcc9 e61c451037c64edb919ae1671cac61d6 X 1ae87266b8e54594a0bc777aa026bcc9--e61c451037c64edb919ae1671cac61d6 e61c451037c64edb919ae1671cac61d6--9be1fc5374f44460a97753a11fb60b55 d1b1673169b14c2d97c2d624832bb661 e61c451037c64edb919ae1671cac61d6--d1b1673169b14c2d97c2d624832bb661 e0bfd40c464b46f6baebfc6a254b0d36 d1b1673169b14c2d97c2d624832bb661--e0bfd40c464b46f6baebfc6a254b0d36 0ed73e5d0c3d4bbd9cd3742ca1d6726b e0bfd40c464b46f6baebfc6a254b0d36--0ed73e5d0c3d4bbd9cd3742ca1d6726b e6756f48e5c1404fb7ff9b7172590b1e 0ed73e5d0c3d4bbd9cd3742ca1d6726b--e6756f48e5c1404fb7ff9b7172590b1e e96781952fc149d58d1c5367d84b4b97 X e6756f48e5c1404fb7ff9b7172590b1e--e96781952fc149d58d1c5367d84b4b97 e96781952fc149d58d1c5367d84b4b97--60184879d40e4007af90fefb7a444163 5c5e9228ad69446683fa0306e807b6c1 e96781952fc149d58d1c5367d84b4b97--5c5e9228ad69446683fa0306e807b6c1 d2b1b0b58d464d0482e1dbfeecae603b 5c5e9228ad69446683fa0306e807b6c1--d2b1b0b58d464d0482e1dbfeecae603b ecfe3cf087034fed874858da80ab5b19 d2b1b0b58d464d0482e1dbfeecae603b--ecfe3cf087034fed874858da80ab5b19 6f879c87062843a2b0419831fb8f6253 ecfe3cf087034fed874858da80ab5b19--6f879c87062843a2b0419831fb8f6253 c35046d9d0144142b7d4757dd8f1f8b1 6f879c87062843a2b0419831fb8f6253--c35046d9d0144142b7d4757dd8f1f8b1 c183ca3707694f668cdf252c1bd40a25 X c35046d9d0144142b7d4757dd8f1f8b1--c183ca3707694f668cdf252c1bd40a25 c183ca3707694f668cdf252c1bd40a25--9c6f091753c84bbe8aebce742828bb40 777631f235ec4aae89d2367c3b673d66 c183ca3707694f668cdf252c1bd40a25--777631f235ec4aae89d2367c3b673d66 d36c8962fb414f64876bbf460a3c661d 777631f235ec4aae89d2367c3b673d66--d36c8962fb414f64876bbf460a3c661d afd16ec21a464c4388f981ad15bc92cf d36c8962fb414f64876bbf460a3c661d--afd16ec21a464c4388f981ad15bc92cf 41e7dc0e2ff7402c8211312058d5f272 afd16ec21a464c4388f981ad15bc92cf--41e7dc0e2ff7402c8211312058d5f272 fea95d762590461486207cf1158cf427 41e7dc0e2ff7402c8211312058d5f272--fea95d762590461486207cf1158cf427 55b11f9dd8b44bf38f54cfdb16d2118e fea95d762590461486207cf1158cf427--55b11f9dd8b44bf38f54cfdb16d2118e 145ff61506a14065b2d02d401d9e28fb X 55b11f9dd8b44bf38f54cfdb16d2118e--145ff61506a14065b2d02d401d9e28fb 145ff61506a14065b2d02d401d9e28fb--90735ac3b98b4f7ab919d59b53acab5d c310e2209dc44a1e883b9432c64bebb3 RZ(-1.0*g0) 145ff61506a14065b2d02d401d9e28fb--c310e2209dc44a1e883b9432c64bebb3 78dc87b363d64233844c40670a38c2ce X c310e2209dc44a1e883b9432c64bebb3--78dc87b363d64233844c40670a38c2ce 78dc87b363d64233844c40670a38c2ce--2aa3953137614d57b25236fc177ce9b2 70f25e8121d04ba89ad673218e7263c6 78dc87b363d64233844c40670a38c2ce--70f25e8121d04ba89ad673218e7263c6 d144dddafbaa459399bbb623adbced48 70f25e8121d04ba89ad673218e7263c6--d144dddafbaa459399bbb623adbced48 4237a9f965b4442bbf3871e5b1f96efd X d144dddafbaa459399bbb623adbced48--4237a9f965b4442bbf3871e5b1f96efd 4237a9f965b4442bbf3871e5b1f96efd--c44c6864d10949c8b09c0b02fbc35e62 ef176b1637d54c56a45a19d25f6b0431 4237a9f965b4442bbf3871e5b1f96efd--ef176b1637d54c56a45a19d25f6b0431 c6e8da91c3dc4678b2413cfc7b4f055e ef176b1637d54c56a45a19d25f6b0431--c6e8da91c3dc4678b2413cfc7b4f055e cb8e5aa3eea94fbc95f49db7e679c9f2 c6e8da91c3dc4678b2413cfc7b4f055e--cb8e5aa3eea94fbc95f49db7e679c9f2 e41084b75f314ceaaea6ac95edbdf630 X cb8e5aa3eea94fbc95f49db7e679c9f2--e41084b75f314ceaaea6ac95edbdf630 e41084b75f314ceaaea6ac95edbdf630--6fd1c3bb18f64f00a50b451135b2012c 992ebf7079d34134be46e16abc1e5141 e41084b75f314ceaaea6ac95edbdf630--992ebf7079d34134be46e16abc1e5141 179aed1bd2cb4cc8a94fdfa8e9150da6 992ebf7079d34134be46e16abc1e5141--179aed1bd2cb4cc8a94fdfa8e9150da6 30a171d5e7b34d0a96ae3c41c191de7a X 179aed1bd2cb4cc8a94fdfa8e9150da6--30a171d5e7b34d0a96ae3c41c191de7a 30a171d5e7b34d0a96ae3c41c191de7a--f57f39a5fb8f40afa0fa22cf72b64929 ca326d9ad7fa4a08b5a1915a37d47e5f 30a171d5e7b34d0a96ae3c41c191de7a--ca326d9ad7fa4a08b5a1915a37d47e5f 8b9f0ae8757f4348a1ad434b8a4f11cf ca326d9ad7fa4a08b5a1915a37d47e5f--8b9f0ae8757f4348a1ad434b8a4f11cf 9fd3a7d3a00c4b7599252a86b5b79de5 8b9f0ae8757f4348a1ad434b8a4f11cf--9fd3a7d3a00c4b7599252a86b5b79de5 96f38bb18c1d45f989fe832da4599afb 9fd3a7d3a00c4b7599252a86b5b79de5--96f38bb18c1d45f989fe832da4599afb 02d1aa1f3f02461082d588ed2b27f236 96f38bb18c1d45f989fe832da4599afb--02d1aa1f3f02461082d588ed2b27f236 138367dd4cb244fb9192f6639412bff0 X 02d1aa1f3f02461082d588ed2b27f236--138367dd4cb244fb9192f6639412bff0 138367dd4cb244fb9192f6639412bff0--b2036aa3e6d54dd7b8db20bb420dcb75 7cc60a71c6964080b4a40f2c9a13a5ed 138367dd4cb244fb9192f6639412bff0--7cc60a71c6964080b4a40f2c9a13a5ed be1f9ff5e6ad483fb8d9b3b36ebfbc90 7cc60a71c6964080b4a40f2c9a13a5ed--be1f9ff5e6ad483fb8d9b3b36ebfbc90 a3f85da5669749f4ae75abfd58dd25c3 X be1f9ff5e6ad483fb8d9b3b36ebfbc90--a3f85da5669749f4ae75abfd58dd25c3 a3f85da5669749f4ae75abfd58dd25c3--476c51123aa24f699e60b888e3a5f621 1749a2ee85c44b11b000a9311f440672 a3f85da5669749f4ae75abfd58dd25c3--1749a2ee85c44b11b000a9311f440672 ee1797bfe4454ca9a23a319d0e28e97a 1749a2ee85c44b11b000a9311f440672--ee1797bfe4454ca9a23a319d0e28e97a 72d2a28522c04eafb00572592db3b733 ee1797bfe4454ca9a23a319d0e28e97a--72d2a28522c04eafb00572592db3b733 40474eb63e0b4610bc250ef904ceb7c9 72d2a28522c04eafb00572592db3b733--40474eb63e0b4610bc250ef904ceb7c9 f564e55e182c4f77a0721cb3c3bec300 40474eb63e0b4610bc250ef904ceb7c9--f564e55e182c4f77a0721cb3c3bec300 c6c04907ce914c8b82782463ba2480a6 f564e55e182c4f77a0721cb3c3bec300--c6c04907ce914c8b82782463ba2480a6 81ff035616784b008d71996b3c6a3a7f c6c04907ce914c8b82782463ba2480a6--81ff035616784b008d71996b3c6a3a7f e15acf312d34446583a988e2a3183d73 X 81ff035616784b008d71996b3c6a3a7f--e15acf312d34446583a988e2a3183d73 e15acf312d34446583a988e2a3183d73--71c7f2ed8123472785655991729ec62f dbf6c1c7c17e445098f714fc11523a86 e15acf312d34446583a988e2a3183d73--dbf6c1c7c17e445098f714fc11523a86 dbfb4ad0d8dc40d39f00f319c3acda3a X dbf6c1c7c17e445098f714fc11523a86--dbfb4ad0d8dc40d39f00f319c3acda3a dbfb4ad0d8dc40d39f00f319c3acda3a--8cd50d8c91f84b0b856c2d51d470a410 8650802453d34804a3b65c88560c7ad4 dbfb4ad0d8dc40d39f00f319c3acda3a--8650802453d34804a3b65c88560c7ad4 305f89c1420b4a0fb8c268679ba0bb01 8650802453d34804a3b65c88560c7ad4--305f89c1420b4a0fb8c268679ba0bb01 f4196d93234e4660ae7986e90b6b0798 305f89c1420b4a0fb8c268679ba0bb01--f4196d93234e4660ae7986e90b6b0798 1f32c1acb08a46d5bb65c1b7717184db f4196d93234e4660ae7986e90b6b0798--1f32c1acb08a46d5bb65c1b7717184db 021c59c0d8d34eec97d551cb48741068 1f32c1acb08a46d5bb65c1b7717184db--021c59c0d8d34eec97d551cb48741068 7e02188b24bf44989f80e83e1256d22f 021c59c0d8d34eec97d551cb48741068--7e02188b24bf44989f80e83e1256d22f ddc0e4019ab74addac153c800def84ae 7e02188b24bf44989f80e83e1256d22f--ddc0e4019ab74addac153c800def84ae 173c894e4f6448ffa68f9cfcf5a4dd98 X ddc0e4019ab74addac153c800def84ae--173c894e4f6448ffa68f9cfcf5a4dd98 173c894e4f6448ffa68f9cfcf5a4dd98--69e9b9cdd25c474f97be9e37bda965bd b7b6103bcd6b4e2bb53391c3327fba1c 173c894e4f6448ffa68f9cfcf5a4dd98--b7b6103bcd6b4e2bb53391c3327fba1c 38add2423d7647ee9aa091d301dbfc21 b7b6103bcd6b4e2bb53391c3327fba1c--38add2423d7647ee9aa091d301dbfc21 a1da563ac9c1454ca860942250bd187d 38add2423d7647ee9aa091d301dbfc21--a1da563ac9c1454ca860942250bd187d 284039f92dc74aee95d6407ba68109ac a1da563ac9c1454ca860942250bd187d--284039f92dc74aee95d6407ba68109ac 38cae22eb3724d699fd4402a4380aafc 284039f92dc74aee95d6407ba68109ac--38cae22eb3724d699fd4402a4380aafc d85b5375e4ee457eb0d32658ddbd5c2a 38cae22eb3724d699fd4402a4380aafc--d85b5375e4ee457eb0d32658ddbd5c2a b40cedeab29f4ba892a944b76e958973 d85b5375e4ee457eb0d32658ddbd5c2a--b40cedeab29f4ba892a944b76e958973 bdf3f462eb5a423c8fbd100ded5de6ed RX(b04) b40cedeab29f4ba892a944b76e958973--bdf3f462eb5a423c8fbd100ded5de6ed 3c9745eeddda4fb297e5c9abcf805113 bdf3f462eb5a423c8fbd100ded5de6ed--3c9745eeddda4fb297e5c9abcf805113 a8f078d5cea744239c47e371be4c36aa 3c9745eeddda4fb297e5c9abcf805113--a8f078d5cea744239c47e371be4c36aa 8df02355bc4d4bcd9a602d9133cd002a a8f078d5cea744239c47e371be4c36aa--8df02355bc4d4bcd9a602d9133cd002a 13ae07b1e0c14aacbab9e30795df70e3 X 8df02355bc4d4bcd9a602d9133cd002a--13ae07b1e0c14aacbab9e30795df70e3 13ae07b1e0c14aacbab9e30795df70e3--e7a0900da4d14cfd863f010098b06cc8 a21c8c32cb9649faa1c1b63d54ab3cf7 13ae07b1e0c14aacbab9e30795df70e3--a21c8c32cb9649faa1c1b63d54ab3cf7 abe85b7c3e8e4fe3b5da6d4a67e872c0 a21c8c32cb9649faa1c1b63d54ab3cf7--abe85b7c3e8e4fe3b5da6d4a67e872c0 6e85aa16c6e04ad4939ac91c7bbc920a abe85b7c3e8e4fe3b5da6d4a67e872c0--6e85aa16c6e04ad4939ac91c7bbc920a d396ac47952045899148e65fdc8b413e 6e85aa16c6e04ad4939ac91c7bbc920a--d396ac47952045899148e65fdc8b413e fc9338a95d004f5b8d0aff3708356e2f d396ac47952045899148e65fdc8b413e--fc9338a95d004f5b8d0aff3708356e2f d30306790de54d108ed37209e2bc3483 fc9338a95d004f5b8d0aff3708356e2f--d30306790de54d108ed37209e2bc3483 6b39ca1bc7014b63ad14b0a626ba22e3 d30306790de54d108ed37209e2bc3483--6b39ca1bc7014b63ad14b0a626ba22e3 d31fac8d8e074eb8868db0a062d122a9 X 6b39ca1bc7014b63ad14b0a626ba22e3--d31fac8d8e074eb8868db0a062d122a9 d31fac8d8e074eb8868db0a062d122a9--1a720d7b91574b06887f1319ce1be22c 5577429db0614ff9bc620786485a190a d31fac8d8e074eb8868db0a062d122a9--5577429db0614ff9bc620786485a190a 3206c71b81054402a1c0079ad093beb5 5577429db0614ff9bc620786485a190a--3206c71b81054402a1c0079ad093beb5 d4a9216e85f94621ade179cceaabffc4 3206c71b81054402a1c0079ad093beb5--d4a9216e85f94621ade179cceaabffc4 8ab69658750d40db9ca1f9aa14f4dd84 d4a9216e85f94621ade179cceaabffc4--8ab69658750d40db9ca1f9aa14f4dd84 3ccb3a5b853c478596c5b0b356e14f96 8ab69658750d40db9ca1f9aa14f4dd84--3ccb3a5b853c478596c5b0b356e14f96 a11fe51cb68b44748a6fb49c04791969 3ccb3a5b853c478596c5b0b356e14f96--a11fe51cb68b44748a6fb49c04791969 07cb2ac0fa794a56a59c9ee647f75497 a11fe51cb68b44748a6fb49c04791969--07cb2ac0fa794a56a59c9ee647f75497 d67f5abc8f2a4967825369c363dce8b8 07cb2ac0fa794a56a59c9ee647f75497--d67f5abc8f2a4967825369c363dce8b8 cb955a5cdf8f4a27bb43821c6b9e2d0a d67f5abc8f2a4967825369c363dce8b8--cb955a5cdf8f4a27bb43821c6b9e2d0a 0f5e40183731413ab0ceafc13429050e cb955a5cdf8f4a27bb43821c6b9e2d0a--0f5e40183731413ab0ceafc13429050e 50ac1d2bd7194f8ab0009fb36fe3ea6c 0f5e40183731413ab0ceafc13429050e--50ac1d2bd7194f8ab0009fb36fe3ea6c 22c1587f054e4f2ab8eaf0e6a1496c65 50ac1d2bd7194f8ab0009fb36fe3ea6c--22c1587f054e4f2ab8eaf0e6a1496c65 f5a79a38db3c4220b49b466980edf984 22c1587f054e4f2ab8eaf0e6a1496c65--f5a79a38db3c4220b49b466980edf984 e320605ea37343d2a7d475202acc4114 f5a79a38db3c4220b49b466980edf984--e320605ea37343d2a7d475202acc4114 54de2c2424ad4932b2a1bdbd934ec73f e320605ea37343d2a7d475202acc4114--54de2c2424ad4932b2a1bdbd934ec73f 1df02a9eda034363b9959ffb90f166d5 54de2c2424ad4932b2a1bdbd934ec73f--1df02a9eda034363b9959ffb90f166d5 554bc8252f4846d49e9a474466d3cbe7 1df02a9eda034363b9959ffb90f166d5--554bc8252f4846d49e9a474466d3cbe7 16a80e6a1dc6436c85093261bea5d900 554bc8252f4846d49e9a474466d3cbe7--16a80e6a1dc6436c85093261bea5d900 60966cef91f94cb094d75106ccc147c8 16a80e6a1dc6436c85093261bea5d900--60966cef91f94cb094d75106ccc147c8 3b75865ba5cf4c62a2bcb732cd2a5031 60966cef91f94cb094d75106ccc147c8--3b75865ba5cf4c62a2bcb732cd2a5031 9a586a68c4054b65b9aa94afd23900d3 3b75865ba5cf4c62a2bcb732cd2a5031--9a586a68c4054b65b9aa94afd23900d3 9d5a272b70474fcaa5a386ae9b666d86 X 9a586a68c4054b65b9aa94afd23900d3--9d5a272b70474fcaa5a386ae9b666d86 9d5a272b70474fcaa5a386ae9b666d86--81acb6980bf74cf5b10a6710e18814ea 1d4e599ce0934fc0aaadc77416de6c3a RZ(-1.0*g1) 9d5a272b70474fcaa5a386ae9b666d86--1d4e599ce0934fc0aaadc77416de6c3a bfa6f435c5e248d596794151cc0fc88c X 1d4e599ce0934fc0aaadc77416de6c3a--bfa6f435c5e248d596794151cc0fc88c bfa6f435c5e248d596794151cc0fc88c--89a0147784e94ea5a5192972b36cd7c1 c0a9cc819d924599833eb299b760dd56 bfa6f435c5e248d596794151cc0fc88c--c0a9cc819d924599833eb299b760dd56 c66b32bfb18a4948be6c693739ad19bf c0a9cc819d924599833eb299b760dd56--c66b32bfb18a4948be6c693739ad19bf 4bdc0013345a483986863d46930308d5 c66b32bfb18a4948be6c693739ad19bf--4bdc0013345a483986863d46930308d5 c7f5275f14954670b6c82a3a48d416fc 4bdc0013345a483986863d46930308d5--c7f5275f14954670b6c82a3a48d416fc 8520daafa04540e6a7891192f6370c61 c7f5275f14954670b6c82a3a48d416fc--8520daafa04540e6a7891192f6370c61 f9df898fe58b4033b0d1c07a153362c4 8520daafa04540e6a7891192f6370c61--f9df898fe58b4033b0d1c07a153362c4 d49d966b217147768126bf6f926108d4 f9df898fe58b4033b0d1c07a153362c4--d49d966b217147768126bf6f926108d4 817893e62a1e40e9936756757ec87777 d49d966b217147768126bf6f926108d4--817893e62a1e40e9936756757ec87777 534dff1306764d1eb3cb13bef2b05696 817893e62a1e40e9936756757ec87777--534dff1306764d1eb3cb13bef2b05696 bd22915ec4d44b8bab15eb8ba05f374d 534dff1306764d1eb3cb13bef2b05696--bd22915ec4d44b8bab15eb8ba05f374d 1d1bf1d6973c487eae18f54c3f44b257 bd22915ec4d44b8bab15eb8ba05f374d--1d1bf1d6973c487eae18f54c3f44b257 2fd94cadd7a54ebe82f1120aafc05458 1d1bf1d6973c487eae18f54c3f44b257--2fd94cadd7a54ebe82f1120aafc05458 f2e087fb30894b79bf2f9da3dd587a72 2fd94cadd7a54ebe82f1120aafc05458--f2e087fb30894b79bf2f9da3dd587a72 18270dd845ee476aaca1fe24bb2b7df3 X f2e087fb30894b79bf2f9da3dd587a72--18270dd845ee476aaca1fe24bb2b7df3 18270dd845ee476aaca1fe24bb2b7df3--5632270eae274f5b95de73f5748dca1b 482b352a74ad485b943d9479f0ba2d93 18270dd845ee476aaca1fe24bb2b7df3--482b352a74ad485b943d9479f0ba2d93 2664149b5d1044dabba633bfb4f66290 482b352a74ad485b943d9479f0ba2d93--2664149b5d1044dabba633bfb4f66290 c1833393bd394ac18ed99f818e759b05 2664149b5d1044dabba633bfb4f66290--c1833393bd394ac18ed99f818e759b05 168ab0e0892b4fb691905bb281242b10 X c1833393bd394ac18ed99f818e759b05--168ab0e0892b4fb691905bb281242b10 168ab0e0892b4fb691905bb281242b10--2444bc5e6d2248b792a5088c0ec8baaf 1cb6eee4f9534a468abde0c8df980ff0 168ab0e0892b4fb691905bb281242b10--1cb6eee4f9534a468abde0c8df980ff0 ad7c1ba6434b46728fcff7d6a86ada6a 1cb6eee4f9534a468abde0c8df980ff0--ad7c1ba6434b46728fcff7d6a86ada6a 7144774098a54d3cb2a931dc3c2b291c ad7c1ba6434b46728fcff7d6a86ada6a--7144774098a54d3cb2a931dc3c2b291c 0694790edb51433c9448abd73f3b3015 7144774098a54d3cb2a931dc3c2b291c--0694790edb51433c9448abd73f3b3015 b3eca41ba5124e4f91d906fa10db8214 X 0694790edb51433c9448abd73f3b3015--b3eca41ba5124e4f91d906fa10db8214 b3eca41ba5124e4f91d906fa10db8214--e964bcc9438b438fbf24261cdf2873bd b6c6b403ecfd4aeb8e08f21490d980a3 b3eca41ba5124e4f91d906fa10db8214--b6c6b403ecfd4aeb8e08f21490d980a3 c23d92982ad648f3a590936950d126e6 b6c6b403ecfd4aeb8e08f21490d980a3--c23d92982ad648f3a590936950d126e6 eab4ab6622774c4d98e505575aaec70c c23d92982ad648f3a590936950d126e6--eab4ab6622774c4d98e505575aaec70c 9f6fcaae4d0c4855be9e7469329a7f31 eab4ab6622774c4d98e505575aaec70c--9f6fcaae4d0c4855be9e7469329a7f31 5ae73d0b54c343e782e651c24824099d 9f6fcaae4d0c4855be9e7469329a7f31--5ae73d0b54c343e782e651c24824099d c26228af747d49dba6186d5743142c3a X 5ae73d0b54c343e782e651c24824099d--c26228af747d49dba6186d5743142c3a c26228af747d49dba6186d5743142c3a--66f5a50810e84659a6a5a5de5011f182 99582d35f25045669886708a69f7a143 c26228af747d49dba6186d5743142c3a--99582d35f25045669886708a69f7a143 329c0a38f9324134b1e02d8addc67f6f 99582d35f25045669886708a69f7a143--329c0a38f9324134b1e02d8addc67f6f 72012c72f7684135af4612f41c0d0d70 329c0a38f9324134b1e02d8addc67f6f--72012c72f7684135af4612f41c0d0d70 5e4ef79272ef4d089c3e92a043d59239 72012c72f7684135af4612f41c0d0d70--5e4ef79272ef4d089c3e92a043d59239 805ca34c71d84c7b98ec63073908c507 5e4ef79272ef4d089c3e92a043d59239--805ca34c71d84c7b98ec63073908c507 ca41099fe05646a3836b37c10f0b454b 805ca34c71d84c7b98ec63073908c507--ca41099fe05646a3836b37c10f0b454b 2fc3d0af79e34a77bb779e6b87d0fd16 X ca41099fe05646a3836b37c10f0b454b--2fc3d0af79e34a77bb779e6b87d0fd16 2fc3d0af79e34a77bb779e6b87d0fd16--8d6c8249737a4333b77af431bce2e2a1 70c4c0a4f5f2406bb4820d69a5db78ac RZ(-1.0*g1) 2fc3d0af79e34a77bb779e6b87d0fd16--70c4c0a4f5f2406bb4820d69a5db78ac 724edfce8bcf4a56a9e6405773a101da X 70c4c0a4f5f2406bb4820d69a5db78ac--724edfce8bcf4a56a9e6405773a101da 724edfce8bcf4a56a9e6405773a101da--9a79356126a94a1fafd1de627e1ba620 14f9a0250aed478aa2075158ec1a4db0 724edfce8bcf4a56a9e6405773a101da--14f9a0250aed478aa2075158ec1a4db0 22482ffc0abe4ebba30625ab40254d7b 14f9a0250aed478aa2075158ec1a4db0--22482ffc0abe4ebba30625ab40254d7b 0df20f48effc48f788f382e11d090a38 X 22482ffc0abe4ebba30625ab40254d7b--0df20f48effc48f788f382e11d090a38 0df20f48effc48f788f382e11d090a38--8dcee6c38677417dbc2d647f5e8505a4 9c6302e2e1bc4aec8c330d80347efca4 0df20f48effc48f788f382e11d090a38--9c6302e2e1bc4aec8c330d80347efca4 07ec85ed9a934c708612cb621dcda99d 9c6302e2e1bc4aec8c330d80347efca4--07ec85ed9a934c708612cb621dcda99d 2d4e0a3168e14f03a2147b16cca4bf88 07ec85ed9a934c708612cb621dcda99d--2d4e0a3168e14f03a2147b16cca4bf88 43b5ceb17bd241caafa9a992e3d78d7f X 2d4e0a3168e14f03a2147b16cca4bf88--43b5ceb17bd241caafa9a992e3d78d7f 43b5ceb17bd241caafa9a992e3d78d7f--d969a67126bc45cabcee25655f7ab0aa 8f4e7c6b4e884e25a0d3c636a6a0f882 43b5ceb17bd241caafa9a992e3d78d7f--8f4e7c6b4e884e25a0d3c636a6a0f882 413e4a5a873948028a7644c64ebd6321 8f4e7c6b4e884e25a0d3c636a6a0f882--413e4a5a873948028a7644c64ebd6321 7da2dba1aa0a45fab4a80d46ec07cce8 X 413e4a5a873948028a7644c64ebd6321--7da2dba1aa0a45fab4a80d46ec07cce8 7da2dba1aa0a45fab4a80d46ec07cce8--df9561e28150495da6c9fd08b33f03e6 1d10c9bc9dbc48cfa0d855d1a2185d2b 7da2dba1aa0a45fab4a80d46ec07cce8--1d10c9bc9dbc48cfa0d855d1a2185d2b 49bd7a85b55e41eea8c6b40d94e544ce 1d10c9bc9dbc48cfa0d855d1a2185d2b--49bd7a85b55e41eea8c6b40d94e544ce 0eb369ba757b400584df2a919e7090aa 49bd7a85b55e41eea8c6b40d94e544ce--0eb369ba757b400584df2a919e7090aa 34af035276e844d0ad7a6d385eaf7540 0eb369ba757b400584df2a919e7090aa--34af035276e844d0ad7a6d385eaf7540 b36b036f749f46369dd1a50b253a01da 34af035276e844d0ad7a6d385eaf7540--b36b036f749f46369dd1a50b253a01da c3351205c2284e148bcac968c87c55e9 X b36b036f749f46369dd1a50b253a01da--c3351205c2284e148bcac968c87c55e9 c3351205c2284e148bcac968c87c55e9--aa34c530d4bf40ed83ce1af16c4125fc 2d26f6c7de3e499f9eafb309917f680c c3351205c2284e148bcac968c87c55e9--2d26f6c7de3e499f9eafb309917f680c a85676d1e6b7421db2c341240535548d 2d26f6c7de3e499f9eafb309917f680c--a85676d1e6b7421db2c341240535548d 631dcdc870f143be8f00586ccfb0aa01 X a85676d1e6b7421db2c341240535548d--631dcdc870f143be8f00586ccfb0aa01 631dcdc870f143be8f00586ccfb0aa01--569c5c68cb4f4d30921c68d305fbc5a0 42eb5ce877f74e5580ab40ccfb2764f5 631dcdc870f143be8f00586ccfb0aa01--42eb5ce877f74e5580ab40ccfb2764f5 1d6dc49a3f2e4a4587444f2d76209223 42eb5ce877f74e5580ab40ccfb2764f5--1d6dc49a3f2e4a4587444f2d76209223 dbbf3e45f0814f2f97ad1fa05bb819fe 1d6dc49a3f2e4a4587444f2d76209223--dbbf3e45f0814f2f97ad1fa05bb819fe a30b77f16d7b46f1af7b41cf66a52f72 dbbf3e45f0814f2f97ad1fa05bb819fe--a30b77f16d7b46f1af7b41cf66a52f72 f6bb3c47f25a4e7da38b87e9f7deb8ce a30b77f16d7b46f1af7b41cf66a52f72--f6bb3c47f25a4e7da38b87e9f7deb8ce b38f949d121a45078dbb98b1e0f1d80d f6bb3c47f25a4e7da38b87e9f7deb8ce--b38f949d121a45078dbb98b1e0f1d80d 8719a372b4f84aa0968392a19174180b b38f949d121a45078dbb98b1e0f1d80d--8719a372b4f84aa0968392a19174180b 3daf372b45f9410cbaba6f1fab955668 X 8719a372b4f84aa0968392a19174180b--3daf372b45f9410cbaba6f1fab955668 3daf372b45f9410cbaba6f1fab955668--e87947e218474ebea42c6e7255a20a32 8f741c82b3b24bd186593bdda026665a 3daf372b45f9410cbaba6f1fab955668--8f741c82b3b24bd186593bdda026665a b9b8b77c1cbf4504b84780b99fd934ba X 8f741c82b3b24bd186593bdda026665a--b9b8b77c1cbf4504b84780b99fd934ba b9b8b77c1cbf4504b84780b99fd934ba--d1d3960b0c1244e5bb8b2865a6e2b318 69800c5bcb0b443bb17f6a240dffef7b b9b8b77c1cbf4504b84780b99fd934ba--69800c5bcb0b443bb17f6a240dffef7b 4352a33b41784a14b05e319b2516470e 69800c5bcb0b443bb17f6a240dffef7b--4352a33b41784a14b05e319b2516470e a09aa371b6db4ad4adcf76dc41b82945 4352a33b41784a14b05e319b2516470e--a09aa371b6db4ad4adcf76dc41b82945 440ecc365764412aa0cfd959d07609fc a09aa371b6db4ad4adcf76dc41b82945--440ecc365764412aa0cfd959d07609fc f1ff960e69034cf48653377b50e5de46 440ecc365764412aa0cfd959d07609fc--f1ff960e69034cf48653377b50e5de46 c5a07b077a494217992e684884a6512f f1ff960e69034cf48653377b50e5de46--c5a07b077a494217992e684884a6512f ac1abf25261840049012a9ad061cc6ea c5a07b077a494217992e684884a6512f--ac1abf25261840049012a9ad061cc6ea 6594d574996042ba88e30f90634cd3ca X ac1abf25261840049012a9ad061cc6ea--6594d574996042ba88e30f90634cd3ca 6594d574996042ba88e30f90634cd3ca--38b48bf72cd64e85836b1f6d9566f709 1b16abbcb1284e13b557aa87d814c325 6594d574996042ba88e30f90634cd3ca--1b16abbcb1284e13b557aa87d814c325 af46cfce59514b209e350de9d7e5520e 1b16abbcb1284e13b557aa87d814c325--af46cfce59514b209e350de9d7e5520e dacac71f4ff0449795a3bfb10248f50b af46cfce59514b209e350de9d7e5520e--dacac71f4ff0449795a3bfb10248f50b 17031fcc0feb404a95e2d6442f9aaeab dacac71f4ff0449795a3bfb10248f50b--17031fcc0feb404a95e2d6442f9aaeab 005f7f5077024c02a1a1e6ec03b9c073 17031fcc0feb404a95e2d6442f9aaeab--005f7f5077024c02a1a1e6ec03b9c073 043481b216da4b279a30e187515b83bc 005f7f5077024c02a1a1e6ec03b9c073--043481b216da4b279a30e187515b83bc 314b1f1c80554d2ea64e68571345b5aa 043481b216da4b279a30e187515b83bc--314b1f1c80554d2ea64e68571345b5aa aea5101b4d6347b89f082ee7270cef15 RX(b14) 314b1f1c80554d2ea64e68571345b5aa--aea5101b4d6347b89f082ee7270cef15 aea5101b4d6347b89f082ee7270cef15--19df6313e0e2476fbb4008fe5e4b371e b2270bcf246b4a2390a24c018711349a f2220bc99f45405fbedfa263401a7005 973a00bf552242888e7377394950aed0--f2220bc99f45405fbedfa263401a7005 95d50203b50a444cb60b819b7f5718d8 6 65f88db5f3044f18b9b203d37b7e08f5 f2220bc99f45405fbedfa263401a7005--65f88db5f3044f18b9b203d37b7e08f5 95e5e43c404347549b49eaebe02c7732 65f88db5f3044f18b9b203d37b7e08f5--95e5e43c404347549b49eaebe02c7732 f033eff0605e41b7b5cf4493aa207be5 95e5e43c404347549b49eaebe02c7732--f033eff0605e41b7b5cf4493aa207be5 4c5683881f4e4393a6bbd38394ad1a89 X f033eff0605e41b7b5cf4493aa207be5--4c5683881f4e4393a6bbd38394ad1a89 4c5683881f4e4393a6bbd38394ad1a89--c6f549a8f76d419ca5f91070d209234d 171916054dd54ba3b6a8796d4985bb8f 4c5683881f4e4393a6bbd38394ad1a89--171916054dd54ba3b6a8796d4985bb8f 177ec75b8b8a456ca1ebc560fb060123 171916054dd54ba3b6a8796d4985bb8f--177ec75b8b8a456ca1ebc560fb060123 8d9133b0cc1448f999eb6e3e8cb603ce 177ec75b8b8a456ca1ebc560fb060123--8d9133b0cc1448f999eb6e3e8cb603ce 023c2540ac03454fa46cdbb3d2ccb690 8d9133b0cc1448f999eb6e3e8cb603ce--023c2540ac03454fa46cdbb3d2ccb690 ff959c07465443ad9be66cea7e565e66 023c2540ac03454fa46cdbb3d2ccb690--ff959c07465443ad9be66cea7e565e66 95230eefb90d4bcb8e0a21a5f644b577 X ff959c07465443ad9be66cea7e565e66--95230eefb90d4bcb8e0a21a5f644b577 95230eefb90d4bcb8e0a21a5f644b577--2dd130a6512b4738b42e531b5fced766 8504d520eb54424bb9c33d02d50c8815 95230eefb90d4bcb8e0a21a5f644b577--8504d520eb54424bb9c33d02d50c8815 3b4c5ae89ee54d94a60f1ed7ae8af2c7 8504d520eb54424bb9c33d02d50c8815--3b4c5ae89ee54d94a60f1ed7ae8af2c7 9a27a1fd52ff48a795514646cf676050 3b4c5ae89ee54d94a60f1ed7ae8af2c7--9a27a1fd52ff48a795514646cf676050 baa0f0e936bd42b7b6a7f9bb1df3dc2b 9a27a1fd52ff48a795514646cf676050--baa0f0e936bd42b7b6a7f9bb1df3dc2b e547bbba9546417eb3d99af14b1fa936 baa0f0e936bd42b7b6a7f9bb1df3dc2b--e547bbba9546417eb3d99af14b1fa936 9a2ecf1864be470796972bfe86fa2539 e547bbba9546417eb3d99af14b1fa936--9a2ecf1864be470796972bfe86fa2539 9c1b7704034449d39bd84fb7fe73d244 9a2ecf1864be470796972bfe86fa2539--9c1b7704034449d39bd84fb7fe73d244 c2e9721d7d5d45a9b1c0cacb6127903d 9c1b7704034449d39bd84fb7fe73d244--c2e9721d7d5d45a9b1c0cacb6127903d c2c11b2774134131824b988fe68f066d c2e9721d7d5d45a9b1c0cacb6127903d--c2c11b2774134131824b988fe68f066d 6831242ec36647e89581a007d0095b04 c2c11b2774134131824b988fe68f066d--6831242ec36647e89581a007d0095b04 18f653a6e3274380806daf46b2ce0563 6831242ec36647e89581a007d0095b04--18f653a6e3274380806daf46b2ce0563 61f5c33c148c4227a69ff0ca14590eab 18f653a6e3274380806daf46b2ce0563--61f5c33c148c4227a69ff0ca14590eab 9e2466e0a67449ed9cbca99d6ea81825 61f5c33c148c4227a69ff0ca14590eab--9e2466e0a67449ed9cbca99d6ea81825 cd8829f1ee5b4240af6992f676e37679 9e2466e0a67449ed9cbca99d6ea81825--cd8829f1ee5b4240af6992f676e37679 e1cd2427bc044633ad1556b3fbcf46e1 cd8829f1ee5b4240af6992f676e37679--e1cd2427bc044633ad1556b3fbcf46e1 dbc0c583bd434bd1b2c89a0332ec1b39 e1cd2427bc044633ad1556b3fbcf46e1--dbc0c583bd434bd1b2c89a0332ec1b39 776ad8f80ec84bbabbf794e48d8ae852 dbc0c583bd434bd1b2c89a0332ec1b39--776ad8f80ec84bbabbf794e48d8ae852 c668cd6f0957438facff36e856be33ae 776ad8f80ec84bbabbf794e48d8ae852--c668cd6f0957438facff36e856be33ae ea4e72c41fc94543a9ccd22839673e58 c668cd6f0957438facff36e856be33ae--ea4e72c41fc94543a9ccd22839673e58 ff53e0b4e5384d5d887497effbe3ee78 ea4e72c41fc94543a9ccd22839673e58--ff53e0b4e5384d5d887497effbe3ee78 fdf2b4c5a02c4f27854a889717e193c4 ff53e0b4e5384d5d887497effbe3ee78--fdf2b4c5a02c4f27854a889717e193c4 57c25b9de8a142b28a53960e7f7e9ab6 fdf2b4c5a02c4f27854a889717e193c4--57c25b9de8a142b28a53960e7f7e9ab6 cf10254963be4ec1a24ca7f78e06fd9c 57c25b9de8a142b28a53960e7f7e9ab6--cf10254963be4ec1a24ca7f78e06fd9c 9bc5ab3f462e483a87e89e4eb2eac7d8 cf10254963be4ec1a24ca7f78e06fd9c--9bc5ab3f462e483a87e89e4eb2eac7d8 0195a50ff43944a09a014804cb9cf6da 9bc5ab3f462e483a87e89e4eb2eac7d8--0195a50ff43944a09a014804cb9cf6da 3f246416e6cc48d59e08b2338a378646 0195a50ff43944a09a014804cb9cf6da--3f246416e6cc48d59e08b2338a378646 7a76135fb5424d558d607bc2bd802302 3f246416e6cc48d59e08b2338a378646--7a76135fb5424d558d607bc2bd802302 2108529cf78c46619a43d7b166eb7eac 7a76135fb5424d558d607bc2bd802302--2108529cf78c46619a43d7b166eb7eac e6f2dad506064d968eba665299b702c4 2108529cf78c46619a43d7b166eb7eac--e6f2dad506064d968eba665299b702c4 cb6f017cf1e4448391425632230fa227 e6f2dad506064d968eba665299b702c4--cb6f017cf1e4448391425632230fa227 0e1afead784f4e8199bb09219568acb3 cb6f017cf1e4448391425632230fa227--0e1afead784f4e8199bb09219568acb3 f9fcdb447cc4475786218af778de6605 0e1afead784f4e8199bb09219568acb3--f9fcdb447cc4475786218af778de6605 f2ca16008114418cb9102213102f5fa7 f9fcdb447cc4475786218af778de6605--f2ca16008114418cb9102213102f5fa7 8f58c266ce9c45c8be83eb62ba44013b f2ca16008114418cb9102213102f5fa7--8f58c266ce9c45c8be83eb62ba44013b a08a9b254826498da4e593cf422f667c 8f58c266ce9c45c8be83eb62ba44013b--a08a9b254826498da4e593cf422f667c 4a0b0af77e6c46c1a66488c8e8336e41 a08a9b254826498da4e593cf422f667c--4a0b0af77e6c46c1a66488c8e8336e41 8557f2f0e8784aeba256c8765e14bc46 4a0b0af77e6c46c1a66488c8e8336e41--8557f2f0e8784aeba256c8765e14bc46 1437ff707ed14bb7bbbc39913d1c2a13 8557f2f0e8784aeba256c8765e14bc46--1437ff707ed14bb7bbbc39913d1c2a13 dce966c982b042828bb232834d262237 1437ff707ed14bb7bbbc39913d1c2a13--dce966c982b042828bb232834d262237 b9996804f0e6462f96ef71d1fbae1645 X dce966c982b042828bb232834d262237--b9996804f0e6462f96ef71d1fbae1645 b9996804f0e6462f96ef71d1fbae1645--64996dcefb364affb4a0628d2a40fe36 1113caaa27064f759d5edd6e4033ef88 RZ(-1.0*g0) b9996804f0e6462f96ef71d1fbae1645--1113caaa27064f759d5edd6e4033ef88 fbe57f7408d64656a02c55ca598a8043 X 1113caaa27064f759d5edd6e4033ef88--fbe57f7408d64656a02c55ca598a8043 fbe57f7408d64656a02c55ca598a8043--1ae87266b8e54594a0bc777aa026bcc9 99b14856fc7f454fb8c210153f4beba3 fbe57f7408d64656a02c55ca598a8043--99b14856fc7f454fb8c210153f4beba3 d7992655e2664dd086ce8c776333e485 99b14856fc7f454fb8c210153f4beba3--d7992655e2664dd086ce8c776333e485 1f53e91a1ab042eab55f4f95ae13f340 d7992655e2664dd086ce8c776333e485--1f53e91a1ab042eab55f4f95ae13f340 0d6cebd757bd42e39ed1f6841a960635 1f53e91a1ab042eab55f4f95ae13f340--0d6cebd757bd42e39ed1f6841a960635 175b157596284780872646938b6e04ae 0d6cebd757bd42e39ed1f6841a960635--175b157596284780872646938b6e04ae ce8c91f7e82d4f91803cfcc90c00bf73 175b157596284780872646938b6e04ae--ce8c91f7e82d4f91803cfcc90c00bf73 8822655fe3114f88a07469fa81fc8c00 X ce8c91f7e82d4f91803cfcc90c00bf73--8822655fe3114f88a07469fa81fc8c00 8822655fe3114f88a07469fa81fc8c00--5c5e9228ad69446683fa0306e807b6c1 2071c763c1604ae2a3c93559ef64fab1 8822655fe3114f88a07469fa81fc8c00--2071c763c1604ae2a3c93559ef64fab1 0bbb7f2fd08c4a01b152a92f6dfef5f9 2071c763c1604ae2a3c93559ef64fab1--0bbb7f2fd08c4a01b152a92f6dfef5f9 908d500226ac44c098baf00199ed3a11 0bbb7f2fd08c4a01b152a92f6dfef5f9--908d500226ac44c098baf00199ed3a11 f02f994495694f6e9a907d5f4155bba1 X 908d500226ac44c098baf00199ed3a11--f02f994495694f6e9a907d5f4155bba1 f02f994495694f6e9a907d5f4155bba1--c35046d9d0144142b7d4757dd8f1f8b1 037f3b5aaf2c4701880a6ba4fc1789f8 f02f994495694f6e9a907d5f4155bba1--037f3b5aaf2c4701880a6ba4fc1789f8 ff118694f53e4437bea9e4606668f723 037f3b5aaf2c4701880a6ba4fc1789f8--ff118694f53e4437bea9e4606668f723 d17c16fd47cb48dda6ebf86fd06dbbc4 ff118694f53e4437bea9e4606668f723--d17c16fd47cb48dda6ebf86fd06dbbc4 ff027553c9054b59847fdd36eb8b347b d17c16fd47cb48dda6ebf86fd06dbbc4--ff027553c9054b59847fdd36eb8b347b 2caec61c6cc14ccf9044f4ac7d222717 ff027553c9054b59847fdd36eb8b347b--2caec61c6cc14ccf9044f4ac7d222717 e8ae6f0fe96b4b59a87cab317e2d5dc0 2caec61c6cc14ccf9044f4ac7d222717--e8ae6f0fe96b4b59a87cab317e2d5dc0 059b9eab91d045a18f3d6d5bcbd6ebff e8ae6f0fe96b4b59a87cab317e2d5dc0--059b9eab91d045a18f3d6d5bcbd6ebff f38e81b2a27e447bb12b8afd6d4e5033 059b9eab91d045a18f3d6d5bcbd6ebff--f38e81b2a27e447bb12b8afd6d4e5033 836011149dbb41e68b84fd459d4acc69 f38e81b2a27e447bb12b8afd6d4e5033--836011149dbb41e68b84fd459d4acc69 545dff5824ce4effbba682273b488f06 836011149dbb41e68b84fd459d4acc69--545dff5824ce4effbba682273b488f06 89c04e7a713c4ca8bf9d435c761d05b2 545dff5824ce4effbba682273b488f06--89c04e7a713c4ca8bf9d435c761d05b2 6aa160bb109e4f68ad3e133a46544b33 89c04e7a713c4ca8bf9d435c761d05b2--6aa160bb109e4f68ad3e133a46544b33 9310d9a2fb314468ae923696608588e9 6aa160bb109e4f68ad3e133a46544b33--9310d9a2fb314468ae923696608588e9 f995b771588449e4a8c7527765210034 X 9310d9a2fb314468ae923696608588e9--f995b771588449e4a8c7527765210034 f995b771588449e4a8c7527765210034--ef176b1637d54c56a45a19d25f6b0431 dffbd355bf4845479020a3a5338265f3 RZ(-1.0*g0) f995b771588449e4a8c7527765210034--dffbd355bf4845479020a3a5338265f3 d6b56e43ce3e47598a2526374c398cd3 X dffbd355bf4845479020a3a5338265f3--d6b56e43ce3e47598a2526374c398cd3 d6b56e43ce3e47598a2526374c398cd3--cb8e5aa3eea94fbc95f49db7e679c9f2 a203e0a5cd4f405189b54440b10eca3d d6b56e43ce3e47598a2526374c398cd3--a203e0a5cd4f405189b54440b10eca3d a398745c2293440d8834fe3e2b977887 a203e0a5cd4f405189b54440b10eca3d--a398745c2293440d8834fe3e2b977887 a45b9d96139b45979cf65531adb20206 a398745c2293440d8834fe3e2b977887--a45b9d96139b45979cf65531adb20206 e65fd9ab2d5b4018afb03a7d60759e0f a45b9d96139b45979cf65531adb20206--e65fd9ab2d5b4018afb03a7d60759e0f 9bae251af9034dd0b9bd295197307732 X e65fd9ab2d5b4018afb03a7d60759e0f--9bae251af9034dd0b9bd295197307732 9bae251af9034dd0b9bd295197307732--ca326d9ad7fa4a08b5a1915a37d47e5f 2997c7f00d2f4669afe3e85449677222 9bae251af9034dd0b9bd295197307732--2997c7f00d2f4669afe3e85449677222 84e27e2b6ed14a5abecc39bbbfc043a4 2997c7f00d2f4669afe3e85449677222--84e27e2b6ed14a5abecc39bbbfc043a4 3908d765cb574635830a882361cf406e 84e27e2b6ed14a5abecc39bbbfc043a4--3908d765cb574635830a882361cf406e 39f46de276384470ac6715ca07d7fc15 X 3908d765cb574635830a882361cf406e--39f46de276384470ac6715ca07d7fc15 39f46de276384470ac6715ca07d7fc15--02d1aa1f3f02461082d588ed2b27f236 2e3d2e611a384035b81e5a6dc45fc626 39f46de276384470ac6715ca07d7fc15--2e3d2e611a384035b81e5a6dc45fc626 11d340c866e9405b83e32a1dbf5b659b 2e3d2e611a384035b81e5a6dc45fc626--11d340c866e9405b83e32a1dbf5b659b b43d842ae2774918a337343715245036 11d340c866e9405b83e32a1dbf5b659b--b43d842ae2774918a337343715245036 77e896b40fc647f08b98949919eeabb3 b43d842ae2774918a337343715245036--77e896b40fc647f08b98949919eeabb3 b44110df45fd4d138fd0d5ed451fe34e X 77e896b40fc647f08b98949919eeabb3--b44110df45fd4d138fd0d5ed451fe34e b44110df45fd4d138fd0d5ed451fe34e--1749a2ee85c44b11b000a9311f440672 b37d495afeb844daa79c69eaff7fb7de b44110df45fd4d138fd0d5ed451fe34e--b37d495afeb844daa79c69eaff7fb7de 42430ea27a434959a5e296529db2e970 b37d495afeb844daa79c69eaff7fb7de--42430ea27a434959a5e296529db2e970 4dc54dc4f4464c88a4e3e5cb9a16bf56 42430ea27a434959a5e296529db2e970--4dc54dc4f4464c88a4e3e5cb9a16bf56 9c3ec0400f4044fdbddf5ab5e47c9310 4dc54dc4f4464c88a4e3e5cb9a16bf56--9c3ec0400f4044fdbddf5ab5e47c9310 fd39d1f2deb44fbe90d79f1899fc1769 9c3ec0400f4044fdbddf5ab5e47c9310--fd39d1f2deb44fbe90d79f1899fc1769 ba3f0029539c4f0589f34bb91a490bf9 X fd39d1f2deb44fbe90d79f1899fc1769--ba3f0029539c4f0589f34bb91a490bf9 ba3f0029539c4f0589f34bb91a490bf9--81ff035616784b008d71996b3c6a3a7f c2ba98693ee045b3bbd0a574c336c1eb ba3f0029539c4f0589f34bb91a490bf9--c2ba98693ee045b3bbd0a574c336c1eb b53cf15e0568423094d9c5da5e81ab7d c2ba98693ee045b3bbd0a574c336c1eb--b53cf15e0568423094d9c5da5e81ab7d edfdc97888154e79bceeab849b7f3790 b53cf15e0568423094d9c5da5e81ab7d--edfdc97888154e79bceeab849b7f3790 3ad614c61a824aa2bdb771e1039e26c3 X edfdc97888154e79bceeab849b7f3790--3ad614c61a824aa2bdb771e1039e26c3 3ad614c61a824aa2bdb771e1039e26c3--8650802453d34804a3b65c88560c7ad4 85e3714373e3485a9ee0b1ca2ebfbb5c 3ad614c61a824aa2bdb771e1039e26c3--85e3714373e3485a9ee0b1ca2ebfbb5c 1b5f42453d214e90b261f1ee29903fd8 85e3714373e3485a9ee0b1ca2ebfbb5c--1b5f42453d214e90b261f1ee29903fd8 a803f74a094f44128298985c03614f73 1b5f42453d214e90b261f1ee29903fd8--a803f74a094f44128298985c03614f73 1a2ac520dde944f7ab7b4503898c6a14 a803f74a094f44128298985c03614f73--1a2ac520dde944f7ab7b4503898c6a14 685867311ef342fba03b7e76a599279f 1a2ac520dde944f7ab7b4503898c6a14--685867311ef342fba03b7e76a599279f 513b93ab262c43d09d292608412144d3 X 685867311ef342fba03b7e76a599279f--513b93ab262c43d09d292608412144d3 513b93ab262c43d09d292608412144d3--ddc0e4019ab74addac153c800def84ae 9b4e036aa9c54bb5a47d6a74b2a94292 513b93ab262c43d09d292608412144d3--9b4e036aa9c54bb5a47d6a74b2a94292 4d72f130ae7340189668cb4d95ff10dd X 9b4e036aa9c54bb5a47d6a74b2a94292--4d72f130ae7340189668cb4d95ff10dd 4d72f130ae7340189668cb4d95ff10dd--b7b6103bcd6b4e2bb53391c3327fba1c b4e3050781114bb6a42b73e9a8a9576f 4d72f130ae7340189668cb4d95ff10dd--b4e3050781114bb6a42b73e9a8a9576f 1d5673ee44af46469da3a32cca2b920f b4e3050781114bb6a42b73e9a8a9576f--1d5673ee44af46469da3a32cca2b920f a32d25842710406e83288b45f938f194 1d5673ee44af46469da3a32cca2b920f--a32d25842710406e83288b45f938f194 77b6f40b77f747c5add898729fa42db6 a32d25842710406e83288b45f938f194--77b6f40b77f747c5add898729fa42db6 b33b4763457e45579f516782530f5063 77b6f40b77f747c5add898729fa42db6--b33b4763457e45579f516782530f5063 b82af9cadaf54d329daf697db5810a90 X b33b4763457e45579f516782530f5063--b82af9cadaf54d329daf697db5810a90 b82af9cadaf54d329daf697db5810a90--b40cedeab29f4ba892a944b76e958973 f1b139025ae4409eaba3398443c2b067 RX(b05) b82af9cadaf54d329daf697db5810a90--f1b139025ae4409eaba3398443c2b067 5f77e131f25d4594a82ecc65b478a931 f1b139025ae4409eaba3398443c2b067--5f77e131f25d4594a82ecc65b478a931 80bf00fa0f0a49a9818bbb5da5bea811 5f77e131f25d4594a82ecc65b478a931--80bf00fa0f0a49a9818bbb5da5bea811 12e6a17a267142bba9ffd49606170d26 80bf00fa0f0a49a9818bbb5da5bea811--12e6a17a267142bba9ffd49606170d26 450a7620e5a14944942d547048d6c845 12e6a17a267142bba9ffd49606170d26--450a7620e5a14944942d547048d6c845 d5346b193eb148e187e7429692e34ffa X 450a7620e5a14944942d547048d6c845--d5346b193eb148e187e7429692e34ffa d5346b193eb148e187e7429692e34ffa--a21c8c32cb9649faa1c1b63d54ab3cf7 988994f4ca2c4ae284065844b8fff465 d5346b193eb148e187e7429692e34ffa--988994f4ca2c4ae284065844b8fff465 4d6bf46c50eb4dbe825237fee497f454 988994f4ca2c4ae284065844b8fff465--4d6bf46c50eb4dbe825237fee497f454 ce11599e17d14881afc3e9da0f8eae14 4d6bf46c50eb4dbe825237fee497f454--ce11599e17d14881afc3e9da0f8eae14 758402ce74484bd8b4376724dd4ca0e9 ce11599e17d14881afc3e9da0f8eae14--758402ce74484bd8b4376724dd4ca0e9 7f5f74270ebb4fbca38c04425318136a 758402ce74484bd8b4376724dd4ca0e9--7f5f74270ebb4fbca38c04425318136a 422d538469bc456389fa4e8847b73b7c X 7f5f74270ebb4fbca38c04425318136a--422d538469bc456389fa4e8847b73b7c 422d538469bc456389fa4e8847b73b7c--6b39ca1bc7014b63ad14b0a626ba22e3 6887f7bae9ca48a4b0a3c00135db552b 422d538469bc456389fa4e8847b73b7c--6887f7bae9ca48a4b0a3c00135db552b 2303f8f5ef1e47d9a5a8e9c25b10f269 6887f7bae9ca48a4b0a3c00135db552b--2303f8f5ef1e47d9a5a8e9c25b10f269 d6626a43ff594c759512ae8add00e107 2303f8f5ef1e47d9a5a8e9c25b10f269--d6626a43ff594c759512ae8add00e107 c119769847cb4cb3843ef90c091be34f d6626a43ff594c759512ae8add00e107--c119769847cb4cb3843ef90c091be34f 063162f84eb04552b814c3e2f8dfb9ae c119769847cb4cb3843ef90c091be34f--063162f84eb04552b814c3e2f8dfb9ae 706ade09485641e69663af861fb57def 063162f84eb04552b814c3e2f8dfb9ae--706ade09485641e69663af861fb57def 22e619a9ee1d414e847cc8ed76ff3517 706ade09485641e69663af861fb57def--22e619a9ee1d414e847cc8ed76ff3517 982590117b744c199b5ed026baf9e2f9 22e619a9ee1d414e847cc8ed76ff3517--982590117b744c199b5ed026baf9e2f9 6b4287f299fb474484690efdd434dfe5 982590117b744c199b5ed026baf9e2f9--6b4287f299fb474484690efdd434dfe5 5cc0dee42f934992afbe7acda2411b7c 6b4287f299fb474484690efdd434dfe5--5cc0dee42f934992afbe7acda2411b7c 58079c75b1424dcdaaeb36383830ac6c 5cc0dee42f934992afbe7acda2411b7c--58079c75b1424dcdaaeb36383830ac6c df2cdf3302e743fbbfae9c3be224babc 58079c75b1424dcdaaeb36383830ac6c--df2cdf3302e743fbbfae9c3be224babc 2981d4ce9a0b401c8c845e7b5b235b72 df2cdf3302e743fbbfae9c3be224babc--2981d4ce9a0b401c8c845e7b5b235b72 d32a0f43da2a4579a8ca80018fe6da82 2981d4ce9a0b401c8c845e7b5b235b72--d32a0f43da2a4579a8ca80018fe6da82 e2f6dd21d89c48e6aed66d6cf909ad3f d32a0f43da2a4579a8ca80018fe6da82--e2f6dd21d89c48e6aed66d6cf909ad3f 06cfe0524f0948a5ab253c83be3020c4 e2f6dd21d89c48e6aed66d6cf909ad3f--06cfe0524f0948a5ab253c83be3020c4 ba37ad66a00f4bdd933cec58fa014fb7 06cfe0524f0948a5ab253c83be3020c4--ba37ad66a00f4bdd933cec58fa014fb7 3c3dcb59038140e896ed05abf331e926 ba37ad66a00f4bdd933cec58fa014fb7--3c3dcb59038140e896ed05abf331e926 7f79c4409fbb47cabfb9f7de07ce3ebb 3c3dcb59038140e896ed05abf331e926--7f79c4409fbb47cabfb9f7de07ce3ebb b56a81e759ec404ebf82a365e1c91247 7f79c4409fbb47cabfb9f7de07ce3ebb--b56a81e759ec404ebf82a365e1c91247 235493565cd94904a554c64bca6f131c b56a81e759ec404ebf82a365e1c91247--235493565cd94904a554c64bca6f131c 5c75d72afb1d4e9689d0511cd1a730cd 235493565cd94904a554c64bca6f131c--5c75d72afb1d4e9689d0511cd1a730cd 815d34743f6a4e12b642f6c447388c43 5c75d72afb1d4e9689d0511cd1a730cd--815d34743f6a4e12b642f6c447388c43 05a2d210268342a48035d98684231a00 815d34743f6a4e12b642f6c447388c43--05a2d210268342a48035d98684231a00 ce69805b1dbb41b09465b36468827a33 05a2d210268342a48035d98684231a00--ce69805b1dbb41b09465b36468827a33 4bb9960a3ee44b41bf42153b7527afc6 ce69805b1dbb41b09465b36468827a33--4bb9960a3ee44b41bf42153b7527afc6 ca39f29799b342ca93d01a1d9f8f8835 4bb9960a3ee44b41bf42153b7527afc6--ca39f29799b342ca93d01a1d9f8f8835 0d2bb6283d564b52b1cbb2833fab1a5a ca39f29799b342ca93d01a1d9f8f8835--0d2bb6283d564b52b1cbb2833fab1a5a a2689d1122a449b1b632f6259f92aff2 0d2bb6283d564b52b1cbb2833fab1a5a--a2689d1122a449b1b632f6259f92aff2 c64d2ca8bfdd49879cda711f06819869 a2689d1122a449b1b632f6259f92aff2--c64d2ca8bfdd49879cda711f06819869 a37065fd702745b3b5b52daf833dcb12 c64d2ca8bfdd49879cda711f06819869--a37065fd702745b3b5b52daf833dcb12 7b716407eb5342a8b4a02c53e814c67c a37065fd702745b3b5b52daf833dcb12--7b716407eb5342a8b4a02c53e814c67c b13880ce2f63418aaafc3caa715b0dff 7b716407eb5342a8b4a02c53e814c67c--b13880ce2f63418aaafc3caa715b0dff 0f6f55c7f3294c688f1708bfbc4b14f5 b13880ce2f63418aaafc3caa715b0dff--0f6f55c7f3294c688f1708bfbc4b14f5 95befee0bc084983b76b87f978777934 0f6f55c7f3294c688f1708bfbc4b14f5--95befee0bc084983b76b87f978777934 1975e5e71a194bf5b8aded52ffd67d78 95befee0bc084983b76b87f978777934--1975e5e71a194bf5b8aded52ffd67d78 2c3caf5196ee4d96831e34db535e01a9 1975e5e71a194bf5b8aded52ffd67d78--2c3caf5196ee4d96831e34db535e01a9 6ec00bc8b1f14ba6bc715ab123a4587e 2c3caf5196ee4d96831e34db535e01a9--6ec00bc8b1f14ba6bc715ab123a4587e e9fe562657c7444db675b0fce2475185 6ec00bc8b1f14ba6bc715ab123a4587e--e9fe562657c7444db675b0fce2475185 f1addc7091ad4bd295bd85cfb5b303fa X e9fe562657c7444db675b0fce2475185--f1addc7091ad4bd295bd85cfb5b303fa f1addc7091ad4bd295bd85cfb5b303fa--482b352a74ad485b943d9479f0ba2d93 18af236f2a1f4a2babf999351e809b9c RZ(-1.0*g1) f1addc7091ad4bd295bd85cfb5b303fa--18af236f2a1f4a2babf999351e809b9c f60a7d45f01d46c2813b3f954da40ebd X 18af236f2a1f4a2babf999351e809b9c--f60a7d45f01d46c2813b3f954da40ebd f60a7d45f01d46c2813b3f954da40ebd--c1833393bd394ac18ed99f818e759b05 ec63b18e5b4a4162a5038f9ee61f3d68 f60a7d45f01d46c2813b3f954da40ebd--ec63b18e5b4a4162a5038f9ee61f3d68 0f2d901035034e97a9962ffdb4d30b0c ec63b18e5b4a4162a5038f9ee61f3d68--0f2d901035034e97a9962ffdb4d30b0c 7ae83c985a34473dbaa8adc032a8c026 0f2d901035034e97a9962ffdb4d30b0c--7ae83c985a34473dbaa8adc032a8c026 7998662c1e404ad58f820d714f5e2d80 7ae83c985a34473dbaa8adc032a8c026--7998662c1e404ad58f820d714f5e2d80 889999fb2fef49df8adf7dc3d87befbb 7998662c1e404ad58f820d714f5e2d80--889999fb2fef49df8adf7dc3d87befbb cad560e4f49f468ea06a25fadb10cd26 889999fb2fef49df8adf7dc3d87befbb--cad560e4f49f468ea06a25fadb10cd26 542265d6fc7c491faaa5c2dc3afcb6b6 X cad560e4f49f468ea06a25fadb10cd26--542265d6fc7c491faaa5c2dc3afcb6b6 542265d6fc7c491faaa5c2dc3afcb6b6--b6c6b403ecfd4aeb8e08f21490d980a3 c9d40a6351ca4486aee12ba2a4c11eac 542265d6fc7c491faaa5c2dc3afcb6b6--c9d40a6351ca4486aee12ba2a4c11eac 1048dee4f85044eab69c7ff1ca83af09 c9d40a6351ca4486aee12ba2a4c11eac--1048dee4f85044eab69c7ff1ca83af09 2eca3202096447afb64b6378b4ebd44a 1048dee4f85044eab69c7ff1ca83af09--2eca3202096447afb64b6378b4ebd44a 8d20138f6689424885504984f8240d92 X 2eca3202096447afb64b6378b4ebd44a--8d20138f6689424885504984f8240d92 8d20138f6689424885504984f8240d92--5ae73d0b54c343e782e651c24824099d cecc37dc681b49fb8476accf72ed1f2e 8d20138f6689424885504984f8240d92--cecc37dc681b49fb8476accf72ed1f2e 5c34f5acb5c94b0db3a3695f6987daa4 cecc37dc681b49fb8476accf72ed1f2e--5c34f5acb5c94b0db3a3695f6987daa4 f1f531efb5cd47698a95df4f46033155 5c34f5acb5c94b0db3a3695f6987daa4--f1f531efb5cd47698a95df4f46033155 f0d2cfa89bb94288affdb4dcd09c3fa2 f1f531efb5cd47698a95df4f46033155--f0d2cfa89bb94288affdb4dcd09c3fa2 6e9ba71a2c1144c786f6bb9f61d0b262 f0d2cfa89bb94288affdb4dcd09c3fa2--6e9ba71a2c1144c786f6bb9f61d0b262 776a266eb13d4fc18570d971df4e9f85 6e9ba71a2c1144c786f6bb9f61d0b262--776a266eb13d4fc18570d971df4e9f85 4b5f4bb69a8949abb746d082238c9355 776a266eb13d4fc18570d971df4e9f85--4b5f4bb69a8949abb746d082238c9355 91f0dc2eeb394f2da6935165af714ea0 4b5f4bb69a8949abb746d082238c9355--91f0dc2eeb394f2da6935165af714ea0 6accc36f5845464abfd966e4793f1e42 91f0dc2eeb394f2da6935165af714ea0--6accc36f5845464abfd966e4793f1e42 c8631ec20f224a16a9dd19b9477e2de8 6accc36f5845464abfd966e4793f1e42--c8631ec20f224a16a9dd19b9477e2de8 a82c6e3ef3e14de4b90c09f122c7c7ba c8631ec20f224a16a9dd19b9477e2de8--a82c6e3ef3e14de4b90c09f122c7c7ba 225075e29f7541c5857fede45167a816 a82c6e3ef3e14de4b90c09f122c7c7ba--225075e29f7541c5857fede45167a816 8d7bd2ec0ed04023aed8515611e865a9 225075e29f7541c5857fede45167a816--8d7bd2ec0ed04023aed8515611e865a9 242d7f66077e4d128a44c48d64c67239 X 8d7bd2ec0ed04023aed8515611e865a9--242d7f66077e4d128a44c48d64c67239 242d7f66077e4d128a44c48d64c67239--9c6302e2e1bc4aec8c330d80347efca4 0a91e54837ee47f2ace52e80fa8324cb RZ(-1.0*g1) 242d7f66077e4d128a44c48d64c67239--0a91e54837ee47f2ace52e80fa8324cb 939d50e6f4ae4bb1bf87add5d04e65e2 X 0a91e54837ee47f2ace52e80fa8324cb--939d50e6f4ae4bb1bf87add5d04e65e2 939d50e6f4ae4bb1bf87add5d04e65e2--2d4e0a3168e14f03a2147b16cca4bf88 692d6b4c6c5c46559059cff107466c50 939d50e6f4ae4bb1bf87add5d04e65e2--692d6b4c6c5c46559059cff107466c50 6e820c2d72a741a5a61c400e3a7996cc 692d6b4c6c5c46559059cff107466c50--6e820c2d72a741a5a61c400e3a7996cc 21317c3d1d3c4114b79db2a2544fc43d 6e820c2d72a741a5a61c400e3a7996cc--21317c3d1d3c4114b79db2a2544fc43d 7581524af92e4368b561806c65c3d2bf 21317c3d1d3c4114b79db2a2544fc43d--7581524af92e4368b561806c65c3d2bf af5d743f35154c438c525928474f2d1f X 7581524af92e4368b561806c65c3d2bf--af5d743f35154c438c525928474f2d1f af5d743f35154c438c525928474f2d1f--1d10c9bc9dbc48cfa0d855d1a2185d2b f9c49a6d9b3a488c8c70f8f6f842d1fe af5d743f35154c438c525928474f2d1f--f9c49a6d9b3a488c8c70f8f6f842d1fe 85689652405940d4810e1e14413da6a3 f9c49a6d9b3a488c8c70f8f6f842d1fe--85689652405940d4810e1e14413da6a3 12b9fbf7d8b94ff08b47a6187f838eec 85689652405940d4810e1e14413da6a3--12b9fbf7d8b94ff08b47a6187f838eec f7c8cb2309ab400c8fa42a940422b137 X 12b9fbf7d8b94ff08b47a6187f838eec--f7c8cb2309ab400c8fa42a940422b137 f7c8cb2309ab400c8fa42a940422b137--b36b036f749f46369dd1a50b253a01da b32d6287add44099967e48cb2c5b5d58 f7c8cb2309ab400c8fa42a940422b137--b32d6287add44099967e48cb2c5b5d58 097a56020cf145d389108074e7fff984 b32d6287add44099967e48cb2c5b5d58--097a56020cf145d389108074e7fff984 8cdc090093fb474d92c2f44b126971bc 097a56020cf145d389108074e7fff984--8cdc090093fb474d92c2f44b126971bc a383fe36621648f2bd9b38757bfa1a41 8cdc090093fb474d92c2f44b126971bc--a383fe36621648f2bd9b38757bfa1a41 91ce04cbf54d4e17bbc7187abf277284 X a383fe36621648f2bd9b38757bfa1a41--91ce04cbf54d4e17bbc7187abf277284 91ce04cbf54d4e17bbc7187abf277284--42eb5ce877f74e5580ab40ccfb2764f5 40519a88d2ad49e18539d00f2ef4ebcd 91ce04cbf54d4e17bbc7187abf277284--40519a88d2ad49e18539d00f2ef4ebcd f8483de92ecc4a899dc9ed07c61bff69 40519a88d2ad49e18539d00f2ef4ebcd--f8483de92ecc4a899dc9ed07c61bff69 f1e35aa753b44c5c8acd18482e4283c6 f8483de92ecc4a899dc9ed07c61bff69--f1e35aa753b44c5c8acd18482e4283c6 149984c0f4644719ba0bad1f4585e28b f1e35aa753b44c5c8acd18482e4283c6--149984c0f4644719ba0bad1f4585e28b 5ede3c48b9f248a7adb95598451b2ffd 149984c0f4644719ba0bad1f4585e28b--5ede3c48b9f248a7adb95598451b2ffd a70c0c73566f4d53bbae660ac3180e94 X 5ede3c48b9f248a7adb95598451b2ffd--a70c0c73566f4d53bbae660ac3180e94 a70c0c73566f4d53bbae660ac3180e94--8719a372b4f84aa0968392a19174180b a10f34827979424e944162a84de31981 a70c0c73566f4d53bbae660ac3180e94--a10f34827979424e944162a84de31981 097934ce6e0c4672aea44110b1d96e21 a10f34827979424e944162a84de31981--097934ce6e0c4672aea44110b1d96e21 a672647d64b64a99874c0b22491de34c 097934ce6e0c4672aea44110b1d96e21--a672647d64b64a99874c0b22491de34c 9eaf2c621373462aab4b7ae85ae6bb0d X a672647d64b64a99874c0b22491de34c--9eaf2c621373462aab4b7ae85ae6bb0d 9eaf2c621373462aab4b7ae85ae6bb0d--69800c5bcb0b443bb17f6a240dffef7b 0236e8ffdfd546b5a17f65729d348299 9eaf2c621373462aab4b7ae85ae6bb0d--0236e8ffdfd546b5a17f65729d348299 d9b3d301273f442d96e9a62066db1abb 0236e8ffdfd546b5a17f65729d348299--d9b3d301273f442d96e9a62066db1abb 9c7176c0dafa48b196d55b831b158204 d9b3d301273f442d96e9a62066db1abb--9c7176c0dafa48b196d55b831b158204 d750b8453afd4df6ae7327ef9293aada 9c7176c0dafa48b196d55b831b158204--d750b8453afd4df6ae7327ef9293aada 094dd13676404a66b1019c3e9afdcce1 d750b8453afd4df6ae7327ef9293aada--094dd13676404a66b1019c3e9afdcce1 a9ffce198d68450faba5f94ed411a805 X 094dd13676404a66b1019c3e9afdcce1--a9ffce198d68450faba5f94ed411a805 a9ffce198d68450faba5f94ed411a805--ac1abf25261840049012a9ad061cc6ea 66025b3185564c01837d893a44412327 a9ffce198d68450faba5f94ed411a805--66025b3185564c01837d893a44412327 3e618367e26d4e0faedc2c661747afb5 X 66025b3185564c01837d893a44412327--3e618367e26d4e0faedc2c661747afb5 3e618367e26d4e0faedc2c661747afb5--1b16abbcb1284e13b557aa87d814c325 0ec58f2c501b4829bd19cfff383c5c13 3e618367e26d4e0faedc2c661747afb5--0ec58f2c501b4829bd19cfff383c5c13 3a427e32e7bd4047b9bf816f67496b4f 0ec58f2c501b4829bd19cfff383c5c13--3a427e32e7bd4047b9bf816f67496b4f 899261a9730e483fbb237aff48af6736 3a427e32e7bd4047b9bf816f67496b4f--899261a9730e483fbb237aff48af6736 20b92f13f28349e3a14c6d18914bc597 899261a9730e483fbb237aff48af6736--20b92f13f28349e3a14c6d18914bc597 94b3d332199a4a7b86352a4aeb78dce6 20b92f13f28349e3a14c6d18914bc597--94b3d332199a4a7b86352a4aeb78dce6 e35b5f560c3a44caa832693c9d272e6e X 94b3d332199a4a7b86352a4aeb78dce6--e35b5f560c3a44caa832693c9d272e6e e35b5f560c3a44caa832693c9d272e6e--314b1f1c80554d2ea64e68571345b5aa 8342eed9b6514cb69a2cb385f50a69a5 RX(b15) e35b5f560c3a44caa832693c9d272e6e--8342eed9b6514cb69a2cb385f50a69a5 8342eed9b6514cb69a2cb385f50a69a5--b2270bcf246b4a2390a24c018711349a be3e57d62277436a95b3a9437d99ab46 9f57abfad8e04058b1dbec87182378a6 95d50203b50a444cb60b819b7f5718d8--9f57abfad8e04058b1dbec87182378a6 a09dda7b21af450dad7db19114a54dc8 7 d6d635b8b4e3420a81cc55335a9f9404 9f57abfad8e04058b1dbec87182378a6--d6d635b8b4e3420a81cc55335a9f9404 d86672775a90488d9b3dae8c2e5fd035 d6d635b8b4e3420a81cc55335a9f9404--d86672775a90488d9b3dae8c2e5fd035 9292cd02c2904a95a8e4725a1dfdc4bf d86672775a90488d9b3dae8c2e5fd035--9292cd02c2904a95a8e4725a1dfdc4bf b916113e9dc347758379d32566e71171 9292cd02c2904a95a8e4725a1dfdc4bf--b916113e9dc347758379d32566e71171 ba48501c3a54499798ea6b12bb7c5411 X b916113e9dc347758379d32566e71171--ba48501c3a54499798ea6b12bb7c5411 ba48501c3a54499798ea6b12bb7c5411--171916054dd54ba3b6a8796d4985bb8f e4eca6c93e734fb48d6ed9b955569522 ba48501c3a54499798ea6b12bb7c5411--e4eca6c93e734fb48d6ed9b955569522 b6ae29a351734c6db9b35513e60f214e e4eca6c93e734fb48d6ed9b955569522--b6ae29a351734c6db9b35513e60f214e 56a532b221a04988b35fab6012c0f19c b6ae29a351734c6db9b35513e60f214e--56a532b221a04988b35fab6012c0f19c 6b39f41852e141ef8baa4bb9f5a027b1 X 56a532b221a04988b35fab6012c0f19c--6b39f41852e141ef8baa4bb9f5a027b1 6b39f41852e141ef8baa4bb9f5a027b1--ff959c07465443ad9be66cea7e565e66 e866fa3bd5f249d1b957130c31b896dd 6b39f41852e141ef8baa4bb9f5a027b1--e866fa3bd5f249d1b957130c31b896dd bcf37dfe68d048268a53cbc24a91baa5 e866fa3bd5f249d1b957130c31b896dd--bcf37dfe68d048268a53cbc24a91baa5 ac5f6c86a35644a0b049aef7ececf93e bcf37dfe68d048268a53cbc24a91baa5--ac5f6c86a35644a0b049aef7ececf93e 614356ec072f4fa695af26a9a43b2cc5 ac5f6c86a35644a0b049aef7ececf93e--614356ec072f4fa695af26a9a43b2cc5 293df96609ee4be28d499f0ed065e1d1 614356ec072f4fa695af26a9a43b2cc5--293df96609ee4be28d499f0ed065e1d1 5c5e4f0e13d84b04bfcfbd6b7825cbe3 293df96609ee4be28d499f0ed065e1d1--5c5e4f0e13d84b04bfcfbd6b7825cbe3 23aec36f53b84c759b6d72f3b8611c8f 5c5e4f0e13d84b04bfcfbd6b7825cbe3--23aec36f53b84c759b6d72f3b8611c8f 9d0128c1674047f697390d575ccb8f8d 23aec36f53b84c759b6d72f3b8611c8f--9d0128c1674047f697390d575ccb8f8d ec9450ad5273475ca525967d8567e25e 9d0128c1674047f697390d575ccb8f8d--ec9450ad5273475ca525967d8567e25e ae1d80dd9e0f4b099ba0fbb445f23512 ec9450ad5273475ca525967d8567e25e--ae1d80dd9e0f4b099ba0fbb445f23512 40fb1842c6d14901bf5c8e8946db879d ae1d80dd9e0f4b099ba0fbb445f23512--40fb1842c6d14901bf5c8e8946db879d b688a79185a74cc682c2c9b5bf283158 40fb1842c6d14901bf5c8e8946db879d--b688a79185a74cc682c2c9b5bf283158 ee171e7896464092b6a55850e2d6a162 b688a79185a74cc682c2c9b5bf283158--ee171e7896464092b6a55850e2d6a162 8983b0d709cd4fe082adf73c7bb73fb7 ee171e7896464092b6a55850e2d6a162--8983b0d709cd4fe082adf73c7bb73fb7 b08160e3c24d431aa4956946c9b69965 8983b0d709cd4fe082adf73c7bb73fb7--b08160e3c24d431aa4956946c9b69965 12bf92b2bebb431384a59bb679e33311 b08160e3c24d431aa4956946c9b69965--12bf92b2bebb431384a59bb679e33311 25215e1ec4704873a1f7d348c8a65a7a 12bf92b2bebb431384a59bb679e33311--25215e1ec4704873a1f7d348c8a65a7a a34081440a614653a1d178ad14eb1857 25215e1ec4704873a1f7d348c8a65a7a--a34081440a614653a1d178ad14eb1857 fd283448ffa440859c08398d9a20a150 a34081440a614653a1d178ad14eb1857--fd283448ffa440859c08398d9a20a150 892d43595e9e4d7e82ecad7e13a4eec2 fd283448ffa440859c08398d9a20a150--892d43595e9e4d7e82ecad7e13a4eec2 0b484eee9fb8434bbde56b018ea1783a 892d43595e9e4d7e82ecad7e13a4eec2--0b484eee9fb8434bbde56b018ea1783a 46c6256e26994d12a60e161af8d449a1 0b484eee9fb8434bbde56b018ea1783a--46c6256e26994d12a60e161af8d449a1 a38b7f67e7e6474b977b5045c3ebd313 46c6256e26994d12a60e161af8d449a1--a38b7f67e7e6474b977b5045c3ebd313 c0cdcb957e8e4ce996202cc91a9d27bb a38b7f67e7e6474b977b5045c3ebd313--c0cdcb957e8e4ce996202cc91a9d27bb c575021d0bf84c0da256e06780b6b077 c0cdcb957e8e4ce996202cc91a9d27bb--c575021d0bf84c0da256e06780b6b077 081344477a41476d9ec6feeb9f4dec33 c575021d0bf84c0da256e06780b6b077--081344477a41476d9ec6feeb9f4dec33 9974e9887c0144969a4d5c1550df24a6 081344477a41476d9ec6feeb9f4dec33--9974e9887c0144969a4d5c1550df24a6 e728a595774c4250a1c1408525d0da2e 9974e9887c0144969a4d5c1550df24a6--e728a595774c4250a1c1408525d0da2e 6c12d84a553346ca933700101a669f53 e728a595774c4250a1c1408525d0da2e--6c12d84a553346ca933700101a669f53 2b36ceb4bb4a4ac1816b1797f5673443 6c12d84a553346ca933700101a669f53--2b36ceb4bb4a4ac1816b1797f5673443 cd09cd04b1134bdfbbf5cbaeb83d7d53 2b36ceb4bb4a4ac1816b1797f5673443--cd09cd04b1134bdfbbf5cbaeb83d7d53 cdbdf68cf8a3479fa0f9426d04d0c8c5 cd09cd04b1134bdfbbf5cbaeb83d7d53--cdbdf68cf8a3479fa0f9426d04d0c8c5 6d189dcab56d42e5af4afa5317d569a6 cdbdf68cf8a3479fa0f9426d04d0c8c5--6d189dcab56d42e5af4afa5317d569a6 598c0d8d61054d678f5937eaee0d93be 6d189dcab56d42e5af4afa5317d569a6--598c0d8d61054d678f5937eaee0d93be cca7866cf7a045028ffdf6a9652f2b68 598c0d8d61054d678f5937eaee0d93be--cca7866cf7a045028ffdf6a9652f2b68 81cbca07b6804454bd3c1ff9c9e81711 cca7866cf7a045028ffdf6a9652f2b68--81cbca07b6804454bd3c1ff9c9e81711 c0cc7d4dfaf04ff8acf38ca9d5b24b92 81cbca07b6804454bd3c1ff9c9e81711--c0cc7d4dfaf04ff8acf38ca9d5b24b92 a247433a67904e03a7e78a0feb5d0e68 c0cc7d4dfaf04ff8acf38ca9d5b24b92--a247433a67904e03a7e78a0feb5d0e68 05035e35b9f549eabbbbbc669338f968 a247433a67904e03a7e78a0feb5d0e68--05035e35b9f549eabbbbbc669338f968 676281195d7f4362ab2ade56c5f15b60 05035e35b9f549eabbbbbc669338f968--676281195d7f4362ab2ade56c5f15b60 5883e5be5dc341148f709c522e7789de 676281195d7f4362ab2ade56c5f15b60--5883e5be5dc341148f709c522e7789de a65c130032194f81bd1924712b75b55f 5883e5be5dc341148f709c522e7789de--a65c130032194f81bd1924712b75b55f 362e6e3ad6eb4288b2f5507a7e72917a a65c130032194f81bd1924712b75b55f--362e6e3ad6eb4288b2f5507a7e72917a c78dd50cc6424595ae7b6721a5619576 362e6e3ad6eb4288b2f5507a7e72917a--c78dd50cc6424595ae7b6721a5619576 69c84504e580474faaee98b7132906d9 c78dd50cc6424595ae7b6721a5619576--69c84504e580474faaee98b7132906d9 d2371bcdc87b47ea9975a73322d6a4a8 69c84504e580474faaee98b7132906d9--d2371bcdc87b47ea9975a73322d6a4a8 f808ef96f8264cbda1991bae25d2b603 d2371bcdc87b47ea9975a73322d6a4a8--f808ef96f8264cbda1991bae25d2b603 bac66a213bfa413db9e4f985c3e8e787 f808ef96f8264cbda1991bae25d2b603--bac66a213bfa413db9e4f985c3e8e787 5ce3f2e60f7245128f5925a541ac4901 bac66a213bfa413db9e4f985c3e8e787--5ce3f2e60f7245128f5925a541ac4901 c48c5f05ba384d05a783c226be711681 5ce3f2e60f7245128f5925a541ac4901--c48c5f05ba384d05a783c226be711681 7cfc277964e644d291ad22f5aa23d6fa X c48c5f05ba384d05a783c226be711681--7cfc277964e644d291ad22f5aa23d6fa 7cfc277964e644d291ad22f5aa23d6fa--2071c763c1604ae2a3c93559ef64fab1 fd9005b12f7f40d49c1bee38b7f89043 RZ(-1.0*g0) 7cfc277964e644d291ad22f5aa23d6fa--fd9005b12f7f40d49c1bee38b7f89043 84d8d2715f3b4c83a3459224397cc3b4 X fd9005b12f7f40d49c1bee38b7f89043--84d8d2715f3b4c83a3459224397cc3b4 84d8d2715f3b4c83a3459224397cc3b4--908d500226ac44c098baf00199ed3a11 58faa48024f74942a637c51b30b75b09 84d8d2715f3b4c83a3459224397cc3b4--58faa48024f74942a637c51b30b75b09 f4931f3335d64d6eae054fa54f153e38 58faa48024f74942a637c51b30b75b09--f4931f3335d64d6eae054fa54f153e38 adccb6af9b85454a86d4fe7343fd15d1 f4931f3335d64d6eae054fa54f153e38--adccb6af9b85454a86d4fe7343fd15d1 301504712e8e44e6a8e6ed80ac0bc071 adccb6af9b85454a86d4fe7343fd15d1--301504712e8e44e6a8e6ed80ac0bc071 21d134c540514c4b8bd79ae9bf66a296 301504712e8e44e6a8e6ed80ac0bc071--21d134c540514c4b8bd79ae9bf66a296 e556d7e6c2874272a3410b9983a9e24a 21d134c540514c4b8bd79ae9bf66a296--e556d7e6c2874272a3410b9983a9e24a ff4aeb83637649a0a27ad60f0185e6b9 e556d7e6c2874272a3410b9983a9e24a--ff4aeb83637649a0a27ad60f0185e6b9 d8a966abce9f493c8f4af17053d55480 ff4aeb83637649a0a27ad60f0185e6b9--d8a966abce9f493c8f4af17053d55480 0ed1bb2153744daabb34f70379b79ded d8a966abce9f493c8f4af17053d55480--0ed1bb2153744daabb34f70379b79ded a0795c53d2af4013a5072a4a53a3a9f6 0ed1bb2153744daabb34f70379b79ded--a0795c53d2af4013a5072a4a53a3a9f6 85ab7c0a70f24524a790c4f2d5d9a2a0 a0795c53d2af4013a5072a4a53a3a9f6--85ab7c0a70f24524a790c4f2d5d9a2a0 36343c56ff164952880d204bbe13edcc 85ab7c0a70f24524a790c4f2d5d9a2a0--36343c56ff164952880d204bbe13edcc 277f3c2289f4456ca3753b241313cf78 36343c56ff164952880d204bbe13edcc--277f3c2289f4456ca3753b241313cf78 a1b62da66b2440319cb1ab432d9bd099 277f3c2289f4456ca3753b241313cf78--a1b62da66b2440319cb1ab432d9bd099 edb0e56dbb014562a6ddc28ef34a3d59 a1b62da66b2440319cb1ab432d9bd099--edb0e56dbb014562a6ddc28ef34a3d59 cf8759f4fd3c4c909fcb882aba3ae59c edb0e56dbb014562a6ddc28ef34a3d59--cf8759f4fd3c4c909fcb882aba3ae59c 2ad1d3a18d374932bc85b6a66beb72a1 cf8759f4fd3c4c909fcb882aba3ae59c--2ad1d3a18d374932bc85b6a66beb72a1 271a8cd14d4642e2b7eeedbda95cf251 2ad1d3a18d374932bc85b6a66beb72a1--271a8cd14d4642e2b7eeedbda95cf251 f2915340db724097875953e980a5cf46 271a8cd14d4642e2b7eeedbda95cf251--f2915340db724097875953e980a5cf46 20314cf332f64d16abb3c9637b08ce16 f2915340db724097875953e980a5cf46--20314cf332f64d16abb3c9637b08ce16 16c974e493f44977b70d6b97ace024d3 20314cf332f64d16abb3c9637b08ce16--16c974e493f44977b70d6b97ace024d3 e442a07017ef42b1b6b1095a7470deb9 16c974e493f44977b70d6b97ace024d3--e442a07017ef42b1b6b1095a7470deb9 cbd0316e29a146bf9db1ef7db8ca0592 X e442a07017ef42b1b6b1095a7470deb9--cbd0316e29a146bf9db1ef7db8ca0592 cbd0316e29a146bf9db1ef7db8ca0592--2997c7f00d2f4669afe3e85449677222 2d3944d0bbe34949897a77497ec4c72d RZ(-1.0*g0) cbd0316e29a146bf9db1ef7db8ca0592--2d3944d0bbe34949897a77497ec4c72d 2b5b41d131fc4ce0b1fb1d317bf74720 X 2d3944d0bbe34949897a77497ec4c72d--2b5b41d131fc4ce0b1fb1d317bf74720 2b5b41d131fc4ce0b1fb1d317bf74720--3908d765cb574635830a882361cf406e bb0501c75539438d8cdad1a0eaaa4ea0 2b5b41d131fc4ce0b1fb1d317bf74720--bb0501c75539438d8cdad1a0eaaa4ea0 37d48f9a257e4dc3b62ca4072f50b0d0 bb0501c75539438d8cdad1a0eaaa4ea0--37d48f9a257e4dc3b62ca4072f50b0d0 8f7c9e322425427ebbe236d0a73fb6d0 37d48f9a257e4dc3b62ca4072f50b0d0--8f7c9e322425427ebbe236d0a73fb6d0 0e38dbc12e45443d930d0ea94f8b0384 8f7c9e322425427ebbe236d0a73fb6d0--0e38dbc12e45443d930d0ea94f8b0384 08a4e120cf004b6cb3127e9660da0b59 0e38dbc12e45443d930d0ea94f8b0384--08a4e120cf004b6cb3127e9660da0b59 92cda37a5b624dd5bdae3540600d6310 08a4e120cf004b6cb3127e9660da0b59--92cda37a5b624dd5bdae3540600d6310 1fca0842f4154b718f276dad6847b430 X 92cda37a5b624dd5bdae3540600d6310--1fca0842f4154b718f276dad6847b430 1fca0842f4154b718f276dad6847b430--b37d495afeb844daa79c69eaff7fb7de 8b05ebcbb2eb45999332e5249c781753 1fca0842f4154b718f276dad6847b430--8b05ebcbb2eb45999332e5249c781753 4c1e685f196441fa84197e9124bbddc7 8b05ebcbb2eb45999332e5249c781753--4c1e685f196441fa84197e9124bbddc7 660a6421086a4ee9b2aabc909c641059 4c1e685f196441fa84197e9124bbddc7--660a6421086a4ee9b2aabc909c641059 48e79d5b1cbb44858d39e8a9af5e42dc X 660a6421086a4ee9b2aabc909c641059--48e79d5b1cbb44858d39e8a9af5e42dc 48e79d5b1cbb44858d39e8a9af5e42dc--fd39d1f2deb44fbe90d79f1899fc1769 fe7ef6c3a2e640918da56d5c9e9f6b1b 48e79d5b1cbb44858d39e8a9af5e42dc--fe7ef6c3a2e640918da56d5c9e9f6b1b 30dd2b390d3e4133866a3ae8ca996238 fe7ef6c3a2e640918da56d5c9e9f6b1b--30dd2b390d3e4133866a3ae8ca996238 fb6bc624b9154601a339c8761b4a630a 30dd2b390d3e4133866a3ae8ca996238--fb6bc624b9154601a339c8761b4a630a 6b815ef642954789a65f5a639a533a23 fb6bc624b9154601a339c8761b4a630a--6b815ef642954789a65f5a639a533a23 6be143d83b024d8cb93830f4fa15c1f1 6b815ef642954789a65f5a639a533a23--6be143d83b024d8cb93830f4fa15c1f1 4c030d4592c14c1cbb2d782e5822363a X 6be143d83b024d8cb93830f4fa15c1f1--4c030d4592c14c1cbb2d782e5822363a 4c030d4592c14c1cbb2d782e5822363a--85e3714373e3485a9ee0b1ca2ebfbb5c 76405656c0b84d83805e659ece3cffb4 4c030d4592c14c1cbb2d782e5822363a--76405656c0b84d83805e659ece3cffb4 a5fe294817aa4a23be6bd1a241598441 76405656c0b84d83805e659ece3cffb4--a5fe294817aa4a23be6bd1a241598441 52efd90d778240bdaaa5dbe8cd58d0d3 a5fe294817aa4a23be6bd1a241598441--52efd90d778240bdaaa5dbe8cd58d0d3 dec3d570c69847d68a2b9a7e366081c5 X 52efd90d778240bdaaa5dbe8cd58d0d3--dec3d570c69847d68a2b9a7e366081c5 dec3d570c69847d68a2b9a7e366081c5--685867311ef342fba03b7e76a599279f 72efe359870b4ac085b3eb52c78e71c7 dec3d570c69847d68a2b9a7e366081c5--72efe359870b4ac085b3eb52c78e71c7 f463fcc9344540099818666a92b31041 72efe359870b4ac085b3eb52c78e71c7--f463fcc9344540099818666a92b31041 6cf6189347cc45ff8de052d4cc65c082 f463fcc9344540099818666a92b31041--6cf6189347cc45ff8de052d4cc65c082 9139ad1095d8429f8a3bd8ba82fed77b X 6cf6189347cc45ff8de052d4cc65c082--9139ad1095d8429f8a3bd8ba82fed77b 9139ad1095d8429f8a3bd8ba82fed77b--b4e3050781114bb6a42b73e9a8a9576f afa1c382dc8d4ab5bccfed9c6cb3231e 9139ad1095d8429f8a3bd8ba82fed77b--afa1c382dc8d4ab5bccfed9c6cb3231e ce0c5266c7484c558b452f0ddd1e09ba afa1c382dc8d4ab5bccfed9c6cb3231e--ce0c5266c7484c558b452f0ddd1e09ba a45a837d366b42c1b23ad8c29d3e41e4 ce0c5266c7484c558b452f0ddd1e09ba--a45a837d366b42c1b23ad8c29d3e41e4 fb2428ce8a6e4a419bf92b18e7bae382 X a45a837d366b42c1b23ad8c29d3e41e4--fb2428ce8a6e4a419bf92b18e7bae382 fb2428ce8a6e4a419bf92b18e7bae382--b33b4763457e45579f516782530f5063 d0956581ec914d909e6db192f313a88e fb2428ce8a6e4a419bf92b18e7bae382--d0956581ec914d909e6db192f313a88e 44c9e91b8f104fab807b4ed7dd73f023 RX(b06) d0956581ec914d909e6db192f313a88e--44c9e91b8f104fab807b4ed7dd73f023 75a7f0c4d9aa4e72a5853e9dc89ffcb1 44c9e91b8f104fab807b4ed7dd73f023--75a7f0c4d9aa4e72a5853e9dc89ffcb1 6faa014e644142dd834f642e1b3be408 75a7f0c4d9aa4e72a5853e9dc89ffcb1--6faa014e644142dd834f642e1b3be408 a9d12a196ac6422ca40ea508c6cabeff 6faa014e644142dd834f642e1b3be408--a9d12a196ac6422ca40ea508c6cabeff dd372a35295749e790950f98ab9b971c a9d12a196ac6422ca40ea508c6cabeff--dd372a35295749e790950f98ab9b971c cf63db2cee6f4e7a87ca4db5cd7daca0 dd372a35295749e790950f98ab9b971c--cf63db2cee6f4e7a87ca4db5cd7daca0 f78f1d42b0a14df382fad5c79bb9a538 X cf63db2cee6f4e7a87ca4db5cd7daca0--f78f1d42b0a14df382fad5c79bb9a538 f78f1d42b0a14df382fad5c79bb9a538--988994f4ca2c4ae284065844b8fff465 02f0b266db214cb0b7610544a74d01ce f78f1d42b0a14df382fad5c79bb9a538--02f0b266db214cb0b7610544a74d01ce 156b00ab6b784f55b739bc156eec62d3 02f0b266db214cb0b7610544a74d01ce--156b00ab6b784f55b739bc156eec62d3 016eb013ea30470ab31bf5282988165d 156b00ab6b784f55b739bc156eec62d3--016eb013ea30470ab31bf5282988165d c2930d3e41274e5f981ba1645c134ad4 X 016eb013ea30470ab31bf5282988165d--c2930d3e41274e5f981ba1645c134ad4 c2930d3e41274e5f981ba1645c134ad4--7f5f74270ebb4fbca38c04425318136a 246084dae8724f97a9c118f101cd25a6 c2930d3e41274e5f981ba1645c134ad4--246084dae8724f97a9c118f101cd25a6 804d7fa16a4a487aa2ca022d6b4171da 246084dae8724f97a9c118f101cd25a6--804d7fa16a4a487aa2ca022d6b4171da 8b6e41f383f44cae8bab44eb7b9ec7ea 804d7fa16a4a487aa2ca022d6b4171da--8b6e41f383f44cae8bab44eb7b9ec7ea d034f585f22640ee91572ee323ef02c3 8b6e41f383f44cae8bab44eb7b9ec7ea--d034f585f22640ee91572ee323ef02c3 f25104b7e9794a72885c843be5b21a68 d034f585f22640ee91572ee323ef02c3--f25104b7e9794a72885c843be5b21a68 ca78f9a704f44b17b924f77d8fc8e3b1 f25104b7e9794a72885c843be5b21a68--ca78f9a704f44b17b924f77d8fc8e3b1 8d8e4153325b4c1cbd053c4516a20e8f ca78f9a704f44b17b924f77d8fc8e3b1--8d8e4153325b4c1cbd053c4516a20e8f 5de113bba70b4c92a007663eb467aaf8 8d8e4153325b4c1cbd053c4516a20e8f--5de113bba70b4c92a007663eb467aaf8 1b204a53efb84b768d846947e6fec175 5de113bba70b4c92a007663eb467aaf8--1b204a53efb84b768d846947e6fec175 7194c644b95d4ebdb2e887a340b5e2c7 1b204a53efb84b768d846947e6fec175--7194c644b95d4ebdb2e887a340b5e2c7 229222ba25964bc6a36073a765972d8d 7194c644b95d4ebdb2e887a340b5e2c7--229222ba25964bc6a36073a765972d8d 31e5e352839b4ea19c194cbdede90e9d 229222ba25964bc6a36073a765972d8d--31e5e352839b4ea19c194cbdede90e9d 21a9c4725966431bb7838fcaeced4af5 31e5e352839b4ea19c194cbdede90e9d--21a9c4725966431bb7838fcaeced4af5 b66064f80b3446b38fbf6afdc23e0707 21a9c4725966431bb7838fcaeced4af5--b66064f80b3446b38fbf6afdc23e0707 3daf2b37fa6e4377bb48c483ebab9e4b b66064f80b3446b38fbf6afdc23e0707--3daf2b37fa6e4377bb48c483ebab9e4b 95ee33e9746f4c5e8b93eca14f777f7b 3daf2b37fa6e4377bb48c483ebab9e4b--95ee33e9746f4c5e8b93eca14f777f7b 766d4b54d0bc45de86ee71bc55e4cd4c 95ee33e9746f4c5e8b93eca14f777f7b--766d4b54d0bc45de86ee71bc55e4cd4c ab554b1a7537457db151df95df6c206d 766d4b54d0bc45de86ee71bc55e4cd4c--ab554b1a7537457db151df95df6c206d 02fd74b21d67421a92906aeb21238650 ab554b1a7537457db151df95df6c206d--02fd74b21d67421a92906aeb21238650 5b98ee3585a944d3970adca2badf0952 02fd74b21d67421a92906aeb21238650--5b98ee3585a944d3970adca2badf0952 73a63b37cf974cbaa72e3205ee1a4457 5b98ee3585a944d3970adca2badf0952--73a63b37cf974cbaa72e3205ee1a4457 3febf8b4c5324f2ab342c90696406a70 73a63b37cf974cbaa72e3205ee1a4457--3febf8b4c5324f2ab342c90696406a70 8e7291b308d540b7bf04e482d74330f1 3febf8b4c5324f2ab342c90696406a70--8e7291b308d540b7bf04e482d74330f1 fd4221d5fed14a99aba3131744f32057 8e7291b308d540b7bf04e482d74330f1--fd4221d5fed14a99aba3131744f32057 5af3dee2a6654b8381f05ce4a6565279 fd4221d5fed14a99aba3131744f32057--5af3dee2a6654b8381f05ce4a6565279 c174bfac96504a4da65ed11fee7e1ea1 5af3dee2a6654b8381f05ce4a6565279--c174bfac96504a4da65ed11fee7e1ea1 886555ee07824409a5252f0d3f141cfc c174bfac96504a4da65ed11fee7e1ea1--886555ee07824409a5252f0d3f141cfc 1e62f1e1ef664e39a509ff0849a83e38 886555ee07824409a5252f0d3f141cfc--1e62f1e1ef664e39a509ff0849a83e38 72d29e83f15547f5bd6709c3accce18f 1e62f1e1ef664e39a509ff0849a83e38--72d29e83f15547f5bd6709c3accce18f 80f2be2f76444be888ed2126f2e43198 72d29e83f15547f5bd6709c3accce18f--80f2be2f76444be888ed2126f2e43198 7d97679408234960b60df0d1f5ff5a1c 80f2be2f76444be888ed2126f2e43198--7d97679408234960b60df0d1f5ff5a1c 0b0ca3dbe05f471797124d6d08c21871 7d97679408234960b60df0d1f5ff5a1c--0b0ca3dbe05f471797124d6d08c21871 342c5d629ac442fba01ecd7dd266d076 0b0ca3dbe05f471797124d6d08c21871--342c5d629ac442fba01ecd7dd266d076 7cd8353a54a943718ee67357859f03c4 342c5d629ac442fba01ecd7dd266d076--7cd8353a54a943718ee67357859f03c4 19b3b48995c846f3b256daad6fed22b5 7cd8353a54a943718ee67357859f03c4--19b3b48995c846f3b256daad6fed22b5 2f5a33eae5b946c3abb05fb125fd6026 19b3b48995c846f3b256daad6fed22b5--2f5a33eae5b946c3abb05fb125fd6026 52ae3393fb5143b2af75bcab952c3956 2f5a33eae5b946c3abb05fb125fd6026--52ae3393fb5143b2af75bcab952c3956 c051b38c92d64e3f8a130df9f405b9bf 52ae3393fb5143b2af75bcab952c3956--c051b38c92d64e3f8a130df9f405b9bf 5482601301214c43a1272bf62683cd4e c051b38c92d64e3f8a130df9f405b9bf--5482601301214c43a1272bf62683cd4e 6ecd38f212a348e2844acb7c016b7209 5482601301214c43a1272bf62683cd4e--6ecd38f212a348e2844acb7c016b7209 3295decbd1fe4c3087eb3f376180db05 6ecd38f212a348e2844acb7c016b7209--3295decbd1fe4c3087eb3f376180db05 776b9b15aeef48cda2b307dfbfdfe024 3295decbd1fe4c3087eb3f376180db05--776b9b15aeef48cda2b307dfbfdfe024 e5879aa49c204fa4a993dc4aed75b636 776b9b15aeef48cda2b307dfbfdfe024--e5879aa49c204fa4a993dc4aed75b636 a2ce638c7983421b8162f21d33595336 e5879aa49c204fa4a993dc4aed75b636--a2ce638c7983421b8162f21d33595336 1f68d2299117427a8134f03c7d0a1ff6 a2ce638c7983421b8162f21d33595336--1f68d2299117427a8134f03c7d0a1ff6 e665d85cbe0c4e878a9f4a53627a2616 1f68d2299117427a8134f03c7d0a1ff6--e665d85cbe0c4e878a9f4a53627a2616 b910ce7e2fb24f03aba3f2227e213366 e665d85cbe0c4e878a9f4a53627a2616--b910ce7e2fb24f03aba3f2227e213366 19ecb0a0411f481380ba227dd52caacf b910ce7e2fb24f03aba3f2227e213366--19ecb0a0411f481380ba227dd52caacf f83e742f3b1141018a3c64b52dd3b2eb 19ecb0a0411f481380ba227dd52caacf--f83e742f3b1141018a3c64b52dd3b2eb 9ea5a8364f8c4440b6e41cd0448d3a63 f83e742f3b1141018a3c64b52dd3b2eb--9ea5a8364f8c4440b6e41cd0448d3a63 c1f71983a197450fa42bbe82d8f1c1bf X 9ea5a8364f8c4440b6e41cd0448d3a63--c1f71983a197450fa42bbe82d8f1c1bf c1f71983a197450fa42bbe82d8f1c1bf--c9d40a6351ca4486aee12ba2a4c11eac 8922be02c9374564b13b83fac99c2fc8 RZ(-1.0*g1) c1f71983a197450fa42bbe82d8f1c1bf--8922be02c9374564b13b83fac99c2fc8 f8fdb771b6734b3cbc6c9c310e939976 X 8922be02c9374564b13b83fac99c2fc8--f8fdb771b6734b3cbc6c9c310e939976 f8fdb771b6734b3cbc6c9c310e939976--2eca3202096447afb64b6378b4ebd44a 74e7284af65042e0a3f7ef18eda35a24 f8fdb771b6734b3cbc6c9c310e939976--74e7284af65042e0a3f7ef18eda35a24 f4de966fdc8244f5b0fa04f554860d9d 74e7284af65042e0a3f7ef18eda35a24--f4de966fdc8244f5b0fa04f554860d9d d951811941ba4051a3916e70fdb958c4 f4de966fdc8244f5b0fa04f554860d9d--d951811941ba4051a3916e70fdb958c4 cf2c857f2ab44ac383829c86c6bdc7af d951811941ba4051a3916e70fdb958c4--cf2c857f2ab44ac383829c86c6bdc7af 394f6822c132402bb4026f2220d76cef cf2c857f2ab44ac383829c86c6bdc7af--394f6822c132402bb4026f2220d76cef 4f5dd93215094250a278e61399e82031 394f6822c132402bb4026f2220d76cef--4f5dd93215094250a278e61399e82031 eafc7c4eb7344a07bd61cf75449a4aba 4f5dd93215094250a278e61399e82031--eafc7c4eb7344a07bd61cf75449a4aba 6533d8ca7a3841fc86597146cd8c8c5b eafc7c4eb7344a07bd61cf75449a4aba--6533d8ca7a3841fc86597146cd8c8c5b 8ecccbc7f8c045cdaeff13cb1043bc38 6533d8ca7a3841fc86597146cd8c8c5b--8ecccbc7f8c045cdaeff13cb1043bc38 595c4eaa5aa34593be6cf76835277896 8ecccbc7f8c045cdaeff13cb1043bc38--595c4eaa5aa34593be6cf76835277896 3bf04190a3f14157ad9277fb0f3fd439 595c4eaa5aa34593be6cf76835277896--3bf04190a3f14157ad9277fb0f3fd439 0cdb8c53e3d747dfa3cbaf58a36323bf 3bf04190a3f14157ad9277fb0f3fd439--0cdb8c53e3d747dfa3cbaf58a36323bf cdfec217a550492f80f5dd4fae3b395f 0cdb8c53e3d747dfa3cbaf58a36323bf--cdfec217a550492f80f5dd4fae3b395f 4cfc4b6765c24c36837afb560b86c569 cdfec217a550492f80f5dd4fae3b395f--4cfc4b6765c24c36837afb560b86c569 2e17fdb498764c3094b0eead79dd5b50 4cfc4b6765c24c36837afb560b86c569--2e17fdb498764c3094b0eead79dd5b50 5e8212a31dcc4c1bae57c458d516436f 2e17fdb498764c3094b0eead79dd5b50--5e8212a31dcc4c1bae57c458d516436f fc0d7f27cb76422ca57992a711e97a12 5e8212a31dcc4c1bae57c458d516436f--fc0d7f27cb76422ca57992a711e97a12 d2b580dc5c5044e18a96143d13251260 fc0d7f27cb76422ca57992a711e97a12--d2b580dc5c5044e18a96143d13251260 94a0812d726c4a64962c90dc3ca407f1 d2b580dc5c5044e18a96143d13251260--94a0812d726c4a64962c90dc3ca407f1 d89d3814f99f4b868f4a3040c200d7c3 94a0812d726c4a64962c90dc3ca407f1--d89d3814f99f4b868f4a3040c200d7c3 3f70dec738ed406aa8f3066bbb89704e d89d3814f99f4b868f4a3040c200d7c3--3f70dec738ed406aa8f3066bbb89704e 4f7edd56b49f45b090391edad17b8bf4 3f70dec738ed406aa8f3066bbb89704e--4f7edd56b49f45b090391edad17b8bf4 5f7d7cd81e304f08b77635bad6b978f7 X 4f7edd56b49f45b090391edad17b8bf4--5f7d7cd81e304f08b77635bad6b978f7 5f7d7cd81e304f08b77635bad6b978f7--f9c49a6d9b3a488c8c70f8f6f842d1fe 54ed3f9ffbdf46f08f5cfa5512734ad5 RZ(-1.0*g1) 5f7d7cd81e304f08b77635bad6b978f7--54ed3f9ffbdf46f08f5cfa5512734ad5 3bc1250527084bafb0727ae0ba5bfda4 X 54ed3f9ffbdf46f08f5cfa5512734ad5--3bc1250527084bafb0727ae0ba5bfda4 3bc1250527084bafb0727ae0ba5bfda4--12b9fbf7d8b94ff08b47a6187f838eec e62bb55f0f47443ea023e39be20d99c6 3bc1250527084bafb0727ae0ba5bfda4--e62bb55f0f47443ea023e39be20d99c6 e6acfa13cf4c419ead2d6b6371acc625 e62bb55f0f47443ea023e39be20d99c6--e6acfa13cf4c419ead2d6b6371acc625 733bb076727848c38dbb40beabefaaa4 e6acfa13cf4c419ead2d6b6371acc625--733bb076727848c38dbb40beabefaaa4 b522d2e969184de98eabcd45c5db94b6 733bb076727848c38dbb40beabefaaa4--b522d2e969184de98eabcd45c5db94b6 0e0fff40a54d4001970552d0a27867e1 b522d2e969184de98eabcd45c5db94b6--0e0fff40a54d4001970552d0a27867e1 fad625b11baa427697cfd9778052fbf3 0e0fff40a54d4001970552d0a27867e1--fad625b11baa427697cfd9778052fbf3 a21b543abdfb4c5cb3f6a569060e0b47 X fad625b11baa427697cfd9778052fbf3--a21b543abdfb4c5cb3f6a569060e0b47 a21b543abdfb4c5cb3f6a569060e0b47--40519a88d2ad49e18539d00f2ef4ebcd c6d38dbf41574cdda10257fcf3cc6a3a a21b543abdfb4c5cb3f6a569060e0b47--c6d38dbf41574cdda10257fcf3cc6a3a 97f21e1ff6b54c2a9faded925234b75a c6d38dbf41574cdda10257fcf3cc6a3a--97f21e1ff6b54c2a9faded925234b75a a4e72ac3248f42d1b5156906230e5b83 97f21e1ff6b54c2a9faded925234b75a--a4e72ac3248f42d1b5156906230e5b83 e8ff434debb1472bbc253000ce1457ca X a4e72ac3248f42d1b5156906230e5b83--e8ff434debb1472bbc253000ce1457ca e8ff434debb1472bbc253000ce1457ca--5ede3c48b9f248a7adb95598451b2ffd d6290285e5a94f7f8347828879f043ca e8ff434debb1472bbc253000ce1457ca--d6290285e5a94f7f8347828879f043ca a0ad956562f84afabebdc89d06235578 d6290285e5a94f7f8347828879f043ca--a0ad956562f84afabebdc89d06235578 1ae394aafd7f4244a8deae9fa2836e0e a0ad956562f84afabebdc89d06235578--1ae394aafd7f4244a8deae9fa2836e0e b1b8e4f9f25447b8a4e80fa59103df2c 1ae394aafd7f4244a8deae9fa2836e0e--b1b8e4f9f25447b8a4e80fa59103df2c 8d70fde442704c1197dce999749dee28 b1b8e4f9f25447b8a4e80fa59103df2c--8d70fde442704c1197dce999749dee28 09912a8c9d454a3f9cb26b4a4e7fec1d X 8d70fde442704c1197dce999749dee28--09912a8c9d454a3f9cb26b4a4e7fec1d 09912a8c9d454a3f9cb26b4a4e7fec1d--0236e8ffdfd546b5a17f65729d348299 f152bf4e0e9e4690bcee126836a8a42a 09912a8c9d454a3f9cb26b4a4e7fec1d--f152bf4e0e9e4690bcee126836a8a42a 6477a5ea51ca46789244dc6c2d692fc0 f152bf4e0e9e4690bcee126836a8a42a--6477a5ea51ca46789244dc6c2d692fc0 e06d0553324c45f5b49dd832e1790e9e 6477a5ea51ca46789244dc6c2d692fc0--e06d0553324c45f5b49dd832e1790e9e f2295f81ceb84b1c8cfea4456c9ed082 X e06d0553324c45f5b49dd832e1790e9e--f2295f81ceb84b1c8cfea4456c9ed082 f2295f81ceb84b1c8cfea4456c9ed082--094dd13676404a66b1019c3e9afdcce1 002c2f8b64434db89c57c6ff05af5894 f2295f81ceb84b1c8cfea4456c9ed082--002c2f8b64434db89c57c6ff05af5894 00c6fb1717524da281ac6e321c27ec97 002c2f8b64434db89c57c6ff05af5894--00c6fb1717524da281ac6e321c27ec97 63488750274940e3855cd14920741bca 00c6fb1717524da281ac6e321c27ec97--63488750274940e3855cd14920741bca ca42070484e741418f9b88dec371ccb9 X 63488750274940e3855cd14920741bca--ca42070484e741418f9b88dec371ccb9 ca42070484e741418f9b88dec371ccb9--0ec58f2c501b4829bd19cfff383c5c13 96f279432b9d4ee2843629869062f844 ca42070484e741418f9b88dec371ccb9--96f279432b9d4ee2843629869062f844 b501452bdd5d454eb4b0ceaf49777684 96f279432b9d4ee2843629869062f844--b501452bdd5d454eb4b0ceaf49777684 0b677f22d0f04012b2d44575d403fe55 b501452bdd5d454eb4b0ceaf49777684--0b677f22d0f04012b2d44575d403fe55 fd741c8161394ac5add23d5413907dee X 0b677f22d0f04012b2d44575d403fe55--fd741c8161394ac5add23d5413907dee fd741c8161394ac5add23d5413907dee--94b3d332199a4a7b86352a4aeb78dce6 eac1faf8f9a84b0788d2f3bd030e382c fd741c8161394ac5add23d5413907dee--eac1faf8f9a84b0788d2f3bd030e382c 4dac8a5ec52e42cb8a20cfcf71056572 RX(b16) eac1faf8f9a84b0788d2f3bd030e382c--4dac8a5ec52e42cb8a20cfcf71056572 4dac8a5ec52e42cb8a20cfcf71056572--be3e57d62277436a95b3a9437d99ab46 b1d0beec1ff44e7096da0a628cefc418 584c88c88b244c7186b2cee4f95e317f a09dda7b21af450dad7db19114a54dc8--584c88c88b244c7186b2cee4f95e317f d2929bc29a07474fa1933438c1f6e123 584c88c88b244c7186b2cee4f95e317f--d2929bc29a07474fa1933438c1f6e123 6349d327de3344c3b39c51488cd8ecb9 d2929bc29a07474fa1933438c1f6e123--6349d327de3344c3b39c51488cd8ecb9 5db0ec096f6246a6bb0e7bc2c5795fd1 6349d327de3344c3b39c51488cd8ecb9--5db0ec096f6246a6bb0e7bc2c5795fd1 b42ec38de1f7448cbb824e4f72c7eaaa 5db0ec096f6246a6bb0e7bc2c5795fd1--b42ec38de1f7448cbb824e4f72c7eaaa 484a5030817942ee9f5b46cb7254ef0b b42ec38de1f7448cbb824e4f72c7eaaa--484a5030817942ee9f5b46cb7254ef0b 19b80f575bc14b89a535605c8de0ef47 X 484a5030817942ee9f5b46cb7254ef0b--19b80f575bc14b89a535605c8de0ef47 19b80f575bc14b89a535605c8de0ef47--e4eca6c93e734fb48d6ed9b955569522 bccdeff1ead9488fb9c3ac394913cc0b RZ(1.0*g0) 19b80f575bc14b89a535605c8de0ef47--bccdeff1ead9488fb9c3ac394913cc0b 6571c5463f274f07aff3eec1984d358e X bccdeff1ead9488fb9c3ac394913cc0b--6571c5463f274f07aff3eec1984d358e 6571c5463f274f07aff3eec1984d358e--56a532b221a04988b35fab6012c0f19c 52f34a0404b54c92b14ca3de5ab1777e 6571c5463f274f07aff3eec1984d358e--52f34a0404b54c92b14ca3de5ab1777e 6676048d548644cfab7c157b6b5a544e 52f34a0404b54c92b14ca3de5ab1777e--6676048d548644cfab7c157b6b5a544e 41031bb563e94c09821f60a2252e1590 6676048d548644cfab7c157b6b5a544e--41031bb563e94c09821f60a2252e1590 4cd02696b8ae43a082f645bf6e600b29 41031bb563e94c09821f60a2252e1590--4cd02696b8ae43a082f645bf6e600b29 73c12b4062164dba8512f686af4f37bf 4cd02696b8ae43a082f645bf6e600b29--73c12b4062164dba8512f686af4f37bf bfa65172af3945339a1cbeb93af087ff 73c12b4062164dba8512f686af4f37bf--bfa65172af3945339a1cbeb93af087ff ea530b236b7c4c008d67f066a1df643d bfa65172af3945339a1cbeb93af087ff--ea530b236b7c4c008d67f066a1df643d d1b5130b777a491d9669cadcfb362923 ea530b236b7c4c008d67f066a1df643d--d1b5130b777a491d9669cadcfb362923 994945e89225435bb419da38d164a1b2 d1b5130b777a491d9669cadcfb362923--994945e89225435bb419da38d164a1b2 1ee837b3433a414091c2e30ed69b6bf1 994945e89225435bb419da38d164a1b2--1ee837b3433a414091c2e30ed69b6bf1 1ec228a0bd8b422f8d855bf7ac5147a1 1ee837b3433a414091c2e30ed69b6bf1--1ec228a0bd8b422f8d855bf7ac5147a1 776007a89f134e59bcd41fb7592c4ddb 1ec228a0bd8b422f8d855bf7ac5147a1--776007a89f134e59bcd41fb7592c4ddb 15f1148eab414665b621811f1fb554b7 776007a89f134e59bcd41fb7592c4ddb--15f1148eab414665b621811f1fb554b7 775781fed13f4a50b177305796d4accf 15f1148eab414665b621811f1fb554b7--775781fed13f4a50b177305796d4accf c25a5858ca5c4c0aae8063522062f653 775781fed13f4a50b177305796d4accf--c25a5858ca5c4c0aae8063522062f653 83329180362845da81c52762a2b24b29 c25a5858ca5c4c0aae8063522062f653--83329180362845da81c52762a2b24b29 e8235e3f892c48aabc3bb333bbfa9eba 83329180362845da81c52762a2b24b29--e8235e3f892c48aabc3bb333bbfa9eba b98498b8aa8d453f8bf60431f64139cb e8235e3f892c48aabc3bb333bbfa9eba--b98498b8aa8d453f8bf60431f64139cb e178c0f7115448eeb2a46d50ce995525 b98498b8aa8d453f8bf60431f64139cb--e178c0f7115448eeb2a46d50ce995525 da6f628bf4234887b85c88878f629c61 e178c0f7115448eeb2a46d50ce995525--da6f628bf4234887b85c88878f629c61 94fc5d73f6a54d238fd8ad0a6c4b1252 da6f628bf4234887b85c88878f629c61--94fc5d73f6a54d238fd8ad0a6c4b1252 84ca58615bad4f85b2a05afb554ea571 94fc5d73f6a54d238fd8ad0a6c4b1252--84ca58615bad4f85b2a05afb554ea571 fe5f01d2087c43e5a13794d8af9eb7dc 84ca58615bad4f85b2a05afb554ea571--fe5f01d2087c43e5a13794d8af9eb7dc c8437c59fff44b198715d76afc09dba4 fe5f01d2087c43e5a13794d8af9eb7dc--c8437c59fff44b198715d76afc09dba4 eacb2e4a4010459ab313826b80f0ba19 c8437c59fff44b198715d76afc09dba4--eacb2e4a4010459ab313826b80f0ba19 b016e45d170b4513ad8dbbbc0019ca43 eacb2e4a4010459ab313826b80f0ba19--b016e45d170b4513ad8dbbbc0019ca43 c69e8d92d9784b56899a4a78fc7ee6cd b016e45d170b4513ad8dbbbc0019ca43--c69e8d92d9784b56899a4a78fc7ee6cd 7fb4c8d4f8d94e6989da633fc4bf4f25 c69e8d92d9784b56899a4a78fc7ee6cd--7fb4c8d4f8d94e6989da633fc4bf4f25 e5337004e9344ba18e0b8c2455d18b31 7fb4c8d4f8d94e6989da633fc4bf4f25--e5337004e9344ba18e0b8c2455d18b31 1cfb994a140a47099a78669197a912b7 e5337004e9344ba18e0b8c2455d18b31--1cfb994a140a47099a78669197a912b7 439718ea53d94a068b16166dd21ed654 1cfb994a140a47099a78669197a912b7--439718ea53d94a068b16166dd21ed654 3d25d615f001453c85978d49ea1ee388 439718ea53d94a068b16166dd21ed654--3d25d615f001453c85978d49ea1ee388 91df542c99b84f8f86e37e98ab875458 3d25d615f001453c85978d49ea1ee388--91df542c99b84f8f86e37e98ab875458 16330b4787004bb6835cdbbfe1c90a6e 91df542c99b84f8f86e37e98ab875458--16330b4787004bb6835cdbbfe1c90a6e 7b792aad7675437a90c1eaacb0ee727d 16330b4787004bb6835cdbbfe1c90a6e--7b792aad7675437a90c1eaacb0ee727d 9c7228a220cf4bcabc7e71acb7def18b 7b792aad7675437a90c1eaacb0ee727d--9c7228a220cf4bcabc7e71acb7def18b 5d7e6a6a4b7a46a5906053ef9ea41bf1 9c7228a220cf4bcabc7e71acb7def18b--5d7e6a6a4b7a46a5906053ef9ea41bf1 0bd076456a6c447b82404e8d76c8a13c 5d7e6a6a4b7a46a5906053ef9ea41bf1--0bd076456a6c447b82404e8d76c8a13c 9fdb09f41aef46c3a9427086ca91cb88 0bd076456a6c447b82404e8d76c8a13c--9fdb09f41aef46c3a9427086ca91cb88 53f308bfe41e4473b8e72aa1c75078e3 9fdb09f41aef46c3a9427086ca91cb88--53f308bfe41e4473b8e72aa1c75078e3 a4f6fcfe20ca404da114e1b318bf5528 53f308bfe41e4473b8e72aa1c75078e3--a4f6fcfe20ca404da114e1b318bf5528 a8eb04f66211469ebb5be2adb3df7752 a4f6fcfe20ca404da114e1b318bf5528--a8eb04f66211469ebb5be2adb3df7752 3db53b7cc1d14605bb16a8aacfd3a3f2 a8eb04f66211469ebb5be2adb3df7752--3db53b7cc1d14605bb16a8aacfd3a3f2 3e47863405064f3286c41f9b5c957290 3db53b7cc1d14605bb16a8aacfd3a3f2--3e47863405064f3286c41f9b5c957290 b23ed1228f9b4a28bf02d3fa4713f8a9 3e47863405064f3286c41f9b5c957290--b23ed1228f9b4a28bf02d3fa4713f8a9 0b358d391b3349c2b5eba4737e665dac b23ed1228f9b4a28bf02d3fa4713f8a9--0b358d391b3349c2b5eba4737e665dac 0953a253bed546c69640504b2ad3cabb 0b358d391b3349c2b5eba4737e665dac--0953a253bed546c69640504b2ad3cabb e917d6ae0a7843d0b65c8b952b641f0b 0953a253bed546c69640504b2ad3cabb--e917d6ae0a7843d0b65c8b952b641f0b 186304ca66eb4cacbc204c033e9616fe e917d6ae0a7843d0b65c8b952b641f0b--186304ca66eb4cacbc204c033e9616fe d6ea29efda0649b4a4575f6bcc8fe6f6 186304ca66eb4cacbc204c033e9616fe--d6ea29efda0649b4a4575f6bcc8fe6f6 90f97ed094e343cf8596e8adb06a6997 d6ea29efda0649b4a4575f6bcc8fe6f6--90f97ed094e343cf8596e8adb06a6997 28f88b8b5b094c568eec033d5ce51228 90f97ed094e343cf8596e8adb06a6997--28f88b8b5b094c568eec033d5ce51228 1a4f205cb91642b982aa43d2a1385d6e 28f88b8b5b094c568eec033d5ce51228--1a4f205cb91642b982aa43d2a1385d6e 8a8a5f9605e244f4a618cdc1d47ef38a 1a4f205cb91642b982aa43d2a1385d6e--8a8a5f9605e244f4a618cdc1d47ef38a 829d7dea176e40348b6296160dc1f31e 8a8a5f9605e244f4a618cdc1d47ef38a--829d7dea176e40348b6296160dc1f31e 135562eebc2448fe9e2164c12fbbbd71 829d7dea176e40348b6296160dc1f31e--135562eebc2448fe9e2164c12fbbbd71 768d8f9e3277428ca5b20f7253097704 135562eebc2448fe9e2164c12fbbbd71--768d8f9e3277428ca5b20f7253097704 59272295977d40e2bf8e1bd5a9823f82 768d8f9e3277428ca5b20f7253097704--59272295977d40e2bf8e1bd5a9823f82 604f1ceb902c4b17ad55b61de4640fec 59272295977d40e2bf8e1bd5a9823f82--604f1ceb902c4b17ad55b61de4640fec a9bc624d52484622aa63cb711e194eb5 604f1ceb902c4b17ad55b61de4640fec--a9bc624d52484622aa63cb711e194eb5 d37e7cd8863e4829906a60475a8f4c58 a9bc624d52484622aa63cb711e194eb5--d37e7cd8863e4829906a60475a8f4c58 8bdb6f58a28742e4a8c115fc541e94c6 d37e7cd8863e4829906a60475a8f4c58--8bdb6f58a28742e4a8c115fc541e94c6 f3801f0a0a9d43179b971a5dd4d5a595 8bdb6f58a28742e4a8c115fc541e94c6--f3801f0a0a9d43179b971a5dd4d5a595 5a1a73be30804457993061a81ecc3551 f3801f0a0a9d43179b971a5dd4d5a595--5a1a73be30804457993061a81ecc3551 ad8357de7e4f4775bf2130fc069c79c9 5a1a73be30804457993061a81ecc3551--ad8357de7e4f4775bf2130fc069c79c9 005077185cdd429a99075603d82eba08 ad8357de7e4f4775bf2130fc069c79c9--005077185cdd429a99075603d82eba08 3cc11e3cd4c848e0831bb196516bdf5c 005077185cdd429a99075603d82eba08--3cc11e3cd4c848e0831bb196516bdf5c 5c0c0d72444c4e8fbd055800de30412b 3cc11e3cd4c848e0831bb196516bdf5c--5c0c0d72444c4e8fbd055800de30412b 1ed2c8672d174895bafd87d284f89afb 5c0c0d72444c4e8fbd055800de30412b--1ed2c8672d174895bafd87d284f89afb 1773958ade0947a8a880af4878cb7a9b 1ed2c8672d174895bafd87d284f89afb--1773958ade0947a8a880af4878cb7a9b 0b1a98544dcb488e97f7bade154ca80f 1773958ade0947a8a880af4878cb7a9b--0b1a98544dcb488e97f7bade154ca80f 5685225fd24e443380ad227b0f769edd 0b1a98544dcb488e97f7bade154ca80f--5685225fd24e443380ad227b0f769edd 20250566d6cd4eea88c379722ae0a741 5685225fd24e443380ad227b0f769edd--20250566d6cd4eea88c379722ae0a741 e4f843a54230462190705e8c275a505b 20250566d6cd4eea88c379722ae0a741--e4f843a54230462190705e8c275a505b 38161143675a4e25bfd825b17b41f6bd e4f843a54230462190705e8c275a505b--38161143675a4e25bfd825b17b41f6bd 4f9f830c5d2149c9b9cea1624181fb0d 38161143675a4e25bfd825b17b41f6bd--4f9f830c5d2149c9b9cea1624181fb0d 7150bd4f0fb645fb9f5248b549eeca11 4f9f830c5d2149c9b9cea1624181fb0d--7150bd4f0fb645fb9f5248b549eeca11 8a001f641cf549219eaeaf41125c90e3 7150bd4f0fb645fb9f5248b549eeca11--8a001f641cf549219eaeaf41125c90e3 b2ae84dd82634aa6b47a6d4285f39dd3 8a001f641cf549219eaeaf41125c90e3--b2ae84dd82634aa6b47a6d4285f39dd3 59e4f3066ced4e2ea7452f955c585f6f b2ae84dd82634aa6b47a6d4285f39dd3--59e4f3066ced4e2ea7452f955c585f6f 617956d715ce437cba7ef571db3d3541 59e4f3066ced4e2ea7452f955c585f6f--617956d715ce437cba7ef571db3d3541 1ad1428db2824e578f7bff7158e3e581 617956d715ce437cba7ef571db3d3541--1ad1428db2824e578f7bff7158e3e581 a20f874286c047ebba39848e2274a00b 1ad1428db2824e578f7bff7158e3e581--a20f874286c047ebba39848e2274a00b a223c94cbb21426597aa882d8688a491 a20f874286c047ebba39848e2274a00b--a223c94cbb21426597aa882d8688a491 b2ff140d5cca470fad8ac80bb6d371b6 a223c94cbb21426597aa882d8688a491--b2ff140d5cca470fad8ac80bb6d371b6 fa7523f102964f5d900ff0bcd151b6b6 b2ff140d5cca470fad8ac80bb6d371b6--fa7523f102964f5d900ff0bcd151b6b6 fddc89b111bf4b5181eed6678131b9bb X fa7523f102964f5d900ff0bcd151b6b6--fddc89b111bf4b5181eed6678131b9bb fddc89b111bf4b5181eed6678131b9bb--8b05ebcbb2eb45999332e5249c781753 7d2c48c9789049bcadf5c2f25c8a9f8e RZ(-1.0*g0) fddc89b111bf4b5181eed6678131b9bb--7d2c48c9789049bcadf5c2f25c8a9f8e 8f603f8130774f25868d38421837eecf X 7d2c48c9789049bcadf5c2f25c8a9f8e--8f603f8130774f25868d38421837eecf 8f603f8130774f25868d38421837eecf--660a6421086a4ee9b2aabc909c641059 cdc3fb9a7333425997adc2d26a5e68d9 8f603f8130774f25868d38421837eecf--cdc3fb9a7333425997adc2d26a5e68d9 cb9dcd2fefda44f99060cab107034435 cdc3fb9a7333425997adc2d26a5e68d9--cb9dcd2fefda44f99060cab107034435 145bf8fb09404679b58333d857a976b0 cb9dcd2fefda44f99060cab107034435--145bf8fb09404679b58333d857a976b0 db761eafd7494187b7ee0c01d3a96289 145bf8fb09404679b58333d857a976b0--db761eafd7494187b7ee0c01d3a96289 017a8fe16e6f4ed89595263cbcec9f7e db761eafd7494187b7ee0c01d3a96289--017a8fe16e6f4ed89595263cbcec9f7e db75de47e9fc4d00a00596d04a45351b 017a8fe16e6f4ed89595263cbcec9f7e--db75de47e9fc4d00a00596d04a45351b 061e6c07b0d745a1b7adf6624dd308c1 db75de47e9fc4d00a00596d04a45351b--061e6c07b0d745a1b7adf6624dd308c1 5a14d073d4534adbbb8217507887ede2 X 061e6c07b0d745a1b7adf6624dd308c1--5a14d073d4534adbbb8217507887ede2 5a14d073d4534adbbb8217507887ede2--76405656c0b84d83805e659ece3cffb4 ebedb97eddd84d7fb6db55e8d475083c RZ(-1.0*g0) 5a14d073d4534adbbb8217507887ede2--ebedb97eddd84d7fb6db55e8d475083c 17c529569248439ba0feee517a5d83aa X ebedb97eddd84d7fb6db55e8d475083c--17c529569248439ba0feee517a5d83aa 17c529569248439ba0feee517a5d83aa--52efd90d778240bdaaa5dbe8cd58d0d3 bc110c05ad214a09b4435dd213a04f8f 17c529569248439ba0feee517a5d83aa--bc110c05ad214a09b4435dd213a04f8f 428bf8a7e2c847898c7feefb3db5df5f bc110c05ad214a09b4435dd213a04f8f--428bf8a7e2c847898c7feefb3db5df5f dbc2a035619c4e33be55fcb506442586 428bf8a7e2c847898c7feefb3db5df5f--dbc2a035619c4e33be55fcb506442586 1952cd98fd724b6faffc1fe8314978aa dbc2a035619c4e33be55fcb506442586--1952cd98fd724b6faffc1fe8314978aa ee0aa657df66403a9914bea51980da14 1952cd98fd724b6faffc1fe8314978aa--ee0aa657df66403a9914bea51980da14 06e59c0458374dcea0cb52b6dd105372 X ee0aa657df66403a9914bea51980da14--06e59c0458374dcea0cb52b6dd105372 06e59c0458374dcea0cb52b6dd105372--afa1c382dc8d4ab5bccfed9c6cb3231e ec9cf7867d1b47869db12915bf6873a5 RZ(-1.0*g0) 06e59c0458374dcea0cb52b6dd105372--ec9cf7867d1b47869db12915bf6873a5 1493eb5974294d2f86e93371b4770eac X ec9cf7867d1b47869db12915bf6873a5--1493eb5974294d2f86e93371b4770eac 1493eb5974294d2f86e93371b4770eac--a45a837d366b42c1b23ad8c29d3e41e4 1054b39d8759450fbdabd7582917f331 1493eb5974294d2f86e93371b4770eac--1054b39d8759450fbdabd7582917f331 72e6e0792a5f48c99c980e4a4f0c9b36 1054b39d8759450fbdabd7582917f331--72e6e0792a5f48c99c980e4a4f0c9b36 eaa6de1df28b4414baf8bb0ae6ae3cac RX(b07) 72e6e0792a5f48c99c980e4a4f0c9b36--eaa6de1df28b4414baf8bb0ae6ae3cac c1367cad5c5d4384acfda6acc9cf89e3 eaa6de1df28b4414baf8bb0ae6ae3cac--c1367cad5c5d4384acfda6acc9cf89e3 11dd339921d846838a012f06cfa1fa9d c1367cad5c5d4384acfda6acc9cf89e3--11dd339921d846838a012f06cfa1fa9d aa60db9480174a6b9f76e48592be2a49 11dd339921d846838a012f06cfa1fa9d--aa60db9480174a6b9f76e48592be2a49 3cfc459ca7cb4fb6aeeb99e2164c70bb aa60db9480174a6b9f76e48592be2a49--3cfc459ca7cb4fb6aeeb99e2164c70bb b4c68769171b499899634ab6662969a0 3cfc459ca7cb4fb6aeeb99e2164c70bb--b4c68769171b499899634ab6662969a0 5e4cbe8a4dc8499e9fdc9c6f4ce1ddc7 b4c68769171b499899634ab6662969a0--5e4cbe8a4dc8499e9fdc9c6f4ce1ddc7 b2d9df32f77b47e28418a63f22913666 X 5e4cbe8a4dc8499e9fdc9c6f4ce1ddc7--b2d9df32f77b47e28418a63f22913666 b2d9df32f77b47e28418a63f22913666--02f0b266db214cb0b7610544a74d01ce bc569ea9e4fa47119f1cb67dd1c47cd9 RZ(1.0*g1) b2d9df32f77b47e28418a63f22913666--bc569ea9e4fa47119f1cb67dd1c47cd9 08387bee40ce49f99ae5934dfad18942 X bc569ea9e4fa47119f1cb67dd1c47cd9--08387bee40ce49f99ae5934dfad18942 08387bee40ce49f99ae5934dfad18942--016eb013ea30470ab31bf5282988165d c15acd1717e0446d83bd82a6e9f09329 08387bee40ce49f99ae5934dfad18942--c15acd1717e0446d83bd82a6e9f09329 10313930b34c4a90b6bf88e8dddc6a62 c15acd1717e0446d83bd82a6e9f09329--10313930b34c4a90b6bf88e8dddc6a62 7418d8bb42514896ac48edccbda99e29 10313930b34c4a90b6bf88e8dddc6a62--7418d8bb42514896ac48edccbda99e29 7aa2ca9ff9e84104bea4c6017acbec4f 7418d8bb42514896ac48edccbda99e29--7aa2ca9ff9e84104bea4c6017acbec4f ad184ce6f5cd40ecb01c504d7c407040 7aa2ca9ff9e84104bea4c6017acbec4f--ad184ce6f5cd40ecb01c504d7c407040 32557c99710f46898dbce4831d2191f8 ad184ce6f5cd40ecb01c504d7c407040--32557c99710f46898dbce4831d2191f8 6db39d3b4dad4f1fa8f671d564ece0cf 32557c99710f46898dbce4831d2191f8--6db39d3b4dad4f1fa8f671d564ece0cf da3ac9a211ed4dc0a39c0592aae1fcaf 6db39d3b4dad4f1fa8f671d564ece0cf--da3ac9a211ed4dc0a39c0592aae1fcaf 0074536d3ee14f189bd3c8191bb2c445 da3ac9a211ed4dc0a39c0592aae1fcaf--0074536d3ee14f189bd3c8191bb2c445 ae23d30161ac4ebb90adb615cab20a2b 0074536d3ee14f189bd3c8191bb2c445--ae23d30161ac4ebb90adb615cab20a2b 2166f691c2604d9a944bdbbec41be3de ae23d30161ac4ebb90adb615cab20a2b--2166f691c2604d9a944bdbbec41be3de 1ce1ace9e7194c0ba2976ff6bbb20f57 2166f691c2604d9a944bdbbec41be3de--1ce1ace9e7194c0ba2976ff6bbb20f57 7bf4fa22ea4040efa705ec7773d49991 1ce1ace9e7194c0ba2976ff6bbb20f57--7bf4fa22ea4040efa705ec7773d49991 26bed7553d4f417b9fd4b477f52a5cc3 7bf4fa22ea4040efa705ec7773d49991--26bed7553d4f417b9fd4b477f52a5cc3 3d599418269f4c46a6351f97069c38cf 26bed7553d4f417b9fd4b477f52a5cc3--3d599418269f4c46a6351f97069c38cf 8b28063609164709a104ee9b39849e85 3d599418269f4c46a6351f97069c38cf--8b28063609164709a104ee9b39849e85 befb41d55a354579bbafd8c0dc863afd 8b28063609164709a104ee9b39849e85--befb41d55a354579bbafd8c0dc863afd caeb8bde39f241da9b6f49fb3bd84d5b befb41d55a354579bbafd8c0dc863afd--caeb8bde39f241da9b6f49fb3bd84d5b bab077fe889a4d84b1212bfffe3dd85f caeb8bde39f241da9b6f49fb3bd84d5b--bab077fe889a4d84b1212bfffe3dd85f 214f7304e8304b9b8bdd4bff2d4ecdf8 bab077fe889a4d84b1212bfffe3dd85f--214f7304e8304b9b8bdd4bff2d4ecdf8 359d58cfeba745dcb029e166591b1b4b 214f7304e8304b9b8bdd4bff2d4ecdf8--359d58cfeba745dcb029e166591b1b4b 34b63586634e4d0292689cb36aad30ad 359d58cfeba745dcb029e166591b1b4b--34b63586634e4d0292689cb36aad30ad 7cc4d2e6342047cd8edfaea5242b462d 34b63586634e4d0292689cb36aad30ad--7cc4d2e6342047cd8edfaea5242b462d a88ebd32c9fb4703972f76bc46c0ff68 7cc4d2e6342047cd8edfaea5242b462d--a88ebd32c9fb4703972f76bc46c0ff68 e67dd13d64db46bda7dcc5d9b40cecbd a88ebd32c9fb4703972f76bc46c0ff68--e67dd13d64db46bda7dcc5d9b40cecbd 5da0bdb1d4f04b128f6da5ce742f01f0 e67dd13d64db46bda7dcc5d9b40cecbd--5da0bdb1d4f04b128f6da5ce742f01f0 ca970e8c3fcc4b96ba6a2079df348210 5da0bdb1d4f04b128f6da5ce742f01f0--ca970e8c3fcc4b96ba6a2079df348210 354824a27bdb476f8deac4b382d1a1d6 ca970e8c3fcc4b96ba6a2079df348210--354824a27bdb476f8deac4b382d1a1d6 0afc7358444c46349a56310018e385ad 354824a27bdb476f8deac4b382d1a1d6--0afc7358444c46349a56310018e385ad a4bc74f17a7e4b01a8662c1adec589b3 0afc7358444c46349a56310018e385ad--a4bc74f17a7e4b01a8662c1adec589b3 d31015934fae4af09eeba9cab47802fb a4bc74f17a7e4b01a8662c1adec589b3--d31015934fae4af09eeba9cab47802fb 1dc8709aea224b48a40e2953143a1adf d31015934fae4af09eeba9cab47802fb--1dc8709aea224b48a40e2953143a1adf aa4c255b57064d689f769f9657aefe67 1dc8709aea224b48a40e2953143a1adf--aa4c255b57064d689f769f9657aefe67 98033fe9b5e84485a2ac513502b1bf13 aa4c255b57064d689f769f9657aefe67--98033fe9b5e84485a2ac513502b1bf13 64931f45c396417695e2fd40addb53cc 98033fe9b5e84485a2ac513502b1bf13--64931f45c396417695e2fd40addb53cc f9b1fc3b990d40d6a5f770d728d8a4fc 64931f45c396417695e2fd40addb53cc--f9b1fc3b990d40d6a5f770d728d8a4fc 459be49b4612400db1499ef5e1551fe3 f9b1fc3b990d40d6a5f770d728d8a4fc--459be49b4612400db1499ef5e1551fe3 56baf3d09e7344c4bd419cf4d34756a0 459be49b4612400db1499ef5e1551fe3--56baf3d09e7344c4bd419cf4d34756a0 b00ade1b06fb41e589557d2659fa29d5 56baf3d09e7344c4bd419cf4d34756a0--b00ade1b06fb41e589557d2659fa29d5 d6092afc8aaf48f69c37988f437c8a9f b00ade1b06fb41e589557d2659fa29d5--d6092afc8aaf48f69c37988f437c8a9f 3be4ab45bef7433a9530424b1e9c5b30 d6092afc8aaf48f69c37988f437c8a9f--3be4ab45bef7433a9530424b1e9c5b30 8282849a046641ddb2c077289be74b34 3be4ab45bef7433a9530424b1e9c5b30--8282849a046641ddb2c077289be74b34 c5ebcfc7eb59496e968f57c846e04fb1 8282849a046641ddb2c077289be74b34--c5ebcfc7eb59496e968f57c846e04fb1 eb57338c35e94153ad461d33a357d53f c5ebcfc7eb59496e968f57c846e04fb1--eb57338c35e94153ad461d33a357d53f db14e74b6ad047b4b6ff6c144fdcd98e eb57338c35e94153ad461d33a357d53f--db14e74b6ad047b4b6ff6c144fdcd98e 2c87ac66d9044ae799d1489171e01468 db14e74b6ad047b4b6ff6c144fdcd98e--2c87ac66d9044ae799d1489171e01468 402181fd3b1a46e58bc51a604cd6c05f 2c87ac66d9044ae799d1489171e01468--402181fd3b1a46e58bc51a604cd6c05f 5585f1b065734558b2a2f62b8f363df1 402181fd3b1a46e58bc51a604cd6c05f--5585f1b065734558b2a2f62b8f363df1 405c3c40d25743d89d8512b60211f367 5585f1b065734558b2a2f62b8f363df1--405c3c40d25743d89d8512b60211f367 87bae4607b1d45008cf9146ebfa05bfc 405c3c40d25743d89d8512b60211f367--87bae4607b1d45008cf9146ebfa05bfc b1c78ee176d1414ba55a16a5911bb8a7 87bae4607b1d45008cf9146ebfa05bfc--b1c78ee176d1414ba55a16a5911bb8a7 62524d37a43549f0b29e2c875c2df170 b1c78ee176d1414ba55a16a5911bb8a7--62524d37a43549f0b29e2c875c2df170 d29419c21fb74dd496e574b30e801a49 62524d37a43549f0b29e2c875c2df170--d29419c21fb74dd496e574b30e801a49 790b61c725ad4c4e95f43eac262c42dd d29419c21fb74dd496e574b30e801a49--790b61c725ad4c4e95f43eac262c42dd 309f54c3120340999869c8ea3ff51ee8 790b61c725ad4c4e95f43eac262c42dd--309f54c3120340999869c8ea3ff51ee8 4ea18e3cbba247caa556471fecfa65c4 309f54c3120340999869c8ea3ff51ee8--4ea18e3cbba247caa556471fecfa65c4 4bbe57e352d24660aef4c625165f9af6 4ea18e3cbba247caa556471fecfa65c4--4bbe57e352d24660aef4c625165f9af6 9f845004e7b8414eaa45428f6ef9dc01 4bbe57e352d24660aef4c625165f9af6--9f845004e7b8414eaa45428f6ef9dc01 290b11a4c8f140d3a48edc500805031b 9f845004e7b8414eaa45428f6ef9dc01--290b11a4c8f140d3a48edc500805031b 9d07d19adec744c6ba0e98c05d010179 290b11a4c8f140d3a48edc500805031b--9d07d19adec744c6ba0e98c05d010179 d947db7e0de444b9b8e9c4284ea0ec1e 9d07d19adec744c6ba0e98c05d010179--d947db7e0de444b9b8e9c4284ea0ec1e 0165f103f8f0463980b99eed277d9575 d947db7e0de444b9b8e9c4284ea0ec1e--0165f103f8f0463980b99eed277d9575 95b737e21b9043a5900560874600abd4 0165f103f8f0463980b99eed277d9575--95b737e21b9043a5900560874600abd4 65fff98cd62642418b074090c3dbb069 95b737e21b9043a5900560874600abd4--65fff98cd62642418b074090c3dbb069 6f49daa2cba94333b9236a3de0279e9d 65fff98cd62642418b074090c3dbb069--6f49daa2cba94333b9236a3de0279e9d c8ae498bdf58443db1ed6258e1c4aa0c 6f49daa2cba94333b9236a3de0279e9d--c8ae498bdf58443db1ed6258e1c4aa0c 5e77d56d14834634b83caa73966f9444 c8ae498bdf58443db1ed6258e1c4aa0c--5e77d56d14834634b83caa73966f9444 39f35f6a09a54527a5dcfe7e7e2e7d25 5e77d56d14834634b83caa73966f9444--39f35f6a09a54527a5dcfe7e7e2e7d25 6ef43234b12b495f96ff47383fafc287 39f35f6a09a54527a5dcfe7e7e2e7d25--6ef43234b12b495f96ff47383fafc287 bb3a501b6e6642e488198c85dd17123b 6ef43234b12b495f96ff47383fafc287--bb3a501b6e6642e488198c85dd17123b f03f31d509274074bf15335f9e8eac75 bb3a501b6e6642e488198c85dd17123b--f03f31d509274074bf15335f9e8eac75 5bbf634b66a643c288aff054e55641f3 f03f31d509274074bf15335f9e8eac75--5bbf634b66a643c288aff054e55641f3 9905fe23ef6e4ab2b9b336a588929d97 5bbf634b66a643c288aff054e55641f3--9905fe23ef6e4ab2b9b336a588929d97 b647c6aabd76478b8b3680acd62f158d 9905fe23ef6e4ab2b9b336a588929d97--b647c6aabd76478b8b3680acd62f158d b113319934bb40659aed4e08b606b97b b647c6aabd76478b8b3680acd62f158d--b113319934bb40659aed4e08b606b97b 78583717fded439683c2409468d4c2a9 b113319934bb40659aed4e08b606b97b--78583717fded439683c2409468d4c2a9 10f7bec29e4b4b139ebd1ca3d84db9ff 78583717fded439683c2409468d4c2a9--10f7bec29e4b4b139ebd1ca3d84db9ff 0c385a431f39456290d774dec2c2594a 10f7bec29e4b4b139ebd1ca3d84db9ff--0c385a431f39456290d774dec2c2594a fdf431a0448e49bf8dd59b36af8d071b 0c385a431f39456290d774dec2c2594a--fdf431a0448e49bf8dd59b36af8d071b 1ac131db4d664efcbf26dc53e78597b1 fdf431a0448e49bf8dd59b36af8d071b--1ac131db4d664efcbf26dc53e78597b1 9f099c96d3c34d7ca7c8f70cc17819f5 1ac131db4d664efcbf26dc53e78597b1--9f099c96d3c34d7ca7c8f70cc17819f5 2f735bb2b09d463fa42a597966af05ea 9f099c96d3c34d7ca7c8f70cc17819f5--2f735bb2b09d463fa42a597966af05ea 3402c54309d74b228b9d1b8b129f5158 2f735bb2b09d463fa42a597966af05ea--3402c54309d74b228b9d1b8b129f5158 475a757f27ca4b5f9b18c959c9d5a973 3402c54309d74b228b9d1b8b129f5158--475a757f27ca4b5f9b18c959c9d5a973 661c0fcb1d6a43bfaf94e6a6be9aef62 475a757f27ca4b5f9b18c959c9d5a973--661c0fcb1d6a43bfaf94e6a6be9aef62 ab073742c8004994a597a601e3fcb131 661c0fcb1d6a43bfaf94e6a6be9aef62--ab073742c8004994a597a601e3fcb131 6f3fa171355e42adb38373cabeb7210e X ab073742c8004994a597a601e3fcb131--6f3fa171355e42adb38373cabeb7210e 6f3fa171355e42adb38373cabeb7210e--c6d38dbf41574cdda10257fcf3cc6a3a 85884b3312ab47db8bece6eca0565995 RZ(-1.0*g1) 6f3fa171355e42adb38373cabeb7210e--85884b3312ab47db8bece6eca0565995 9e729659a38545cfa0ff00c3efdaad18 X 85884b3312ab47db8bece6eca0565995--9e729659a38545cfa0ff00c3efdaad18 9e729659a38545cfa0ff00c3efdaad18--a4e72ac3248f42d1b5156906230e5b83 63a5f556259b4311b6fd8144ce479f23 9e729659a38545cfa0ff00c3efdaad18--63a5f556259b4311b6fd8144ce479f23 290dade082bb4d9d9a300487ac199d6f 63a5f556259b4311b6fd8144ce479f23--290dade082bb4d9d9a300487ac199d6f 41ca705616384a8d8c829f0b7a2faec7 290dade082bb4d9d9a300487ac199d6f--41ca705616384a8d8c829f0b7a2faec7 828ebf7bb00044f080b3a97867627219 41ca705616384a8d8c829f0b7a2faec7--828ebf7bb00044f080b3a97867627219 74b377d7f1be4e80a61cee1231cb7bb4 828ebf7bb00044f080b3a97867627219--74b377d7f1be4e80a61cee1231cb7bb4 10b5b714263947b5a58c03db95dc1ca7 74b377d7f1be4e80a61cee1231cb7bb4--10b5b714263947b5a58c03db95dc1ca7 3a44624ba20443bbb9da1012a8614b88 10b5b714263947b5a58c03db95dc1ca7--3a44624ba20443bbb9da1012a8614b88 ea9e836ad66943c1b8072611c10c4f19 X 3a44624ba20443bbb9da1012a8614b88--ea9e836ad66943c1b8072611c10c4f19 ea9e836ad66943c1b8072611c10c4f19--f152bf4e0e9e4690bcee126836a8a42a f584f2892b284ea8abcd0de238cd0c4f RZ(-1.0*g1) ea9e836ad66943c1b8072611c10c4f19--f584f2892b284ea8abcd0de238cd0c4f 98de622544ec41ceb956ada591d9b042 X f584f2892b284ea8abcd0de238cd0c4f--98de622544ec41ceb956ada591d9b042 98de622544ec41ceb956ada591d9b042--e06d0553324c45f5b49dd832e1790e9e b276d7a27827470b9570bf028a6425bb 98de622544ec41ceb956ada591d9b042--b276d7a27827470b9570bf028a6425bb c6b983127488436cb3d4ac82812cdb5b b276d7a27827470b9570bf028a6425bb--c6b983127488436cb3d4ac82812cdb5b cc0a1a4ad171454c9d558f4f8f78a382 c6b983127488436cb3d4ac82812cdb5b--cc0a1a4ad171454c9d558f4f8f78a382 6d722b5211e847e4aa041576e3cc5696 cc0a1a4ad171454c9d558f4f8f78a382--6d722b5211e847e4aa041576e3cc5696 120da924417748469f4ed9860a5db85b 6d722b5211e847e4aa041576e3cc5696--120da924417748469f4ed9860a5db85b 129ac8a9ecd645cea236f3daeec5063b X 120da924417748469f4ed9860a5db85b--129ac8a9ecd645cea236f3daeec5063b 129ac8a9ecd645cea236f3daeec5063b--96f279432b9d4ee2843629869062f844 c106bd1134594786a61511997f77ea85 RZ(-1.0*g1) 129ac8a9ecd645cea236f3daeec5063b--c106bd1134594786a61511997f77ea85 08241f7294c34ef0adb4924f2d7de5c5 X c106bd1134594786a61511997f77ea85--08241f7294c34ef0adb4924f2d7de5c5 08241f7294c34ef0adb4924f2d7de5c5--0b677f22d0f04012b2d44575d403fe55 dad06e04a95542d3a81b627744efa2bf 08241f7294c34ef0adb4924f2d7de5c5--dad06e04a95542d3a81b627744efa2bf 564c5fc5a5354638bfccad01b3b87595 dad06e04a95542d3a81b627744efa2bf--564c5fc5a5354638bfccad01b3b87595 85f575f655d641a1acd0b8eb90b366a3 RX(b17) 564c5fc5a5354638bfccad01b3b87595--85f575f655d641a1acd0b8eb90b366a3 85f575f655d641a1acd0b8eb90b366a3--b1d0beec1ff44e7096da0a628cefc418"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -4.2057664150367176\nMaxCut cost at iteration 10: 10.837175888989432\nMaxCut cost at iteration 20: 10.965307954323897\nMaxCut cost at iteration 30: 10.997948744217435\nMaxCut cost at iteration 40: 10.999992814284397\nMaxCut cost at iteration 50: 10.999999975199438\nMaxCut cost at iteration 60: 10.99999999991439\nMaxCut cost at iteration 70: 10.999999999999705\nMaxCut cost at iteration 80: 11.0\nMaxCut cost at iteration 90: 10.999999999999996\nMaxCut cost at iteration 100: 10.999999999999993\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 01111000  2023-12-12T14:24:48.816490 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2023-12-12T14:24:53.299900 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_df2f4a99531247c18a65a20b761f92e0 Constant Chebyshev FM cluster_b8aeb4a0052b4a9b82326dde3d9c8dc8 Constant Fourier FM 3daca02a57124b188c2cf009db4bc007 0 782b7e8a3fd7484188f8cfec1daa2b7a RX(phi) 3daca02a57124b188c2cf009db4bc007--782b7e8a3fd7484188f8cfec1daa2b7a 1739c7b9f6dd4a8d806295d79df27bab 1 46ea2d9780f549ff9c599922892baede RX(acos(phi)) 782b7e8a3fd7484188f8cfec1daa2b7a--46ea2d9780f549ff9c599922892baede 693bd15ea2114ab8b082a9c3c270c5e7 46ea2d9780f549ff9c599922892baede--693bd15ea2114ab8b082a9c3c270c5e7 9d61c9b9c9624d18bab4513e7e40a51a de71eaa2773d448fa21d82e184d1c2ca RX(phi) 1739c7b9f6dd4a8d806295d79df27bab--de71eaa2773d448fa21d82e184d1c2ca 5fac9104c20047719452f9ab601bdae9 2 9b0e21e3f9df4a9cbe6c4acb83ff0870 RX(acos(phi)) de71eaa2773d448fa21d82e184d1c2ca--9b0e21e3f9df4a9cbe6c4acb83ff0870 9b0e21e3f9df4a9cbe6c4acb83ff0870--9d61c9b9c9624d18bab4513e7e40a51a f5f4449a1a4442b183b7d99c100d5353 64047b1f3ff84f1ca826faf9794e5f32 RX(phi) 5fac9104c20047719452f9ab601bdae9--64047b1f3ff84f1ca826faf9794e5f32 d7b5f02da5004795b46ea3830e008077 RX(acos(phi)) 64047b1f3ff84f1ca826faf9794e5f32--d7b5f02da5004795b46ea3830e008077 d7b5f02da5004795b46ea3830e008077--f5f4449a1a4442b183b7d99c100d5353 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom sub-class of Function\nclass custom_func(Function):\n    @classmethod\n    def eval(cls, x):\n        return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_func)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_81646814eb3e489fbfbc6f49e69e0ae1 Constant custom_func FM cluster_08fa473087814e188d2bcdd19430575e Constant asin FM 2d2bedf730c544db977094818eb8f3f1 0 257e7909033748a78c401bbb4ba29039 RX(asin(phi)) 2d2bedf730c544db977094818eb8f3f1--257e7909033748a78c401bbb4ba29039 38e21bff6aa04397bef9c6d587c2873b 1 3eaafa9bbda846aeb8901ae42f542f39 RX(phi**2 + asin(phi)) 257e7909033748a78c401bbb4ba29039--3eaafa9bbda846aeb8901ae42f542f39 4486cd5275f149e3825c231b1ea9550f 3eaafa9bbda846aeb8901ae42f542f39--4486cd5275f149e3825c231b1ea9550f c1f675c574c14be9b3fabe6316c7ed1b cf16edbefaec406db3b59bb2287b7429 RX(asin(phi)) 38e21bff6aa04397bef9c6d587c2873b--cf16edbefaec406db3b59bb2287b7429 28fd9d692f204e12b1b3ef04cada80bf 2 cfd54b54f6f84cd68c2ea44f41019a73 RX(phi**2 + asin(phi)) cf16edbefaec406db3b59bb2287b7429--cfd54b54f6f84cd68c2ea44f41019a73 cfd54b54f6f84cd68c2ea44f41019a73--c1f675c574c14be9b3fabe6316c7ed1b fa0123ef32714b7f846d4cbe295595ce 5bdc9756293d4e5fad912990503b75f4 RX(asin(phi)) 28fd9d692f204e12b1b3ef04cada80bf--5bdc9756293d4e5fad912990503b75f4 302f3872ddc743618a0855acd9246d5b RX(phi**2 + asin(phi)) 5bdc9756293d4e5fad912990503b75f4--302f3872ddc743618a0855acd9246d5b 302f3872ddc743618a0855acd9246d5b--fa0123ef32714b7f846d4cbe295595ce <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_5292d16e62134521958e9ca375f8e76c Exponential Fourier FM cluster_29570887be714929a5b4a7f4291c59a0 Constant Fourier FM cluster_5bf9c55496f64adc9e3c75bbb938ddb3 Tower Fourier FM 45e4bd16699e4d69bfc67d12c3ef46cf 0 0cbabea9f3504c25afe24035c4056a3e RX(phi) 45e4bd16699e4d69bfc67d12c3ef46cf--0cbabea9f3504c25afe24035c4056a3e 39f1399000cf477c9c121a1029e8c9ed 1 72abeea1f3c643d3bf6265bd5c96fb6f RX(1.0*phi) 0cbabea9f3504c25afe24035c4056a3e--72abeea1f3c643d3bf6265bd5c96fb6f 228d38dda1f44f439b98ad2d0ae52f6f RX(1.0*phi) 72abeea1f3c643d3bf6265bd5c96fb6f--228d38dda1f44f439b98ad2d0ae52f6f eab0e787df85492b99ad2e2e77f0761a 228d38dda1f44f439b98ad2d0ae52f6f--eab0e787df85492b99ad2e2e77f0761a dec6eeb7fd3943e7ac8bce4d77f50906 7e0edbcd05af46868c48c605ac58c400 RX(phi) 39f1399000cf477c9c121a1029e8c9ed--7e0edbcd05af46868c48c605ac58c400 e3e4c074529e44baa83f2d2bebe1619c 2 e6e5fe390ad44f82826be1976ded8ba2 RX(2.0*phi) 7e0edbcd05af46868c48c605ac58c400--e6e5fe390ad44f82826be1976ded8ba2 749e4b2b71884f8d8f43493d2213788c RX(2.0*phi) e6e5fe390ad44f82826be1976ded8ba2--749e4b2b71884f8d8f43493d2213788c 749e4b2b71884f8d8f43493d2213788c--dec6eeb7fd3943e7ac8bce4d77f50906 526a0c35f7654238bec71456b4d0f3ff ebd70667ff5248cb888dae58d0757bf8 RX(phi) e3e4c074529e44baa83f2d2bebe1619c--ebd70667ff5248cb888dae58d0757bf8 102cb219b0aa4bb8b14400471d31ea1a 3 e210d481339d47dfa448f6ebfca55f06 RX(3.0*phi) ebd70667ff5248cb888dae58d0757bf8--e210d481339d47dfa448f6ebfca55f06 282fc098c7df4daebdf98374e4f6ff8e RX(4.0*phi) e210d481339d47dfa448f6ebfca55f06--282fc098c7df4daebdf98374e4f6ff8e 282fc098c7df4daebdf98374e4f6ff8e--526a0c35f7654238bec71456b4d0f3ff a57ec3d57c2e4f4fa781e9f57199a29b dd9178db303b4e429b80004777af876f RX(phi) 102cb219b0aa4bb8b14400471d31ea1a--dd9178db303b4e429b80004777af876f a65be922b9d44d32b54e9ad2ad1d0026 4 121a408ab36f4b6fab04965576ff606b RX(4.0*phi) dd9178db303b4e429b80004777af876f--121a408ab36f4b6fab04965576ff606b 7080b096ead6498fa64295fa65929174 RX(8.0*phi) 121a408ab36f4b6fab04965576ff606b--7080b096ead6498fa64295fa65929174 7080b096ead6498fa64295fa65929174--a57ec3d57c2e4f4fa781e9f57199a29b eaddc75175bf4ec0882a4d25641cf96d 1a690f1bbeb94ba1bc75d77db7f54ef6 RX(phi) a65be922b9d44d32b54e9ad2ad1d0026--1a690f1bbeb94ba1bc75d77db7f54ef6 4adf7b84a94545b1b0409dc0d57dff7a RX(5.0*phi) 1a690f1bbeb94ba1bc75d77db7f54ef6--4adf7b84a94545b1b0409dc0d57dff7a 080b1147c8014291b8f55ccaba244ce2 RX(16.0*phi) 4adf7b84a94545b1b0409dc0d57dff7a--080b1147c8014291b8f55ccaba244ce2 080b1147c8014291b8f55ccaba244ce2--eaddc75175bf4ec0882a4d25641cf96d <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 22467f27b61745e7b9f62279793e3135 0 c3d96e14ac8d44f897025ae9fcc94b4b RX(1.0*acos(phi)) 22467f27b61745e7b9f62279793e3135--c3d96e14ac8d44f897025ae9fcc94b4b 81f6d5b0f2c94f978604589d967763f5 1 d5308b74ac5a4e12870ec2a9ddbb4ffc c3d96e14ac8d44f897025ae9fcc94b4b--d5308b74ac5a4e12870ec2a9ddbb4ffc 5270f76ddc0344f8ace3b5ded1c2dee9 fb9ec636784e413e9d7389b208e1ac1e RX(1.414*acos(phi)) 81f6d5b0f2c94f978604589d967763f5--fb9ec636784e413e9d7389b208e1ac1e bb2af327d0874d86842268b6d53fd069 2 fb9ec636784e413e9d7389b208e1ac1e--5270f76ddc0344f8ace3b5ded1c2dee9 6fada0eebed94915932f60c51694de29 08093477d0ea45afb69ba6378b7672aa RX(1.732*acos(phi)) bb2af327d0874d86842268b6d53fd069--08093477d0ea45afb69ba6378b7672aa f47d50ae86474a02a697ea7c452f38ba 3 08093477d0ea45afb69ba6378b7672aa--6fada0eebed94915932f60c51694de29 eeb9f5452ffd4818907584217fa0f446 db21d73855a44a2cb0d73162a6b26372 RX(2.0*acos(phi)) f47d50ae86474a02a697ea7c452f38ba--db21d73855a44a2cb0d73162a6b26372 66311988134b46759e7a0fb240926b07 4 db21d73855a44a2cb0d73162a6b26372--eeb9f5452ffd4818907584217fa0f446 b1f88a5c53734a87a08a797c0ddf5c0c 9c63733bd361452dbfef2f220577f5e3 RX(2.236*acos(phi)) 66311988134b46759e7a0fb240926b07--9c63733bd361452dbfef2f220577f5e3 9c63733bd361452dbfef2f220577f5e3--b1f88a5c53734a87a08a797c0ddf5c0c <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0 # Extra multiplier, which can also be a Parameter\n)\n</code></pre> %3 e2a18187704042a4956e86fd2833c482 0 3d697a08c4794421b71ce7e0f92baed0 RY(80.0*acos(0.667*x + 1.667)) e2a18187704042a4956e86fd2833c482--3d697a08c4794421b71ce7e0f92baed0 394246b1aaee4d90b36bb5f58215322d 1 d37660320c654fe1854f2e36cda06bf3 3d697a08c4794421b71ce7e0f92baed0--d37660320c654fe1854f2e36cda06bf3 5d188d8b088140698f009a8e25bad55d d208559b4eb84ef585d9c004df340837 RY(40.0*acos(0.667*x + 1.667)) 394246b1aaee4d90b36bb5f58215322d--d208559b4eb84ef585d9c004df340837 94b174eedb9540a4a3b520f7d7baac08 2 d208559b4eb84ef585d9c004df340837--5d188d8b088140698f009a8e25bad55d 57e366c22be94b0c94957fb1aa000e2b 89d9c3bb7a1d4d52ad559fe65890e6c2 RY(20.0*acos(0.667*x + 1.667)) 94b174eedb9540a4a3b520f7d7baac08--89d9c3bb7a1d4d52ad559fe65890e6c2 07bf0a9114f6414db6a18b314a0cb0f0 3 89d9c3bb7a1d4d52ad559fe65890e6c2--57e366c22be94b0c94957fb1aa000e2b 10f82573b70f4026810fc79e5f443bbf f0c283745b8442389e33e95346ec689b RY(10.0*acos(0.667*x + 1.667)) 07bf0a9114f6414db6a18b314a0cb0f0--f0c283745b8442389e33e95346ec689b 8dce57291ca54e2a8ad5f8863cdc75c3 4 f0c283745b8442389e33e95346ec689b--10f82573b70f4026810fc79e5f443bbf 91f4a719ee464ca9af53d3263c48f635 dc69afcd586a4f1387b957a477ae038c RY(5.0*acos(0.667*x + 1.667)) 8dce57291ca54e2a8ad5f8863cdc75c3--dc69afcd586a4f1387b957a477ae038c dc69afcd586a4f1387b957a477ae038c--91f4a719ee464ca9af53d3263c48f635"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 925467e314a845bb832e71c9fe84b26a 0 e1547389ff3a4a22b450f5b6d67c37e6 RX(theta\u2080) 925467e314a845bb832e71c9fe84b26a--e1547389ff3a4a22b450f5b6d67c37e6 02deb979941946f581cfe84f507c1000 1 44737c51eeb3454c9130ee82fd72f7da RY(theta\u2083) e1547389ff3a4a22b450f5b6d67c37e6--44737c51eeb3454c9130ee82fd72f7da b8dc955c6fb746e1916651e83908c4bc RX(theta\u2086) 44737c51eeb3454c9130ee82fd72f7da--b8dc955c6fb746e1916651e83908c4bc c87e762852c8447989bf36a587d784dd b8dc955c6fb746e1916651e83908c4bc--c87e762852c8447989bf36a587d784dd 450b34a569ed48eb998e52df4071fc8d c87e762852c8447989bf36a587d784dd--450b34a569ed48eb998e52df4071fc8d 4c9d3e1ab49e4c018f0ba6928a8ad15a RX(theta\u2089) 450b34a569ed48eb998e52df4071fc8d--4c9d3e1ab49e4c018f0ba6928a8ad15a c3bb7d6928c549d28820fb7b49a3fdb5 RY(theta\u2081\u2082) 4c9d3e1ab49e4c018f0ba6928a8ad15a--c3bb7d6928c549d28820fb7b49a3fdb5 13ea508cccb54f4d98af4700df703c0b RX(theta\u2081\u2085) c3bb7d6928c549d28820fb7b49a3fdb5--13ea508cccb54f4d98af4700df703c0b 24f58e5dcc854981b490e60be2436a2a 13ea508cccb54f4d98af4700df703c0b--24f58e5dcc854981b490e60be2436a2a 1ea8aea51a714e47ba5270a131c83a40 24f58e5dcc854981b490e60be2436a2a--1ea8aea51a714e47ba5270a131c83a40 463ab688861e43629f6915595c977a94 1ea8aea51a714e47ba5270a131c83a40--463ab688861e43629f6915595c977a94 8511c3594c574e4e9c64f9c5fc11ee7c fe35272a694a46d0ac21c5eb088c11f6 RX(theta\u2081) 02deb979941946f581cfe84f507c1000--fe35272a694a46d0ac21c5eb088c11f6 232fd153a3f64144b348175d4272b2fa 2 46813465d74545dfb1646bf499c74855 RY(theta\u2084) fe35272a694a46d0ac21c5eb088c11f6--46813465d74545dfb1646bf499c74855 b357b48b84dd420b8a494ef58b2d9f87 RX(theta\u2087) 46813465d74545dfb1646bf499c74855--b357b48b84dd420b8a494ef58b2d9f87 85036c2ecfe349a3a48d0f3aff0cbfb4 X b357b48b84dd420b8a494ef58b2d9f87--85036c2ecfe349a3a48d0f3aff0cbfb4 85036c2ecfe349a3a48d0f3aff0cbfb4--c87e762852c8447989bf36a587d784dd d88b2a7d173041b69635888cad82caa4 85036c2ecfe349a3a48d0f3aff0cbfb4--d88b2a7d173041b69635888cad82caa4 db1a4d8f2f7a48f68e7b13e73a0ef543 RX(theta\u2081\u2080) d88b2a7d173041b69635888cad82caa4--db1a4d8f2f7a48f68e7b13e73a0ef543 9b0f1535456b499b8997e8039cb71958 RY(theta\u2081\u2083) db1a4d8f2f7a48f68e7b13e73a0ef543--9b0f1535456b499b8997e8039cb71958 b9c1aaa63a9640d08b7e6a821a32c919 RX(theta\u2081\u2086) 9b0f1535456b499b8997e8039cb71958--b9c1aaa63a9640d08b7e6a821a32c919 73e4690dd5d74408a859da51a08eddbf X b9c1aaa63a9640d08b7e6a821a32c919--73e4690dd5d74408a859da51a08eddbf 73e4690dd5d74408a859da51a08eddbf--24f58e5dcc854981b490e60be2436a2a 34c766da0fa64576b39005a4d30239bc 73e4690dd5d74408a859da51a08eddbf--34c766da0fa64576b39005a4d30239bc 34c766da0fa64576b39005a4d30239bc--8511c3594c574e4e9c64f9c5fc11ee7c 0c68b854919843379df9fd2289b334db 3b9ab9e3ed774301bbeeec69bdedf00b RX(theta\u2082) 232fd153a3f64144b348175d4272b2fa--3b9ab9e3ed774301bbeeec69bdedf00b f6ff5e0812264ecebc3e923be4c238b3 RY(theta\u2085) 3b9ab9e3ed774301bbeeec69bdedf00b--f6ff5e0812264ecebc3e923be4c238b3 4f7a0401b86446fe89eb8437778cc746 RX(theta\u2088) f6ff5e0812264ecebc3e923be4c238b3--4f7a0401b86446fe89eb8437778cc746 a5f06483bd3e45bab73d7186c2559b04 4f7a0401b86446fe89eb8437778cc746--a5f06483bd3e45bab73d7186c2559b04 1791f85730154de484d49527aa280f6f X a5f06483bd3e45bab73d7186c2559b04--1791f85730154de484d49527aa280f6f 1791f85730154de484d49527aa280f6f--d88b2a7d173041b69635888cad82caa4 44a89b17cd9c4897b1d347497c9d55b5 RX(theta\u2081\u2081) 1791f85730154de484d49527aa280f6f--44a89b17cd9c4897b1d347497c9d55b5 9f783dc3e8e041fda48d98ee871fb80b RY(theta\u2081\u2084) 44a89b17cd9c4897b1d347497c9d55b5--9f783dc3e8e041fda48d98ee871fb80b 50451603ded94748895ebf95445baf02 RX(theta\u2081\u2087) 9f783dc3e8e041fda48d98ee871fb80b--50451603ded94748895ebf95445baf02 a43f4aa69a654974a4f79534b6387e89 50451603ded94748895ebf95445baf02--a43f4aa69a654974a4f79534b6387e89 b3553d0436bb4bed86dd03e99ce16740 X a43f4aa69a654974a4f79534b6387e89--b3553d0436bb4bed86dd03e99ce16740 b3553d0436bb4bed86dd03e99ce16740--34c766da0fa64576b39005a4d30239bc b3553d0436bb4bed86dd03e99ce16740--0c68b854919843379df9fd2289b334db <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 a5fe966a19c34ee298f724f9651a6936 0 f8128b98e93b462cbe711e797216ecac RX(phi\u2080) a5fe966a19c34ee298f724f9651a6936--f8128b98e93b462cbe711e797216ecac d301887e8fa84b19afc49800d48f3f15 1 afb792f840c049c096f4069c8806b730 RY(phi\u2083) f8128b98e93b462cbe711e797216ecac--afb792f840c049c096f4069c8806b730 91471e29390b49ebb9d6659433b6971c RX(phi\u2086) afb792f840c049c096f4069c8806b730--91471e29390b49ebb9d6659433b6971c 0ac1748444644d91a2abc0ef9ccfe9ba 91471e29390b49ebb9d6659433b6971c--0ac1748444644d91a2abc0ef9ccfe9ba d7554d8d638244659117da121b12b1fc 0ac1748444644d91a2abc0ef9ccfe9ba--d7554d8d638244659117da121b12b1fc 7974b65d0ae0489290215a643063d452 RX(phi\u2089) d7554d8d638244659117da121b12b1fc--7974b65d0ae0489290215a643063d452 a2ad07b7c9de4d0e899c233833fabb75 RY(phi\u2081\u2082) 7974b65d0ae0489290215a643063d452--a2ad07b7c9de4d0e899c233833fabb75 e89b8adb22ba4ab7b9f7883422bad91f RX(phi\u2081\u2085) a2ad07b7c9de4d0e899c233833fabb75--e89b8adb22ba4ab7b9f7883422bad91f 0cf94099931245e488f20c1a6ce4ce58 e89b8adb22ba4ab7b9f7883422bad91f--0cf94099931245e488f20c1a6ce4ce58 07659cab19b144f38100ffc9d1103403 0cf94099931245e488f20c1a6ce4ce58--07659cab19b144f38100ffc9d1103403 64c81950084c4652b553d8dcdc042be3 07659cab19b144f38100ffc9d1103403--64c81950084c4652b553d8dcdc042be3 1290c25e972b457f87941219c172f770 28e7163695a54542a22e01bca869a1ea RX(phi\u2081) d301887e8fa84b19afc49800d48f3f15--28e7163695a54542a22e01bca869a1ea af49f652167d451d8c13cd33a663454c 2 5815bc52e6fd411fbcc4da9ff76f253b RY(phi\u2084) 28e7163695a54542a22e01bca869a1ea--5815bc52e6fd411fbcc4da9ff76f253b 1a2ca3ce1c2946f88b78bf3d2468155e RX(phi\u2087) 5815bc52e6fd411fbcc4da9ff76f253b--1a2ca3ce1c2946f88b78bf3d2468155e ec093298a5254f2cb3876b442e856bb1 PHASE(phi_ent\u2080) 1a2ca3ce1c2946f88b78bf3d2468155e--ec093298a5254f2cb3876b442e856bb1 ec093298a5254f2cb3876b442e856bb1--0ac1748444644d91a2abc0ef9ccfe9ba 74ee800d90ac4d7cb9e565c92f7a16c1 ec093298a5254f2cb3876b442e856bb1--74ee800d90ac4d7cb9e565c92f7a16c1 595e8b5eb21744bfa80287fba3944b1e RX(phi\u2081\u2080) 74ee800d90ac4d7cb9e565c92f7a16c1--595e8b5eb21744bfa80287fba3944b1e 80577b34b7b64c159eaa8cf8d10a9483 RY(phi\u2081\u2083) 595e8b5eb21744bfa80287fba3944b1e--80577b34b7b64c159eaa8cf8d10a9483 4d0460d00f2f48eeb559be3f2042fd3b RX(phi\u2081\u2086) 80577b34b7b64c159eaa8cf8d10a9483--4d0460d00f2f48eeb559be3f2042fd3b 98f57b8f55004bf4aedb3044da0f3cf1 PHASE(phi_ent\u2082) 4d0460d00f2f48eeb559be3f2042fd3b--98f57b8f55004bf4aedb3044da0f3cf1 98f57b8f55004bf4aedb3044da0f3cf1--0cf94099931245e488f20c1a6ce4ce58 9ba918aa57214390aa67cbac8f8bd4f7 98f57b8f55004bf4aedb3044da0f3cf1--9ba918aa57214390aa67cbac8f8bd4f7 9ba918aa57214390aa67cbac8f8bd4f7--1290c25e972b457f87941219c172f770 d71341abe42d43f2be1d5464032a3bf6 7a29fc58866a41738ea73a23ff4efac4 RX(phi\u2082) af49f652167d451d8c13cd33a663454c--7a29fc58866a41738ea73a23ff4efac4 520ded886bab4822885c68c472c573b5 RY(phi\u2085) 7a29fc58866a41738ea73a23ff4efac4--520ded886bab4822885c68c472c573b5 c2736354357244ac911312c1df3d35bb RX(phi\u2088) 520ded886bab4822885c68c472c573b5--c2736354357244ac911312c1df3d35bb 7cebed1129034a6cbde653313305361f c2736354357244ac911312c1df3d35bb--7cebed1129034a6cbde653313305361f 91275ffe5aee45e1bd64eb08e92eae79 PHASE(phi_ent\u2081) 7cebed1129034a6cbde653313305361f--91275ffe5aee45e1bd64eb08e92eae79 91275ffe5aee45e1bd64eb08e92eae79--74ee800d90ac4d7cb9e565c92f7a16c1 f79af113b9bd496c8217f8488ec19825 RX(phi\u2081\u2081) 91275ffe5aee45e1bd64eb08e92eae79--f79af113b9bd496c8217f8488ec19825 6d4fa095101d41da84e99443f9822864 RY(phi\u2081\u2084) f79af113b9bd496c8217f8488ec19825--6d4fa095101d41da84e99443f9822864 cf6884d65dca416ab170654026b932b5 RX(phi\u2081\u2087) 6d4fa095101d41da84e99443f9822864--cf6884d65dca416ab170654026b932b5 beca0e6ab4a246b3aa7faaeb80fea1b7 cf6884d65dca416ab170654026b932b5--beca0e6ab4a246b3aa7faaeb80fea1b7 1bad9d66ab2d4a0ca26dd82d3171123d PHASE(phi_ent\u2083) beca0e6ab4a246b3aa7faaeb80fea1b7--1bad9d66ab2d4a0ca26dd82d3171123d 1bad9d66ab2d4a0ca26dd82d3171123d--9ba918aa57214390aa67cbac8f8bd4f7 1bad9d66ab2d4a0ca26dd82d3171123d--d71341abe42d43f2be1d5464032a3bf6 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_17835b77a1474bafa275ddae30aa42c6 cluster_92d300d408334b53bb86baa217056cc6 c5ed0ee376934b75998417198017edb0 0 436b0731e5924918bff46f58ca63d20f RX(theta\u2080) c5ed0ee376934b75998417198017edb0--436b0731e5924918bff46f58ca63d20f 9dfde0d58e0e4881b1885cab16c5a3b3 1 e017d28df02d4697a18b8ce1c13d532c RY(theta\u2083) 436b0731e5924918bff46f58ca63d20f--e017d28df02d4697a18b8ce1c13d532c 0f2b317d16a34f9594e2207bded5e44b RX(theta\u2086) e017d28df02d4697a18b8ce1c13d532c--0f2b317d16a34f9594e2207bded5e44b ba19528721e84907b9b4865c1fed5f85 HamEvo 0f2b317d16a34f9594e2207bded5e44b--ba19528721e84907b9b4865c1fed5f85 e847eee02bff41dfa528e4e722cc6083 RX(theta\u2089) ba19528721e84907b9b4865c1fed5f85--e847eee02bff41dfa528e4e722cc6083 624d62da4b93445497fecb1c08951334 RY(theta\u2081\u2082) e847eee02bff41dfa528e4e722cc6083--624d62da4b93445497fecb1c08951334 14c6038dd43f491aa4018395cfb05707 RX(theta\u2081\u2085) 624d62da4b93445497fecb1c08951334--14c6038dd43f491aa4018395cfb05707 ce1a569b6eac4c4f8f1bd47661f478c2 HamEvo 14c6038dd43f491aa4018395cfb05707--ce1a569b6eac4c4f8f1bd47661f478c2 6a3f8f348e5b427e8a3b2f0568466f74 ce1a569b6eac4c4f8f1bd47661f478c2--6a3f8f348e5b427e8a3b2f0568466f74 ecefc3ca24b64381979193855b629aee d8355d6a3ee6479a9189349b0cb11a81 RX(theta\u2081) 9dfde0d58e0e4881b1885cab16c5a3b3--d8355d6a3ee6479a9189349b0cb11a81 9fcac3e0ea4e456a954d3b5fb7e6c121 2 ceb5a169ed414908bda875cc039ac913 RY(theta\u2084) d8355d6a3ee6479a9189349b0cb11a81--ceb5a169ed414908bda875cc039ac913 97759a9929e749a885fcfd876f03445d RX(theta\u2087) ceb5a169ed414908bda875cc039ac913--97759a9929e749a885fcfd876f03445d 1b636210586c4e6fa4d6a9b1adc0bbfd t = theta_t\u2080 97759a9929e749a885fcfd876f03445d--1b636210586c4e6fa4d6a9b1adc0bbfd ed7be39bd66947f9b19a6b5c25f614a5 RX(theta\u2081\u2080) 1b636210586c4e6fa4d6a9b1adc0bbfd--ed7be39bd66947f9b19a6b5c25f614a5 2ad18901f2134d9baab407421a1a1971 RY(theta\u2081\u2083) ed7be39bd66947f9b19a6b5c25f614a5--2ad18901f2134d9baab407421a1a1971 9c7444ac2b6c41639ac1c5ef20981331 RX(theta\u2081\u2086) 2ad18901f2134d9baab407421a1a1971--9c7444ac2b6c41639ac1c5ef20981331 353cd9c5af13442590ff378a23c10068 t = theta_t\u2081 9c7444ac2b6c41639ac1c5ef20981331--353cd9c5af13442590ff378a23c10068 353cd9c5af13442590ff378a23c10068--ecefc3ca24b64381979193855b629aee 3008c6448b434a5abc375dcd43784d00 b67a2f0efc4a49d19f65132d8c5be156 RX(theta\u2082) 9fcac3e0ea4e456a954d3b5fb7e6c121--b67a2f0efc4a49d19f65132d8c5be156 a37f8b13395e44ac989411e6009d24e8 RY(theta\u2085) b67a2f0efc4a49d19f65132d8c5be156--a37f8b13395e44ac989411e6009d24e8 70b39b5deae24ddea91ec21cb70f9552 RX(theta\u2088) a37f8b13395e44ac989411e6009d24e8--70b39b5deae24ddea91ec21cb70f9552 cec756d6764144738785788326b503bf 70b39b5deae24ddea91ec21cb70f9552--cec756d6764144738785788326b503bf f4ddc0fbbf284e7aa1d05f35c3cc4a07 RX(theta\u2081\u2081) cec756d6764144738785788326b503bf--f4ddc0fbbf284e7aa1d05f35c3cc4a07 9f775efec38d4cf5bb76c8b84e673447 RY(theta\u2081\u2084) f4ddc0fbbf284e7aa1d05f35c3cc4a07--9f775efec38d4cf5bb76c8b84e673447 5af9a827ea9e440bb478750d8895ab92 RX(theta\u2081\u2087) 9f775efec38d4cf5bb76c8b84e673447--5af9a827ea9e440bb478750d8895ab92 5b9aa770f20a44d7b70e7bd0b2657354 5af9a827ea9e440bb478750d8895ab92--5b9aa770f20a44d7b70e7bd0b2657354 5b9aa770f20a44d7b70e7bd0b2657354--3008c6448b434a5abc375dcd43784d00 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_addd5c55ffce42e4a7d581b326954038 cluster_824a246d8ba143aebb865096a090d12a b480087d397946e188e8dc04e8f16183 0 8df76b79f82943058cbdb57d13ff0e1e RX(theta\u2080) b480087d397946e188e8dc04e8f16183--8df76b79f82943058cbdb57d13ff0e1e af8cad87265b4665aaefc6a7f8e35946 1 e240bd9fbd164cecae3ad61197fda4a6 RY(theta\u2086) 8df76b79f82943058cbdb57d13ff0e1e--e240bd9fbd164cecae3ad61197fda4a6 a49af30fbe284786a71cc411fca62a05 RX(theta\u2081\u2082) e240bd9fbd164cecae3ad61197fda4a6--a49af30fbe284786a71cc411fca62a05 dc14fd5f033e412486699784159d3d8f a49af30fbe284786a71cc411fca62a05--dc14fd5f033e412486699784159d3d8f 3d927a3b5f314096a464ea9c665359cd RX(theta\u2081\u2088) dc14fd5f033e412486699784159d3d8f--3d927a3b5f314096a464ea9c665359cd 3c044b5747e14b7ca95cc879266016d6 RY(theta\u2082\u2084) 3d927a3b5f314096a464ea9c665359cd--3c044b5747e14b7ca95cc879266016d6 b247d98d7b214421a1485d922b669811 RX(theta\u2083\u2080) 3c044b5747e14b7ca95cc879266016d6--b247d98d7b214421a1485d922b669811 b2a4289361b34e6da9c31d4e4b174b72 b247d98d7b214421a1485d922b669811--b2a4289361b34e6da9c31d4e4b174b72 eb2da7ac751744c0b7650403595a3f56 b2a4289361b34e6da9c31d4e4b174b72--eb2da7ac751744c0b7650403595a3f56 8b9e619715fb411b9835bd7ce96ebdb2 80521fb5e6ad4e509a095d76fbb2004a RX(theta\u2081) af8cad87265b4665aaefc6a7f8e35946--80521fb5e6ad4e509a095d76fbb2004a ad7882a7c2a6485e98f80905e446efec 2 7a5611478ce04d538ec919a8dca5eee0 RY(theta\u2087) 80521fb5e6ad4e509a095d76fbb2004a--7a5611478ce04d538ec919a8dca5eee0 771cb9e667414faf8b9717dfadf31fa9 RX(theta\u2081\u2083) 7a5611478ce04d538ec919a8dca5eee0--771cb9e667414faf8b9717dfadf31fa9 54a05eab98fb4290a461a0ff015f56a7 771cb9e667414faf8b9717dfadf31fa9--54a05eab98fb4290a461a0ff015f56a7 0165c356c68d49c9b07ee8908e6afdc0 RX(theta\u2081\u2089) 54a05eab98fb4290a461a0ff015f56a7--0165c356c68d49c9b07ee8908e6afdc0 e9a55a41bb924acca59b924f26fe92c5 RY(theta\u2082\u2085) 0165c356c68d49c9b07ee8908e6afdc0--e9a55a41bb924acca59b924f26fe92c5 ff6cbffe4e5841dbafa6d8a52315f487 RX(theta\u2083\u2081) e9a55a41bb924acca59b924f26fe92c5--ff6cbffe4e5841dbafa6d8a52315f487 74d21d54d8364f84a4fa22af25588b88 ff6cbffe4e5841dbafa6d8a52315f487--74d21d54d8364f84a4fa22af25588b88 74d21d54d8364f84a4fa22af25588b88--8b9e619715fb411b9835bd7ce96ebdb2 61722aa412194979bdbde236bc7c534d 7dd9476e3f2c45d89a7e30f8b935a32c RX(theta\u2082) ad7882a7c2a6485e98f80905e446efec--7dd9476e3f2c45d89a7e30f8b935a32c 0826c1c3ad6243b8b5e99aada5518df2 3 e4e6b79e6c6f43caa1f6cc9a6c285351 RY(theta\u2088) 7dd9476e3f2c45d89a7e30f8b935a32c--e4e6b79e6c6f43caa1f6cc9a6c285351 8be86a19def94155932649b94a4ddeeb RX(theta\u2081\u2084) e4e6b79e6c6f43caa1f6cc9a6c285351--8be86a19def94155932649b94a4ddeeb 193c6d92937c4994b8f9d98924c8595b HamEvo 8be86a19def94155932649b94a4ddeeb--193c6d92937c4994b8f9d98924c8595b 94d8e32ff6c54d70b40bbd8f78bcb717 RX(theta\u2082\u2080) 193c6d92937c4994b8f9d98924c8595b--94d8e32ff6c54d70b40bbd8f78bcb717 e8cbcf20a2ec4cb2b20e7994a2bf8711 RY(theta\u2082\u2086) 94d8e32ff6c54d70b40bbd8f78bcb717--e8cbcf20a2ec4cb2b20e7994a2bf8711 b8d2c1268c5b43bebbb084ac61f1021d RX(theta\u2083\u2082) e8cbcf20a2ec4cb2b20e7994a2bf8711--b8d2c1268c5b43bebbb084ac61f1021d 01a4dd680dbe41bab97ca34ff6911eb9 HamEvo b8d2c1268c5b43bebbb084ac61f1021d--01a4dd680dbe41bab97ca34ff6911eb9 01a4dd680dbe41bab97ca34ff6911eb9--61722aa412194979bdbde236bc7c534d fc6b179d74e94b6aa1bf7661f0a1f2e4 b4d7034a41974763b94d728d3613aae1 RX(theta\u2083) 0826c1c3ad6243b8b5e99aada5518df2--b4d7034a41974763b94d728d3613aae1 33f7e2f0b88749048f7e8d3e1b136a94 4 1406aa2f7da54f8b8d2710768738231c RY(theta\u2089) b4d7034a41974763b94d728d3613aae1--1406aa2f7da54f8b8d2710768738231c 72a158f0c87449d78ba7cfe2dcafa8b0 RX(theta\u2081\u2085) 1406aa2f7da54f8b8d2710768738231c--72a158f0c87449d78ba7cfe2dcafa8b0 ae04c1ab2cd940ce9236abb429422a17 t = theta_t\u2080 72a158f0c87449d78ba7cfe2dcafa8b0--ae04c1ab2cd940ce9236abb429422a17 7fe7aa56fa3449979fb601b3db8eb637 RX(theta\u2082\u2081) ae04c1ab2cd940ce9236abb429422a17--7fe7aa56fa3449979fb601b3db8eb637 e88d21dd37b7481182f3acde22d38ce5 RY(theta\u2082\u2087) 7fe7aa56fa3449979fb601b3db8eb637--e88d21dd37b7481182f3acde22d38ce5 48f4b52ac7874cd79474645fe2bfda48 RX(theta\u2083\u2083) e88d21dd37b7481182f3acde22d38ce5--48f4b52ac7874cd79474645fe2bfda48 5061f3ded36b40dc82c7f51d52f24c81 t = theta_t\u2081 48f4b52ac7874cd79474645fe2bfda48--5061f3ded36b40dc82c7f51d52f24c81 5061f3ded36b40dc82c7f51d52f24c81--fc6b179d74e94b6aa1bf7661f0a1f2e4 4b96bbd4b373401b842f2155ee6f2f8d e8633e427a064efd9512811a71d3a3c5 RX(theta\u2084) 33f7e2f0b88749048f7e8d3e1b136a94--e8633e427a064efd9512811a71d3a3c5 4c75fb0bd3874180825b84f4b64bba37 5 250548637d874619b558c5ab9dbdf866 RY(theta\u2081\u2080) e8633e427a064efd9512811a71d3a3c5--250548637d874619b558c5ab9dbdf866 faa8f490cec0489f8b1b900799fe8159 RX(theta\u2081\u2086) 250548637d874619b558c5ab9dbdf866--faa8f490cec0489f8b1b900799fe8159 5e130fa4228447268c29bf3b3ba57f1a faa8f490cec0489f8b1b900799fe8159--5e130fa4228447268c29bf3b3ba57f1a 61f4b31ba6f0472893b6d1db40b140f9 RX(theta\u2082\u2082) 5e130fa4228447268c29bf3b3ba57f1a--61f4b31ba6f0472893b6d1db40b140f9 b88f1111e33442cdad69a0b24de0462a RY(theta\u2082\u2088) 61f4b31ba6f0472893b6d1db40b140f9--b88f1111e33442cdad69a0b24de0462a be662b5188fb4342afe9b7242a5cfd13 RX(theta\u2083\u2084) b88f1111e33442cdad69a0b24de0462a--be662b5188fb4342afe9b7242a5cfd13 abd2ef74bd4a4fbcaf1874b30fd33843 be662b5188fb4342afe9b7242a5cfd13--abd2ef74bd4a4fbcaf1874b30fd33843 abd2ef74bd4a4fbcaf1874b30fd33843--4b96bbd4b373401b842f2155ee6f2f8d 8f015990985a472b99c1e65b310939e0 c3180c9b179f486997a4112f939b91f4 RX(theta\u2085) 4c75fb0bd3874180825b84f4b64bba37--c3180c9b179f486997a4112f939b91f4 843232376d354bbb8b3ab43f9b13e207 RY(theta\u2081\u2081) c3180c9b179f486997a4112f939b91f4--843232376d354bbb8b3ab43f9b13e207 8ac329b782334dd3bed248a49516aa74 RX(theta\u2081\u2087) 843232376d354bbb8b3ab43f9b13e207--8ac329b782334dd3bed248a49516aa74 59d6ea437e2c4ce29390120529416752 8ac329b782334dd3bed248a49516aa74--59d6ea437e2c4ce29390120529416752 003b0194c2454a1581ffacb256f69bac RX(theta\u2082\u2083) 59d6ea437e2c4ce29390120529416752--003b0194c2454a1581ffacb256f69bac 38548c0286ce4b62bbe9e053798f7163 RY(theta\u2082\u2089) 003b0194c2454a1581ffacb256f69bac--38548c0286ce4b62bbe9e053798f7163 628e188c85a545ce9a318e6faa0cbb4c RX(theta\u2083\u2085) 38548c0286ce4b62bbe9e053798f7163--628e188c85a545ce9a318e6faa0cbb4c 5b68a22e61f24eeda1d61e0f1e60fef7 628e188c85a545ce9a318e6faa0cbb4c--5b68a22e61f24eeda1d61e0f1e60fef7 5b68a22e61f24eeda1d61e0f1e60fef7--8f015990985a472b99c1e65b310939e0"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_355e299521194e46939e71be5249fe44 BPMA-1 cluster_aa853ba6ecac4b4b9e37b798465ba6d1 BPMA-0 c5eb023b617d493aac8e7b33a1b44474 0 a8b395a3e77e4763978ec4f3bdfd0081 RX(alpha\u2080\u2080) c5eb023b617d493aac8e7b33a1b44474--a8b395a3e77e4763978ec4f3bdfd0081 720cb4efb7cf41f381ddd2a47f05367d 1 0219481b03784829adab62357c072ae6 RY(alpha\u2080\u2083) a8b395a3e77e4763978ec4f3bdfd0081--0219481b03784829adab62357c072ae6 3dcc0f3b71694e69b0036eaa55794a05 0219481b03784829adab62357c072ae6--3dcc0f3b71694e69b0036eaa55794a05 b138dbfd41e6491995c2c75e3b995c95 3dcc0f3b71694e69b0036eaa55794a05--b138dbfd41e6491995c2c75e3b995c95 bf3b9750a73b4ac8bbea574e14f21ebe RX(gamma\u2080\u2080) b138dbfd41e6491995c2c75e3b995c95--bf3b9750a73b4ac8bbea574e14f21ebe 42434b54fb4444449335472a8508cfac bf3b9750a73b4ac8bbea574e14f21ebe--42434b54fb4444449335472a8508cfac 1dc03b0a5ef44c0b94c2bfe6016ad975 42434b54fb4444449335472a8508cfac--1dc03b0a5ef44c0b94c2bfe6016ad975 2b029a4d860648a684ed554749f70998 RY(beta\u2080\u2083) 1dc03b0a5ef44c0b94c2bfe6016ad975--2b029a4d860648a684ed554749f70998 7de0314c7ff54cbf9b54ba0a860951c6 RX(beta\u2080\u2080) 2b029a4d860648a684ed554749f70998--7de0314c7ff54cbf9b54ba0a860951c6 ea50acfec48b4a0f8b4cb705287fef9f RX(alpha\u2081\u2080) 7de0314c7ff54cbf9b54ba0a860951c6--ea50acfec48b4a0f8b4cb705287fef9f f6c9cc69f92d4875951c9827446ff841 RY(alpha\u2081\u2083) ea50acfec48b4a0f8b4cb705287fef9f--f6c9cc69f92d4875951c9827446ff841 16d6f22d51bc4f59b96be41827223f65 f6c9cc69f92d4875951c9827446ff841--16d6f22d51bc4f59b96be41827223f65 dcf2209fd094488fb9598974836e5e25 16d6f22d51bc4f59b96be41827223f65--dcf2209fd094488fb9598974836e5e25 ceadd292408543029363765a1a1e1117 RX(gamma\u2081\u2080) dcf2209fd094488fb9598974836e5e25--ceadd292408543029363765a1a1e1117 b510e97ed9d0460aa8e46a9101850daf ceadd292408543029363765a1a1e1117--b510e97ed9d0460aa8e46a9101850daf a1d938276d4146febca581e0e304394d b510e97ed9d0460aa8e46a9101850daf--a1d938276d4146febca581e0e304394d ea7d45b71a214e33afe491a41f90029c RY(beta\u2081\u2083) a1d938276d4146febca581e0e304394d--ea7d45b71a214e33afe491a41f90029c 5cfa42e1731f4258be2cc4aea1e30f84 RX(beta\u2081\u2080) ea7d45b71a214e33afe491a41f90029c--5cfa42e1731f4258be2cc4aea1e30f84 01466e4dba9744f8869aa7d1dde26296 5cfa42e1731f4258be2cc4aea1e30f84--01466e4dba9744f8869aa7d1dde26296 94ed6753c9c54dee828bcaad8d75f8b5 f3157498fae44203a592b98d11ca1769 RX(alpha\u2080\u2081) 720cb4efb7cf41f381ddd2a47f05367d--f3157498fae44203a592b98d11ca1769 abb5bae7414c42839a9741d1a4192ac2 2 c576e3f7cfcc464b9accae98fc4ee371 RY(alpha\u2080\u2084) f3157498fae44203a592b98d11ca1769--c576e3f7cfcc464b9accae98fc4ee371 7c19b0e169634fa6a6d3908d5717aeb7 X c576e3f7cfcc464b9accae98fc4ee371--7c19b0e169634fa6a6d3908d5717aeb7 7c19b0e169634fa6a6d3908d5717aeb7--3dcc0f3b71694e69b0036eaa55794a05 d65a2121895743dba8131835be2a01b2 7c19b0e169634fa6a6d3908d5717aeb7--d65a2121895743dba8131835be2a01b2 eed7a0c1ca354cda9b5c980b6d9d8827 RX(gamma\u2080\u2081) d65a2121895743dba8131835be2a01b2--eed7a0c1ca354cda9b5c980b6d9d8827 e5b7aced719f4b92961efc632ed702f0 eed7a0c1ca354cda9b5c980b6d9d8827--e5b7aced719f4b92961efc632ed702f0 6451c720d672428f8b592690a1ea7e8f X e5b7aced719f4b92961efc632ed702f0--6451c720d672428f8b592690a1ea7e8f 6451c720d672428f8b592690a1ea7e8f--1dc03b0a5ef44c0b94c2bfe6016ad975 78b4620675fa40dc9005edf5f19bcaa6 RY(beta\u2080\u2084) 6451c720d672428f8b592690a1ea7e8f--78b4620675fa40dc9005edf5f19bcaa6 bd265edc6b0049fba59ad42c146c3e87 RX(beta\u2080\u2081) 78b4620675fa40dc9005edf5f19bcaa6--bd265edc6b0049fba59ad42c146c3e87 f26d789f795744f79d2f4e206824bc22 RX(alpha\u2081\u2081) bd265edc6b0049fba59ad42c146c3e87--f26d789f795744f79d2f4e206824bc22 b23803c9825a4638ac143459ae8115ef RY(alpha\u2081\u2084) f26d789f795744f79d2f4e206824bc22--b23803c9825a4638ac143459ae8115ef 9e128fcfebe9427f9ecc766e98f68a0b X b23803c9825a4638ac143459ae8115ef--9e128fcfebe9427f9ecc766e98f68a0b 9e128fcfebe9427f9ecc766e98f68a0b--16d6f22d51bc4f59b96be41827223f65 8c5c5a1aae974eb093456df3ae32fc1a 9e128fcfebe9427f9ecc766e98f68a0b--8c5c5a1aae974eb093456df3ae32fc1a 5f010d06db11427d9b84b2043fc9fef7 RX(gamma\u2081\u2081) 8c5c5a1aae974eb093456df3ae32fc1a--5f010d06db11427d9b84b2043fc9fef7 7d825917b89c4c1486cf4e99dbfe99c1 5f010d06db11427d9b84b2043fc9fef7--7d825917b89c4c1486cf4e99dbfe99c1 bfd484bcbfee40778f25aa89d2cdafc8 X 7d825917b89c4c1486cf4e99dbfe99c1--bfd484bcbfee40778f25aa89d2cdafc8 bfd484bcbfee40778f25aa89d2cdafc8--a1d938276d4146febca581e0e304394d 7d6ed5a87c0a48058db716605c082f83 RY(beta\u2081\u2084) bfd484bcbfee40778f25aa89d2cdafc8--7d6ed5a87c0a48058db716605c082f83 29b8b3305bdb4a27872e5d371c47cb3f RX(beta\u2081\u2081) 7d6ed5a87c0a48058db716605c082f83--29b8b3305bdb4a27872e5d371c47cb3f 29b8b3305bdb4a27872e5d371c47cb3f--94ed6753c9c54dee828bcaad8d75f8b5 0b7576ffb55641c6af11b57106e96f98 ff8f2864625c42df9248ab3ff0192aaf RX(alpha\u2080\u2082) abb5bae7414c42839a9741d1a4192ac2--ff8f2864625c42df9248ab3ff0192aaf 44130d902e6d457793525173b6f6d4b9 RY(alpha\u2080\u2085) ff8f2864625c42df9248ab3ff0192aaf--44130d902e6d457793525173b6f6d4b9 fa45ab058bb24919938d0524e3ac66cd 44130d902e6d457793525173b6f6d4b9--fa45ab058bb24919938d0524e3ac66cd c04023d98eb54844b9c69c7ecc53983b X fa45ab058bb24919938d0524e3ac66cd--c04023d98eb54844b9c69c7ecc53983b c04023d98eb54844b9c69c7ecc53983b--d65a2121895743dba8131835be2a01b2 a8d0aee407ae40ea97631449550c413b RX(gamma\u2080\u2082) c04023d98eb54844b9c69c7ecc53983b--a8d0aee407ae40ea97631449550c413b 436d4c6352ab4b99b0ccfdff71135cf1 X a8d0aee407ae40ea97631449550c413b--436d4c6352ab4b99b0ccfdff71135cf1 436d4c6352ab4b99b0ccfdff71135cf1--e5b7aced719f4b92961efc632ed702f0 976540343efa466cb5617368b1fec6b2 436d4c6352ab4b99b0ccfdff71135cf1--976540343efa466cb5617368b1fec6b2 280be3758e494ed9aad0db6c959d623f RY(beta\u2080\u2085) 976540343efa466cb5617368b1fec6b2--280be3758e494ed9aad0db6c959d623f 846961abde214c74a5315b2edafd3964 RX(beta\u2080\u2082) 280be3758e494ed9aad0db6c959d623f--846961abde214c74a5315b2edafd3964 2161a226add04660a81ed430ddf3b188 RX(alpha\u2081\u2082) 846961abde214c74a5315b2edafd3964--2161a226add04660a81ed430ddf3b188 2ef190efd3714ec7bd6e1666d8433765 RY(alpha\u2081\u2085) 2161a226add04660a81ed430ddf3b188--2ef190efd3714ec7bd6e1666d8433765 cf68f315c9334e908ef9f7c7d022793d 2ef190efd3714ec7bd6e1666d8433765--cf68f315c9334e908ef9f7c7d022793d 532fd22f86b7465ba9a154fe2250cea7 X cf68f315c9334e908ef9f7c7d022793d--532fd22f86b7465ba9a154fe2250cea7 532fd22f86b7465ba9a154fe2250cea7--8c5c5a1aae974eb093456df3ae32fc1a 90178ec7cd6d437ba601752cc73c7607 RX(gamma\u2081\u2082) 532fd22f86b7465ba9a154fe2250cea7--90178ec7cd6d437ba601752cc73c7607 c1c838ae3574479a9e6a382555520dbb X 90178ec7cd6d437ba601752cc73c7607--c1c838ae3574479a9e6a382555520dbb c1c838ae3574479a9e6a382555520dbb--7d825917b89c4c1486cf4e99dbfe99c1 cea7592d090a4975b9f4305db9f0a48c c1c838ae3574479a9e6a382555520dbb--cea7592d090a4975b9f4305db9f0a48c 4b994d5511a44edf872e0db2cb277032 RY(beta\u2081\u2085) cea7592d090a4975b9f4305db9f0a48c--4b994d5511a44edf872e0db2cb277032 82f7fb71850a4d7197cb98f5987757b2 RX(beta\u2081\u2082) 4b994d5511a44edf872e0db2cb277032--82f7fb71850a4d7197cb98f5987757b2 82f7fb71850a4d7197cb98f5987757b2--0b7576ffb55641c6af11b57106e96f98"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>This section introduces the various measurement protocols.</p>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>This section introduces mitigation protocols.</p>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'00': 50, '10': 50})]\nnoisy = [Counter({'00': 46, '10': 42, '01': 6, '11': 6})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[1.0026]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9704]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 39bc063b-8f84-44a6-9559-65e88b18acad, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': a4975af5-56fb-4993-b110-c4027b86e24e, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': b83f3287-aab7-4eab-ab0e-f55a7ebdda96, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 48934cbd-b2d7-4158-8cd6-c441e04106be, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 54b1e9ec-da9a-493b-a48b-e0eca0253772, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 94ac0998-f8e7-4b48-bbc3-432f9ab51281, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 14053a76-37da-4298-a33a-0efd2db2ebd3, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 8cca3545-8188-485d-96b2-296540ebd429, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 38e1aa47-a8e3-40d0-b972-1f9ed2562a74, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': c96c74c9-5ff0-4f88-9cd0-e1d14e3c72cb, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0b9ee9b6-3cea-4d83-88eb-c379ba01567c, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_0: tensor([0.1505], requires_grad=True)\n  theta_3: tensor([0.9275], requires_grad=True)\n  theta_4: tensor([0.7986], requires_grad=True)\n  theta_5: tensor([0.1050], requires_grad=True)\n  theta_6: tensor([0.7025], requires_grad=True)\n  theta_7: tensor([0.9841], requires_grad=True)\n  theta_1: tensor([0.0848], requires_grad=True)\n  theta_2: tensor([0.8550], requires_grad=True)\n  theta_8: tensor([0.8725], requires_grad=True)\n}\nembedded = {\n  39bc063b-8f84-44a6-9559-65e88b18acad: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  a4975af5-56fb-4993-b110-c4027b86e24e: tensor([2., 2.])\n  b83f3287-aab7-4eab-ab0e-f55a7ebdda96: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n  48934cbd-b2d7-4158-8cd6-c441e04106be: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n  54b1e9ec-da9a-493b-a48b-e0eca0253772: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n  94ac0998-f8e7-4b48-bbc3-432f9ab51281: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n  14053a76-37da-4298-a33a-0efd2db2ebd3: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n  8cca3545-8188-485d-96b2-296540ebd429: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\n  38e1aa47-a8e3-40d0-b972-1f9ed2562a74: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n  c96c74c9-5ff0-4f88-9cd0-e1d14e3c72cb: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n  0b9ee9b6-3cea-4d83-88eb-c379ba01567c: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_0: tensor([0.1505], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.9275], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.7986], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.1050], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  theta_6: tensor([0.7025], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.9841], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.0848], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.8550], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.8725], grad_fn=&lt;ViewBackward0&gt;)\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n         -0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j],\n        [ 0.1347-0.2025j, -0.2260-0.1742j,  0.3257+0.0072j,  0.0132+0.2774j,\n         -0.2720-0.3532j, -0.4356+0.2895j,  0.3382+0.0606j, -0.0314+0.2912j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'001': 194, '000': 157, '110': 121, '010': 121, '101': 113, '011': 102, '100': 100, '111': 92})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(39bc063b-8f84-44a6-9559-65e88b18acad)-C----------------------------------------Rx(b83f3287-aab7-4eab-ab0e-f55a7ebdda96)-Ry(94ac0998-f8e7-4b48-bbc3-432f9ab51281)-Rx(38e1aa47-a8e3-40d0-b972-1f9ed2562a74)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(a4975af5-56fb-4993-b110-c4027b86e24e)-X----------------------------------------Rx(48934cbd-b2d7-4158-8cd6-c441e04106be)-Ry(14053a76-37da-4298-a33a-0efd2db2ebd3)-Rx(c96c74c9-5ff0-4f88-9cd0-e1d14e3c72cb)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(54b1e9ec-da9a-493b-a48b-e0eca0253772)-Ry(8cca3545-8188-485d-96b2-296540ebd429)-Rx(0b9ee9b6-3cea-4d83-88eb-c379ba01567c)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [0b9ee9b6-3cea-4d83-88eb-c379ba01567c, 14053a76-37da-4298-a33a-0efd2db2ebd3, 38e1aa47-a8e3-40d0-b972-1f9ed2562a74, 39bc063b-8f84-44a6-9559-65e88b18acad, 48934cbd-b2d7-4158-8cd6-c441e04106be, 54b1e9ec-da9a-493b-a48b-e0eca0253772, 8cca3545-8188-485d-96b2-296540ebd429, 94ac0998-f8e7-4b48-bbc3-432f9ab51281, a4975af5-56fb-4993-b110-c4027b86e24e, b83f3287-aab7-4eab-ab0e-f55a7ebdda96, c96c74c9-5ff0-4f88-9cd0-e1d14e3c72cb].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(0.55)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.15)-DEPO(0.1)-Ry(0.93)-DEPO(0.1)-Rx(0.70)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.03)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.08)-DEPO(0.1)-Ry(0.80)-DEPO(0.1)-Rx(0.98)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.85)-DEPO(0.1)-Ry(0.10)-DEPO(0.1)-Rx(0.87)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 b11fe6de0c0a46398bd4459561458e3e 0 c32f72a3fbe6447cadcd9bb8ee303c35 X b11fe6de0c0a46398bd4459561458e3e--c32f72a3fbe6447cadcd9bb8ee303c35 2fc54a5cc6074c2f8af35b0b2c297667 1 1e30ed5280794aee939ed40d07652945 c32f72a3fbe6447cadcd9bb8ee303c35--1e30ed5280794aee939ed40d07652945 3f01e8a2831f40df8ca14ab555970152 42a149e659db4a0b860b8299451e7076 Y 2fc54a5cc6074c2f8af35b0b2c297667--42a149e659db4a0b860b8299451e7076 42a149e659db4a0b860b8299451e7076--3f01e8a2831f40df8ca14ab555970152 </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 8595e658a01a4825a0ad6c5c0172d333 0 26e0954a8b1047678afbe6ebf0399b97 RX(0.5) 8595e658a01a4825a0ad6c5c0172d333--26e0954a8b1047678afbe6ebf0399b97 ef4d508266dd4c69b747e89fb5396ad9 26e0954a8b1047678afbe6ebf0399b97--ef4d508266dd4c69b747e89fb5396ad9 <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 d50ea3d023d04c5d9d4b5bfb17b78fd8 0 288b9755a2cf46ea9e4620df18a96933 d50ea3d023d04c5d9d4b5bfb17b78fd8--288b9755a2cf46ea9e4620df18a96933 06e3a2fd950845c68043e4a9544819b8 1 61d7704464854b638a7a21fd9cfc82df 288b9755a2cf46ea9e4620df18a96933--61d7704464854b638a7a21fd9cfc82df e3d53b8fadd34c8b956489525aba4fe8 6f93a89332a34ba8b49d2b5458d910ef X 06e3a2fd950845c68043e4a9544819b8--6f93a89332a34ba8b49d2b5458d910ef 6f93a89332a34ba8b49d2b5458d910ef--288b9755a2cf46ea9e4620df18a96933 6f93a89332a34ba8b49d2b5458d910ef--e3d53b8fadd34c8b956489525aba4fe8 <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 c2c62df38c3248c2a38ddaad57512b1d 0 567bc66074d84625b21566fa86619b03 X c2c62df38c3248c2a38ddaad57512b1d--567bc66074d84625b21566fa86619b03 06290216aa06409689eec4a4fdffa582 X 567bc66074d84625b21566fa86619b03--06290216aa06409689eec4a4fdffa582 3e53dca490224bd5ac9a80a468ee2798 06290216aa06409689eec4a4fdffa582--3e53dca490224bd5ac9a80a468ee2798 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 55370c91c87b4b14ab24f015bcee945b 0 63e3ad98fcec49d68daf754497ce62b6 X 55370c91c87b4b14ab24f015bcee945b--63e3ad98fcec49d68daf754497ce62b6 7401eea32e674e7099c592ab06aeb403 1 7929782684964a7c83e8fc7f6f5335a4 63e3ad98fcec49d68daf754497ce62b6--7929782684964a7c83e8fc7f6f5335a4 322b41e48f2046b3824efd493634b8d7 7929782684964a7c83e8fc7f6f5335a4--322b41e48f2046b3824efd493634b8d7 8d9dda173ce14d6fa639dc28b08211df 806e027416524c718532bd45998448a5 7401eea32e674e7099c592ab06aeb403--806e027416524c718532bd45998448a5 c375dbe8daca4aa9926198c9fa315f06 X 806e027416524c718532bd45998448a5--c375dbe8daca4aa9926198c9fa315f06 c375dbe8daca4aa9926198c9fa315f06--8d9dda173ce14d6fa639dc28b08211df </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 4a570e3d898249b1b105a7584be7d41d 0 a7ecc4b01fb6456dab1f21b5b5e1bd60 X 4a570e3d898249b1b105a7584be7d41d--a7ecc4b01fb6456dab1f21b5b5e1bd60 d1d9772ce847486f96ea766b99280c3a 1 91c11eb5ab564d32929ef578670c6a8b a7ecc4b01fb6456dab1f21b5b5e1bd60--91c11eb5ab564d32929ef578670c6a8b 609809bcebcb4e08a5e75f4a6721aa21 bc16a4231b0a49c6980470f68bd1176a X d1d9772ce847486f96ea766b99280c3a--bc16a4231b0a49c6980470f68bd1176a bc16a4231b0a49c6980470f68bd1176a--609809bcebcb4e08a5e75f4a6721aa21 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_008f4b2eecc14bc8ad87e0da8ee968f9 subblock cluster_f70766164e054a67a2c42bef326909ff subblock cdf18caa23ec4206ab22232eec3c7819 0 0898119770a34458894678f37afa4b34 X cdf18caa23ec4206ab22232eec3c7819--0898119770a34458894678f37afa4b34 a3b76bfca25c46d79becf99d1e60dd54 1 5d2874d826244534aafe74a4697fa35a X 0898119770a34458894678f37afa4b34--5d2874d826244534aafe74a4697fa35a 47ed70a81eb942eaa66d5694faf2bff9 5d2874d826244534aafe74a4697fa35a--47ed70a81eb942eaa66d5694faf2bff9 0cfcf0e6a8854b4f9bda1bf1963d8dcb 3fc4a18ecdd847c195f9e107f88017ab Y a3b76bfca25c46d79becf99d1e60dd54--3fc4a18ecdd847c195f9e107f88017ab 40ebcd44b21e427f9d4bff3ca9f34e19 2 718c792868354dc59a205f23aabb7523 Y 3fc4a18ecdd847c195f9e107f88017ab--718c792868354dc59a205f23aabb7523 718c792868354dc59a205f23aabb7523--0cfcf0e6a8854b4f9bda1bf1963d8dcb d83dff7fea374cd4ab21be8d6e18154b 84ac4de26c87404abd06b2fd980dea85 40ebcd44b21e427f9d4bff3ca9f34e19--84ac4de26c87404abd06b2fd980dea85 71c80af80dd147229404e9ff5ba67a9e 3 5111d0f4d9d147ae835a8f6194db9a11 84ac4de26c87404abd06b2fd980dea85--5111d0f4d9d147ae835a8f6194db9a11 5111d0f4d9d147ae835a8f6194db9a11--d83dff7fea374cd4ab21be8d6e18154b 240b5e32511a47daa04cc82e774fbb0f 1631c550e996467da09e1047a43d9f35 71c80af80dd147229404e9ff5ba67a9e--1631c550e996467da09e1047a43d9f35 cb467342f55b480d85fbebcf8c9cd40f 4 969cfab403d74bb78221c591d0beaab7 1631c550e996467da09e1047a43d9f35--969cfab403d74bb78221c591d0beaab7 969cfab403d74bb78221c591d0beaab7--240b5e32511a47daa04cc82e774fbb0f 9d739eca12bb4b269eb137bd73a2b32a ccbce1313a1f4ae79c37df6ff8afb58f X cb467342f55b480d85fbebcf8c9cd40f--ccbce1313a1f4ae79c37df6ff8afb58f ccbce1313a1f4ae79c37df6ff8afb58f--1631c550e996467da09e1047a43d9f35 386e326254314a5e922aaf0638fffeed X ccbce1313a1f4ae79c37df6ff8afb58f--386e326254314a5e922aaf0638fffeed 386e326254314a5e922aaf0638fffeed--969cfab403d74bb78221c591d0beaab7 386e326254314a5e922aaf0638fffeed--9d739eca12bb4b269eb137bd73a2b32a"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'11': 257, '10': 254, '00': 251, '01': 238})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'110': 30, '100': 28, '010': 22, '000': 20})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(2)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import torch\nimport numpy as np\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": torch.Tensor([torch.pi / 2, torch.pi])}\nvalues_ket = {\"psi\": torch.Tensor([torch.pi / 2, torch.pi])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[ 0.2630, -0.0138],\n        [ 0.0106,  0.0010]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from torch import pi\nfrom qadence import RX, run\n\n# Let's use a torch type.\nblock = RX(0, pi)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9754+0.0000j, 0.0000-0.2203j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.9058+0.0000j, 0.0000-0.4237j],\n        [0.9047+0.0000j, 0.0000-0.4260j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5444+0.0000j, 0.8070+0.0000j, 0.0000-0.1279j, 0.0000-0.1896j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_c3c2226f332e4323a232aad0e4aafaf7 [* 2] cluster_2e5ab058bcea4568a2f972b3ef844850 Rotations 01e40e2241d44db08be1987843ae9403 0 f0d9f87947e04fb5ac20c91ce3f42ef2 RX(phi/theta) 01e40e2241d44db08be1987843ae9403--f0d9f87947e04fb5ac20c91ce3f42ef2 920c8259c8c04b42af1aa29baa2df518 1 b0bbfdb0251e4971901aeb2c16682379 RX(phi) f0d9f87947e04fb5ac20c91ce3f42ef2--b0bbfdb0251e4971901aeb2c16682379 f2e88d2cbcac45c5a741af70ab62545b RX(phi) b0bbfdb0251e4971901aeb2c16682379--f2e88d2cbcac45c5a741af70ab62545b cc0ee54a912a4d988773aa023e2a603a RX(phi + theta) f2e88d2cbcac45c5a741af70ab62545b--cc0ee54a912a4d988773aa023e2a603a 72eb7ede135349d6a95229142bab1ccb cc0ee54a912a4d988773aa023e2a603a--72eb7ede135349d6a95229142bab1ccb fe01b462b4fa4468940b8d5e4f2d6e9b 72eb7ede135349d6a95229142bab1ccb--fe01b462b4fa4468940b8d5e4f2d6e9b ac09ba8b2daf49099eb4b4539bee34af Z fe01b462b4fa4468940b8d5e4f2d6e9b--ac09ba8b2daf49099eb4b4539bee34af b5f286c9cead471ca474ec1550dae8a9 ac09ba8b2daf49099eb4b4539bee34af--b5f286c9cead471ca474ec1550dae8a9 f29dc91ab828495d919b86b050c7a116 2ee2fa7e7e7e4f7eacfdc0f56bd67ec8 RY(2*theta) 920c8259c8c04b42af1aa29baa2df518--2ee2fa7e7e7e4f7eacfdc0f56bd67ec8 1d6b23eb7bd1476c91c2b6e5b252108a 2 8737a24bf0f04667bd96153e0b73385c RY(theta) 2ee2fa7e7e7e4f7eacfdc0f56bd67ec8--8737a24bf0f04667bd96153e0b73385c 775c7135e4f94cf1a05bcf8826c123d7 RY(theta) 8737a24bf0f04667bd96153e0b73385c--775c7135e4f94cf1a05bcf8826c123d7 f729654a569444ba8206bf65f57a5555 RY(theta**2) 775c7135e4f94cf1a05bcf8826c123d7--f729654a569444ba8206bf65f57a5555 0f0bdb3725ee4c3c8ee2dd3ea51ccb60 X f729654a569444ba8206bf65f57a5555--0f0bdb3725ee4c3c8ee2dd3ea51ccb60 0f0bdb3725ee4c3c8ee2dd3ea51ccb60--72eb7ede135349d6a95229142bab1ccb 4ae948a25c66487c8e402a9338d0c7f9 0f0bdb3725ee4c3c8ee2dd3ea51ccb60--4ae948a25c66487c8e402a9338d0c7f9 ed69ce25467c4b0b8bbdbb211b278413 Z 4ae948a25c66487c8e402a9338d0c7f9--ed69ce25467c4b0b8bbdbb211b278413 ed69ce25467c4b0b8bbdbb211b278413--f29dc91ab828495d919b86b050c7a116 ee619db9184a4ba1950219aae4979e3d a081b79035d4454dbaeef5286f811bc7 RZ(cos(phi)) 1d6b23eb7bd1476c91c2b6e5b252108a--a081b79035d4454dbaeef5286f811bc7 190e05d2bd644cfeb36df3a26da162d1 RZ(phi) a081b79035d4454dbaeef5286f811bc7--190e05d2bd644cfeb36df3a26da162d1 120d676f90004743ad8323b42fa524bc RZ(phi) 190e05d2bd644cfeb36df3a26da162d1--120d676f90004743ad8323b42fa524bc 337d2a6d4dcf47cbb482f4fd38e1e8a8 RZ(cos(phi)) 120d676f90004743ad8323b42fa524bc--337d2a6d4dcf47cbb482f4fd38e1e8a8 4b1b3e7ec12b4a60b253881f50e26462 337d2a6d4dcf47cbb482f4fd38e1e8a8--4b1b3e7ec12b4a60b253881f50e26462 c28fbff4587642b59a1c18f1483d574a X 4b1b3e7ec12b4a60b253881f50e26462--c28fbff4587642b59a1c18f1483d574a c28fbff4587642b59a1c18f1483d574a--4ae948a25c66487c8e402a9338d0c7f9 e3d209c004574e00aa58ba82bd2f27d7 Z c28fbff4587642b59a1c18f1483d574a--e3d209c004574e00aa58ba82bd2f27d7 e3d209c004574e00aa58ba82bd2f27d7--ee619db9184a4ba1950219aae4979e3d <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.3193]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9192+0.0000j, 0.2725+0.0000j, 0.0000-0.2725j, 0.0000-0.0808j],\n        [0.7623+0.0000j, 0.4257+0.0000j, 0.0000-0.4257j, 0.0000-0.2377j],\n        [0.7010+0.0000j, 0.4578+0.0000j, 0.0000-0.4578j, 0.0000-0.2990j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 cdfb29bfc9814deebdbcc6acdafdab34 0 0fe81e75e8624f569f13fa5aac48dea7 RX(theta\u2080) cdfb29bfc9814deebdbcc6acdafdab34--0fe81e75e8624f569f13fa5aac48dea7 9fa111ef86f74698ac9e289c6256a46e 1 3bdeb38081df4268b9b573f92b839e5a RY(theta\u2084) 0fe81e75e8624f569f13fa5aac48dea7--3bdeb38081df4268b9b573f92b839e5a 3c12d557e0f04589a54cc43fab1b07fd RX(theta\u2088) 3bdeb38081df4268b9b573f92b839e5a--3c12d557e0f04589a54cc43fab1b07fd 38852498060546c6ac7aff0680094c8b 3c12d557e0f04589a54cc43fab1b07fd--38852498060546c6ac7aff0680094c8b 22c23e9af11d4af2b5b0b9465298bb79 38852498060546c6ac7aff0680094c8b--22c23e9af11d4af2b5b0b9465298bb79 a5be0e493ba3403bb4e5928e411e420a RX(theta\u2081\u2082) 22c23e9af11d4af2b5b0b9465298bb79--a5be0e493ba3403bb4e5928e411e420a 4ed1d69892ae4e90be7c3b1804c3de1b RY(theta\u2081\u2086) a5be0e493ba3403bb4e5928e411e420a--4ed1d69892ae4e90be7c3b1804c3de1b acf02f7d866747f48bd9acad29511494 RX(theta\u2082\u2080) 4ed1d69892ae4e90be7c3b1804c3de1b--acf02f7d866747f48bd9acad29511494 4ce58db0679b4e73a8152972bb7c9dda acf02f7d866747f48bd9acad29511494--4ce58db0679b4e73a8152972bb7c9dda cde12948c59b40a2987c05deff322894 4ce58db0679b4e73a8152972bb7c9dda--cde12948c59b40a2987c05deff322894 2ecb231c4fd84485a182acf7b5350c28 cde12948c59b40a2987c05deff322894--2ecb231c4fd84485a182acf7b5350c28 a61ca5e9af5e4c2583b7fe11f9ab1b2a 4395dcfa9ec44edaa4d98d52aea962b3 RX(theta\u2081) 9fa111ef86f74698ac9e289c6256a46e--4395dcfa9ec44edaa4d98d52aea962b3 ea349ade2fe4405e9ae5701b6908c2aa 2 ab8870a281dc4e0a8e30eb280e871575 RY(theta\u2085) 4395dcfa9ec44edaa4d98d52aea962b3--ab8870a281dc4e0a8e30eb280e871575 74ee99d24cf84cdca1e69740d0b30aea RX(theta\u2089) ab8870a281dc4e0a8e30eb280e871575--74ee99d24cf84cdca1e69740d0b30aea 744745fb819e4eb3b0e637e9d0ba92f3 X 74ee99d24cf84cdca1e69740d0b30aea--744745fb819e4eb3b0e637e9d0ba92f3 744745fb819e4eb3b0e637e9d0ba92f3--38852498060546c6ac7aff0680094c8b 15b34498a33544e490dd58cf3a2f7739 744745fb819e4eb3b0e637e9d0ba92f3--15b34498a33544e490dd58cf3a2f7739 9083b75bae194c0f9f9e2ecd04517ade RX(theta\u2081\u2083) 15b34498a33544e490dd58cf3a2f7739--9083b75bae194c0f9f9e2ecd04517ade ea04d0f0aa4b455f91cc427b661c20aa RY(theta\u2081\u2087) 9083b75bae194c0f9f9e2ecd04517ade--ea04d0f0aa4b455f91cc427b661c20aa 7628c28d7fa348948bfc3e2b053fdc68 RX(theta\u2082\u2081) ea04d0f0aa4b455f91cc427b661c20aa--7628c28d7fa348948bfc3e2b053fdc68 c42f25ac44c64212806930317c1039eb X 7628c28d7fa348948bfc3e2b053fdc68--c42f25ac44c64212806930317c1039eb c42f25ac44c64212806930317c1039eb--4ce58db0679b4e73a8152972bb7c9dda d0ae6406f78b48a58070363894716acc c42f25ac44c64212806930317c1039eb--d0ae6406f78b48a58070363894716acc d0ae6406f78b48a58070363894716acc--a61ca5e9af5e4c2583b7fe11f9ab1b2a 3e0598b3cf574625972415b012058c67 c5be5276d304459896a077e0b3d21ee7 RX(theta\u2082) ea349ade2fe4405e9ae5701b6908c2aa--c5be5276d304459896a077e0b3d21ee7 3b0c5eb74e714de9b5f0c424238b354a 3 336560464c1d491a91599ebe93c403b2 RY(theta\u2086) c5be5276d304459896a077e0b3d21ee7--336560464c1d491a91599ebe93c403b2 023799043b31497993ceff507b903c43 RX(theta\u2081\u2080) 336560464c1d491a91599ebe93c403b2--023799043b31497993ceff507b903c43 1b77759e7dd24c85867ee8faad22afbf 023799043b31497993ceff507b903c43--1b77759e7dd24c85867ee8faad22afbf 582c57925c054fb59ddc9ec0f1be0126 X 1b77759e7dd24c85867ee8faad22afbf--582c57925c054fb59ddc9ec0f1be0126 582c57925c054fb59ddc9ec0f1be0126--15b34498a33544e490dd58cf3a2f7739 8753cd62e3de4136870515805f6c02b4 RX(theta\u2081\u2084) 582c57925c054fb59ddc9ec0f1be0126--8753cd62e3de4136870515805f6c02b4 2cefd2807ea040419da809d584b5716c RY(theta\u2081\u2088) 8753cd62e3de4136870515805f6c02b4--2cefd2807ea040419da809d584b5716c 3366912a01d148ee87b216b6068e0c1b RX(theta\u2082\u2082) 2cefd2807ea040419da809d584b5716c--3366912a01d148ee87b216b6068e0c1b cec2d30adab0419f9ebcb0f600fe22d4 3366912a01d148ee87b216b6068e0c1b--cec2d30adab0419f9ebcb0f600fe22d4 460a8842acf645af83ea33da9a38ef64 X cec2d30adab0419f9ebcb0f600fe22d4--460a8842acf645af83ea33da9a38ef64 460a8842acf645af83ea33da9a38ef64--d0ae6406f78b48a58070363894716acc 460a8842acf645af83ea33da9a38ef64--3e0598b3cf574625972415b012058c67 dce0b70c9cb54997bf08910a21a074ca d2e3e24c19f14f56941430e6f3957bde RX(theta\u2083) 3b0c5eb74e714de9b5f0c424238b354a--d2e3e24c19f14f56941430e6f3957bde 6a2e2051877a4808b54df6f360411b6a RY(theta\u2087) d2e3e24c19f14f56941430e6f3957bde--6a2e2051877a4808b54df6f360411b6a 974ce8d42f3a4f8794ba4baad351dfad RX(theta\u2081\u2081) 6a2e2051877a4808b54df6f360411b6a--974ce8d42f3a4f8794ba4baad351dfad 9534535f010040758c9e032e28bffd28 X 974ce8d42f3a4f8794ba4baad351dfad--9534535f010040758c9e032e28bffd28 9534535f010040758c9e032e28bffd28--1b77759e7dd24c85867ee8faad22afbf 124b2c65aec94ddd902c0480bc5c885a 9534535f010040758c9e032e28bffd28--124b2c65aec94ddd902c0480bc5c885a 224548b62c924ca1b94895192148dcd9 RX(theta\u2081\u2085) 124b2c65aec94ddd902c0480bc5c885a--224548b62c924ca1b94895192148dcd9 6f3f3e866efa40e5ba1e01a400adaf6a RY(theta\u2081\u2089) 224548b62c924ca1b94895192148dcd9--6f3f3e866efa40e5ba1e01a400adaf6a 957a05472933457eb08165923a70b0a9 RX(theta\u2082\u2083) 6f3f3e866efa40e5ba1e01a400adaf6a--957a05472933457eb08165923a70b0a9 8c843b5303844f599253c080a26382c5 X 957a05472933457eb08165923a70b0a9--8c843b5303844f599253c080a26382c5 8c843b5303844f599253c080a26382c5--cec2d30adab0419f9ebcb0f600fe22d4 13a45cf3cfe046ad87195a7919009750 8c843b5303844f599253c080a26382c5--13a45cf3cfe046ad87195a7919009750 13a45cf3cfe046ad87195a7919009750--dce0b70c9cb54997bf08910a21a074ca </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_04b7e45fc6c34fd284b43e5ae0b58bfd HEA cluster_3e3a8d96cf474d66bbb1a61b8d1793a7 HEA c4916f7328f04b9193db16da5348c1f2 0 ae6947c3ba3b46d9a4a11da9bfe4deca RX(theta\u2080) c4916f7328f04b9193db16da5348c1f2--ae6947c3ba3b46d9a4a11da9bfe4deca 88d01ebc3b934529b8aff60285e17575 1 7948d67bd03e46538d06f77bfb1beea7 RY(theta\u2084) ae6947c3ba3b46d9a4a11da9bfe4deca--7948d67bd03e46538d06f77bfb1beea7 f5c7b9241c094e02aefb89850f139404 RX(theta\u2088) 7948d67bd03e46538d06f77bfb1beea7--f5c7b9241c094e02aefb89850f139404 da64b2ab05bb49f18b155b1d37e8483b f5c7b9241c094e02aefb89850f139404--da64b2ab05bb49f18b155b1d37e8483b e097e6fae5134ce1884b71678b2ddb90 da64b2ab05bb49f18b155b1d37e8483b--e097e6fae5134ce1884b71678b2ddb90 d5a810944fe84693b62e7b368fc94ba4 RX(theta\u2081\u2082) e097e6fae5134ce1884b71678b2ddb90--d5a810944fe84693b62e7b368fc94ba4 01fbe7cf4a554983ab1b76f346336c28 RY(theta\u2081\u2086) d5a810944fe84693b62e7b368fc94ba4--01fbe7cf4a554983ab1b76f346336c28 d9b8e27b92a841b48c38fda82b6af171 RX(theta\u2082\u2080) 01fbe7cf4a554983ab1b76f346336c28--d9b8e27b92a841b48c38fda82b6af171 894154657d5544a49107edafbbcc73ef d9b8e27b92a841b48c38fda82b6af171--894154657d5544a49107edafbbcc73ef 1e2b9e14cd49402cb0e24f7ccd13b254 894154657d5544a49107edafbbcc73ef--1e2b9e14cd49402cb0e24f7ccd13b254 9481f540754a414aa827f318a776d07a RX(theta\u2080) 1e2b9e14cd49402cb0e24f7ccd13b254--9481f540754a414aa827f318a776d07a e7513cb60b594a02b646bb23f74444a2 RY(theta\u2084) 9481f540754a414aa827f318a776d07a--e7513cb60b594a02b646bb23f74444a2 b36392d41104449fa2771cd6578ade5a RX(theta\u2088) e7513cb60b594a02b646bb23f74444a2--b36392d41104449fa2771cd6578ade5a e5d07ca278614b8e80bf4cbe9b2a6ad3 b36392d41104449fa2771cd6578ade5a--e5d07ca278614b8e80bf4cbe9b2a6ad3 d3a68e172a1144e6b6b9331153036a30 e5d07ca278614b8e80bf4cbe9b2a6ad3--d3a68e172a1144e6b6b9331153036a30 8726ec291bf94f6d8b47569f9c353fb4 RX(theta\u2081\u2082) d3a68e172a1144e6b6b9331153036a30--8726ec291bf94f6d8b47569f9c353fb4 76c6c65b01c04c559e1e6b43d8ed7fc1 RY(theta\u2081\u2086) 8726ec291bf94f6d8b47569f9c353fb4--76c6c65b01c04c559e1e6b43d8ed7fc1 9dc3b65cc33340a98b150ed1e46aba4c RX(theta\u2082\u2080) 76c6c65b01c04c559e1e6b43d8ed7fc1--9dc3b65cc33340a98b150ed1e46aba4c 5104911badef4864bcbc744b3c94dad5 9dc3b65cc33340a98b150ed1e46aba4c--5104911badef4864bcbc744b3c94dad5 c939fa758a524a0082fa6c7fa560f6e2 5104911badef4864bcbc744b3c94dad5--c939fa758a524a0082fa6c7fa560f6e2 19f79437e3e042898b7bd917523e2b2f c939fa758a524a0082fa6c7fa560f6e2--19f79437e3e042898b7bd917523e2b2f e7645bb3c46e461abf64f876317f6258 256832bd5c6d476dad629f4c5f1316ea RX(theta\u2081) 88d01ebc3b934529b8aff60285e17575--256832bd5c6d476dad629f4c5f1316ea 29fd1190605a4e71a6877d36e868ea74 2 1a7f3fd1d7284c05840391cf6b6bdc7e RY(theta\u2085) 256832bd5c6d476dad629f4c5f1316ea--1a7f3fd1d7284c05840391cf6b6bdc7e b22d9e5e166b4636b7969703894f6ec9 RX(theta\u2089) 1a7f3fd1d7284c05840391cf6b6bdc7e--b22d9e5e166b4636b7969703894f6ec9 88a24f2e1f04480c8d82c312d04b3724 X b22d9e5e166b4636b7969703894f6ec9--88a24f2e1f04480c8d82c312d04b3724 88a24f2e1f04480c8d82c312d04b3724--da64b2ab05bb49f18b155b1d37e8483b 053ffde2d6054b81a7a2ce4858872918 88a24f2e1f04480c8d82c312d04b3724--053ffde2d6054b81a7a2ce4858872918 10ad8c32115b4d5d9ba9d9344e2a4918 RX(theta\u2081\u2083) 053ffde2d6054b81a7a2ce4858872918--10ad8c32115b4d5d9ba9d9344e2a4918 b0a681f278ee44fbb3a82dfc701dc560 RY(theta\u2081\u2087) 10ad8c32115b4d5d9ba9d9344e2a4918--b0a681f278ee44fbb3a82dfc701dc560 1358beb8cc0940a18b0989c6cedabff1 RX(theta\u2082\u2081) b0a681f278ee44fbb3a82dfc701dc560--1358beb8cc0940a18b0989c6cedabff1 5da257dc52a245bf8a3f810087c5c93d X 1358beb8cc0940a18b0989c6cedabff1--5da257dc52a245bf8a3f810087c5c93d 5da257dc52a245bf8a3f810087c5c93d--894154657d5544a49107edafbbcc73ef d0b85555cd6e40f1bd7592a50dc34ba4 5da257dc52a245bf8a3f810087c5c93d--d0b85555cd6e40f1bd7592a50dc34ba4 781f6ac9d4994c7f96023819af718331 RX(theta\u2081) d0b85555cd6e40f1bd7592a50dc34ba4--781f6ac9d4994c7f96023819af718331 44bcba8a6dfa4f1dbe047282db432c66 RY(theta\u2085) 781f6ac9d4994c7f96023819af718331--44bcba8a6dfa4f1dbe047282db432c66 d2eda8cbcffc431a8661348016c32bb9 RX(theta\u2089) 44bcba8a6dfa4f1dbe047282db432c66--d2eda8cbcffc431a8661348016c32bb9 ed9f55586a0d40b1ad7b97fb096e3d03 X d2eda8cbcffc431a8661348016c32bb9--ed9f55586a0d40b1ad7b97fb096e3d03 ed9f55586a0d40b1ad7b97fb096e3d03--e5d07ca278614b8e80bf4cbe9b2a6ad3 9d3a3324533b447ba155060e60705842 ed9f55586a0d40b1ad7b97fb096e3d03--9d3a3324533b447ba155060e60705842 91668df6d0d84fb8a90fc090de1c7bc3 RX(theta\u2081\u2083) 9d3a3324533b447ba155060e60705842--91668df6d0d84fb8a90fc090de1c7bc3 c3cfa35463c84c0e90decaa424f48859 RY(theta\u2081\u2087) 91668df6d0d84fb8a90fc090de1c7bc3--c3cfa35463c84c0e90decaa424f48859 bf50484ad04247f5be6f3d13b6892886 RX(theta\u2082\u2081) c3cfa35463c84c0e90decaa424f48859--bf50484ad04247f5be6f3d13b6892886 33f99d45fad24eb8a945d72d18a44bdd X bf50484ad04247f5be6f3d13b6892886--33f99d45fad24eb8a945d72d18a44bdd 33f99d45fad24eb8a945d72d18a44bdd--5104911badef4864bcbc744b3c94dad5 c2e0afa29b344ac3b706f6ed9c46e422 33f99d45fad24eb8a945d72d18a44bdd--c2e0afa29b344ac3b706f6ed9c46e422 c2e0afa29b344ac3b706f6ed9c46e422--e7645bb3c46e461abf64f876317f6258 26199b3e0caf449a90d5a5794a030f63 3697a1c9358540758cc0a35e5ce598e6 RX(theta\u2082) 29fd1190605a4e71a6877d36e868ea74--3697a1c9358540758cc0a35e5ce598e6 40587f754ab2462bbbc576489930af07 3 cfa88087e0b24d89baac6e2f9dfdfeae RY(theta\u2086) 3697a1c9358540758cc0a35e5ce598e6--cfa88087e0b24d89baac6e2f9dfdfeae 9e0fa0ee33b845179371615314a3b7bd RX(theta\u2081\u2080) cfa88087e0b24d89baac6e2f9dfdfeae--9e0fa0ee33b845179371615314a3b7bd d1e91ff48f9e477399909b5cd88ba5bd 9e0fa0ee33b845179371615314a3b7bd--d1e91ff48f9e477399909b5cd88ba5bd 276e6a33222847fd8921904c3d2052bb X d1e91ff48f9e477399909b5cd88ba5bd--276e6a33222847fd8921904c3d2052bb 276e6a33222847fd8921904c3d2052bb--053ffde2d6054b81a7a2ce4858872918 befd46a3df12465aa9ac2cf0b64c592f RX(theta\u2081\u2084) 276e6a33222847fd8921904c3d2052bb--befd46a3df12465aa9ac2cf0b64c592f d8460c6a48de4c2f88cda182ce6854a5 RY(theta\u2081\u2088) befd46a3df12465aa9ac2cf0b64c592f--d8460c6a48de4c2f88cda182ce6854a5 813dc23541114abbbfeab2421b14ba68 RX(theta\u2082\u2082) d8460c6a48de4c2f88cda182ce6854a5--813dc23541114abbbfeab2421b14ba68 fca3a83bf3604513849edad056067f92 813dc23541114abbbfeab2421b14ba68--fca3a83bf3604513849edad056067f92 a8654d15cae74608b7f5ea31ecd48a86 X fca3a83bf3604513849edad056067f92--a8654d15cae74608b7f5ea31ecd48a86 a8654d15cae74608b7f5ea31ecd48a86--d0b85555cd6e40f1bd7592a50dc34ba4 7c5769f957134b48a6b4937d1931e4ee RX(theta\u2082) a8654d15cae74608b7f5ea31ecd48a86--7c5769f957134b48a6b4937d1931e4ee 3bdc58bc88a8400db7843ef2c4720679 RY(theta\u2086) 7c5769f957134b48a6b4937d1931e4ee--3bdc58bc88a8400db7843ef2c4720679 662b8ea4c142456494800c4a48f7e09b RX(theta\u2081\u2080) 3bdc58bc88a8400db7843ef2c4720679--662b8ea4c142456494800c4a48f7e09b 797cea5e3498467a89b4003665cb5afd 662b8ea4c142456494800c4a48f7e09b--797cea5e3498467a89b4003665cb5afd 4ce8ba68ff1647f7a92cbbbb25f91271 X 797cea5e3498467a89b4003665cb5afd--4ce8ba68ff1647f7a92cbbbb25f91271 4ce8ba68ff1647f7a92cbbbb25f91271--9d3a3324533b447ba155060e60705842 3b21d64608824bfba6748d5ea0d928d6 RX(theta\u2081\u2084) 4ce8ba68ff1647f7a92cbbbb25f91271--3b21d64608824bfba6748d5ea0d928d6 436faa5b026848fa99cbd1877ca6e9ae RY(theta\u2081\u2088) 3b21d64608824bfba6748d5ea0d928d6--436faa5b026848fa99cbd1877ca6e9ae a30f7da10c1c4156a84c2cc9bed9ce11 RX(theta\u2082\u2082) 436faa5b026848fa99cbd1877ca6e9ae--a30f7da10c1c4156a84c2cc9bed9ce11 86e0a0e9fea5440ca1792857de165322 a30f7da10c1c4156a84c2cc9bed9ce11--86e0a0e9fea5440ca1792857de165322 daf58617207e42aa954e364765f9f194 X 86e0a0e9fea5440ca1792857de165322--daf58617207e42aa954e364765f9f194 daf58617207e42aa954e364765f9f194--c2e0afa29b344ac3b706f6ed9c46e422 daf58617207e42aa954e364765f9f194--26199b3e0caf449a90d5a5794a030f63 5c0a067240a64f36b38932955f3bd76c 799452197328428b8b733477b2d84ea7 RX(theta\u2083) 40587f754ab2462bbbc576489930af07--799452197328428b8b733477b2d84ea7 a84f6e01577b476aba0b1642b96f5747 RY(theta\u2087) 799452197328428b8b733477b2d84ea7--a84f6e01577b476aba0b1642b96f5747 e73ddc9a6da54e25a8f8edf6b5a1ff8b RX(theta\u2081\u2081) a84f6e01577b476aba0b1642b96f5747--e73ddc9a6da54e25a8f8edf6b5a1ff8b 9352560c4d1545a68460c8342c11fd74 X e73ddc9a6da54e25a8f8edf6b5a1ff8b--9352560c4d1545a68460c8342c11fd74 9352560c4d1545a68460c8342c11fd74--d1e91ff48f9e477399909b5cd88ba5bd 8c6da519a55f43fba0834cc8d341c7db 9352560c4d1545a68460c8342c11fd74--8c6da519a55f43fba0834cc8d341c7db 29f40e537f624121b7eb8231f8346468 RX(theta\u2081\u2085) 8c6da519a55f43fba0834cc8d341c7db--29f40e537f624121b7eb8231f8346468 bce443798dd64652bfc0f4abc55b2e19 RY(theta\u2081\u2089) 29f40e537f624121b7eb8231f8346468--bce443798dd64652bfc0f4abc55b2e19 3928c32cb6f4414b84611a6b5cb5d8f8 RX(theta\u2082\u2083) bce443798dd64652bfc0f4abc55b2e19--3928c32cb6f4414b84611a6b5cb5d8f8 fd755ec6614f4b83a6d73d65d360e8e7 X 3928c32cb6f4414b84611a6b5cb5d8f8--fd755ec6614f4b83a6d73d65d360e8e7 fd755ec6614f4b83a6d73d65d360e8e7--fca3a83bf3604513849edad056067f92 78506149ac8341799979114bee3106a5 fd755ec6614f4b83a6d73d65d360e8e7--78506149ac8341799979114bee3106a5 2bc35d00e2d844bb92f4809a4d01a62b RX(theta\u2083) 78506149ac8341799979114bee3106a5--2bc35d00e2d844bb92f4809a4d01a62b 931465c06a71403b90093a892a2e4cec RY(theta\u2087) 2bc35d00e2d844bb92f4809a4d01a62b--931465c06a71403b90093a892a2e4cec 88dc8133892f406ea2563af3c118ba7d RX(theta\u2081\u2081) 931465c06a71403b90093a892a2e4cec--88dc8133892f406ea2563af3c118ba7d 05f2c6047d464261865b6dc3ebda60b4 X 88dc8133892f406ea2563af3c118ba7d--05f2c6047d464261865b6dc3ebda60b4 05f2c6047d464261865b6dc3ebda60b4--797cea5e3498467a89b4003665cb5afd 7580b08245a24abe80793568acbe50ff 05f2c6047d464261865b6dc3ebda60b4--7580b08245a24abe80793568acbe50ff fd5e6a6dc02f4d96a31d91d84759676d RX(theta\u2081\u2085) 7580b08245a24abe80793568acbe50ff--fd5e6a6dc02f4d96a31d91d84759676d ac74afa502f344f08c923319bf6a94cb RY(theta\u2081\u2089) fd5e6a6dc02f4d96a31d91d84759676d--ac74afa502f344f08c923319bf6a94cb dac236d9ab1c42bdac14ce54d44bf93f RX(theta\u2082\u2083) ac74afa502f344f08c923319bf6a94cb--dac236d9ab1c42bdac14ce54d44bf93f c13b5cccb2ac4d56b83a4024f5558aa4 X dac236d9ab1c42bdac14ce54d44bf93f--c13b5cccb2ac4d56b83a4024f5558aa4 c13b5cccb2ac4d56b83a4024f5558aa4--86e0a0e9fea5440ca1792857de165322 bbbcfcf43a124c36829ab6b7046cf822 c13b5cccb2ac4d56b83a4024f5558aa4--bbbcfcf43a124c36829ab6b7046cf822 bbbcfcf43a124c36829ab6b7046cf822--5c0a067240a64f36b38932955f3bd76c </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_d705988408ad438697efe2a4f98450d1 HEA cluster_7dc06f89720b4a7f825f3d1879042380 HEA 53de1da1269240748744cc9aaf1e5a5c 0 83d64be6aac6420a8a3cfa1301cc1d20 RX(p1\u2080) 53de1da1269240748744cc9aaf1e5a5c--83d64be6aac6420a8a3cfa1301cc1d20 990035753009494b80bd5ee3834545bf 1 2c3d38bef4c94f5cad11fba865b3acf1 RY(p1\u2084) 83d64be6aac6420a8a3cfa1301cc1d20--2c3d38bef4c94f5cad11fba865b3acf1 ff70c07523fe480aa2f472608176d259 RX(p1\u2088) 2c3d38bef4c94f5cad11fba865b3acf1--ff70c07523fe480aa2f472608176d259 3014fb9501704e649fd34b93056f1de3 ff70c07523fe480aa2f472608176d259--3014fb9501704e649fd34b93056f1de3 c8170368a3c646418e8bf1287a6a0931 3014fb9501704e649fd34b93056f1de3--c8170368a3c646418e8bf1287a6a0931 eaa3d897527049058b0077e86ef545a4 RX(p1\u2081\u2082) c8170368a3c646418e8bf1287a6a0931--eaa3d897527049058b0077e86ef545a4 5fd600930f2d48b4974545666e799e90 RY(p1\u2081\u2086) eaa3d897527049058b0077e86ef545a4--5fd600930f2d48b4974545666e799e90 f99423760a064bd395624d2367432a77 RX(p1\u2082\u2080) 5fd600930f2d48b4974545666e799e90--f99423760a064bd395624d2367432a77 be711a1510d543fd8ddbaeaeadb51c9d f99423760a064bd395624d2367432a77--be711a1510d543fd8ddbaeaeadb51c9d e937920ee2e243c582d5c67b232a2a61 be711a1510d543fd8ddbaeaeadb51c9d--e937920ee2e243c582d5c67b232a2a61 679a34db5a5945b694b78c94a9d5c483 RX(p2\u2080) e937920ee2e243c582d5c67b232a2a61--679a34db5a5945b694b78c94a9d5c483 980dc687d98f4277b60218cfae4a8504 RY(p2\u2084) 679a34db5a5945b694b78c94a9d5c483--980dc687d98f4277b60218cfae4a8504 4cfa707877484b9781a351eb4bf2cf54 RX(p2\u2088) 980dc687d98f4277b60218cfae4a8504--4cfa707877484b9781a351eb4bf2cf54 98edb9a303ab418faafd3b682c25123d 4cfa707877484b9781a351eb4bf2cf54--98edb9a303ab418faafd3b682c25123d 5870f82f82ae49ada66566620b4eee99 98edb9a303ab418faafd3b682c25123d--5870f82f82ae49ada66566620b4eee99 de4e00c647ab4a408b89bb76c595694d RX(p2\u2081\u2082) 5870f82f82ae49ada66566620b4eee99--de4e00c647ab4a408b89bb76c595694d 7809620c9d66466eb07a30d28fba970e RY(p2\u2081\u2086) de4e00c647ab4a408b89bb76c595694d--7809620c9d66466eb07a30d28fba970e cef268b7224148b5b1c43c78e9f2d5fb RX(p2\u2082\u2080) 7809620c9d66466eb07a30d28fba970e--cef268b7224148b5b1c43c78e9f2d5fb e7030ee3fca744e6b557b292ff953057 cef268b7224148b5b1c43c78e9f2d5fb--e7030ee3fca744e6b557b292ff953057 2d7da5b383194629bf2aaf7c834e8e18 e7030ee3fca744e6b557b292ff953057--2d7da5b383194629bf2aaf7c834e8e18 34ba76c6547142f080fd5648ef8fcedb 2d7da5b383194629bf2aaf7c834e8e18--34ba76c6547142f080fd5648ef8fcedb c908d82195544a4b8fa9862d2bcf0280 d1bd7a52039e437f91c290453216efaf RX(p1\u2081) 990035753009494b80bd5ee3834545bf--d1bd7a52039e437f91c290453216efaf 96da39d9f03b4d6b99ec132f693cebc5 2 56203d9af36b4af59d2cbf0eba59cca5 RY(p1\u2085) d1bd7a52039e437f91c290453216efaf--56203d9af36b4af59d2cbf0eba59cca5 bcc2c06d3b1f4efd9c712ae010f05a8e RX(p1\u2089) 56203d9af36b4af59d2cbf0eba59cca5--bcc2c06d3b1f4efd9c712ae010f05a8e 0bc5fc13706c45c5a903486fa8bafd4f X bcc2c06d3b1f4efd9c712ae010f05a8e--0bc5fc13706c45c5a903486fa8bafd4f 0bc5fc13706c45c5a903486fa8bafd4f--3014fb9501704e649fd34b93056f1de3 35df7d6996954ffe8619feed49c06ae9 0bc5fc13706c45c5a903486fa8bafd4f--35df7d6996954ffe8619feed49c06ae9 b00abe27d6a1440a8ab9347a92a75cb0 RX(p1\u2081\u2083) 35df7d6996954ffe8619feed49c06ae9--b00abe27d6a1440a8ab9347a92a75cb0 4e2c98b32219434985a8d9b0ae305dbd RY(p1\u2081\u2087) b00abe27d6a1440a8ab9347a92a75cb0--4e2c98b32219434985a8d9b0ae305dbd 4cbe319c97e242c0878cfc17f458b6f2 RX(p1\u2082\u2081) 4e2c98b32219434985a8d9b0ae305dbd--4cbe319c97e242c0878cfc17f458b6f2 dbb9850ec93749fe8da6b6d199bd8018 X 4cbe319c97e242c0878cfc17f458b6f2--dbb9850ec93749fe8da6b6d199bd8018 dbb9850ec93749fe8da6b6d199bd8018--be711a1510d543fd8ddbaeaeadb51c9d d2c12187653b4eb69bcbe00fe85d5877 dbb9850ec93749fe8da6b6d199bd8018--d2c12187653b4eb69bcbe00fe85d5877 a1bc8593842549a688bcb3006ab3d15f RX(p2\u2081) d2c12187653b4eb69bcbe00fe85d5877--a1bc8593842549a688bcb3006ab3d15f 17657c20bd8e4146a19d0ed1295df45f RY(p2\u2085) a1bc8593842549a688bcb3006ab3d15f--17657c20bd8e4146a19d0ed1295df45f e397e6a03c83442ab777804c5375252b RX(p2\u2089) 17657c20bd8e4146a19d0ed1295df45f--e397e6a03c83442ab777804c5375252b b5be67d36dc3461a865671d0edb54de4 X e397e6a03c83442ab777804c5375252b--b5be67d36dc3461a865671d0edb54de4 b5be67d36dc3461a865671d0edb54de4--98edb9a303ab418faafd3b682c25123d 214e060b03f64f3b8abd2f4df926ab94 b5be67d36dc3461a865671d0edb54de4--214e060b03f64f3b8abd2f4df926ab94 050497798dc3416799b6c42e135a2961 RX(p2\u2081\u2083) 214e060b03f64f3b8abd2f4df926ab94--050497798dc3416799b6c42e135a2961 318cf5acb96a44b89e07bbae3b0f279b RY(p2\u2081\u2087) 050497798dc3416799b6c42e135a2961--318cf5acb96a44b89e07bbae3b0f279b 0a968f5bd2f242d48098e6e27de1fddf RX(p2\u2082\u2081) 318cf5acb96a44b89e07bbae3b0f279b--0a968f5bd2f242d48098e6e27de1fddf b659000d3a3b46f9841b0a033af47adc X 0a968f5bd2f242d48098e6e27de1fddf--b659000d3a3b46f9841b0a033af47adc b659000d3a3b46f9841b0a033af47adc--e7030ee3fca744e6b557b292ff953057 bad1e32d17f84aa28dd660d83e36bd40 b659000d3a3b46f9841b0a033af47adc--bad1e32d17f84aa28dd660d83e36bd40 bad1e32d17f84aa28dd660d83e36bd40--c908d82195544a4b8fa9862d2bcf0280 593858f1e5664d7eae7fac448adbb6e0 7276478bee364ecbb083dc818c94619f RX(p1\u2082) 96da39d9f03b4d6b99ec132f693cebc5--7276478bee364ecbb083dc818c94619f a5b2cf0c583c45a693eb9c17560b9140 3 ff846ce39e0c44618413c6684e2ad411 RY(p1\u2086) 7276478bee364ecbb083dc818c94619f--ff846ce39e0c44618413c6684e2ad411 0a932be724724fbbb6a6c6673d6b3fcf RX(p1\u2081\u2080) ff846ce39e0c44618413c6684e2ad411--0a932be724724fbbb6a6c6673d6b3fcf a822e971b488436b88849a128d2136d7 0a932be724724fbbb6a6c6673d6b3fcf--a822e971b488436b88849a128d2136d7 f62fc79b0ff04dcb9091bcc71475d09e X a822e971b488436b88849a128d2136d7--f62fc79b0ff04dcb9091bcc71475d09e f62fc79b0ff04dcb9091bcc71475d09e--35df7d6996954ffe8619feed49c06ae9 77957b54430345eb97e43f7998d4489a RX(p1\u2081\u2084) f62fc79b0ff04dcb9091bcc71475d09e--77957b54430345eb97e43f7998d4489a 1ab3ddd3cfde4fb192bf88ad592ec1fb RY(p1\u2081\u2088) 77957b54430345eb97e43f7998d4489a--1ab3ddd3cfde4fb192bf88ad592ec1fb 16e915536ab74f2aa7a5912068b4499f RX(p1\u2082\u2082) 1ab3ddd3cfde4fb192bf88ad592ec1fb--16e915536ab74f2aa7a5912068b4499f 6b175c0cdfad4981a4b29609cfb0494c 16e915536ab74f2aa7a5912068b4499f--6b175c0cdfad4981a4b29609cfb0494c 5e036d71ac4041b0af3a4cd31d075cc0 X 6b175c0cdfad4981a4b29609cfb0494c--5e036d71ac4041b0af3a4cd31d075cc0 5e036d71ac4041b0af3a4cd31d075cc0--d2c12187653b4eb69bcbe00fe85d5877 bc44774c3d0f48c9b3e6ba84ade1716f RX(p2\u2082) 5e036d71ac4041b0af3a4cd31d075cc0--bc44774c3d0f48c9b3e6ba84ade1716f ab439dc2062849f4a39879759b1a9b99 RY(p2\u2086) bc44774c3d0f48c9b3e6ba84ade1716f--ab439dc2062849f4a39879759b1a9b99 fa86dba2669b46499d9c7106d0e6ad22 RX(p2\u2081\u2080) ab439dc2062849f4a39879759b1a9b99--fa86dba2669b46499d9c7106d0e6ad22 5af11aaf155a4a7bafad4f1f53d27801 fa86dba2669b46499d9c7106d0e6ad22--5af11aaf155a4a7bafad4f1f53d27801 4e1d010246ee48acabf81eae363ec055 X 5af11aaf155a4a7bafad4f1f53d27801--4e1d010246ee48acabf81eae363ec055 4e1d010246ee48acabf81eae363ec055--214e060b03f64f3b8abd2f4df926ab94 d160211e15a54bd6a000073af1d2c5ea RX(p2\u2081\u2084) 4e1d010246ee48acabf81eae363ec055--d160211e15a54bd6a000073af1d2c5ea c484bae75fde4b008a8cf120c7c4a5bb RY(p2\u2081\u2088) d160211e15a54bd6a000073af1d2c5ea--c484bae75fde4b008a8cf120c7c4a5bb f956c42d8dc8450a9b4152e554f4bf45 RX(p2\u2082\u2082) c484bae75fde4b008a8cf120c7c4a5bb--f956c42d8dc8450a9b4152e554f4bf45 2084db3040c049f492c223e5064b75cc f956c42d8dc8450a9b4152e554f4bf45--2084db3040c049f492c223e5064b75cc f9774b1c0a4149c3afac2604b48bf45e X 2084db3040c049f492c223e5064b75cc--f9774b1c0a4149c3afac2604b48bf45e f9774b1c0a4149c3afac2604b48bf45e--bad1e32d17f84aa28dd660d83e36bd40 f9774b1c0a4149c3afac2604b48bf45e--593858f1e5664d7eae7fac448adbb6e0 b329f1e65d1a4630ada4d1a484083cb1 dc360531ecd0433ba081aad86b816a1d RX(p1\u2083) a5b2cf0c583c45a693eb9c17560b9140--dc360531ecd0433ba081aad86b816a1d e7c07c196102410a99a322ca335a3fe6 RY(p1\u2087) dc360531ecd0433ba081aad86b816a1d--e7c07c196102410a99a322ca335a3fe6 5c64ed0efd684d3786554fedbc13d397 RX(p1\u2081\u2081) e7c07c196102410a99a322ca335a3fe6--5c64ed0efd684d3786554fedbc13d397 5b44a48682b5490d9156cec34b5abffb X 5c64ed0efd684d3786554fedbc13d397--5b44a48682b5490d9156cec34b5abffb 5b44a48682b5490d9156cec34b5abffb--a822e971b488436b88849a128d2136d7 618ed30e9643426cb6220aa99cd224de 5b44a48682b5490d9156cec34b5abffb--618ed30e9643426cb6220aa99cd224de 099963bcbb7b4c14b4098e2ec15824b8 RX(p1\u2081\u2085) 618ed30e9643426cb6220aa99cd224de--099963bcbb7b4c14b4098e2ec15824b8 fb94e29732464fec95c9f6a675bf359d RY(p1\u2081\u2089) 099963bcbb7b4c14b4098e2ec15824b8--fb94e29732464fec95c9f6a675bf359d e07b82b492a84b7db85fd9a7c431028d RX(p1\u2082\u2083) fb94e29732464fec95c9f6a675bf359d--e07b82b492a84b7db85fd9a7c431028d 06dff2aaca4e4960900389b7fe29a752 X e07b82b492a84b7db85fd9a7c431028d--06dff2aaca4e4960900389b7fe29a752 06dff2aaca4e4960900389b7fe29a752--6b175c0cdfad4981a4b29609cfb0494c fb0e4b72089d46cd8516ee88f6ef6f18 06dff2aaca4e4960900389b7fe29a752--fb0e4b72089d46cd8516ee88f6ef6f18 3e90fbf07085493ebe968f7a95e8023a RX(p2\u2083) fb0e4b72089d46cd8516ee88f6ef6f18--3e90fbf07085493ebe968f7a95e8023a b947a3d533bd4308aed64d1e840e8674 RY(p2\u2087) 3e90fbf07085493ebe968f7a95e8023a--b947a3d533bd4308aed64d1e840e8674 3c24680c47824c3cb0463cd7a2c0b007 RX(p2\u2081\u2081) b947a3d533bd4308aed64d1e840e8674--3c24680c47824c3cb0463cd7a2c0b007 4ed095f553cf41b58a61710beb7fc171 X 3c24680c47824c3cb0463cd7a2c0b007--4ed095f553cf41b58a61710beb7fc171 4ed095f553cf41b58a61710beb7fc171--5af11aaf155a4a7bafad4f1f53d27801 b9ecccec0faa4b51b140c62e56a1b516 4ed095f553cf41b58a61710beb7fc171--b9ecccec0faa4b51b140c62e56a1b516 8311729a3c4e4f558a9d2b2de54c2db0 RX(p2\u2081\u2085) b9ecccec0faa4b51b140c62e56a1b516--8311729a3c4e4f558a9d2b2de54c2db0 5b75fe332e55486e80134c1168f684e5 RY(p2\u2081\u2089) 8311729a3c4e4f558a9d2b2de54c2db0--5b75fe332e55486e80134c1168f684e5 059565824cd24dc0ab43b3a1d605e842 RX(p2\u2082\u2083) 5b75fe332e55486e80134c1168f684e5--059565824cd24dc0ab43b3a1d605e842 18e0a2509b6f42a5887e94c1374e5285 X 059565824cd24dc0ab43b3a1d605e842--18e0a2509b6f42a5887e94c1374e5285 18e0a2509b6f42a5887e94c1374e5285--2084db3040c049f492c223e5064b75cc 010d38d7dce84ba5982a23f401e09888 18e0a2509b6f42a5887e94c1374e5285--010d38d7dce84ba5982a23f401e09888 010d38d7dce84ba5982a23f401e09888--b329f1e65d1a4630ada4d1a484083cb1 </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6723])), ('theta_0', tensor([0.1476])), ('theta_1', tensor([0.6309])), ('theta_10', tensor([0.8657])), ('theta_11', tensor([0.8418])), ('theta_12', tensor([0.1063])), ('theta_13', tensor([0.6077])), ('theta_14', tensor([0.8846])), ('theta_15', tensor([0.9668])), ('theta_16', tensor([0.2565])), ('theta_17', tensor([0.1043])), ('theta_18', tensor([0.9783])), ('theta_19', tensor([0.0618])), ('theta_2', tensor([0.1834])), ('theta_20', tensor([0.4442])), ('theta_21', tensor([0.6389])), ('theta_22', tensor([0.6250])), ('theta_23', tensor([0.5487])), ('theta_3', tensor([0.8038])), ('theta_4', tensor([0.9408])), ('theta_5', tensor([0.4441])), ('theta_6', tensor([0.6926])), ('theta_7', tensor([0.3457])), ('theta_8', tensor([0.6128])), ('theta_9', tensor([0.6174]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.6713])), ('theta_0', tensor([0.1486])), ('theta_1', tensor([0.6319])), ('theta_10', tensor([0.8667])), ('theta_11', tensor([0.8428])), ('theta_12', tensor([0.1073])), ('theta_13', tensor([0.6067])), ('theta_14', tensor([0.8856])), ('theta_15', tensor([0.9678])), ('theta_16', tensor([0.2575])), ('theta_17', tensor([0.1033])), ('theta_18', tensor([0.9773])), ('theta_19', tensor([0.0608])), ('theta_2', tensor([0.1844])), ('theta_20', tensor([0.4452])), ('theta_21', tensor([0.6379])), ('theta_22', tensor([0.6260])), ('theta_23', tensor([0.5497])), ('theta_3', tensor([0.8048])), ('theta_4', tensor([0.9418])), ('theta_5', tensor([0.4451])), ('theta_6', tensor([0.6936])), ('theta_7', tensor([0.3467])), ('theta_8', tensor([0.6138])), ('theta_9', tensor([0.6184]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9986+0.0000j,  0.0000-0.0369j,  0.0000-0.0369j, -0.0014+0.0000j],\n        [ 0.9556+0.0000j,  0.0000-0.2059j,  0.0000-0.2059j, -0.0444+0.0000j],\n        [ 0.9810+0.0000j,  0.0000-0.1367j,  0.0000-0.1367j, -0.0190+0.0000j]])\nxs = [Counter({'00': 99, '10': 1}), Counter({'00': 86, '01': 8, '10': 6}), Counter({'00': 95, '01': 4, '10': 1})]\nex = tensor([[0.9973],\n        [0.9113],\n        [0.9619]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9973, 0.9973],\n        [0.9113, 0.9113],\n        [0.9619, 0.9619]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2023-12-12T14:24:55.166994 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*np.pi, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2023-12-12T14:24:55.502421 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'01': 52, '00': 48})]\nSample in little endian = [Counter({'10': 52, '00': 48})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'10': 52, '00': 48})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample\nimport torch\n\n# RX(pi/4) on qubit 1\nn_qubits = 2\nop = RX(1, torch.pi/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 88, '01': 12})]\nOn Braket = [Counter({'00': 87, '01': 13})]\nOn Pulser = [Counter({'00': 89, '01': 11})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [0.71347553-0.58459751j 0.        +0.j         0.29877691-0.24480761j\n 0.        +0.j        ]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_47cd3c7fcacb4ae48e7427389cd3def6 Circuit block cluster_cbc479d0ea4443d4bb04808fff2b2dec Prep block 708fce5cbc5a4871ac3c815852f91261 0 bd0050a1457542fe80b70cfe6184d04c 708fce5cbc5a4871ac3c815852f91261--bd0050a1457542fe80b70cfe6184d04c 1fe996c41c214730b1362a51b6ed2762 1 d24a18af2c2c4225be7db3bd32d8e2c7 RX(theta\u2080) bd0050a1457542fe80b70cfe6184d04c--d24a18af2c2c4225be7db3bd32d8e2c7 249d380cc0754c38a8baf5137b2cf566 RY(theta\u2084) d24a18af2c2c4225be7db3bd32d8e2c7--249d380cc0754c38a8baf5137b2cf566 e8a2a9ecd385428d91f43a5f59b0a669 RX(theta\u2088) 249d380cc0754c38a8baf5137b2cf566--e8a2a9ecd385428d91f43a5f59b0a669 769d3b08447a43ac9c15edd523fe0afb e8a2a9ecd385428d91f43a5f59b0a669--769d3b08447a43ac9c15edd523fe0afb 5710f59e881a432fa85c7cf16e5df0c4 769d3b08447a43ac9c15edd523fe0afb--5710f59e881a432fa85c7cf16e5df0c4 b61529445e5245c1af744c31bca65007 RX(theta\u2081\u2082) 5710f59e881a432fa85c7cf16e5df0c4--b61529445e5245c1af744c31bca65007 54ba1f96088d49d2894c520aca38336e RY(theta\u2081\u2086) b61529445e5245c1af744c31bca65007--54ba1f96088d49d2894c520aca38336e 8bce27203a4f47f2b56156877c5e102f RX(theta\u2082\u2080) 54ba1f96088d49d2894c520aca38336e--8bce27203a4f47f2b56156877c5e102f 69ce68e9954349cdb7b7349147f1939d 8bce27203a4f47f2b56156877c5e102f--69ce68e9954349cdb7b7349147f1939d d106d71dd0824d449cd875f0427812db 69ce68e9954349cdb7b7349147f1939d--d106d71dd0824d449cd875f0427812db ef47da833443470c885aefd4faa0ca9a d106d71dd0824d449cd875f0427812db--ef47da833443470c885aefd4faa0ca9a d3b9e97f30594023903b02ec6619bc78 759d29cec9394cada2d63de1ae1c4797 1fe996c41c214730b1362a51b6ed2762--759d29cec9394cada2d63de1ae1c4797 04fa3c9469f84395847cd0dcceb63eab 2 7e1a8d0dc23240f384f83b0b16eee13d RX(theta\u2081) 759d29cec9394cada2d63de1ae1c4797--7e1a8d0dc23240f384f83b0b16eee13d 32711a67f2de48a6b1dee820489b80ec RY(theta\u2085) 7e1a8d0dc23240f384f83b0b16eee13d--32711a67f2de48a6b1dee820489b80ec 4d2e3eab95bc4119a29ac0289ee60996 RX(theta\u2089) 32711a67f2de48a6b1dee820489b80ec--4d2e3eab95bc4119a29ac0289ee60996 0c3122669dd84092b8b38881e5717ce7 X 4d2e3eab95bc4119a29ac0289ee60996--0c3122669dd84092b8b38881e5717ce7 0c3122669dd84092b8b38881e5717ce7--769d3b08447a43ac9c15edd523fe0afb 0fbf9e41e03348d78652e286f7bfae37 0c3122669dd84092b8b38881e5717ce7--0fbf9e41e03348d78652e286f7bfae37 bd46e2a2f7764579944376d7d58181b3 RX(theta\u2081\u2083) 0fbf9e41e03348d78652e286f7bfae37--bd46e2a2f7764579944376d7d58181b3 38e3e13148ce469582610931405124e5 RY(theta\u2081\u2087) bd46e2a2f7764579944376d7d58181b3--38e3e13148ce469582610931405124e5 492ca8df17774cb5ba91452c5f1ed3b7 RX(theta\u2082\u2081) 38e3e13148ce469582610931405124e5--492ca8df17774cb5ba91452c5f1ed3b7 fd98e1791c6141a6a6059cb17c36b3b2 X 492ca8df17774cb5ba91452c5f1ed3b7--fd98e1791c6141a6a6059cb17c36b3b2 fd98e1791c6141a6a6059cb17c36b3b2--69ce68e9954349cdb7b7349147f1939d d13a90009bd34210a7f8486aec101c9a fd98e1791c6141a6a6059cb17c36b3b2--d13a90009bd34210a7f8486aec101c9a d13a90009bd34210a7f8486aec101c9a--d3b9e97f30594023903b02ec6619bc78 018e6d7ebf4c4dbb9f015d707600512d 94cc3f73a32941b395854d72c2f94157 04fa3c9469f84395847cd0dcceb63eab--94cc3f73a32941b395854d72c2f94157 a12d4805c9c14f1cbf7f8b7ec466b973 3 553f111c5e9544e1a0fb10a49a4bfe00 RX(theta\u2082) 94cc3f73a32941b395854d72c2f94157--553f111c5e9544e1a0fb10a49a4bfe00 52911733ae6f43029e71041d064542b3 RY(theta\u2086) 553f111c5e9544e1a0fb10a49a4bfe00--52911733ae6f43029e71041d064542b3 0ceba898d4fa419fa8d55b8c90aa8376 RX(theta\u2081\u2080) 52911733ae6f43029e71041d064542b3--0ceba898d4fa419fa8d55b8c90aa8376 00a3642d290047daa2edd23f323036b1 0ceba898d4fa419fa8d55b8c90aa8376--00a3642d290047daa2edd23f323036b1 dd0dabacc9c143a08cc822159e2b1969 X 00a3642d290047daa2edd23f323036b1--dd0dabacc9c143a08cc822159e2b1969 dd0dabacc9c143a08cc822159e2b1969--0fbf9e41e03348d78652e286f7bfae37 95a3ef89cba048eaaaa902012a10cbf2 RX(theta\u2081\u2084) dd0dabacc9c143a08cc822159e2b1969--95a3ef89cba048eaaaa902012a10cbf2 273f986544b445e48aa6206c845b01ec RY(theta\u2081\u2088) 95a3ef89cba048eaaaa902012a10cbf2--273f986544b445e48aa6206c845b01ec 6f7cc16f064e4c2e8fe76063aa537831 RX(theta\u2082\u2082) 273f986544b445e48aa6206c845b01ec--6f7cc16f064e4c2e8fe76063aa537831 a9ae34712048490fa8f0d6aecac6b499 6f7cc16f064e4c2e8fe76063aa537831--a9ae34712048490fa8f0d6aecac6b499 1f1eb1dc9f1943a6b909f6a1ddd9dc87 X a9ae34712048490fa8f0d6aecac6b499--1f1eb1dc9f1943a6b909f6a1ddd9dc87 1f1eb1dc9f1943a6b909f6a1ddd9dc87--d13a90009bd34210a7f8486aec101c9a 1f1eb1dc9f1943a6b909f6a1ddd9dc87--018e6d7ebf4c4dbb9f015d707600512d 3b8135f367444fe0bc0e16ec877e0a3b 27514f51de4448728701728f7500dfb0 X a12d4805c9c14f1cbf7f8b7ec466b973--27514f51de4448728701728f7500dfb0 b8e0e70b8ba5485ea11f9b41e8afcc5e RX(theta\u2083) 27514f51de4448728701728f7500dfb0--b8e0e70b8ba5485ea11f9b41e8afcc5e adf8bdfdf215484f8f1e8cb0b24f7e1f RY(theta\u2087) b8e0e70b8ba5485ea11f9b41e8afcc5e--adf8bdfdf215484f8f1e8cb0b24f7e1f e49b3f85038a4a96988bfb01679415f3 RX(theta\u2081\u2081) adf8bdfdf215484f8f1e8cb0b24f7e1f--e49b3f85038a4a96988bfb01679415f3 c0b3f8fb30a54fb6b89935fcea3bd4ef X e49b3f85038a4a96988bfb01679415f3--c0b3f8fb30a54fb6b89935fcea3bd4ef c0b3f8fb30a54fb6b89935fcea3bd4ef--00a3642d290047daa2edd23f323036b1 47d63a05b9cb480c88eb770df1fccd58 c0b3f8fb30a54fb6b89935fcea3bd4ef--47d63a05b9cb480c88eb770df1fccd58 69a77766d19e49e79b9eadc8282cb3be RX(theta\u2081\u2085) 47d63a05b9cb480c88eb770df1fccd58--69a77766d19e49e79b9eadc8282cb3be 1a6723c0b2fe452eabfa378fc5f82b9d RY(theta\u2081\u2089) 69a77766d19e49e79b9eadc8282cb3be--1a6723c0b2fe452eabfa378fc5f82b9d aac5bd1d880e48aeabc614073a90e661 RX(theta\u2082\u2083) 1a6723c0b2fe452eabfa378fc5f82b9d--aac5bd1d880e48aeabc614073a90e661 ae02238819984f62bb885c2f685f317e X aac5bd1d880e48aeabc614073a90e661--ae02238819984f62bb885c2f685f317e ae02238819984f62bb885c2f685f317e--a9ae34712048490fa8f0d6aecac6b499 808ef8bfe0104fbb820c4bb9c8d704e2 ae02238819984f62bb885c2f685f317e--808ef8bfe0104fbb820c4bb9c8d704e2 808ef8bfe0104fbb820c4bb9c8d704e2--3b8135f367444fe0bc0e16ec877e0a3b  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[ 0.2561-0.1032j,  0.0494+0.0587j,  0.3258+0.1880j,  0.2518-0.0606j,\n         -0.3047-0.3365j, -0.0829+0.4560j,  0.2562+0.1226j, -0.1817+0.4180j],\n        [ 0.3139+0.4935j, -0.2357+0.3002j,  0.4257+0.0696j,  0.0326+0.0448j,\n          0.1226-0.1125j, -0.2873+0.1443j, -0.1797-0.3972j, -0.0041-0.0452j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}