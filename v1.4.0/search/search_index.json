{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qadence","text":"<p>For a high-level overview of Qadence features, check out our white paper.</p> <p>Qadence is a Python package that provides a simple interface to build digital-analog quantum programs with tunable qubit interaction defined on arbitrary register topologies realizable on neutral atom devices.</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li> <p>A block-based system for composing complex digital-analog   programs in a flexible and scalable manner, inspired by the Julia quantum SDK   Yao.jl and functional programming concepts.</p> </li> <li> <p>A simple interface to work with interacting neutral-atom qubit systems   using arbitrary registers topologies.</p> </li> <li> <p>An intuitive expression-based system developed on top of the symbolic library Sympy to construct parametric quantum programs easily.</p> </li> <li> <p>High-order generalized parameter shift rules for differentiating parametrized quantum operations.</p> </li> <li> <p>Out-of-the-box automatic differentiability of quantum programs with PyTorch integration.</p> </li> <li> <p>Efficient execution on a variety of different purpose backends: from state vector simulators to tensor network emulators and real devices.</p> </li> </ul> <p>In following are some examples of Qadence possibilites in the analog, digital-analog and digital paradigms.</p>"},{"location":"#analog-emulation-of-a-perfect-state-transfer","title":"Analog emulation of a perfect state transfer","text":"<p>This next example showcases the construction and sampling of a system that admits a perfect state transfer between the two edge qubits of a three qubit register laid out in a line. This relies on time-evolving a Hamiltonian for a custom defined qubit interaction until \\(t=\\frac{\\pi}{\\sqrt 2}\\).</p> <pre><code>from qadence import X, Y, HamEvo, Register, product_state, sample, add, PI\n\n# Define the qubit-qubit interaction term.\ndef interaction(i, j):\n    return 0.5 * (X(i) @ X(j) + Y(i) @ Y(j))  # Compose gates in parallel and sum their contribution.\n\n# Initial state with left-most qubit in the 1 state.\ninit_state = product_state(\"100\")\n\n# Define a register of 3 qubits laid out in a line.\nregister = Register.line(n_qubits=3)\n\n# Define an interaction Hamiltonian by summing interactions on indexed qubits.\n# hamiltonian = interaction(0, 1) + interaction(1, 2)\nhamiltonian = add(interaction(*edge) for edge in register.edges)\n\n# Define and time-evolve the Hamiltonian until t=pi/sqrt(2).\nt = PI / (2**0.5)  # Dimensionless.\nevolution = HamEvo(hamiltonian, t)\n\n# Sample with 100 shots.\nsamples = sample(register, evolution, state=init_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'001': 100})]\n</code></pre>"},{"location":"#digital-analog-example","title":"Digital-analog example","text":"<p>This final example deals with the construction and sampling of an Ising Hamiltonian that includes a distance-based interaction between qubits and a global analog block of rotations around the \\(X\\)-axis. Here, global has to be understood as applied to the whole register for qubits.</p> <pre><code>from qadence import Register, AnalogRX, sample, PI\n\n# Global analog RX block.\nblock = AnalogRX(PI)\n\n# Almost non-interacting qubits as too far apart.\nregister = Register.from_coordinates([(0,0), (0,15)])\nsamples = sample(register, block)\n\n# Interacting qubits are close to each other.\nregister = Register.from_coordinates([(0,0), (0,5)])\nsamples = sample(register, AnalogRX(PI))\n</code></pre> <pre><code>distance = 15: samples = [Counter({'11': 100})]\ndistance =  5: samples = [Counter({'01': 41, '00': 30, '10': 29})]\n</code></pre>"},{"location":"#sampling-the-canonical-bell-state","title":"Sampling the canonical Bell state","text":"<p>This example illustrates how to prepare a Bell state using digital gates and sampling from the outcome bitstring distribution:</p> <pre><code>from qadence import CNOT, H, chain, sample\n\n# Preparing a Bell state by composing a Hadamard and CNOT gates in sequence.\nbell_state = chain(H(0), CNOT(0,1))\n\n# Sample with 100 shots.\nsamples = sample(bell_state, n_shots=100)\n</code></pre> <pre><code>samples = [Counter({'00': 53, '11': 47})]\n</code></pre>"},{"location":"#further-resources","title":"Further resources","text":"<p>For a more comprehensive introduction and advanced topics, please have a look at the following tutorials:</p> <ul> <li>Quantum state conventions used throughout Qadence.</li> <li>Basic tutorials for first hands-on.</li> <li>Digital-analog basics to build quantum programs in the digital-analog paradigm.</li> <li>Parametric quantum circuits for the generation and manipulation of parametric programs.</li> <li>Advanced features about low-level backend interface and differentiablity.</li> <li><code>QuantumModel</code> for defining custom models.</li> </ul>"},{"location":"#installation-guide","title":"Installation guide","text":"<p>Qadence can be installed from PyPI with <code>pip</code> as follows:</p> <pre><code>pip install qadence\n</code></pre> <p>The default backend for Qadence is PyQTorch, a differentiable state vector simulator for digital-analog simulation. It is possible to install additional backends and the circuit visualization library using the following extras:</p> <ul> <li><code>braket</code>: the Braket backend.</li> <li><code>pulser</code>: the Pulser backend for composing, simulating and executing pulse sequences for neutral-atom quantum devices.</li> <li><code>visualization</code>: to display diagrammatically quantum circuits.</li> </ul> <p>To just get qadence with the <code>pyqtorch</code> backend, simply run:</p> <pre><code>pip install qadence\n</code></pre> <p>To install other backends or the visualization tool, please use:</p> <pre><code>pip install \"qadence[braket,pulser,visualization]\"\n</code></pre> <p>Warning</p> <p>In order to correctly install the <code>visualization</code> extra, the <code>graphviz</code> package needs to be installed in your system:</p> <pre><code># on Ubuntu\nsudo apt install graphviz\n\n# on MacOS\nbrew install graphviz\n\n# via conda\nconda install python-graphviz\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>We recommend to use the <code>hatch</code> environment manager to install <code>qadence</code> from source:</p> <pre><code>python -m pip install hatch\n\n# get into a shell with all the dependencies\npython -m hatch shell\n\n# run a command within the virtual environment with all the dependencies\npython -m hatch run python my_script.py\n</code></pre> <p>Warning</p> <p><code>hatch</code> will not combine nicely with other environment managers such Conda. If you want to use Conda, install it from source using <code>pip</code>:</p> <pre><code># within the Conda environment\npython -m pip install -e .\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use Qadence for a publication, we kindly ask you to cite our work using the following BibTex entry:</p> <pre><code>@article{qadence2024pasqal,\n  title = {Qadence: a differentiable interface for digital-analog programs.},\n  author={Dominik Seitz and Niklas Heim and Jo\u00e3o P. Moutinho and Roland Guichard and Vytautas Abramavicius and Aleksander Wennersteen and Gert-Jan Both and Anton Quelle and Caroline de Groot and Gergana V. Velikova and Vincent E. Elfving and Mario Dagrada},\n  journal={arXiv:2401.09915},\n  url = {https://github.com/pasqal-io/qadence},\n  year = {2024}\n}\n</code></pre>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>We're grateful for your interest in participating in Qadence. Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an issue or proposing a feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to qadence, feel free to create an issue on qadence's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a pull request","text":"<p>We're excited that you're eager to contribute to Qadence. To contribute, fork the <code>main</code> branch of qadence repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/qadence</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/qadence.git\n</code></pre> <p>Next, navigate to your new qadence fork directory and mark the main qadence repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/qadence.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within qadence, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run qadence tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful things for your workflow: linting and testing","text":"<p>Use <code>pre-commit</code> to lint your code and run the unit tests before pushing a new commit.</p> <p>Using <code>hatch</code>, it's simply:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Our CI/CD pipeline will also test if the documentation can be built correctly. To test it locally, please run:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"},{"location":"models/","title":"Quantum models","text":""},{"location":"models/#qadence.models.quantum_model.QuantumModel","title":"<code>QuantumModel(circuit, observable=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, mitigation=None, configuration=None)</code>","text":"<p>             Bases: <code>Module</code></p> <p>The central class of qadence that executes <code>QuantumCircuit</code>s and make them differentiable.</p> <p>This class should be used as base class for any new quantum model supported in the qadence framework for information on the implementation of custom models see here.</p> <p>Initialize a generic QuantumModel instance.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The circuit that is executed.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>observable</code> <p>Optional observable(s) that are used only in the <code>expectation</code> method. You can also provide observables on the fly to the expectation call directly.</p> <p> TYPE: <code>list[AbstractBlock] | AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>A backend for circuit execution.</p> <p> TYPE: <code>BackendName | str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>A differentiability mode. Parameter shift based modes work on all backends. AD based modes only on PyTorch based backends.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>Configuration for the backend.</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if the <code>diff_mode</code> argument is set to None</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock | None = None,\n    backend: BackendName | str = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n):\n    \"\"\"Initialize a generic QuantumModel instance.\n\n    Arguments:\n        circuit: The circuit that is executed.\n        observable: Optional observable(s) that are used only in the `expectation` method. You\n            can also provide observables on the fly to the expectation call directly.\n        backend: A backend for circuit execution.\n        diff_mode: A differentiability mode. Parameter shift based modes work on all backends.\n            AD based modes only on PyTorch based backends.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        configuration: Configuration for the backend.\n        noise: A noise model to use.\n\n    Raises:\n        ValueError: if the `diff_mode` argument is set to None\n    \"\"\"\n    super().__init__()\n\n    if not isinstance(circuit, QuantumCircuit):\n        TypeError(\n            f\"The circuit should be of type '&lt;class QuantumCircuit&gt;'. Got {type(circuit)}.\"\n        )\n\n    if diff_mode is None:\n        raise ValueError(\"`diff_mode` cannot be `None` in a `QuantumModel`.\")\n\n    self.backend = backend_factory(\n        backend=backend, diff_mode=diff_mode, configuration=configuration\n    )\n\n    if isinstance(observable, list) or observable is None:\n        observable = observable\n    else:\n        observable = [observable]\n\n    def _is_feature_param(p: Parameter) -&gt; bool:\n        return not p.trainable and not p.is_number\n\n    if observable is None:\n        self.inputs = list(filter(_is_feature_param, circuit.unique_parameters))\n    else:\n        uparams = unique_parameters(chain(circuit.block, *observable))\n        self.inputs = list(filter(_is_feature_param, uparams))\n\n    conv = self.backend.convert(circuit, observable)\n    self.embedding_fn = conv.embedding_fn\n    self._circuit = conv.circuit\n    self._observable = conv.observable\n    self._backend_name = backend\n    self._diff_mode = diff_mode\n    self._measurement = measurement\n    self._noise = noise\n    self._mitigation = mitigation\n    self._params = nn.ParameterDict(\n        {\n            str(key): nn.Parameter(val, requires_grad=val.requires_grad)\n            for key, val in conv.params.items()\n        }\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.in_features","title":"<code>in_features: int</code>  <code>property</code>","text":"<p>Number of inputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.num_vparams","title":"<code>num_vparams: int</code>  <code>property</code>","text":"<p>The number of variational parameters.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.out_features","title":"<code>out_features: int | None</code>  <code>property</code>","text":"<p>Number of outputs.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.vals_vparams","title":"<code>vals_vparams: Tensor</code>  <code>property</code>","text":"<p>Dictionary with parameters which are actually updated during optimization.</p>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.assign_parameters","title":"<code>assign_parameters(values)</code>","text":"<p>Return the final, assigned circuit that is used in e.g. <code>backend.run</code>.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def assign_parameters(self, values: dict[str, Tensor]) -&gt; Any:\n    \"\"\"Return the final, assigned circuit that is used in e.g. `backend.run`.\"\"\"\n    params = self.embedding_fn(self._params, values)\n    return self.backend.assign_parameters(self._circuit, params)\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.expectation","title":"<code>expectation(values={}, observable=None, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute expectation using the given backend.</p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor of shape n_batches x n_obs</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def expectation(\n    self,\n    values: dict[str, Tensor] = {},\n    observable: list[ConvertedObservable] | ConvertedObservable | None = None,\n    state: Optional[Tensor] = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Compute expectation using the given backend.\n\n    Returns:\n        A torch.Tensor of shape n_batches x n_obs\n    \"\"\"\n    if observable is None:\n        if self._observable is None:\n            raise ValueError(\n                \"Provide an AbstractBlock as the observable to compute expectation.\"\n                \"Either pass a 'native_observable' directly to 'QuantumModel.expectation'\"\n                \"or pass a (non-native) '&lt;class AbstractBlock&gt;' to the 'QuantumModel.__init__'.\"\n            )\n        observable = self._observable\n\n    params = self.embedding_fn(self._params, values)\n    if measurement is None:\n        measurement = self._measurement\n    if noise is None:\n        noise = self._noise\n    else:\n        self._noise = noise\n    if mitigation is None:\n        mitigation = self._mitigation\n    return self.backend.expectation(\n        circuit=self._circuit,\n        observable=observable,\n        param_values=params,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n</code></pre>"},{"location":"models/#qadence.models.quantum_model.QuantumModel.reset_vparams","title":"<code>reset_vparams(values)</code>","text":"<p>Reset all the variational parameters with a given list of values.</p> Source code in <code>qadence/models/quantum_model.py</code> <pre><code>def reset_vparams(self, values: Sequence) -&gt; None:\n    \"\"\"Reset all the variational parameters with a given list of values.\"\"\"\n    current_vparams = OrderedDict({k: v for k, v in self._params.items() if v.requires_grad})\n\n    assert (\n        len(values) == self.num_vparams\n    ), \"Pass an iterable with the values of all variational parameters\"\n    for i, k in enumerate(current_vparams.keys()):\n        current_vparams[k].data = torch.tensor([values[i]])\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN","title":"<code>QNN(circuit, observable, transform=None, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD, measurement=None, noise=None, configuration=None, inputs=None)</code>","text":"<p>             Bases: <code>QuantumModel</code></p> <p>Quantum neural network model for n-dimensional inputs.</p> <p>Examples: <pre><code>import torch\nfrom qadence import QuantumCircuit, QNN, Z\nfrom qadence import hea, feature_map, hamiltonian_factory, kron\n\n# create the circuit\nn_qubits, depth = 2, 4\nfm = kron(\n    feature_map(1, support=(0,), param=\"x\"),\n    feature_map(1, support=(1,), param=\"y\")\n)\nansatz = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\nobs_base = hamiltonian_factory(n_qubits, detuning=Z)\n\n# the QNN will yield two outputs\nobs = [2.0 * obs_base, 4.0 * obs_base]\n\n# initialize and use the model\nqnn = QNN(circuit, obs, inputs=[\"x\", \"y\"])\ny = qnn(torch.rand(3, 2))\n</code></pre> <pre><code>tensor([[-0.2139, -0.4279],\n        [-0.0197, -0.0394],\n        [-0.2313, -0.4627]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> </p> <p>Initialize the QNN.</p> <p>The number of inputs is determined by the feature parameters in the input quantum circuit while the number of outputs is determined by how many observables are provided as input</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>The quantum circuit to use for the QNN.</p> <p> TYPE: <code>QuantumCircuit</code> </p> <code>transform</code> <p>A transformation applied to the output of the QNN.</p> <p> TYPE: <code>Callable[[Tensor], Tensor]</code> DEFAULT: <code>None</code> </p> <code>inputs</code> <p>Tuple that indicates the order of variables of the tensors that are passed to the model. Given input tensors <code>xs = torch.rand(batch_size, input_size:=2)</code> a QNN with <code>inputs=(\"t\", \"x\")</code> will assign <code>t, x = xs[:,0], xs[:,1]</code>.</p> <p> TYPE: <code>list[Basic | str] | None</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>The chosen quantum backend.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>The differentiation engine to use. Choices 'gpsr' or 'ad'.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>optional configuration for the backend</p> <p> TYPE: <code>BackendConfiguration | dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def __init__(\n    self,\n    circuit: QuantumCircuit,\n    observable: list[AbstractBlock] | AbstractBlock,\n    transform: Callable[[Tensor], Tensor] = None,  # transform output of the QNN\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: DiffMode = DiffMode.AD,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    configuration: BackendConfiguration | dict | None = None,\n    inputs: list[sympy.Basic | str] | None = None,\n):\n    \"\"\"Initialize the QNN.\n\n    The number of inputs is determined by the feature parameters in the input\n    quantum circuit while the number of outputs is determined by how many\n    observables are provided as input\n\n    Args:\n        circuit: The quantum circuit to use for the QNN.\n        transform: A transformation applied to the output of the QNN.\n        inputs: Tuple that indicates the order of variables of the tensors that are passed\n            to the model. Given input tensors `xs = torch.rand(batch_size, input_size:=2)` a QNN\n            with `inputs=(\"t\", \"x\")` will assign `t, x = xs[:,0], xs[:,1]`.\n        backend: The chosen quantum backend.\n        diff_mode: The differentiation engine to use. Choices 'gpsr' or 'ad'.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        configuration: optional configuration for the backend\n    \"\"\"\n    super().__init__(\n        circuit,\n        observable=observable,\n        backend=backend,\n        diff_mode=diff_mode,\n        measurement=measurement,\n        configuration=configuration,\n        noise=noise,\n    )\n    if self.out_features is None:\n        raise ValueError(\"You need to provide at least one observable in the QNN constructor\")\n    self.transform = transform if transform else lambda x: x\n\n    if (inputs is not None) and (len(self.inputs) == len(inputs)):\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in inputs]  # type: ignore[union-attr]\n    elif (inputs is None) and len(self.inputs) &lt;= 1:\n        self.inputs = [sympy.symbols(x) if isinstance(x, str) else x for x in self.inputs]  # type: ignore[union-attr]\n    else:\n        raise ValueError(\n            \"\"\"\n            Your QNN has more than one input. Please provide a list of inputs in the order of\n            your tensor domain. For example, if you want to pass\n            `xs = torch.rand(batch_size, input_size:=3)` to you QNN, where\n            ```\n            t = x[:,0]\n            x = x[:,1]\n            y = x[:,2]\n            ```\n            you have to specify\n            ```\n            QNN(circuit, observable, inputs=[\"t\", \"x\", \"y\"])\n            ```\n            You can also pass a list of sympy symbols.\n        \"\"\"\n        )\n</code></pre>"},{"location":"models/#qadence.models.qnn.QNN.forward","title":"<code>forward(values=None, state=None, measurement=None, noise=None, endianness=Endianness.BIG)</code>","text":"<p>Forward pass of the model.</p> <p>This returns the (differentiable) expectation value of the given observable operator defined in the constructor. Differently from the base QuantumModel class, the QNN accepts also a tensor as input for the forward pass. The tensor is expected to have shape: <code>n_batches x in_features</code> where <code>n_batches</code> is the number of data points and <code>in_features</code> is the dimensionality of the problem</p> <p>The output of the forward pass is the expectation value of the input observable(s). If a single observable is given, the output shape is <code>n_batches</code> while if multiple observables are given the output shape is instead <code>n_batches x n_observables</code></p> PARAMETER  DESCRIPTION <code>values</code> <p>the values of the feature parameters</p> <p> TYPE: <code>dict[str, Tensor] | Tensor</code> DEFAULT: <code>None</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>optional measurement protocol. If None, use exact expectation value with a statevector simulator</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a tensor with the expectation value of the observables passed in the constructor of the model</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/models/qnn.py</code> <pre><code>def forward(\n    self,\n    values: dict[str, Tensor] | Tensor = None,\n    state: Tensor | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Forward pass of the model.\n\n    This returns the (differentiable) expectation value of the given observable\n    operator defined in the constructor. Differently from the base QuantumModel\n    class, the QNN accepts also a tensor as input for the forward pass. The\n    tensor is expected to have shape: `n_batches x in_features` where `n_batches`\n    is the number of data points and `in_features` is the dimensionality of the problem\n\n    The output of the forward pass is the expectation value of the input\n    observable(s). If a single observable is given, the output shape is\n    `n_batches` while if multiple observables are given the output shape\n    is instead `n_batches x n_observables`\n\n    Args:\n        values: the values of the feature parameters\n        state: Initial state.\n        measurement: optional measurement protocol. If None,\n            use exact expectation value with a statevector simulator\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n\n    Returns:\n        Tensor: a tensor with the expectation value of the observables passed\n            in the constructor of the model\n    \"\"\"\n    return self.expectation(\n        values, state=state, measurement=measurement, noise=noise, endianness=endianness\n    )\n</code></pre>"},{"location":"advanced_tutorials/","title":"Advanced Tutorials","text":"<p>In this section, advanced programming concepts and implementations in Qadence are examplified.</p>"},{"location":"advanced_tutorials/custom-models/","title":"Custom quantum models","text":"<p>In <code>qadence</code>, the <code>QuantumModel</code> is the central class point for executing <code>QuantumCircuit</code>s.  The idea of a <code>QuantumModel</code> is to decouple the backend execution from the management of circuit parameters and desired quantum computation output.</p> <p>In the following, we create a custom <code>QuantumModel</code> instance which introduces some additional optimizable parameters: *  an adjustable scaling factor in front of the observable to measured *  adjustable scale and shift factors to be applied to the model output before returning the result</p> <p>This can be easily done using PyTorch flexible model definition, and it will automatically work with the rest of <code>qadence</code> infrastructure.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit\n\n\nclass CustomQuantumModel(QuantumModel):\n\n    def __init__(self, circuit: QuantumCircuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\"):\n        super().__init__(circuit, observable=observable, backend=backend, diff_mode=diff_mode)\n\n        self.n_qubits = circuit.n_qubits\n\n        # define some additional parameters which will scale and shift (variationally) the\n        # output of the QuantumModel\n        # you can use all torch machinery for building those\n        self.scale_out = torch.nn.Parameter(torch.ones(1))\n        self.shift_out = torch.nn.Parameter(torch.ones(1))\n\n    # override the forward pass of the model\n    # the forward pass is the output of your QuantumModel and in this case\n    # it's the (scaled) expectation value of the total magnetization with\n    # a variable coefficient in front\n    def forward(self, values: dict[str, torch.Tensor]) -&gt; torch.Tensor:\n\n        # scale the observable\n        res = self.expectation(values)\n\n        # scale and shift the result before returning\n        return self.shift_out + res * self.scale_out\n</code></pre> <p>The custom model can be used like any other <code>QuantumModel</code>: <pre><code>from qadence import Parameter, RX, CNOT, QuantumCircuit\nfrom qadence import chain, kron, hamiltonian_factory, Z\nfrom sympy import acos\n\ndef quantum_circuit(n_qubits):\n\n    x = Parameter(\"x\", trainable=False)\n    fm = kron(RX(i, acos(x) * (i+1)) for i in range(n_qubits))\n\n    ansatz = kron(RX(i, f\"theta{i}\") for i in range(n_qubits))\n    ansatz = chain(ansatz, CNOT(0, n_qubits-1))\n\n    block = chain(fm, ansatz)\n    block.tag = \"circuit\"\n    return QuantumCircuit(n_qubits, block)\n\nn_qubits = 4\nbatch_size = 10\ncircuit = quantum_circuit(n_qubits)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)  # Total magnetization\n\nmodel = CustomQuantumModel(circuit, observable, backend=\"pyqtorch\")\n\nvalues = {\"x\": torch.rand(batch_size)}\nres = model(values)\nprint(\"Model output: \", res)\nassert len(res) == batch_size\n</code></pre> <pre><code>Model output:  tensor([[ 0.2242],\n        [-0.9385],\n        [-0.8001],\n        [-1.6125],\n        [ 0.3012],\n        [-0.3495],\n        [-0.3129],\n        [-1.5662],\n        [-0.7268],\n        [-1.5662]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> </p>"},{"location":"advanced_tutorials/custom-models/#quantum-model-with-wavefunction-overlaps","title":"Quantum model with wavefunction overlaps","text":"<p><code>QuantumModel</code>'s can also use different quantum operations in their forward pass, such as wavefunction overlaps described here. Beware that the resulting overlap tensor has to be differentiable to apply gradient-based optimization. This is only applicable to the <code>\"EXACT\"</code> overlap method.</p> <p>Here we show how to use overlap calculation when fitting a parameterized quantum circuit to act as a standard Hadamard gate.</p> <pre><code>from qadence import RY, RX, H, Overlap\n\n# create a quantum model which acts as an Hadamard gate after training\nclass LearnHadamard(QuantumModel):\n    def __init__(\n        self,\n        train_circuit: QuantumCircuit,\n        target_circuit: QuantumCircuit,\n        backend=\"pyqtorch\",\n    ):\n        super().__init__(circuit=train_circuit, backend=backend)\n        self.overlap_fn = Overlap(train_circuit, target_circuit, backend=backend, method=\"exact\", diff_mode='ad')\n\n    def forward(self):\n        return self.overlap_fn()\n\n    # compute the wavefunction of the associated train circuit\n    def wavefunction(self):\n        return model.overlap_fn.run({})\n\n\ntrain_circuit = QuantumCircuit(1, chain(RX(0, \"phi\"), RY(0, \"theta\")))\ntarget_circuit = QuantumCircuit(1, H(0))\n\nmodel = LearnHadamard(train_circuit, target_circuit)\n\n# get the overlap between model and target circuit wavefunctions\nprint(model())\n</code></pre> <pre><code>tensor([[0.8449]], grad_fn=&lt;UnsqueezeBackward0&gt;)\n</code></pre> <p>This model can then be trained with the standard Qadence helper functions.</p> <pre><code>from qadence import run\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-1)\n\ndef loss_fn(model: LearnHadamard, _unused) -&gt; tuple[torch.Tensor, dict]:\n    loss = criterion(torch.tensor([[1.0]]), model())\n    return loss, {}\n\nconfig = TrainConfig(max_iter=2500)\nmodel, optimizer = train_with_grad(\n    model, None, optimizer, config, loss_fn=loss_fn\n)\n\nwf_target = run(target_circuit)\nassert torch.allclose(wf_target, model.wavefunction(), atol=1e-2)\n</code></pre> <pre><code>\n</code></pre>"},{"location":"advanced_tutorials/differentiability/","title":"Differentiability","text":"<p>Many application in quantum computing and quantum machine learning more specifically requires the differentiation of a quantum circuit with respect to its parameters.</p> <p>In Qadence, we perform quantum computations via the <code>QuantumModel</code> interface. The derivative of the outputs of quantum models with respect to feature and variational parameters in the quantum circuit can be implemented in Qadence with two different modes:</p> <ul> <li>Automatic differentiation (AD) mode <sup>1</sup>. This mode allows to differentiation both <code>run()</code> and <code>expectation()</code> methods of the <code>QuantumModel</code> and it is the fastest available differentiation method. Under the hood, it is based on the PyTorch autograd engine wrapped by the <code>DifferentiableBackend</code> class. This mode is not working on quantum devices.</li> <li>Generalized parameter shift rule (GPSR) mode. This is general implementation of the well known parameter  shift rule algorithm <sup>2</sup> which works for arbitrary quantum operations <sup>3</sup>. This mode is only applicable to  the <code>expectation()</code> method of <code>QuantumModel</code> but it is compatible with execution or quantum devices.</li> </ul>"},{"location":"advanced_tutorials/differentiability/#automatic-differentiation","title":"Automatic differentiation","text":"<p>Automatic differentiation <sup>1</sup> is a procedure to derive a complex function defined as a sequence of elementary mathematical operations in the form of a computer program. Automatic differentiation is a cornerstone of modern machine learning and a crucial ingredient of its recent successes. In its so-called reverse mode, it follows this sequence of operations in reverse order by systematically applying the chain rule to recover the exact value of derivative. Reverse mode automatic differentiation is implemented in Qadence leveraging the PyTorch <code>autograd</code> engine.</p> <p>Only available via the PyQTorch or Horqrux backends</p> <p>Currently, automatic differentiation mode is only available when the <code>pyqtorch</code> or <code>horqrux</code> backends are selected.</p>"},{"location":"advanced_tutorials/differentiability/#generalized-parameter-shift-rule","title":"Generalized parameter shift rule","text":"<p>The generalized parameter shift rule implementation in Qadence was introduced in <sup>3</sup>. Here the standard parameter shift rules, which only works for quantum operations whose generator has a single gap in its eigenvalue spectrum, was generalized to work with arbitrary generators of quantum operations.</p> <p>For this, we define the differentiable function as quantum expectation value</p> \\[ f(x) = \\left\\langle 0\\right|\\hat{U}^{\\dagger}(x)\\hat{C}\\hat{U}(x)\\left|0\\right\\rangle \\] <p>where \\(\\hat{U}(x)={\\rm exp}{\\left( -i\\frac{x}{2}\\hat{G}\\right)}\\) is the quantum evolution operator with generator \\(\\hat{G}\\) representing the structure of the underlying quantum circuit and \\(\\hat{C}\\) is the cost operator. Then using the eigenvalue spectrum \\(\\left\\{ \\lambda_n\\right\\}\\) of the generator \\(\\hat{G}\\) we calculate the full set of corresponding unique non-zero spectral gaps \\(\\left\\{ \\Delta_s\\right\\}\\) (differences between eigenvalues). It can be shown that the final expression of derivative of \\(f(x)\\) is then given by the following expression:</p> <p>\\(\\begin{equation} \\frac{{\\rm d}f\\left(x\\right)}{{\\rm d}x}=\\overset{S}{\\underset{s=1}{\\sum}}\\Delta_{s}R_{s}, \\end{equation}\\)</p> <p>where \\(S\\) is the number of unique non-zero spectral gaps and \\(R_s\\) are real quantities that are solutions of a system of linear equations</p> <p>\\(\\begin{equation} \\begin{cases} F_{1} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{1}\\Delta_{s}}{2}\\right)R_{s},\\\\ F_{2} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{2}\\Delta_{s}}{2}\\right)R_{s},\\\\  &amp; ...\\\\ F_{S} &amp; =4\\overset{S}{\\underset{s=1}{\\sum}}{\\rm sin}\\left(\\frac{\\delta_{M}\\Delta_{s}}{2}\\right)R_{s}. \\end{cases} \\end{equation}\\)</p> <p>Here \\(F_s=f(x+\\delta_s)-f(x-\\delta_s)\\) denotes the difference between values of functions evaluated at shifted arguments \\(x\\pm\\delta_s\\).</p>"},{"location":"advanced_tutorials/differentiability/#adjoint-differentiation","title":"Adjoint Differentiation","text":"<p>Qadence also offers a memory-efficient, non-device compatible alternative to automatic differentation, called 'Adjoint Differentiation' <sup>4</sup> and allows for precisely calculating the gradients of variational parameters in O(P) time and using O(1) state-vectors. Adjoint Differentation is currently only supported by the Torch Engine and allows for first-order derivatives only.</p>"},{"location":"advanced_tutorials/differentiability/#usage","title":"Usage","text":""},{"location":"advanced_tutorials/differentiability/#basics","title":"Basics","text":"<p>In Qadence, the differentiation modes can be selected via the <code>diff_mode</code> argument of the QuantumModel class. It either accepts a <code>DiffMode</code>(<code>DiffMode.GSPR</code>, <code>DiffMode.AD</code> or <code>DiffMode.ADJOINT</code>) or a string (<code>\"gpsr\"\"</code>, <code>\"ad\"</code> or <code>\"adjoint\"</code>). The code in the box below shows how to create <code>QuantumModel</code> instances with all available differentiation modes.</p> <pre><code>from qadence import (FeatureParameter, RX, Z, hea, chain,\n                    hamiltonian_factory, QuantumCircuit,\n                    QuantumModel, BackendName, DiffMode)\nimport torch\n\nn_qubits = 2\n\n# Define a symbolic parameter to differentiate with respect to\nx = FeatureParameter(\"x\")\n\nblock = chain(hea(n_qubits, 1), RX(0, x))\n\n# create quantum circuit\ncircuit = QuantumCircuit(n_qubits, block)\n\n# create total magnetization cost operator\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# create models with AD, ADJOINT and GPSR differentiation engines\nmodel_ad = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.AD)\nmodel_adjoint = QuantumModel(circuit, obs,\n                        backend=BackendName.PYQTORCH,\n                        diff_mode=DiffMode.ADJOINT)\nmodel_gpsr = QuantumModel(circuit, obs,\n                          backend=BackendName.PYQTORCH,\n                          diff_mode=DiffMode.GPSR)\n\n# Create concrete values for the parameter we want to differentiate with respect to\nxs = torch.linspace(0, 2*torch.pi, 100, requires_grad=True)\nvalues = {\"x\": xs}\n\n# calculate function f(x)\nexp_val_ad = model_ad.expectation(values)\nexp_val_adjoint = model_adjoint.expectation(values)\nexp_val_gpsr = model_gpsr.expectation(values)\n\n# calculate derivative df/dx using the PyTorch\n# autograd engine\ndexpval_x_ad = torch.autograd.grad(\n    exp_val_ad, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_adjoint = torch.autograd.grad(\n    exp_val_adjoint, values[\"x\"], torch.ones_like(exp_val_ad), create_graph=True\n)[0]\ndexpval_x_gpsr = torch.autograd.grad(\n    exp_val_gpsr, values[\"x\"], torch.ones_like(exp_val_gpsr), create_graph=True\n)[0]\n</code></pre> <p>We can plot the resulting derivatives and see that in both cases they coincide.</p> <pre><code>import matplotlib.pyplot as plt\n\n# plot f(x) and df/dx derivatives calculated using AD ,ADJOINT and GPSR\n# differentiation engines\nfig, ax = plt.subplots()\nax.scatter(xs.detach().numpy(),\n           exp_val_ad.detach().numpy(),\n           label=\"f(x)\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_ad.detach().numpy(),\n           label=\"df/dx AD\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_adjoint.detach().numpy(),\n           label=\"df/dx ADJOINT\")\nax.scatter(xs.detach().numpy(),\n           dexpval_x_gpsr.detach().numpy(),\n           s=5,\n           label=\"df/dx GPSR\")\nplt.legend()\n</code></pre> 2024-02-15T16:11:30.886578 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"advanced_tutorials/differentiability/#low-level-control-on-the-shift-values","title":"Low-level control on the shift values","text":"<p>In order to get a finer control over the GPSR differentiation engine we can use the low-level Qadence API to define a <code>DifferentiableBackend</code>.</p> <pre><code>from qadence.engines.torch import DifferentiableBackend\nfrom qadence.backends.pyqtorch import Backend as PyQBackend\n\n# define differentiable quantum backend\nquantum_backend = PyQBackend()\nconv = quantum_backend.convert(circuit, obs)\npyq_circ, pyq_obs, embedding_fn, params = conv\ndiff_backend = DifferentiableBackend(quantum_backend, diff_mode=DiffMode.GPSR, shift_prefac=0.2)\n\n# calculate function f(x)\nexpval = diff_backend.expectation(pyq_circ, pyq_obs, embedding_fn(params, values))\n</code></pre> <p>Here we passed an additional argument <code>shift_prefac</code> to the <code>DifferentiableBackend</code> instance that governs the magnitude of shifts \\(\\delta\\equiv\\alpha\\delta^\\prime\\) shown in equation (2) above. In this relation \\(\\delta^\\prime\\) is set internally and \\(\\alpha\\) is the value passed by <code>shift_prefac</code> and the resulting shift value \\(\\delta\\) is then used in all the following GPSR calculations.</p> <p>Tuning parameter \\(\\alpha\\) is useful to improve results when the generator \\(\\hat{G}\\) or the quantum operation is a dense matrix, for example a complex <code>HamEvo</code> operation; if many entries of this matrix are sufficiently larger than 0 the operation is equivalent to a strongly interacting system. In such case parameter \\(\\alpha\\) should be gradually lowered in order to achieve exact derivative values.</p>"},{"location":"advanced_tutorials/differentiability/#low-level-differentiation-of-qadence-circuits-using-jax","title":"Low-level differentiation of qadence circuits using JAX","text":"<p>For users interested in using the <code>JAX</code> engine instead, we show how to run and differentiate qadence programs using the <code>horqrux</code> backend under qadence examples.</p>"},{"location":"advanced_tutorials/differentiability/#references","title":"References","text":"<ol> <li> <p>A. G. Baydin et al., Automatic Differentiation in Machine Learning: a Survey \u21a9\u21a9</p> </li> <li> <p>Schuld et al., Evaluating analytic gradients on quantum hardware (2018). \u21a9</p> </li> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9\u21a9</p> </li> <li> <p>Tyson et al., Efficient calculation of gradients in classical simulations of variational quantum algorithms \u21a9</p> </li> </ol>"},{"location":"advanced_tutorials/projectors/","title":"Projector blocks","text":"<p>This section introduces the <code>ProjectorBlock</code> as an implementation for the quantum mechanical projection operation onto the subspace spanned by \\(|a\\rangle\\): \\(\\mathbb{\\hat{P}}=|a\\rangle \\langle a|\\). It evaluates the outer product for bras and kets expressed as bitstrings for a given qubit support. They have to possess matching lengths.</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence.operations import Projector  # Projector as an operation.\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# As any block, the matrix representation can be retrieved.\nprojector_matrix = block_to_tensor(projector_block)\n</code></pre> <pre><code>projector matrix = tensor([[[0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\n</code></pre> <p>Other standard operations are expressed as projectors in Qadence. For instance, the number operator is the projector onto the 1-subspace, \\(N=|1\\rangle\\langle 1|\\).</p> <p>In fact, projectors can be used to compose any arbitrary operator. For example, the <code>CNOT</code> can be defined as \\(\\textrm{CNOT}(i,j)=|0\\rangle\\langle 0|_i\\otimes \\mathbb{I}_j+|1\\rangle\\langle 1|_i\\otimes X_j\\) and we can compare its matrix representation with the native one in Qadence:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import kron, I, X, CNOT\n\n# Define a projector for |0&gt; onto the qubit labelled 0.\nprojector0 = Projector(ket=\"0\", bra=\"0\", qubit_support=0)\n\n# Define a projector for |1&gt; onto the qubit labelled 0.\nprojector1 = Projector(ket=\"1\", bra=\"1\", qubit_support=0)\n\n# Construct the projector controlled CNOT.\nprojector_cnot = kron(projector0, I(1)) + kron(projector1, X(1))\n\n# Get the underlying unitary.\nprojector_cnot_matrix = block_to_tensor(projector_cnot)\n\n# Qadence CNOT unitary.\nqadence_cnot_matrix = block_to_tensor(CNOT(0,1))\n</code></pre> <pre><code>projector cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\nqadence cnot matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]], grad_fn=&lt;AddBackward0&gt;)\n</code></pre> <p>Another example is the canonical SWAP unitary that can be defined as \\(SWAP=|00\\rangle\\langle 00|+|01\\rangle\\langle 10|+|10\\rangle\\langle 01|+|11\\rangle\\langle 11|\\). Indeed, it can be shown that their matricial representations are again identical:</p> <pre><code>from qadence.blocks import block_to_tensor\nfrom qadence import SWAP\n\n# Define all projectors.\nprojector00 = Projector(ket=\"00\", bra=\"00\", qubit_support=(0, 1))\nprojector01 = Projector(ket=\"01\", bra=\"10\", qubit_support=(0, 1))\nprojector10 = Projector(ket=\"10\", bra=\"01\", qubit_support=(0, 1))\nprojector11 = Projector(ket=\"11\", bra=\"11\", qubit_support=(0, 1))\n\n# Construct the SWAP gate.\nprojector_swap = projector00 + projector10 + projector01 + projector11\n\n# Get the underlying unitary.\nprojector_swap_matrix = block_to_tensor(projector_swap)\n\n# Qadence SWAP unitary.\nqadence_swap_matrix = block_to_tensor(SWAP(0,1))\n</code></pre> <pre><code>projector swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]])\nqadence swap matrix = tensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]]], grad_fn=&lt;UnsafeViewBackward0&gt;)\n</code></pre> <p>Warning</p> <p>Projectors are non-unitary operators, only supported by the PyQTorch backend.</p> <p>To examplify this point, let's run some non-unitary computation involving projectors.</p> <pre><code>from qadence import chain, run\nfrom qadence.operations import H, CNOT\n\n# Define a projector for |1&gt; onto the qubit labelled 1.\nprojector_block = Projector(ket=\"1\", bra=\"1\", qubit_support=1)\n\n# Some non-unitary computation.\nnon_unitary_block = chain(H(0), CNOT(0,1), projector_block)\n\n# Projected wavefunction becomes unnormalized\nprojected_wf = run(non_unitary_block)  # Run on PyQTorch.\n</code></pre> <pre><code>projected_wf = tensor([[0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre>"},{"location":"backends/backend/","title":"Abstract backend","text":""},{"location":"backends/backend/#qadence.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The abstract class that defines the interface for the backends.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>backend unique string identifier</p> <p> TYPE: <code>BackendName</code> </p> <code>supports_ad</code> <p>whether or not the backend has a native autograd</p> <p> TYPE: <code>bool</code> </p> <code>supports_bp</code> <p>whether or not the backend has a native backprop</p> <p> TYPE: <code>bool</code> </p> <code>supports_adjoint</code> <p>Does the backend support native adjoint differentation.</p> <p> TYPE: <code>bool</code> </p> <code>is_remote</code> <p>whether computations are executed locally or remotely on this backend, useful when using cloud platforms where credentials are needed for example.</p> <p> TYPE: <code>bool</code> </p> <code>with_measurements</code> <p>whether it supports counts or not</p> <p> TYPE: <code>bool</code> </p> <code>with_noise</code> <p>whether to add realistic noise or not</p> <p> TYPE: <code>bool</code> </p> <code>native_endianness</code> <p>The native endianness of the backend</p> <p> TYPE: <code>Endianness</code> </p> <code>engine</code> <p>The underlying (native) automatic differentiation engine of the backend.</p> <p> TYPE: <code>Engine</code> </p>"},{"location":"backends/backend/#qadence.backend.Backend.circuit","title":"<code>circuit(circuit)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract <code>QuantumCircuit</code> to the native backend representation.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A circuit, for example: <code>QuantumCircuit(2, X(0))</code></p> <p> TYPE: <code>QuantumCircuit</code> </p> RETURNS DESCRIPTION <code>ConvertedCircuit</code> <p>A converted circuit <code>c</code>. You can access the original, arbstract circuit via <code>c.abstract</code></p> <code>ConvertedCircuit</code> <p>and the converted (or backend native) circuit via <code>c.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef circuit(self, circuit: QuantumCircuit) -&gt; ConvertedCircuit:\n    \"\"\"Converts an abstract `QuantumCircuit` to the native backend representation.\n\n    Arguments:\n        circuit: A circuit, for example: `QuantumCircuit(2, X(0))`\n\n    Returns:\n        A converted circuit `c`. You can access the original, arbstract circuit via `c.abstract`\n        and the converted (or backend *native*) circuit via `c.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.observable","title":"<code>observable(observable, n_qubits)</code>  <code>abstractmethod</code>","text":"<p>Converts an abstract observable (which is just an <code>AbstractBlock</code>) to the native backend.</p> <p>representation.</p> PARAMETER  DESCRIPTION <code>observable</code> <p>An observable.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>n_qubits</code> <p>Number of qubits the observable covers. This is typically <code>circuit.n_qubits</code>.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ConvertedObservable</code> <p>A converted observable <code>o</code>. You can access the original, arbstract observable via</p> <code>ConvertedObservable</code> <p><code>o.abstract</code> and the converted (or backend native) observable via <code>o.native</code>.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef observable(self, observable: AbstractBlock, n_qubits: int) -&gt; ConvertedObservable:\n    \"\"\"Converts an abstract observable (which is just an `AbstractBlock`) to the native backend.\n\n    representation.\n\n    Arguments:\n        observable: An observable.\n        n_qubits: Number of qubits the observable covers. This is typically `circuit.n_qubits`.\n\n    Returns:\n        A converted observable `o`. You can access the original, arbstract observable via\n        `o.abstract` and the converted (or backend *native*) observable via `o.native`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.run_dm","title":"<code>run_dm(circuit, noise, param_values={}, state=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Run a circuit and return the resulting the density matrix.</p> <p>TODO: Temporary method for the purposes of noise model implementation. To be removed in a later refactoring.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting density matrix.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>Tensor</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef run_dm(\n    self,\n    circuit: ConvertedCircuit,\n    noise: Noise,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; Tensor:\n    \"\"\"Run a circuit and return the resulting the density matrix.\n\n    TODO: Temporary method for the purposes of noise model implementation.\n    To be removed in a later refactoring.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting density matrix.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1000, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>  <code>abstractmethod</code>","text":"<p>Sample bit strings.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, Tensor]</code> DEFAULT: <code>{}</code> </p> <code>n_shots</code> <p>Number of shots to sample.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>An error mitigation protocol to apply.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>@abstractmethod\ndef sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1000,\n    state: ArrayLike | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Sample bit strings.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        n_shots: Number of shots to sample.\n        state: Initial state.\n        noise: A noise model to use.\n        mitigation: An error mitigation protocol to apply.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration","title":"<code>BackendConfiguration</code>  <code>dataclass</code>","text":""},{"location":"backends/backend/#qadence.backend.BackendConfiguration.available_options","title":"<code>available_options()</code>","text":"<p>Return as a string the available fields with types of the configuration.</p> RETURNS DESCRIPTION <code>str</code> <p>a string with all the available fields, one per line</p> <p> TYPE: <code>str</code> </p> Source code in <code>qadence/backend.py</code> <pre><code>def available_options(self) -&gt; str:\n    \"\"\"Return as a string the available fields with types of the configuration.\n\n    Returns:\n        str: a string with all the available fields, one per line\n    \"\"\"\n    conf_msg = \"\"\n    for _field in fields(self):\n        if not _field.name.startswith(\"_\"):\n            conf_msg += (\n                f\"Name: {_field.name} - Type: {_field.type} - Default value: {_field.default}\\n\"\n            )\n    return conf_msg\n</code></pre>"},{"location":"backends/backend/#qadence.backend.BackendConfiguration.get_param_name","title":"<code>get_param_name(blk)</code>","text":"<p>Return parameter names for the current backend.</p> <p>Depending on which backend is in use this function returns either UUIDs or expressions of parameters.</p> Source code in <code>qadence/backend.py</code> <pre><code>def get_param_name(self, blk: AbstractBlock) -&gt; Tuple[str, ...]:\n    \"\"\"Return parameter names for the current backend.\n\n    Depending on which backend is in use this\n    function returns either UUIDs or expressions of parameters.\n    \"\"\"\n    param_ids: Tuple\n    # FIXME: better type hiearchy?\n    types = (TimeEvolutionBlock, ParametricBlock, ConstantAnalogRotation, InteractionBlock)\n    if not isinstance(blk, types):\n        raise TypeError(f\"Can not infer param name from {type(blk)}\")\n    else:\n        if self._use_gate_params:\n            param_ids = tuple(blk.parameters.uuids())\n        else:\n            param_ids = tuple(map(stringify, blk.parameters.expressions()))\n    return param_ids\n</code></pre>"},{"location":"backends/braket/","title":"Amazon Braket","text":""},{"location":"backends/braket/#braket-digital-backend","title":"Braket Digital backend","text":""},{"location":"backends/braket/#qadence.backends.braket.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.assign_parameters","title":"<code>assign_parameters(circuit, param_values)</code>","text":"<p>Assign numerical values to the circuit parameters.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def assign_parameters(\n    self, circuit: ConvertedCircuit, param_values: dict[str, Tensor | float]\n) -&gt; BraketCircuit:\n    \"\"\"Assign numerical values to the circuit parameters.\"\"\"\n    if param_values is None:\n        return circuit.native()\n\n    params_copy = param_values.copy()\n    pnames = [p.name for p in circuit.native.parameters]\n\n    # account for fixed parameters\n    for name in param_values.keys():\n        if name not in pnames:\n            params_copy.pop(name)\n\n    # make sure that all the parameters are single floats\n    # otherwise it won't be accepted by Braket\n    native_params = promote_parameters(params_copy)\n\n    # assign the parameters to the circuit\n    assigned_circuit = circuit.native(**native_params)\n\n    return assigned_circuit\n</code></pre>"},{"location":"backends/braket/#qadence.backends.braket.backend.Backend.sample","title":"<code>sample(circuit, param_values={}, n_shots=1, state=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Execute the circuit and return samples of the resulting wavefunction.</p> Source code in <code>qadence/backends/braket/backend.py</code> <pre><code>def sample(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, Tensor] = {},\n    n_shots: int = 1,\n    state: Tensor | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; list[Counter]:\n    \"\"\"Execute the circuit and return samples of the resulting wavefunction.\"\"\"\n    if state is not None:\n        raise NotImplementedError(\"Braket cannot handle a custom initial state.\")\n\n    if n_shots &lt; 1:\n        raise ValueError(\"You can only call sample with n_shots&gt;0.\")\n\n    if self.is_remote:\n        # handle here, or different backends?\n        raise NotImplementedError\n\n    # loop over all values in the batch\n\n    samples = []\n    for vals in to_list_of_dicts(param_values):\n        final_circuit = self.assign_parameters(circuit, vals)\n        task = self._device.run(final_circuit, n_shots)\n        samples.append(task.result().measurement_counts)\n    if endianness != self.native_endianness:\n        from qadence.transpile import invert_endianness\n\n        samples = invert_endianness(samples)\n    if noise is not None:\n        samples = apply_noise(noise=noise, samples=samples)\n    if mitigation is not None:\n        logger.warning(\n            \"Mitigation protocol is deprecated. Use qadence-protocols instead.\",\n        )\n        assert noise\n        samples = apply_mitigation(noise=noise, mitigation=mitigation, samples=samples)\n    return samples\n</code></pre>"},{"location":"backends/differentiable/","title":"DifferentiableBackend","text":""},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine TORCH.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: QuantumBackend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.TORCH, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.torch.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/torch/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n    differentiable_expectation = DifferentiableExpectation(\n        backend=self.backend,\n        circuit=circuit,\n        observable=observable,\n        param_values=param_values,\n        state=state,\n        measurement=measurement,\n        noise=noise,\n        mitigation=mitigation,\n        endianness=endianness,\n    )\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = differentiable_expectation.ad\n    elif self.diff_mode == DiffMode.ADJOINT:\n        expectation = differentiable_expectation.adjoint\n    else:\n        try:\n            fns = get_gpsr_fns()\n            psr_fn = fns[self.diff_mode]\n        except KeyError:\n            raise ValueError(f\"{self.diff_mode} differentiation mode is not supported\")\n        expectation = partial(differentiable_expectation.psr, psr_fn=psr_fn, **self.psr_args)\n    return expectation()\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend","title":"<code>DifferentiableBackend(backend, diff_mode=DiffMode.AD, **psr_args)</code>","text":"<p>             Bases: <code>DifferentiableBackend</code></p> <p>A class which wraps a QuantumBackend with the automatic differentation engine JAX.</p> PARAMETER  DESCRIPTION <code>backend</code> <p>An instance of the QuantumBackend type perform execution.</p> <p> TYPE: <code>Backend</code> </p> <code>diff_mode</code> <p>A differentiable mode supported by the differentiation engine.</p> <p> TYPE: <code>DiffMode</code> DEFAULT: <code>AD</code> </p> <code>**psr_args</code> <p>Arguments that will be passed on to <code>DifferentiableExpectation</code>.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>{}</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def __init__(\n    self,\n    backend: Backend,\n    diff_mode: DiffMode = DiffMode.AD,\n    **psr_args: int | float | None,\n) -&gt; None:\n    super().__init__(backend=backend, engine=Engine.JAX, diff_mode=diff_mode)\n    self.psr_args = psr_args\n</code></pre>"},{"location":"backends/differentiable/#qadence.engines.jax.differentiable_backend.DifferentiableBackend.expectation","title":"<code>expectation(circuit, observable, param_values={}, state=None, measurement=None, noise=None, mitigation=None, endianness=Endianness.BIG)</code>","text":"<p>Compute the expectation value of the <code>circuit</code> with the given <code>observable</code>.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>observable</code> <p>A converted observable as returned by <code>backend.observable</code>.</p> <p> TYPE: <code>list[ConvertedObservable] | ConvertedObservable</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>ParamDictType</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>ArrayLike | None</code> DEFAULT: <code>None</code> </p> <code>measurement</code> <p>Optional measurement protocol. If None, use exact expectation value with a statevector simulator.</p> <p> TYPE: <code>Measurements | None</code> DEFAULT: <code>None</code> </p> <code>noise</code> <p>A noise model to use.</p> <p> TYPE: <code>Noise | None</code> DEFAULT: <code>None</code> </p> <code>mitigation</code> <p>The error mitigation to use.</p> <p> TYPE: <code>Mitigations | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting bit strings.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> Source code in <code>qadence/engines/jax/differentiable_backend.py</code> <pre><code>def expectation(\n    self,\n    circuit: ConvertedCircuit,\n    observable: list[ConvertedObservable] | ConvertedObservable,\n    param_values: ParamDictType = {},\n    state: ArrayLike | None = None,\n    measurement: Measurements | None = None,\n    noise: Noise | None = None,\n    mitigation: Mitigations | None = None,\n    endianness: Endianness = Endianness.BIG,\n) -&gt; ArrayLike:\n    \"\"\"Compute the expectation value of the `circuit` with the given `observable`.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        observable: A converted observable as returned by `backend.observable`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        measurement: Optional measurement protocol. If None, use\n            exact expectation value with a statevector simulator.\n        noise: A noise model to use.\n        mitigation: The error mitigation to use.\n        endianness: Endianness of the resulting bit strings.\n    \"\"\"\n    observable = observable if isinstance(observable, list) else [observable]\n\n    if self.diff_mode == DiffMode.AD:\n        expectation = self.backend.expectation(circuit, observable, param_values, state)\n    else:\n        expectation = DifferentiableExpectation(\n            backend=self.backend,\n            circuit=circuit,\n            observable=observable,\n            param_values=param_values,\n            state=state,\n            measurement=measurement,\n            noise=noise,\n            mitigation=mitigation,\n            endianness=endianness,\n        ).psr()\n    return expectation\n</code></pre>"},{"location":"backends/pulser/","title":"Pulser","text":"<p>The Pulser backend features a basic integration with the pulse-level programming interface Pulser. This backend offers for now few simple operations which are translated into a valid, non time-dependent pulse sequence. In particular, one has access to:</p> <ul> <li>analog rotations: <code>AnalogRx</code> and <code>AnalogRy</code> blocks</li> <li>free evolution blocks (basically no pulse, just interaction): <code>AnalogWait</code> block</li> <li>a block for creating entangled states: <code>AnalogEntanglement</code></li> <li>digital rotation <code>Rx</code> and <code>Ry</code></li> </ul>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>The Pulser backend.</p>"},{"location":"backends/pulser/#qadence.backends.pulser.backend.create_register","title":"<code>create_register(register)</code>","text":"<p>Convert Qadence Register to Pulser Register.</p> Source code in <code>qadence/backends/pulser/backend.py</code> <pre><code>def create_register(register: Register) -&gt; PulserRegister:\n    \"\"\"Convert Qadence Register to Pulser Register.\"\"\"\n    coords = np.array(list(register.coords.values()))\n    return PulserRegister.from_coordinates(coords)\n</code></pre>"},{"location":"backends/pyqtorch/","title":"PyQTorch","text":"<p>Fast differentiable statevector emulator based on PyTorch. The code is open source, hosted on Github and maintained by Pasqal.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend","title":"<code>Backend</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Backend</code></p> <p>PyQTorch backend.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.convert","title":"<code>convert(circuit, observable=None)</code>","text":"<p>Convert an abstract circuit and an optional observable to their native representation.</p> <p>Additionally, this function constructs an embedding function which maps from user-facing parameters to device parameters (read more on parameter embedding here).</p> Source code in <code>qadence/backend.py</code> <pre><code>def convert(\n    self, circuit: QuantumCircuit, observable: list[AbstractBlock] | AbstractBlock | None = None\n) -&gt; Converted:\n    \"\"\"Convert an abstract circuit and an optional observable to their native representation.\n\n    Additionally, this function constructs an embedding function which maps from\n    user-facing parameters to device parameters (read more on parameter embedding\n    [here][qadence.blocks.embedding.embedding]).\n    \"\"\"\n\n    def check_observable(obs_obj: Any) -&gt; AbstractBlock:\n        if isinstance(obs_obj, QubitOperator):\n            from qadence.blocks.manipulate import from_openfermion\n\n            assert len(obs_obj.terms) &gt; 0, \"Make sure to give a non-empty qubit hamiltonian\"\n\n            return from_openfermion(obs_obj)\n\n        elif isinstance(obs_obj, (CompositeBlock, PrimitiveBlock, ScaleBlock)):\n            from qadence.blocks.utils import block_is_qubit_hamiltonian\n\n            assert block_is_qubit_hamiltonian(\n                obs_obj\n            ), \"Make sure the QubitHamiltonian consists only of Pauli operators X, Y, Z, I\"\n            return obs_obj\n        raise TypeError(\n            \"qubit_hamiltonian should be a Pauli-like AbstractBlock or a QubitOperator\"\n        )\n\n    conv_circ = self.circuit(circuit)\n    circ_params, circ_embedding_fn = embedding(\n        conv_circ.abstract.block, self.config._use_gate_params, self.engine\n    )\n    params = circ_params\n    if observable is not None:\n        observable = observable if isinstance(observable, list) else [observable]\n        conv_obs = []\n        obs_embedding_fn_list = []\n\n        for obs in observable:\n            obs = check_observable(obs)\n            c_obs = self.observable(obs, max(circuit.n_qubits, obs.n_qubits))\n            obs_params, obs_embedding_fn = embedding(\n                c_obs.abstract, self.config._use_gate_params, self.engine\n            )\n            params.update(obs_params)\n            obs_embedding_fn_list.append(obs_embedding_fn)\n            conv_obs.append(c_obs)\n\n        def embedding_fn_dict(a: dict, b: dict) -&gt; dict:\n            embedding_dict = circ_embedding_fn(a, b)\n            for o in obs_embedding_fn_list:\n                embedding_dict.update(o(a, b))\n            return embedding_dict\n\n        return Converted(conv_circ, conv_obs, embedding_fn_dict, params)\n\n    def embedding_fn(a: dict, b: dict) -&gt; dict:\n        return circ_embedding_fn(a, b)\n\n    return Converted(conv_circ, None, embedding_fn, params)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.backend.Backend.run","title":"<code>run(circuit, param_values={}, state=None, endianness=Endianness.BIG, *args, **kwargs)</code>","text":"<p>Run a circuit and return the resulting wave function.</p> PARAMETER  DESCRIPTION <code>circuit</code> <p>A converted circuit as returned by <code>backend.circuit</code>.</p> <p> TYPE: <code>ConvertedCircuit</code> </p> <code>param_values</code> <p>Already embedded parameters of the circuit. See <code>embedding</code> for more info.</p> <p> TYPE: <code>dict[str, ArrayLike]</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor | None</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>Endianness of the resulting wavefunction.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> RETURNS DESCRIPTION <code>ArrayLike</code> <p>A list of Counter objects where each key represents a bitstring</p> <code>ArrayLike</code> <p>and its value the number of times it has been sampled from the given wave function.</p> Source code in <code>qadence/backend.py</code> <pre><code>def run(\n    self,\n    circuit: ConvertedCircuit,\n    param_values: dict[str, ArrayLike] = {},\n    state: Tensor | None = None,\n    endianness: Endianness = Endianness.BIG,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ArrayLike:\n    \"\"\"Run a circuit and return the resulting wave function.\n\n    Arguments:\n        circuit: A converted circuit as returned by `backend.circuit`.\n        param_values: _**Already embedded**_ parameters of the circuit. See\n            [`embedding`][qadence.blocks.embedding.embedding] for more info.\n        state: Initial state.\n        endianness: Endianness of the resulting wavefunction.\n\n    Returns:\n        A list of Counter objects where each key represents a bitstring\n        and its value the number of times it has been sampled from the given wave function.\n    \"\"\"\n    validate_values_and_state(state, circuit.abstract.n_qubits, param_values)\n    return self._run(circuit, param_values, state, endianness, *args, **kwargs)\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration","title":"<code>Configuration</code>  <code>dataclass</code>","text":"<p>             Bases: <code>BackendConfiguration</code></p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.algo_hevo","title":"<code>algo_hevo: AlgoHEvo = AlgoHEvo.EXP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Determine which kind of Hamiltonian evolution algorithm to use.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.loop_expectation","title":"<code>loop_expectation: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>When computing batches of expectation values, only allocate one wavefunction.</p> <p>Loop over the batch of parameters to only allocate a single wavefunction at any given time.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.n_steps_hevo","title":"<code>n_steps_hevo: int = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default number of steps for the Hamiltonian evolution.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_gradient_checkpointing","title":"<code>use_gradient_checkpointing: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use gradient checkpointing.</p> <p>Recommended for higher-order optimization tasks.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.config.Configuration.use_single_qubit_composition","title":"<code>use_single_qubit_composition: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Composes chains of single qubit gates into a single matmul if possible.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.supported_gates","title":"<code>supported_gates = list(set(OpName.list()) - set([OpName.TDAGGER]))</code>  <code>module-attribute</code>","text":"<p>The set of supported gates.</p> <p>Tdagger is currently not supported.</p>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQComposedBlock","title":"<code>PyQComposedBlock(ops, qubits, n_qubits, config=None)</code>","text":"<p>             Bases: <code>QuantumCircuit</code></p> <p>Compose a chain of single qubit operations on the same qubit into a single.</p> <p>call to _apply_batch_gate.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    ops: list[Module],\n    qubits: Tuple[int, ...],\n    n_qubits: int,\n    config: Configuration = None,\n):\n    \"\"\"Compose a chain of single qubit operations on the same qubit into a single.\n\n    call to _apply_batch_gate.\n    \"\"\"\n    super().__init__(n_qubits, ops)\n    self.qubits = qubits\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution","title":"<code>PyQHamiltonianEvolution(qubit_support, n_qubits, block, config)</code>","text":"<p>             Bases: <code>Module</code></p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def __init__(\n    self,\n    qubit_support: Tuple[int, ...],\n    n_qubits: int,\n    block: TimeEvolutionBlock,\n    config: Configuration,\n):\n    super().__init__()\n    self.qubit_support = qubit_support\n    self.n_qubits = n_qubits\n    self.param_names = config.get_param_name(block)\n    self.block = block\n    self.hmat: Tensor\n\n    if isinstance(block.generator, AbstractBlock) and not block.generator.is_parametric:\n        hmat = block_to_tensor(\n            block.generator,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self.register_buffer(\"hmat\", hmat)\n        self._hamiltonian = lambda self, values: self.hmat\n\n    elif isinstance(block.generator, Tensor):\n        m = block.generator.to(dtype=cdouble)\n        hmat = block_to_tensor(\n            MatrixBlock(m, qubit_support=block.qubit_support),\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n        )\n        hmat = hmat.permute(1, 2, 0)\n        self.register_buffer(\"hmat\", hmat)\n        self._hamiltonian = lambda self, values: self.hmat\n\n    elif isinstance(block.generator, sympy.Basic):\n        self._hamiltonian = (\n            lambda self, values: values[self.param_names[1]].squeeze(3).permute(1, 2, 0)\n        )\n        # FIXME Why are we squeezing\n    else:\n\n        def _hamiltonian(self: PyQHamiltonianEvolution, values: dict[str, Tensor]) -&gt; Tensor:\n            hmat = _block_to_tensor_embedded(\n                block.generator,  # type: ignore[arg-type]\n                values=values,\n                qubit_support=self.qubit_support,\n                use_full_support=False,\n                device=self.device,\n            )\n            return hmat.permute(1, 2, 0)\n\n        self._hamiltonian = _hamiltonian\n\n    self._time_evolution = lambda values: values[self.param_names[0]]\n    self._device: torch_device = (\n        self.hmat.device if hasattr(self, \"hmat\") else torch_device(\"cpu\")\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.dagger","title":"<code>dagger(values)</code>","text":"<p>Dagger of the evolved operator given the current parameter values.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def dagger(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Dagger of the evolved operator given the current parameter values.\"\"\"\n    return _dagger(self.unitary(values))\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_generator","title":"<code>jacobian_generator(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to generator parameter(s).</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_generator(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to generator parameter(s).\"\"\"\n    if len(self.param_names) &gt; 2:\n        raise NotImplementedError(\n            \"jacobian_generator does not support generators\\\n                                    with more than 1 parameter.\"\n        )\n\n    def _generator(val: Tensor) -&gt; Tensor:\n        val_copy = values.copy()\n        val_copy[self.param_names[1]] = val\n        hmat = _block_to_tensor_embedded(\n            self.block.generator,  # type: ignore[arg-type]\n            values=val_copy,\n            qubit_support=self.qubit_support,\n            use_full_support=False,\n            device=self.device,\n        )\n        return hmat.permute(1, 2, 0)\n\n    return finitediff(\n        lambda v: self._unitary(\n            time_evolution=self._time_evolution(values), hamiltonian=_generator(v)\n        ),\n        values[self.param_names[1]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.jacobian_time","title":"<code>jacobian_time(values)</code>","text":"<p>Approximate jacobian of the evolved operator with respect to time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def jacobian_time(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"Approximate jacobian of the evolved operator with respect to time evolution.\"\"\"\n    return finitediff(\n        lambda t: self._unitary(time_evolution=t, hamiltonian=self._hamiltonian(self, values)),\n        values[self.param_names[0]],\n    )\n</code></pre>"},{"location":"backends/pyqtorch/#qadence.backends.pyqtorch.convert_ops.PyQHamiltonianEvolution.unitary","title":"<code>unitary(values)</code>","text":"<p>The evolved operator given current parameter values for generator and time evolution.</p> Source code in <code>qadence/backends/pyqtorch/convert_ops.py</code> <pre><code>def unitary(self, values: dict[str, Tensor]) -&gt; Tensor:\n    \"\"\"The evolved operator given current parameter values for generator and time evolution.\"\"\"\n    return self._unitary(self._hamiltonian(self, values), self._time_evolution(values))\n</code></pre>"},{"location":"development/architecture/","title":"Architecture and sharp bits","text":"<p>Qadence as a software library mixes functional and object-oriented programming. We do that by maintaining core objects and operating on them with functions.</p> <p>Furthermore, Qadence strives at keeping the lower level abstraction layers for automatic differentiation and quantum computation fully stateless while only the frontend layer which is the main user-facing interface is stateful.</p> <p>Code design philosopy</p> <p>Functional, stateless core with object-oriented, stateful user interface.</p>"},{"location":"development/architecture/#abstraction-layers","title":"Abstraction layers","text":"<p>In Qadence there are 4 main objects spread across 3 different levels of abstraction:</p> <ul> <li> <p>Frontend layer: The user facing layer and encompasses two objects:</p> <ul> <li><code>QuantumCircuit</code>: A class representing an abstract quantum   circuit not tight not any particular framework. Parameters are represented symbolically using   <code>sympy</code> expressions.</li> <li><code>QuantumModel</code>: The models are higher-level abstraction   providing an interface for executing different kinds of common quantum computing models such   quantum neural networks (QNNs), quantum kernels etc.</li> </ul> </li> <li> <p>Differentiation layer: Intermediate layer has the purpose of integrating quantum   computation with a given automatic differentiation engine. It is meant to be purely stateless and   contains one object:</p> <ul> <li><code>DifferentiableBackend</code>:   An abstract class whose concrete implementation wraps a quantum backend and make it   automatically differentiable using different engines (e.g. PyTorch or Jax).   Note, that today only PyTorch is supported but there is plan to add also a Jax   differentiable backend which will require some changes in the base class implementation.</li> </ul> </li> <li> <p>Quantum layer: The lower-level layer which directly interfaces with quantum emulators   and processing units. It is meant to be purely stateless and it contains one base object which is   specialized for each supported backend:</p> <ul> <li><code>Backend</code>: An abstract class whose concrete implementation   enables the execution of quantum circuit with a variety of quantum backends (normally non   automatically differentiable by default) such as PyQTorch, Pulser or Braket.</li> </ul> </li> </ul>"},{"location":"development/architecture/#main-components","title":"Main components","text":""},{"location":"development/architecture/#quantumcircuit","title":"<code>QuantumCircuit</code>","text":"<p>We consider <code>QuantumCircuit</code> to be an abstract object, i.e. it is not tied to any backend. However, it blocks are even more abstract. This is because we consider <code>QuantumCircuit</code>s \"real\", whereas the blocks are largely considered just syntax.</p> <p>Unitary <code>QuantumCircuits</code> (this encompasses digital, or gate-based, circuits as well as analog circuits) are constructed by [<code>PrimitiveBlocks</code>] using a syntax that allows you to execute them in sequence, dubbed <code>ChainBlock</code> in the code, or in parallel (i.e. at the same time) where applicable, dubbed <code>KronBlock</code> in the code. Notice that this differs from other packages by providing more control of the layout of the circuit than conventional packages like Qiskit, and from Yao where the blocks are the primary type.</p>"},{"location":"development/architecture/#quantummodel","title":"<code>QuantumModel</code>","text":"<p><code>QuantumModel</code>s are meant to be the main entry point for quantum computations in <code>qadence</code>. In general, they take one or more quantum circuit as input and they wrap all the necessary boiler plate code to make the circuit executable and differentiable on the chosen backend.</p> <p>Models are meant to be specific for a certain kind of quantum problem or algorithm and you can easily create new ones starting from the base class <code>QuantumModel</code>, as explained in the custom model tutorial. Currently, Qadence offers a <code>QNN</code> model class which provides convenient methods to work with quantum neural networks with multi-dimensional inputs and outputs.</p>"},{"location":"development/architecture/#differentiablebackend","title":"<code>DifferentiableBackend</code>","text":"<p>The differentiable backend is a thin wrapper which takes as input a <code>QuantumCircuit</code> instance and a chosen quantum backend and make the circuit execution routines (expectation value, overalap, etc.) differentiable. Qadence offers both a PyTorch and Jax differentiation engine.</p>"},{"location":"development/architecture/#quantum-backend","title":"Quantum <code>Backend</code>","text":"<p>For execution the primary object is the <code>Backend</code>. Backends maintain the same user-facing interface, and internally connects to other libraries to execute circuits. Those other libraries can execute the code on QPUs and local or cloud-based emulators. The <code>Backends</code> use PyTorch tensors to represent data and leverages PyTorchs autograd to help compute derivatives of circuits.</p>"},{"location":"development/architecture/#symbolic-parameters","title":"Symbolic parameters","text":"<p>To illustrate how parameters work in Qadence, let's consider the following simple block composed of just two rotations:</p> <pre><code>import sympy\nfrom qadence import Parameter, RX\n\nparam = Parameter(\"phi\", trainable=False)\nblock = RX(0, param) * RX(1, sympy.acos(param))\n</code></pre> <p>The rotation angles assigned to <code>RX</code> (and to any Qadence quantum operation) are defined as arbitrary expressions of <code>Parameter</code>'s. <code>Parameter</code> is a subclass of <code>sympy.Symbol</code>, thus fully interoperable with it.</p> <p>To assign values of the parameter <code>phi</code> in a quantum model, one should use a dictionary containing the a key with parameter name and the corresponding values values:</p> <pre><code>import torch\nfrom qadence import run\n\nvalues = {\"phi\": torch.rand(10)}\nwf = run(block, values=values)\n</code></pre> <p>This is the only interface for parameter assignment exposed to the user. Under the hood, parameters applied to every quantum operation are identified in different ways:</p> <ul> <li> <p>By default, with a stringified version of the <code>sympy</code> expression supplied to the quantum operation. Notice that multiple operations can have the same expression.</p> </li> <li> <p>In certain case, e.g. for constructing parameter shift rules, one must access a unique identifier of the parameter for each quantum operation. Therefore, Qadence also creates unique identifiers for each parametrized operation (see the <code>ParamMap</code> class).</p> </li> </ul> <p>By default, when one constructs a new backend, the parameter identifiers are the <code>sympy</code> expressions which are used when converting an abstract block into a native circuit for the chosen backend. However, one can use the unique identifiers as parameter names by setting the private flag <code>_use_gate_params</code> to <code>True</code> in the backend configuration <code>BackendConfiguration</code>. This is automatically set when PSR differentiation is selected (see next section for more details).</p> <p>You can see the logic for choosing the parameter identifier in <code>get_param_name</code>.</p>"},{"location":"development/architecture/#differentiation-with-parameter-shift-rules-psr","title":"Differentiation with parameter shift rules (PSR)","text":"<p>In Qadence, parameter shift rules are applied by implementing a custom <code>torch.autograd.Function</code> class for PyTorch and the <code>custom_vjp</code> in the Jax Engine, respectively.</p> <p>A custom PyTorch <code>Function</code> looks like this:</p> <pre><code>import torch\nfrom torch.autograd import Function\n\nclass CustomFunction(Function):\n\n    # forward pass implementation giving the output of the module\n    @staticmethod\n    def forward(ctx, inputs: torch.Tensor, params: torch.Tensor):\n        ctx.save_for_backward(inputs, params)\n        ...\n\n    # backward pass implementation giving the derivative of the module\n    # with respect to the parameters. This must return the whole vector-jacobian\n    # product to integrate within the autograd engine\n    @staticmethod\n    def backward(ctx, grad_output: torch.Tensor):\n        inputs, params = ctx.saved_tensors\n        ...\n</code></pre> <p>The class <code>PSRExpectation</code> under <code>qadence.engines.torch.differentiable_expectation</code> implements parameter shift rules for all parameters using a custom function as the one above. There are a few implementation details to keep in mind if you want to modify the PSR code:</p> <ul> <li> <p>PyTorch <code>Function</code> only works with tensor arguments. Parameters in Qadence are passed around as   dictionaries with parameter names as keys and current parameter values (tensors)   as values. This works for both variational and feature parameters. However, the <code>Function</code> class   only work with PyTorch tensors as input, not dictionaries. Therefore, the forward pass of   <code>PSRExpectation</code> accepts one argument <code>param_keys</code> with the   parameter keys and a variadic positional argument <code>param_values</code> with the parameter values one by   one. The dictionary is reconstructed within the <code>forward()</code> pass body.</p> </li> <li> <p>Higher-order derivatives with PSR. Higher-order PSR derivatives can be tricky. Parameter shift   rules calls, under the hood, the <code>QuantumBackend</code> expectation value routine that usually yield a   non-differentiable output. Therefore, a second call to the backward pass would not work. However,   Qadence employs a very simple trick to make higher-order derivatives work: instead of using   directly the expectation value of the quantum backend, the PSR backward pass uses the PSR forward   pass itself as expectation value function (see the code below). In this way, multiple calls to the   backward pass are allowed since the <code>expectation_fn</code> routine is always differentiable by   definition. Notice that this implementation is simple but suboptimal since, in some corner cases,   higher-order derivates might include some repeated terms that, with this implementation, are   always recomputed.</p> </li> </ul> <pre><code># expectation value used in the PSR backward pass\ndef expectation_fn(params: dict[str, Tensor]) -&gt; Tensor:\n    return PSRExpectation.apply(\n        ctx.expectation_fn,\n        ctx.param_psrs,\n        params.keys(),\n        *params.values(),\n    )\n</code></pre> <ul> <li> <p>Operation parameters must be uniquely identified for PSR to work. Parameter shift rules work at the level of individual quantum operations. This means that, given a parameter <code>x</code>, one needs to sum the contributions from shifting the parameter values of all the operation where the parameter <code>x</code> appears. When constructing the PSR rules, one must access a unique parameter identifier for each operation even if the corresponding user-facing parameter is the same. Therefore, when PSR differentiation is selected, the flag <code>_use_gate_params</code> is automatically set to <code>True</code> in the backend configuration <code>BackendConfiguration</code> (see previous section).</p> </li> <li> <p>PSR must not be applied to observable parameters. In Qadence, Pauli observables can also be parametrized. However, the tunable parameters of observables are purely classical and should not be included in the differentiation with PSRs. However, the quantum expectation value depends on them, thus they still need to enter into the PSR evaluation. To solve this issue, the code sets the <code>requires_grad</code> attribute of all observable parameters to <code>False</code> when constructing the PSRs for the circuit as in the snippet below:</p> </li> </ul> <pre><code>for obs in observable:\n    for param_id, _ in uuid_to_eigen(obs).items():\n        param_to_psr[param_id] = lambda x: torch.tensor([0.0], requires_grad=False)\n</code></pre>"},{"location":"development/draw/","title":"<code>qadence.draw</code> example plots","text":"<p>Mostly for quick, manual checking of correct plotting output.</p> <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\n</code></pre> %3 ea3a6fc0965747489971340ca700abbb 0 db7a05854d814498b9780d20919ef1a7 X ea3a6fc0965747489971340ca700abbb--db7a05854d814498b9780d20919ef1a7 5683bb9e20c74be0915df738c0779c02 1 c31ab21b738f4b0688330d98d16f9f79 db7a05854d814498b9780d20919ef1a7--c31ab21b738f4b0688330d98d16f9f79 913c41db6acd4e5a95150a204abc3a24 7baf467ea48c4bf58ced99185f3e57cb Y 5683bb9e20c74be0915df738c0779c02--7baf467ea48c4bf58ced99185f3e57cb 7baf467ea48c4bf58ced99185f3e57cb--913c41db6acd4e5a95150a204abc3a24 <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(0))\n</code></pre> %3 ae39fff1855d4dfd9cbd494a57b18f42 0 57ade647fbf040d9b3a7443bdb7f87f9 X ae39fff1855d4dfd9cbd494a57b18f42--57ade647fbf040d9b3a7443bdb7f87f9 452c3168cc6041ee819060e9e9ab140c Y 57ade647fbf040d9b3a7443bdb7f87f9--452c3168cc6041ee819060e9e9ab140c df49b998c7ca4605b7cb5f2ce605a1bb 452c3168cc6041ee819060e9e9ab140c--df49b998c7ca4605b7cb5f2ce605a1bb <pre><code>from qadence import X, Y, chain\nfrom qadence.draw import display\n\nb = chain(X(0), Y(1))\n</code></pre> %3 35c76a38b09b404ab7204f92943fd81f 0 5efc8fe0ac754d7599fd4ea625746365 X 35c76a38b09b404ab7204f92943fd81f--5efc8fe0ac754d7599fd4ea625746365 bc881c28eec34a4cb7b8d9a3cd210bfd 1 8fc821a64c8c443181e87297c0af9d70 5efc8fe0ac754d7599fd4ea625746365--8fc821a64c8c443181e87297c0af9d70 71e9e0df97c842499b06392cfb344e59 8fc821a64c8c443181e87297c0af9d70--71e9e0df97c842499b06392cfb344e59 8b09f14e217149bc8cb0832d5fc065ed 6879edadfdbb4d3c9ece4a858444eed9 bc881c28eec34a4cb7b8d9a3cd210bfd--6879edadfdbb4d3c9ece4a858444eed9 f83f512f7e9647979466978b69d4ba15 Y 6879edadfdbb4d3c9ece4a858444eed9--f83f512f7e9647979466978b69d4ba15 f83f512f7e9647979466978b69d4ba15--8b09f14e217149bc8cb0832d5fc065ed <pre><code>from qadence import X, Y, add\nfrom qadence.draw import display\n\nb = add(X(0), Y(1), X(2))\n</code></pre> %3 cluster_ec35cc375dcf42269bb787ba7abd934a cbe4686c4ec84720b9cb0e8ed440fff9 0 2d586e12f9224bc6a04e143b1536b172 cbe4686c4ec84720b9cb0e8ed440fff9--2d586e12f9224bc6a04e143b1536b172 a974dd82799b40728d53933c1332b1d3 1 3f4bd25476804e56a8ba97d10f343fe7 2d586e12f9224bc6a04e143b1536b172--3f4bd25476804e56a8ba97d10f343fe7 0f22847e945d45f487ffc0f5bbfc8e10 541e6424765a4e24bde14a1982ea4613 AddBlock a974dd82799b40728d53933c1332b1d3--541e6424765a4e24bde14a1982ea4613 705f155ad8264c1aa76e88e5b16ceeaf 2 541e6424765a4e24bde14a1982ea4613--0f22847e945d45f487ffc0f5bbfc8e10 7af3238a476b4d28a8fbdae6572039a6 a4b18fc48fc941eb923ece6c237ad953 705f155ad8264c1aa76e88e5b16ceeaf--a4b18fc48fc941eb923ece6c237ad953 a4b18fc48fc941eb923ece6c237ad953--7af3238a476b4d28a8fbdae6572039a6 <pre><code>from qadence import CNOT, RX, HamEvo, X, Y, Z, chain, kron\n\nrx = kron(RX(3,0.5), RX(2, \"x\"))\nrx.tag = \"rx\"\ngen = chain(Z(i) for i in range(4))\n\n# `chain` puts things in sequence\nblock = chain(\n    kron(X(0), Y(1), rx),\n    CNOT(2,3),\n    HamEvo(gen, 10)\n)\n</code></pre> %3 cluster_04e93f7d607248af8982ecf149f3a7d4 cluster_63dd6987ac46423ba526207a78b77e44 rx 134732a60c914c1db0a62b680ad2155d 0 872ea326c6f24e46954e881a60de6d88 X 134732a60c914c1db0a62b680ad2155d--872ea326c6f24e46954e881a60de6d88 3f491f14ced342d69709aa615bcfce5d 1 143fabbd9e454f77b5ac95b155dd28df 872ea326c6f24e46954e881a60de6d88--143fabbd9e454f77b5ac95b155dd28df 0f5733e31b6f440898a0fb2bbaa92a50 143fabbd9e454f77b5ac95b155dd28df--0f5733e31b6f440898a0fb2bbaa92a50 da76319a5d5e4d8584937a96ae521321 0f5733e31b6f440898a0fb2bbaa92a50--da76319a5d5e4d8584937a96ae521321 5cd4999d1d344627b21a50914b2d395a 87b8aed5e9dd4fff9a8105c779cf7821 Y 3f491f14ced342d69709aa615bcfce5d--87b8aed5e9dd4fff9a8105c779cf7821 c8b019a7af5f4dfe87ac03368151ab2c 2 4a74a34b210346d2817a542ad63a905f 87b8aed5e9dd4fff9a8105c779cf7821--4a74a34b210346d2817a542ad63a905f 2f1d5928c4584aefa3381adc40373e20 HamEvo 4a74a34b210346d2817a542ad63a905f--2f1d5928c4584aefa3381adc40373e20 2f1d5928c4584aefa3381adc40373e20--5cd4999d1d344627b21a50914b2d395a d3b3181c55274d398356d7c65f198ef4 985d03af96e540f2b06c46370069aa15 RX(x) c8b019a7af5f4dfe87ac03368151ab2c--985d03af96e540f2b06c46370069aa15 4a684f8cf1694c9ea2588dcae87275a9 3 a06ac8032071489691fb9290d7ef3e5c 985d03af96e540f2b06c46370069aa15--a06ac8032071489691fb9290d7ef3e5c 9ebe407e177f46f6a3eb887ccfebda73 t = 10 a06ac8032071489691fb9290d7ef3e5c--9ebe407e177f46f6a3eb887ccfebda73 9ebe407e177f46f6a3eb887ccfebda73--d3b3181c55274d398356d7c65f198ef4 facc2d14bdaf46889108385fa0aa702b 2870dd6b73de4ab2945a5a48a30ab359 RX(0.5) 4a684f8cf1694c9ea2588dcae87275a9--2870dd6b73de4ab2945a5a48a30ab359 18245ccee0e149a5aaa261ceff74ffd9 X 2870dd6b73de4ab2945a5a48a30ab359--18245ccee0e149a5aaa261ceff74ffd9 18245ccee0e149a5aaa261ceff74ffd9--a06ac8032071489691fb9290d7ef3e5c fc0c58660ef14ce9b760685b2c7d457a 18245ccee0e149a5aaa261ceff74ffd9--fc0c58660ef14ce9b760685b2c7d457a fc0c58660ef14ce9b760685b2c7d457a--facc2d14bdaf46889108385fa0aa702b <pre><code>from qadence import feature_map, hea, chain\n\nblock = chain(feature_map(4, reupload_scaling=\"Tower\"), hea(4,2))\n</code></pre> %3 cluster_b4f8381b420b471b8b28dd680d174ec4 HEA cluster_1b00ddfbc0c54cafbd9a6619eb65fd4d Tower Fourier FM d32f26c285af4598afe5a06ec2424e57 0 80290867492f4caf87818109cffd1b45 RX(1.0*phi) d32f26c285af4598afe5a06ec2424e57--80290867492f4caf87818109cffd1b45 a9c10a3bace04b6a8a36f284c9f1b152 1 73bcc204cfc24938a06940dda6ce5fb1 RX(theta\u2080) 80290867492f4caf87818109cffd1b45--73bcc204cfc24938a06940dda6ce5fb1 448a2073db1840de8008eac87997712c RY(theta\u2084) 73bcc204cfc24938a06940dda6ce5fb1--448a2073db1840de8008eac87997712c a9ab29feb938416fa20cb2936d59df99 RX(theta\u2088) 448a2073db1840de8008eac87997712c--a9ab29feb938416fa20cb2936d59df99 f9f86dc98c7d4b78b639eb8248fe6b5b a9ab29feb938416fa20cb2936d59df99--f9f86dc98c7d4b78b639eb8248fe6b5b 1bfcac33965849fdb12e84614bb2565a f9f86dc98c7d4b78b639eb8248fe6b5b--1bfcac33965849fdb12e84614bb2565a c0ced519d0ec4b32aed5f49a5c550bb9 RX(theta\u2081\u2082) 1bfcac33965849fdb12e84614bb2565a--c0ced519d0ec4b32aed5f49a5c550bb9 4328add5de1743e1a771b115c5823d1b RY(theta\u2081\u2086) c0ced519d0ec4b32aed5f49a5c550bb9--4328add5de1743e1a771b115c5823d1b f7ac9fd4b6194d048978c8a952fb39bc RX(theta\u2082\u2080) 4328add5de1743e1a771b115c5823d1b--f7ac9fd4b6194d048978c8a952fb39bc 4397dc1bb80b4a01bd0798a7585f6e68 f7ac9fd4b6194d048978c8a952fb39bc--4397dc1bb80b4a01bd0798a7585f6e68 3a1c8b607fdd4f979759634212ae7ede 4397dc1bb80b4a01bd0798a7585f6e68--3a1c8b607fdd4f979759634212ae7ede c91b97134195411c8b9b3cf4595206d9 3a1c8b607fdd4f979759634212ae7ede--c91b97134195411c8b9b3cf4595206d9 9dff0401cecb4fbd9c48acef9eaa1fa7 e6d00184d0754bf4b90fb48e4b04e001 RX(2.0*phi) a9c10a3bace04b6a8a36f284c9f1b152--e6d00184d0754bf4b90fb48e4b04e001 15bd946dc4ec46289b5a7ca7affa9b60 2 12d1669e60f54cacacd1211be7cc9bb5 RX(theta\u2081) e6d00184d0754bf4b90fb48e4b04e001--12d1669e60f54cacacd1211be7cc9bb5 b376ed79fbce418698194afe6c507ff7 RY(theta\u2085) 12d1669e60f54cacacd1211be7cc9bb5--b376ed79fbce418698194afe6c507ff7 f698e09f9b0148419e70991fafbfa8e3 RX(theta\u2089) b376ed79fbce418698194afe6c507ff7--f698e09f9b0148419e70991fafbfa8e3 5a0c72afac834e088665148a5635b2ac X f698e09f9b0148419e70991fafbfa8e3--5a0c72afac834e088665148a5635b2ac 5a0c72afac834e088665148a5635b2ac--f9f86dc98c7d4b78b639eb8248fe6b5b 5f3cd2a8623746debd77f9311855cf38 5a0c72afac834e088665148a5635b2ac--5f3cd2a8623746debd77f9311855cf38 21252d01cb464a618c005817132ed676 RX(theta\u2081\u2083) 5f3cd2a8623746debd77f9311855cf38--21252d01cb464a618c005817132ed676 ded6779736714202a96630ef320c72bf RY(theta\u2081\u2087) 21252d01cb464a618c005817132ed676--ded6779736714202a96630ef320c72bf ab3ac6ba347b486ebf0e4ba733ad96e6 RX(theta\u2082\u2081) ded6779736714202a96630ef320c72bf--ab3ac6ba347b486ebf0e4ba733ad96e6 aeb29d144f8c476e9dad1dff535aeac7 X ab3ac6ba347b486ebf0e4ba733ad96e6--aeb29d144f8c476e9dad1dff535aeac7 aeb29d144f8c476e9dad1dff535aeac7--4397dc1bb80b4a01bd0798a7585f6e68 5deb62e7d8d04a99991f793400c73d9c aeb29d144f8c476e9dad1dff535aeac7--5deb62e7d8d04a99991f793400c73d9c 5deb62e7d8d04a99991f793400c73d9c--9dff0401cecb4fbd9c48acef9eaa1fa7 6dd74ac0cd2047c4880e2d6ccd9be73b 0bc43ab96f1c4d2884bbb9591bd4be2d RX(3.0*phi) 15bd946dc4ec46289b5a7ca7affa9b60--0bc43ab96f1c4d2884bbb9591bd4be2d b7adfcc7734144de8dfd3febd660f19c 3 6d71dfb24e6b4c54962164a6e62cc7a6 RX(theta\u2082) 0bc43ab96f1c4d2884bbb9591bd4be2d--6d71dfb24e6b4c54962164a6e62cc7a6 ba2ab0bd965244c8b5b7e0ca2fa9176a RY(theta\u2086) 6d71dfb24e6b4c54962164a6e62cc7a6--ba2ab0bd965244c8b5b7e0ca2fa9176a 1fb6babeb55d4660905f47ca93b8cdb5 RX(theta\u2081\u2080) ba2ab0bd965244c8b5b7e0ca2fa9176a--1fb6babeb55d4660905f47ca93b8cdb5 4a679f0372734c8e99a56987edc2f003 1fb6babeb55d4660905f47ca93b8cdb5--4a679f0372734c8e99a56987edc2f003 3dde3dda5c8048409722c4791145ac9c X 4a679f0372734c8e99a56987edc2f003--3dde3dda5c8048409722c4791145ac9c 3dde3dda5c8048409722c4791145ac9c--5f3cd2a8623746debd77f9311855cf38 566faa597e2f42679732457a2bc5e6b8 RX(theta\u2081\u2084) 3dde3dda5c8048409722c4791145ac9c--566faa597e2f42679732457a2bc5e6b8 42ce35b4a5ca4d3a9944f708ef3ef811 RY(theta\u2081\u2088) 566faa597e2f42679732457a2bc5e6b8--42ce35b4a5ca4d3a9944f708ef3ef811 5d54115bedda4aed9ed096597f8edd64 RX(theta\u2082\u2082) 42ce35b4a5ca4d3a9944f708ef3ef811--5d54115bedda4aed9ed096597f8edd64 ed280a78dca34999b08d2d907c67bb08 5d54115bedda4aed9ed096597f8edd64--ed280a78dca34999b08d2d907c67bb08 65a90df30f024b91b44e8ed0d92a0235 X ed280a78dca34999b08d2d907c67bb08--65a90df30f024b91b44e8ed0d92a0235 65a90df30f024b91b44e8ed0d92a0235--5deb62e7d8d04a99991f793400c73d9c 65a90df30f024b91b44e8ed0d92a0235--6dd74ac0cd2047c4880e2d6ccd9be73b fa361d61960a4c36afc55d0d44b356ca f7d7d242b9644a3495ff888333594bd5 RX(4.0*phi) b7adfcc7734144de8dfd3febd660f19c--f7d7d242b9644a3495ff888333594bd5 6e351e9c29984d81a853b820a3a239b6 RX(theta\u2083) f7d7d242b9644a3495ff888333594bd5--6e351e9c29984d81a853b820a3a239b6 d7f0ea2ba2624010873f8b4d14ef1814 RY(theta\u2087) 6e351e9c29984d81a853b820a3a239b6--d7f0ea2ba2624010873f8b4d14ef1814 87091cc10d2744689545e60826219483 RX(theta\u2081\u2081) d7f0ea2ba2624010873f8b4d14ef1814--87091cc10d2744689545e60826219483 fe1e157317c4472db09cc622ca71e709 X 87091cc10d2744689545e60826219483--fe1e157317c4472db09cc622ca71e709 fe1e157317c4472db09cc622ca71e709--4a679f0372734c8e99a56987edc2f003 d1ad482e544c42c3b843dcd570b39f23 fe1e157317c4472db09cc622ca71e709--d1ad482e544c42c3b843dcd570b39f23 a095d0660d00493eb607395fdab622a7 RX(theta\u2081\u2085) d1ad482e544c42c3b843dcd570b39f23--a095d0660d00493eb607395fdab622a7 23a0a07083474efc8ca1d6207da0a07d RY(theta\u2081\u2089) a095d0660d00493eb607395fdab622a7--23a0a07083474efc8ca1d6207da0a07d 2e0b9a092c9a45a4b5f81115141b5447 RX(theta\u2082\u2083) 23a0a07083474efc8ca1d6207da0a07d--2e0b9a092c9a45a4b5f81115141b5447 cd587883368f4292bf96b2b49cedb9e4 X 2e0b9a092c9a45a4b5f81115141b5447--cd587883368f4292bf96b2b49cedb9e4 cd587883368f4292bf96b2b49cedb9e4--ed280a78dca34999b08d2d907c67bb08 0cb47cd59b8c46ca95f94756792be519 cd587883368f4292bf96b2b49cedb9e4--0cb47cd59b8c46ca95f94756792be519 0cb47cd59b8c46ca95f94756792be519--fa361d61960a4c36afc55d0d44b356ca <pre><code>from qadence import QuantumModel, QuantumCircuit, total_magnetization, hea\n\nmodel = QuantumModel(QuantumCircuit(3, hea(3,2)), total_magnetization(3))\n</code></pre> %3 cluster_4fbd1ed68c174fcf832b4812e1055b11 Obs. cluster_f0b090275dab49d78b7fe26df98ba65c cluster_6048a57f87f84134974297c1ffd7e580 HEA b6134b79f799460eab2b7ea0334e7d0f 0 448f88f4add842c0a92590a3617c4e94 RX(theta\u2080) b6134b79f799460eab2b7ea0334e7d0f--448f88f4add842c0a92590a3617c4e94 b689e5417bdb4fab8f7e4fd59f7129c8 1 eff097ffc22e43b8bc972d597f9df750 RY(theta\u2083) 448f88f4add842c0a92590a3617c4e94--eff097ffc22e43b8bc972d597f9df750 4d227938a8684f878872733a060ac383 RX(theta\u2086) eff097ffc22e43b8bc972d597f9df750--4d227938a8684f878872733a060ac383 746ea89f60e04e9d9bdbe560653aa17a 4d227938a8684f878872733a060ac383--746ea89f60e04e9d9bdbe560653aa17a 837e1e7351654e94ab01d21bd48c75cc 746ea89f60e04e9d9bdbe560653aa17a--837e1e7351654e94ab01d21bd48c75cc 8936ab4c1d0c4b48978ba8a1cc70d54d RX(theta\u2089) 837e1e7351654e94ab01d21bd48c75cc--8936ab4c1d0c4b48978ba8a1cc70d54d 93c2eb3e4e5644dcbf66ce75e03e1b4a RY(theta\u2081\u2082) 8936ab4c1d0c4b48978ba8a1cc70d54d--93c2eb3e4e5644dcbf66ce75e03e1b4a 3a40d5458f1147748e367f5ef332a5b6 RX(theta\u2081\u2085) 93c2eb3e4e5644dcbf66ce75e03e1b4a--3a40d5458f1147748e367f5ef332a5b6 52dbd6eecd914063940fc29183ad5d96 3a40d5458f1147748e367f5ef332a5b6--52dbd6eecd914063940fc29183ad5d96 ee7cc302e6e641f4b7a0ab2b27dc26cf 52dbd6eecd914063940fc29183ad5d96--ee7cc302e6e641f4b7a0ab2b27dc26cf 8ab10f09a2ab40789651e441f4f39cfa ee7cc302e6e641f4b7a0ab2b27dc26cf--8ab10f09a2ab40789651e441f4f39cfa dc61c440a58942fe839b75780c599576 8ab10f09a2ab40789651e441f4f39cfa--dc61c440a58942fe839b75780c599576 24e295fa290b4efb956bd466c9e551ed 51eb68e70c7a4543bf39ad28fddf54ec RX(theta\u2081) b689e5417bdb4fab8f7e4fd59f7129c8--51eb68e70c7a4543bf39ad28fddf54ec 87e6483f9f5e4e548cbc2dfbcbb530c5 2 88aebf5ee8bd4df7a1f1e2b5fe9cdaa7 RY(theta\u2084) 51eb68e70c7a4543bf39ad28fddf54ec--88aebf5ee8bd4df7a1f1e2b5fe9cdaa7 4365cda80c1b4ed7bf8d2b1bdf4a9ecb RX(theta\u2087) 88aebf5ee8bd4df7a1f1e2b5fe9cdaa7--4365cda80c1b4ed7bf8d2b1bdf4a9ecb 0d22c193e310455184dee7ab43cefe97 X 4365cda80c1b4ed7bf8d2b1bdf4a9ecb--0d22c193e310455184dee7ab43cefe97 0d22c193e310455184dee7ab43cefe97--746ea89f60e04e9d9bdbe560653aa17a a0ccf87b8dce46a7a13194dc2a6f5f0a 0d22c193e310455184dee7ab43cefe97--a0ccf87b8dce46a7a13194dc2a6f5f0a c255c1a8706c4e019f88bcec4bb23037 RX(theta\u2081\u2080) a0ccf87b8dce46a7a13194dc2a6f5f0a--c255c1a8706c4e019f88bcec4bb23037 98b08abd81534f8f8d64d942bac73046 RY(theta\u2081\u2083) c255c1a8706c4e019f88bcec4bb23037--98b08abd81534f8f8d64d942bac73046 22d2bc4340784fedaf25904b91c8fc05 RX(theta\u2081\u2086) 98b08abd81534f8f8d64d942bac73046--22d2bc4340784fedaf25904b91c8fc05 15ebd7545f1c4a0899f1963500d0225a X 22d2bc4340784fedaf25904b91c8fc05--15ebd7545f1c4a0899f1963500d0225a 15ebd7545f1c4a0899f1963500d0225a--52dbd6eecd914063940fc29183ad5d96 edbee4f01b4b4ccf9928a2cee0e4c70c 15ebd7545f1c4a0899f1963500d0225a--edbee4f01b4b4ccf9928a2cee0e4c70c 6ff9ab24cae2479d94b0986337b5f661 AddBlock edbee4f01b4b4ccf9928a2cee0e4c70c--6ff9ab24cae2479d94b0986337b5f661 6ff9ab24cae2479d94b0986337b5f661--24e295fa290b4efb956bd466c9e551ed 6742838605ba44f98e45b7ec547102f1 23b7861878d742b68dc7e8a7154df128 RX(theta\u2082) 87e6483f9f5e4e548cbc2dfbcbb530c5--23b7861878d742b68dc7e8a7154df128 f64abe8fe94848eb97f963219a6b0d82 RY(theta\u2085) 23b7861878d742b68dc7e8a7154df128--f64abe8fe94848eb97f963219a6b0d82 8f7d98d5ca1441dd90f70950b4a21c11 RX(theta\u2088) f64abe8fe94848eb97f963219a6b0d82--8f7d98d5ca1441dd90f70950b4a21c11 5173262d4b2145b8a9ef247745a011bc 8f7d98d5ca1441dd90f70950b4a21c11--5173262d4b2145b8a9ef247745a011bc 9854b72903524895bf6e6b6146c4f6a8 X 5173262d4b2145b8a9ef247745a011bc--9854b72903524895bf6e6b6146c4f6a8 9854b72903524895bf6e6b6146c4f6a8--a0ccf87b8dce46a7a13194dc2a6f5f0a 0900d320f7104312aa7d5278d98eab8f RX(theta\u2081\u2081) 9854b72903524895bf6e6b6146c4f6a8--0900d320f7104312aa7d5278d98eab8f 0f04a85bcfb54757bb24501c34e51723 RY(theta\u2081\u2084) 0900d320f7104312aa7d5278d98eab8f--0f04a85bcfb54757bb24501c34e51723 c89da84eef60463cb760b5295d9c7df5 RX(theta\u2081\u2087) 0f04a85bcfb54757bb24501c34e51723--c89da84eef60463cb760b5295d9c7df5 c12396fc2e20470aadd7d0b3feced463 c89da84eef60463cb760b5295d9c7df5--c12396fc2e20470aadd7d0b3feced463 7e4d229742e34d2186e0199af6147675 X c12396fc2e20470aadd7d0b3feced463--7e4d229742e34d2186e0199af6147675 7e4d229742e34d2186e0199af6147675--edbee4f01b4b4ccf9928a2cee0e4c70c 0579517ba25141d98a405cb152b305fc 7e4d229742e34d2186e0199af6147675--0579517ba25141d98a405cb152b305fc 0579517ba25141d98a405cb152b305fc--6742838605ba44f98e45b7ec547102f1 <pre><code>from qadence import *\n\nb = chain(SWAP(0,1), SWAP(0,3))\n</code></pre> %3 fa30a9550f7542c8933ab6c989ebdcce 0 1539e49d52f44801942c94d1dde32c02 fa30a9550f7542c8933ab6c989ebdcce--1539e49d52f44801942c94d1dde32c02 c0185a6e7b4844cfbf17142283ccb3b0 1 ff6a2fd9cd234bc7a379ffae11f5cb37 21affcd21b7b4d29abc5fd04056cefd2 1539e49d52f44801942c94d1dde32c02--21affcd21b7b4d29abc5fd04056cefd2 6059256caa5240f7b700903544bd9feb ff6a2fd9cd234bc7a379ffae11f5cb37--6059256caa5240f7b700903544bd9feb 6ff135b9235e43b9b7e5115bbcb6998b 2618114e80c74ca494aa6700b6efa1b3 6059256caa5240f7b700903544bd9feb--2618114e80c74ca494aa6700b6efa1b3 fda47add550247f680bfd55086f99963 6ff135b9235e43b9b7e5115bbcb6998b--fda47add550247f680bfd55086f99963 bc4ebd293c36482bbb495d76368fadd0 e07b8c34c0744c87b6624f7e589f58ba c0185a6e7b4844cfbf17142283ccb3b0--e07b8c34c0744c87b6624f7e589f58ba b6b7ce55ff5e401db06f08e3e6cacd15 2 e07b8c34c0744c87b6624f7e589f58ba--ff6a2fd9cd234bc7a379ffae11f5cb37 2b399b548eed4c259a8dd907bf2ba445 21affcd21b7b4d29abc5fd04056cefd2--2b399b548eed4c259a8dd907bf2ba445 00b91461101f4ce488e7bbfd66098de0 2b399b548eed4c259a8dd907bf2ba445--00b91461101f4ce488e7bbfd66098de0 00b91461101f4ce488e7bbfd66098de0--bc4ebd293c36482bbb495d76368fadd0 987295ade70445268b12337c5b2caea3 b58b644fc14f447cb71ba37c7b646e1c b6b7ce55ff5e401db06f08e3e6cacd15--b58b644fc14f447cb71ba37c7b646e1c 63934f0ed1804500a63041c494fdfdec 3 26eb604a2854413eb73c7fdcc8d9c837 b58b644fc14f447cb71ba37c7b646e1c--26eb604a2854413eb73c7fdcc8d9c837 c368ea135d8849a0b3cbaf512163e37b 26eb604a2854413eb73c7fdcc8d9c837--c368ea135d8849a0b3cbaf512163e37b 120d74383355434a929d73ad68bba56a c368ea135d8849a0b3cbaf512163e37b--120d74383355434a929d73ad68bba56a 120d74383355434a929d73ad68bba56a--987295ade70445268b12337c5b2caea3 f50fec0f037345d8a9c32d012b96002d 6a5f6016da6c4bde99b8edb5e4954797 63934f0ed1804500a63041c494fdfdec--6a5f6016da6c4bde99b8edb5e4954797 eefe3512f35c43d08ac75a1c3cf47235 6a5f6016da6c4bde99b8edb5e4954797--eefe3512f35c43d08ac75a1c3cf47235 b27940b82c5c404fa04943716ffbd21e eefe3512f35c43d08ac75a1c3cf47235--b27940b82c5c404fa04943716ffbd21e b27940b82c5c404fa04943716ffbd21e--6ff135b9235e43b9b7e5115bbcb6998b 2618114e80c74ca494aa6700b6efa1b3--f50fec0f037345d8a9c32d012b96002d <pre><code>from qadence import *\n\nb = chain(CPHASE(0, 1, 0.5), CPHASE(0, 2, 0.5), CPHASE(0, 3, 0.5))\n</code></pre> %3 83040ccde2be4f31870a7cfdaac9bc9c 0 2736c6b575f04ec3a48ede1744540b54 83040ccde2be4f31870a7cfdaac9bc9c--2736c6b575f04ec3a48ede1744540b54 9db970487e5e4d528022e10cd7053b0f 1 328202458c804bb59f58e244ef29ccb9 2736c6b575f04ec3a48ede1744540b54--328202458c804bb59f58e244ef29ccb9 ace96c0424f54910b08901a852125e81 328202458c804bb59f58e244ef29ccb9--ace96c0424f54910b08901a852125e81 161787a80dd844258cb401057868c4a5 ace96c0424f54910b08901a852125e81--161787a80dd844258cb401057868c4a5 fe5f5e791bd145908821443a8db5ed8a 39aa94b1ecd9434fa427034245e188b3 PHASE(0.5) 9db970487e5e4d528022e10cd7053b0f--39aa94b1ecd9434fa427034245e188b3 6d384ea2418e44a09b3610ab9e275e12 2 39aa94b1ecd9434fa427034245e188b3--2736c6b575f04ec3a48ede1744540b54 a876973252b64ea298edef36fff9fc9c 39aa94b1ecd9434fa427034245e188b3--a876973252b64ea298edef36fff9fc9c 969f341bfb13404caf849a8e2410b0a7 a876973252b64ea298edef36fff9fc9c--969f341bfb13404caf849a8e2410b0a7 969f341bfb13404caf849a8e2410b0a7--fe5f5e791bd145908821443a8db5ed8a 6290b7efc231487b8fdc02c5e9829231 02bf8718ba37465b9a2e1ccc224de327 6d384ea2418e44a09b3610ab9e275e12--02bf8718ba37465b9a2e1ccc224de327 c008d45dfd0f44ae97e827d86f2cd47b 3 bfb2e972afed4e9082d814ba097df7e8 PHASE(0.5) 02bf8718ba37465b9a2e1ccc224de327--bfb2e972afed4e9082d814ba097df7e8 bfb2e972afed4e9082d814ba097df7e8--328202458c804bb59f58e244ef29ccb9 bd111215190c4c509bf1537d9819315b bfb2e972afed4e9082d814ba097df7e8--bd111215190c4c509bf1537d9819315b bd111215190c4c509bf1537d9819315b--6290b7efc231487b8fdc02c5e9829231 464d127c928b4ecbbab91d366488cf1c 42403c8af8eb4ad4b0e0533835b84057 c008d45dfd0f44ae97e827d86f2cd47b--42403c8af8eb4ad4b0e0533835b84057 d05ef54029864f2ba20361262b23738d 42403c8af8eb4ad4b0e0533835b84057--d05ef54029864f2ba20361262b23738d c326ae7d7c714ce9a5036392dec25539 PHASE(0.5) d05ef54029864f2ba20361262b23738d--c326ae7d7c714ce9a5036392dec25539 c326ae7d7c714ce9a5036392dec25539--ace96c0424f54910b08901a852125e81 c326ae7d7c714ce9a5036392dec25539--464d127c928b4ecbbab91d366488cf1c"},{"location":"development/draw/#developer-documentation","title":"Developer documentation","text":"<p>This section contains examples in pure graphviz that can be used to understand roughly what is done in the actual drawing backend.</p> <pre><code>import graphviz\n\nfont_name = \"Sans-Serif\"\nfont_size = \"8\"\n\ngraph_attr = {\n    \"rankdir\": \"LR\",  # LR = left to right, TB = top to bottom\n    \"nodesep\": \"0.1\",  # In inches, tells distance between nodes without edges\n    \"compound\": \"true\",  # Needed to draw properly edges in hamevo when content is hidden\n    \"splines\": \"false\",  # Needed to draw control gates vertical lines one over the other\n}  # These are the default values for graphs\n\nnode_attr = {\n    \"shape\": \"box\",  # 'box' for normal nodes, 'point' for control gates or 'plaintext' for starting nodes (the qubit label).\n    \"style\": \"rounded\",  # Unfortunately we can't specify the radius of the rounded, at least for this version\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"width\": \"0.1\",  # In inches, it doesn't get tinier than the label font.\n    \"height\": \"0.1\"  # In inches, it doesn't get tinier than the label font.\n}  # These are the defaults values that can be overridden at node declaration.\n\ndefault_cluster_attr = {\n    \"fontname\": font_name,\n    \"fontsize\": font_size,\n    \"labelloc\": \"b\",  # location of cluster label. b as bottom, t as top\n    \"style\": \"rounded\"\n} # These are the defaults values that can be overridden at sub graph declaration\n\nhamevo_cluster_attr = {\n    \"label\": \"HamEvo(t=10)\"\n}\nhamevo_cluster_attr.update(default_cluster_attr)\n\nh = graphviz.Graph(graph_attr=graph_attr, node_attr=node_attr)\nh.node(\"Hello World!\")\nh\n</code></pre> <pre><code>\n</code></pre> <pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Add start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Add nodes\nh.node('X', group=\"0\")\nh.node('Y', group=\"1\")\n\n# Add hamevo and its nodes\nhamevo = graphviz.Graph(name='cluster_hamevo', graph_attr=hamevo_cluster_attr)\nfor i in range(4):\n    hamevo.node(f'z{i}', shape=\"box\", style=\"invis\", label=f'{i}', group=f\"{i}\")\nh.subgraph(hamevo)\n\n# Add rx gates cluster and its nodes\ncluster_attr = {\"label\": \"RX gates\"}\ncluster_attr.update(default_cluster_attr)\ncluster = graphviz.Graph(name=\"cluster_0\", graph_attr=cluster_attr)\ncluster.node('RX(x)', group=\"2\")\ncluster.node('RX(0.5)', group=\"3\")\nh.subgraph(cluster)\n\nh.node('cnot0', label='', shape='point', width='0.1', group='0')\nh.node('cnot1', label='X', group='1')\nh.node('cnot2', label='', shape='point', width='0.1', group='2')\nh.node('cnot3', label='', shape='point', width='0.1', group='3')\n\n# Add edges\nh.edge('s0', 'X')\nh.edge('X', 'cnot0')\nh.edge('cnot0', 'z0', lhead='cluster_hamevo')\nh.edge('z0', 'e0', ltail='cluster_hamevo')\nh.edge('s1', 'Y')\nh.edge('Y', 'cnot1')\nh.edge('cnot1', 'z1', lhead='cluster_hamevo')\nh.edge('z1', 'e1', ltail='cluster_hamevo')\nh.edge('s2', 'RX(x)')\nh.edge('RX(x)', 'cnot2')\nh.edge('cnot2', 'z2', lhead='cluster_hamevo')\nh.edge('z2', 'e2', ltail='cluster_hamevo')\nh.edge('s3', 'RX(0.5)')\nh.edge('RX(0.5)', 'cnot3')\nh.edge('cnot3', 'z3', lhead='cluster_hamevo')\nh.edge('z3', 'e3', ltail='cluster_hamevo')\nh.edge('cnot1', 'cnot0', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot2', constraint='false')  # constraint: false is needed to draw vertical edges\nh.edge('cnot1', 'cnot3', constraint='false')  # constraint: false is needed to draw vertical edges\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"development/draw/#example-of-cluster-of-clusters","title":"Example of cluster of clusters","text":"<pre><code># Define graph\nh = graphviz.Graph(node_attr=node_attr, graph_attr=graph_attr)\n\n# Define start and end nodes\nfor i in range(4):\n    h.node(f's{i}', shape=\"plaintext\", label=f'{i}', group=f\"{i}\")\n    h.node(f'e{i}', style='invis', group=f\"{i}\")\n\n# Define outer cluster\ncluster_attr = {\"label\": \"Outer cluster\"}\ncluster_attr.update(default_cluster_attr)\nouter_cluster = graphviz.Graph(name=\"cluster_outer\", graph_attr=cluster_attr)\n\n# Define inner cluster 1 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 1\"}\ncluster_attr.update(default_cluster_attr)\ninner1_cluster = graphviz.Graph(name=\"cluster_inner1\", graph_attr=cluster_attr)\ninner1_cluster.node(\"a0\", group=\"0\")\ninner1_cluster.node(\"a1\", group=\"1\")\nouter_cluster.subgraph(inner1_cluster)\n\n# Define inner cluster 2 and its nodes\ncluster_attr = {\"label\": \"Inner cluster 2\"}\ncluster_attr.update(default_cluster_attr)\ninner2_cluster = graphviz.Graph(name=\"cluster_inner2\", graph_attr=cluster_attr)\ninner2_cluster.node(\"a2\", group=\"2\")\ninner2_cluster.node(\"a3\", group=\"3\")\nouter_cluster.subgraph(inner2_cluster)\n\n# This has to be done here, after inner clusters definitions\nh.subgraph(outer_cluster)\n\n# Define more nodes\nfor i in range(4):\n    h.node(f\"b{i}\", group=f\"{i}\")\n\nfor i in range(4):\n    h.edge(f's{i}', f'a{i}')\n    h.edge(f'a{i}', f'b{i}')\n    h.edge(f'b{i}', f'e{i}')\n\nh\n</code></pre> <pre><code>\n</code></pre>"},{"location":"digital_analog_qc/","title":"Digital-Analog Quantum Computation","text":"<p>Digital-analog quantum computation (DAQC) is a universal quantum computing paradigm<sup>1</sup>, based on two primary computations:</p> <ul> <li>Fast single-qubit operations (digital).</li> <li>Multi-partite entangling operations acting on all qubits (analog).</li> </ul> <p>A promising quantum computing platform for the implementation of the DAQC paradigm is neutral-atoms, where both these computations are realizable.</p>"},{"location":"digital_analog_qc/#digital-analog-emulation","title":"Digital-analog emulation","text":"<p>Qadence simplifies the execution of DAQC programs on either emulated or real devices by providing a simplified interface for customizing interactions and interfacing with pulse-level programming in <code>Pulser</code><sup>3</sup>.</p>"},{"location":"digital_analog_qc/#digital-analog-transformation","title":"Digital-analog transformation","text":"<p>Furthermore, the essence of digital-analog computation is the ability to represent any analog operation, i.e. any arbitrary Hamiltonian, using an auxiliary device-amenable Hamiltonian, such as the ubiquitous Ising model<sup>2</sup>. This is at the core of the DAQC implementation in Qadence.</p>"},{"location":"digital_analog_qc/#execution-on-rydberg-atom-arrays-with-restriced-addressability","title":"Execution on Rydberg atom arrays with restriced addressability","text":"<p>Finally, Qadence offers some convenience constructors and interfaces to execute programs compatible with a DAQC flavor featuring only a restricted access to individual qubit addressability with always-on interaction. This regime is common in currently available neutral atom quantum computers.</p>"},{"location":"digital_analog_qc/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/analog-basics/","title":"Basic operations on neutral-atoms","text":"<p>Warning</p> <p>The digital-analog emulation framework is under construction and more changes to the interface may still occur.</p> <p>Qadence includes primitives for the construction of programs implemented on a set of interacting qubits. The goal is to build digital-analog programs that better represent the reality of interacting qubit platforms, such as neutral-atoms, while maintaining a simplified interface for users coming from a digital quantum computing background that may not be as familiar with pulse-level programming.</p> <p>To build the intuition for the interface in Qadence, it is important to go over some of the underlying physics. We can write a general Hamiltonian for a set of \\(n\\) interacting qubits as</p> \\[ \\mathcal{H} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right), \\] <p>where the driving Hamiltonian \\(\\mathcal{H}^\\text{d}_{i}\\) describes the pulses used to control single-qubit rotations, and the interaction Hamiltonian \\(\\mathcal{H}^\\text{int}_{ij}\\) describes the natural interaction between qubits.</p>"},{"location":"digital_analog_qc/analog-basics/#rydberg-atoms","title":"Rydberg atoms","text":"<p>For the purpose of digital-analog emulation of neutral-atom systems in Qadence, we now consider a simplified time-independent global driving Hamiltonian, written as</p> \\[ \\mathcal{H}^\\text{d}_{i} = \\frac{\\Omega}{2}\\left(\\cos(\\phi) X_i - \\sin(\\phi) Y_i \\right) - \\delta N_i \\] <p>where \\(\\Omega\\) is the Rabi frequency, \\(\\delta\\) is the detuning, \\(\\phi\\) is the phase, \\(X_i\\) and \\(Y_i\\) are the standard Pauli operators, and \\(N_i=\\frac{1}{2}(I_i-Z_i)\\) is the number operator. This Hamiltonian allows arbitrary global single-qubit rotations to be written, meaning that the values set for \\((\\Omega,\\phi,\\delta)\\) are the same accross the qubit support.</p> <p>For the interaction term, Rydberg atoms typically allow both an Ising and an XY mode of operation. For now, we focus on the Ising interaction, where the Hamiltonian is written as</p> \\[ \\mathcal{H}^\\text{int}_{ij} = \\frac{C_6}{r_{ij}^6}N_iN_j \\] <p>where \\(r_{ij}\\) is the distance between atoms \\(i\\) and \\(j\\), and \\(C_6\\) is a coefficient depending on the specific Rydberg level of the excited state used in the computational logic states. A typical value for rydberg level of 60 is \\(C_6\\approx 866~[\\text{rad} . \\mu \\text{m}^6 / \\text{ns}]\\).</p> <p>For a given register of atoms prepared in some spatial coordinates, the Hamiltonians described will generate the dynamics of some unitary operation as</p> \\[ U(t, \\Omega, \\delta, \\phi) = \\exp(-i\\mathcal{H}t) \\] <p>where we specify the final parameter \\(t\\), the duration of the operation.</p> <p>Qadence uses the following units for user-specified parameters:</p> <ul> <li>Rabi frequency and detuning \\(\\Omega\\), \\(\\delta\\): \\([\\text{rad}/\\mu \\text{s}]\\)</li> <li>Phase \\(\\phi\\): \\([\\text{rad}]\\)</li> <li>Duration \\(t\\): \\([\\text{ns}]\\)</li> <li>Atom coordinates: \\([\\mu \\text{m}]\\)</li> </ul>"},{"location":"digital_analog_qc/analog-basics/#in-practice","title":"In practice","text":"<p>Given the Hamiltonian description in the previous section, we will now go over a few examples of the standard operations available in Qadence.</p>"},{"location":"digital_analog_qc/analog-basics/#arbitrary-rotation","title":"Arbitrary rotation","text":"<p>To start, we will exemplify the a general rotation on a set of atoms. To create an arbitrary register of atoms, we refer the user to the register creation tutorial. Below, we create a line register of three qubits with a separation of \\(8~\\mu\\text{m}\\). This is a typical value used in combination with a standard experimental setup of neutral atoms such that the interaction term in the Hamiltonian can effectively be used for computations.</p> <pre><code>from qadence import Register\n\nreg = Register.line(3, spacing=8.0)  # Atom spacing in \u03bcm\n</code></pre> <p>Currently, the most general rotation operation uses the <code>AnalogRot</code> operation, which essentially implements \\(U(t, \\Omega, \\delta, \\phi)\\) defined above.</p> <pre><code>from qadence import AnalogRot, PI\n\nrot_op = AnalogRot(\n    duration = 500., # [ns]\n    omega = PI, # [rad/\u03bcs]\n    delta = PI, # [rad/\u03bcs]\n    phase = PI, # [rad]\n)\n</code></pre> <p>Note that in the code above a specific qubit support is not defined. By default this operation applies a global rotation on all qubits. We can define a circuit using the 3-qubit register and run it in the pyqtorch backend:</p> <pre><code>from qadence import BackendName, run\n\nwf = run(reg, rot_op, backend = BackendName.PYQTORCH)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> Under the hood of AnalogRot      To be fully explicit about what goes on under the hood of `AnalogRot`, we can look at the example     code below.      <pre><code>from qadence import BackendName, HamEvo, X, Y, N, add, run, PI\nfrom qadence.analog.constants import C6_DICT\nfrom math import cos, sin\n\n# Following the 3-qubit register above\nn_qubits = 3\ndx = 8.0\n\n# Parameters used in the AnalogRot\nduration = 500.\nomega = PI\ndelta = PI\nphase = PI\n\n# Building the terms in the driving Hamiltonian\nh_x = (omega / 2) * cos(phase) * add(X(i) for i in range(n_qubits))\nh_y = (-1.0 * omega / 2) * sin(phase) * add(Y(i) for i in range(n_qubits))\nh_n = -1.0 * delta * add(N(i) for i in range(n_qubits))\n\n# Building the interaction Hamiltonian\n\n# Dictionary of coefficient values for each Rydberg level, which is 60 by default\nc_6 = C6_DICT[60]\n\nh_int = c_6 * (\n    1/(dx**6) * (N(0)@N(1)) +\n    1/(dx**6) * (N(1)@N(2)) +\n    1/((2*dx)**6) * (N(0)@N(2))\n)\n\nhamiltonian = h_x + h_y + h_n + h_int\n\n# Convert duration to \u00b5s due to the units of the Hamiltonian\nexplicit_rot = HamEvo(hamiltonian, duration / 1000)\n\nwf = run(n_qubits, explicit_rot, backend = BackendName.PYQTORCH)\n\n# We get the same final wavefunction\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4248-0.2411j, -0.1687+0.3156j, -0.1696+0.2676j, -0.2040-0.2671j,\n         -0.1687+0.3156j,  0.0014-0.2721j, -0.2040-0.2671j,  0.3034-0.1130j]])\n</code></pre> <p>When sending the <code>AnalogRot</code> operation to the pyqtorch backend, Qadence automatically builds the correct Hamiltonian and the corresponding <code>HamEvo</code> operation with the added qubit interactions, as shown explicitly in the minimized section above. However, this operation is also supported in the Pulser backend, where the correct pulses are automatically created.</p> <pre><code>wf = run(\n    reg,\n    rot_op,\n    backend = BackendName.PULSER,\n)\n\nprint(wf)\n</code></pre> <pre><code>tensor([[ 0.4254-0.2408j, -0.1688+0.3157j, -0.1698+0.2678j, -0.2044-0.2666j,\n         -0.1688+0.3157j,  0.0010-0.2721j, -0.2044-0.2666j,  0.3024-0.1138j]])\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#rx-ry-rz-rotations","title":"RX / RY / RZ rotations","text":"<p>The <code>AnalogRot</code> provides full control over the parameters of \\(\\mathcal{H}^\\text{d}\\), but users coming from a digital quantum computing background may be more familiar with the standard <code>RX</code>, <code>RY</code> and <code>RZ</code> rotations, also available in Qadence. For the emulated analog interface, Qadence provides alternative <code>AnalogRX</code>, <code>AnalogRY</code> and <code>AnalogRZ</code> operations which call <code>AnalogRot</code> under the hood to represent the rotations accross the respective axis.</p> <p>For a given angle of rotation \\(\\theta\\) provided to each of these operations, currently a set of hardcoded assumptions are made on the tunable Hamiltonian parameters:</p> \\[ \\begin{aligned} \\text{RX}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = 0, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RY}:&amp; \\quad \\Omega = \\pi, \\quad \\delta = 0, \\quad \\phi = -\\pi/2, \\quad t = (\\theta/\\Omega)\\times 10^3 \\\\ \\text{RZ}:&amp; \\quad \\Omega = 0, \\quad \\delta = \\pi, \\quad \\phi = 0, \\quad t = (\\theta/\\delta)\\times 10^3 \\\\ \\end{aligned} \\] <p>Note that the \\(\\text{RZ}\\) operation as defined above includes a global phase compared to the standard \\(\\text{RZ}\\) rotation since it evolves \\(\\exp\\left(-i\\frac{\\theta}{2}\\frac{I-Z}{2}\\right)\\) instead of \\(\\exp\\left(-i\\frac{\\theta}{2}Z\\right)\\) given the detuning operator in \\(\\mathcal{H}^\\text{d}\\).</p> <p>Warning</p> <p>As shown above, the values of \\(\\Omega\\) and \\(\\delta\\) are currently hardcoded in these operators, and the effective angle of rotation is controlled by varying the duration of the evolution. Currently, the best way to overcome this is to use <code>AnalogRot</code> directly, but more general and convenient options will be provided soon in an improved interface.</p> <p>Below we exemplify the usage of <code>AnalogRX</code>:</p> <pre><code>from qadence import Register, BackendName\nfrom qadence import RX, AnalogRX, random_state, equivalent_state, kron, run, PI\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# Rotation angle\ntheta = PI\n\n# Analog rotation using the Rydberg Hamiltonian\nrot_analog = AnalogRX(angle = theta)\n\n# Equivalent full-digital global rotation\nrot_digital = kron(RX(i, theta) for i in range(n_qubits))\n\n# Some random initial state\ninit_state = random_state(n_qubits)\n\n# Compare the final state using the full digital and the AnalogRX\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\n\nwf_digital_pyq = run(\n    reg,\n    rot_digital,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_digital_pyq, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  False\n</code></pre> <p>As we can see, running a global <code>RX</code> or the <code>AnalogRX</code> does not result in equivalent states at the end, given that the digital <code>RX</code> operation does not include the interaction between the qubits. By setting <code>dx</code> very high in the code above the interaction will be less significant and the results will match.</p> <p>However, if we compare with the Pulser backend, we see that the results for <code>AnalogRX</code> are consistent with the expected results from a real device:</p> <pre><code>wf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER,\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#evolving-the-interaction-term","title":"Evolving the interaction term","text":"<p>Finally, besides applying specific qubit rotations, we can also choose to evolve only the interaction term \\(\\mathcal{H}^\\text{int}\\), equivalent to setting \\(\\Omega = \\delta = \\phi = 0\\). To do so, Qadence provides the function <code>AnalogInteraction</code> which does exactly this.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, AnalogInteraction, run\n\nn_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\nduration = 1000.\nop = AnalogInteraction(duration = duration)\n\ninit_state = random_state(n_qubits)\n\nwf_pyq = run(reg, op, state = init_state, backend = BackendName.PYQTORCH)\nwf_pulser = run(reg, op, state = init_state, backend = BackendName.PULSER)\n\nbool_equiv = equivalent_state(wf_pyq, wf_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#device-specifications-in-qadence","title":"Device specifications in Qadence","text":"<p>As a way to control other specifications of the interacting Rydberg atoms, Qadence provides a <code>RydbergDevice</code> class, which is currently used for both the pyqtorch and the pulser backends. Below we initialize a Rydberg device showcasing all the possible options.</p> <pre><code>from qadence import RydbergDevice, DeviceType, Interaction, PI\n\ndevice_specs = RydbergDevice(\n    interaction=Interaction.NN, # Or Interaction.XY, supported only for pyqtorch\n    rydberg_level=60, # Integer value affecting the C_6 coefficient\n    coeff_xy=3700.00, # C_3 coefficient for the XY interaction\n    max_detuning=2 * PI * 4, # Max value for delta, currently only used in pulser\n    max_amp=2 * PI * 3, # Max value for omega, currently only used in pulser\n    pattern=None, # Semi-local addressing pattern, see the relevant tutorial\n    type=DeviceType.IDEALIZED, # Pulser device to which the qadence device is converted in that backend\n)\n</code></pre> <p>The values above are the defaults when simply running <code>device_specs = RydbergDevice()</code>. The convenience wrappers <code>IdealDevice()</code> or <code>RealisticDevice()</code> can also be used which simply change the <code>type</code> for the Pulser backend, but also allow an <code>AddressingPattern</code> passed in the <code>pattern</code> argument (see the relevant tutorial here).</p> <p>Warning</p> <p>Currently, the options above are not fully integrated in both backends and this class should mostly be used if a user wishes to experiment with a different <code>rydberg_level</code>, or to change the device type for the pulser backend.</p> <p>Planned features to add to the RydbergDevice include the definition of custom interaction functions, the control of other drive Hamiltonian parameters so that \\(\\Omega\\), \\(\\delta\\) and \\(\\phi\\) are not hardcoded when doing analog rotations, and the usage of the <code>max_detuning</code> and <code>max_amp</code> to control those respective parameters when training models in the pyqtorch backend.</p> <p>Finally, to change a given simulation, the device specifications are integrated in the Qadence <code>Register</code>. By default, all registers initialize an <code>IdealDevice()</code> under the hood. Below we run a quick test for a different rydberg level.</p> <pre><code>from qadence import Register, BackendName, random_state, equivalent_state, run\nfrom qadence import AnalogRX, RydbergDevice, PI\n\ndevice_specs = RydbergDevice(rydberg_level = 70)\n\nn_qubits_side = 2\nreg = Register.square(\n    n_qubits_side,\n    spacing = 8.0,\n    device_specs = device_specs\n)\n\nrot_analog = AnalogRX(angle = PI)\n\ninit_state = random_state(n_qubits = 4)\n\nwf_analog_pyq = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PYQTORCH\n)\n\nwf_analog_pulser = run(\n    reg,\n    rot_analog,\n    state = init_state,\n    backend = BackendName.PULSER\n)\n\nbool_equiv = equivalent_state(wf_analog_pyq, wf_analog_pulser, atol = 1e-03)\n\nprint(\"States equivalent: \", bool_equiv)\n</code></pre> <pre><code>States equivalent:  True\n</code></pre>"},{"location":"digital_analog_qc/analog-basics/#technical-details","title":"Technical details","text":"<p>Warning</p> <p>The details described here are relevant in the current version but will be lifted soon for the next version of the emulated analog interface.</p> <p>In the previous section we have exemplified the main ingredients of the current user-facing functionalities of the emulated analog interface, and in the next tutorial on Quantum Circuit Learning we will exmplify its usage in a simple QML example. Here we specify some extra details of this interface.</p> <p>In the block system, all analog rotation operators initialize a <code>ConstantAnalogRotation</code> block, while the <code>AnalogInteraction</code> operation initializes an <code>InteractionBlock</code>. As we have shown, by default, these blocks use a global qubit support, which can be passed explicitly by setting <code>qubit_support = QubitSupportType.GLOBAL</code>. However, composing blocks using <code>kron</code> with local qubit supports and different durations is not allowed.</p> <pre><code>from qadence import AnalogRX, AnalogRY, Register, kron\n\ndx = 8.0\nreg = Register.from_coordinates([(0, 0), (dx, 0)])\n\n# Does not work (the angle affects the duration, as seen above):\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (1,))\n\ntry:\n    block = kron(rot_0, rot_1)\nexcept ValueError as error:\n    print(\"Error:\", error)\n\n# Works:\nrot_0 = AnalogRX(angle = 1.0, qubit_support = (0,))\nrot_1 = AnalogRY(angle = 1.0, qubit_support = (1,))\n\nblock = kron(rot_0, rot_1)\n</code></pre> <pre><code>Error: Kron'ed blocks have to have same duration.\n</code></pre> <p>Using <code>chain</code> is only supported between analog blocks with global qubit support:</p> <pre><code>from qadence import chain\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = \"global\")\n\nblock = chain(rot_0, rot_1)\n</code></pre> <p>The restrictions above only apply to the analog blocks, and analog and digital blocks can currently be composed.</p> <pre><code>from qadence import RX\n\nrot_0 = AnalogRX(angle = 1.0, qubit_support = \"global\")\nrot_1 = AnalogRY(angle = 2.0, qubit_support = (0,))\nrot_digital = RX(1, 1.0)\n\nblock_0 = chain(rot_0, rot_digital)\nblock_1 = kron(rot_1, rot_digital)\n</code></pre>"},{"location":"digital_analog_qc/analog-qcl/","title":"Fitting a simple function","text":"<p>Analog blocks can be parametrized in the usual Qadence manner. Like any other parameters, they can be optimized. The next snippet examplifies the creation of an analog and parameterized ansatz to fit a simple function. First, define a register and feature map block. We again use a default spacing of \\(8~\\mu\\text{m}\\) as done in the basic tutorial.</p> <pre><code>from qadence import Register, FeatureParameter, chain\nfrom qadence import AnalogRX, AnalogRY, AnalogRZ, AnalogInteraction\nfrom sympy import acos\n\n# Line register\nn_qubits = 2\nregister = Register.line(n_qubits, spacing = 8.0)\n\n# The input feature x for the circuit to learn f(x)\nx = FeatureParameter(\"x\")\n\n# Feature map with a few global analog rotations\nfm = chain(\n    AnalogRX(x),\n    AnalogRY(2*x),\n    AnalogRZ(3*x),\n)\n</code></pre> <p>Next, we define the ansatz with parameterized rotations.</p> <pre><code>from qadence import hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel, BackendName, DiffMode\nfrom qadence import VariationalParameter\n\nt_0 = 1000. * VariationalParameter(\"t_0\")\nt_1 = 1000. * VariationalParameter(\"t_1\")\nt_2 = 1000. * VariationalParameter(\"t_2\")\n\n# Creating the ansatz with parameterized rotations and wait time\nansatz = chain(\n    AnalogRX(\"tht_0\"),\n    AnalogRY(\"tht_1\"),\n    AnalogRZ(\"tht_2\"),\n    AnalogInteraction(t_0),\n    AnalogRX(\"tht_3\"),\n    AnalogRY(\"tht_4\"),\n    AnalogRZ(\"tht_5\"),\n    AnalogInteraction(t_1),\n    AnalogRX(\"tht_6\"),\n    AnalogRY(\"tht_7\"),\n    AnalogRZ(\"tht_8\"),\n    AnalogInteraction(t_2),\n)\n</code></pre> <p>We define the measured observable as the total magnetization, and build the <code>QuantumModel</code>.</p> <pre><code># Total magnetization observable\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Defining the circuit and observable\ncircuit = QuantumCircuit(register, fm, ansatz)\n\nmodel = QuantumModel(\n    circuit,\n    observable = observable,\n    backend = BackendName.PYQTORCH,\n    diff_mode = DiffMode.AD\n)\n</code></pre> <p>Now we can define the function to fit as well as our training and test data.</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\n\n# Function to fit:\ndef f(x):\n    return x**2\n\nx_test = torch.linspace(-1.0, 1.0, steps=100)\ny_test = f(x_test)\n\nx_train = torch.linspace(-1.0, 1.0, steps=10)\ny_train = f(x_train)\n\n# Initial prediction from the model, to be visualized later\ny_pred_initial = model.expectation({\"x\": x_test}).detach()\n</code></pre> <p>Finally we define a simple loss function and training loop.</p> <pre><code>mse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(x_train, y_train):\n    out = model.expectation({\"x\": x_train})\n    loss = mse_loss(out.squeeze(), y_train)\n    return loss\n\nn_epochs = 200\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_fn(x_train, y_train)\n    loss.backward()\n    optimizer.step()\n</code></pre> <p>And with the model trained we can plot the final results.</p> <pre><code>y_pred_final = model.expectation({\"x\": x_test}).detach()\n\nplt.plot(x_test, y_pred_initial, label = \"Initial prediction\")\nplt.plot(x_test, y_pred_final, label = \"Final prediction\")\nplt.scatter(x_train, y_train, label = \"Training points\")\n</code></pre> 2024-02-15T16:11:34.843714 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/","title":"Solve a QUBO problem","text":"<p>In this notebook, we solve a quadratic unconstrained binary optimization (QUBO) problem with Qadence. QUBOs are very popular combinatorial optimization problems with a wide range of applications. Here, we solve the problem using the QAOA <sup>1</sup> variational algorithm by embedding the QUBO problem weights onto a register as standard for neutral atom quantum devices.</p> <p>Additional background information on QUBOs can be found here, directly solved using the pulse-level interface Pulser.</p>"},{"location":"digital_analog_qc/analog-qubo/#define-and-solve-qubo","title":"Define and solve QUBO","text":"Pre-requisite: optimal register coordinates for embedding the QUBO problem <p>A basic ingredient for solving a QUBO problem with a neutral atom device is to embed the problem onto the atomic register. In short, embedding algorithms cast the problem onto a graph mapped onto the register by optimally finding atomic coordinates. A discussion on the embedding algorithms is beyond the scope of this tutorial and a simplified version taken from here is added below.</p> <p><pre><code>import numpy as np\nimport numpy.typing as npt\nfrom scipy.optimize import minimize\nfrom scipy.spatial.distance import pdist, squareform\nfrom qadence import RydbergDevice\n\ndef qubo_register_coords(Q: np.ndarray, device: RydbergDevice) -&gt; list:\n    \"\"\"Compute coordinates for register.\"\"\"\n\n    def evaluate_mapping(new_coords, *args):\n        \"\"\"Cost function to minimize. Ideally, the pairwise\n        distances are conserved\"\"\"\n        Q, shape = args\n        new_coords = np.reshape(new_coords, shape)\n        interaction_coeff = device.rydberg_level\n        new_Q = squareform(interaction_coeff / pdist(new_coords) ** 6)\n        return np.linalg.norm(new_Q - Q)\n\n    shape = (len(Q), 2)\n    np.random.seed(0)\n    x0 = np.random.random(shape).flatten()\n    res = minimize(\n        evaluate_mapping,\n        x0,\n        args=(Q, shape),\n        method=\"Nelder-Mead\",\n        tol=1e-6,\n        options={\"maxiter\": 200000, \"maxfev\": None},\n    )\n    return [(x, y) for (x, y) in np.reshape(res.x, (len(Q), 2))]\n</code></pre> </p> <p>With the embedding routine under our belt, let's start by adding the required imports and ensure the reproducibility of this tutorial.</p> <pre><code>import torch\nfrom qadence import QuantumModel, QuantumCircuit, Register\nfrom qadence import RydbergDevice, AnalogRX, AnalogRZ, chain\nfrom qadence.ml_tools import train_gradient_free, TrainConfig, num_parameters\nimport nevergrad as ng\nimport matplotlib.pyplot as plt\n\nseed = 0\nnp.random.seed(seed)\ntorch.manual_seed(seed)\n</code></pre> <p>The QUBO problem is initially defined by a graph of weighted edges and a cost function to be optimized. The weighted edges are represented by a real-valued symmetric matrix <code>Q</code> which is used throughout the tutorial.</p> <pre><code># QUBO problem weights (real-value symmetric matrix)\nQ = np.array(\n    [\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n    ]\n)\n\ndef loss(model: QuantumModel, *args) -&gt; tuple[float, dict]:\n    to_arr_fn = lambda bitstring: np.array(list(bitstring), dtype=int)\n    cost_fn = lambda arr: arr.T @ Q @ arr\n    samples = model.sample({}, n_shots=1000)[0]  # extract samples\n    cost_fn = sum(samples[key] * cost_fn(to_arr_fn(key)) for key in samples)\n    return cost_fn / sum(samples.values()), {}  # We return an optional metrics dict\n</code></pre> <p>The QAOA algorithm needs a variational quantum circuit with optimizable parameters. For that purpose, we use a fully analog circuit composed of two global rotations per layer on different axes of the Bloch sphere. The first rotation corresponds to the mixing Hamiltonian and the second one to the embedding Hamiltonian <sup>1</sup>. In this setting, the embedding is realized by the appropriate register coordinates and the resulting qubit interaction.</p> Rydberg level <p>The Rydberg level is set to 70. We initialize the weighted register graph from the QUBO definition similarly to what is done in the original tutorial, and set the device specifications with the updated Rydberg level.</p> <pre><code># Device specification and atomic register\ndevice = RydbergDevice(rydberg_level=70)\n\nreg = Register.from_coordinates(\n    qubo_register_coords(Q, device), device_specs=device\n)\n\n# Analog variational quantum circuit\nlayers = 2\nblock = chain(*[AnalogRX(f\"t{i}\") * AnalogRZ(f\"s{i}\") for i in range(layers)])\ncircuit = QuantumCircuit(reg, block)\n</code></pre> <pre><code>\n</code></pre> <p>By feeding the circuit to a <code>QuantumModel</code> we can check the initial counts where no clear solution can be found:</p> <pre><code>model = QuantumModel(circuit)\ninitial_counts = model.sample({}, n_shots=1000)[0]\n</code></pre> <pre><code>initial_counts = Counter({'01000': 197, '00001': 193, '00010': 189, '00100': 174, '10000': 169, '00000': 78})\n</code></pre> <p>Finally, we can proceed with the variational optimization. The cost function defined above is derived from bitstring computations and therefore non differentiable. We use Qadence ML facilities to run gradient-free optimizations using the <code>nevergrad</code> library.</p> <pre><code>config = TrainConfig(max_iter=100)\noptimizer = ng.optimizers.NGOpt(\n    budget=config.max_iter, parametrization=num_parameters(model)\n)\ntrain_gradient_free(model, None, optimizer, config, loss)\n\noptimal_counts = model.sample({}, n_shots=1000)[0]\n</code></pre>   optimal_count = Counter({'00100': 191, '10000': 190, '00001': 183, '01000': 181, '00010': 163, '00000': 92})    <p>Finally, let's plot the solution. The expected bitstrings are marked in red.</p> <pre><code># Known solutions to the QUBO problem.\nsolution_bitstrings = [\"01011\", \"00111\"]\n\ndef plot_distribution(C, ax, title):\n    C = dict(sorted(C.items(), key=lambda item: item[1], reverse=True))\n    indexes = solution_bitstrings # QUBO solutions\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in C}\n    ax.set_xlabel(\"bitstrings\")\n    ax.set_ylabel(\"counts\")\n    ax.set_xticks([i for i in range(len(C.keys()))], C.keys(), rotation=90)\n    ax.bar(list(C.keys())[:20], list(C.values())[:20])\n    ax.set_title(title)\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 4))\nplot_distribution(initial_counts, axs[0], \"Initial counts\")\nplot_distribution(optimal_counts, axs[1], \"Optimal counts\")\n</code></pre> 2024-02-15T16:11:36.730232 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/analog-qubo/#references","title":"References","text":"<ol> <li> <p>Edward Farhi, Jeffrey Goldstone, Sam Gutmann, A Quantum Approximate Optimization Algorithm, arXiv:1411.4028 (2014) \u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/daqc-cnot/","title":"<code>CNOT</code> with interacting qubits","text":"<p>Digital-analog quantum computing focuses on using single qubit digital gates combined with more complex and device-dependent analog interactions to represent quantum programs. This paradigm has been shown to be universal for quantum computation<sup>1</sup>. However, while this approach may have advantages when adapting quantum programs to real devices, known quantum algorithms are very often expressed in a fully digital paradigm. As such, it is also important to have concrete ways to transform from one paradigm to another.</p> <p>This tutorial will exemplify the DAQC transformation starting with the representation of a simple digital <code>CNOT</code> using the universality of the Ising Hamiltonian<sup>2</sup>.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-with-cphase","title":"<code>CNOT</code> with <code>CPHASE</code>","text":"<p>Let's look at a single example of how the digital-analog transformation can be used to perform a <code>CNOT</code> on two qubits inside a register of globally interacting qubits.</p> <p>First, note that the <code>CNOT</code> can be decomposed with two Hadamard and a <code>CPHASE</code> gate with \\(\\phi=\\pi\\):</p> <pre><code>import torch\nfrom qadence import chain, sample, product_state\n\nfrom qadence.draw import display\nfrom qadence import X, I, Z, H, N, CPHASE, CNOT, HamEvo, PI\n\nn_qubits = 2\n\n# CNOT gate\ncnot_gate = CNOT(0, 1)\n\n# CNOT decomposed\nphi = PI\ncnot_decomp = chain(H(1), CPHASE(0, 1, phi), H(1))\n\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample from CNOT gate and 100 shots = [Counter({'11': 100})]\nsample from decomposed CNOT gate and 100 shots = [Counter({'11': 100})]\n</code></pre> <p>The <code>CPHASE</code> matrix is diagonal, and can be implemented by exponentiating an Ising-like Hamiltonian, or generator,</p> \\[\\text{CPHASE}(i,j,\\phi)=\\text{exp}\\left(-i\\phi \\mathcal{H}_\\text{CP}(i, j)\\right)\\] \\[\\begin{aligned} \\mathcal{H}_\\text{CP}&amp;=-\\frac{1}{4}(I_i-Z_i)(I_j-Z_j)\\\\ &amp;=-N_iN_j \\end{aligned}\\] <p>where the number operator \\(N_i = \\frac{1}{2}(I_i-Z_i)=\\hat{n}_i\\) is used, leading to an Ising-like interaction \\(\\hat{n}_i\\hat{n}_j\\) realisable in neutral-atom systems. Let's rebuild the <code>CNOT</code> using this evolution.</p> <pre><code>from qadence import kron, block_to_tensor\n\n# Hamiltonian for the CPHASE gate\nh_cphase = (-1.0) * kron(N(0), N(1))\n\n# Exponentiating and time-evolving the Hamiltonian until t=phi.\ncphase_evo = HamEvo(h_cphase, phi)\n\n# Check that we have the CPHASE gate:\ncphase_matrix = block_to_tensor(CPHASE(0, 1, phi))\ncphase_evo_matrix = block_to_tensor(cphase_evo)\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix: True\n</code></pre> <p>Now that the <code>CPHASE</code> generator is checked, it can be applied to the <code>CNOT</code>:</p> <pre><code># CNOT with Hamiltonian Evolution\ncnot_evo = chain(\n    H(1),\n    cphase_evo,\n    H(1)\n)\n\n# Initialize state to check CNOTs sample outcomes.\ninit_state = product_state(\"10\")\n</code></pre> <pre><code>sample cnot_gate = [Counter({'11': 100})]\nsample cnot_evo = [Counter({'11': 100})]\n</code></pre> <p>Thus, a <code>CNOT</code> gate can be created by combining a few single-qubit gates together with a two-qubit Ising interaction between the control and the target qubit which is the essence of the Ising transform proposed in the seminal DAQC paper<sup>2</sup> for \\(ZZ\\) interactions. In Qadence, both \\(ZZ\\) and \\(NN\\) interactions are supported.</p>"},{"location":"digital_analog_qc/daqc-cnot/#cnot-in-an-interacting-system-of-three-qubits","title":"<code>CNOT</code> in an interacting system of three qubits","text":"<p>Consider a simple experimental setup with \\(n=3\\) interacting qubits laid out in a triangular grid. For the sake of simplicity, all qubits interact with each other with an \\(NN\\)-Ising interaction of constant strength \\(g_\\text{int}\\). The Hamiltonian for the system can be written by summing interaction terms over all pairs:</p> \\[\\mathcal{H}_\\text{sys}=\\sum_{i=0}^{n}\\sum_{j=0}^{i-1}g_\\text{int}N_iN_j,\\] <p>which in this case leads to only three interaction terms,</p> \\[\\mathcal{H}_\\text{sys}=g_\\text{int}(N_0N_1+N_1N_2+N_0N_2)\\] <p>This generator can be easily built in Qadence:</p> <pre><code>from qadence import add, kron\nn_qubits = 3\n\n# Interaction strength.\ng_int = 1.0\n\n# Build a list of interactions.\ninteraction_list = []\nfor i in range(n_qubits):\n    for j in range(i):\n        interaction_list.append(g_int * kron(N(i), N(j)))\n\nh_sys = add(*interaction_list)\n</code></pre> <pre><code>h_sys = AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(2)\n\u2502       \u2514\u2500\u2500 N(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(1)\n</code></pre> <p>Now let's consider that the experimental system is fixed, and qubits can not be isolated one from another. The options are:</p> <ul> <li>Turn on or off the global system Hamiltonian.</li> <li>Perform local single-qubit rotations.</li> </ul> <p>To perform a fully digital <code>CNOT(0,1)</code>, the interacting control on qubit 0 and target on qubit 1 must be isolated from the third one to implement the gate directly. While this can be achieved for a three-qubit system, it becomes experimentally untractable when scaling the qubit count.</p> <p>However, this is not the case within the digital-analog paradigm. In fact, the two qubit Ising interaction required for the <code>CNOT</code> can be represented with a combination of the global system Hamiltonian and a specific set of single-qubit rotations. Full details about this transformation are to be found in the DAQC paper<sup>2</sup> but a more succint yet in-depth description takes place in the next section. It is conveniently available in Qadence by calling the <code>daqc_transform</code> function.</p> <p>In the most general sense, the <code>daqc_transform</code> function will return a circuit that represents the evolution of a target Hamiltonian \\(\\mathcal{H}_\\text{target}\\) (here the unitary of the gate) until a specified time \\(t_f\\) by using only the evolution of a build Hamiltonian \\(\\mathcal{H}_\\text{build}\\) (here \\(\\mathcal{H}_\\text{sys}\\)) together with local \\(X\\)-gates. In Qadence, <code>daqc_transform</code> is applicable for \\(\\mathcal{H}_\\text{target}\\) and \\(\\mathcal{H}_\\text{build}\\) composed only of \\(ZZ\\)- or \\(NN\\)-interactions. These generators are parsed by the <code>daqc_transform</code> function and the appropriate type is automatically determined together with the appropriate single-qubit detunings and global phases.</p> <p>Let's apply it for the <code>CNOT</code> implementation:</p> <pre><code>from qadence import daqc_transform, Strategy\n\n# Settings for the target CNOT operation\ni = 0  # Control qubit\nj = 1  # Target qubit\nk = 2  # The extra qubit\n\n# Define the target CNOT operation\n# by composing with identity on the extra qubit.\ncnot_target = kron(CNOT(i, j), I(k))\n\n# The two-qubit NN-Ising interaction term for the CPHASE\nh_int = (-1.0) * kron(N(i), N(j))\n\n# Transforming the two-qubit Ising interaction using only our system Hamiltonian\ntransformed_ising = daqc_transform(\n    n_qubits=3,        # Total number of qubits in the transformation\n    gen_target=h_int,  # The target Ising generator\n    t_f=PI,            # The target evolution time\n    gen_build=h_sys,   # The building block Ising generator to be used\n    strategy=Strategy.SDAQC,   # Currently only sDAQC is implemented\n    ignore_global_phases=False  # Global phases from mapping between Z and N\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_9ee28635b94b423db99796ef76b80700 cluster_1ee93fc43c74424a98a5e6b7d7ed900f cluster_539b4197291e469492efbb4c9b0b566e cluster_bd38f04f2c8648d39e50096e2d23bc41 cluster_86a463871b974581a9efba2dee8b2d20 cluster_c47fb95b6c6741e5b12dc223487da550 cluster_e4f44d25b59e4c0b9c00471794794766 bfb01a2432fe4b9fa0b3de797c5086de 0 6cafe05f8a754a4eb6c654b78550dbd3 HamEvo bfb01a2432fe4b9fa0b3de797c5086de--6cafe05f8a754a4eb6c654b78550dbd3 e0fb1ef810ca4033a2290c1ed4085c9b 1 b51d69b3dc4747298fc0f511ed6be039 HamEvo 6cafe05f8a754a4eb6c654b78550dbd3--b51d69b3dc4747298fc0f511ed6be039 c587ab15434a406ba1a8c44e3956b28d HamEvo b51d69b3dc4747298fc0f511ed6be039--c587ab15434a406ba1a8c44e3956b28d 1d026764a8af495fb0cacde667a9fa06 X c587ab15434a406ba1a8c44e3956b28d--1d026764a8af495fb0cacde667a9fa06 3ebda324464649d3859c94366ec9ec7e HamEvo 1d026764a8af495fb0cacde667a9fa06--3ebda324464649d3859c94366ec9ec7e 05aa1ac6f8324690b8f4eb6c33b56e3d HamEvo 3ebda324464649d3859c94366ec9ec7e--05aa1ac6f8324690b8f4eb6c33b56e3d 6f68c76640d046ed9e8d1f837adce71f X 05aa1ac6f8324690b8f4eb6c33b56e3d--6f68c76640d046ed9e8d1f837adce71f 22a1135139674275b0c534a844781700 6f68c76640d046ed9e8d1f837adce71f--22a1135139674275b0c534a844781700 4b9ab6b7bf3a40b1a85e6ddbebf9f2fb HamEvo 22a1135139674275b0c534a844781700--4b9ab6b7bf3a40b1a85e6ddbebf9f2fb 75b98791599e487fb98db6135cda46fa HamEvo 4b9ab6b7bf3a40b1a85e6ddbebf9f2fb--75b98791599e487fb98db6135cda46fa 86f43f02b7a74573bf11b5ed11a47352 75b98791599e487fb98db6135cda46fa--86f43f02b7a74573bf11b5ed11a47352 8c97ec6e0cc5425eb99bccfd5d89ee29 86f43f02b7a74573bf11b5ed11a47352--8c97ec6e0cc5425eb99bccfd5d89ee29 faa2471c0b2347628d2e8524ac91c75c b7851b0bc30948d1b88ae085a3ce9fc2 t = -3.142 e0fb1ef810ca4033a2290c1ed4085c9b--b7851b0bc30948d1b88ae085a3ce9fc2 1fd6a62e58ba4324981c480fd3362c3a 2 ff0fda46552a4331a65f912e60dedbb5 t = 3.142 b7851b0bc30948d1b88ae085a3ce9fc2--ff0fda46552a4331a65f912e60dedbb5 29e7607b063d445cb73bd6844d0722a0 t = -3.142 ff0fda46552a4331a65f912e60dedbb5--29e7607b063d445cb73bd6844d0722a0 0b7fa8bb30f04922882848d8539b2346 29e7607b063d445cb73bd6844d0722a0--0b7fa8bb30f04922882848d8539b2346 140713577c134f6c9eb09268fd2169dd t = 1.571 0b7fa8bb30f04922882848d8539b2346--140713577c134f6c9eb09268fd2169dd 7cebfe78db68448d9b366f284b880f52 t = 1.571 140713577c134f6c9eb09268fd2169dd--7cebfe78db68448d9b366f284b880f52 fbb7f603f8564deca5c98e804446b1c5 7cebfe78db68448d9b366f284b880f52--fbb7f603f8564deca5c98e804446b1c5 4cabe85ac05947e3b955a824a9069661 X fbb7f603f8564deca5c98e804446b1c5--4cabe85ac05947e3b955a824a9069661 b27b13efafcd4cbb8f24c6f0702ec8d1 t = 1.571 4cabe85ac05947e3b955a824a9069661--b27b13efafcd4cbb8f24c6f0702ec8d1 f85ee176ca3c4f32bdcef12e2f1669b3 t = 1.571 b27b13efafcd4cbb8f24c6f0702ec8d1--f85ee176ca3c4f32bdcef12e2f1669b3 222fb8fd6fd9423e8b18b2abb0b4af7c X f85ee176ca3c4f32bdcef12e2f1669b3--222fb8fd6fd9423e8b18b2abb0b4af7c 222fb8fd6fd9423e8b18b2abb0b4af7c--faa2471c0b2347628d2e8524ac91c75c 05e33fd2872448f395ce0544da2e06d4 36df8116250e4023864c2a62e8a42a5d 1fd6a62e58ba4324981c480fd3362c3a--36df8116250e4023864c2a62e8a42a5d 9407f764b80d4de680d78e14e76af145 36df8116250e4023864c2a62e8a42a5d--9407f764b80d4de680d78e14e76af145 ab2e41f5e0af4312b63fd197e03f841f 9407f764b80d4de680d78e14e76af145--ab2e41f5e0af4312b63fd197e03f841f bf6c34133439488d9597635b9d2246b0 X ab2e41f5e0af4312b63fd197e03f841f--bf6c34133439488d9597635b9d2246b0 303320a0748340159b769ff9dddd012b bf6c34133439488d9597635b9d2246b0--303320a0748340159b769ff9dddd012b 3f9c79f7ca2d4351ac7290f6bde7a43f 303320a0748340159b769ff9dddd012b--3f9c79f7ca2d4351ac7290f6bde7a43f a8b01c1d02a146bf840a5929963c2c78 X 3f9c79f7ca2d4351ac7290f6bde7a43f--a8b01c1d02a146bf840a5929963c2c78 fa22c7a6c16f475bb19763db61adf567 X a8b01c1d02a146bf840a5929963c2c78--fa22c7a6c16f475bb19763db61adf567 5b0d099612574647938a429e91a92f97 fa22c7a6c16f475bb19763db61adf567--5b0d099612574647938a429e91a92f97 ddfe25b98fd94bb5854f58727e3c2004 5b0d099612574647938a429e91a92f97--ddfe25b98fd94bb5854f58727e3c2004 e40d71a0775c41ea875006e289211286 X ddfe25b98fd94bb5854f58727e3c2004--e40d71a0775c41ea875006e289211286 e40d71a0775c41ea875006e289211286--05e33fd2872448f395ce0544da2e06d4 <p>The output circuit displays three groups of system Hamiltonian evolutions which account for global-phases and single-qubit detunings related to the mapping between the \\(Z\\) and \\(N\\) operators. Optionally, global phases can be ignored.</p> <p>In general, the mapping of a \\(n\\)-qubit Ising Hamiltonian to another will require at most \\(n(n-1)\\) evolutions. The transformed circuit performs these evolutions for specific times that are computed from the solution of a linear system of equations involving the set of interactions in the target and build Hamiltonians.</p> <p>In this case, the mapping is exact when using the step-wise DAQC strategy (<code>Strategy.SDAQC</code>) available in Qadence. In banged DAQC (<code>Strategy.BDAQC</code>) the mapping is approximate, but easier to implement on a physical device with always-on interactions such as neutral-atom systems.</p> <p>Just as before, the transformed Ising circuit can be checked to exactly recover the <code>CPHASE</code> gate:</p> <pre><code># CPHASE on (i, j), Identity on third qubit:\ncphase_matrix = block_to_tensor(kron(CPHASE(i, j, phi), I(k)))\n\n# CPHASE using the transformed circuit:\ncphase_evo_matrix = block_to_tensor(transformed_ising)\n\n# Check that it implements the CPHASE.\n# Will fail if global phases are ignored.\n</code></pre> <pre><code>cphase_matrix == cphase_evo_matrix : True\n</code></pre> <p>The <code>CNOT</code> gate can now finally be built:</p> <pre><code>from qadence import equivalent_state, run, sample\n\ncnot_daqc = chain(\n    H(j),\n    transformed_ising,\n    H(j)\n)\n\n# And finally apply the CNOT on a specific 3-qubit initial state:\ninit_state = product_state(\"101\")\n\n# Check we get an equivalent wavefunction\nwf_cnot = run(n_qubits, block=cnot_target, state=init_state)\nwf_daqc = run(n_qubits, block=cnot_daqc, state=init_state)\n\n# Visualize the CNOT bit-flip in samples.\n</code></pre> <pre><code>wf_cnot == wf_dacq : True\nsample cnot_target = [Counter({'111': 100})]\nsample cnot_dacq = [Counter({'111': 100})]\n</code></pre> <p>As one can see, a <code>CNOT</code> operation has been succesfully implemented on the desired target qubits by using only the global system as the building block Hamiltonian and single-qubit rotations. Decomposing a single digital gate into an Ising Hamiltonian serves as a proof of principle for the potential of this technique to represent universal quantum computation.</p>"},{"location":"digital_analog_qc/daqc-cnot/#technical-details-on-the-daqc-transformation","title":"Technical details on the DAQC transformation","text":"<ul> <li>The mapping between target generator and final circuit is performed by solving a linear system of size \\(n(n-1)\\) where \\(n\\) is the number of qubits, so it can be computed efficiently (i.e., with a polynomial cost in the number of qubits).</li> <li>The linear system to be solved is actually not invertible for \\(n=4\\) qubits. This is very specific edge case requiring a workaround, that is currently not yet implemented.</li> <li>As mentioned, the final circuit has at most \\(n(n-1)\\) slices, so there is at most a quadratic overhead in circuit depth.</li> </ul> <p>Finally, and most important to its usage:</p> <ul> <li>The target Hamiltonian should be sufficiently represented in the building block Hamiltonian.</li> </ul> <p>To illustrate this point, consider the following target and build Hamiltonians:</p> <pre><code># Interaction between qubits 0 and 1\ngen_target = 1.0 * (Z(0) @ Z(1))\n\n# Fixed interaction between qubits 1 and 2, and customizable between 0 and 1\ndef gen_build(g_int):\n    return g_int * (Z(0) @ Z(1)) + 1.0 * (Z(1) @ Z(2))\n</code></pre> <p>And now we perform the DAQC transform by setting <code>g_int=1.0</code>, exactly matching the target Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=1.0),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_bd9a6f7eae3e44c8b99e579bf86ec529 cluster_abc20a5c3a654c28ad561e1323e328c6 5aae1c65dfef4d54acb02819050a5f11 0 72658944ade249698eba92527712d7d3 X 5aae1c65dfef4d54acb02819050a5f11--72658944ade249698eba92527712d7d3 5e15360d6b804417aeabc32ea59aec4b 1 8af17a1ccf1648c5944f9554c79cbc04 HamEvo 72658944ade249698eba92527712d7d3--8af17a1ccf1648c5944f9554c79cbc04 8576df82cde1455cb63867f62b12a535 X 8af17a1ccf1648c5944f9554c79cbc04--8576df82cde1455cb63867f62b12a535 32a7473e29c44d22b6a4f10046ec37fa 8576df82cde1455cb63867f62b12a535--32a7473e29c44d22b6a4f10046ec37fa de5d75750b0847338706ad3e0018a169 HamEvo 32a7473e29c44d22b6a4f10046ec37fa--de5d75750b0847338706ad3e0018a169 84275d74e67e42f28dce37cf7eaa96df de5d75750b0847338706ad3e0018a169--84275d74e67e42f28dce37cf7eaa96df 16f6fc0a71504e879d47662173cacb51 84275d74e67e42f28dce37cf7eaa96df--16f6fc0a71504e879d47662173cacb51 7bd69a9e0772495e86dd153c3fa8aa33 e93e7a4bf7544f23aa82d5c9a11324ad 5e15360d6b804417aeabc32ea59aec4b--e93e7a4bf7544f23aa82d5c9a11324ad 239d17288e4746188e762f6e2f0290a8 2 50cec73b3c924faf9eca954c89afa60f t = -0.500 e93e7a4bf7544f23aa82d5c9a11324ad--50cec73b3c924faf9eca954c89afa60f 1b6c8a1d7ffb4b8ea00938bb033a3c88 50cec73b3c924faf9eca954c89afa60f--1b6c8a1d7ffb4b8ea00938bb033a3c88 7394689ea1a34259b06e61ef12724b2c X 1b6c8a1d7ffb4b8ea00938bb033a3c88--7394689ea1a34259b06e61ef12724b2c 70f19942265f4ea2a37e7e40d51b0eca t = -0.500 7394689ea1a34259b06e61ef12724b2c--70f19942265f4ea2a37e7e40d51b0eca d09faf89d2a44fb390120d569bb425d8 X 70f19942265f4ea2a37e7e40d51b0eca--d09faf89d2a44fb390120d569bb425d8 d09faf89d2a44fb390120d569bb425d8--7bd69a9e0772495e86dd153c3fa8aa33 7b6df47c14114d719b89dd8d2e5e138f 1ef7b9c365d84ff393dc6ae6f533f0d1 X 239d17288e4746188e762f6e2f0290a8--1ef7b9c365d84ff393dc6ae6f533f0d1 8f677be734a346fb8dc2b3bf051aa72b 1ef7b9c365d84ff393dc6ae6f533f0d1--8f677be734a346fb8dc2b3bf051aa72b 66605532ea0a4656b988fdcfc75a6625 X 8f677be734a346fb8dc2b3bf051aa72b--66605532ea0a4656b988fdcfc75a6625 35e5c3c26ca944e582dcdccb2c87fd93 X 66605532ea0a4656b988fdcfc75a6625--35e5c3c26ca944e582dcdccb2c87fd93 f9d465cda35e432282aeb3615c1d13d3 35e5c3c26ca944e582dcdccb2c87fd93--f9d465cda35e432282aeb3615c1d13d3 a357f2a44c174cb5a6ef502b1671b0d9 X f9d465cda35e432282aeb3615c1d13d3--a357f2a44c174cb5a6ef502b1671b0d9 a357f2a44c174cb5a6ef502b1671b0d9--7b6df47c14114d719b89dd8d2e5e138f <p>Now, if the interaction between qubits 0 and 1 is weakened in the build Hamiltonian:</p> <pre><code>transformed_ising = daqc_transform(\n    n_qubits=3,\n    gen_target=gen_target,\n    t_f=1.0,\n    gen_build=gen_build(g_int=0.001),\n)\n\n# display(transformed_ising)\n</code></pre> %3 cluster_526e6eac59c94d5fb322f9c7c9b1e1b5 cluster_6051601cd2e247b588dd9949336293b7 a41a8e1c2f554b6cb5cafaf3cec53545 0 360100b1b76040ec83a7631bbba0c4d4 X a41a8e1c2f554b6cb5cafaf3cec53545--360100b1b76040ec83a7631bbba0c4d4 d795c0f4330a4aa8922f9dfabb99b390 1 73be23ed16314a1b8c23878fd9f3914e HamEvo 360100b1b76040ec83a7631bbba0c4d4--73be23ed16314a1b8c23878fd9f3914e 364573bfa88e4a65807e915063485dbc X 73be23ed16314a1b8c23878fd9f3914e--364573bfa88e4a65807e915063485dbc 02b7810f2a3f4de397b6e2526e4f8756 364573bfa88e4a65807e915063485dbc--02b7810f2a3f4de397b6e2526e4f8756 7734726e1a90472e9ad4c6df2eb4079c HamEvo 02b7810f2a3f4de397b6e2526e4f8756--7734726e1a90472e9ad4c6df2eb4079c 27d6751032074193ab4f66a04c22fd6e 7734726e1a90472e9ad4c6df2eb4079c--27d6751032074193ab4f66a04c22fd6e dcb9538ba4754adcb434b1bfc69f9951 27d6751032074193ab4f66a04c22fd6e--dcb9538ba4754adcb434b1bfc69f9951 9b62a60fdae24c0d96187b5e3825d6e6 e13f406f683746d7b2af1c94e038f083 d795c0f4330a4aa8922f9dfabb99b390--e13f406f683746d7b2af1c94e038f083 5c99a9fa601a4220bdb1a87e8875f535 2 831295d50ae04c6789c70c3d3bfb9ec9 t = -500.000000000000 e13f406f683746d7b2af1c94e038f083--831295d50ae04c6789c70c3d3bfb9ec9 af197c3a914b48eeb3257dfd7e69e90b 831295d50ae04c6789c70c3d3bfb9ec9--af197c3a914b48eeb3257dfd7e69e90b cac53fd6f6fd4d81b5cf51fbc7ff9048 X af197c3a914b48eeb3257dfd7e69e90b--cac53fd6f6fd4d81b5cf51fbc7ff9048 469fcad5b9b14b87bd4e24234e8179a4 t = -500.000000000000 cac53fd6f6fd4d81b5cf51fbc7ff9048--469fcad5b9b14b87bd4e24234e8179a4 d5bfde2f20704ca7991b2ef1e8905728 X 469fcad5b9b14b87bd4e24234e8179a4--d5bfde2f20704ca7991b2ef1e8905728 d5bfde2f20704ca7991b2ef1e8905728--9b62a60fdae24c0d96187b5e3825d6e6 0eb76ad166a64387a2df7dca38968953 90c0c1329b99478386d19a3000190bd9 X 5c99a9fa601a4220bdb1a87e8875f535--90c0c1329b99478386d19a3000190bd9 5c4794a5afb542c0afd4dd6fc68671a8 90c0c1329b99478386d19a3000190bd9--5c4794a5afb542c0afd4dd6fc68671a8 a8f240fccb8c4ace84ef861193bae501 X 5c4794a5afb542c0afd4dd6fc68671a8--a8f240fccb8c4ace84ef861193bae501 ba1156c2e06e41cf86ac7fa5aa0f8551 X a8f240fccb8c4ace84ef861193bae501--ba1156c2e06e41cf86ac7fa5aa0f8551 62dc8909393e4a8ba3d5accb5838068f ba1156c2e06e41cf86ac7fa5aa0f8551--62dc8909393e4a8ba3d5accb5838068f 38bb762cbbe2463187ac79ca45a6a463 X 62dc8909393e4a8ba3d5accb5838068f--38bb762cbbe2463187ac79ca45a6a463 38bb762cbbe2463187ac79ca45a6a463--0eb76ad166a64387a2df7dca38968953 <p>The times slices using the build Hamiltonian need now to evolve for much longer to represent the same interaction since it is not sufficiently represented in the building block Hamiltonian.</p> <p>In the limit where that interaction is not present, the transform will not work:</p> <pre><code>try:\n    transformed_ising = daqc_transform(\n        n_qubits=3,\n        gen_target=gen_target,\n        t_f=1.0,\n        gen_build=gen_build(g_int = 0.0),\n    )\nexcept ValueError as error:\n    print(\"Error:\", error)\n</code></pre> <pre><code>Error: Incompatible interactions between target and build Hamiltonians.\n</code></pre>"},{"location":"digital_analog_qc/daqc-cnot/#references","title":"References","text":"<ol> <li> <p>Dodd et al., Universal quantum computation and simulation using any entangling Hamiltonian and local unitaries, PRA 65, 040301 (2002). \u21a9</p> </li> <li> <p>Parra-Rodriguez et al., Digital-Analog Quantum Computation, PRA 101, 022305 (2020). \u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/pulser-basic/","title":"Pulse-level programming with Pulser","text":"<p>Qadence offers a direct interface with Pulser<sup>1</sup>, an open-source pulse-level interface written in Python and specifically designed for programming neutral atom quantum computers.</p> <p>Using directly Pulser requires advanced knowledge on pulse-level programming and on how neutral atom devices work. Qadence abstracts this complexity out by using the familiar block-based interface for building pulse sequences in Pulser while leaving the possibility to directly manipulate them if required by, for instance, optimal pulse shaping.</p> <p>Note</p> <p>The Pulser backend is still experimental and the interface might change in the future. Please note that it does not support <code>DiffMode.AD</code>.</p> <p>Note</p> <p>With the Pulser backend, <code>qadence</code> simulations can be executed on the cloud emulators available on the PASQAL cloud platform. In order to do so, make to have valid credentials for the PASQAL cloud platform and use the following configuration for the Pulser backend:</p> <pre><code>config = {\n    \"cloud_configuration\": {\n        \"username\": \"&lt;changeme&gt;\",\n        \"password\": \"&lt;changeme&gt;\",\n        \"project_id\": \"&lt;changeme&gt;\",  # the project should have access to emulators\n        \"platform\": \"EMU_FREE\"  # choose between `EMU_TN` and `EMU_FREE`\n    }\n}\n</code></pre> <p>For inquiries and more details on the cloud credentials, please contact info@pasqal.com.</p>"},{"location":"digital_analog_qc/pulser-basic/#default-qubit-interaction","title":"Default qubit interaction","text":"<p>When simulating pulse sequences written using Pulser, the underlying constructed Hamiltonian is equivalent to a digital-analog quantum computing program (see digital-analog emulation for more details) with the following interaction term:</p> \\[ \\mathcal{H}_{\\textrm{int}} = \\sum_{i&lt;j} \\frac{C_6}{|R_i - R_j|^6} \\hat{n}_i \\hat{n}_j \\] <p>where \\(C_6\\) is an interaction strength coefficient dependent on the principal quantum number of chosen the neutral atom system, \\(R_i\\) are atomic positions in Cartesian coordinates and \\(\\hat{n} = \\frac{1-\\sigma^z_i}{2}\\) the number operator.</p> <p>Note</p> <p>The Ising interaction is always-on for all computations performed with the Pulser backend. It cannot be switched off.</p>"},{"location":"digital_analog_qc/pulser-basic/#available-quantum-operations","title":"Available quantum operations","text":"<p>Currently, the Pulser backend supports the following operations:</p> gate description trainable parameter <code>RX</code>, <code>RY</code> Single qubit rotations. Notice that the interaction is on and this affects the resulting gate fidelity. rotation angle <code>AnalogRX</code>, <code>AnalogRY</code>, <code>AnalogRZ</code> Span a single qubit rotation among the entire register. rotation angle <code>entangle</code> Fully entangle the register. interaction time <code>AnalogInteraction</code> An idle block to to free-evolve for a duration according to the interaction. free evolution time"},{"location":"digital_analog_qc/pulser-basic/#sequence-the-bell-state-on-a-two-qubit-register","title":"Sequence the Bell state on a two qubit register","text":"<p>The next example illustrates how to create a pulse sequence to prepare a Bell state. This is a sequence of an entanglement operation, represented as an <code>entangle</code> gate (using <code>CZ</code> interactions) in the \\(X\\)-basis and a \\(Y\\) rotation for readout in the \\(Z\\)-basis:</p> <pre><code>from qadence import chain, entangle, RY\n\nbell_state = chain(\n   entangle(\"t\", qubit_support=(0,1)),\n   RY(0, \"y\"),\n)\n</code></pre> <pre><code>bell_state = ChainBlock(0,1)\n\u251c\u2500\u2500 AnalogEntanglement(t=0.19153186677421175, support=(0, 1))\n\u2514\u2500\u2500 RY(0) [params: ['y']]\n</code></pre> <p>Next, a <code>Register</code> with two qubits is combined with the resulting <code>ChainBlock</code> to form a circuit. Then, the <code>QuantumModel</code> converts the circuit into a proper parametrized pulse sequence with the Pulser backend. Supplying the parameter values allows to sample the pulse sequence outcome:</p> <pre><code>import torch\nimport matplotlib.pyplot as plt\nfrom qadence import Register, QuantumCircuit, QuantumModel, PI\n\nregister = Register.line(2, spacing = 8.0)  # Two qubits with a distance of 8\u00b5m\ncircuit = QuantumCircuit(register, bell_state)\nmodel = QuantumModel(circuit, backend=\"pulser\", diff_mode=\"gpsr\")\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Return the final state vector\nfinal_vector = model.run(params)\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>final_vector = tensor([[-0.7114-0.0169j, -0.0339+0.0156j,  0.0109-0.0457j,  0.6630-0.2244j]])\nsample = Counter({'00': 30, '11': 20})\n</code></pre> <p>Plot the distribution:</p> <p><pre><code>\n</code></pre> 2024-02-15T16:11:37.256415 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/  One can visualise the pulse sequence with different parameters using the <code>assign_paramters</code> method.</p> <pre><code>model.assign_parameters(params).draw(show=False)\n</code></pre> 2024-02-15T16:11:37.381443 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#change-device-specifications","title":"Change device specifications","text":"<p>At variance with other backends, Pulser provides the concept of <code>Device</code>. A <code>Device</code> instance encapsulates all the properties for the definition of a real neutral atoms processor, including but not limited to the maximum laser amplitude for pulses, the maximum distance between two qubits and the maximum duration of the pulse. For more information, please check this tutorial.</p> <p>Qadence offers a simplified interface with only two devices which are detailed here:</p> <ul> <li><code>IDEALIZED</code> (default): ideal device which should be used only for testing purposes. It does not restrict the simulation of pulse sequences.</li> <li><code>REALISTIC</code>: device specification close to real neutral atom quantum processors.</li> </ul> <p>Note</p> <p>If you want to perform simulations closer to the specifications of real neutral atom machines, always select the <code>REALISTIC</code> device.</p> <p>One can use the <code>Configuration</code> of the Pulser backend to select the appropriate device:</p> <pre><code>from qadence import BackendName, DiffMode\nfrom qadence import RealisticDevice\n\n# Choose a realistic device\nregister = Register.line(2, spacing = 8.0, device_specs = RealisticDevice())\n\ncircuit = QuantumCircuit(register, bell_state)\n\nmodel = QuantumModel(\n    circuit,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR,\n)\n\nparams = {\n    \"t\": torch.tensor([1000]),  # ns\n    \"y\": torch.tensor([3*PI/2]),\n}\n\n# Sample from the result state vector\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> <pre><code>sample = Counter({'00': 27, '11': 21, '10': 2})\n</code></pre>"},{"location":"digital_analog_qc/pulser-basic/#create-a-custom-gate","title":"Create a custom gate","text":"<p>A major advantage of the block-based interface in Qadence is the ease to compose complex operations from a restricted set of primitive ones. In the following, a custom entanglement operation is used as an example.</p> <p>The operation consists of moving all the qubits to the \\(X\\)-basis. This is realized when the atomic interaction performs a controlled-\\(Z\\) operation during the free evolution. As seen before, this is implemented with the <code>AnalogInteraction</code> and <code>AnalogRY</code> blocks together with appropriate parameters.</p> <pre><code>from qadence import AnalogRY, chain, AnalogInteraction\n\n# Custom entanglement operation.\ndef my_entanglement(duration):\n    return chain(\n        AnalogRY(-PI / 2),\n        AnalogInteraction(duration)\n    )\n\nprotocol = chain(\n   my_entanglement(\"t\"),\n   RY(0, \"y\"),\n)\n\nregister = Register.line(2, spacing = 8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"t\": torch.tensor([500]),  # ns\n    \"y\": torch.tensor([PI / 2]),\n}\n\nsample = model.sample(params, n_shots=50)[0]\n</code></pre> 2024-02-15T16:11:37.851589 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#digital-analog-qnn-circuit","title":"Digital-analog QNN circuit","text":"<p>Finally, let's put all together by constructing a digital-analog version of a quantum neural network circuit with feature map and variational ansatz.</p> <pre><code>from qadence import kron, fourier_feature_map\nfrom qadence.operations import RX, RY, AnalogRX\n\nhea_one_layer = chain(\n    kron(RY(0, \"th00\"), RY(1, \"th01\")),\n    kron(RX(0, \"th10\"), RX(1, \"th11\")),\n    kron(RY(0, \"th20\"), RY(1, \"th21\")),\n    entangle(\"t\", qubit_support=(0,1)),\n)\n\nprotocol = chain(\n    fourier_feature_map(1, param=\"x\"),\n    hea_one_layer,\n    AnalogRX(PI/4)\n)\n\nregister = Register.line(2, spacing=8.0)\ncircuit = QuantumCircuit(register, protocol)\nmodel = QuantumModel(circuit, backend=BackendName.PULSER, diff_mode=DiffMode.GPSR)\n\nparams = {\n    \"x\": torch.tensor([0.8]), # rad\n    \"t\": torch.tensor([900]), # ns\n    \"th00\":  torch.rand(1), # rad\n    \"th01\":  torch.rand(1), # rad\n    \"th10\":  torch.rand(1), # rad\n    \"th11\":  torch.rand(1), # rad\n    \"th20\":  torch.rand(1), # rad\n    \"th21\":  torch.rand(1), # rad\n}\n\nmodel.assign_parameters(params).draw(draw_phase_area=True, show=False)\n</code></pre> 2024-02-15T16:11:38.009298 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"digital_analog_qc/pulser-basic/#references","title":"References","text":"<ol> <li> <p>Pulser: An open-source package for the design of pulse sequences in programmable neutral-atom arrays \u21a9</p> </li> </ol>"},{"location":"digital_analog_qc/semi-local-addressing/","title":"Restricted local addressability","text":""},{"location":"digital_analog_qc/semi-local-addressing/#physics-behind-semi-local-addressing-patterns","title":"Physics behind semi-local addressing patterns","text":"<p>Recall that in Qadence the general neutral-atom Hamiltonian for a set of \\(n\\) interacting qubits is given by expression</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} = \\sum_{i=0}^{n-1}\\left(\\mathcal{H}^\\text{d}_{i}(t) + \\sum_{j&lt;i}\\mathcal{H}^\\text{int}_{ij}\\right) \\] <p>as is described in detail in the analog interface basics documentation.</p> <p>The driving Hamiltonian term in priciple can model any local single-qubit rotation by addressing each qubit individually. However, some neutral-atom devices offer restricted local addressability using devices called spatial light modulators (SLMs).</p> <p>We refer to this regime as semi-local addressability. In this regime, the individual qubit addressing is restricted to a pattern of targeted qubits which is kept fixed during the execution of the quantum circuit. More formally, the addressing pattern appears as an additional term in the neutral-atom Hamiltonian:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm drive} + \\mathcal{H}_{\\rm int} + \\mathcal{H}_{\\rm local} \\] <p>where \\(\\mathcal{H}_{\\rm pattern}\\) is given by</p> \\[ \\mathcal{H}_{\\rm local} = \\sum_{i=0}^{n-1}\\left(-\\Delta w_i^{\\rm det} \\hat{n}_i + \\Gamma w_i^{\\rm drive} \\hat{\\sigma}^x_i\\right). \\] <p>Here \\(\\Delta\\) specifies the maximal negative detuning that each qubit in the register can be exposed to. The weight \\(w_i^{\\rm det}\\in [0, 1]\\) determines the actual value of detuning that \\(i\\)-th qubit feels and this way the detuning pattern is emulated. Similarly, for the amplitude pattern \\(\\Gamma\\) determines the maximal additional positive drive that acts on qubits. In this case the corresponding weights \\(w_i^{\\rm drive}\\) can vary in the interval \\([0, 1]\\).</p> <p>Using the detuning and amplitude patterns described above one can modify the behavior of a selected set of qubits, thus achieving semi-local addressing.</p> <p>Qadence implements semi-local addressing in two different flavors of increasing complexity: either as a circuit constructor or directly as a pattern added to the general evolution Hamiltonian described by the circuit.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-circuit-constructors","title":"Using circuit constructors","text":"<p>The <code>rydberg_hea</code> constructor routine allows to build a circuit instance implementing a basic version of the Hamiltonian evolution described above where both \\(\\Delta\\) and \\(\\tilde{\\Omega}\\) coefficients are considered constants. Furthemore, no global drive and detuning are explicitly added to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:</p> \\[ \\mathcal{H} = \\mathcal{H}_{\\rm local}(w^{\\rm drive}, w^{\\rm det}) + \\mathcal{H}_{\\textrm{int}} \\] <p>This implementation does not perform any checks on the weights normalization, thus making it not realistic. This implies that global drive and detuning can be retrieved by appropriately choosing the weights.</p> <p>You can easily create a Rydberg hardware efficient ansatz implementing multiple layers of the evolution generated by the local addressing Hamiltonian:</p> \\[ \\mathcal{H}_{\\rm evo} = \\sum_j \\mathcal{H}_{\\textrm{local}}(w_{j}^{\\rm drive}, w_{j}^{\\rm det}) \\] <p>Notice that in real-device implementation, one layer only is usually achievable.</p> <pre><code>import qadence as qd\nfrom qadence import rydberg_hea, rydberg_hea_layer\n\nn_qubits = 4\nn_layers = 2\nregister = qd.Register.line(n_qubits)\n\n# ansatz constructor\n# the evolution time is parametrized for each layer of the evolution\nansatz = rydberg_hea(\n    register,\n    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution\n    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters\n    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters\n    tunable_phase=True, # make the phase \\phi as a variational parameter\n)\n\n# alternatively, a single ansatz layer can also be created for\n# better flexibility\n\n# these can be variational parameters\ntevo_drive = 1.0  # evolution time for the locally addressed drive term\ntevo_det = 1.0 # evolution time for the locally addressed detuning term\ntevo_int = 1.0  # evolution time for the interaction term\n\n# these can be list of variational parameters\nweights_drive = [0.0, 0.25, 0.5, 0.25]\nweights_det = [0.0, 0.0, 0.5, 0.5]\n\nansatz_layer = rydberg_hea_layer(\n    register,\n    tevo_det,\n    tevo_drive,\n    tevo_int,\n    detunings=weights_det,\n    drives=weights_drive,\n)\n</code></pre> <pre><code>\n</code></pre> <p>This circuit constructor is meant to be used with fully differentiable backends such as <code>pyqtorch</code> and mainly for quick experimentation with neutral atom compatible ansatze.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#using-addressing-patterns","title":"Using addressing patterns","text":"<p>In Qadence semi-local addressing patterns can be created by either specifying fixed values for the weights of the qubits being addressed or defining them as trainable parameters that can be optimized later in some training loop. Semi-local addressing patterns can be defined with the <code>AddressingPattern</code> dataclass.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#fixed-weights","title":"Fixed weights","text":"<p>With fixed weights, detuning/amplitude addressing patterns can be defined in the following way:</p> <pre><code>import torch\nfrom qadence.analog import AddressingPattern\n\nn_qubits = 3\n\nw_det = {0: 0.9, 1: 0.5, 2: 1.0}\nw_amp = {0: 0.1, 1: 0.4, 2: 0.8}\ndet = 9.0\namp = 6.5\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n</code></pre> <p>If only detuning or amplitude pattern is needed - the corresponding weights for all qubits can be set to 0.</p> <p>The created addressing pattern can now be passed as an argument to any Qadence device class, or to the <code>IdealDevice</code> or <code>RealisticDevice</code> to make use of the pre-defined options in those devices,</p> <pre><code>import torch\nfrom qadence import (\n    AnalogRX,\n    AnalogRY,\n    BackendName,\n    DiffMode,\n    Parameter,\n    QuantumCircuit,\n    QuantumModel,\n    Register,\n    chain,\n    total_magnetization,\n    IdealDevice,\n    PI\n)\n\n# define register and circuit\nspacing = 8.0\nx = Parameter(\"x\")\nblock = chain(AnalogRX(3 * x), AnalogRY(0.5 * x))\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\nobs = total_magnetization(n_qubits)\n\nmodel_pyq = QuantumModel(\n    circuit=circ, observable=obs, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD\n)\n\n# calculate expectation value of the circuit for random input value\nvalue = {\"x\": 1.0 + torch.rand(1)}\nexpval_pyq = model_pyq.expectation(values = value)\n</code></pre>   Expectation value on PyQ:  tensor([2.0100])     <p>The same configuration can also be seamlessly used to create a model with the Pulser backend.</p> <pre><code>model_pulser = QuantumModel(\n    circuit=circ,\n    observable=obs,\n    backend=BackendName.PULSER,\n    diff_mode=DiffMode.GPSR\n)\n\n# calculate expectation value of the circuit for same random input value\nexpval_pulser = model_pulser.expectation(values = value)\n</code></pre>   Expectation value on Pulser:  tensor([2.0106])     <p>Note that by default the addressing pattern terms are added to every analog operation in the circuit. However, it is possible to turn the addressing pattern off for specific operations by passing <code>add_pattern=False</code> in the operation. For example <code>AnalogRX(pi)</code> will get the extra addressing pattern term, but <code>AnalogRX(pi, add_pattern=False)</code> will not. This is currently only implemented for the PyQTorch backend. If an addressing pattern is specified for the Pulser backend, it will be added to all the blocks.</p>"},{"location":"digital_analog_qc/semi-local-addressing/#trainable-weights","title":"Trainable weights","text":"<p>Note</p> <p>Trainable parameters currently are supported only by <code>pyqtorch</code> backend.</p> <p>Since both the maximum detuning/amplitude value of the addressing pattern and the corresponding weights can be user specified, they can be variationally used in some QML setting. This can be achieved by defining pattern weights as trainable <code>Parameter</code> instances or strings specifying weight names.</p> <pre><code>n_qubits = 3\nreg = Register.line(n_qubits, spacing=8.0)\n\n# some random target function value\nf_value = torch.rand(1)\n\n# define trainable addressing pattern\nw_amp = {i: f\"w_amp{i}\" for i in range(n_qubits)}\nw_det = {i: f\"w_det{i}\" for i in range(n_qubits)}\namp = \"max_amp\"\ndet = \"max_det\"\n\npattern = AddressingPattern(\n    n_qubits=n_qubits,\n    det=det,\n    amp=amp,\n    weights_det=w_det,\n    weights_amp=w_amp,\n)\n\n# some fixed analog operation\nblock = AnalogRX(PI)\n\ndevice_specs = IdealDevice(pattern = pattern)\n\nreg = Register.line(\n    n_qubits,\n    spacing=spacing,\n    device_specs=device_specs,\n)\n\ncirc = QuantumCircuit(reg, block)\n\n# define quantum model\nobs = total_magnetization(n_qubits)\nmodel = QuantumModel(circuit=circ, observable=obs, backend=BackendName.PYQTORCH)\n\n# prepare for training\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nloss_criterion = torch.nn.MSELoss()\nn_epochs = 200\nloss_save = []\n\n# train model\nfor _ in range(n_epochs):\n    optimizer.zero_grad()\n    out = model.expectation()\n    loss = loss_criterion(f_value, out)\n    loss.backward()\n    optimizer.step()\n    loss_save.append(loss.item())\n\n# get final results\nf_value_model = model.expectation().detach()\n\nassert torch.isclose(f_value, f_value_model, atol=0.01)\n</code></pre>   The target function value:  tensor([0.6974]) The trained function value:  tensor([[0.6974]])    <p>Here, the expectation value of the circuit is fitted by varying the parameters of the addressing pattern.</p>"},{"location":"qadence/blocks/","title":"Block system","text":"<p><code>qadence</code> offers a block-based system to construct quantum circuits in a flexible manner.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock","title":"<code>AbstractBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for both primitive and composite blocks.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A human-readable name attached to the block type. Notice, this is the same for all the class instances so it cannot be used for identifying different blocks</p> <p> TYPE: <code>str</code> </p> <code>qubit_support</code> <p>The qubit support of the block expressed as a tuple of integers</p> <p> TYPE: <code>tuple[int, ...]</code> </p> <code>tag</code> <p>A tag identifying a particular instance of the block which can be used for identification and pretty printing</p> <p> TYPE: <code>str | None</code> </p> <code>eigenvalues</code> <p>The eigenvalues of the matrix representing the block. This is used mainly for primitive blocks and it's needed for generalized parameter shift rule computations. Currently unused.</p> <p> TYPE: <code>list[float] | None</code> </p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.is_identity","title":"<code>is_identity: bool</code>  <code>property</code>","text":"<p>Identity predicate for blocks.</p>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_qubits","title":"<code>n_qubits()</code>","text":"<p>The number of qubits in the whole system.</p> <p>A block acting on qubit N would has at least n_qubits &gt;= N + 1.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_qubits(self) -&gt; int:\n    \"\"\"The number of qubits in the whole system.\n\n    A block acting on qubit N would has at least n_qubits &gt;= N + 1.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.n_supports","title":"<code>n_supports()</code>","text":"<p>The number of qubits the block is acting on.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef n_supports(self) -&gt; int:\n    \"\"\"The number of qubits the block is acting on.\"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.abstract.AbstractBlock.qubit_support","title":"<code>qubit_support()</code>","text":"<p>The indices of the qubit(s) the block is acting on.</p> <p>Qadence uses the ordering [0..,N-1] for qubits.</p> Source code in <code>qadence/blocks/abstract.py</code> <pre><code>@abstractproperty\ndef qubit_support(self) -&gt; Tuple[int, ...]:\n    \"\"\"The indices of the qubit(s) the block is acting on.\n\n    Qadence uses the ordering [0..,N-1] for qubits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#primitive-blocks","title":"Primitive blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.primitive.ControlBlock","title":"<code>ControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: PrimitiveBlock) -&gt; None:\n    self.control = control\n    self.blocks = (target_block,)\n    self.target = target_block.qubit_support\n\n    # using tuple expansion because some control operations could\n    # have multiple targets, e.g. CSWAP\n    super().__init__((*control, *self.target))  # target_block.qubit_support[0]))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock","title":"<code>ParametricBlock(qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>Parameterized primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricBlock.num_parameters","title":"<code>num_parameters()</code>  <code>abstractmethod</code>","text":"<p>The number of parameters required by the block.</p> <p>This is a class property since the number of parameters is defined automatically before instantiating the operation. Also, this could correspond to a larger number of actual user-facing parameters since any parameter expression is allowed</p> <p>Examples: - RX operation has 1 parameter - U operation has 3 parameters - HamEvo has 2 parameters (generator and time evolution)</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>@abstractmethod\ndef num_parameters(cls) -&gt; int:\n    \"\"\"The number of parameters required by the block.\n\n    This is a class property since the number of parameters is defined\n    automatically before instantiating the operation. Also, this could\n    correspond to a larger number of actual user-facing parameters\n    since any parameter expression is allowed\n\n    Examples:\n    - RX operation has 1 parameter\n    - U operation has 3 parameters\n    - HamEvo has 2 parameters (generator and time evolution)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ParametricControlBlock","title":"<code>ParametricControlBlock(control, target_block)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The abstract parametrized ControlBlock.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, control: tuple[int, ...], target_block: ParametricBlock) -&gt; None:\n    self.blocks = (target_block,)\n    self.control = control\n    self.parameters = target_block.parameters\n    super().__init__((*control, *target_block.qubit_support))\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock","title":"<code>PrimitiveBlock(qubit_support)</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Primitive blocks represent elementary unitary operations.</p> <p>Examples are single/multi-qubit gates or Hamiltonian evolution. See <code>qadence.operations</code> for a full list of primitive blocks.</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.PrimitiveBlock.digital_decomposition","title":"<code>digital_decomposition()</code>","text":"<p>Decomposition into purely digital gates.</p> <p>This method returns a decomposition of the Block in a combination of purely digital single-qubit and two-qubit 'gates', by manual/custom knowledge of how this can be done efficiently. :return:</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def digital_decomposition(self) -&gt; AbstractBlock:\n    \"\"\"Decomposition into purely digital gates.\n\n    This method returns a decomposition of the Block in a\n    combination of purely digital single-qubit and two-qubit\n    'gates', by manual/custom knowledge of how this can be done efficiently.\n    :return:\n    \"\"\"\n    return self\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ProjectorBlock","title":"<code>ProjectorBlock(ket, bra, qubit_support)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The abstract ProjectorBlock.</p> <p>Arguments:</p> <pre><code>ket (str): The ket given as a bitstring.\nbra (str): The bra given as a bitstring.\nqubit_support (int | tuple[int]): The qubit_support of the block.\n</code></pre> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(\n    self,\n    ket: str,\n    bra: str,\n    qubit_support: int | tuple[int, ...],\n) -&gt; None:\n    \"\"\"\n    Arguments:\n\n        ket (str): The ket given as a bitstring.\n        bra (str): The bra given as a bitstring.\n        qubit_support (int | tuple[int]): The qubit_support of the block.\n    \"\"\"\n    if isinstance(qubit_support, int):\n        qubit_support = (qubit_support,)\n    if len(bra) != len(ket):\n        raise ValueError(\n            \"Bra and ket must be bitstrings of same length in the 'Projector' definition.\"\n        )\n    elif len(bra) != len(qubit_support):\n        raise ValueError(\"Bra or ket must be of same length as the 'qubit_support'\")\n    for wf in [bra, ket]:\n        if not all(int(item) == 0 or int(item) == 1 for item in wf):\n            raise ValueError(\n                \"All qubits must be either in the '0' or '1' state\"\n                \" in the 'ProjectorBlock' definition.\"\n            )\n\n    self.ket = ket\n    self.bra = bra\n    super().__init__(qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.ScaleBlock","title":"<code>ScaleBlock(block, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Scale blocks are created when multiplying a block by a number or parameter.</p> <p>Example: <pre><code>from qadence import X\n\nprint(X(0) * 2)\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 X(0)\n</code></pre> </p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, block: AbstractBlock, parameter: Any):\n    self.block = block\n    # TODO: more meaningful name like `scale`?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    super().__init__(block.qubit_support)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.primitive.TimeEvolutionBlock","title":"<code>TimeEvolutionBlock(qubit_support)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>Simple time evolution block with time-independent Hamiltonian.</p> <p>This class is just a convenience class which is used to label blocks which contains simple time evolution with time-independent Hamiltonian operators</p> Source code in <code>qadence/blocks/primitive.py</code> <pre><code>def __init__(self, qubit_support: tuple[int, ...]):\n    self._qubit_support = qubit_support\n</code></pre>"},{"location":"qadence/blocks/#analog-blocks","title":"Analog blocks","text":"<p>To learn how to use analog blocks and how to mix digital &amp; analog blocks, check out the digital-analog section of the documentation.</p> <p>Examples on how to use digital-analog blocks can be found in the *examples folder of the qadence repo:</p> <ul> <li>Fit a simple sinus: <code>examples/digital-analog/fit-sin.py</code></li> <li>Solve a QUBO: <code>examples/digital-analog/qubo.py</code></li> </ul>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogChain","title":"<code>AnalogChain(blocks)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>A chain of analog blocks.</p> <p>Needed because analog blocks require stricter validation than the general <code>ChainBlock</code>.</p> <p><code>AnalogChain</code>s can only be constructed from <code>AnalogKron</code> blocks or globally supported, primitive, analog blocks (like <code>InteractionBlock</code>s and <code>ConstantAnalogRotation</code>s).</p> <p>Automatically constructed by the <code>chain</code> function if only analog blocks are given.</p> <p>Example: <pre><code>from qadence import X, chain, AnalogInteraction\n\nb = chain(AnalogInteraction(200), AnalogInteraction(200))\nprint(type(b))  # this is an `AnalogChain`\n\nb = chain(X(0), AnalogInteraction(200))\nprint(type(b))  # this is a general `ChainBlock`\n</code></pre> <pre><code>&lt;class 'qadence.blocks.analog.AnalogChain'&gt;\n&lt;class 'qadence.blocks.composite.ChainBlock'&gt;\n</code></pre> </p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...]):\n    \"\"\"A chain of analog blocks.\n\n    Needed because analog blocks require\n    stricter validation than the general `ChainBlock`.\n\n    `AnalogChain`s can only be constructed from `AnalogKron` blocks or\n    _**globally supported**_, primitive, analog blocks (like `InteractionBlock`s and\n    `ConstantAnalogRotation`s).\n\n    Automatically constructed by the [`chain`][qadence.blocks.utils.chain]\n    function if only analog blocks are given.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, chain, AnalogInteraction\n\n    b = chain(AnalogInteraction(200), AnalogInteraction(200))\n    print(type(b))  # this is an `AnalogChain`\n\n    b = chain(X(0), AnalogInteraction(200))\n    print(type(b))  # this is a general `ChainBlock`\n    ```\n    \"\"\"\n    for b in blocks:\n        if not (isinstance(b, AnalogKron) or b.qubit_support.is_global):\n            raise ValueError(\"Only KronBlocks or global blocks can be chain'ed.\")\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.AnalogKron","title":"<code>AnalogKron(blocks, interaction=Interaction.NN)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogComposite</code></p> <p>Stack analog blocks vertically (i.e. in time).</p> <p>Needed because analog require stricter validation than the general <code>KronBlock</code>.</p> <p><code>AnalogKron</code>s can only be constructed from non-global, analog blocks with the same duration.</p> Source code in <code>qadence/blocks/analog.py</code> <pre><code>def __init__(self, blocks: Tuple[AnalogBlock, ...], interaction: Interaction = Interaction.NN):\n    \"\"\"Stack analog blocks vertically (i.e. in time).\n\n    Needed because analog require\n    stricter validation than the general `KronBlock`.\n\n    `AnalogKron`s can only be constructed from _**non-global**_, analog blocks\n    with the _**same duration**_.\n    \"\"\"\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    self.blocks = blocks\n    self.interaction = interaction\n\n    qubit_support = QubitSupport()\n    duration = blocks[0].duration\n    for b in blocks:\n        if not isinstance(b, AnalogBlock):\n            raise ValueError(\"Can only kron `AnalgoBlock`s with other `AnalgoBlock`s.\")\n\n        if b.qubit_support == QubitSupport(\"global\"):\n            raise ValueError(\"Blocks with global support cannot be kron'ed.\")\n\n        if not qubit_support.is_disjoint(b.qubit_support):\n            raise ValueError(\"Make sure blocks act on distinct qubits!\")\n\n        if not np.isclose(evaluate(duration), evaluate(b.duration)):\n            raise ValueError(\"Kron'ed blocks have to have same duration.\")\n\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.analog.ConstantAnalogRotation","title":"<code>ConstantAnalogRotation</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Implements a constant analog rotation with interaction dictated by the chosen Hamiltonian.</p> <pre><code>H/h = \u2211\u1d62(\u03a9/2 cos(\u03c6)*X\u1d62 - sin(\u03c6)*Y\u1d62 - \u03b4n\u1d62) + H\u1d62\u2099\u209c.\n</code></pre> <p>To construct this block you can use of the following convenience wrappers: - The general rotation operation <code>AnalogRot</code> - Shorthands for rotatins around an axis:   <code>AnalogRX</code>,   <code>AnalogRY</code>,   <code>AnalogRZ</code></p> <p>WARNING: do not use <code>ConstantAnalogRotation</code> with <code>alpha</code> as differentiable parameter - use the convenience wrappers mentioned above.</p>"},{"location":"qadence/blocks/#qadence.blocks.analog.InteractionBlock","title":"<code>InteractionBlock</code>  <code>dataclass</code>","text":"<p>             Bases: <code>AnalogBlock</code></p> <p>Free-evolution for the Hamiltonian interaction term of a register of qubits.</p> <p>In real interacting quantum devices, it means letting the system evolve freely according to the time-dependent Schrodinger equation. With emulators, this block is translated to an appropriate interaction Hamiltonian, for example, an Ising interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n</code></pre> <p>or an XY-interaction</p> <pre><code>H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2083/r\u2c7c\u2c7c\u00b3 (X\u1d62X\u2c7c + Z\u1d62Z\u2c7c)\n</code></pre> <p>with <code>n\u1d62 = (1-Z\u1d62)/2</code>.</p> <p>To construct, use the <code>AnalogInteraction</code> function.</p>"},{"location":"qadence/blocks/#composite-blocks","title":"Composite blocks","text":""},{"location":"qadence/blocks/#qadence.blocks.utils.chain","title":"<code>chain(*args)</code>","text":"<p>Chain blocks sequentially.</p> <p>On digital backends this can be interpreted loosely as a matrix mutliplication of blocks. In the analog case it chains blocks in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to chain. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator, List[AbstractBlock]]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>ChainBlock</p> <p>Example: <pre><code>from qadence import X, Y, chain\n\nb = chain(X(0), Y(0))\n\n# or use a generator\nb = chain(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def chain(*args: Union[AbstractBlock, Generator, List[AbstractBlock]]) -&gt; ChainBlock:\n    \"\"\"Chain blocks sequentially.\n\n    On digital backends this can be interpreted\n    loosely as a matrix mutliplication of blocks. In the analog case it chains\n    blocks in time.\n\n    Arguments:\n        *args: Blocks to chain. Can also be a generator.\n\n    Returns:\n        ChainBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, chain\n\n    b = chain(X(0), Y(0))\n\n    # or use a generator\n    b = chain(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogChain` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_chain(*args)  # type: ignore[return-value,arg-type]\n    return _construct(ChainBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.kron","title":"<code>kron(*args)</code>","text":"<p>Stack blocks vertically.</p> <p>On digital backends this can be intepreted loosely as a kronecker product of blocks. In the analog case it executes blocks parallel in time.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to kron. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>KronBlock</p> <p>Example: <pre><code>from qadence import X, Y, kron\n\nb = kron(X(0), Y(1))\n\n# or use a generator\nb = kron(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def kron(*args: Union[AbstractBlock, Generator]) -&gt; KronBlock:\n    \"\"\"Stack blocks vertically.\n\n    On digital backends this can be intepreted\n    loosely as a kronecker product of blocks. In the analog case it executes\n    blocks parallel in time.\n\n    Arguments:\n        *args: Blocks to kron. Can also be a generator.\n\n    Returns:\n        KronBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, kron\n\n    b = kron(X(0), Y(1))\n\n    # or use a generator\n    b = kron(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    # ugly hack to use `AnalogKron` if we are dealing only with analog blocks\n    if len(args) and all(\n        isinstance(a, AnalogBlock) or isinstance(a, AnalogComposite) for a in args\n    ):\n        return analog_kron(*args)  # type: ignore[return-value,arg-type]\n    return _construct(KronBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.utils.add","title":"<code>add(*args)</code>","text":"<p>Sums blocks.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Blocks to add. Can also be a generator.</p> <p> TYPE: <code>Union[AbstractBlock, Generator]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>AddBlock</code> <p>AddBlock</p> <p>Example: <pre><code>from qadence import X, Y, add\n\nb = add(X(0), Y(0))\n\n# or use a generator\nb = add(X(i) for i in range(3))\nprint(b)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> </p> Source code in <code>qadence/blocks/utils.py</code> <pre><code>def add(*args: Union[AbstractBlock, Generator]) -&gt; AddBlock:\n    \"\"\"Sums blocks.\n\n    Arguments:\n        *args: Blocks to add. Can also be a generator.\n\n    Returns:\n        AddBlock\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import X, Y, add\n\n    b = add(X(0), Y(0))\n\n    # or use a generator\n    b = add(X(i) for i in range(3))\n    print(b)\n    ```\n    \"\"\"\n    return _construct(AddBlock, args)\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.AddBlock","title":"<code>AddBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Adds blocks.</p> <p>Constructed via <code>add</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.ChainBlock","title":"<code>ChainBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Chains blocks sequentially.</p> <p>Constructed via <code>chain</code></p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#qadence.blocks.composite.CompositeBlock","title":"<code>CompositeBlock</code>","text":"<p>             Bases: <code>AbstractBlock</code></p> <p>Block which composes multiple blocks into one larger block (which can again be composed).</p> <p>Composite blocks are constructed via <code>chain</code>, <code>kron</code>, and <code>add</code>.</p>"},{"location":"qadence/blocks/#qadence.blocks.composite.KronBlock","title":"<code>KronBlock(blocks)</code>","text":"<p>             Bases: <code>CompositeBlock</code></p> <p>Stacks blocks horizontally.</p> <p>Constructed via <code>kron</code>.</p> Source code in <code>qadence/blocks/composite.py</code> <pre><code>def __init__(self, blocks: Tuple[AbstractBlock, ...]):\n    if len(blocks) == 0:\n        raise NotImplementedError(\"Empty KronBlocks not supported\")\n\n    qubit_support = QubitSupport()\n    for b in blocks:\n        assert (\n            QubitSupportType.GLOBAL,\n        ) != b.qubit_support, \"Blocks with global support cannot be kron'ed.\"\n        assert qubit_support.is_disjoint(\n            b.qubit_support\n        ), \"Make sure blocks act on distinct qubits!\"\n        qubit_support += b.qubit_support\n\n    self.blocks = blocks\n</code></pre>"},{"location":"qadence/blocks/#converting-blocks-to-matrices","title":"Converting blocks to matrices","text":""},{"location":"qadence/blocks/#qadence.blocks.block_to_tensor.block_to_tensor","title":"<code>block_to_tensor(block, values={}, qubit_support=None, use_full_support=True, tensor_type=TensorType.DENSE, endianness=Endianness.BIG, device=torch.device('cpu'))</code>","text":"<p>Convert a block into a torch tensor.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to convert.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>values</code> <p>A optional dict with values for parameters.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>qubit_support</code> <p>The qubit_support of the block.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>use_full_support</code> <p>True infers the total number of qubits.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>tensor_type</code> <p>the target tensor type.</p> <p> TYPE: <code>TensorType</code> DEFAULT: <code>DENSE</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\nblock = hea(2,2)\nprint(block_to_tensor(block))\n\n# In case you have a diagonal observable, you can use\nobs = hamiltonian_factory(2, detuning = Z)\nprint(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n</code></pre> <pre><code>tensor([[[ 0.1205+0.2779j, -0.4028-0.5196j, -0.6412+0.0323j, -0.2348-0.0933j],\n         [-0.1532-0.2579j,  0.3364+0.4789j, -0.6311-0.0889j, -0.3710+0.1539j],\n         [-0.2295-0.6436j, -0.0058-0.3170j,  0.1553+0.2692j, -0.3819-0.4360j],\n         [-0.0921-0.5856j, -0.2621-0.2365j, -0.1598-0.2440j,  0.4385+0.4966j]]],\n       grad_fn=&lt;UnsafeViewBackward0&gt;)\ntensor(indices=tensor([[0, 3],\n                       [0, 3]]),\n       values=tensor([ 2.+0.j, -2.+0.j]),\n       size=(4, 4), nnz=2, layout=torch.sparse_coo)\n</code></pre> </p> Source code in <code>qadence/blocks/block_to_tensor.py</code> <pre><code>def block_to_tensor(\n    block: AbstractBlock,\n    values: dict[str, TNumber | torch.Tensor] = {},\n    qubit_support: tuple | None = None,\n    use_full_support: bool = True,\n    tensor_type: TensorType = TensorType.DENSE,\n    endianness: Endianness = Endianness.BIG,\n    device: torch.device = torch.device(\"cpu\"),\n) -&gt; torch.Tensor:\n    \"\"\"\n    Convert a block into a torch tensor.\n\n    Arguments:\n        block (AbstractBlock): The block to convert.\n        values (dict): A optional dict with values for parameters.\n        qubit_support (tuple): The qubit_support of the block.\n        use_full_support (bool): True infers the total number of qubits.\n        tensor_type (TensorType): the target tensor type.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import hea, hamiltonian_factory, Z, block_to_tensor\n\n    block = hea(2,2)\n    print(block_to_tensor(block))\n\n    # In case you have a diagonal observable, you can use\n    obs = hamiltonian_factory(2, detuning = Z)\n    print(block_to_tensor(obs, tensor_type=\"SparseDiagonal\"))\n    ```\n    \"\"\"\n\n    # FIXME: default use_full_support to False. In general, it would\n    # be more efficient to do that, and make sure that computations such\n    # as observables only do the matmul of the size of the qubit support.\n\n    if tensor_type == TensorType.DENSE:\n        from qadence.blocks import embedding\n\n        (ps, embed) = embedding(block)\n        return _block_to_tensor_embedded(\n            block,\n            embed(ps, values),\n            qubit_support,\n            use_full_support,\n            endianness=endianness,\n            device=device,\n        )\n\n    elif tensor_type == TensorType.SPARSEDIAGONAL:\n        t = block_to_diagonal(block, endianness=endianness)\n        indices, values, size = torch.nonzero(t), t[t != 0], len(t)\n        indices = torch.stack((indices.flatten(), indices.flatten()))\n        return torch.sparse_coo_tensor(indices, values, (size, size))\n</code></pre>"},{"location":"qadence/constructors/","title":"Constructors for common quantum circuits","text":""},{"location":"qadence/constructors/#qadence.constructors.feature_maps.chebyshev_feature_map","title":"<code>chebyshev_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>The qubit support</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def chebyshev_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        support (Iterable[int]): The qubit support\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'chebyshev_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.CHEBYSHEV)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.exp_fourier_feature_map","title":"<code>exp_fourier_feature_map(n_qubits, support=None, param='x', feature_range=None)</code>","text":"<p>Exponential fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the feature</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>name of feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'x'</code> </p> <code>feature_range</code> <p>min and max value of the feature, as floats in a Tuple</p> <p> TYPE: <code>tuple[float, float]</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def exp_fourier_feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    param: str = \"x\",\n    feature_range: tuple[float, float] = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Exponential fourier feature map.\n\n    Args:\n        n_qubits: number of qubits in the feature\n        support: qubit support\n        param: name of feature `Parameter`\n        feature_range: min and max value of the feature, as floats in a Tuple\n    \"\"\"\n\n    if feature_range is None:\n        feature_range = (0.0, 2.0**n_qubits)\n\n    support = tuple(range(n_qubits)) if support is None else support\n    hlayer = kron(H(qubit) for qubit in support)\n    rlayer = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=RZ,\n        fm_type=BasisSet.FOURIER,\n        reupload_scaling=ReuploadScaling.EXP,\n        feature_range=feature_range,\n        target_range=(0.0, 2 * PI),\n    )\n    rlayer.tag = None\n    return tag(chain(hlayer, rlayer), f\"ExpFourierFM({param})\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.feature_map","title":"<code>feature_map(n_qubits, support=None, param='phi', op=RX, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT, feature_range=None, target_range=None, multiplier=None, param_prefix=None)</code>","text":"<p>Construct a feature map of a given type.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>Number of qubits the feature map covers. Results in <code>support=range(n_qubits)</code>.</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>Puts one feature-encoding rotation gate on every qubit in <code>support</code>. n_qubits in this case specifies the total overall qubits of the circuit, which may be wider than the support itself, but not narrower.</p> <p> TYPE: <code>tuple[int, ...] | None</code> DEFAULT: <code>None</code> </p> <code>param</code> <p>Parameter of the feature map; you can pass a string or Parameter; it will be set as non-trainable (FeatureParameter) regardless.</p> <p> TYPE: <code>Parameter | str</code> DEFAULT: <code>'phi'</code> </p> <code>op</code> <p>Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.</p> <p> TYPE: <code>RotationTypes</code> DEFAULT: <code>RX</code> </p> <code>fm_type</code> <p>Basis set for data encoding; choose from <code>BasisSet.FOURIER</code> for Fourier encoding, or <code>BasisSet.CHEBYSHEV</code> for Chebyshev polynomials of the first kind.</p> <p> TYPE: <code>BasisSet | Callable | str</code> DEFAULT: <code>FOURIER</code> </p> <code>reupload_scaling</code> <p>how the feature map scales the data that is re-uploaded for each qubit. choose from <code>ReuploadScaling</code> enumeration or provide your own function with a single int as input and int or float as output.</p> <p> TYPE: <code>ReuploadScaling | Callable | str</code> DEFAULT: <code>CONSTANT</code> </p> <code>feature_range</code> <p>range of data that the input data provided comes from. Used to map input data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>target_range</code> <p>range of data the data encoder assumes as the natural range. For example, in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI). Used to map data to the correct domain of the feature-encoding function.</p> <p> TYPE: <code>tuple[float, float] | None</code> DEFAULT: <code>None</code> </p> <code>multiplier</code> <p>overall multiplier; this is useful for reuploading the feature map serially with different scalings; can be a number or parameter/expression.</p> <p> TYPE: <code>Parameter | TParameter | None</code> DEFAULT: <code>None</code> </p> <code>param_prefix</code> <p>string prefix to create trainable parameters multiplying the feature parameter inside the feature-encoding function. Note that currently this does not take into account the domain of the feature-encoding function.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <p>Example: <pre><code>from qadence import feature_map, BasisSet, ReuploadScaling\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\nprint(f\"{fm = }\")\n\nfm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\nprint(f\"{fm = }\")\n</code></pre> <pre><code>fm = KronBlock(0,1,2) [tag: Constant Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['phi']]\n\u251c\u2500\u2500 RX(1) [params: ['phi']]\n\u2514\u2500\u2500 RX(2) [params: ['phi']]\nfm = KronBlock(0,1,2) [tag: Constant Chebyshev FM]\n\u251c\u2500\u2500 RX(0) [params: ['acos(phi)']]\n\u251c\u2500\u2500 RX(1) [params: ['acos(phi)']]\n\u2514\u2500\u2500 RX(2) [params: ['acos(phi)']]\nfm = KronBlock(0,1,2) [tag: Tower Fourier FM]\n\u251c\u2500\u2500 RX(0) [params: ['1_0*phi']]\n\u251c\u2500\u2500 RX(1) [params: ['2_0*phi']]\n\u2514\u2500\u2500 RX(2) [params: ['3_0*phi']]\n</code></pre> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def feature_map(\n    n_qubits: int,\n    support: tuple[int, ...] | None = None,\n    param: Parameter | str = \"phi\",\n    op: RotationTypes = RX,\n    fm_type: BasisSet | Callable | str = BasisSet.FOURIER,\n    reupload_scaling: ReuploadScaling | Callable | str = ReuploadScaling.CONSTANT,\n    feature_range: tuple[float, float] | None = None,\n    target_range: tuple[float, float] | None = None,\n    multiplier: Parameter | TParameter | None = None,\n    param_prefix: str | None = None,\n) -&gt; KronBlock:\n    \"\"\"Construct a feature map of a given type.\n\n    Arguments:\n        n_qubits: Number of qubits the feature map covers. Results in `support=range(n_qubits)`.\n        support: Puts one feature-encoding rotation gate on every qubit in `support`. n_qubits in\n            this case specifies the total overall qubits of the circuit, which may be wider than the\n            support itself, but not narrower.\n        param: Parameter of the feature map; you can pass a string or Parameter;\n            it will be set as non-trainable (FeatureParameter) regardless.\n        op: Rotation operation of the feature map; choose from RX, RY, RZ or PHASE.\n        fm_type: Basis set for data encoding; choose from `BasisSet.FOURIER` for Fourier\n            encoding, or `BasisSet.CHEBYSHEV` for Chebyshev polynomials of the first kind.\n        reupload_scaling: how the feature map scales the data that is re-uploaded for each qubit.\n            choose from `ReuploadScaling` enumeration or provide your own function with a single\n            int as input and int or float as output.\n        feature_range: range of data that the input data provided comes from. Used to map input data\n            to the correct domain of the feature-encoding function.\n        target_range: range of data the data encoder assumes as the natural range. For example,\n            in Chebyshev polynomials it is (-1, 1), while for Fourier it may be chosen as (0, 2*PI).\n            Used to map data to the correct domain of the feature-encoding function.\n        multiplier: overall multiplier; this is useful for reuploading the feature map serially with\n            different scalings; can be a number or parameter/expression.\n        param_prefix: string prefix to create trainable parameters multiplying the feature parameter\n            inside the feature-encoding function. Note that currently this does not take into\n            account the domain of the feature-encoding function.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import feature_map, BasisSet, ReuploadScaling\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.CHEBYSHEV)\n    print(f\"{fm = }\")\n\n    fm = feature_map(3, fm_type=BasisSet.FOURIER, reupload_scaling = ReuploadScaling.TOWER)\n    print(f\"{fm = }\")\n    ```\n    \"\"\"\n\n    # Process input\n    if support is None:\n        support = tuple(range(n_qubits))\n    elif len(support) != n_qubits:\n        raise ValueError(\"Wrong qubit support supplied\")\n\n    if op not in ROTATIONS:\n        raise ValueError(\n            f\"Operation {op} not supported. \"\n            f\"Please provide one from {[rot.__name__ for rot in ROTATIONS]}.\"\n        )\n\n    # Backwards compatibility\n    fm_type, reupload_scaling = backwards_compatibility(fm_type, reupload_scaling)\n\n    scaled_fparam = fm_parameter_scaling(\n        fm_type, param, feature_range=feature_range, target_range=target_range\n    )\n\n    transform_func = fm_parameter_func(fm_type)\n\n    basis_tag = fm_type.value if isinstance(fm_type, BasisSet) else str(fm_type)\n    rs_func, rs_tag = fm_reupload_scaling_fn(reupload_scaling)\n\n    # Set overall multiplier\n    multiplier = 1 if multiplier is None else Parameter(multiplier)\n\n    # Build feature map\n    op_list = []\n    fparam = scaled_fparam\n    for i, qubit in enumerate(support):\n        if param_prefix is not None:\n            train_param = VariationalParameter(param_prefix + f\"_{i}\")\n            fparam = train_param * scaled_fparam\n        op_list.append(op(qubit, multiplier * rs_func(i) * transform_func(fparam)))\n    fm = kron(*op_list)\n\n    fm.tag = rs_tag + \" \" + basis_tag + \" FM\"\n\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.fourier_feature_map","title":"<code>fourier_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Fourier feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def fourier_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Fourier feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'fourier_feature_map' is deprecated. Please use 'feature_map' directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(n_qubits, support=support, param=param, op=op, fm_type=BasisSet.FOURIER)\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.feature_maps.tower_feature_map","title":"<code>tower_feature_map(n_qubits, support=None, param='phi', op=RX)</code>","text":"<p>Construct a Chebyshev tower feature map.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits across which the FM is created</p> <p> TYPE: <code>int</code> </p> <code>param</code> <p>The base name for the feature <code>Parameter</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'phi'</code> </p> Source code in <code>qadence/constructors/feature_maps.py</code> <pre><code>def tower_feature_map(\n    n_qubits: int, support: tuple[int, ...] = None, param: str = \"phi\", op: RotationTypes = RX\n) -&gt; AbstractBlock:\n    \"\"\"Construct a Chebyshev tower feature map.\n\n    Args:\n        n_qubits: number of qubits across which the FM is created\n        param: The base name for the feature `Parameter`\n    \"\"\"\n    warnings.warn(\n        \"Function 'tower_feature_map' is deprecated. Please use feature_map directly.\",\n        FutureWarning,\n    )\n    fm = feature_map(\n        n_qubits,\n        support=support,\n        param=param,\n        op=op,\n        fm_type=BasisSet.CHEBYSHEV,\n        reupload_scaling=ReuploadScaling.TOWER,\n    )\n    return fm\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.build_qnn","title":"<code>build_qnn(n_qubits, n_features, depth=None, ansatz=None, fm_pauli=RY, spectrum='simple', basis='fourier', fm_strategy='parallel')</code>","text":"<p>Helper function to build a qadence QNN quantum circuit.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of input dimensions.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>The depth of the ansatz.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>ansatz</code> <p>An optional argument to pass a custom qadence ansatz.</p> <p> TYPE: <code>Optional[AbstractBlock]</code> DEFAULT: <code>None</code> </p> <code>fm_pauli</code> <p>The type of Pauli gate for the feature map. Must be one of 'RX', 'RY', or 'RZ'.</p> <p> TYPE: <code>str</code> DEFAULT: <code>RY</code> </p> <code>spectrum</code> <p>The desired spectrum of the feature map generator. The options simple, tower and exponential produce a spectrum with linear, quadratic and exponential eigenvalues with respect to the number of qubits.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'simple'</code> </p> <code>basis</code> <p>The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x and arcos(x) respectively.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'fourier'</code> </p> <code>fm_strategy</code> <p>The feature map encoding strategy. If \"parallel\", the features are encoded in one block of rotation gates, with each feature given an equal number of qubits. If \"serial\", the features are encoded sequentially, with a HEA block between.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'parallel'</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>A list of Abstract blocks to be used for constructing a quantum circuit</p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def build_qnn(\n    n_qubits: int,\n    n_features: int,\n    depth: int = None,\n    ansatz: Optional[AbstractBlock] = None,\n    fm_pauli: Type[RY] = RY,\n    spectrum: str = \"simple\",\n    basis: str = \"fourier\",\n    fm_strategy: str = \"parallel\",\n) -&gt; list[AbstractBlock]:\n    \"\"\"Helper function to build a qadence QNN quantum circuit.\n\n    Args:\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of input dimensions.\n        depth (int): The depth of the ansatz.\n        ansatz (Optional[AbstractBlock]):  An optional argument to pass a custom qadence ansatz.\n        fm_pauli (str): The type of Pauli gate for the feature map. Must be one of 'RX',\n            'RY', or 'RZ'.\n        spectrum (str): The desired spectrum of the feature map generator. The options simple,\n            tower and exponential produce a spectrum with linear, quadratic and exponential\n            eigenvalues with respect to the number of qubits.\n        basis (str): The encoding function. The options fourier and chebyshev correspond to \u03a6(x)=x\n            and arcos(x) respectively.\n        fm_strategy (str): The feature map encoding strategy. If \"parallel\", the features\n            are encoded in one block of rotation gates, with each feature given\n            an equal number of qubits. If \"serial\", the features are encoded\n            sequentially, with a HEA block between.\n\n    Returns:\n        A list of Abstract blocks to be used for constructing a quantum circuit\n    \"\"\"\n    depth = n_qubits if depth is None else depth\n\n    idx_fms = build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)\n\n    if fm_strategy == \"parallel\":\n        _fm = kron(*idx_fms)\n        fm = tag(_fm, tag=\"FM\")\n\n    elif fm_strategy == \"serial\":\n        fm_components: list[AbstractBlock] = []\n        for j, fm_idx in enumerate(idx_fms[:-1]):\n            fm_idx = tag(fm_idx, tag=f\"FM{j}\")  # type: ignore[assignment]\n            fm_component = (fm_idx, hea(n_qubits, 1, f\"theta_{j}\"))\n            fm_components.extend(fm_component)\n        fm_components.append(tag(idx_fms[-1], tag=f\"FM{len(idx_fms) - 1}\"))\n        fm = chain(*fm_components)  # type: ignore[assignment]\n\n    ansatz = hea(n_qubits, depth=depth) if ansatz is None else ansatz\n    return [fm, ansatz]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea","title":"<code>hea(n_qubits, depth=1, param_prefix='theta', support=None, strategy=Strategy.DIGITAL, **strategy_args)</code>","text":"<p>Factory function for the Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.DigitalAnalog</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>**strategy_args</code> <p>see below</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> PARAMETER DESCRIPTION <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer. Valid for Digital and DigitalAnalog HEA.</p> <p> TYPE: <code>list</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c. Valid for only for Digital HEA.</p> <p> TYPE: <code>bool</code> </p> <code>entangler</code> <ul> <li>Digital: 2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational parameters on the rotation angles.</li> <li>DigitaAnalog | Analog: Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</li> </ul> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples: <pre><code>from qadence import RZ, RX\nfrom qadence import hea\n\n# create the circuit\nn_qubits, depth = 2, 4\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    strategy=\"sDAQC\",\n    operations=[RZ,RX,RZ]\n)\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    support: tuple[int, ...] = None,\n    strategy: Strategy = Strategy.DIGITAL,\n    **strategy_args: Any,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Factory function for the Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits: number of qubits in the block\n        depth: number of layers of the HEA\n        param_prefix: the base name of the variational parameters\n        support: qubit indexes where the HEA is applied\n        strategy: Strategy.Digital or Strategy.DigitalAnalog\n        **strategy_args: see below\n\n    Keyword Arguments:\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer. Valid for\n            Digital and DigitalAnalog HEA.\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c. Valid for only\n            for Digital HEA.\n        entangler (AbstractBlock):\n            - Digital: 2-qubit entangling operation. Supports CNOT, CZ,\n            CRX, CRY, CRZ, CPHASE. Controlled rotations will have variational\n            parameters on the rotation angles.\n            - DigitaAnalog | Analog: Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import RZ, RX\n    from qadence import hea\n\n    # create the circuit\n    n_qubits, depth = 2, 4\n    ansatz = hea(\n        n_qubits=n_qubits,\n        depth=depth,\n        strategy=\"sDAQC\",\n        operations=[RZ,RX,RZ]\n    )\n    ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    hea_func_dict = {\n        Strategy.DIGITAL: hea_digital,\n        Strategy.SDAQC: hea_sDAQC,\n        Strategy.BDAQC: hea_bDAQC,\n        Strategy.ANALOG: hea_analog,\n    }\n\n    try:\n        hea_func = hea_func_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    hea_block: AbstractBlock = hea_func(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        **strategy_args,\n    )  # type: ignore\n\n    return hea_block\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_digital","title":"<code>hea_digital(n_qubits, depth=1, param_prefix='theta', periodic=False, operations=[RX, RY, RX], support=None, entangler=CNOT)</code>","text":"<p>Construct the Digital Hardware Efficient Ansatz (HEA).</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>periodic</code> <p>if the qubits should be linked periodically. periodic=False is not supported in emu-c.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>2-qubit entangling operation. Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations will have variational parameters on the rotation angles.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>CNOT</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_digital(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    periodic: bool = False,\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: Type[DigitalEntanglers] = CNOT,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Digital Hardware Efficient Ansatz (HEA).\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        periodic (bool): if the qubits should be linked periodically.\n            periodic=False is not supported in emu-c.\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): 2-qubit entangling operation.\n            Supports CNOT, CZ, CRX, CRY, CRZ. Controlld rotations\n            will have variational parameters on the rotation angles.\n    \"\"\"\n    try:\n        if entangler not in [CNOT, CZ, CRX, CRY, CRZ, CPHASE]:\n            raise ValueError(\n                \"Please provide a valid two-qubit entangler operation for digital HEA.\"\n            )\n    except TypeError:\n        raise ValueError(\"Please provide a valid two-qubit entangler operation for digital HEA.\")\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        periodic=periodic,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.ansatze.hea_sDAQC","title":"<code>hea_sDAQC(n_qubits, depth=1, param_prefix='theta', operations=[RX, RY, RX], support=None, entangler=None)</code>","text":"<p>Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.</p> <p>It uses step-wise digital-analog computation.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the block.</p> <p> TYPE: <code>int</code> </p> <code>depth</code> <p>number of layers of the HEA.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>param_prefix</code> <p>the base name of the variational parameters</p> <p> TYPE: <code>str</code> DEFAULT: <code>'theta'</code> </p> <code>operations</code> <p>list of operations to cycle through in the digital single-qubit rotations of each layer.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[RX, RY, RX]</code> </p> <code>support</code> <p>qubit indexes where the HEA is applied.</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>None</code> </p> <code>entangler</code> <p>Hamiltonian generator for the analog entangling layer. Defaults to global ZZ Hamiltonian. Time parameter is considered variational.</p> <p> TYPE: <code>AbstractBlock</code> DEFAULT: <code>None</code> </p> Source code in <code>qadence/constructors/ansatze.py</code> <pre><code>def hea_sDAQC(\n    n_qubits: int,\n    depth: int = 1,\n    param_prefix: str = \"theta\",\n    operations: list[type[AbstractBlock]] = [RX, RY, RX],\n    support: tuple[int, ...] = None,\n    entangler: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Construct the Hardware Efficient Ansatz (HEA) with analog entangling layers.\n\n    It uses step-wise digital-analog computation.\n\n    Args:\n        n_qubits (int): number of qubits in the block.\n        depth (int): number of layers of the HEA.\n        param_prefix (str): the base name of the variational parameters\n        operations (list): list of operations to cycle through in the\n            digital single-qubit rotations of each layer.\n        support (tuple): qubit indexes where the HEA is applied.\n        entangler (AbstractBlock): Hamiltonian generator for the\n            analog entangling layer. Defaults to global ZZ Hamiltonian.\n            Time parameter is considered variational.\n    \"\"\"\n\n    # TODO: Add qubit support\n    if entangler is None:\n        entangler = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n    try:\n        if not block_is_qubit_hamiltonian(entangler):\n            raise ValueError(\n                \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n            )\n    except NotImplementedError:\n        raise ValueError(\n            \"Please provide a valid Pauli Hamiltonian generator for digital-analog HEA.\"\n        )\n\n    rot_list = _rotations_digital(\n        n_qubits=n_qubits,\n        depth=depth,\n        param_prefix=param_prefix,\n        support=support,\n        operations=operations,\n    )\n\n    ent_list = _entanglers_analog(\n        depth=depth,\n        param_prefix=param_prefix,\n        entangler=entangler,\n    )\n\n    layers = []\n    for d in range(depth):\n        layers.append(rot_list[d])\n        layers.append(ent_list[d])\n    return tag(chain(*layers), \"HEA-sDA\")\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.hamiltonian_factory","title":"<code>hamiltonian_factory(register, interaction=None, detuning=None, interaction_strength=None, detuning_strength=None, random_strength=False, use_all_node_pairs=False)</code>","text":"<p>General Hamiltonian creation function.</p> <p>Can be used to create Hamiltonians with 2-qubit interactions and single-qubit detunings, both with arbitrary strength or parameterized.</p> PARAMETER  DESCRIPTION <code>register</code> <p>register of qubits with a specific graph topology, or number of qubits. When passing a number of qubits a register with all-to-all connectivity is created.</p> <p> TYPE: <code>Register | int</code> </p> <code>interaction</code> <p>Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.</p> <p> TYPE: <code>Interaction | Callable | None</code> DEFAULT: <code>None</code> </p> <code>detuning</code> <p>single-qubit operator N, X, Y, or Z.</p> <p> TYPE: <code>TDetuning | None</code> DEFAULT: <code>None</code> </p> <code>interaction_strength</code> <p>list of values to be used as the interaction strength for each pair of qubits. Should be ordered following the order of <code>Register(n_qubits).edges</code>. Alternatively, some string \"x\" can be passed, which will create a parameterized interactions for each pair of qubits, each labelled as <code>\"x_ij\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>detuning_strength</code> <p>list of values to be used as the detuning strength for each qubit. Alternatively, some string \"x\" can be passed, which will create a parameterized detuning for each qubit, each labelled as <code>\"x_i\"</code>.</p> <p> TYPE: <code>TArray | str | None</code> DEFAULT: <code>None</code> </p> <code>random_strength</code> <p>set random interaction and detuning strengths between -1 and 1.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>use_all_node_pairs</code> <p>computes an interaction term for every pair of nodes in the graph, independent of the edge topology in the register. Useful for defining Hamiltonians where the interaction strength decays with the distance.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>from qadence import hamiltonian_factory, Interaction, Register, Z\n\nn_qubits = 3\n\n# Constant total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\n\n# Parameterized total magnetization observable:\nobservable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n# Random all-to-all XY Hamiltonian generator:\ngenerator = hamiltonian_factory(\n    n_qubits,\n    interaction = Interaction.XY,\n    random_strength = True,\n    )\n\n# Parameterized NN Hamiltonian generator with a square grid interaction topology:\nregister = Register.square(qubits_side = n_qubits)\ngenerator = hamiltonian_factory(\n    register,\n    interaction = Interaction.NN,\n    interaction_strength = \"theta\"\n    )\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def hamiltonian_factory(\n    register: Register | int,\n    interaction: Interaction | Callable | None = None,\n    detuning: TDetuning | None = None,\n    interaction_strength: TArray | str | None = None,\n    detuning_strength: TArray | str | None = None,\n    random_strength: bool = False,\n    use_all_node_pairs: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    General Hamiltonian creation function.\n\n    Can be used to create Hamiltonians with 2-qubit\n    interactions and single-qubit detunings, both with arbitrary strength or parameterized.\n\n    Arguments:\n        register: register of qubits with a specific graph topology, or number of qubits.\n            When passing a number of qubits a register with all-to-all connectivity\n            is created.\n        interaction: Interaction.ZZ, Interaction.NN, Interaction.XY, or Interacton.XYZ.\n        detuning: single-qubit operator N, X, Y, or Z.\n        interaction_strength: list of values to be used as the interaction strength for each\n            pair of qubits. Should be ordered following the order of `Register(n_qubits).edges`.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            interactions for each pair of qubits, each labelled as `\"x_ij\"`.\n        detuning_strength: list of values to be used as the detuning strength for each qubit.\n            Alternatively, some string \"x\" can be passed, which will create a parameterized\n            detuning for each qubit, each labelled as `\"x_i\"`.\n        random_strength: set random interaction and detuning strengths between -1 and 1.\n        use_all_node_pairs: computes an interaction term for every pair of nodes in the graph,\n            independent of the edge topology in the register. Useful for defining Hamiltonians\n            where the interaction strength decays with the distance.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import hamiltonian_factory, Interaction, Register, Z\n\n        n_qubits = 3\n\n        # Constant total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z)\n\n        # Parameterized total magnetization observable:\n        observable = hamiltonian_factory(n_qubits, detuning = Z, detuning_strength = \"z\")\n\n        # Random all-to-all XY Hamiltonian generator:\n        generator = hamiltonian_factory(\n            n_qubits,\n            interaction = Interaction.XY,\n            random_strength = True,\n            )\n\n        # Parameterized NN Hamiltonian generator with a square grid interaction topology:\n        register = Register.square(qubits_side = n_qubits)\n        generator = hamiltonian_factory(\n            register,\n            interaction = Interaction.NN,\n            interaction_strength = \"theta\"\n            )\n        ```\n    \"\"\"\n\n    if interaction is None and detuning is None:\n        raise ValueError(\"Please provide an interaction and/or detuning for the Hamiltonian.\")\n\n    # If number of qubits is given, creates all-to-all register\n    register = Register(register) if isinstance(register, int) else register\n\n    # Get interaction function\n    if interaction is not None:\n        if callable(interaction):\n            int_fn = interaction\n            try:\n                if not block_is_qubit_hamiltonian(interaction(0, 1)):\n                    raise ValueError(\"Custom interactions must be composed of Pauli operators.\")\n            except TypeError:\n                raise TypeError(\n                    \"Please use a custom interaction function signed with two integer parameters.\"\n                )\n        else:\n            int_fn = INTERACTION_DICT.get(interaction, None)  # type: ignore [arg-type]\n            if int_fn is None:\n                raise KeyError(f\"Interaction {interaction} not supported.\")\n\n    # Check single-qubit detuning\n    if (detuning is not None) and (detuning not in DETUNINGS):\n        raise TypeError(f\"Detuning of type {type(detuning)} not supported.\")\n\n    # Pre-process detuning and interaction strengths and update register\n    detuning_strength_array = _preprocess_strengths(\n        register, detuning_strength, \"nodes\", random_strength\n    )\n\n    edge_str = \"all_node_pairs\" if use_all_node_pairs else \"edges\"\n    interaction_strength_array = _preprocess_strengths(\n        register, interaction_strength, edge_str, random_strength\n    )\n\n    # Create single-qubit detunings:\n    single_qubit_terms: List[AbstractBlock] = []\n    if detuning is not None:\n        for strength, node in zip(detuning_strength_array, register.nodes):\n            single_qubit_terms.append(strength * detuning(node))\n\n    # Create two-qubit interactions:\n    two_qubit_terms: List[AbstractBlock] = []\n    edge_data = register.all_node_pairs if use_all_node_pairs else register.edges\n    if interaction is not None and int_fn is not None:\n        for strength, edge in zip(interaction_strength_array, edge_data):\n            two_qubit_terms.append(strength * int_fn(*edge))\n\n    return add(*single_qubit_terms, *two_qubit_terms)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_nn","title":"<code>interaction_nn(i, j)</code>","text":"<p>Ising NN interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_nn(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising NN interaction.\"\"\"\n    return N(i) @ N(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xy","title":"<code>interaction_xy(i, j)</code>","text":"<p>XY interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xy(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"XY interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_xyz","title":"<code>interaction_xyz(i, j)</code>","text":"<p>Heisenberg XYZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_xyz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Heisenberg XYZ interaction.\"\"\"\n    return X(i) @ X(j) + Y(i) @ Y(j) + Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.hamiltonians.interaction_zz","title":"<code>interaction_zz(i, j)</code>","text":"<p>Ising ZZ interaction.</p> Source code in <code>qadence/constructors/hamiltonians.py</code> <pre><code>def interaction_zz(i: int, j: int) -&gt; AbstractBlock:\n    \"\"\"Ising ZZ interaction.\"\"\"\n    return Z(i) @ Z(j)\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.qft.qft","title":"<code>qft(n_qubits, support=None, inverse=False, reverse_in=False, swaps_out=False, strategy=Strategy.DIGITAL, gen_build=None)</code>","text":"<p>The Quantum Fourier Transform.</p> <p>Depending on the application, user should be careful with qubit ordering in the input and output. This can be controlled with reverse_in and swaps_out arguments.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of qubits in the QFT</p> <p> TYPE: <code>int</code> </p> <code>support</code> <p>qubit support to use</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <code>inverse</code> <p>True performs the inverse QFT</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reverse_in</code> <p>Reverses the input qubits to account for endianness</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>swaps_out</code> <p>Performs swaps on the output qubits to match the \"textbook\" QFT.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>strategy</code> <p>Strategy.Digital or Strategy.sDAQC</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>DIGITAL</code> </p> <code>gen_build</code> <p>building block Ising Hamiltonian for the DAQC transform. Defaults to constant all-to-all Ising.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import qft\n\nn_qubits = 3\n\nqft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/qft.py</code> <pre><code>def qft(\n    n_qubits: int,\n    support: tuple[int, ...] = None,\n    inverse: bool = False,\n    reverse_in: bool = False,\n    swaps_out: bool = False,\n    strategy: Strategy = Strategy.DIGITAL,\n    gen_build: AbstractBlock | None = None,\n) -&gt; AbstractBlock:\n    \"\"\"\n    The Quantum Fourier Transform.\n\n    Depending on the application, user should be careful with qubit ordering\n    in the input and output. This can be controlled with reverse_in and swaps_out\n    arguments.\n\n    Args:\n        n_qubits: number of qubits in the QFT\n        support: qubit support to use\n        inverse: True performs the inverse QFT\n        reverse_in: Reverses the input qubits to account for endianness\n        swaps_out: Performs swaps on the output qubits to match the \"textbook\" QFT.\n        strategy: Strategy.Digital or Strategy.sDAQC\n        gen_build: building block Ising Hamiltonian for the DAQC transform.\n            Defaults to constant all-to-all Ising.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import qft\n\n        n_qubits = 3\n\n        qft_circuit = qft(n_qubits, strategy = \"sDAQC\")\n        ```\n    \"\"\"\n\n    if support is None:\n        support = tuple(range(n_qubits))\n\n    assert len(support) &lt;= n_qubits, \"Wrong qubit support supplied\"\n\n    if reverse_in:\n        support = support[::-1]\n\n    qft_layer_dict = {\n        Strategy.DIGITAL: _qft_layer_digital,\n        Strategy.SDAQC: _qft_layer_sDAQC,\n        Strategy.BDAQC: _qft_layer_bDAQC,\n        Strategy.ANALOG: _qft_layer_analog,\n    }\n\n    try:\n        layer_func = qft_layer_dict[strategy]\n    except KeyError:\n        raise KeyError(f\"Strategy {strategy} not recognized.\")\n\n    qft_layers = reversed(range(n_qubits)) if inverse else range(n_qubits)\n\n    qft_circ = chain(\n        layer_func(\n            n_qubits=n_qubits, support=support, layer=layer, inverse=inverse, gen_build=gen_build\n        )  # type: ignore\n        for layer in qft_layers\n    )\n\n    if swaps_out:\n        swap_ops = [SWAP(support[i], support[n_qubits - i - 1]) for i in range(n_qubits // 2)]\n        qft_circ = chain(*swap_ops, qft_circ) if inverse else chain(qft_circ, *swap_ops)\n\n    return tag(qft_circ, tag=\"iQFT\") if inverse else tag(qft_circ, tag=\"QFT\")\n</code></pre>"},{"location":"qadence/constructors/#hardware-efficient-ansatz-for-rydberg-atom-arrays","title":"Hardware efficient ansatz for Rydberg atom arrays","text":""},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea","title":"<code>rydberg_hea(register, n_layers=1, addressable_detuning=True, addressable_drive=False, tunable_phase=False, additional_prefix=None)</code>","text":"<p>Hardware efficient ansatz for neutral atom (Rydberg) platforms.</p> <p>This constructor implements a variational ansatz which is very close to what is implementable on 2nd generation PASQAL quantum devices. In particular, it implements evolution over a specific Hamiltonian which can be realized on the device. This Hamiltonian contains:</p> <ul> <li> <p>an interaction term given by the standard NN interaction and determined starting     from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c</p> </li> <li> <p>a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to     all the qubits. If the <code>addressable_detuning</code> flag is set to True, the routine     effectively a local n_i = (1+sigma_i^z)/2 term in the     evolved Hamiltonian with a different coefficient for each atom. These     coefficients determine a local addressing pattern for the detuning on a subset     of the qubits. In this routine, the coefficients are variational parameters     and they will therefore be optimized at each optimizer step</p> </li> <li> <p>a drive term which corresponding to a sigma^x evolution operation applied to     all the qubits. If the <code>addressable_drive</code> flag is set to True, the routine     effectively a local sigma_i^x term in the evolved Hamiltonian with a different     coefficient for each atom. These coefficients determine a local addressing pattern     for the drive on a subset of the qubits. In this routine, the coefficients are     variational parameters and they will therefore be optimized at each optimizer step</p> </li> <li> <p>if the <code>tunable_phase</code> flag is set to True, the drive term is modified in the following     way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y     The addressable pattern above is maintained and the phase is considered just as an     additional variational parameter which is optimized with the rest</p> </li> </ul> <p>Notice that, on real devices, the coefficients assigned to each qubit in both the detuning and drive patterns should be non-negative and they should always sum to 1. This is not the case for the implementation in this routine since the coefficients (weights) do not have any constraint. Therefore, this HEA is not completely realizable on neutral atom devices.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input atomic register with Cartesian coordinates.</p> <p> TYPE: <code>Register</code> </p> <code>n_layers</code> <p>number layers in the HEA, each layer includes a drive, detuning and pure interaction pulses whose is a variational parameter</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>addressable_detuning</code> <p>whether to turn on the trainable semi-local addressing pattern on the detuning (n_i terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>addressable_drive</code> <p>whether to turn on the trainable semi-local addressing pattern on the drive (sigma_i^x terms in the Hamiltonian)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>tunable_phase</code> <p>whether to have a tunable phase to get both sigma^x and sigma^y rotations in the drive term. If False, only a sigma^x term will be included in the drive part of the Hamiltonian generator</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_prefix</code> <p>an additional prefix to attach to the parameter names</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>The Rydberg HEA block</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea(\n    register: qd.Register,\n    n_layers: int = 1,\n    addressable_detuning: bool = True,\n    addressable_drive: bool = False,\n    tunable_phase: bool = False,\n    additional_prefix: str = None,\n) -&gt; qd.blocks.ChainBlock:\n    \"\"\"Hardware efficient ansatz for neutral atom (Rydberg) platforms.\n\n    This constructor implements a variational ansatz which is very close to\n    what is implementable on 2nd generation PASQAL quantum devices. In particular,\n    it implements evolution over a specific Hamiltonian which can be realized on\n    the device. This Hamiltonian contains:\n\n    * an interaction term given by the standard NN interaction and determined starting\n        from the positions in the input register: H\u1d62\u2099\u209c = \u2211\u1d62\u2c7c C\u2086/r\u1d62\u2c7c\u2076 n\u1d62n\u2c7c\n\n    * a detuning term which corresponding to a n_i = (1+sigma_i^z)/2 applied to\n        all the qubits. If the `addressable_detuning` flag is set to True, the routine\n        effectively a local n_i = (1+sigma_i^z)/2 term in the\n        evolved Hamiltonian with a different coefficient for each atom. These\n        coefficients determine a local addressing pattern for the detuning on a subset\n        of the qubits. In this routine, the coefficients are variational parameters\n        and they will therefore be optimized at each optimizer step\n\n    * a drive term which corresponding to a sigma^x evolution operation applied to\n        all the qubits. If the `addressable_drive` flag is set to True, the routine\n        effectively a local sigma_i^x term in the evolved Hamiltonian with a different\n        coefficient for each atom. These coefficients determine a local addressing pattern\n        for the drive on a subset of the qubits. In this routine, the coefficients are\n        variational parameters and they will therefore be optimized at each optimizer step\n\n    * if the `tunable_phase` flag is set to True, the drive term is modified in the following\n        way: drive = cos(phi) * sigma^x - sin(phi) * sigma^y\n        The addressable pattern above is maintained and the phase is considered just as an\n        additional variational parameter which is optimized with the rest\n\n    Notice that, on real devices, the coefficients assigned to each qubit in both the detuning\n    and drive patterns should be non-negative and they should always sum to 1. This is not the\n    case for the implementation in this routine since the coefficients (weights) do not have any\n    constraint. Therefore, this HEA is not completely realizable on neutral atom devices.\n\n    Args:\n        register: the input atomic register with Cartesian coordinates.\n        n_layers: number layers in the HEA, each layer includes a drive, detuning and\n            pure interaction pulses whose is a variational parameter\n        addressable_detuning: whether to turn on the trainable semi-local addressing pattern\n            on the detuning (n_i terms in the Hamiltonian)\n        addressable_drive: whether to turn on the trainable semi-local addressing pattern\n            on the drive (sigma_i^x terms in the Hamiltonian)\n        tunable_phase: whether to have a tunable phase to get both sigma^x and sigma^y rotations\n            in the drive term. If False, only a sigma^x term will be included in the drive part\n            of the Hamiltonian generator\n        additional_prefix: an additional prefix to attach to the parameter names\n\n    Returns:\n        The Rydberg HEA block\n    \"\"\"\n    n_qubits = register.n_qubits\n    prefix = \"\" if additional_prefix is None else \"_\" + additional_prefix\n\n    detunings = None\n    # add a detuning pattern locally addressing the atoms\n    if addressable_detuning:\n        detunings = [qd.VariationalParameter(f\"detmap_{j}\") for j in range(n_qubits)]\n\n    drives = None\n    # add a drive pattern locally addressing the atoms\n    if addressable_drive:\n        drives = [qd.VariationalParameter(f\"drivemap_{j}\") for j in range(n_qubits)]\n\n    phase = None\n    if tunable_phase:\n        phase = qd.VariationalParameter(\"phase\")\n\n    return chain(\n        rydberg_hea_layer(\n            register,\n            VariationalParameter(f\"At{prefix}_{layer}\"),\n            VariationalParameter(f\"Omega{prefix}_{layer}\"),\n            VariationalParameter(f\"wait{prefix}_{layer}\"),\n            detunings=detunings,\n            drives=drives,\n            phase=phase,\n        )\n        for layer in range(n_layers)\n    )\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.rydberg_hea.rydberg_hea_layer","title":"<code>rydberg_hea_layer(register, tevo_drive, tevo_det, tevo_wait, phase=None, detunings=None, drives=None, drive_scaling=1.0)</code>","text":"<p>A single layer of the Rydberg hardware efficient ansatz.</p> PARAMETER  DESCRIPTION <code>register</code> <p>the input register with atomic coordinates needed to build the interaction.</p> <p> TYPE: <code>Register</code> </p> <code>tevo_drive</code> <p>a variational parameter for the duration of the drive term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_det</code> <p>a variational parameter for the duration of the detuning term of the Hamiltonian generator, including optional semi-local addressing</p> <p> TYPE: <code>Parameter | float</code> </p> <code>tevo_wait</code> <p>a variational parameter for the duration of the waiting time with interaction only</p> <p> TYPE: <code>Parameter | float</code> </p> <code>phase</code> <p>a variational parameter representing the global phase. If None, the global phase is set to 0 which results in a drive term in sigma^x only. Otherwise both sigma^x and sigma^y terms will be present</p> <p> TYPE: <code>Parameter | float | None</code> DEFAULT: <code>None</code> </p> <code>detunings</code> <p>a list of parameters with the weights of the locally addressed detuning terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drives</code> <p>a list of parameters with the weights of the locally addressed drive terms. These are variational parameters which are tuned by the optimizer</p> <p> TYPE: <code>list[Parameter] | list[float] | None</code> DEFAULT: <code>None</code> </p> <code>drive_scaling</code> <p>a scaling term to be added to the drive Hamiltonian generator</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A block with a single layer of Rydberg HEA</p> Source code in <code>qadence/constructors/rydberg_hea.py</code> <pre><code>def rydberg_hea_layer(\n    register: qd.Register,\n    tevo_drive: Parameter | float,\n    tevo_det: Parameter | float,\n    tevo_wait: Parameter | float,\n    phase: Parameter | float | None = None,\n    detunings: list[Parameter] | list[float] | None = None,\n    drives: list[Parameter] | list[float] | None = None,\n    drive_scaling: float = 1.0,\n) -&gt; ChainBlock:\n    \"\"\"A single layer of the Rydberg hardware efficient ansatz.\n\n    Args:\n        register: the input register with atomic coordinates needed to build the interaction.\n        tevo_drive: a variational parameter for the duration of the drive term of\n            the Hamiltonian generator, including optional semi-local addressing\n        tevo_det: a variational parameter for the duration of the detuning term of the\n            Hamiltonian generator, including optional semi-local addressing\n        tevo_wait: a variational parameter for the duration of the waiting\n            time with interaction only\n        phase: a variational parameter representing the global phase. If None, the\n            global phase is set to 0 which results in a drive term in sigma^x only. Otherwise\n            both sigma^x and sigma^y terms will be present\n        detunings: a list of parameters with the weights of the locally addressed\n            detuning terms. These are variational parameters which are tuned by the optimizer\n        drives: a list of parameters with the weights of the locally addressed\n            drive terms. These are variational parameters which are tuned by the optimizer\n        drive_scaling: a scaling term to be added to the drive Hamiltonian generator\n\n    Returns:\n        A block with a single layer of Rydberg HEA\n    \"\"\"\n    n_qubits = register.n_qubits\n\n    drive_x = _amplitude_map(n_qubits, qd.X, weights=drives)\n    drive_y = _amplitude_map(n_qubits, qd.Y, weights=drives)\n    detuning = _amplitude_map(n_qubits, qd.N, weights=detunings)\n    interaction = hamiltonian_factory(register, qd.Interaction.NN)\n\n    # drive and interaction are not commuting thus they need to be\n    # added directly into the final Hamiltonian generator\n    if phase is not None:\n        generator = (\n            drive_scaling * sympy.cos(phase) * drive_x\n            - drive_scaling * sympy.sin(phase) * drive_y\n            + interaction\n        )\n    else:\n        generator = drive_scaling * drive_x + interaction\n\n    return chain(\n        qd.HamEvo(generator, tevo_drive),\n        # detuning and interaction are commuting, so they\n        # can be ordered arbitrarily and treated separately\n        qd.HamEvo(interaction, tevo_wait),\n        qd.HamEvo(detuning, tevo_det),\n    )\n</code></pre>"},{"location":"qadence/constructors/#the-daqc-transform","title":"The DAQC Transform","text":""},{"location":"qadence/constructors/#qadence.constructors.daqc.daqc.daqc_transform","title":"<code>daqc_transform(n_qubits, gen_target, t_f, gen_build=None, zero_tol=1e-08, strategy=Strategy.SDAQC, ignore_global_phases=False)</code>","text":"<p>Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.</p> <p>The result is another fixed 2-body Hamiltonian.</p> <p>Reference for universality of 2-body Hamiltonians:</p> <p>-- https://arxiv.org/abs/quant-ph/0106064</p> <p>Based on the transformation for Ising (ZZ) interactions, as described in the paper</p> <p>-- https://arxiv.org/abs/1812.03637</p> <p>The transform translates a target weighted generator of the type:</p> <pre><code>`gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>To a circuit using analog evolutions with a fixed building block generator:</p> <pre><code>`gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n</code></pre> <p>where <code>op = Z</code> or <code>op = N</code>.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>total number of qubits to use.</p> <p> TYPE: <code>int</code> </p> <code>gen_target</code> <p>target generator built with the structure above. The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>t_f</code> <p>total time for the gen_target evolution.</p> <p> TYPE: <code>float</code> </p> <code>gen_build</code> <p>fixed generator to act as a building block. Defaults to constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type of the generator will be automatically evaluated when parsing.</p> <p> TYPE: <code>AbstractBlock | None</code> DEFAULT: <code>None</code> </p> <code>zero_tol</code> <p>default \"zero\" for a missing interaction. Included for numerical reasons, see notes below.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-08</code> </p> <code>strategy</code> <p>sDAQC or bDAQC, following definitions in the reference paper.</p> <p> TYPE: <code>Strategy</code> DEFAULT: <code>SDAQC</code> </p> <code>ignore_global_phases</code> <p>if <code>True</code> the transform does not correct the global phases coming from the mapping between ZZ and NN interactions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Notes:</p> <pre><code>The paper follows an index convention of running from 1 to N. A few functions\nhere also use that convention to be consistent with the paper. However, for qadence\nrelated things the indices are converted to [0, N-1].\n\nThe case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\nThere is a workaround for this described in the paper, but it is currently not implemented.\n\nThe current implementation may result in evolution times that are both positive or\nnegative. In practice, both can be represented by simply changing the signs of the\ninteractions. However, for a real implementation where the interactions should remain\nfixed, the paper discusses a workaround that is not currently implemented.\n\nThe transformation works by representing each interaction in the target hamiltonian by\na set of evolutions using the build hamiltonian. As a consequence, some care must be\ntaken when choosing the build hamiltonian. Some cases:\n\n- The target hamiltonian can have any interaction, as long as it is sufficiently\nrepresented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\nis in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\nneeds to be in the build hamiltonian. This is checked when the generators are parsed.\n\n- The build hamiltonian can have any interaction, irrespectively of it being needed\nfor the target hamiltonian. This is especially useful for designing local operations\nthrough the repeated evolution of a \"global\" hamiltonian.\n\n- The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\nAny interaction strength smaller than `zero_tol` in the build hamiltonian will not be\nconsidered, and thus that interaction is missing.\n\n- The various ratios `g_jk / f_jk` will influence the time parameter for the various\nevolution slices, meaning that if there is a big discrepancy in the interaction strength\nfor a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\nevolutions with very large times.\n\n- A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\ntimes smaller than `zero_tol` will not be represented.\n</code></pre> <p>Examples:</p> <pre><code>from qadence import Z, N, daqc_transform\n\nn_qubits = 3\n\ngen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\ngen_target = 0.1 * (Z(1)@Z(2))\n\nt_f = 2.0\n\ntransformed_circuit = daqc_transform(\n    n_qubits = n_qubits,\n    gen_target = gen_target,\n    t_f = t_f,\n    gen_build = gen_build,\n)\n</code></pre> <pre><code>\n</code></pre> Source code in <code>qadence/constructors/daqc/daqc.py</code> <pre><code>def daqc_transform(\n    n_qubits: int,\n    gen_target: AbstractBlock,\n    t_f: float,\n    gen_build: AbstractBlock | None = None,\n    zero_tol: float = 1e-08,\n    strategy: Strategy = Strategy.SDAQC,\n    ignore_global_phases: bool = False,\n) -&gt; AbstractBlock:\n    \"\"\"\n    Implements the DAQC transform for representing an arbitrary 2-body Hamiltonian.\n\n    The result is another fixed 2-body Hamiltonian.\n\n    Reference for universality of 2-body Hamiltonians:\n\n    -- https://arxiv.org/abs/quant-ph/0106064\n\n    Based on the transformation for Ising (ZZ) interactions, as described in the paper\n\n    -- https://arxiv.org/abs/1812.03637\n\n    The transform translates a target weighted generator of the type:\n\n        `gen_target = add(g_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    To a circuit using analog evolutions with a fixed building block generator:\n\n        `gen_build = add(f_jk * kron(op(j), op(k)) for j &lt; k)`\n\n    where `op = Z` or `op = N`.\n\n    Args:\n        n_qubits: total number of qubits to use.\n        gen_target: target generator built with the structure above. The type\n            of the generator will be automatically evaluated when parsing.\n        t_f (float): total time for the gen_target evolution.\n        gen_build: fixed generator to act as a building block. Defaults to\n            constant NN: add(1.0 * kron(N(j), N(k)) for j &lt; k). The type\n            of the generator will be automatically evaluated when parsing.\n        zero_tol: default \"zero\" for a missing interaction. Included for\n            numerical reasons, see notes below.\n        strategy: sDAQC or bDAQC, following definitions in the reference paper.\n        ignore_global_phases: if `True` the transform does not correct the global\n            phases coming from the mapping between ZZ and NN interactions.\n\n    Notes:\n\n        The paper follows an index convention of running from 1 to N. A few functions\n        here also use that convention to be consistent with the paper. However, for qadence\n        related things the indices are converted to [0, N-1].\n\n        The case for `n_qubits = 4` is an edge case where the sign matrix is not invertible.\n        There is a workaround for this described in the paper, but it is currently not implemented.\n\n        The current implementation may result in evolution times that are both positive or\n        negative. In practice, both can be represented by simply changing the signs of the\n        interactions. However, for a real implementation where the interactions should remain\n        fixed, the paper discusses a workaround that is not currently implemented.\n\n        The transformation works by representing each interaction in the target hamiltonian by\n        a set of evolutions using the build hamiltonian. As a consequence, some care must be\n        taken when choosing the build hamiltonian. Some cases:\n\n        - The target hamiltonian can have any interaction, as long as it is sufficiently\n        represented in the build hamiltonian. E.g., if the interaction `g_01 * kron(Z(0), Z(1))`\n        is in the target hamiltonian, the corresponding interaction `f_01 * kron(Z(0), Z(1))`\n        needs to be in the build hamiltonian. This is checked when the generators are parsed.\n\n        - The build hamiltonian can have any interaction, irrespectively of it being needed\n        for the target hamiltonian. This is especially useful for designing local operations\n        through the repeated evolution of a \"global\" hamiltonian.\n\n        - The parameter `zero_tol` controls what it means for an interaction to be \"missing\".\n        Any interaction strength smaller than `zero_tol` in the build hamiltonian will not be\n        considered, and thus that interaction is missing.\n\n        - The various ratios `g_jk / f_jk` will influence the time parameter for the various\n        evolution slices, meaning that if there is a big discrepancy in the interaction strength\n        for a given qubit pair (j, k), the output circuit may require the usage of hamiltonian\n        evolutions with very large times.\n\n        - A warning will be issued for evolution times larger than `1/sqrt(zero_tol)`. Evolution\n        times smaller than `zero_tol` will not be represented.\n\n    Examples:\n        ```python exec=\"on\" source=\"material-block\" result=\"json\"\n        from qadence import Z, N, daqc_transform\n\n        n_qubits = 3\n\n        gen_build = 0.5 * (N(0)@N(1)) + 0.7 * (N(1)@N(2)) + 0.2 * (N(0)@N(2))\n\n        gen_target = 0.1 * (Z(1)@Z(2))\n\n        t_f = 2.0\n\n        transformed_circuit = daqc_transform(\n            n_qubits = n_qubits,\n            gen_target = gen_target,\n            t_f = t_f,\n            gen_build = gen_build,\n        )\n        ```\n    \"\"\"\n\n    ##################\n    # Input controls #\n    ##################\n\n    if strategy != Strategy.SDAQC:\n        raise NotImplementedError(\"Currently only the sDAQC transform is implemented.\")\n\n    if n_qubits == 4:\n        raise NotImplementedError(\"DAQC transform 4-qubit edge case not implemented.\")\n\n    if gen_build is None:\n        gen_build = hamiltonian_factory(n_qubits, interaction=Interaction.NN)\n\n    try:\n        if (not block_is_qubit_hamiltonian(gen_target)) or (\n            not block_is_qubit_hamiltonian(gen_build)\n        ):\n            raise ValueError(\n                \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n            )\n    except NotImplementedError:\n        # Happens when block_is_qubit_hamiltonian is called on something that is not a block.\n        raise TypeError(\n            \"Generator block is not a qubit Hamiltonian. Only ZZ or NN interactions allowed.\"\n        )\n\n    #####################\n    # Generator parsing #\n    #####################\n\n    g_jk_target, mat_jk_target, target_type = _parse_generator(n_qubits, gen_target, 0.0)\n    g_jk_build, mat_jk_build, build_type = _parse_generator(n_qubits, gen_build, zero_tol)\n\n    # Get the global phase hamiltonian and single-qubit detuning hamiltonian\n    if build_type == GenDAQC.NN:\n        h_phase_build, h_sq_build = _nn_phase_and_detunings(n_qubits, mat_jk_build)\n\n    if target_type == GenDAQC.NN:\n        h_phase_target, h_sq_target = _nn_phase_and_detunings(n_qubits, mat_jk_target)\n\n    # Time re-scalings\n    if build_type == GenDAQC.ZZ and target_type == GenDAQC.NN:\n        t_star = t_f / 4.0\n    elif build_type == GenDAQC.NN and target_type == GenDAQC.ZZ:\n        t_star = 4.0 * t_f\n    else:\n        t_star = t_f\n\n    # Check if target Hamiltonian can be mapped with the build Hamiltonian\n    assert _check_compatibility(g_jk_target, g_jk_build, zero_tol)\n\n    ##################\n    # DAQC Transform #\n    ##################\n\n    # Section III A of https://arxiv.org/abs/1812.03637:\n\n    # Matrix M for the linear system, exemplified in Table I:\n    matrix_M = _build_matrix_M(n_qubits)\n\n    # Linear system mapping interaction ratios -&gt; evolution times.\n    t_slices = torch.linalg.solve(matrix_M, g_jk_target / g_jk_build) * t_star\n\n    # ZZ-DAQC with ZZ or NN build Hamiltonian\n    daqc_slices = []\n    for m in range(2, n_qubits + 1):\n        for n in range(1, m):\n            alpha = _ix_map(n_qubits, n, m)\n            t = t_slices[alpha - 1]\n            if abs(t) &gt; zero_tol:\n                if abs(t) &gt; (1 / (zero_tol**0.5)):\n                    logger.warning(\n                        \"\"\"\nTransformed circuit with very long evolution time.\nMake sure your target interactions are sufficiently\nrepresented in the build Hamiltonian.\"\"\"\n                    )\n                x_gates = kron(X(n - 1), X(m - 1))\n                analog_evo = HamEvo(gen_build, t)\n                # TODO: Fix repeated X-gates\n                if build_type == GenDAQC.NN:\n                    # Local detuning at each DAQC layer for NN build Hamiltonian\n                    sq_detuning_build = HamEvo(h_sq_build, t)\n                    daqc_slices.append(chain(x_gates, sq_detuning_build, analog_evo, x_gates))\n                elif build_type == GenDAQC.ZZ:\n                    daqc_slices.append(chain(x_gates, analog_evo, x_gates))\n\n    daqc_circuit = chain(*daqc_slices)\n\n    ########################\n    # Phases and Detunings #\n    ########################\n\n    if target_type == GenDAQC.NN:\n        # Local detuning given a NN target Hamiltonian\n        sq_detuning_target = HamEvo(h_sq_target, t_f).dagger()\n        daqc_circuit = chain(sq_detuning_target, daqc_circuit)\n\n    if not ignore_global_phases:\n        if build_type == GenDAQC.NN:\n            # Constant global phase given a NN build Hamiltonian\n            global_phase_build = HamEvo(h_phase_build, t_slices.sum())\n            daqc_circuit = chain(global_phase_build, daqc_circuit)\n\n        if target_type == GenDAQC.NN:\n            # Constant global phase and given a NN target Hamiltonian\n            global_phase_target = HamEvo(h_phase_target, t_f).dagger()\n            daqc_circuit = chain(global_phase_target, daqc_circuit)\n\n    return daqc_circuit\n</code></pre>"},{"location":"qadence/constructors/#some-utility-functions","title":"Some utility functions","text":""},{"location":"qadence/constructors/#qadence.constructors.utils.build_idx_fms","title":"<code>build_idx_fms(basis, fm_pauli, fm_strategy, n_features, n_qubits, spectrum)</code>","text":"<p>Builds the index feature maps based on the given parameters.</p> PARAMETER  DESCRIPTION <code>basis</code> <p>Type of basis chosen for the feature map.</p> <p> TYPE: <code>str</code> </p> <code>fm_pauli</code> <p>The chosen Pauli rotation type.</p> <p> TYPE: <code>PrimitiveBlock type</code> </p> <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>spectrum</code> <p>The chosen spectrum.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[KronBlock]</code> <p>List[KronBlock]: The list of index feature maps.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def build_idx_fms(\n    basis: str,\n    fm_pauli: Type[RY],\n    fm_strategy: str,\n    n_features: int,\n    n_qubits: int,\n    spectrum: str,\n) -&gt; list[KronBlock]:\n    \"\"\"Builds the index feature maps based on the given parameters.\n\n    Args:\n        basis (str): Type of basis chosen for the feature map.\n        fm_pauli (PrimitiveBlock type): The chosen Pauli rotation type.\n        fm_strategy (str): The feature map strategy to be used. Possible values are\n            'parallel' or 'serial'.\n        n_features (int): The number of features.\n        n_qubits (int): The number of qubits.\n        spectrum (str): The chosen spectrum.\n\n    Returns:\n        List[KronBlock]: The list of index feature maps.\n    \"\"\"\n    idx_fms = []\n    for i in range(n_features):\n        target_qubits = get_fm_qubits(fm_strategy, i, n_qubits, n_features)\n        param = FeatureParameter(f\"x{i}\")\n        block = kron(\n            *[\n                fm_pauli(qubit, generator_prefactor(spectrum, j) * basis_func(basis, param))\n                for j, qubit in enumerate(target_qubits)\n            ]\n        )\n        idx_fm = block\n        idx_fms.append(idx_fm)\n    return idx_fms\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.generator_prefactor","title":"<code>generator_prefactor(spectrum, qubit_index)</code>","text":"<p>Converts a spectrum string, e.g. tower or exponential.</p> <p>The result is the correct generator prefactor.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def generator_prefactor(spectrum: str, qubit_index: int) -&gt; float | int:\n    \"\"\"Converts a spectrum string, e.g. tower or exponential.\n\n    The result is the correct generator prefactor.\n    \"\"\"\n    spectrum = spectrum.lower()\n    conversion_dict: dict[str, float | int] = {\n        \"simple\": 1,\n        \"tower\": qubit_index + 1,\n        \"exponential\": 2 * PI / (2 ** (qubit_index + 1)),\n    }\n    return conversion_dict[spectrum]\n</code></pre>"},{"location":"qadence/constructors/#qadence.constructors.utils.get_fm_qubits","title":"<code>get_fm_qubits(fm_strategy, i, n_qubits, n_features)</code>","text":"<p>Returns the list of target qubits for the given feature map strategy and feature index.</p> PARAMETER  DESCRIPTION <code>fm_strategy</code> <p>The feature map strategy to be used. Possible values are 'parallel' or 'serial'.</p> <p> TYPE: <code>str</code> </p> <code>i</code> <p>The feature index.</p> <p> TYPE: <code>int</code> </p> <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>n_features</code> <p>The number of features.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Iterable</code> <p>List[int]: The list of target qubits.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the feature map strategy is not implemented.</p> Source code in <code>qadence/constructors/utils.py</code> <pre><code>def get_fm_qubits(fm_strategy: str, i: int, n_qubits: int, n_features: int) -&gt; Iterable:\n    \"\"\"Returns the list of target qubits for the given feature map strategy and feature index.\n\n    Args:\n        fm_strategy (str): The feature map strategy to be used. Possible values\n            are 'parallel' or 'serial'.\n        i (int): The feature index.\n        n_qubits (int): The number of qubits.\n        n_features (int): The number of features.\n\n    Returns:\n        List[int]: The list of target qubits.\n\n    Raises:\n        ValueError: If the feature map strategy is not implemented.\n    \"\"\"\n    if fm_strategy == \"parallel\":\n        n_qubits_per_feature = int(n_qubits / n_features)\n        target_qubits = range(i * n_qubits_per_feature, (i + 1) * n_qubits_per_feature)\n    elif fm_strategy == \"serial\":\n        target_qubits = range(0, n_qubits)\n    else:\n        raise ValueError(f\"Feature map strategy {fm_strategy} not implemented.\")\n    return target_qubits\n</code></pre>"},{"location":"qadence/draw/","title":"Drawing","text":""},{"location":"qadence/draw/#drawing","title":"Drawing","text":""},{"location":"qadence/draw/#qadence.draw.display","title":"<code>display(x, qcd=None, layout='LR', theme='light', fill=True, **kwargs)</code>","text":"<p>Display a block, circuit, or quantum model.</p> <p>The <code>kwargs</code> are forwarded to the underlying <code>nx.Graph</code>, so you can e.g. specify the size of the resulting plot via <code>size=\"2,2\"</code> (see examples)</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>qcd</code> <p>Circuit diagram to plot the block into.</p> <p> TYPE: <code>QuantumCircuitDiagram | Cluster | None</code> DEFAULT: <code>None</code> </p> <code>layout</code> <p>Can be either \"LR\" (left-right), or \"TB\" (top-bottom).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'LR'</code> </p> <code>theme</code> <p>Available themes are: [\"light\", \"dark\", \"black\", \"white\"].</p> <p> TYPE: <code>str</code> DEFAULT: <code>'light'</code> </p> <code>fill</code> <p>Whether to fill the passed <code>x</code> with identities.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>kwargs</code> <p>Passed on to <code>nx.Graph</code></p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\ndisplay(b, size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def display(\n    x: Any,\n    qcd: QuantumCircuitDiagram | Cluster | None = None,\n    layout: str = \"LR\",\n    theme: str = \"light\",\n    fill: bool = True,\n    **kwargs: Any,\n) -&gt; Graph:\n    \"\"\"Display a block, circuit, or quantum model.\n\n    The `kwargs` are forwarded to\n    the underlying `nx.Graph`, so you can e.g. specify the size of the resulting plot via\n    `size=\"2,2\"` (see examples)\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        qcd: Circuit diagram to plot the block into.\n        layout: Can be either \"LR\" (left-right), or \"TB\" (top-bottom).\n        theme: Available themes are: [\"light\", \"dark\", \"black\", \"white\"].\n        fill: Whether to fill the passed `x` with identities.\n        kwargs: Passed on to `nx.Graph`\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def display(*args, **kwargs): return args # markdown-exec: hide\n    display(b, size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    return make_diagram(x, **kwargs).show()\n</code></pre>"},{"location":"qadence/draw/#qadence.draw.savefig","title":"<code>savefig(x, filename, *args, **kwargs)</code>","text":"<p>Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as <code>display</code>.</p> PARAMETER  DESCRIPTION <code>x</code> <p><code>AbstractBlock</code>, <code>QuantumCircuit</code>, or <code>QuantumModel</code>.</p> <p> TYPE: <code>Any</code> </p> <code>filename</code> <p>Should end in svg/png.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Same as in <code>display</code>.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> <p>Examples: <pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nb = kron(X(0), Y(1))\nsavefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n</code></pre> </p> Source code in <code>qadence/draw/__init__.py</code> <pre><code>def savefig(x: Any, filename: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Save a block, circuit, or quantum model to file. Accepts the same args/kwargs as `display`.\n\n    Arguments:\n        x: `AbstractBlock`, `QuantumCircuit`, or `QuantumModel`.\n        filename: Should end in svg/png.\n        args: Same as in `display`.\n        kwargs: Same as in `display`.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" html=\"1\"\n    from qadence import X, Y, kron\n    from qadence.draw import display\n\n    b = kron(X(0), Y(1))\n    def savefig(*args, **kwargs): return args # markdown-exec: hide\n    savefig(b, \"test.svg\", size=\"1,1\", theme=\"dark\")\n    ```\n    \"\"\"\n    make_diagram(x, *args, **kwargs).savefig(filename)\n</code></pre>"},{"location":"qadence/execution/","title":"Execution","text":""},{"location":"qadence/execution/#qadence.execution.expectation","title":"<code>expectation(x, observable, values={}, state=None, backend=BackendName.PYQTORCH, diff_mode=None, noise=None, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.expectation</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>observable</code> <p>Observable(s) w.r.t. which the expectation is computed.</p> <p> TYPE: <code>Union[list[AbstractBlock], AbstractBlock]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>diff_mode</code> <p>Which differentiation mode to use.</p> <p> TYPE: <code>Union[DiffMode, str, None]</code> DEFAULT: <code>None</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> <pre><code>from qadence import RX, Z, Register, QuantumCircuit, expectation\n\nreg = Register(1)\nblock = RX(0, 0.5)\nobservable = Z(0)\ncirc = QuantumCircuit(reg, block)\n\n# You can compute the expectation for a\n# QuantumCircuit with a given observable.\nexpectation(circ, observable)\n\n# You can also use only a block.\n# In this case the register is constructed automatically to\n# Register.line(block.n_qubits)\nexpectation(block, observable)\n\n# Or a register and block\nexpectation(reg, block, observable)\n</code></pre> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef expectation(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    observable: Union[list[AbstractBlock], AbstractBlock],\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    diff_mode: Union[DiffMode, str, None] = None,\n    noise: Union[Noise, None] = None,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.expectation` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        observable: Observable(s) w.r.t. which the expectation is computed.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        diff_mode: Which differentiation mode to use.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n\n    ```python exec=\"on\" source=\"material-block\"\n    from qadence import RX, Z, Register, QuantumCircuit, expectation\n\n    reg = Register(1)\n    block = RX(0, 0.5)\n    observable = Z(0)\n    circ = QuantumCircuit(reg, block)\n\n    # You can compute the expectation for a\n    # QuantumCircuit with a given observable.\n    expectation(circ, observable)\n\n    # You can also use only a block.\n    # In this case the register is constructed automatically to\n    # Register.line(block.n_qubits)\n    expectation(block, observable)\n\n    # Or a register and block\n    expectation(reg, block, observable)\n    ```\n    \"\"\"\n\n    raise ValueError(f\"Cannot execute {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.run","title":"<code>run(x, *args, values={}, state=None, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.run</code> method.</p> <p>This is a <code>functools.singledispatch</code>ed function so it can be called with a number of different arguments. See the examples of the <code>expectation</code> function. This function works exactly the same.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>None</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A wavefunction</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef run(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Tensor = None,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; Tensor:\n    \"\"\"Convenience wrapper for the `QuantumModel.run` method.\n\n     This is a\n    `functools.singledispatch`ed function so it can be called with a number of different arguments.\n    See the examples of the [`expectation`][qadence.execution.expectation] function. This function\n    works exactly the same.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        configuration: The backend configuration.\n\n    Returns:\n        A wavefunction\n    \"\"\"\n    raise ValueError(f\"Cannot run {type(x)}\")\n</code></pre>"},{"location":"qadence/execution/#qadence.execution.sample","title":"<code>sample(x, *args, values={}, state=None, n_shots=100, backend=BackendName.PYQTORCH, endianness=Endianness.BIG, noise=None, configuration=None)</code>","text":"<p>Convenience wrapper for the <code>QuantumModel.sample</code> method.</p> PARAMETER  DESCRIPTION <code>x</code> <p>Circuit, block, or (register+block) to run.</p> <p> TYPE: <code>Union[QuantumCircuit, AbstractBlock, Register, int]</code> </p> <code>values</code> <p>User-facing parameter dict.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>{}</code> </p> <code>state</code> <p>Initial state.</p> <p> TYPE: <code>Union[Tensor, None]</code> DEFAULT: <code>None</code> </p> <code>n_shots</code> <p>Number of shots per element in the batch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>backend</code> <p>Name of the backend to run on.</p> <p> TYPE: <code>BackendName</code> DEFAULT: <code>PYQTORCH</code> </p> <code>endianness</code> <p>The target device endianness.</p> <p> TYPE: <code>Endianness</code> DEFAULT: <code>BIG</code> </p> <code>noise</code> <p>The noise model to use if any.</p> <p> TYPE: <code>Union[Noise, None]</code> DEFAULT: <code>None</code> </p> <code>configuration</code> <p>The backend configuration.</p> <p> TYPE: <code>Union[BackendConfiguration, dict, None]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Counter]</code> <p>A list of Counter instances with the sample results</p> Source code in <code>qadence/execution.py</code> <pre><code>@singledispatch\ndef sample(\n    x: Union[QuantumCircuit, AbstractBlock, Register, int],\n    *args: Any,\n    values: dict = {},\n    state: Union[Tensor, None] = None,\n    n_shots: int = 100,\n    backend: BackendName = BackendName.PYQTORCH,\n    endianness: Endianness = Endianness.BIG,\n    noise: Union[Noise, None] = None,\n    configuration: Union[BackendConfiguration, dict, None] = None,\n) -&gt; list[Counter]:\n    \"\"\"Convenience wrapper for the `QuantumModel.sample` method.\n\n    Arguments:\n        x: Circuit, block, or (register+block) to run.\n        values: User-facing parameter dict.\n        state: Initial state.\n        n_shots: Number of shots per element in the batch.\n        backend: Name of the backend to run on.\n        endianness: The target device endianness.\n        noise: The noise model to use if any.\n        configuration: The backend configuration.\n\n    Returns:\n        A list of Counter instances with the sample results\n    \"\"\"\n    raise ValueError(f\"Cannot sample from {type(x)}\")\n</code></pre>"},{"location":"qadence/ml_tools/","title":"QML tools","text":""},{"location":"qadence/ml_tools/#ml-tools","title":"ML Tools","text":"<p>This module implements gradient-free and gradient-based training loops for torch Modules and QuantumModel.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig","title":"<code>TrainConfig</code>  <code>dataclass</code>","text":"<p>Default config for the train function.</p> <p>The default value of each field can be customized with the constructor:</p> <pre><code>from qadence.ml_tools import TrainConfig\nc = TrainConfig(folder=\"/tmp/train\")\n</code></pre> <pre><code>TrainConfig(max_iter=10000, print_every=1000, write_every=50, checkpoint_every=5000, folder=PosixPath('/tmp/train'), create_subfolder_per_run=False, checkpoint_best_only=False, validation_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7ff68d5d72e0&gt;, trainstop_criterion=&lt;function TrainConfig.__post_init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7ff68d5d43a0&gt;, batch_size=1, verbose=True)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.batch_size","title":"<code>batch_size: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The batch_size to use when passing a list/tuple of torch.Tensors.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_best_only","title":"<code>checkpoint_best_only: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint only if a metric has improved.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.checkpoint_every","title":"<code>checkpoint_every: int = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write model/optimizer checkpoint.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.create_subfolder_per_run","title":"<code>create_subfolder_per_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs stored in subfolder with name <code>&lt;timestamp&gt;_&lt;PID&gt;</code>.</p> <p>Prevents continuing from previous checkpoint, useful for fast prototyping.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.folder","title":"<code>folder: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Checkpoint/tensorboard logs folder.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.max_iter","title":"<code>max_iter: int = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of training iterations.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.print_every","title":"<code>print_every: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Print loss/metrics.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.trainstop_criterion","title":"<code>trainstop_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given training stopping metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.validation_criterion","title":"<code>validation_criterion: Optional[Callable] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A boolean function which evaluates a given validation metric is satisfied.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.verbose","title":"<code>verbose: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether or not to print out metrics values during training.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.config.TrainConfig.write_every","title":"<code>write_every: int = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Write tensorboard logs.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.get_parameters","title":"<code>get_parameters(model)</code>","text":"<p>Retrieve all trainable model parameters in a single vector.</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>a 1-dimensional tensor with the parameters</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def get_parameters(model: Module) -&gt; Tensor:\n    \"\"\"Retrieve all trainable model parameters in a single vector.\n\n    Args:\n        model (Module): the input PyTorch model\n\n    Returns:\n        Tensor: a 1-dimensional tensor with the parameters\n    \"\"\"\n    ps = [p.reshape(-1) for p in model.parameters() if p.requires_grad]\n    return torch.concat(ps)\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.num_parameters","title":"<code>num_parameters(model)</code>","text":"<p>Return the total number of parameters of the given model.</p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def num_parameters(model: Module) -&gt; int:\n    \"\"\"Return the total number of parameters of the given model.\"\"\"\n    return len(get_parameters(model))\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.parameters.set_parameters","title":"<code>set_parameters(model, theta)</code>","text":"<p>Set all trainable parameters of a model from a single vector.</p> <p>Notice that this function assumes prior knowledge of right number of parameters in the model</p> PARAMETER  DESCRIPTION <code>model</code> <p>the input PyTorch model</p> <p> TYPE: <code>Module</code> </p> <code>theta</code> <p>the parameters to assign</p> <p> TYPE: <code>Tensor</code> </p> Source code in <code>qadence/ml_tools/parameters.py</code> <pre><code>def set_parameters(model: Module, theta: Tensor) -&gt; None:\n    \"\"\"Set all trainable parameters of a model from a single vector.\n\n    Notice that this function assumes prior knowledge of right number\n    of parameters in the model\n\n    Args:\n        model (Module): the input PyTorch model\n        theta (Tensor): the parameters to assign\n    \"\"\"\n\n    with torch.no_grad():\n        idx = 0\n        for ps in model.parameters():\n            if ps.requires_grad:\n                n = torch.numel(ps)\n                if ps.ndim == 0:\n                    ps[()] = theta[idx : idx + n]\n                else:\n                    ps[:] = theta[idx : idx + n].reshape(ps.size())\n                idx += n\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.optimize_step.optimize_step","title":"<code>optimize_step(model, optimizer, loss_fn, xs, device=None)</code>","text":"<p>Default Torch optimize step with closure.</p> <p>This is the default optimization step which should work for most of the standard use cases of optimization of Torch models</p> PARAMETER  DESCRIPTION <code>model</code> <p>The input model</p> <p> TYPE: <code>Module</code> </p> <code>optimizer</code> <p>The chosen Torch optimizer</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>A custom loss function</p> <p> TYPE: <code>Callable</code> </p> <code>xs</code> <p>the input data. If None it means that the given model does not require any input data</p> <p> TYPE: <code>dict | list | Tensor | None</code> </p> <code>device</code> <p>A target device to run computation on.</p> <p> TYPE: <code>device</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>tuple containing the model, the optimizer, a dictionary with the collected metrics and the compute value loss</p> <p> TYPE: <code>tuple[Tensor | float, dict | None]</code> </p> Source code in <code>qadence/ml_tools/optimize_step.py</code> <pre><code>def optimize_step(\n    model: Module,\n    optimizer: Optimizer,\n    loss_fn: Callable,\n    xs: dict | list | torch.Tensor | None,\n    device: torch.device = None,\n) -&gt; tuple[torch.Tensor | float, dict | None]:\n    \"\"\"Default Torch optimize step with closure.\n\n    This is the default optimization step which should work for most\n    of the standard use cases of optimization of Torch models\n\n    Args:\n        model (Module): The input model\n        optimizer (Optimizer): The chosen Torch optimizer\n        loss_fn (Callable): A custom loss function\n        xs (dict | list | torch.Tensor | None): the input data. If None it means\n            that the given model does not require any input data\n        device (torch.device): A target device to run computation on.\n\n    Returns:\n        tuple: tuple containing the model, the optimizer, a dictionary with\n            the collected metrics and the compute value loss\n    \"\"\"\n\n    loss, metrics = None, {}\n    xs_to_device = data_to_device(xs, device)\n\n    def closure() -&gt; Any:\n        # NOTE: We need the nonlocal as we can't return a metric dict and\n        # because e.g. LBFGS calls this closure multiple times but for some\n        # reason the returned loss is always the first one...\n        nonlocal metrics, loss\n        optimizer.zero_grad()\n        loss, metrics = loss_fn(model, xs_to_device)\n        loss.backward(retain_graph=True)\n        return loss.item()\n\n    optimizer.step(closure)\n    # return the loss/metrics that are being mutated inside the closure...\n    return loss, metrics\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn, device=None, optimize_step=optimize_step, write_tensorboard=write_tensorboard)</code>","text":"<p>Runs the training loop with gradient-based optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train.</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>dataloader of different types. If None, no data is required by the model</p> <p> TYPE: <code>Union[None, DataLoader, DictDataLoader]</code> </p> <code>optimizer</code> <p>The optimizer to use.</p> <p> TYPE: <code>Optimizer</code> </p> <code>config</code> <p><code>TrainConfig</code> with additional training options.</p> <p> TYPE: <code>TrainConfig</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> <code>device</code> <p>String defining device to train on, pass 'cuda' for GPU.</p> <p> TYPE: <code>device</code> DEFAULT: <code>None</code> </p> <code>optimize_step</code> <p>Customizable optimization callback which is called at every iteration.= The function must have the signature <code>optimize_step(model, optimizer, loss_fn, xs, device=\"cpu\")</code> (see the example below). Apart from the default we already supply three other optimization functions <code>optimize_step_evo</code>, <code>optimize_step_grad_norm</code>, and <code>optimize_step_inv_dirichlet</code>. Learn more about how to use this in the Advancded features tutorial of the documentation.</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>optimize_step</code> </p> <code>write_tensorboard</code> <p>Customizable tensorboard logging callback which is called every <code>config.write_every</code> iterations. The function must have the signature <code>write_tensorboard(writer, loss, metrics, iteration)</code> (see the example below).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>write_tensorboard</code> </p> <p>Example: <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning = Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\n## lets prepare the train routine\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\nn_epochs = 5\nbatch_size = 25\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n)\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n</code></pre> </p> Source code in <code>qadence/ml_tools/train_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: Union[None, DataLoader, DictDataLoader],\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: torch_device = None,\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n    \"\"\"Runs the training loop with gradient-based optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss,\n    metrics: dict), where `metrics` is a dict of scalars. Loss and metrics are\n    written to tensorboard. Checkpoints are written every\n    `config.checkpoint_every` steps (and after the last training step).  If a\n    checkpoint is found at `config.folder` we resume training from there.  The\n    tensorboard logs can be viewed via `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train.\n        dataloader: dataloader of different types. If None, no data is required by\n            the model\n        optimizer: The optimizer to use.\n        config: `TrainConfig` with additional training options.\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n        device: String defining device to train on, pass 'cuda' for GPU.\n        optimize_step: Customizable optimization callback which is called at every iteration.=\n            The function must have the signature `optimize_step(model,\n            optimizer, loss_fn, xs, device=\"cpu\")` (see the example below).\n            Apart from the default we already supply three other optimization\n            functions `optimize_step_evo`, `optimize_step_grad_norm`, and\n            `optimize_step_inv_dirichlet`. Learn more about how to use this in\n            the [Advancded features](../../tutorials/advanced) tutorial of the\n            documentation.\n        write_tensorboard: Customizable tensorboard logging callback which is\n            called every `config.write_every` iterations. The function must have\n            the signature `write_tensorboard(writer, loss, metrics, iteration)`\n            (see the example below).\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\"\n    from pathlib import Path\n    import torch\n    from itertools import count\n    from qadence import Parameter, QuantumCircuit, Z\n    from qadence import hamiltonian_factory, hea, feature_map, chain\n    from qadence.models import QNN\n    from qadence.ml_tools import TrainConfig, train_with_grad, to_dataloader\n\n    n_qubits = 2\n    fm = feature_map(n_qubits)\n    ansatz = hea(n_qubits=n_qubits, depth=3)\n    observable = hamiltonian_factory(n_qubits, detuning = Z)\n    circuit = QuantumCircuit(n_qubits, fm, ansatz)\n\n    model = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\n    batch_size = 1\n    input_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\n    pred = model(input_values)\n\n    ## lets prepare the train routine\n\n    cnt = count()\n    criterion = torch.nn.MSELoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\n    def loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n        next(cnt)\n        x, y = data[0], data[1]\n        out = model(x)\n        loss = criterion(out, y)\n        return loss, {}\n\n    tmp_path = Path(\"/tmp\")\n    n_epochs = 5\n    batch_size = 25\n    config = TrainConfig(\n        folder=tmp_path,\n        max_iter=n_epochs,\n        checkpoint_every=100,\n        write_every=100,\n    )\n    x = torch.linspace(0, 1, batch_size).reshape(-1, 1)\n    y = torch.sin(x)\n    data = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    train_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n    ```\n    \"\"\"\n\n    # Move model to device before optimizer is loaded\n    if isinstance(model, DataParallel):\n        model = model.module.to(device)\n    else:\n        model = model.to(device)\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    ## Training\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        # outer epoch loop\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            try:\n                # in case there is not data needed by the model\n                # this is the case, for example, of quantum models\n                # which do not have classical input data (e.g. chemistry)\n                if dataloader is None:\n                    loss, metrics = optimize_step(\n                        model=model, optimizer=optimizer, loss_fn=loss_fn, xs=None, device=device\n                    )\n                    loss = loss.item()\n\n                elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                    loss, metrics = optimize_step(\n                        model=model,\n                        optimizer=optimizer,\n                        loss_fn=loss_fn,\n                        xs=next(dl_iter),  # type: ignore[arg-type]\n                        device=device,\n                    )\n\n                else:\n                    raise NotImplementedError(\n                        f\"Unsupported dataloader type: {type(dataloader)}. \"\n                        \"You can use e.g. `qadence.ml_tools.to_dataloader` to build a dataloader.\"\n                    )\n\n                if iteration % config.print_every == 0 and config.verbose:\n                    print_metrics(loss, metrics, iteration)\n\n                if iteration % config.write_every == 0:\n                    write_tensorboard(writer, loss, metrics, iteration)\n\n                if config.folder:\n                    if iteration % config.checkpoint_every == 0:\n                        write_checkpoint(config.folder, model, optimizer, iteration)\n\n            except KeyboardInterrupt:\n                print(\"Terminating training gracefully after the current iteration.\")\n                break\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.train_no_grad.train","title":"<code>train(model, dataloader, optimizer, config, loss_fn)</code>","text":"<p>Runs the training loop with a gradient-free optimizer.</p> <p>Assumes that <code>loss_fn</code> returns a tuple of (loss, metrics: dict), where <code>metrics</code> is a dict of scalars. Loss and metrics are written to tensorboard. Checkpoints are written every <code>config.checkpoint_every</code> steps (and after the last training step).  If a checkpoint is found at <code>config.folder</code> we resume training from there.  The tensorboard logs can be viewed via <code>tensorboard --logdir /path/to/folder</code>.</p> PARAMETER  DESCRIPTION <code>model</code> <p>The model to train</p> <p> TYPE: <code>Module</code> </p> <code>dataloader</code> <p>Dataloader constructed via <code>dictdataloader</code></p> <p> TYPE: <code>DictDataLoader | DataLoader | None</code> </p> <code>optimizer</code> <p>The optimizer to use taken from the Nevergrad library. If this is not the case the function will raise an AssertionError</p> <p> TYPE: <code>Optimizer</code> </p> <code>loss_fn</code> <p>Loss function returning (loss: float, metrics: dict[str, float])</p> <p> TYPE: <code>Callable</code> </p> Source code in <code>qadence/ml_tools/train_no_grad.py</code> <pre><code>def train(\n    model: Module,\n    dataloader: DictDataLoader | DataLoader | None,\n    optimizer: NGOptimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n) -&gt; tuple[Module, NGOptimizer]:\n    \"\"\"Runs the training loop with a gradient-free optimizer.\n\n    Assumes that `loss_fn` returns a tuple of (loss, metrics: dict), where\n    `metrics` is a dict of scalars. Loss and metrics are written to\n    tensorboard. Checkpoints are written every `config.checkpoint_every` steps\n    (and after the last training step).  If a checkpoint is found at `config.folder`\n    we resume training from there.  The tensorboard logs can be viewed via\n    `tensorboard --logdir /path/to/folder`.\n\n    Args:\n        model: The model to train\n        dataloader: Dataloader constructed via `dictdataloader`\n        optimizer: The optimizer to use taken from the Nevergrad library. If this is not\n            the case the function will raise an AssertionError\n        loss_fn: Loss function returning (loss: float, metrics: dict[str, float])\n    \"\"\"\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n        logger.debug(f\"Loaded model and optimizer from {config.folder}\")\n\n    def _update_parameters(\n        data: Tensor | None, ng_params: ng.p.Array\n    ) -&gt; tuple[float, dict, ng.p.Array]:\n        loss, metrics = loss_fn(model, data)  # type: ignore[misc]\n        optimizer.tell(ng_params, float(loss))\n        ng_params = optimizer.ask()  # type: ignore [assignment]\n        params = promote_to_tensor(ng_params.value, requires_grad=False)\n        set_parameters(model, params)\n        return loss, metrics, ng_params\n\n    assert loss_fn is not None, \"Provide a valid loss function\"\n    # TODO: support also Scipy optimizers\n    assert isinstance(optimizer, NGOptimizer), \"Use only optimizers from the Nevergrad library\"\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    # set optimizer configuration and initial parameters\n    optimizer.budget = config.max_iter\n    optimizer.enable_pickling()\n\n    # TODO: Make it GPU compatible if possible\n    params = get_parameters(model).detach().numpy()\n    ng_params = ng.p.Array(init=params)\n\n    # serial training\n    # TODO: Add a parallelization using the num_workers argument in Nevergrad\n    progress = Progress(\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        TimeRemainingColumn(elapsed_when_finished=True),\n    )\n    with progress:\n        dl_iter = iter(dataloader) if dataloader is not None else None\n\n        for iteration in progress.track(range(init_iter, init_iter + config.max_iter)):\n            if dataloader is None:\n                loss, metrics, ng_params = _update_parameters(None, ng_params)\n\n            elif isinstance(dataloader, (DictDataLoader, DataLoader)):\n                data = next(dl_iter)  # type: ignore[arg-type]\n                loss, metrics, ng_params = _update_parameters(data, ng_params)\n\n            else:\n                raise NotImplementedError(\"Unsupported dataloader type!\")\n\n            if iteration % config.print_every == 0 and config.verbose:\n                print_metrics(loss, metrics, iteration)\n\n            if iteration % config.write_every == 0:\n                write_tensorboard(writer, loss, metrics, iteration)\n\n            if config.folder:\n                if iteration % config.checkpoint_every == 0:\n                    write_checkpoint(config.folder, model, optimizer, iteration)\n\n            if iteration &gt;= init_iter + config.max_iter:\n                break\n\n    ## Final writing and stuff\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.DictDataLoader","title":"<code>DictDataLoader</code>  <code>dataclass</code>","text":"<p>This class only holds a dictionary of <code>DataLoader</code>s and samples from them.</p>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.InfiniteTensorDataset","title":"<code>InfiniteTensorDataset(*tensors)</code>","text":"<p>             Bases: <code>IterableDataset</code></p> <p>Randomly sample points from the first dimension of the given tensors.</p> <p>Behaves like a normal torch <code>Dataset</code> just that we can sample from it as many times as we want.</p> <p>Examples: <pre><code>import torch\nfrom qadence.ml_tools.data import InfiniteTensorDataset\n\nx_data, y_data = torch.rand(5,2), torch.ones(5,1)\n# The dataset accepts any number of tensors with the same batch dimension\nds = InfiniteTensorDataset(x_data, y_data)\n\n# call `next` to get one sample from each tensor:\nxs = next(iter(ds))\n</code></pre> <pre><code>(tensor([0.3026, 0.2765]), tensor([1.]))\n</code></pre></p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def __init__(self, *tensors: Tensor):\n    \"\"\"Randomly sample points from the first dimension of the given tensors.\n\n    Behaves like a normal torch `Dataset` just that we can sample from it as\n    many times as we want.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools.data import InfiniteTensorDataset\n\n    x_data, y_data = torch.rand(5,2), torch.ones(5,1)\n    # The dataset accepts any number of tensors with the same batch dimension\n    ds = InfiniteTensorDataset(x_data, y_data)\n\n    # call `next` to get one sample from each tensor:\n    xs = next(iter(ds))\n    print(str(xs)) # markdown-exec: hide\n    ```\n    \"\"\"\n    self.tensors = tensors\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.data_to_device","title":"<code>data_to_device(xs, device)</code>","text":"<p>Utility method to move arbitrary data to 'device'.</p> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>@singledispatch\ndef data_to_device(xs: Any, device: torch_device) -&gt; Any:\n    \"\"\"Utility method to move arbitrary data to 'device'.\"\"\"\n    raise ValueError(f\"Cannot move {type(xs)} to a pytorch device.\")\n</code></pre>"},{"location":"qadence/ml_tools/#qadence.ml_tools.data.to_dataloader","title":"<code>to_dataloader(*tensors, batch_size=1, infinite=False)</code>","text":"<p>Convert torch tensors an (infinite) Dataloader.</p> PARAMETER  DESCRIPTION <code>*tensors</code> <p>Torch tensors to use in the dataloader.</p> <p> TYPE: <code>Tensor</code> DEFAULT: <code>()</code> </p> <code>batch_size</code> <p>batch size of sampled tensors</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>infinite</code> <p>if <code>True</code>, the dataloader will keep sampling indefinitely even after the whole dataset was sampled once</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <p>Examples:</p> <pre><code>import torch\nfrom qadence.ml_tools import to_dataloader\n\n(x, y, z) = [torch.rand(10) for _ in range(3)]\nloader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\nprint(next(loader))\nprint(next(loader))\nprint(next(loader))\n</code></pre> <pre><code>[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n[tensor([0.6595, 0.0538, 0.8660, 0.8650, 0.0394]), tensor([0.2900, 0.3294, 0.6735, 0.3359, 0.2816]), tensor([0.4227, 0.3033, 0.5571, 0.8693, 0.4491])]\n[tensor([0.3523, 0.4637, 0.0024, 0.5235, 0.7832]), tensor([0.7859, 0.8499, 0.4648, 0.2846, 0.6703]), tensor([0.5092, 0.4580, 0.1599, 0.6729, 0.4423])]\n</code></pre> Source code in <code>qadence/ml_tools/data.py</code> <pre><code>def to_dataloader(*tensors: Tensor, batch_size: int = 1, infinite: bool = False) -&gt; DataLoader:\n    \"\"\"Convert torch tensors an (infinite) Dataloader.\n\n    Arguments:\n        *tensors: Torch tensors to use in the dataloader.\n        batch_size: batch size of sampled tensors\n        infinite: if `True`, the dataloader will keep sampling indefinitely even after the whole\n            dataset was sampled once\n\n    Examples:\n\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    import torch\n    from qadence.ml_tools import to_dataloader\n\n    (x, y, z) = [torch.rand(10) for _ in range(3)]\n    loader = iter(to_dataloader(x, y, z, batch_size=5, infinite=True))\n    print(next(loader))\n    print(next(loader))\n    print(next(loader))\n    ```\n    \"\"\"\n    ds = InfiniteTensorDataset(*tensors) if infinite else TensorDataset(*tensors)\n    return DataLoader(ds, batch_size=batch_size)\n</code></pre>"},{"location":"qadence/operations/","title":"Operations","text":"<p>Operations are common <code>PrimitiveBlocks</code>, these are often called gates elsewhere.</p>"},{"location":"qadence/operations/#constant-blocks","title":"Constant blocks","text":"<p>CY gate not implemented</p>"},{"location":"qadence/operations/#qadence.operations.X","title":"<code>X(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The X gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Y","title":"<code>Y(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Y gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.Z","title":"<code>Z(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Z gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.I","title":"<code>I(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The identity gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.H","title":"<code>H(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hadamard or H gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = (1 / np.sqrt(2)) * (X(target) + Z(target) - np.sqrt(2) * I(target))\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.S","title":"<code>S(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The S / Phase gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SDagger","title":"<code>SDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the S / Phase gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.SWAP","title":"<code>SWAP(control, target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The SWAP gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    a11 = 0.5 * (Z(control) - I(control))\n    a22 = -0.5 * (Z(target) + I(target))\n    a12 = 0.5 * (chain(X(control), Z(control)) + X(control))\n    a21 = 0.5 * (chain(Z(target), X(target)) + X(target))\n    self.generator = (\n        kron(-1.0 * a22, a11) + kron(-1.0 * a11, a22) + kron(a12, a21) + kron(a21, a12)\n    )\n    super().__init__((control, target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.T","title":"<code>T(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The T gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.TDagger","title":"<code>TDagger(target)</code>","text":"<p>             Bases: <code>PrimitiveBlock</code></p> <p>The Hermitian adjoint/conjugate transpose of the T gate.</p> Source code in <code>qadence/operations/primitive.py</code> <pre><code>def __init__(self, target: int):\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CNOT","title":"<code>CNOT(control, target)</code>","text":"<p>             Bases: <code>ControlBlock</code></p> <p>The CNot, or CX, gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    self.generator = kron(N(control), X(target) - I(target))\n    super().__init__((control,), X(target))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CZ","title":"<code>CZ(control, target)</code>","text":"<p>             Bases: <code>MCZ</code></p> <p>The CZ gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(self, control: int, target: int) -&gt; None:\n    super().__init__((control,), target)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CPHASE","title":"<code>CPHASE(control, target, parameter)</code>","text":"<p>             Bases: <code>MCPHASE</code></p> <p>The CPHASE gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#parametrized-blocks","title":"Parametrized blocks","text":""},{"location":"qadence/operations/#qadence.operations.RX","title":"<code>RX(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rx gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    # TODO: should we give them more meaningful names? like 'angle'?\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = X(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RY","title":"<code>RY(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Ry gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Y(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.RZ","title":"<code>RZ(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Rz gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TParameter | ParamMap):\n    self.parameters = (\n        parameter if isinstance(parameter, ParamMap) else ParamMap(parameter=parameter)\n    )\n    self.generator = Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRX","title":"<code>CRX(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRX</code></p> <p>The CRX gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRY","title":"<code>CRY(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRY</code></p> <p>The CRY gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: TParameter,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.CRZ","title":"<code>CRZ(control, target, parameter)</code>","text":"<p>             Bases: <code>MCRZ</code></p> <p>The CRZ gate.</p> Source code in <code>qadence/operations/control_ops.py</code> <pre><code>def __init__(\n    self,\n    control: int,\n    target: int,\n    parameter: Parameter | TNumber | sympy.Expr | str,\n):\n    super().__init__((control,), target, parameter)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.PHASE","title":"<code>PHASE(target, parameter)</code>","text":"<p>             Bases: <code>ParametricBlock</code></p> <p>The Parametric Phase / S gate.</p> Source code in <code>qadence/operations/parametric.py</code> <pre><code>def __init__(self, target: int, parameter: Parameter | TNumber | sympy.Expr | str):\n    self.parameters = ParamMap(parameter=parameter)\n    self.generator = I(target) - Z(target)\n    super().__init__((target,))\n</code></pre>"},{"location":"qadence/operations/#hamiltonian-evolution","title":"Hamiltonian Evolution","text":"<p>AnalogSWAP should be turned into a proper analog block</p>"},{"location":"qadence/operations/#qadence.operations.HamEvo","title":"<code>HamEvo(generator, parameter, qubit_support=None)</code>","text":"<p>             Bases: <code>TimeEvolutionBlock</code></p> <p>A block implementing the Hamiltonian evolution operation H where:</p> <pre><code>H = exp(-iG, t)\n</code></pre> <p>where G represents a square generator and t represents the time parameter which can be parametrized.</p> PARAMETER  DESCRIPTION <code>generator</code> <p>Either a AbstractBlock, torch.Tensor or numpy.ndarray.</p> <p> TYPE: <code>Union[TGenerator, AbstractBlock]</code> </p> <code>parameter</code> <p>A scalar or vector of numeric or torch.Tensor type.</p> <p> TYPE: <code>TParameter</code> </p> <code>qubit_support</code> <p>The qubits on which the evolution will be performed on.</p> <p> TYPE: <code>tuple[int, ...]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <pre><code>from qadence import RX, HamEvo, run, PI\nimport torch\nhevo = HamEvo(generator=RX(0, PI), parameter=torch.rand(2))\nprint(run(hevo))\n# Now lets use a torch.Tensor as a generator, Now we have to pass the support\ngen = torch.rand(2,2, dtype=torch.complex128)\nhevo = HamEvo(generator=gen, parameter=torch.rand(2), qubit_support=(0,))\nprint(run(hevo))\n</code></pre> <pre><code>tensor([[ 1.1384-3.6270e-17j, -0.5441+1.7335e-17j],\n        [ 1.2545-5.3697e-17j, -0.7574+3.2421e-17j]])\ntensor([[1.5091-0.7780j, 0.5771-0.9542j],\n        [1.4106-0.5384j, 0.5040-0.6605j]])\n</code></pre> Source code in <code>qadence/operations/ham_evo.py</code> <pre><code>def __init__(\n    self,\n    generator: Union[TGenerator, AbstractBlock],\n    parameter: TParameter,\n    qubit_support: tuple[int, ...] = None,\n):\n    gen_exprs = {}\n    if qubit_support is None and not isinstance(generator, AbstractBlock):\n        raise ValueError(\"You have to supply a qubit support for non-block generators.\")\n    super().__init__(qubit_support if qubit_support else generator.qubit_support)\n    if isinstance(generator, AbstractBlock):\n        qubit_support = generator.qubit_support\n        if generator.is_parametric:\n            gen_exprs = {str(e): e for e in expressions(generator)}\n    elif isinstance(generator, torch.Tensor):\n        msg = \"Please provide a square generator.\"\n        if len(generator.shape) == 2:\n            assert generator.shape[0] == generator.shape[1], msg\n        elif len(generator.shape) == 3:\n            assert generator.shape[1] == generator.shape[2], msg\n            assert generator.shape[0] == 1, \"Qadence doesnt support batched generators.\"\n        else:\n            raise TypeError(\n                \"Only 2D or 3D generators are supported.\\\n                            In case of a 3D generator, the batch dim\\\n                            is expected to be at dim 0.\"\n            )\n        gen_exprs = {str(generator.__hash__()): generator}\n    elif isinstance(generator, (sympy.Basic, sympy.Array)):\n        gen_exprs = {str(generator): generator}\n    else:\n        raise TypeError(\n            f\"Generator of type {type(generator)} not supported.\\\n                        If you're using a numpy.ndarray, please cast it to a torch tensor.\"\n        )\n    ps = {\"parameter\": Parameter(parameter), **gen_exprs}\n    self.parameters = ParamMap(**ps)\n    self.generator = generator\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.HamEvo.digital_decomposition","title":"<code>digital_decomposition(approximation=LTSOrder.ST4)</code>","text":"<p>Decompose the Hamiltonian evolution into digital gates.</p> PARAMETER  DESCRIPTION <code>approximation</code> <p>Choose the type of decomposition. Defaults to \"st4\". Available types are: * 'basic' = apply first-order Trotter formula and decompose each term of     the exponential into digital gates. It is exact only if applied to an     operator whose terms are mutually commuting. * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting     Hamiltonians. * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting     Hamiltonians.</p> <p> TYPE: <code>str</code> DEFAULT: <code>ST4</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>a block with the digital decomposition</p> <p> TYPE: <code>AbstractBlock</code> </p> Source code in <code>qadence/operations/ham_evo.py</code> <pre><code>def digital_decomposition(self, approximation: LTSOrder = LTSOrder.ST4) -&gt; AbstractBlock:\n    \"\"\"Decompose the Hamiltonian evolution into digital gates.\n\n    Args:\n        approximation (str, optional): Choose the type of decomposition. Defaults to \"st4\".\n            Available types are:\n            * 'basic' = apply first-order Trotter formula and decompose each term of\n                the exponential into digital gates. It is exact only if applied to an\n                operator whose terms are mutually commuting.\n            * 'st2' = Trotter-Suzuki 2nd order formula for approximating non-commuting\n                Hamiltonians.\n            * 'st4' = Trotter-Suzuki 4th order formula for approximating non-commuting\n                Hamiltonians.\n\n    Returns:\n        AbstractBlock: a block with the digital decomposition\n    \"\"\"\n\n    # psi(t) = exp(-i * H * t * psi0)\n    # psi(t) = exp(-i * lambda * t * psi0)\n    # H = sum(Paulin) + sum(Pauli1*Pauli2)\n    logger.info(\"Quantum simulation of the time-independent Schr\u00f6dinger equation.\")\n\n    blocks = []\n\n    # how to change the type/dict to enum effectively\n\n    # when there is a term including non-commuting matrices use st2 or st4\n\n    # 1) should check that the given generator respects the constraints\n    # single-qubit gates\n\n    assert isinstance(\n        self.generator, AbstractBlock\n    ), \"Only a generator represented as a block can be decomposed\"\n\n    if block_is_qubit_hamiltonian(self.generator):\n        try:\n            block_is_commuting_hamiltonian(self.generator)\n            approximation = LTSOrder.BASIC  # use the simpler approach if the H is commuting\n        except TypeError:\n            logger.warning(\n                \"\"\"Non-commuting terms in the Pauli operator.\n                The Suzuki-Trotter approximation is applied.\"\"\"\n            )\n\n        blocks.extend(\n            lie_trotter_suzuki(\n                block=self.generator,\n                parameter=self.parameters.parameter,\n                order=LTSOrder[approximation],\n            )\n        )\n\n        # 2) return an AbstractBlock instance with the set of gates\n        # resulting from the decomposition\n\n        return chain(*blocks)\n    else:\n        raise NotImplementedError(\n            \"The current digital decomposition can be applied only to Pauli Hamiltonians.\"\n        )\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogSWAP","title":"<code>AnalogSWAP(control, target, parameter=3 * PI / 4)</code>","text":"<p>             Bases: <code>HamEvo</code></p> <p>Single time-independent Hamiltonian evolution over a Rydberg Ising.</p> <p>hamiltonian yielding a SWAP (up to global phase).</p> <p>Derived from Bapat et al. where it is applied to XX-type Hamiltonian</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def __init__(self, control: int, target: int, parameter: TParameter = 3 * PI / 4):\n    rydberg_ising_hamiltonian_generator = (\n        4.0 * kron((I(control) - Z(control)) / 2.0, (I(target) - Z(target)) / 2.0)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(control)\n        + (2.0 / 3.0) * np.sqrt(2.0) * X(target)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(control)\n        + (1.0 + np.sqrt(5.0) / 3) * Z(target)\n    )\n    super().__init__(rydberg_ising_hamiltonian_generator, parameter, (control, target))\n</code></pre>"},{"location":"qadence/operations/#analog-blocks","title":"Analog blocks","text":""},{"location":"qadence/operations/#qadence.operations.AnalogRX","title":"<code>AnalogRX(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog X rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9)\n</code></pre> PARAMETER  DESCRIPTION <code>angle</code> <p>Rotation angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRX(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog X rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9)\n    ```\n\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=0, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRY","title":"<code>AnalogRY(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Y rotation.</p> <p>Shorthand for <code>AnalogRot</code>:</p> <p><pre><code>\u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\nAnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n</code></pre> Arguments:     angle: Rotation angle [rad]     qubit_support: Defines the (local/global) qubit support</p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRY(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Y rotation.\n\n    Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n\n    ```python\n    \u03c6=2.4; \u03a9=\u03c0; t = \u03c6/\u03a9 * 1000\n    AnalogRot(duration=t, omega=\u03a9, phase=-\u03c0/2)\n    ```\n    Arguments:\n        angle: Rotation angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n    return _analog_rot(angle, qubit_support, phase=-PI / 2, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRZ","title":"<code>AnalogRZ(angle, qubit_support='global', add_pattern=True)</code>","text":"<p>Analog Z rotation. Shorthand for <code>AnalogRot</code>: <pre><code>\u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\nAnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n</code></pre></p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRZ(\n    angle: float | str | Parameter,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"Analog Z rotation. Shorthand for [`AnalogRot`][qadence.operations.AnalogRot]:\n    ```\n    \u03c6=2.4; \u03b4=\u03c0; t = \u03c6/\u03b4 * 100)\n    AnalogRot(duration=t, delta=\u03b4, phase=\u03c0/2)\n    ```\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    alpha = _cast(Parameter, angle)\n    delta = PI\n    omega = 0\n    duration = alpha / delta * 1000\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=0.0, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(qubit_support=q, parameters=ps, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogRot","title":"<code>AnalogRot(duration, omega=0, delta=0, phase=0, qubit_support='global', add_pattern=True)</code>","text":"<p>General analog rotation operation.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Duration of the rotation [ns].</p> <p> TYPE: <code>float | str | Parameter</code> </p> <code>omega</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>delta</code> <p>Rotation frequency [rad/\u03bcs]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>phase</code> <p>Phase angle [rad]</p> <p> TYPE: <code>float | str | Parameter</code> DEFAULT: <code>0</code> </p> <code>qubit_support</code> <p>Defines the (local/global) qubit support</p> <p> TYPE: <code>str | QubitSupport | Tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>ConstantAnalogRotation</code> <p>ConstantAnalogRotation</p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogRot(\n    duration: float | str | Parameter,\n    omega: float | str | Parameter = 0,\n    delta: float | str | Parameter = 0,\n    phase: float | str | Parameter = 0,\n    qubit_support: str | QubitSupport | Tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; ConstantAnalogRotation:\n    \"\"\"General analog rotation operation.\n\n    Arguments:\n        duration: Duration of the rotation [ns].\n        omega: Rotation frequency [rad/\u03bcs]\n        delta: Rotation frequency [rad/\u03bcs]\n        phase: Phase angle [rad]\n        qubit_support: Defines the (local/global) qubit support\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        ConstantAnalogRotation\n    \"\"\"\n\n    if omega == 0 and delta == 0:\n        raise ValueError(\"Parameters omega and delta cannot both be 0.\")\n\n    q = _cast(QubitSupport, qubit_support)\n    duration = Parameter(duration)\n    omega = Parameter(omega)\n    delta = Parameter(delta)\n    phase = Parameter(phase)\n    h_norm = sympy.sqrt(omega**2 + delta**2)\n    alpha = duration * h_norm / 1000\n    ps = ParamMap(\n        alpha=alpha, duration=duration, omega=omega, delta=delta, phase=phase, h_norm=h_norm\n    )\n    return ConstantAnalogRotation(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/operations/#qadence.operations.AnalogInteraction","title":"<code>AnalogInteraction(duration, qubit_support='global', add_pattern=True)</code>","text":"<p>Evolution of the interaction term for a register of qubits.</p> <p>Constructs a <code>InteractionBlock</code>.</p> PARAMETER  DESCRIPTION <code>duration</code> <p>Time to evolve the interaction for in nanoseconds.</p> <p> TYPE: <code>TNumber | Basic</code> </p> <code>qubit_support</code> <p>Qubits the <code>InteractionBlock</code> is applied to. Can be either <code>\"global\"</code> to evolve the interaction block to all qubits or a tuple of integers.</p> <p> TYPE: <code>str | QubitSupport | tuple</code> DEFAULT: <code>'global'</code> </p> <code>add_pattern</code> <p>False disables the semi-local addressing pattern for the execution of this specific block.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>InteractionBlock</code> <p>a <code>InteractionBlock</code></p> Source code in <code>qadence/operations/analog.py</code> <pre><code>def AnalogInteraction(\n    duration: TNumber | sympy.Basic,\n    qubit_support: str | QubitSupport | tuple = \"global\",\n    add_pattern: bool = True,\n) -&gt; InteractionBlock:\n    \"\"\"Evolution of the interaction term for a register of qubits.\n\n    Constructs a [`InteractionBlock`][qadence.blocks.analog.InteractionBlock].\n\n    Arguments:\n        duration: Time to evolve the interaction for in nanoseconds.\n        qubit_support: Qubits the `InteractionBlock` is applied to. Can be either\n            `\"global\"` to evolve the interaction block to all qubits or a tuple of integers.\n        add_pattern: False disables the semi-local addressing pattern\n            for the execution of this specific block.\n\n    Returns:\n        a `InteractionBlock`\n    \"\"\"\n    q = _cast(QubitSupport, qubit_support)\n    ps = ParamMap(duration=duration)\n    return InteractionBlock(parameters=ps, qubit_support=q, add_pattern=add_pattern)\n</code></pre>"},{"location":"qadence/parameters/","title":"Parameters","text":""},{"location":"qadence/parameters/#parameters","title":"Parameters","text":""},{"location":"qadence/parameters/#qadence.parameters.ParamMap","title":"<code>ParamMap(**kwargs)</code>","text":"<p>Connects UUIDs of parameters to their expressions and names.</p> <p>This class is not user-facing and only needed for more complex block definitions. It provides convenient access to expressions/UUIDs/names needed in different backends.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Parameters.</p> <p> TYPE: <code>str | TNumber | Tensor | Basic | Parameter</code> DEFAULT: <code>{}</code> </p> <p>Example: <pre><code>import sympy\nfrom qadence.parameters import ParamMap\n\n(x,y) = sympy.symbols(\"x y\")\nps = ParamMap(omega=2.0, duration=x+y)\n\nprint(f\"{ps.names() = }\")\nprint(f\"{ps.expressions() = }\")\nprint(f\"{ps.uuids() = }\")\n</code></pre> <pre><code>ps.names() = dict_keys(['omega', 'duration'])\nps.expressions() = dict_values([2.00000000000000, x + y])\nps.uuids() = dict_keys(['491a7b4e-6023-488c-a1ae-cb66f463775e', '2c5c4aa0-01ee-4621-8a32-04809d3b7139'])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __init__(self, **kwargs: str | TNumber | Tensor | Basic | Parameter):\n    self._name_dict: dict[str, tuple[str, Basic]] = {}\n    self._uuid_dict: dict[str, str] = {}\n    for name, v in kwargs.items():\n        param = v if isinstance(v, sympy.Basic) else Parameter(v)\n        uuid = str(uuid4())\n        self._name_dict[name] = (uuid, param)\n        self._uuid_dict[uuid] = param\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>             Bases: <code>Symbol</code></p> <p>A wrapper on top of <code>sympy.Symbol</code>.</p> <p>Includes two additional keywords: <code>trainable</code> and <code>value</code>. This class is to define both feature parameter and variational parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.trainable","title":"<code>trainable: bool</code>  <code>instance-attribute</code>","text":"<p>Trainable parameters are variational parameters.</p> <p>Non-trainable parameters are feature parameters.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.value","title":"<code>value: TNumber</code>  <code>instance-attribute</code>","text":"<p>(Initial) value of the parameter.</p>"},{"location":"qadence/parameters/#qadence.parameters.Parameter.__new__","title":"<code>__new__(name, **assumptions)</code>","text":"<p>Arguments:</p> <pre><code>name: When given a string only, the class\n    constructs a trainable Parameter with a a randomly initialized value.\n**assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n    kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, VariationalParameter\n\ntheta = Parameter(\"theta\")\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\nassert not theta.is_number\n\n# you can specify both trainable/value in the constructor\ntheta = Parameter(\"theta\", trainable=True, value=2.0)\nprint(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n# VariationalParameter/FeatureParameter are constructing\n# trainable/untrainable Parameters\ntheta = VariationalParameter(\"theta\", value=2.0)\nassert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n# When provided with a numeric type, Parameter constructs a sympy numeric type\":\nconstant_zero = Parameter(0)\nassert constant_zero.is_number\n\n# When passed a Parameter or a sympy expression, it just returns it.\nexpr = Parameter(\"x\") * Parameter(\"y\")\nprint(f\"{expr=} : {expr.free_symbols}\")\n</code></pre> <pre><code>theta: trainable=True value=0.9859993654159114\ntheta: trainable=True value=2.0\nexpr=x*y : {y, x}\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def __new__(\n    cls, name: str | TNumber | Tensor | Basic | Parameter, **assumptions: Any\n) -&gt; Parameter | Basic | Expr | Array:\n    \"\"\"\n    Arguments:\n\n        name: When given a string only, the class\n            constructs a trainable Parameter with a a randomly initialized value.\n        **assumptions: are passed on to the parent class `sympy.Symbol`. Two new assumption\n            kwargs are supported by this constructor: `trainable: bool`, and `value: TNumber`.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, VariationalParameter\n\n    theta = Parameter(\"theta\")\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n    assert not theta.is_number\n\n    # you can specify both trainable/value in the constructor\n    theta = Parameter(\"theta\", trainable=True, value=2.0)\n    print(f\"{theta}: trainable={theta.trainable} value={theta.value}\")\n\n    # VariationalParameter/FeatureParameter are constructing\n    # trainable/untrainable Parameters\n    theta = VariationalParameter(\"theta\", value=2.0)\n    assert theta == Parameter(\"theta\", trainable=True, value=2.0)\n\n    # When provided with a numeric type, Parameter constructs a sympy numeric type\":\n    constant_zero = Parameter(0)\n    assert constant_zero.is_number\n\n    # When passed a Parameter or a sympy expression, it just returns it.\n    expr = Parameter(\"x\") * Parameter(\"y\")\n    print(f\"{expr=} : {expr.free_symbols}\")\n    ```\n    \"\"\"\n    p: Parameter\n    if isinstance(name, get_args(TNumber)):\n        return sympify(name)\n    elif isinstance(name, Tensor):\n        if name.numel() == 1:\n            return sympify(name)\n        else:\n            return Array(name.detach().numpy())\n    elif isinstance(name, Parameter):\n        p = super().__new__(cls, name.name, **assumptions)\n        p.name = name.name\n        p.trainable = name.trainable\n        p.value = name.value\n        return p\n    elif isinstance(name, (Basic, Expr)):\n        if name.is_number:\n            return sympify(evaluate(name))\n        return name\n    elif isinstance(name, str):\n        p = super().__new__(cls, name, **assumptions)\n        p.trainable = assumptions.get(\"trainable\", True)\n        p.value = assumptions.get(\"value\", None)\n        if p.value is None:\n            p.value = rand(1).item()\n        return p\n    else:\n        raise TypeError(f\"Parameter does not support type {type(name)}\")\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.FeatureParameter","title":"<code>FeatureParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=False)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def FeatureParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=False)`.\"\"\"\n    return Parameter(name, trainable=False, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.VariationalParameter","title":"<code>VariationalParameter(name, **kwargs)</code>","text":"<p>Shorthand for <code>Parameter(..., trainable=True)</code>.</p> Source code in <code>qadence/parameters.py</code> <pre><code>def VariationalParameter(name: str, **kwargs: Any) -&gt; Parameter:\n    \"\"\"Shorthand for `Parameter(..., trainable=True)`.\"\"\"\n    return Parameter(name, trainable=True, **kwargs)\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.evaluate","title":"<code>evaluate(expr, values={}, as_torch=False)</code>","text":"<p>Arguments:</p> <pre><code>expr: An expression consisting of Parameters.\nvalues: values dict which contains values for the Parameters,\n    if empty, Parameter.value will be used.\nas_torch: Whether to retrieve a torch-differentiable expression result.\n</code></pre> <p>Example: <pre><code>from qadence.parameters import Parameter, evaluate\n\nexpr = Parameter(\"x\") * Parameter(\"y\")\n\n# Unless specified, Parameter initialized random values\n# Lets evaluate this expression and see what the result is\nres = evaluate(expr)\nprint(res)\n\n# We can also evaluate the expr using a custom dict\nd = {\"x\": 1, \"y\":2}\nres = evaluate(expr, d)\nprint(res)\n\n# Lastly, if we want a differentiable result, lets put the as_torch flag\nres = evaluate(expr, d, as_torch=True)\nprint(res)\n</code></pre> <pre><code>0.6903893734503416\n2.0\ntensor([2])\n</code></pre> </p> Source code in <code>qadence/parameters.py</code> <pre><code>def evaluate(expr: Expr, values: dict = {}, as_torch: bool = False) -&gt; TNumber | Tensor:\n    \"\"\"\n    Arguments:\n\n        expr: An expression consisting of Parameters.\n        values: values dict which contains values for the Parameters,\n            if empty, Parameter.value will be used.\n        as_torch: Whether to retrieve a torch-differentiable expression result.\n\n    Example:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.parameters import Parameter, evaluate\n\n    expr = Parameter(\"x\") * Parameter(\"y\")\n\n    # Unless specified, Parameter initialized random values\n    # Lets evaluate this expression and see what the result is\n    res = evaluate(expr)\n    print(res)\n\n    # We can also evaluate the expr using a custom dict\n    d = {\"x\": 1, \"y\":2}\n    res = evaluate(expr, d)\n    print(res)\n\n    # Lastly, if we want a differentiable result, lets put the as_torch flag\n    res = evaluate(expr, d, as_torch=True)\n    print(res)\n    ```\n    \"\"\"\n    res: Basic\n    res_value: TNumber | Tensor\n    query: dict[Parameter, TNumber | Tensor] = {}\n    if isinstance(expr, Array):\n        return Tensor(expr.tolist())\n    else:\n        if not expr.is_number:\n            for s in expr.free_symbols:\n                if s.name in values.keys():\n                    query[s] = values[s.name]\n                elif hasattr(s, \"value\"):\n                    query[s] = s.value\n                else:\n                    raise ValueError(f\"No value provided for symbol {s.name}\")\n        if as_torch:\n            res_value = make_differentiable(expr)(**{s.name: tensor(v) for s, v in query.items()})\n        else:\n            res = expr.subs(query)\n            res_value = sympy_to_numeric(res)\n        return res_value\n</code></pre>"},{"location":"qadence/parameters/#qadence.parameters.extract_original_param_entry","title":"<code>extract_original_param_entry(param)</code>","text":"<p>Given an Expression, what was the original \"param\" given by the user? It is either.</p> <p>going to be a numeric value, or a sympy Expression (in case a string was given, it was converted via Parameter(\"string\").</p> Source code in <code>qadence/parameters.py</code> <pre><code>def extract_original_param_entry(\n    param: Expr,\n) -&gt; TNumber | Tensor | Expr:\n    \"\"\"\n    Given an Expression, what was the original \"param\" given by the user? It is either.\n\n    going to be a numeric value, or a sympy Expression (in case a string was given,\n    it was converted via Parameter(\"string\").\n    \"\"\"\n    return param if not param.is_number else evaluate(param)\n</code></pre>"},{"location":"qadence/parameters/#parameter-embedding","title":"Parameter embedding","text":""},{"location":"qadence/parameters/#qadence.blocks.embedding.embedding","title":"<code>embedding(block, to_gate_params=False, engine=Engine.TORCH)</code>","text":"<p>Construct embedding function which maps user-facing parameters to either expression-level.</p> <p>parameters or gate-level parameters. The constructed embedding function has the signature:</p> <pre><code> embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n</code></pre> <p>which means that it maps the variational parameter dict <code>params</code> and the feature parameter dict <code>inputs</code> to one new parameter dict <code>embedded_dict</code> which holds all parameters that are needed to execute a circuit on a given backend. There are two different modes for this mapping:</p> <ul> <li>Expression-level parameters: For AD-based optimization. For every unique expression we end   up with one entry in the embedded dict:   <code>len(embedded_dict) == len(unique_parameter_expressions)</code>.</li> <li>Gate-level parameters: For PSR-based optimization or real devices. One parameter for each   gate parameter, regardless if they are based on the same expression. <code>len(embedded_dict) ==   len(parametric_gates)</code>. This is needed because PSR requires to shift the angles of every   gate where the same parameter appears.</li> </ul> PARAMETER  DESCRIPTION <code>block</code> <p>parametrized block into which we want to embed parameters.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>to_gate_params</code> <p>A boolean flag whether to generate gate-level parameters or expression-level parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType]]</code> <p>A tuple with variational parameter dict and the embedding function.</p> Source code in <code>qadence/blocks/embedding.py</code> <pre><code>def embedding(\n    block: AbstractBlock, to_gate_params: bool = False, engine: Engine = Engine.TORCH\n) -&gt; tuple[ParamDictType, Callable[[ParamDictType, ParamDictType], ParamDictType],]:\n    \"\"\"Construct embedding function which maps user-facing parameters to either *expression-level*.\n\n    parameters or *gate-level* parameters. The constructed embedding function has the signature:\n\n         embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n\n    which means that it maps the *variational* parameter dict `params` and the *feature* parameter\n    dict `inputs` to one new parameter dict `embedded_dict` which holds all parameters that are\n    needed to execute a circuit on a given backend. There are two different *modes* for this\n    mapping:\n\n    - *Expression-level* parameters: For AD-based optimization. For every unique expression we end\n      up with one entry in the embedded dict:\n      `len(embedded_dict) == len(unique_parameter_expressions)`.\n    - *Gate-level* parameters: For PSR-based optimization or real devices. One parameter for each\n      gate parameter, regardless if they are based on the same expression. `len(embedded_dict) ==\n      len(parametric_gates)`. This is needed because PSR requires to shift the angles of **every**\n      gate where the same parameter appears.\n\n    Arguments:\n        block: parametrized block into which we want to embed parameters.\n        to_gate_params: A boolean flag whether to generate gate-level parameters or\n            expression-level parameters.\n\n    Returns:\n        A tuple with variational parameter dict and the embedding function.\n    \"\"\"\n    concretize_parameter = _concretize_parameter(engine)\n    if engine == Engine.TORCH:\n        cast_dtype = tensor\n    else:\n        from jax.numpy import array\n\n        cast_dtype = array\n\n    unique_expressions = unique(expressions(block))\n    unique_symbols = [p for p in unique(parameters(block)) if not isinstance(p, sympy.Array)]\n    unique_const_matrices = [e for e in unique_expressions if isinstance(e, sympy.Array)]\n    unique_expressions = [e for e in unique_expressions if not isinstance(e, sympy.Array)]\n\n    # NOTE\n    # there are 3 kinds of parameters in qadence\n    # - non-trainable which are considered as inputs for classical data\n    # - trainable which are the variational parameters to be optimized\n    # - fixed: which are non-trainable parameters with fixed value (e.g. pi/2)\n    #\n    # both non-trainable and trainable parameters can have the same element applied\n    # to different operations in the quantum circuit, e.g. assigning the same parameter\n    # to multiple gates.\n    non_numeric_symbols = [p for p in unique_symbols if not p.is_number]\n    trainable_symbols = [p for p in non_numeric_symbols if p.trainable]\n    constant_expressions = [expr for expr in unique_expressions if expr.is_number]\n    # we dont need to care about constant symbols if they are contained in an symbolic expression\n    # we only care about gate params which are ONLY a constant\n\n    embeddings: dict[sympy.Expr, DifferentiableExpression] = {\n        expr: make_differentiable(expr=expr, engine=engine)\n        for expr in unique_expressions\n        if not expr.is_number\n    }\n\n    uuid_to_expr = uuid_to_expression(block)\n\n    def embedding_fn(params: ParamDictType, inputs: ParamDictType) -&gt; ParamDictType:\n        embedded_params: dict[sympy.Expr, ArrayLike] = {}\n        for expr, fn in embeddings.items():\n            angle: ArrayLike\n            values = {}\n            for symbol in expr.free_symbols:\n                if symbol.name in inputs:\n                    value = inputs[symbol.name]\n                elif symbol.name in params:\n                    value = params[symbol.name]\n                else:\n                    msg_trainable = \"Trainable\" if symbol.trainable else \"Non-trainable\"\n                    raise KeyError(\n                        f\"{msg_trainable} parameter '{symbol.name}' not found in the \"\n                        f\"inputs list: {list(inputs.keys())} nor the \"\n                        f\"params list: {list(params.keys())}.\"\n                    )\n                values[symbol.name] = value\n            angle = fn(**values)\n            # do not reshape parameters which are multi-dimensional\n            # tensors, such as for example generator matrices\n            if not len(angle.squeeze().shape) &gt; 1:\n                angle = angle.reshape(-1)\n            embedded_params[expr] = angle\n\n        for e in constant_expressions + unique_const_matrices:\n            embedded_params[e] = params[stringify(e)]\n\n        if to_gate_params:\n            gate_lvl_params: ParamDictType = {}\n            for uuid, e in uuid_to_expr.items():\n                gate_lvl_params[uuid] = embedded_params[e]\n            return gate_lvl_params\n        else:\n            return {stringify(k): v for k, v in embedded_params.items()}\n\n    params: ParamDictType\n    params = {\n        p.name: concretize_parameter(value=p.value, trainable=True) for p in trainable_symbols\n    }\n    params.update(\n        {\n            stringify(expr): concretize_parameter(value=evaluate(expr), trainable=False)\n            for expr in constant_expressions\n        }\n    )\n    params.update(\n        {\n            stringify(expr): cast_dtype(nparray(expr.tolist(), dtype=npcdouble))\n            for expr in unique_const_matrices\n        }\n    )\n    return params, embedding_fn\n</code></pre>"},{"location":"qadence/quantumcircuit/","title":"QuantumCircuit","text":""},{"location":"qadence/quantumcircuit/#quantumcircuit","title":"QuantumCircuit","text":"<p>The abstract <code>QuantumCircuit</code> is the key object in Qadence, as it is what can be executed.</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit","title":"<code>QuantumCircuit(support, *blocks)</code>  <code>dataclass</code>","text":"<p>Am abstract QuantumCircuit instance.</p> <p>It needs to be passed to a quantum backend for execution.</p> <p>Arguments:</p> <pre><code>support: `Register` or number of qubits. If an integer is provided, a register is\n    constructed with `Register.all_to_all(x)`\n*blocks: (Possibly multiple) blocks to construct the circuit from.\n</code></pre> Source code in <code>qadence/circuit.py</code> <pre><code>def __init__(self, support: int | Register, *blocks: AbstractBlock):\n    \"\"\"\n    Arguments:\n\n        support: `Register` or number of qubits. If an integer is provided, a register is\n            constructed with `Register.all_to_all(x)`\n        *blocks: (Possibly multiple) blocks to construct the circuit from.\n    \"\"\"\n    self.block = chain(*blocks) if len(blocks) != 1 else blocks[0]\n    self.register = Register(support) if isinstance(support, int) else support\n\n    global_block = isinstance(self.block, AnalogBlock) and self.block.qubit_support.is_global\n    if not global_block and len(self.block) and self.block.n_qubits &gt; self.register.n_qubits:\n        raise ValueError(\n            f\"Register with {self.register.n_qubits} qubits is too small for the \"\n            f\"given block with {self.block.n_qubits} qubits\"\n        )\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.unique_parameters","title":"<code>unique_parameters: list[Parameter]</code>  <code>property</code>","text":"<p>Return the unique parameters in the circuit.</p> <p>These parameters are the actual user-facing parameters which can be assigned by the user. Multiple gates can contain the same unique parameter</p> RETURNS DESCRIPTION <code>list[Parameter]</code> <p>list[Parameter]: List of unique parameters in the circuit</p>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.dagger","title":"<code>dagger()</code>","text":"<p>Reverse the QuantumCircuit by calling dagger on the block.</p> Source code in <code>qadence/circuit.py</code> <pre><code>def dagger(self) -&gt; QuantumCircuit:\n    \"\"\"Reverse the QuantumCircuit by calling dagger on the block.\"\"\"\n    return QuantumCircuit(self.n_qubits, self.block.dagger())\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.get_blocks_by_tag","title":"<code>get_blocks_by_tag(tag)</code>","text":"<p>Extract one or more blocks using the human-readable tag.</p> <p>This function recursively explores all composite blocks to find all the occurrences of a certain tag in the blocks.</p> PARAMETER  DESCRIPTION <code>tag</code> <p>the tag to look for</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[AbstractBlock]</code> <p>list[AbstractBlock]: The block(s) corresponding to the given tag</p> Source code in <code>qadence/circuit.py</code> <pre><code>def get_blocks_by_tag(self, tag: str) -&gt; list[AbstractBlock]:\n    \"\"\"Extract one or more blocks using the human-readable tag.\n\n    This function recursively explores all composite blocks to find\n    all the occurrences of a certain tag in the blocks.\n\n    Args:\n        tag (str): the tag to look for\n\n    Returns:\n        list[AbstractBlock]: The block(s) corresponding to the given tag\n    \"\"\"\n\n    def _get_block(block: AbstractBlock) -&gt; list[AbstractBlock]:\n        blocks = []\n        if block.tag == tag:\n            blocks += [block]\n        if isinstance(block, CompositeBlock):\n            blocks += flatten(*[_get_block(b) for b in block.blocks])\n        return blocks\n\n    return _get_block(self.block)\n</code></pre>"},{"location":"qadence/quantumcircuit/#qadence.circuit.QuantumCircuit.parameters","title":"<code>parameters()</code>","text":"<p>Extract all parameters for primitive blocks in the circuit.</p> <p>Notice that this function returns all the unique Parameters used in the quantum circuit. These can correspond to constants too.</p> RETURNS DESCRIPTION <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>List[tuple[Parameter]]: A list of tuples containing the Parameter</p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>instance of each of the primitive blocks in the circuit or, if the <code>flatten</code></p> <code>list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]</code> <p>flag is set to True, a flattened list of all circuit parameters</p> Source code in <code>qadence/circuit.py</code> <pre><code>def parameters(self) -&gt; list[Parameter | Basic] | list[tuple[Parameter | Basic, ...]]:\n    \"\"\"Extract all parameters for primitive blocks in the circuit.\n\n    Notice that this function returns all the unique Parameters used\n    in the quantum circuit. These can correspond to constants too.\n\n    Returns:\n        List[tuple[Parameter]]: A list of tuples containing the Parameter\n        instance of each of the primitive blocks in the circuit or, if the `flatten`\n        flag is set to True, a flattened list of all circuit parameters\n    \"\"\"\n    return parameters(self.block)\n</code></pre>"},{"location":"qadence/register/","title":"Register","text":""},{"location":"qadence/register/#quantum-registers","title":"Quantum Registers","text":""},{"location":"qadence/register/#qadence.register.Register","title":"<code>Register(support, spacing=1.0, device_specs=DEFAULT_DEVICE)</code>","text":"<p>A 2D register of qubits which includes their coordinates.</p> <p>It is needed for e.g. analog computing. The coordinates are ignored in backends that don't need them. The easiest way to construct a register is via its classmethods like <code>Register.triangular_lattice</code>.</p> PARAMETER  DESCRIPTION <code>support</code> <p>A graph or number of qubits. Nodes can include a <code>\"pos\"</code> attribute such that e.g.: <code>graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}</code> which will be used in backends that need qubit coordinates. See the classmethods for simple construction of some predefined lattices if you don't want to build a graph manually. If you pass an integer the resulting register is the same as <code>Register.all_to_all(n_qubits)</code>.</p> <p> TYPE: <code>Graph | int</code> </p> <code>spacing</code> <p>Value set as the distance between the two closest qubits.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>1.0</code> </p> <p>Examples: <pre><code>from qadence import Register\n\nreg = Register.honeycomb_lattice(2,3)\nreg.draw()\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/register.py</code> <pre><code>def __init__(\n    self,\n    support: nx.Graph | int,\n    spacing: float | None = 1.0,\n    device_specs: RydbergDevice = DEFAULT_DEVICE,\n):\n    \"\"\"\n    A 2D register of qubits which includes their coordinates.\n\n    It is needed for e.g. analog computing.\n    The coordinates are ignored in backends that don't need them. The easiest\n    way to construct a register is via its classmethods like `Register.triangular_lattice`.\n\n    Arguments:\n        support: A graph or number of qubits. Nodes can include a `\"pos\"` attribute\n            such that e.g.: `graph.nodes = {0: {\"pos\": (2,3)}, 1: {\"pos\": (0,0)}, ...}` which\n            will be used in backends that need qubit coordinates.\n            See the classmethods for simple construction of some predefined lattices if you\n            don't want to build a graph manually.\n            If you pass an integer the resulting register is the same as\n            `Register.all_to_all(n_qubits)`.\n        spacing: Value set as the distance between the two closest qubits.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import Register\n\n    reg = Register.honeycomb_lattice(2,3)\n    reg.draw()\n    ```\n    \"\"\"\n    if device_specs is not None and not isinstance(device_specs, RydbergDevice):\n        raise ValueError(\"Device specs are not valid. Please pass a `RydbergDevice` instance.\")\n\n    self.device_specs = device_specs\n\n    self.graph = support if isinstance(support, nx.Graph) else alltoall_graph(support)\n\n    if spacing is not None and self.min_distance != 0.0:\n        _scale_node_positions(self.graph, self.min_distance, spacing)\n</code></pre>"},{"location":"qadence/register/#qadence.register.line_graph","title":"<code>line_graph(n_qubits)</code>","text":"<p>Create graph representing linear lattice.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>number of nodes in the graph</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Graph</code> <p>graph instance</p> Source code in <code>qadence/register.py</code> <pre><code>def line_graph(n_qubits: int) -&gt; nx.Graph:\n    \"\"\"Create graph representing linear lattice.\n\n    Args:\n        n_qubits (int): number of nodes in the graph\n\n    Returns:\n        graph instance\n    \"\"\"\n    graph = nx.Graph()\n    for i in range(n_qubits):\n        graph.add_node(i, pos=(i, 0.0))\n    for i, j in zip(range(n_qubits - 1), range(1, n_qubits)):\n        graph.add_edge(i, j)\n    return graph\n</code></pre>"},{"location":"qadence/serialization/","title":"Serialization","text":""},{"location":"qadence/serialization/#serialization","title":"Serialization","text":""},{"location":"qadence/serialization/#qadence.serialization.deserialize","title":"<code>deserialize(d, as_torch=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Deserializes a dict to one of the supported types.</p> PARAMETER  DESCRIPTION <code>d</code> <p>A dict containing a serialized object.</p> <p> TYPE: <code>dict</code> </p> <p>Returns:     AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a9d0c4cd-1389-4c59-98de-747140576ef9', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.6398639069137206'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('3895fe69-8e4a-4fbd-9e88-5352882b91e0', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.4276945815961849'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('9aaceea5-74e8-4a1d-b96d-d679982cfc91', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.8742892845567309'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('b4d00a4e-f545-406b-b716-58cefade8cbb', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.41919975377010965'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('2fd3be37-d1d6-42e2-a83b-01892011943a', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.6109177287180888'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('ddb175c0-0d4f-493a-9592-e1d59c43a2c5', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.37421788716051174'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def deserialize(d: dict, as_torch: bool = False) -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Deserializes a dict to one of the supported types.\n\n    Arguments:\n        d (dict): A dict containing a serialized object.\n    Returns:\n        AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register, Module.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    obj: Any\n    if d.get(\"expression\"):\n        expr = eval(d[\"expression\"])\n        if hasattr(expr, \"free_symbols\"):\n            for symb in expr.free_symbols:\n                symb.value = float(d[\"symbols\"][symb.name][\"value\"])\n        obj = expr\n    elif d.get(\"QuantumModel\"):\n        obj = QuantumModel._from_dict(d, as_torch)\n    elif d.get(\"QNN\"):\n        obj = QNN._from_dict(d, as_torch)\n    elif d.get(\"TransformedModule\"):\n        obj = TransformedModule._from_dict(d, as_torch)\n    elif d.get(\"block\") and d.get(\"register\"):\n        obj = QuantumCircuit._from_dict(d)\n    elif d.get(\"graph\"):\n        obj = Register._from_dict(d)\n    elif d.get(\"type\"):\n        if d[\"type\"] in ALL_BLOCK_NAMES:\n            block: AbstractBlock = (\n                getattr(operations, d[\"type\"])._from_dict(d)\n                if hasattr(operations, d[\"type\"])\n                else getattr(qadenceblocks, d[\"type\"])._from_dict(d)\n            )\n            if d[\"tag\"] is not None:\n                block = tag(block, d[\"tag\"])\n            obj = block\n    else:\n        import warnings\n\n        msg = warnings.warn(\n            \"In order to load a custom torch.nn.Module, make sure its imported in the namespace.\"\n        )\n        try:\n            module_name = list(d.keys())[0]\n            obj = getattr(globals(), module_name)\n            obj.load_state_dict(d[module_name])\n        except Exception as e:\n            logger.error(\n                TypeError(\n                    f\"{msg}. Unable to deserialize object due to {e}.\\\n                    Supported objects are: {SUPPORTED_OBJECTS}\"\n                )\n            )\n    return obj\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.load","title":"<code>load(file_path, map_location='cpu')</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register Loads a .json or .pt file to one of the supported types.</p> PARAMETER  DESCRIPTION <code>file_path</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> </p> <code>map_location</code> <p>In case of a .pt file, on which device to load the object (cpu,cuda).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'cpu'</code> </p> <p>Returns:     A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def load(file_path: str | Path, map_location: str = \"cpu\") -&gt; SUPPORTED_TYPES:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register\n    Loads a .json or .pt file to one of the supported types.\n\n    Arguments:\n        file_path (str): The name of the file.\n        map_location (str): In case of a .pt file, on which device to load the object (cpu,cuda).\n    Returns:\n        A object of type AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    d = {}\n    if isinstance(file_path, str):\n        file_path = Path(file_path)\n    if not os.path.exists(file_path):\n        logger.error(f\"File {file_path} not found.\")\n        raise FileNotFoundError\n    FORMAT = file_extension(file_path)\n    _, _, load_fn, _ = FORMAT_DICT[FORMAT]  # type: ignore[index]\n    try:\n        d = load_fn(file_path, map_location)\n        logger.debug(f\"Successfully loaded {d} from {file_path}.\")\n    except Exception as e:\n        logger.error(f\"Unable to load Object from {file_path} due to {e}\")\n    return deserialize(d)\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.save","title":"<code>save(obj, folder, file_name='', format=SerializationFormat.JSON)</code>","text":"<p>Same as serialize/deserialize but for storing/loading files.</p> <p>Supported types: AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module Saves a qadence object to a json/.pt.</p> PARAMETER  DESCRIPTION <code>obj</code> <pre><code>Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n</code></pre> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register</code> </p> <code>file_name</code> <p>The name of the file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>format</code> <p>The type of file to save.</p> <p> TYPE: <code>str</code> DEFAULT: <code>JSON</code> </p> <p>Returns:     None.</p> <p>Examples: <pre><code>import torch\nfrom pathlib import Path\nimport os\n\nfrom qadence import save, load, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nqc = QuantumCircuit(n_qubits, myblock)\n# Lets store the circuit in a json file\nsave(qc, '.', 'circ')\nloaded_qc = load(Path('circ.json'))\nqc == loaded_qc\nos.remove('circ.json')\n## Let's wrap it in a QuantumModel and store that\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\nsave(qm, folder= '.',file_name= 'quantum_model')\nqm_loaded = load('quantum_model.json')\nos.remove('quantum_model.json')\n</code></pre> <pre><code>\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def save(\n    obj: SUPPORTED_TYPES,\n    folder: str | Path,\n    file_name: str = \"\",\n    format: SerializationFormat = SerializationFormat.JSON,\n) -&gt; None:\n    \"\"\"\n    Same as serialize/deserialize but for storing/loading files.\n\n    Supported types:\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | torch.nn.Module\n    Saves a qadence object to a json/.pt.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register):\n                Either AbstractBlock, QuantumCircuit, QuantumModel, TransformedModule, Register.\n        file_name (str): The name of the file.\n        format (str): The type of file to save.\n    Returns:\n        None.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from pathlib import Path\n    import os\n\n    from qadence import save, load, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    qc = QuantumCircuit(n_qubits, myblock)\n    # Lets store the circuit in a json file\n    save(qc, '.', 'circ')\n    loaded_qc = load(Path('circ.json'))\n    qc == loaded_qc\n    os.remove('circ.json')\n    ## Let's wrap it in a QuantumModel and store that\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n    save(qm, folder= '.',file_name= 'quantum_model')\n    qm_loaded = load('quantum_model.json')\n    os.remove('quantum_model.json')\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(f\"Serialization of object type {type(obj)} not supported.\")\n    folder = Path(folder)\n    if not folder.is_dir():\n        logger.error(NotADirectoryError)\n    if file_name == \"\":\n        file_name = type(obj).__name__\n    try:\n        suffix, save_fn, _, save_params = FORMAT_DICT[format]\n        d = serialize(obj, save_params)\n        file_path = folder / Path(file_name + suffix)\n        save_fn(d, file_path)\n        logger.debug(f\"Successfully saved {obj} from to {folder}.\")\n    except Exception as e:\n        logger.error(f\"Unable to write {type(obj)} to disk due to {e}\")\n</code></pre>"},{"location":"qadence/serialization/#qadence.serialization.serialize","title":"<code>serialize(obj, save_params=False)</code>","text":"<p>Supported Types:</p> <p>AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module Serializes a qadence object to a dictionary.</p> PARAMETER  DESCRIPTION <code>obj</code> <p> TYPE: <code>AbstractBlock | QuantumCircuit | QuantumModel | Register | Module</code> </p> <p>Returns:     A dict.</p> <p>Examples: <pre><code>import torch\nfrom qadence import serialize, deserialize, hea, hamiltonian_factory, Z\nfrom qadence import QuantumCircuit, QuantumModel\n\nn_qubits = 2\nmyblock = hea(n_qubits=n_qubits, depth=1)\nblock_dict = serialize(myblock)\nprint(block_dict)\n\n## Lets use myblock in a QuantumCircuit and serialize it.\n\nqc = QuantumCircuit(n_qubits, myblock)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n## Finally, let's wrap it in a QuantumModel\nobs = hamiltonian_factory(n_qubits, detuning = Z)\nqm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n# Lets check if the loaded QuantumModel returns the same expectation\nassert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n</code></pre> <pre><code>{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': 'HEA', 'blocks': [{'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('f650d326-f7d1-4868-8807-58aa66e4baa4', {'name': 'theta_0', 'expression': \"Parameter('theta_0')\", 'symbols': {'theta_0': {'name': 'theta_0', 'trainable': 'True', 'value': '0.9806087614373826'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('e67b7c8c-9d62-4b2a-8a4a-5c663b6e4b73', {'name': 'theta_1', 'expression': \"Parameter('theta_1')\", 'symbols': {'theta_1': {'name': 'theta_1', 'trainable': 'True', 'value': '0.1191298453974663'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RY', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('6ff272e3-e25f-40cd-a77c-be48e3454828', {'name': 'theta_2', 'expression': \"Parameter('theta_2')\", 'symbols': {'theta_2': {'name': 'theta_2', 'trainable': 'True', 'value': '0.2908857259376022'}}})}}}, {'type': 'RY', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('0921ac78-e439-4faf-b487-2c91d42e9573', {'name': 'theta_3', 'expression': \"Parameter('theta_3')\", 'symbols': {'theta_3': {'name': 'theta_3', 'trainable': 'True', 'value': '0.43496561975352277'}}})}}}]}, {'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'RX', 'qubit_support': (0,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('a9792769-5799-440e-9c43-9d7af0fd9f55', {'name': 'theta_4', 'expression': \"Parameter('theta_4')\", 'symbols': {'theta_4': {'name': 'theta_4', 'trainable': 'True', 'value': '0.13952221070351867'}}})}}}, {'type': 'RX', 'qubit_support': (1,), 'tag': None, 'parameters': {'_name_dict': {'parameter': ('179a985f-ebb3-4e26-9e21-a6869f2bd6d8', {'name': 'theta_5', 'expression': \"Parameter('theta_5')\", 'symbols': {'theta_5': {'name': 'theta_5', 'trainable': 'True', 'value': '0.230873635340905'}}})}}}]}]}, {'type': 'ChainBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'KronBlock', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'CNOT', 'qubit_support': (0, 1), 'tag': None, 'blocks': [{'type': 'X', 'qubit_support': (1,), 'tag': None}]}]}]}]}\n</code></pre> </p> Source code in <code>qadence/serialization.py</code> <pre><code>def serialize(obj: SUPPORTED_TYPES, save_params: bool = False) -&gt; dict:\n    \"\"\"\n    Supported Types:\n\n    AbstractBlock | QuantumCircuit | QuantumModel | TransformedModule | Register | Module\n    Serializes a qadence object to a dictionary.\n\n    Arguments:\n        obj (AbstractBlock | QuantumCircuit | QuantumModel | Register | Module):\n    Returns:\n        A dict.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    import torch\n    from qadence import serialize, deserialize, hea, hamiltonian_factory, Z\n    from qadence import QuantumCircuit, QuantumModel\n\n    n_qubits = 2\n    myblock = hea(n_qubits=n_qubits, depth=1)\n    block_dict = serialize(myblock)\n    print(block_dict)\n\n    ## Lets use myblock in a QuantumCircuit and serialize it.\n\n    qc = QuantumCircuit(n_qubits, myblock)\n    qc_dict = serialize(qc)\n    qc_deserialized = deserialize(qc_dict)\n    assert qc == qc_deserialized\n\n    ## Finally, let's wrap it in a QuantumModel\n    obs = hamiltonian_factory(n_qubits, detuning = Z)\n    qm = QuantumModel(qc, obs, backend='pyqtorch', diff_mode='ad')\n\n    qm_dict = serialize(qm)\n    qm_deserialized = deserialize(qm_dict)\n    # Lets check if the loaded QuantumModel returns the same expectation\n    assert torch.isclose(qm.expectation({}), qm_deserialized.expectation({}))\n    ```\n    \"\"\"\n    if not isinstance(obj, get_args(SUPPORTED_TYPES)):\n        logger.error(TypeError(f\"Serialization of object type {type(obj)} not supported.\"))\n    d: dict = {}\n    try:\n        if isinstance(obj, Expr):\n            symb_dict = {}\n            expr_dict = {\"name\": str(obj), \"expression\": srepr(obj)}\n            symbs: set[Parameter | Basic] = obj.free_symbols\n            if symbs:\n                symb_dict = {\"symbols\": {str(s): s._to_dict() for s in symbs}}\n            d = {**expr_dict, **symb_dict}\n        elif isinstance(obj, (QuantumModel, QNN, TransformedModule)):\n            d = obj._to_dict(save_params)\n        elif isinstance(obj, torch.nn.Module):\n            d = {type(obj).__name__: obj.state_dict()}\n        else:\n            d = obj._to_dict()\n    except Exception as e:\n        logger.error(f\"Serialization of object {obj} failed due to {e}\")\n    return d\n</code></pre>"},{"location":"qadence/states/","title":"State preparation","text":""},{"location":"qadence/states/#state-preparation-routines","title":"State Preparation Routines","text":""},{"location":"qadence/states/#qadence.states.ghz_block","title":"<code>ghz_block(n_qubits)</code>","text":"<p>Generates the abstract ghz state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ChainBlock</code> <p>A ChainBlock representing the GHZ state.</p> <p>Examples: <pre><code>from qadence.states import ghz_block\n\nblock = ghz_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_block(n_qubits: int) -&gt; ChainBlock:\n    \"\"\"\n    Generates the abstract ghz state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A ChainBlock representing the GHZ state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_block\n\n    block = ghz_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    cnots = chain(CNOT(i - 1, i) for i in range(1, n_qubits))\n    return chain(H(0), cnots)\n</code></pre>"},{"location":"qadence/states/#qadence.states.ghz_state","title":"<code>ghz_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a GHZ state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import ghz_state\n\nprint(ghz_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.7071+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def ghz_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a GHZ state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import ghz_state\n\n    print(ghz_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2))\n    return norm * (zero_state(n_qubits, batch_size) + one_state(n_qubits, batch_size))\n</code></pre>"},{"location":"qadence/states/#qadence.states.is_normalized","title":"<code>is_normalized(wf, atol=NORMALIZATION_ATOL)</code>","text":"<p>Checks if a wave function is normalized.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> <code>atol</code> <p>The tolerance.</p> <p> TYPE: <code>float) </code> DEFAULT: <code>NORMALIZATION_ATOL</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>A bool.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, is_normalized\n\nprint(is_normalized(uniform_state(2)))\n</code></pre> <pre><code>True\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def is_normalized(wf: Tensor, atol: float = NORMALIZATION_ATOL) -&gt; bool:\n    \"\"\"\n    Checks if a wave function is normalized.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n        atol (float) : The tolerance.\n\n    Returns:\n        A bool.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, is_normalized\n\n    print(is_normalized(uniform_state(2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        wf = wf.unsqueeze(0)\n    sum_probs: Tensor = (wf.abs() ** 2).sum(dim=1)\n    ones = torch.ones_like(sum_probs)\n    return torch.allclose(sum_probs, ones, rtol=0.0, atol=atol)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"qadence/states/#qadence.states.normalize","title":"<code>normalize(wf)</code>","text":"<p>Normalizes a wavefunction or batch of wave functions.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>Normalized wavefunctions.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, normalize\n\nprint(normalize(uniform_state(2, 2)))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j],\n        [0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def normalize(wf: Tensor) -&gt; Tensor:\n    \"\"\"\n    Normalizes a wavefunction or batch of wave functions.\n\n    Arguments:\n        wf (torch.Tensor): Normalized wavefunctions.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, normalize\n\n    print(normalize(uniform_state(2, 2)))\n    ```\n    \"\"\"\n    if wf.dim() == 1:\n        return wf / torch.sqrt((wf.abs() ** 2).sum())\n    else:\n        return wf / torch.sqrt((wf.abs() ** 2).sum(1)).unsqueeze(1)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_block","title":"<code>one_block(n_qubits)</code>","text":"<p>Generates the abstract one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the one state.</p> <p>Examples: <pre><code>from qadence.states import one_block\n\nblock = one_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the one state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_block\n\n    block = one_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(X, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.one_state","title":"<code>one_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the one state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import one_state\n\nstate = one_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def one_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the one state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import one_state\n\n    state = one_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"1\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/states/#qadence.states.pmf","title":"<code>pmf(wf)</code>","text":"<p>Converts a wave function into a torch Distribution.</p> PARAMETER  DESCRIPTION <code>wf</code> <p>The wave function as a torch tensor.</p> <p> TYPE: <code>Tensor</code> </p> RETURNS DESCRIPTION <code>Distribution</code> <p>A torch.distributions.Distribution.</p> <p>Examples: <pre><code>from qadence.states import uniform_state, pmf\n\nprint(pmf(uniform_state(2)).probs)\n</code></pre> <pre><code>tensor([[0.2500, 0.2500, 0.2500, 0.2500]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def pmf(wf: Tensor) -&gt; Distribution:\n    \"\"\"\n    Converts a wave function into a torch Distribution.\n\n    Arguments:\n        wf (torch.Tensor): The wave function as a torch tensor.\n\n    Returns:\n        A torch.distributions.Distribution.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state, pmf\n\n    print(pmf(uniform_state(2)).probs)\n    ```\n    \"\"\"\n    return Categorical(torch.abs(torch.pow(wf, 2)))\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_block","title":"<code>product_block(bitstring)</code>","text":"<p>Creates an abstract product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import product_block\n\nprint(product_block(\"1100\"))\n</code></pre> <pre><code>KronBlock(0,1,2,3)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u251c\u2500\u2500 I(2)\n\u2514\u2500\u2500 I(3)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def product_block(bitstring: str) -&gt; KronBlock:\n    \"\"\"\n    Creates an abstract product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_block\n\n    print(product_block(\"1100\"))\n    ```\n    \"\"\"\n    return _block_from_bitstring(bitstring)\n</code></pre>"},{"location":"qadence/states/#qadence.states.product_state","title":"<code>product_state(bitstring, batch_size=1, endianness=Endianness.BIG)</code>","text":"<p>Creates a product state from a bitstring.</p> PARAMETER  DESCRIPTION <code>bitstring</code> <p>A bitstring.</p> <p> TYPE: <code>str</code> </p> <code>batch_size</code> <p>Batch size.</p> <p> TYPE: <code>int) </code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import product_state\n\nprint(product_state(\"1100\"))\n</code></pre> <pre><code>tensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>@singledispatch\ndef product_state(\n    bitstring: str, batch_size: int = 1, endianness: Endianness = Endianness.BIG\n) -&gt; Tensor:\n    \"\"\"\n    Creates a product state from a bitstring.\n\n    Arguments:\n        bitstring (str): A bitstring.\n        batch_size (int) : Batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import product_state\n\n    print(product_state(\"1100\"))\n    ```\n    \"\"\"\n    return _state_from_bitstring(bitstring, batch_size, endianness=endianness)\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_bitstring","title":"<code>rand_bitstring(N)</code>","text":"<p>Creates a random bistring.</p> PARAMETER  DESCRIPTION <code>N</code> <p>The length of the bitstring.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string.</p> <p>Examples: <pre><code>from qadence.states import rand_bitstring\n\nprint(rand_bitstring(N=8))\n</code></pre> <pre><code>00110011\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_bitstring(N: int) -&gt; str:\n    \"\"\"\n    Creates a random bistring.\n\n    Arguments:\n        N (int): The length of the bitstring.\n\n    Returns:\n        A string.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_bitstring\n\n    print(rand_bitstring(N=8))\n    ```\n    \"\"\"\n    return \"\".join(str(random.randint(0, 1)) for _ in range(N))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_block","title":"<code>rand_product_block(n_qubits)</code>","text":"<p>Creates a block representing a random abstract product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the product state.</p> <p>Examples: <pre><code>from qadence.states import rand_product_block\n\nprint(rand_product_block(n_qubits=2))\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Creates a block representing a random abstract product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the product state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_block\n\n    print(rand_product_block(n_qubits=2))\n    ```\n    \"\"\"\n    return product_block(rand_bitstring(n_qubits))\n</code></pre>"},{"location":"qadence/states/#qadence.states.rand_product_state","title":"<code>rand_product_state(n_qubits, batch_size=1)</code>","text":"<p>Creates a random product state.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>How many bitstrings to use.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import rand_product_state\n\nprint(rand_product_state(n_qubits=2, batch_size=2))\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def rand_product_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Creates a random product state.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): How many bitstrings to use.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import rand_product_state\n\n    print(rand_product_state(n_qubits=2, batch_size=2))\n    ```\n    \"\"\"\n    wf_batch = torch.zeros(batch_size, 2**n_qubits, dtype=DTYPE)\n    rand_pos = torch.randint(0, 2**n_qubits, (batch_size,))\n    wf_batch[torch.arange(batch_size), rand_pos] = torch.tensor(1.0 + 0j, dtype=DTYPE)\n    return wf_batch\n</code></pre>"},{"location":"qadence/states/#qadence.states.random_state","title":"<code>random_state(n_qubits, batch_size=1, backend=BackendName.PYQTORCH, type=StateGeneratorType.HAAR_MEASURE_FAST)</code>","text":"<p>Generates a random state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>backend</code> <p>The backend to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>PYQTORCH</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>type</code> <p>StateGeneratorType.</p> <p> DEFAULT: <code>HAAR_MEASURE_FAST</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import random_state, StateGeneratorType\nfrom qadence.states import random_state, is_normalized, pmf\nfrom qadence.types import BackendName\nfrom torch.distributions import Distribution\n\n### We have the following options:\nprint([g.value for g in StateGeneratorType])\n\nn_qubits = 2\n# The default is StateGeneratorType.HAAR_MEASURE_FAST\nstate = random_state(n_qubits=n_qubits)\nprint(state)\n\n### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\nrandom = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\nprint(random)\n</code></pre> <pre><code>['RandomRotations', 'HaarMeasureFast', 'HaarMeasureSlow']\ntensor([[ 0.3881-0.1329j,  0.2745-0.3881j, -0.2080+0.2140j,  0.6633-0.2767j]])\ntensor([[0.5137+0.6312j, 0.3668+0.4508j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def random_state(\n    n_qubits: int,\n    batch_size: int = 1,\n    backend: str = BackendName.PYQTORCH,\n    type: StateGeneratorType = StateGeneratorType.HAAR_MEASURE_FAST,\n) -&gt; Tensor:\n    \"\"\"\n    Generates a random state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        backend (str): The backend to use.\n        batch_size (int): The batch size.\n        type : StateGeneratorType.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import random_state, StateGeneratorType\n    from qadence.states import random_state, is_normalized, pmf\n    from qadence.types import BackendName\n    from torch.distributions import Distribution\n\n    ### We have the following options:\n    print([g.value for g in StateGeneratorType])\n\n    n_qubits = 2\n    # The default is StateGeneratorType.HAAR_MEASURE_FAST\n    state = random_state(n_qubits=n_qubits)\n    print(state)\n\n    ### Lets initialize a state using random rotations, i.e., StateGeneratorType.RANDOM_ROTATIONS.\n    random = random_state(n_qubits=n_qubits, type=StateGeneratorType.RANDOM_ROTATIONS)\n    print(random)\n    ```\n    \"\"\"\n\n    if type == StateGeneratorType.HAAR_MEASURE_FAST:\n        state = concat(tuple(_rand_haar_fast(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.HAAR_MEASURE_SLOW:\n        state = concat(tuple(_rand_haar_slow(n_qubits) for _ in range(batch_size)), dim=0)\n    elif type == StateGeneratorType.RANDOM_ROTATIONS:\n        state = run(_abstract_random_state(n_qubits, batch_size))  # type: ignore\n    assert all(list(map(is_normalized, state)))\n    return state\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_block","title":"<code>uniform_block(n_qubits)</code>","text":"<p>Generates the abstract uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the uniform state.</p> <p>Examples: <pre><code>from qadence.states import uniform_block\n\nblock = uniform_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the uniform state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_block\n\n    block = uniform_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(H, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.uniform_state","title":"<code>uniform_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the uniform state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import uniform_state\n\nstate = uniform_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def uniform_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the uniform state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n        batch_size (int): The batch size.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import uniform_state\n\n    state = uniform_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    norm = 1 / torch.sqrt(torch.tensor(2**n_qubits))\n    return norm * torch.ones(batch_size, 2**n_qubits, dtype=DTYPE)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_block","title":"<code>zero_block(n_qubits)</code>","text":"<p>Generates the abstract zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>KronBlock</code> <p>A KronBlock representing the zero state.</p> <p>Examples: <pre><code>from qadence.states import zero_block\n\nblock = zero_block(n_qubits=2)\nprint(block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 I(0)\n\u2514\u2500\u2500 I(1)\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_block(n_qubits: int) -&gt; KronBlock:\n    \"\"\"\n    Generates the abstract zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits.\n\n    Returns:\n        A KronBlock representing the zero state.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_block\n\n    block = zero_block(n_qubits=2)\n    print(block)\n    ```\n    \"\"\"\n    return _from_op(I, n_qubits=n_qubits)\n</code></pre>"},{"location":"qadence/states/#qadence.states.zero_state","title":"<code>zero_state(n_qubits, batch_size=1)</code>","text":"<p>Generates the zero state for a specified number of qubits.</p> PARAMETER  DESCRIPTION <code>n_qubits</code> <p>The number of qubits for which the zero state is to be generated.</p> <p> TYPE: <code>int</code> </p> <code>batch_size</code> <p>The batch size for the zero state.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>Tensor</code> <p>A torch.Tensor.</p> <p>Examples: <pre><code>from qadence.states import zero_state\n\nstate = zero_state(n_qubits=2)\nprint(state)\n</code></pre> <pre><code>tensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> </p> Source code in <code>qadence/states.py</code> <pre><code>def zero_state(n_qubits: int, batch_size: int = 1) -&gt; Tensor:\n    \"\"\"\n    Generates the zero state for a specified number of qubits.\n\n    Arguments:\n        n_qubits (int): The number of qubits for which the zero state is to be generated.\n        batch_size (int): The batch size for the zero state.\n\n    Returns:\n        A torch.Tensor.\n\n    Examples:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence.states import zero_state\n\n    state = zero_state(n_qubits=2)\n    print(state)\n    ```\n    \"\"\"\n    bitstring = \"0\" * n_qubits\n    return _state_from_bitstring(bitstring, batch_size)\n</code></pre>"},{"location":"qadence/transpile/","title":"Transpilation","text":"<p>Contains functions that operate on blocks and circuits to <code>transpile</code> them to new blocks/circuits.</p>"},{"location":"qadence/transpile/#qadence.transpile.transpile.transpile","title":"<code>transpile(*fs)</code>","text":"<p><code>AbstractBlock</code> or <code>QuantumCircuit</code> transpilation.</p> <p>Compose functions that accept a circuit/block and returns a circuit/block.</p> PARAMETER  DESCRIPTION <code>*fs</code> <p>composable functions that either map blocks to blocks (<code>Callable[[AbstractBlock], AbstractBlock]</code>) or circuits to circuits (<code>Callable[[QuantumCircuit], QuantumCircuit]</code>).</p> <p> TYPE: <code>Callable</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>Composed function.</p> <p>Examples:</p> <p>Flatten a block of nested chains and krons: <pre><code>from qadence import *\nfrom qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\nb = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\nprint(b)\n\n# both flatten and scale_primitive_blocks_only are functions that accept and\n# return a block\nt = transpile(flatten, scale_primitive_blocks_only)(b)\nprint(t)\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2] \n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 ChainBlock(0)\n\u2502           \u251c\u2500\u2500 X(0)\n\u2502           \u2514\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u251c\u2500\u2500 X(0)\n        \u2514\u2500\u2500 X(1)\n\nChainBlock(0,1)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u251c\u2500\u2500 Y(0)\n\u2514\u2500\u2500 KronBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> <p>We also proved a decorator to easily turn a function <code>Callable[[AbstractBlock], AbstractBlock]</code> into a <code>Callable[[QuantumCircuit], QuantumCircuit]</code> to be used in circuit transpilation. <pre><code>from qadence import *\nfrom qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n# We want to pass this circuit to `transpile` instead of a block,\n# so we need functions that map from a circuit to a circuit.\ncirc = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n@blockfn_to_circfn\ndef fn(block):\n    # un-decorated function accepts a block and returns a block\n    return block * block\n\ntransp = transpile(\n    # the decorated function accepts a circuit and returns a circuit\n    fn,\n    # already existing functions can also be decorated\n    blockfn_to_circfn(flatten)\n)\nprint(transp(circ))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 X(0)\n\u2502   \u2514\u2500\u2500 X(1)\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 X(1)\n</code></pre> </p> Source code in <code>qadence/transpile/transpile.py</code> <pre><code>def transpile(*fs: Callable) -&gt; Callable:\n    \"\"\"`AbstractBlock` or `QuantumCircuit` transpilation.\n\n    Compose functions that\n    accept a circuit/block and returns a circuit/block.\n\n    Arguments:\n        *fs: composable functions that either map blocks to blocks\n            (`Callable[[AbstractBlock], AbstractBlock]`)\n            or circuits to circuits (`Callable[[QuantumCircuit], QuantumCircuit]`).\n\n    Returns:\n        Composed function.\n\n    Examples:\n\n    Flatten a block of nested chains and krons:\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, flatten, scale_primitive_blocks_only\n\n    b = chain(2 * chain(chain(X(0), Y(0))), kron(kron(X(0), X(1))))\n    print(b)\n    print() # markdown-exec: hide\n\n    # both flatten and scale_primitive_blocks_only are functions that accept and\n    # return a block\n    t = transpile(flatten, scale_primitive_blocks_only)(b)\n    print(t)\n    ```\n\n    We also proved a decorator to easily turn a function `Callable[[AbstractBlock], AbstractBlock]`\n    into a `Callable[[QuantumCircuit], QuantumCircuit]` to be used in circuit transpilation.\n    ```python exec=\"on\" source=\"material-block\" result=\"json\"\n    from qadence import *\n    from qadence.transpile import transpile, blockfn_to_circfn, flatten\n\n    # We want to pass this circuit to `transpile` instead of a block,\n    # so we need functions that map from a circuit to a circuit.\n    circ = QuantumCircuit(2, chain(chain(X(0), chain(X(1)))))\n\n    @blockfn_to_circfn\n    def fn(block):\n        # un-decorated function accepts a block and returns a block\n        return block * block\n\n    transp = transpile(\n        # the decorated function accepts a circuit and returns a circuit\n        fn,\n        # already existing functions can also be decorated\n        blockfn_to_circfn(flatten)\n    )\n    print(transp(circ))\n    ```\n    \"\"\"\n    return lambda x: reduce(lambda acc, f: f(acc), reversed(fs), x)\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.chain_single_qubit_ops","title":"<code>chain_single_qubit_ops(block)</code>","text":"<p>Transpile a chain of krons into a kron of chains of single qubit operations.</p> <p>Examples: <pre><code>from qadence import hea\nfrom qadence.transpile.block import chain_single_qubit_ops\n\n# Consider a single HEA layer\nblock = hea(2,1)\nprint(block)\n\n# After applying chain_single_qubit_ops, we get:\nprint(chain_single_qubit_ops(block))\n</code></pre> <pre><code>ChainBlock(0,1) [tag: HEA]\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502   \u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\nChainBlock(0,1)\n\u251c\u2500\u2500 KronBlock(0,1)\n\u2502   \u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n\u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_2']]\n\u2502   \u2502   \u2514\u2500\u2500 RX(0) [params: ['theta_4']]\n\u2502   \u2514\u2500\u2500 ChainBlock(1)\n\u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n\u2502       \u251c\u2500\u2500 RY(1) [params: ['theta_3']]\n\u2502       \u2514\u2500\u2500 RX(1) [params: ['theta_5']]\n\u2514\u2500\u2500 ChainBlock(0,1)\n    \u2514\u2500\u2500 KronBlock(0,1)\n        \u2514\u2500\u2500 CNOT(0, 1)\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def chain_single_qubit_ops(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Transpile a chain of krons into a kron of chains of single qubit operations.\n\n    Examples:\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import hea\n    from qadence.transpile.block import chain_single_qubit_ops\n\n    # Consider a single HEA layer\n    block = hea(2,1)\n    print(block)\n\n    # After applying chain_single_qubit_ops, we get:\n    print(chain_single_qubit_ops(block))\n    ```\n    \"\"\"\n    if is_chain_of_primitivekrons(block):\n        try:\n            return kron(*map(lambda bs: chain(*bs), zip(*block)))  # type: ignore[misc]\n        except Exception as e:\n            logger.debug(\n                f\"Unable to transpile {block} using chain_single_qubit_ops\\\n                         due to {e}. Returning original circuit.\"\n            )\n            return block\n\n    elif isinstance(block, CompositeBlock):\n        return _construct(type(block), tuple(chain_single_qubit_ops(b) for b in block.blocks))\n    else:\n        return block\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.scale_primitive_blocks_only","title":"<code>scale_primitive_blocks_only(block, scale=None)</code>","text":"<p>Push the scale all the way down into the leaves of the block tree.</p> <p>When given a scaled CompositeBlock consisting of several PrimitiveBlocks.</p> PARAMETER  DESCRIPTION <code>block</code> <p>The block to be transpiled.</p> <p> TYPE: <code>AbstractBlock</code> </p> <code>scale</code> <p>An optional scale parameter. Only to be used for recursive calls internally.</p> <p> TYPE: <code>Basic</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AbstractBlock</code> <p>A block of the same type where the scales have been moved into the subblocks.</p> <p> TYPE: <code>AbstractBlock</code> </p> <p>Examples:</p> <p>There are two different cases: <code>ChainBlock</code>s/<code>KronBlock</code>s: Only the first subblock needs to be scaled because chains/krons represent multiplications. <pre><code>from qadence import chain, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * chain(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 ChainBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nChainBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> <p><code>AddBlock</code>s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")). <pre><code>from qadence import add, X, RX\nfrom qadence.transpile import scale_primitive_blocks_only\nb = 2 * add(X(0), RX(0, \"theta\"))\nprint(b)\n# After applying scale_primitive_blocks_only\nprint(scale_primitive_blocks_only(b))\n</code></pre> <pre><code>[mul: 2] \n\u2514\u2500\u2500 AddBlock(0)\n    \u251c\u2500\u2500 X(0)\n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\nAddBlock(0)\n\u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 [mul: 2.00000000000000] \n    \u2514\u2500\u2500 RX(0) [params: ['theta']]\n</code></pre></p> Source code in <code>qadence/transpile/block.py</code> <pre><code>@singledispatch\ndef scale_primitive_blocks_only(block: AbstractBlock, scale: sympy.Basic = None) -&gt; AbstractBlock:\n    \"\"\"Push the scale all the way down into the leaves of the block tree.\n\n    When given a scaled CompositeBlock consisting of several PrimitiveBlocks.\n\n    Arguments:\n        block: The block to be transpiled.\n        scale: An optional scale parameter. Only to be used for recursive calls internally.\n\n    Returns:\n        AbstractBlock: A block of the same type where the scales have been moved into the subblocks.\n\n    Examples:\n\n    There are two different cases:\n    `ChainBlock`s/`KronBlock`s: Only the first subblock needs to be scaled because chains/krons\n    represent multiplications.\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import chain, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * chain(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n\n    `AddBlock`s: Consider 2 * add(X(0), RX(0, \"theta\")).  The scale needs to be added to all\n    subblocks.  We get add(2 * X(0), 2 * RX(0, \"theta\")).\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence import add, X, RX\n    from qadence.transpile import scale_primitive_blocks_only\n    b = 2 * add(X(0), RX(0, \"theta\"))\n    print(b)\n    # After applying scale_primitive_blocks_only\n    print(scale_primitive_blocks_only(b))\n    ```\n    \"\"\"\n    raise NotImplementedError(f\"scale_primitive_blocks_only is not implemented for {type(block)}\")\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.set_trainable","title":"<code>set_trainable(blocks, value=True, inplace=True)</code>","text":"<p>Set the trainability of all parameters in a block to a given value.</p> PARAMETER  DESCRIPTION <code>blocks</code> <p>Block or list of blocks for which to set the trainable attribute</p> <p> TYPE: <code>AbstractBlock | list[AbstractBlock]</code> </p> <code>value</code> <p>The value of the trainable attribute to assign to the input blocks</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the block(s) in place or not. Currently, only</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the <code>inplace</code> argument is set to False, the function will raise  this exception</p> RETURNS DESCRIPTION <code>AbstractBlock | list[AbstractBlock]</code> <p>AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable attribute set to the given value</p> Source code in <code>qadence/transpile/block.py</code> <pre><code>def set_trainable(\n    blocks: AbstractBlock | list[AbstractBlock], value: bool = True, inplace: bool = True\n) -&gt; AbstractBlock | list[AbstractBlock]:\n    \"\"\"Set the trainability of all parameters in a block to a given value.\n\n    Args:\n        blocks (AbstractBlock | list[AbstractBlock]): Block or list of blocks for which\n            to set the trainable attribute\n        value (bool, optional): The value of the trainable attribute to assign to the input blocks\n        inplace (bool, optional): Whether to modify the block(s) in place or not. Currently, only\n\n    Raises:\n        NotImplementedError: if the `inplace` argument is set to False, the function will\n            raise  this exception\n\n    Returns:\n        AbstractBlock | list[AbstractBlock]: the input block or list of blocks with the trainable\n            attribute set to the given value\n    \"\"\"\n\n    if isinstance(blocks, AbstractBlock):\n        blocks = [blocks]\n\n    if inplace:\n        for block in blocks:\n            params: list[sympy.Basic] = parameters(block)\n            for p in params:\n                if not p.is_number:\n                    p.trainable = value\n    else:\n        raise NotImplementedError(\"Not inplace set_trainable is not yet available\")\n\n    return blocks if len(blocks) &gt; 1 else blocks[0]\n</code></pre>"},{"location":"qadence/transpile/#qadence.transpile.block.validate","title":"<code>validate(block)</code>","text":"<p>Moves a block from global to local qubit numbers by adding PutBlocks.</p> <p>Reassigns qubit locations appropriately.</p>"},{"location":"qadence/transpile/#qadence.transpile.block.validate--example","title":"Example","text":"<pre><code>from qadence.blocks import chain\nfrom qadence.operations import X\nfrom qadence.transpile import validate\n\nx = chain(chain(X(0)), chain(X(1)))\nprint(x)\nprint(validate(x))\n</code></pre> <pre><code>ChainBlock(0,1)\n\u251c\u2500\u2500 ChainBlock(0)\n\u2502   \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 ChainBlock(1)\n    \u2514\u2500\u2500 X(1)\nChainBlock(0,1)\n\u251c\u2500\u2500 put on (0)\n\u2502   \u2514\u2500\u2500 ChainBlock(0)\n\u2502       \u2514\u2500\u2500 put on (0)\n\u2502           \u2514\u2500\u2500 X(0)\n\u2514\u2500\u2500 put on (1)\n    \u2514\u2500\u2500 ChainBlock(0)\n        \u2514\u2500\u2500 put on (0)\n            \u2514\u2500\u2500 X(0)\n</code></pre> Source code in <code>qadence/transpile/block.py</code> <pre><code>def validate(block: AbstractBlock) -&gt; AbstractBlock:\n    \"\"\"Moves a block from global to local qubit numbers by adding PutBlocks.\n\n    Reassigns qubit locations appropriately.\n\n    # Example\n    ```python exec=\"on\" source=\"above\" result=\"json\"\n    from qadence.blocks import chain\n    from qadence.operations import X\n    from qadence.transpile import validate\n\n    x = chain(chain(X(0)), chain(X(1)))\n    print(x)\n    print(validate(x))\n    ```\n    \"\"\"\n    vblock: AbstractBlock\n    from qadence.transpile import reassign\n\n    if isinstance(block, ControlBlock):\n        vblock = deepcopy(block)\n        b: AbstractBlock\n        (b,) = block.blocks\n        b = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n        b = validate(b)\n        vblock.blocks = (b,)  # type: ignore[assignment]\n\n    elif isinstance(block, CompositeBlock):\n        blocks = []\n        for b in block.blocks:\n            mi, ma = min(b.qubit_support), max(b.qubit_support)\n            nb = reassign(b, {i: i - min(b.qubit_support) for i in b.qubit_support})\n            nb = validate(nb)\n            nb = PutBlock(nb, tuple(range(mi, ma + 1)))\n            blocks.append(nb)\n        try:\n            vblock = _construct(type(block), tuple(blocks))\n        except AssertionError as e:\n            if str(e) == \"Make sure blocks act on distinct qubits!\":\n                vblock = chain(*blocks)\n            else:\n                raise e\n\n    elif isinstance(block, PrimitiveBlock):\n        vblock = deepcopy(block)\n\n    else:\n        raise NotImplementedError\n\n    vblock.tag = block.tag\n    return vblock\n</code></pre>"},{"location":"qadence/types/","title":"Types","text":""},{"location":"qadence/types/#qadence-types","title":"Qadence Types","text":""},{"location":"qadence/types/#qadence.types.TArray","title":"<code>TArray = Union[Iterable, Tensor, np.ndarray]</code>  <code>module-attribute</code>","text":"<p>Union of common array types.</p>"},{"location":"qadence/types/#qadence.types.TGenerator","title":"<code>TGenerator = Union[Tensor, sympy.Array, sympy.Basic]</code>  <code>module-attribute</code>","text":"<p>Union of torch tensors and numpy arrays.</p>"},{"location":"qadence/types/#qadence.types.TNumber","title":"<code>TNumber = Union[int, float, complex]</code>  <code>module-attribute</code>","text":"<p>Union of python number types.</p>"},{"location":"qadence/types/#qadence.types.TParameter","title":"<code>TParameter = Union[TNumber, Tensor, sympy.Basic, str]</code>  <code>module-attribute</code>","text":"<p>Union of numbers, tensors, and parameter types.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo","title":"<code>AlgoHEvo</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Hamiltonian Evolution algorithms that can be used by the backend.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EIG","title":"<code>EIG = 'EIG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using Hamiltonian diagonalization.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.EXP","title":"<code>EXP = 'EXP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Using torch.matrix_exp on the generator matrix.</p>"},{"location":"qadence/types/#qadence.types.AlgoHEvo.RK4","title":"<code>RK4 = 'RK4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>4th order Runge-Kutta approximation.</p>"},{"location":"qadence/types/#qadence.types.BasisSet","title":"<code>BasisSet</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Basis set for feature maps.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.CHEBYSHEV","title":"<code>CHEBYSHEV = 'Chebyshev'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chebyshev polynomials of the first kind.</p>"},{"location":"qadence/types/#qadence.types.BasisSet.FOURIER","title":"<code>FOURIER = 'Fourier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fourier basis set.</p>"},{"location":"qadence/types/#qadence.types.DeviceType","title":"<code>DeviceType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Supported types of devices for Pulser backend.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.IDEALIZED","title":"<code>IDEALIZED = 'IdealDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Idealized device, least realistic.</p>"},{"location":"qadence/types/#qadence.types.DeviceType.REALISTIC","title":"<code>REALISTIC = 'RealisticDevice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Device with realistic specs.</p>"},{"location":"qadence/types/#qadence.types.Endianness","title":"<code>Endianness</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The endianness convention to use.</p>"},{"location":"qadence/types/#qadence.types.Endianness.BIG","title":"<code>BIG = 'Big'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use Big endianness.</p>"},{"location":"qadence/types/#qadence.types.Endianness.LITTLE","title":"<code>LITTLE = 'Little'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use little endianness.</p>"},{"location":"qadence/types/#qadence.types.FigFormat","title":"<code>FigFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available output formats for exporting visualized circuits to a file.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PDF","title":"<code>PDF = 'PDF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PDF format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.PNG","title":"<code>PNG = 'PNG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>PNG format.</p>"},{"location":"qadence/types/#qadence.types.FigFormat.SVG","title":"<code>SVG = 'SVG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SVG format.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC","title":"<code>GenDAQC</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>The type of interaction for the DAQC transform.</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN</p>"},{"location":"qadence/types/#qadence.types.GenDAQC.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ</p>"},{"location":"qadence/types/#qadence.types.Interaction","title":"<code>Interaction</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Interaction types used in.</p> <ul> <li><code>RydbergDevice</code>.</li> <li><code>hamiltonian_factory</code>.</li> </ul>"},{"location":"qadence/types/#qadence.types.Interaction.NN","title":"<code>NN = 'NN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NN-Ising Interaction, N=(I-Z)/2.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XY","title":"<code>XY = 'XY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XY Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.XYZ","title":"<code>XYZ = 'XYZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>XYZ Interaction.</p>"},{"location":"qadence/types/#qadence.types.Interaction.ZZ","title":"<code>ZZ = 'ZZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ZZ-Ising Interaction.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder","title":"<code>LTSOrder</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lie-Trotter-Suzuki approximation order.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.BASIC","title":"<code>BASIC = 'BASIC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Basic.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST2","title":"<code>ST2 = 'ST2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST2.</p>"},{"location":"qadence/types/#qadence.types.LTSOrder.ST4","title":"<code>ST4 = 'ST4'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ST4.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology","title":"<code>LatticeTopology</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Lattice topologies to choose from for the register.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ALL_TO_ALL","title":"<code>ALL_TO_ALL = 'all_to_all'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>All to all- connected lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.ARBITRARY","title":"<code>ARBITRARY = 'arbitrary'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Arbitrarily-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.CIRCLE","title":"<code>CIRCLE = 'circle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Circular lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.HONEYCOMB_LATTICE","title":"<code>HONEYCOMB_LATTICE = 'honeycomb_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Honeycomb-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.LINE","title":"<code>LINE = 'line'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Line-format lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.RECTANGULAR_LATTICE","title":"<code>RECTANGULAR_LATTICE = 'rectangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rectangular-shaped lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.SQUARE","title":"<code>SQUARE = 'square'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Square lattice.</p>"},{"location":"qadence/types/#qadence.types.LatticeTopology.TRIANGULAR_LATTICE","title":"<code>TRIANGULAR_LATTICE = 'triangular_lattice'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Triangular-shaped shape.</p>"},{"location":"qadence/types/#qadence.types.OpName","title":"<code>OpName</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>A list of all available of digital-analog operations.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGENTANG","title":"<code>ANALOGENTANG = 'AnalogEntanglement'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGINTERACTION","title":"<code>ANALOGINTERACTION = 'AnalogInteraction'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog interaction operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRX","title":"<code>ANALOGRX = 'AnalogRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RX operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRY","title":"<code>ANALOGRY = 'AnalogRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RY operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGRZ","title":"<code>ANALOGRZ = 'AnalogRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog RZ operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.ANALOGSWAP","title":"<code>ANALOGSWAP = 'AnalogSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The analog SWAP operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.CNOT","title":"<code>CNOT = 'CNOT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CNOT gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CPHASE","title":"<code>CPHASE = 'CPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The controlled PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRX","title":"<code>CRX = 'CRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRY","title":"<code>CRY = 'CRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Controlled RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CRZ","title":"<code>CRZ = 'CRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CSWAP","title":"<code>CSWAP = 'CSWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Control SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.CZ","title":"<code>CZ = 'CZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ENTANGLE","title":"<code>ENTANGLE = 'entangle'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The entanglement operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.H","title":"<code>H = 'H'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hadamard gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.HAMEVO","title":"<code>HAMEVO = 'HamEvo'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Hamiltonian Evolution operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.I","title":"<code>I = 'I'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Identity gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCPHASE","title":"<code>MCPHASE = 'MCPHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRX","title":"<code>MCRX = 'MCRX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRY","title":"<code>MCRY = 'MCRY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCRZ","title":"<code>MCRZ = 'MCRZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.MCZ","title":"<code>MCZ = 'MCZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Multicontrol CZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.N","title":"<code>N = 'N'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The N = (1/2)(I-Z) operator.</p>"},{"location":"qadence/types/#qadence.types.OpName.PHASE","title":"<code>PHASE = 'PHASE'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PHASE gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.PROJ","title":"<code>PROJ = 'Projector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The projector operation.</p>"},{"location":"qadence/types/#qadence.types.OpName.RX","title":"<code>RX = 'RX'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RX gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RY","title":"<code>RY = 'RY'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RY gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.RZ","title":"<code>RZ = 'RZ'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The RZ gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.S","title":"<code>S = 'S'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SDAGGER","title":"<code>SDAGGER = 'SDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The S dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.SWAP","title":"<code>SWAP = 'SWAP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The SWAP gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.T","title":"<code>T = 'T'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TDAGGER","title":"<code>TDAGGER = 'TDagger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The T dagger gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.TOFFOLI","title":"<code>TOFFOLI = 'Toffoli'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Toffoli gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.U","title":"<code>U = 'U'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The U gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.X","title":"<code>X = 'X'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The X gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Y","title":"<code>Y = 'Y'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Y gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.Z","title":"<code>Z = 'Z'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Z gate.</p>"},{"location":"qadence/types/#qadence.types.OpName.ZERO","title":"<code>ZERO = 'Zero'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The zero gate.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod","title":"<code>OverlapMethod</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Overlap Methods to choose from.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.COMPUTE_UNCOMPUTE","title":"<code>COMPUTE_UNCOMPUTE = 'compute_uncompute'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Compute-uncompute.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.EXACT","title":"<code>EXACT = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exact.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.HADAMARD_TEST","title":"<code>HADAMARD_TEST = 'hadamard_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hadamard-test.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.JENSEN_SHANNON","title":"<code>JENSEN_SHANNON = 'jensen_shannon'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Jensen-shannon.</p>"},{"location":"qadence/types/#qadence.types.OverlapMethod.SWAP_TEST","title":"<code>SWAP_TEST = 'swap_test'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Swap-test.</p>"},{"location":"qadence/types/#qadence.types.ParameterType","title":"<code>ParameterType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Parameter types available in qadence.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FEATURE","title":"<code>FEATURE = 'Feature'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>FeatureParameters act as input and are not trainable.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.FIXED","title":"<code>FIXED = 'Fixed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed/ constant parameters are neither trainable nor act as input.</p>"},{"location":"qadence/types/#qadence.types.ParameterType.VARIATIONAL","title":"<code>VARIATIONAL = 'Variational'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>VariationalParameters are trainable.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType","title":"<code>QubitSupportType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Qubit support types.</p>"},{"location":"qadence/types/#qadence.types.QubitSupportType.GLOBAL","title":"<code>GLOBAL = 'global'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use global qubit support.</p>"},{"location":"qadence/types/#qadence.types.ResultType","title":"<code>ResultType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available data types for generating certain results.</p>"},{"location":"qadence/types/#qadence.types.ResultType.NUMPY","title":"<code>NUMPY = 'Numpy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Numpy Array Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.STRING","title":"<code>STRING = 'String'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>String Type.</p>"},{"location":"qadence/types/#qadence.types.ResultType.TORCH","title":"<code>TORCH = 'Torch'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Torch Tensor Type.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling","title":"<code>ReuploadScaling</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Scaling for data reuploads in feature maps.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.CONSTANT","title":"<code>CONSTANT = 'Constant'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Constant scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.EXP","title":"<code>EXP = 'Exponential'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Exponentially increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.ReuploadScaling.TOWER","title":"<code>TOWER = 'Tower'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Linearly increasing scaling.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat","title":"<code>SerializationFormat</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Available serialization formats for circuits.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.JSON","title":"<code>JSON = 'JSON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The Json format.</p>"},{"location":"qadence/types/#qadence.types.SerializationFormat.PT","title":"<code>PT = 'PT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The PT format used by Torch.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType","title":"<code>StateGeneratorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Methods to generate random states.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_FAST","title":"<code>HAAR_MEASURE_FAST = 'HaarMeasureFast'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.HAAR_MEASURE_SLOW","title":"<code>HAAR_MEASURE_SLOW = 'HaarMeasureSlow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HaarMeasure non-optimized version.</p>"},{"location":"qadence/types/#qadence.types.StateGeneratorType.RANDOM_ROTATIONS","title":"<code>RANDOM_ROTATIONS = 'RandomRotations'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random Rotations.</p>"},{"location":"qadence/types/#qadence.types.StrEnum","title":"<code>StrEnum</code>","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"qadence/types/#qadence.types.StrEnum.__str__","title":"<code>__str__()</code>","text":"<p>Used when dumping enum fields in a schema.</p> Source code in <code>qadence/types.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Used when dumping enum fields in a schema.\"\"\"\n    ret: str = self.value\n    return ret\n</code></pre>"},{"location":"qadence/types/#qadence.types.Strategy","title":"<code>Strategy</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Computing paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.ANALOG","title":"<code>ANALOG = 'Analog'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the analog paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.BDAQC","title":"<code>BDAQC = 'bDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the banged digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.DIGITAL","title":"<code>DIGITAL = 'Digital'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the digital paradigm.</p>"},{"location":"qadence/types/#qadence.types.Strategy.SDAQC","title":"<code>SDAQC = 'sDAQC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Use the step-wise digital-analog QC paradigm.</p>"},{"location":"qadence/types/#qadence.types.TensorType","title":"<code>TensorType</code>","text":"<p>             Bases: <code>StrEnum</code></p> <p>Tensor Types for converting blocks to tensors.</p>"},{"location":"qadence/types/#qadence.types.TensorType.DENSE","title":"<code>DENSE = 'Dense'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a block to a dense tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSE","title":"<code>SPARSE = 'Sparse'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a observable block to a sparse tensor.</p>"},{"location":"qadence/types/#qadence.types.TensorType.SPARSEDIAGONAL","title":"<code>SPARSEDIAGONAL = 'SparseDiagonal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Convert a diagonal observable block to a sparse diagonal if possible.</p>"},{"location":"qml/","title":"Variational quantum algorithms","text":"<p>Variational algorithms on noisy devices and quantum machine learning (QML)[^1] in particular are one of the main target applications for Qadence. For this purpose, the library offers both flexible symbolic expressions for the quantum circuit parameters via <code>sympy</code> (see here for more details) and native automatic differentiation via integration with PyTorch deep learning framework.</p> <p>Furthermore, Qadence offers a wide range of utilities for helping building and researching quantum machine learning algorithms, including:</p> <ul> <li>a set of constructors for circuits commonly used in quantum machine learning such as feature maps and ansatze</li> <li>a set of tools for training and optimizing quantum neural networks and loading classical data into a QML algorithm</li> </ul>"},{"location":"qml/#some-simple-examples","title":"Some simple examples","text":"<p>Qadence symbolic parameter interface allows to create arbitrary feature maps to encode classical data into quantum circuits with an arbitrary non-linear function embedding for the input values:</p> <pre><code>import qadence as qd\nfrom qadence.operations import *\nimport torch\nfrom sympy import acos\n\nn_qubits = 4\n\n# Example feature map, also directly available with the `feature_map` function\nfp = qd.FeatureParameter(\"phi\")\nfm = qd.kron(RX(i, acos(fp)) for i in range(n_qubits))\n\n# the key in the dictionary must correspond to\n# the name of the assigned to the feature parameter\ninputs = {\"phi\": torch.rand(3)}\nsamples = qd.sample(fm, values=inputs)\n</code></pre> <pre><code>samples = Counter({'0000': 78, '1000': 8, '0010': 5, '0100': 4, '0001': 1, '0101': 1, '1010': 1, '1101': 1, '1110': 1})\n</code></pre> <p>The <code>constructors.feature_map</code> module provides convenience functions to build commonly used feature maps where the input parameter is encoded in the single-qubit gates rotation angle. This function will be further demonstrated in the QML constructors tutorial.</p> <p>Furthermore, Qadence is natively integrated with PyTorch automatic differentiation engine thus Qadence quantum models can be used seamlessly in a PyTorch workflow.</p> <p>Let's create a quantum neural network model using the feature map just defined, a digital-analog variational ansatz (also explained here) and a simple observable \\(X(0) \\otimes X(1)\\). We use the convenience <code>QNN</code> quantum model abstraction.</p> <pre><code>ansatz = qd.hea(n_qubits, strategy=\"sDAQC\")\ncircuit = qd.QuantumCircuit(n_qubits, fm, ansatz)\nobservable = qd.kron(X(0), X(1))\n\nmodel = qd.QNN(circuit, observable)\n\n# NOTE: the `QNN` is a torch.nn.Module\nassert isinstance(model, torch.nn.Module)\n</code></pre> <pre><code>True\n</code></pre> <p>Differentiation works the same way as any other PyTorch module:</p> <pre><code>values = {\"phi\": torch.rand(10, requires_grad=True)}\n\n# the forward pass of the quantum model returns the expectation\n# value of the input observable\nout = model(values)\n\n# you can compute the gradient with respect to inputs using\n# PyTorch autograd differentiation engine\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n\n# you can also call directly a backward pass to compute derivatives with respect\n# to the variational parameters and use it for implementing variational\n# optimization\nout.sum().backward()\n</code></pre> <pre><code>Quantum model output: \ntensor([[-0.0018],\n        [-0.0004],\n        [ 0.0510],\n        [ 0.0049],\n        [ 0.0771],\n        [ 0.0133],\n        [-0.0328],\n        [-0.0192],\n        [ 0.0395],\n        [-0.0323]], grad_fn=&lt;CatBackward0&gt;)\n\nFirst-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>To run QML on real devices, Qadence offers generalized parameter shift rules (GPSR) <sup>1</sup> for arbitrary quantum operations which can be selected when constructing the <code>QNN</code> model:</p> <pre><code>model = qd.QNN(circuit, observable, diff_mode=\"gpsr\")\nout = model(values)\n\ndout = torch.autograd.grad(out, values[\"phi\"], torch.ones_like(out), create_graph=True)[0]\nprint(f\"First-order derivative w.r.t. the feature parameter: \\n{dout}\")\n</code></pre> <pre><code>First-order derivative w.r.t. the feature parameter: \ntensor([ 0.4446,  0.4420,  0.3099,  0.4317,  0.1779, -0.5565,  0.4933,  0.4737,\n         0.3478,  0.4926], grad_fn=&lt;MulBackward0&gt;)\n</code></pre> <p>See here for more details on how the parameter shift rules implementation works in Qadence.</p>"},{"location":"qml/#references","title":"References","text":"<p>[^1] Schuld, Petruccione, Machine learning on Quantum Computers, Springer Nature (2021)</p> <ol> <li> <p>Kyriienko et al., General quantum circuit differentiation rules \u21a9</p> </li> </ol>"},{"location":"qml/ml_tools/","title":"Training tools","text":""},{"location":"qml/ml_tools/#dataloaders","title":"Dataloaders","text":"<p>When using Qadence, you can supply classical data to a quantum machine learning algorithm by using a standard PyTorch <code>DataLoader</code> instance. Qadence also provides the <code>DictDataLoader</code> convenience class which allows to build dictionaries of <code>DataLoader</code>s instances and easily iterate over them.</p> <pre><code>import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nfrom qadence.ml_tools import DictDataLoader, to_dataloader\n\n\ndef dataloader(data_size: int = 25, batch_size: int = 5, infinite: bool = False) -&gt; DataLoader:\n    x = torch.linspace(0, 1, data_size).reshape(-1, 1)\n    y = torch.sin(x)\n    return to_dataloader(x, y, batch_size=batch_size, infinite=infinite)\n\n\ndef dictdataloader(data_size: int = 25, batch_size: int = 5) -&gt; DictDataLoader:\n    dls = {}\n    for k in [\"y1\", \"y2\"]:\n        x = torch.rand(data_size, 1)\n        y = torch.sin(x)\n        dls[k] = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n    return DictDataLoader(dls)\n\n\n# iterate over standard DataLoader\nfor (x,y) in dataloader(data_size=6, batch_size=2):\n    print(f\"Standard {x = }\")\n\n# construct an infinite dataset which will keep sampling indefinitely\nn_epochs = 5\ndl = iter(dataloader(data_size=6, batch_size=2, infinite=True))\nfor _ in range(n_epochs):\n    (x, y) = next(dl)\n    print(f\"Infinite {x = }\")\n\n# iterate over DictDataLoader\nddl = dictdataloader()\ndata = next(iter(ddl))\nprint(f\"{data = }\")\n</code></pre> <pre><code>Standard x = tensor([[0.0000],\n        [0.2000]])\nStandard x = tensor([[0.4000],\n        [0.6000]])\nStandard x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\nInfinite x = tensor([[0.8000],\n        [1.0000]])\nInfinite x = tensor([[0.0000],\n        [0.2000]])\nInfinite x = tensor([[0.4000],\n        [0.6000]])\ndata = {'y1': [tensor([[0.4053],\n        [0.9018],\n        [0.9084],\n        [0.2606],\n        [0.9428]]), tensor([[0.3943],\n        [0.7844],\n        [0.7885],\n        [0.2577],\n        [0.8092]])], 'y2': [tensor([[0.4695],\n        [0.1881],\n        [0.6359],\n        [0.7454],\n        [0.2043]]), tensor([[0.4524],\n        [0.1870],\n        [0.5939],\n        [0.6783],\n        [0.2029]])]}\n</code></pre>"},{"location":"qml/ml_tools/#optimization-routines","title":"Optimization routines","text":"<p>For training QML models, Qadence also offers a few out-of-the-box routines for optimizing differentiable models, e.g. <code>QNN</code>s and <code>QuantumModel</code>, containing either trainable and/or non-trainable parameters (see the parameters tutorial for detailed information about parameter types):</p> <ul> <li><code>train_with_grad</code> for gradient-based optimization using PyTorch native optimizers</li> <li><code>train_gradient_free</code> for gradient-free optimization using the Nevergrad library.</li> </ul> <p>These routines performs training, logging/printing loss metrics and storing intermediate checkpoints of models. In the following, we use <code>train_with_grad</code> as example but the code can be used directly with the gradient-free routine.</p> <p>As every other training routine commonly used in Machine Learning, it requires <code>model</code>, <code>data</code> and an <code>optimizer</code> as input arguments. However, in addition, it requires a <code>loss_fn</code> and a <code>TrainConfig</code>. A <code>loss_fn</code> is required to be a function which expects both a model and data and returns a tuple of (loss, metrics: <code>&lt;dict&gt;</code>), where <code>metrics</code> is a dict of scalars which can be customized too.</p> <pre><code>import torch\nfrom itertools import count\ncnt = count()\ncriterion = torch.nn.MSELoss()\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n</code></pre> <p>The <code>TrainConfig</code> tells <code>train_with_grad</code> what batch_size should be used, how many epochs to train, in which intervals to print/log metrics and how often to store intermediate checkpoints.</p> <pre><code>from qadence.ml_tools import TrainConfig\n\nbatch_size = 5\nn_epochs = 100\n\nconfig = TrainConfig(\n    folder=\"some_path/\",\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n</code></pre> <p>Let's see it in action with a simple example.</p>"},{"location":"qml/ml_tools/#fitting-a-funtion-with-a-qnn-using-ml_tools","title":"Fitting a funtion with a QNN using <code>ml_tools</code>","text":"<p>Let's look at a complete example of how to use <code>train_with_grad</code> now.</p> <pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nimport matplotlib.pyplot as plt\n\nfrom qadence import Parameter, QuantumCircuit, Z\nfrom qadence import hamiltonian_factory, hea, feature_map, chain\nfrom qadence.models import QNN\nfrom qadence.ml_tools import  TrainConfig, train_with_grad, to_dataloader\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncnt = count()\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n\ndef loss_fn(model: torch.nn.Module, data: torch.Tensor) -&gt; tuple[torch.Tensor, dict]:\n    next(cnt)\n    x, y = data[0], data[1]\n    out = model(x)\n    loss = criterion(out, y)\n    return loss, {}\n\ntmp_path = Path(\"/tmp\")\n\nn_epochs = 50\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nbatch_size = 25\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\ndata = to_dataloader(x, y, batch_size=batch_size, infinite=True)\n\ntrain_with_grad(model, data, optimizer, config, loss_fn=loss_fn)\n\nplt.plot(x, y)\nplt.plot(x, model(x).detach())\n</code></pre> 2024-02-15T16:12:00.780240 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>For users who want to use the low-level API of <code>qadence</code>, here is the example from above written without <code>train_with_grad</code>.</p>"},{"location":"qml/ml_tools/#fitting-a-function-low-level-api","title":"Fitting a function - Low-level API","text":"<pre><code>from pathlib import Path\nimport torch\nfrom itertools import count\nfrom qadence.constructors import hamiltonian_factory, hea, feature_map\nfrom qadence import chain, Parameter, QuantumCircuit, Z\nfrom qadence.models import QNN\nfrom qadence.ml_tools import train_with_grad, TrainConfig\n\nn_qubits = 2\nfm = feature_map(n_qubits)\nansatz = hea(n_qubits=n_qubits, depth=3)\nobservable = hamiltonian_factory(n_qubits, detuning=Z)\ncircuit = QuantumCircuit(n_qubits, fm, ansatz)\n\nmodel = QNN(circuit, observable, backend=\"pyqtorch\", diff_mode=\"ad\")\nbatch_size = 1\ninput_values = {\"phi\": torch.rand(batch_size, requires_grad=True)}\npred = model(input_values)\n\ncriterion = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=0.1)\nn_epochs=50\ncnt = count()\n\ntmp_path = Path(\"/tmp\")\n\nconfig = TrainConfig(\n    folder=tmp_path,\n    max_iter=n_epochs,\n    checkpoint_every=100,\n    write_every=100,\n    batch_size=batch_size,\n)\n\nx = torch.linspace(0, 1, batch_size).reshape(-1, 1)\ny = torch.sin(x)\n\nfor i in range(n_epochs):\n    out = model(x)\n    loss = criterion(out, y)\n    loss.backward()\n    optimizer.step()\n</code></pre>"},{"location":"qml/ml_tools/#custom-train-loop","title":"Custom <code>train</code> loop","text":"<p>If you need custom training functionality that goes beyon what is available in <code>qadence.ml_tools.train_with_grad</code> and <code>qadence.ml_tools.train_gradient_free</code> you can write your own training loop based on the building blocks that are available in Qadence.</p> <p>A simplified version of Qadence's train loop is defined below. Feel free to copy it and modify at will.</p> <pre><code>from typing import Callable, Union\n\nfrom torch.nn import Module\nfrom torch.optim import Optimizer\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\nfrom qadence.ml_tools.config import TrainConfig\nfrom qadence.ml_tools.data import DictDataLoader, data_to_device\nfrom qadence.ml_tools.optimize_step import optimize_step\nfrom qadence.ml_tools.printing import print_metrics, write_tensorboard\nfrom qadence.ml_tools.saveload import load_checkpoint, write_checkpoint\n\n\ndef train(\n    model: Module,\n    data: DataLoader,\n    optimizer: Optimizer,\n    config: TrainConfig,\n    loss_fn: Callable,\n    device: str = \"cpu\",\n    optimize_step: Callable = optimize_step,\n    write_tensorboard: Callable = write_tensorboard,\n) -&gt; tuple[Module, Optimizer]:\n\n    # Move model to device before optimizer is loaded\n    model = model.to(device)\n\n    # load available checkpoint\n    init_iter = 0\n    if config.folder:\n        model, optimizer, init_iter = load_checkpoint(config.folder, model, optimizer)\n\n    # initialize tensorboard\n    writer = SummaryWriter(config.folder, purge_step=init_iter)\n\n    dl_iter = iter(dataloader)\n\n    # outer epoch loop\n    for iteration in range(init_iter, init_iter + config.max_iter):\n        data = data_to_device(next(dl_iter), device)\n        loss, metrics = optimize_step(model, optimizer, loss_fn, data)\n\n        if iteration % config.print_every == 0 and config.verbose:\n            print_metrics(loss, metrics, iteration)\n\n        if iteration % config.write_every == 0:\n            write_tensorboard(writer, loss, metrics, iteration)\n\n        if config.folder:\n            if iteration % config.checkpoint_every == 0:\n                write_checkpoint(config.folder, model, optimizer, iteration)\n\n    # Final writing and checkpointing\n    if config.folder:\n        write_checkpoint(config.folder, model, optimizer, iteration)\n    write_tensorboard(writer, loss, metrics, iteration)\n    writer.close()\n\n    return model, optimizer\n</code></pre>"},{"location":"qml/qaoa/","title":"Solving MaxCut with QAOA","text":"<p>This tutorial shows how to solve the maximum cut (MaxCut) combinatorial optimization problem on a graph using the Quantum Approximate Optimization Algorithm (QAOA), first introduced by Farhi et al. in 2014 <sup>1</sup>.</p> <p>Given an arbitrary graph, the MaxCut problem consists in finding a graph cut which partitions the nodes into two disjoint sets, such that the number of edges in the cut is maximized. This is a very common combinatorial optimization problem which is computationally hard.</p> <p>The graph used for this tutorial is a randomly generated using the <code>networkx</code> library with a \\(0.5\\) probability of having an edge between two arbitrary nodes.</p> <pre><code>import numpy as np\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# ensure reproducibility\nseed = 10\nnp.random.seed(seed)\n\nn_nodes = 8\nedge_prob = 0.5\ngraph = nx.gnp_random_graph(n_nodes, edge_prob)\n\nnx.draw(graph)\n</code></pre> 2024-02-15T16:12:01.373787 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>The goal of the MaxCut algorithm is to maximize the following cost function:</p> \\[\\mathcal{C}(p) = \\sum_{\\alpha}^m \\mathcal{C}_{\\alpha}(p)\\] <p>where \\(p\\) is the given partition of the graph, \\(\\alpha\\) is an index over the edges and \\(\\mathcal{C}_{\\alpha}(p)\\) is written such that if the nodes connected by the \\(\\alpha\\) edge are in the same set, it returns \\(0\\), otherwise it returns \\(1\\).</p>"},{"location":"qml/qaoa/#the-qaoa-quantum-circuit","title":"The QAOA quantum circuit","text":"<p>This problem can be solved by using a parametrized quantum circuit with the QAOA algorithm. This requires a circuit with two main components:</p> <ul> <li>the cost component: a circuit generated by a diagonal Hamiltonian which   encodes the cost function described above into a quantum circuit.</li> <li>the mixing component: a simple set of single-qubit rotations with adjustable   angles which are tuned during the classical optimization loop to minimize the cost</li> </ul> <p>Below, the QAOA quantum circuit with the cost and mixing components is defined using <code>qadence</code> operations. The cost component of each layer of the circuit is decomposed into digital single and two-qubits operations via the <code>.digital_decomposition()</code> method. The decomposition is exact since the Hamiltonian generator is diagonal.</p> <pre><code>from qadence import Zero, I, HamEvo, tag, kron, chain, QuantumCircuit, RX, Z\n\n# generators associated with the edges of the given graph\nzz_ops = [kron(Z(edge[0]), Z(edge[1])) for edge in graph.edges()]\n\nn_qubits = graph.number_of_nodes()\nn_layers = 2\n\ncost_ham = Zero()\nfor op in zz_ops:\n    cost_ham += 0.5 * op\ncost_ham = 0.5 * kron(I(i) for i in range(n_qubits)) - cost_ham\n\nlayers = []\nfor layer in range(n_layers):\n\n    # cost layer with digital decomposition\n    cost_layer = HamEvo(cost_ham, f\"g{layer}\").digital_decomposition()\n    cost_layer = tag(cost_layer, \"cost\")\n\n    # mixing layer with single qubit rotations\n    mixing_layer = kron(RX(i, f\"b{layer}{i}\") for i in range(n_qubits))\n    mixing_layer = tag(mixing_layer, \"mixing\")\n\n    # putting all together in a single ChainBlock\n    layers.append(chain(cost_layer, mixing_layer))\n\nfinal_b = chain(*layers)\n\ncircuit = QuantumCircuit(n_qubits, final_b)\n</code></pre> %3 cluster_032a0bf894034532a6aeaf9754c0dc88 mixing cluster_c61bce7ba0f14ba7ab5672e765e27b6c cost cluster_a704718b7ed247c19d5c1f1669c855f4 mixing cluster_6dcc5b5f31c84668a2b42390852d00a0 cost 8c3f63b11a5847e58748a44ce01f9388 0 a10dd333cc614c67adc79abbe4dab689 8c3f63b11a5847e58748a44ce01f9388--a10dd333cc614c67adc79abbe4dab689 2a3c97cdc0104553a81819da4c308d01 1 14adee27221648c1a68c8fa5c389a35d a10dd333cc614c67adc79abbe4dab689--14adee27221648c1a68c8fa5c389a35d adf4ec155f9b4b2582eee30172af2429 14adee27221648c1a68c8fa5c389a35d--adf4ec155f9b4b2582eee30172af2429 d4360e9e029249c6b9537eab65020fd4 adf4ec155f9b4b2582eee30172af2429--d4360e9e029249c6b9537eab65020fd4 cc06360ed5e443fab1e0757684c9eed1 d4360e9e029249c6b9537eab65020fd4--cc06360ed5e443fab1e0757684c9eed1 965784fd7976466e88f09b51ceea5faf cc06360ed5e443fab1e0757684c9eed1--965784fd7976466e88f09b51ceea5faf 72c73a9234bc4fa19708a75e29208ebb 965784fd7976466e88f09b51ceea5faf--72c73a9234bc4fa19708a75e29208ebb 33b858ac40af431a99fe244232e75a4b 72c73a9234bc4fa19708a75e29208ebb--33b858ac40af431a99fe244232e75a4b 6d85161a93d34b56a686087e8c3c9a9b 33b858ac40af431a99fe244232e75a4b--6d85161a93d34b56a686087e8c3c9a9b 85a18b3e08404749b6c65744b0653dca 6d85161a93d34b56a686087e8c3c9a9b--85a18b3e08404749b6c65744b0653dca 9ef04e6dc1144f0aac0e0204c98b21c7 85a18b3e08404749b6c65744b0653dca--9ef04e6dc1144f0aac0e0204c98b21c7 cb14a3bd78ef4701be9345f56674cc2e 9ef04e6dc1144f0aac0e0204c98b21c7--cb14a3bd78ef4701be9345f56674cc2e 41c498e7205547a0b6815983168c23a4 cb14a3bd78ef4701be9345f56674cc2e--41c498e7205547a0b6815983168c23a4 d6c4c2ac9509475984f82519cb11d611 41c498e7205547a0b6815983168c23a4--d6c4c2ac9509475984f82519cb11d611 e4b5e70c311340f5a238a4f0e93c63d6 d6c4c2ac9509475984f82519cb11d611--e4b5e70c311340f5a238a4f0e93c63d6 61eb772a03764fc2b0b8c17699cd283e e4b5e70c311340f5a238a4f0e93c63d6--61eb772a03764fc2b0b8c17699cd283e e3735b2c86fc4fef882bc33c66ad57e8 61eb772a03764fc2b0b8c17699cd283e--e3735b2c86fc4fef882bc33c66ad57e8 9b03c3b2fdc948fe989ae8c1cfbef198 e3735b2c86fc4fef882bc33c66ad57e8--9b03c3b2fdc948fe989ae8c1cfbef198 5667bbd3d4764905accc9b6204166d5e 9b03c3b2fdc948fe989ae8c1cfbef198--5667bbd3d4764905accc9b6204166d5e b169d06a76ae418ea2f537a92042fddf 5667bbd3d4764905accc9b6204166d5e--b169d06a76ae418ea2f537a92042fddf 6aadd60147dd445f88b8db5c0e4421ec b169d06a76ae418ea2f537a92042fddf--6aadd60147dd445f88b8db5c0e4421ec 090817db7c32455aabfb7abefe01c4b7 6aadd60147dd445f88b8db5c0e4421ec--090817db7c32455aabfb7abefe01c4b7 ade144fbd3364dc8961cd5faf7539ee8 090817db7c32455aabfb7abefe01c4b7--ade144fbd3364dc8961cd5faf7539ee8 f191fdadf2da45d7a8770e089c02bc86 ade144fbd3364dc8961cd5faf7539ee8--f191fdadf2da45d7a8770e089c02bc86 4584d323118e4499b5a2e0572ed18eaa f191fdadf2da45d7a8770e089c02bc86--4584d323118e4499b5a2e0572ed18eaa bdf0a5b43b624d3b9673ea197f453e22 4584d323118e4499b5a2e0572ed18eaa--bdf0a5b43b624d3b9673ea197f453e22 5e1f3ab995ff4ce8a0c0c9ac349fd364 bdf0a5b43b624d3b9673ea197f453e22--5e1f3ab995ff4ce8a0c0c9ac349fd364 6bc290286c024da2b8082757d31c85fc 5e1f3ab995ff4ce8a0c0c9ac349fd364--6bc290286c024da2b8082757d31c85fc 0a007a752b264a31a19de6ecd1bd84d5 6bc290286c024da2b8082757d31c85fc--0a007a752b264a31a19de6ecd1bd84d5 e023875207c44b158d50efffca594c2d 0a007a752b264a31a19de6ecd1bd84d5--e023875207c44b158d50efffca594c2d c2f9e1f49ed343388e01305e4e1cfbc4 e023875207c44b158d50efffca594c2d--c2f9e1f49ed343388e01305e4e1cfbc4 29484be7103d4923a03178adaf6d08c2 c2f9e1f49ed343388e01305e4e1cfbc4--29484be7103d4923a03178adaf6d08c2 2f53d78abfd9496583ba39226aa2b0de 29484be7103d4923a03178adaf6d08c2--2f53d78abfd9496583ba39226aa2b0de a3380a6987474814b5f3d079bf469da4 2f53d78abfd9496583ba39226aa2b0de--a3380a6987474814b5f3d079bf469da4 db7712f0e1f74ca4947c4e048da54864 a3380a6987474814b5f3d079bf469da4--db7712f0e1f74ca4947c4e048da54864 51cdd5165dfb4a30a23d2bdfad391c49 db7712f0e1f74ca4947c4e048da54864--51cdd5165dfb4a30a23d2bdfad391c49 23da6a34777d481b8bfb50624258db07 51cdd5165dfb4a30a23d2bdfad391c49--23da6a34777d481b8bfb50624258db07 1bc30d83f9784a65b989593ad38b2ef5 23da6a34777d481b8bfb50624258db07--1bc30d83f9784a65b989593ad38b2ef5 eb98709220c44ab1b181a33f1e8a1f66 1bc30d83f9784a65b989593ad38b2ef5--eb98709220c44ab1b181a33f1e8a1f66 713f360b51ea441a8ed529748e748ec6 eb98709220c44ab1b181a33f1e8a1f66--713f360b51ea441a8ed529748e748ec6 76bb3b4cbd1b42b79f143e7fc382fd06 713f360b51ea441a8ed529748e748ec6--76bb3b4cbd1b42b79f143e7fc382fd06 606f2e3dcafe4767b34809f70701606b 76bb3b4cbd1b42b79f143e7fc382fd06--606f2e3dcafe4767b34809f70701606b 4b0d68af71ee48a6b65b9d0317971022 606f2e3dcafe4767b34809f70701606b--4b0d68af71ee48a6b65b9d0317971022 523f909955824378ae0f3860a422aa43 4b0d68af71ee48a6b65b9d0317971022--523f909955824378ae0f3860a422aa43 20bce6ee0a43429ca362bb247e617370 523f909955824378ae0f3860a422aa43--20bce6ee0a43429ca362bb247e617370 e211e609351c475383d764ad436f31b2 20bce6ee0a43429ca362bb247e617370--e211e609351c475383d764ad436f31b2 8522fa1fa6d74046806e07cc2e0ba473 e211e609351c475383d764ad436f31b2--8522fa1fa6d74046806e07cc2e0ba473 eb440dd37dee4ce0b177467c8a18e962 8522fa1fa6d74046806e07cc2e0ba473--eb440dd37dee4ce0b177467c8a18e962 5298c572cddc4f38a745a967150a6345 eb440dd37dee4ce0b177467c8a18e962--5298c572cddc4f38a745a967150a6345 fe6dbd53e54843a1b3322e860a34a22d 5298c572cddc4f38a745a967150a6345--fe6dbd53e54843a1b3322e860a34a22d 25446480c741470480cb69ba32217591 fe6dbd53e54843a1b3322e860a34a22d--25446480c741470480cb69ba32217591 0adc03ce867a49ffa62456b5e9792642 25446480c741470480cb69ba32217591--0adc03ce867a49ffa62456b5e9792642 d7a867c008344a558ca68ea76067851e 0adc03ce867a49ffa62456b5e9792642--d7a867c008344a558ca68ea76067851e abedd1e330044135955aebfb2cf90bc8 d7a867c008344a558ca68ea76067851e--abedd1e330044135955aebfb2cf90bc8 7e90628f0a2c4743a263c928ad432942 abedd1e330044135955aebfb2cf90bc8--7e90628f0a2c4743a263c928ad432942 8024f5d60f054ffabb7b95891cb8cacb 7e90628f0a2c4743a263c928ad432942--8024f5d60f054ffabb7b95891cb8cacb 15c5802e0a184a709bbd1486f33f3603 8024f5d60f054ffabb7b95891cb8cacb--15c5802e0a184a709bbd1486f33f3603 831a4a5430c5444e864e0f371dc05a5e 15c5802e0a184a709bbd1486f33f3603--831a4a5430c5444e864e0f371dc05a5e 2767bb2739b84e1990b37d9f4fa7eafc 831a4a5430c5444e864e0f371dc05a5e--2767bb2739b84e1990b37d9f4fa7eafc c676d975725a430a9cd9b26b58cc57b5 2767bb2739b84e1990b37d9f4fa7eafc--c676d975725a430a9cd9b26b58cc57b5 7995f6a198fb44b9998ef40bee24a262 c676d975725a430a9cd9b26b58cc57b5--7995f6a198fb44b9998ef40bee24a262 a0da2d5299474556a467908f27de810a 7995f6a198fb44b9998ef40bee24a262--a0da2d5299474556a467908f27de810a 119355529ab2460cbc662fd31059c5b2 a0da2d5299474556a467908f27de810a--119355529ab2460cbc662fd31059c5b2 f00144401c7b4b528913eec150e6736b 119355529ab2460cbc662fd31059c5b2--f00144401c7b4b528913eec150e6736b b5d605c6c37f443cbd156b2849a59f98 f00144401c7b4b528913eec150e6736b--b5d605c6c37f443cbd156b2849a59f98 44ff7978b606406e988f10fb0104a80e b5d605c6c37f443cbd156b2849a59f98--44ff7978b606406e988f10fb0104a80e 4cbea672c119471680426dd7b52bcb3d 44ff7978b606406e988f10fb0104a80e--4cbea672c119471680426dd7b52bcb3d e3746e56fd4443cfb6bc91fc1e3d5dd6 4cbea672c119471680426dd7b52bcb3d--e3746e56fd4443cfb6bc91fc1e3d5dd6 dcd0c3082f5a41ccbda0872c49ddf84e e3746e56fd4443cfb6bc91fc1e3d5dd6--dcd0c3082f5a41ccbda0872c49ddf84e ccfcb5a155a14395a341db0aee1ca3ad dcd0c3082f5a41ccbda0872c49ddf84e--ccfcb5a155a14395a341db0aee1ca3ad a24bb88a95df471ba3a4f78ec1b802e9 ccfcb5a155a14395a341db0aee1ca3ad--a24bb88a95df471ba3a4f78ec1b802e9 4380a1ff069d4efbba6cb6cade6844c2 a24bb88a95df471ba3a4f78ec1b802e9--4380a1ff069d4efbba6cb6cade6844c2 d48a6193410d4e60aea8cf7714936e7d 4380a1ff069d4efbba6cb6cade6844c2--d48a6193410d4e60aea8cf7714936e7d 2459ff04f5454cbcb6569345a12294a7 d48a6193410d4e60aea8cf7714936e7d--2459ff04f5454cbcb6569345a12294a7 992c004ad9b04c24a56435176022485a 2459ff04f5454cbcb6569345a12294a7--992c004ad9b04c24a56435176022485a 99ebf3e9fe03473189a04134fcd2cc94 992c004ad9b04c24a56435176022485a--99ebf3e9fe03473189a04134fcd2cc94 1a750953045845f18a473b3816e46447 99ebf3e9fe03473189a04134fcd2cc94--1a750953045845f18a473b3816e46447 b2b70d0b2fa5480cb302dbb56d091c8c 1a750953045845f18a473b3816e46447--b2b70d0b2fa5480cb302dbb56d091c8c 79e4c7ea6ef24dea8f8e3a14e028ce9e b2b70d0b2fa5480cb302dbb56d091c8c--79e4c7ea6ef24dea8f8e3a14e028ce9e a4ebed403bcf413eac322918f9207709 79e4c7ea6ef24dea8f8e3a14e028ce9e--a4ebed403bcf413eac322918f9207709 d8618ecc00c24013be9470ec9088cfd0 a4ebed403bcf413eac322918f9207709--d8618ecc00c24013be9470ec9088cfd0 5512f62433134b10903ad54b205b622d d8618ecc00c24013be9470ec9088cfd0--5512f62433134b10903ad54b205b622d 05ee78f4d4c7406ca2dcd90fe32df60d 5512f62433134b10903ad54b205b622d--05ee78f4d4c7406ca2dcd90fe32df60d 41fea44aa1ef49038b52018865eb7eda 05ee78f4d4c7406ca2dcd90fe32df60d--41fea44aa1ef49038b52018865eb7eda 4cee37964fa34e1b929636b7b46070bf 41fea44aa1ef49038b52018865eb7eda--4cee37964fa34e1b929636b7b46070bf 90ac7b2294744432b99c4d17082d02c5 4cee37964fa34e1b929636b7b46070bf--90ac7b2294744432b99c4d17082d02c5 12cbc11bd2274a149980b4a661aeddb1 90ac7b2294744432b99c4d17082d02c5--12cbc11bd2274a149980b4a661aeddb1 d039eca337094b57b003ec9aa34e97d5 12cbc11bd2274a149980b4a661aeddb1--d039eca337094b57b003ec9aa34e97d5 72c1df2ffb434d4d8021472da61f1fc0 d039eca337094b57b003ec9aa34e97d5--72c1df2ffb434d4d8021472da61f1fc0 25039ecb820e4719854e1f654ef944ba 72c1df2ffb434d4d8021472da61f1fc0--25039ecb820e4719854e1f654ef944ba 8c3e414014ac48fea5abf82ce308a53c 25039ecb820e4719854e1f654ef944ba--8c3e414014ac48fea5abf82ce308a53c ace5cbabe4b44a13af623fc865af8734 8c3e414014ac48fea5abf82ce308a53c--ace5cbabe4b44a13af623fc865af8734 66c51c1891a04ad48d925594e390cff4 ace5cbabe4b44a13af623fc865af8734--66c51c1891a04ad48d925594e390cff4 02a97bd2ff0a4cfab5dc80888639a3ff 66c51c1891a04ad48d925594e390cff4--02a97bd2ff0a4cfab5dc80888639a3ff e4489fcd033042b4ab44fb47cfd2a524 02a97bd2ff0a4cfab5dc80888639a3ff--e4489fcd033042b4ab44fb47cfd2a524 0b6d9a3bd428472f9731618e610502e8 e4489fcd033042b4ab44fb47cfd2a524--0b6d9a3bd428472f9731618e610502e8 e7c27e5e32d9414b806a643173b5eafa 0b6d9a3bd428472f9731618e610502e8--e7c27e5e32d9414b806a643173b5eafa 398addbe5b644297a1c4aa3ac68e532b e7c27e5e32d9414b806a643173b5eafa--398addbe5b644297a1c4aa3ac68e532b bd3aceda0f084826a288347bbc7a25df 398addbe5b644297a1c4aa3ac68e532b--bd3aceda0f084826a288347bbc7a25df 0e16e0cd68dc41deb699835ea5476386 bd3aceda0f084826a288347bbc7a25df--0e16e0cd68dc41deb699835ea5476386 b47bea9e484b4ecea8f42541c228175c 0e16e0cd68dc41deb699835ea5476386--b47bea9e484b4ecea8f42541c228175c c4fd57fee7824a70b1cd97fc0ff018b4 b47bea9e484b4ecea8f42541c228175c--c4fd57fee7824a70b1cd97fc0ff018b4 42727e04d234426a8b9aab11e19aadb2 c4fd57fee7824a70b1cd97fc0ff018b4--42727e04d234426a8b9aab11e19aadb2 96fa75aef46744be83cb92e7e7a6067d 42727e04d234426a8b9aab11e19aadb2--96fa75aef46744be83cb92e7e7a6067d b5bd77059cbc488bbc17d6e4720aa4d2 96fa75aef46744be83cb92e7e7a6067d--b5bd77059cbc488bbc17d6e4720aa4d2 4c19746c58a94867810956b7902c295c b5bd77059cbc488bbc17d6e4720aa4d2--4c19746c58a94867810956b7902c295c 67e1fc5b6c4e483ea10fbfc91ffdf318 4c19746c58a94867810956b7902c295c--67e1fc5b6c4e483ea10fbfc91ffdf318 48554b931dd64951b283b74eb678340d 67e1fc5b6c4e483ea10fbfc91ffdf318--48554b931dd64951b283b74eb678340d dca9af0c17a74201bee3fb2de7d46d07 48554b931dd64951b283b74eb678340d--dca9af0c17a74201bee3fb2de7d46d07 eb39a5df5a1245749686939fc18f72c8 dca9af0c17a74201bee3fb2de7d46d07--eb39a5df5a1245749686939fc18f72c8 1250f307ab1b49f7bc37ea26a2122c01 eb39a5df5a1245749686939fc18f72c8--1250f307ab1b49f7bc37ea26a2122c01 4ed1208944a14f8494dc0866a51fc101 1250f307ab1b49f7bc37ea26a2122c01--4ed1208944a14f8494dc0866a51fc101 0b1aed6b12be408795f4b4b3523c63de 4ed1208944a14f8494dc0866a51fc101--0b1aed6b12be408795f4b4b3523c63de 2e8dae1e1b074fd9bac3e6840ff9b5da 0b1aed6b12be408795f4b4b3523c63de--2e8dae1e1b074fd9bac3e6840ff9b5da f606c15a003649638b1eec4e7e53bdf6 2e8dae1e1b074fd9bac3e6840ff9b5da--f606c15a003649638b1eec4e7e53bdf6 4fecddc4ea39438fa43331fba115e9ed f606c15a003649638b1eec4e7e53bdf6--4fecddc4ea39438fa43331fba115e9ed f01d9ef8d186412eacbc24167d2ac58a 4fecddc4ea39438fa43331fba115e9ed--f01d9ef8d186412eacbc24167d2ac58a deba3a3b35ea4c87b3dca03806b005b0 f01d9ef8d186412eacbc24167d2ac58a--deba3a3b35ea4c87b3dca03806b005b0 aed47b5fb69a402691d180491908cdc3 deba3a3b35ea4c87b3dca03806b005b0--aed47b5fb69a402691d180491908cdc3 9422815499844a00a8c69753e1f64270 RX(b00) aed47b5fb69a402691d180491908cdc3--9422815499844a00a8c69753e1f64270 fb2ba6b247c84372b773283cc75d009f 9422815499844a00a8c69753e1f64270--fb2ba6b247c84372b773283cc75d009f 93db2797bfb44a90ac9a2a0ddb571936 fb2ba6b247c84372b773283cc75d009f--93db2797bfb44a90ac9a2a0ddb571936 fc452d82cf6e437b90647cc94a38f0e1 93db2797bfb44a90ac9a2a0ddb571936--fc452d82cf6e437b90647cc94a38f0e1 2848996cb35748fa8291fc237bc73657 fc452d82cf6e437b90647cc94a38f0e1--2848996cb35748fa8291fc237bc73657 c3aadd49a1ce445ba5737bafc06c5a57 2848996cb35748fa8291fc237bc73657--c3aadd49a1ce445ba5737bafc06c5a57 cb6a58fd6ce04f1ea4ad43dc162c5ca3 c3aadd49a1ce445ba5737bafc06c5a57--cb6a58fd6ce04f1ea4ad43dc162c5ca3 97b8cbfa48a8405abbd57a52868062fe cb6a58fd6ce04f1ea4ad43dc162c5ca3--97b8cbfa48a8405abbd57a52868062fe 727301126885498f9feb0ee5a9965b3f 97b8cbfa48a8405abbd57a52868062fe--727301126885498f9feb0ee5a9965b3f f11624f81db94bc79af8784b8df99c42 727301126885498f9feb0ee5a9965b3f--f11624f81db94bc79af8784b8df99c42 c35740cfd48447618d22badb2564b418 f11624f81db94bc79af8784b8df99c42--c35740cfd48447618d22badb2564b418 df794d08ca0a47a8b2ad1635852ecfb8 c35740cfd48447618d22badb2564b418--df794d08ca0a47a8b2ad1635852ecfb8 4db80955e04948d38093b6a71549e791 df794d08ca0a47a8b2ad1635852ecfb8--4db80955e04948d38093b6a71549e791 d951b36aada548b29106739a4b474205 4db80955e04948d38093b6a71549e791--d951b36aada548b29106739a4b474205 8e52ca792f5c48c7aa43ebf1336d3bf5 d951b36aada548b29106739a4b474205--8e52ca792f5c48c7aa43ebf1336d3bf5 3821e96d1b5a467a8e94bd31e6e9a257 8e52ca792f5c48c7aa43ebf1336d3bf5--3821e96d1b5a467a8e94bd31e6e9a257 56893468e2e149069343ccd783f0e2cb 3821e96d1b5a467a8e94bd31e6e9a257--56893468e2e149069343ccd783f0e2cb ab541c9dcb2f4fc89a883054b88bfbb9 56893468e2e149069343ccd783f0e2cb--ab541c9dcb2f4fc89a883054b88bfbb9 d14b4226aacc4942a52b7df24216ec66 ab541c9dcb2f4fc89a883054b88bfbb9--d14b4226aacc4942a52b7df24216ec66 15584b68dab346d49eb8d0f8498ddec8 d14b4226aacc4942a52b7df24216ec66--15584b68dab346d49eb8d0f8498ddec8 b5528ddb43a9419b92dc7f7183f9c2f7 15584b68dab346d49eb8d0f8498ddec8--b5528ddb43a9419b92dc7f7183f9c2f7 ffae6952b7134f0aba819539f2714d2a b5528ddb43a9419b92dc7f7183f9c2f7--ffae6952b7134f0aba819539f2714d2a 011f525e32ee4b0c925882c3ea01a19f ffae6952b7134f0aba819539f2714d2a--011f525e32ee4b0c925882c3ea01a19f fb292ec230304792baa664442d83e8df 011f525e32ee4b0c925882c3ea01a19f--fb292ec230304792baa664442d83e8df 3969a72a5aea418dafbc91c919d6c328 fb292ec230304792baa664442d83e8df--3969a72a5aea418dafbc91c919d6c328 eb89b40b2c644e4492424a56fdae8ad6 3969a72a5aea418dafbc91c919d6c328--eb89b40b2c644e4492424a56fdae8ad6 5b2635c6951e49e48744e133a7c4d8aa eb89b40b2c644e4492424a56fdae8ad6--5b2635c6951e49e48744e133a7c4d8aa 7ee3f84183d648f1912e5fd846d81932 5b2635c6951e49e48744e133a7c4d8aa--7ee3f84183d648f1912e5fd846d81932 60f6e6fb79db40f0908603181c9bc34b 7ee3f84183d648f1912e5fd846d81932--60f6e6fb79db40f0908603181c9bc34b 8c205ffe5b194ca6849aba073a4dce2b 60f6e6fb79db40f0908603181c9bc34b--8c205ffe5b194ca6849aba073a4dce2b 07673364a9d34be69593ca76e02383fb 8c205ffe5b194ca6849aba073a4dce2b--07673364a9d34be69593ca76e02383fb d1cf37660445417899081945d03e348b 07673364a9d34be69593ca76e02383fb--d1cf37660445417899081945d03e348b 3d6bc717d4c1409cb6a7112195edbc8c d1cf37660445417899081945d03e348b--3d6bc717d4c1409cb6a7112195edbc8c d840dd76ab5b46dd87e7f053e2d166b6 3d6bc717d4c1409cb6a7112195edbc8c--d840dd76ab5b46dd87e7f053e2d166b6 c41e1d72d3ab49e787121902688780ad d840dd76ab5b46dd87e7f053e2d166b6--c41e1d72d3ab49e787121902688780ad 521780bf290145ae973e24867818731e c41e1d72d3ab49e787121902688780ad--521780bf290145ae973e24867818731e de166c76b35f4fdb8cd63236d8f63c80 521780bf290145ae973e24867818731e--de166c76b35f4fdb8cd63236d8f63c80 69140ad05710437faacf69f68a1bf2b2 de166c76b35f4fdb8cd63236d8f63c80--69140ad05710437faacf69f68a1bf2b2 07320eadae4d4f98936dd0db560639ba 69140ad05710437faacf69f68a1bf2b2--07320eadae4d4f98936dd0db560639ba 27603dd09c874a2b9633012a94449d75 07320eadae4d4f98936dd0db560639ba--27603dd09c874a2b9633012a94449d75 8c728f7ea72942faab5fdb976a43dd50 27603dd09c874a2b9633012a94449d75--8c728f7ea72942faab5fdb976a43dd50 7a23f5bc22f441c59c609193db2de3bc 8c728f7ea72942faab5fdb976a43dd50--7a23f5bc22f441c59c609193db2de3bc d434640878a9423bbe6b2c857ede3c8d 7a23f5bc22f441c59c609193db2de3bc--d434640878a9423bbe6b2c857ede3c8d b1c9bbf47b034c2fbc07106c4a57d6de d434640878a9423bbe6b2c857ede3c8d--b1c9bbf47b034c2fbc07106c4a57d6de a471d4c30b51410fb2908c02cccbad53 b1c9bbf47b034c2fbc07106c4a57d6de--a471d4c30b51410fb2908c02cccbad53 19e3d443ba33483b907ef0f62f178418 a471d4c30b51410fb2908c02cccbad53--19e3d443ba33483b907ef0f62f178418 1e8f83d059ec4b249a0dc1b8a6b211d6 19e3d443ba33483b907ef0f62f178418--1e8f83d059ec4b249a0dc1b8a6b211d6 f4e93e1e70e4415ca1bd7f33690ed2f9 1e8f83d059ec4b249a0dc1b8a6b211d6--f4e93e1e70e4415ca1bd7f33690ed2f9 844f54b19ae14b258a0b49abf455ca2d f4e93e1e70e4415ca1bd7f33690ed2f9--844f54b19ae14b258a0b49abf455ca2d 5c7ad8486ff3482d8dc72dd4d09bdcf1 844f54b19ae14b258a0b49abf455ca2d--5c7ad8486ff3482d8dc72dd4d09bdcf1 eeca710e8d2745d0b60ea2f7f540a2f5 5c7ad8486ff3482d8dc72dd4d09bdcf1--eeca710e8d2745d0b60ea2f7f540a2f5 e11e7f99aadb4828946b5f7740d8882d eeca710e8d2745d0b60ea2f7f540a2f5--e11e7f99aadb4828946b5f7740d8882d c59113fdd53d4853bc23f458c4f037de e11e7f99aadb4828946b5f7740d8882d--c59113fdd53d4853bc23f458c4f037de 3c8c629a5f1d4a6eb724fbea77b98807 c59113fdd53d4853bc23f458c4f037de--3c8c629a5f1d4a6eb724fbea77b98807 15365db8be8b461abf35822e8ed43be2 3c8c629a5f1d4a6eb724fbea77b98807--15365db8be8b461abf35822e8ed43be2 98f99ede405a4b96b79863d3f3ebbf33 15365db8be8b461abf35822e8ed43be2--98f99ede405a4b96b79863d3f3ebbf33 28c3872db2d6421cbd2e5595692ff282 98f99ede405a4b96b79863d3f3ebbf33--28c3872db2d6421cbd2e5595692ff282 e890518efd70490893b71a4c30eea174 28c3872db2d6421cbd2e5595692ff282--e890518efd70490893b71a4c30eea174 44a2ba2e97ff4e24b2f485a02f6541dc e890518efd70490893b71a4c30eea174--44a2ba2e97ff4e24b2f485a02f6541dc 817317ac9dc54a029726e13fc4466a43 44a2ba2e97ff4e24b2f485a02f6541dc--817317ac9dc54a029726e13fc4466a43 a27ce8a21e7c46459f0b96a97bf2ebb7 817317ac9dc54a029726e13fc4466a43--a27ce8a21e7c46459f0b96a97bf2ebb7 bef26097682847798d449a4e8ca37185 a27ce8a21e7c46459f0b96a97bf2ebb7--bef26097682847798d449a4e8ca37185 3fe098f004584afa9c5dad1eff121064 bef26097682847798d449a4e8ca37185--3fe098f004584afa9c5dad1eff121064 3ea13d8e306a44869251628637515ed6 3fe098f004584afa9c5dad1eff121064--3ea13d8e306a44869251628637515ed6 8e5c482009d548659466639db28fb989 3ea13d8e306a44869251628637515ed6--8e5c482009d548659466639db28fb989 27b589670d5c4f559295794ed20c2241 8e5c482009d548659466639db28fb989--27b589670d5c4f559295794ed20c2241 e10bb14cf3a2443faca10f3d32e78a00 27b589670d5c4f559295794ed20c2241--e10bb14cf3a2443faca10f3d32e78a00 f3c26f475515433f93c892831c379326 e10bb14cf3a2443faca10f3d32e78a00--f3c26f475515433f93c892831c379326 42fdf980ea314a9e9690779a7fca4ce4 f3c26f475515433f93c892831c379326--42fdf980ea314a9e9690779a7fca4ce4 e7fad9fc98b94b79a1c248c2d2d810be 42fdf980ea314a9e9690779a7fca4ce4--e7fad9fc98b94b79a1c248c2d2d810be 432226eb557d4935a918bee6394a752d e7fad9fc98b94b79a1c248c2d2d810be--432226eb557d4935a918bee6394a752d e9a58487029e4414aa2759903f4854af 432226eb557d4935a918bee6394a752d--e9a58487029e4414aa2759903f4854af 45eb8a4b71ae4780a493f4e49775dcc6 e9a58487029e4414aa2759903f4854af--45eb8a4b71ae4780a493f4e49775dcc6 24be5a4319f2459f95b3adf7b7980f8a 45eb8a4b71ae4780a493f4e49775dcc6--24be5a4319f2459f95b3adf7b7980f8a 835bc475640f457c83bfd145d2336201 24be5a4319f2459f95b3adf7b7980f8a--835bc475640f457c83bfd145d2336201 c94620fc997b4cf4b1ea2ca2d19f8e6b 835bc475640f457c83bfd145d2336201--c94620fc997b4cf4b1ea2ca2d19f8e6b 0a6fc3d5aee24c0e810ec3952173f937 c94620fc997b4cf4b1ea2ca2d19f8e6b--0a6fc3d5aee24c0e810ec3952173f937 6ae56be35c304efaba752a4a1c600246 0a6fc3d5aee24c0e810ec3952173f937--6ae56be35c304efaba752a4a1c600246 4e74c42dd0294967b4c0c7f472f0b300 6ae56be35c304efaba752a4a1c600246--4e74c42dd0294967b4c0c7f472f0b300 3ae88b49435b41e0a36b4c1dc0628102 4e74c42dd0294967b4c0c7f472f0b300--3ae88b49435b41e0a36b4c1dc0628102 0f81c27892c74a0cb9532fca0c9ec830 3ae88b49435b41e0a36b4c1dc0628102--0f81c27892c74a0cb9532fca0c9ec830 639c043aeff34343ba87a385ca3af500 0f81c27892c74a0cb9532fca0c9ec830--639c043aeff34343ba87a385ca3af500 2bdb6f43536c474e9f1229793556621b 639c043aeff34343ba87a385ca3af500--2bdb6f43536c474e9f1229793556621b 51680cf65c824045bbc5f441b227828f 2bdb6f43536c474e9f1229793556621b--51680cf65c824045bbc5f441b227828f f04508c2698e4b09bfdffb7c8f3be4f0 51680cf65c824045bbc5f441b227828f--f04508c2698e4b09bfdffb7c8f3be4f0 eaeacd28d2f140e194aab894c0ca578a f04508c2698e4b09bfdffb7c8f3be4f0--eaeacd28d2f140e194aab894c0ca578a e2848880b5e04c729b0069739eae8ae7 eaeacd28d2f140e194aab894c0ca578a--e2848880b5e04c729b0069739eae8ae7 4bfd06e2b61641ebb4a445bf9e9b99ad e2848880b5e04c729b0069739eae8ae7--4bfd06e2b61641ebb4a445bf9e9b99ad 5753fd77635245b9a6e9679d05f9a2a1 4bfd06e2b61641ebb4a445bf9e9b99ad--5753fd77635245b9a6e9679d05f9a2a1 1600f15042624994be27751bb4c98b35 5753fd77635245b9a6e9679d05f9a2a1--1600f15042624994be27751bb4c98b35 6d524740e6be4a3b94f0b3e73125db68 1600f15042624994be27751bb4c98b35--6d524740e6be4a3b94f0b3e73125db68 ce688f746314460a96055863cecce886 6d524740e6be4a3b94f0b3e73125db68--ce688f746314460a96055863cecce886 a73cfa89f2df4e568de818445f62c831 ce688f746314460a96055863cecce886--a73cfa89f2df4e568de818445f62c831 5e2ab2f728e84c07bfa63a549ccb1898 a73cfa89f2df4e568de818445f62c831--5e2ab2f728e84c07bfa63a549ccb1898 b19d055cb0b743e180ca2bf5e9b0a567 5e2ab2f728e84c07bfa63a549ccb1898--b19d055cb0b743e180ca2bf5e9b0a567 fc94aca713df499dba7d6d1eb33cfdfc b19d055cb0b743e180ca2bf5e9b0a567--fc94aca713df499dba7d6d1eb33cfdfc 7215fdc25c7e4d26b0580b8cc47442cb fc94aca713df499dba7d6d1eb33cfdfc--7215fdc25c7e4d26b0580b8cc47442cb 8e5169a836be4e16bee80cb4962e18a5 7215fdc25c7e4d26b0580b8cc47442cb--8e5169a836be4e16bee80cb4962e18a5 34605fe9eba94246aea681e4b7f0e18f 8e5169a836be4e16bee80cb4962e18a5--34605fe9eba94246aea681e4b7f0e18f c28e1ca1a75243af936c1531ab3d4522 34605fe9eba94246aea681e4b7f0e18f--c28e1ca1a75243af936c1531ab3d4522 59039b70c4b342b49eda069557420bc5 c28e1ca1a75243af936c1531ab3d4522--59039b70c4b342b49eda069557420bc5 9df5b4ced87445d69560197492909a38 59039b70c4b342b49eda069557420bc5--9df5b4ced87445d69560197492909a38 2a24eeb53a8e4b2fb61d0efda13d0309 9df5b4ced87445d69560197492909a38--2a24eeb53a8e4b2fb61d0efda13d0309 8226d027f672452a870ed1bc0da77bbf 2a24eeb53a8e4b2fb61d0efda13d0309--8226d027f672452a870ed1bc0da77bbf 461b9d59b80141c49305e12d69b4179d 8226d027f672452a870ed1bc0da77bbf--461b9d59b80141c49305e12d69b4179d dc3cb192b38b458a9bb03d5c283f0288 461b9d59b80141c49305e12d69b4179d--dc3cb192b38b458a9bb03d5c283f0288 b05d445ffe9d428b8fe134dda465c6fa dc3cb192b38b458a9bb03d5c283f0288--b05d445ffe9d428b8fe134dda465c6fa 1c7ee0ba5778465485d298b2b07816c5 b05d445ffe9d428b8fe134dda465c6fa--1c7ee0ba5778465485d298b2b07816c5 9eeace8b06d646f9a247e6bce06d0c6f 1c7ee0ba5778465485d298b2b07816c5--9eeace8b06d646f9a247e6bce06d0c6f b3ee609e54b248e08db516ca47a915cf 9eeace8b06d646f9a247e6bce06d0c6f--b3ee609e54b248e08db516ca47a915cf f87f5ecd9aa74f17ac2c1ace93d2eeff b3ee609e54b248e08db516ca47a915cf--f87f5ecd9aa74f17ac2c1ace93d2eeff 8c622e0f63ee4e389c2c76d82b40547b f87f5ecd9aa74f17ac2c1ace93d2eeff--8c622e0f63ee4e389c2c76d82b40547b b0bfae08fd5346a9b64ad359f94ea3a0 8c622e0f63ee4e389c2c76d82b40547b--b0bfae08fd5346a9b64ad359f94ea3a0 6b990c28a27d4f1b9d6986ef0ff2ec2c b0bfae08fd5346a9b64ad359f94ea3a0--6b990c28a27d4f1b9d6986ef0ff2ec2c a955fbf5dc5a4134a137c0cc0a61def9 6b990c28a27d4f1b9d6986ef0ff2ec2c--a955fbf5dc5a4134a137c0cc0a61def9 b522b0271e6b4f639d9a449256cd33f8 a955fbf5dc5a4134a137c0cc0a61def9--b522b0271e6b4f639d9a449256cd33f8 2cdab29a16b845f78cc31631237943b6 b522b0271e6b4f639d9a449256cd33f8--2cdab29a16b845f78cc31631237943b6 429da5f924cf40b8b112c14361fa7bd5 2cdab29a16b845f78cc31631237943b6--429da5f924cf40b8b112c14361fa7bd5 b8e699e2fdba45ef877680c3ad2cb58b 429da5f924cf40b8b112c14361fa7bd5--b8e699e2fdba45ef877680c3ad2cb58b 202529ec585a45c2b0d51edd5bb3b512 b8e699e2fdba45ef877680c3ad2cb58b--202529ec585a45c2b0d51edd5bb3b512 7486513eceeb434bb9c642c436946021 RX(b10) 202529ec585a45c2b0d51edd5bb3b512--7486513eceeb434bb9c642c436946021 8805db9c18fe41cda036f02973fc1e1c 7486513eceeb434bb9c642c436946021--8805db9c18fe41cda036f02973fc1e1c 9a50ad2a250c4b61a5344eb859a6af93 26e24cdb7fde4881b9fc2dcbe36a644f X 2a3c97cdc0104553a81819da4c308d01--26e24cdb7fde4881b9fc2dcbe36a644f 9487c44d15ba4e64ad5d3db70198b21e 2 26e24cdb7fde4881b9fc2dcbe36a644f--a10dd333cc614c67adc79abbe4dab689 4a873f1d5479474e943d41cc01259e81 26e24cdb7fde4881b9fc2dcbe36a644f--4a873f1d5479474e943d41cc01259e81 61d1622452b94172bb2eeecba6b4dbae 4a873f1d5479474e943d41cc01259e81--61d1622452b94172bb2eeecba6b4dbae 2c34894012e849daa686f081600da28f 61d1622452b94172bb2eeecba6b4dbae--2c34894012e849daa686f081600da28f f4e45617e24d46bcbffc11b654591f61 2c34894012e849daa686f081600da28f--f4e45617e24d46bcbffc11b654591f61 0806bf7cd9ad4bdb97a72ee1945b7e75 f4e45617e24d46bcbffc11b654591f61--0806bf7cd9ad4bdb97a72ee1945b7e75 aef496d09d1646e3a1b647c0d3b50205 0806bf7cd9ad4bdb97a72ee1945b7e75--aef496d09d1646e3a1b647c0d3b50205 c597233f79454d93a5e8aa8ba34f22f9 aef496d09d1646e3a1b647c0d3b50205--c597233f79454d93a5e8aa8ba34f22f9 7b38c16d0a484c50816488ef64b3f10c c597233f79454d93a5e8aa8ba34f22f9--7b38c16d0a484c50816488ef64b3f10c 714e9897b88d42909e4d7b7cfa3205d2 7b38c16d0a484c50816488ef64b3f10c--714e9897b88d42909e4d7b7cfa3205d2 788a78a03d9e407f973e05d176ed4616 714e9897b88d42909e4d7b7cfa3205d2--788a78a03d9e407f973e05d176ed4616 00c74791bbd74d56a75b9df292fa0d64 788a78a03d9e407f973e05d176ed4616--00c74791bbd74d56a75b9df292fa0d64 06cd9a42f7e249eba779ec9079d6d523 00c74791bbd74d56a75b9df292fa0d64--06cd9a42f7e249eba779ec9079d6d523 be79b49ff1da461bae89e3c87e90c422 06cd9a42f7e249eba779ec9079d6d523--be79b49ff1da461bae89e3c87e90c422 53913886f3454bcfb121d0b875da1899 X be79b49ff1da461bae89e3c87e90c422--53913886f3454bcfb121d0b875da1899 53913886f3454bcfb121d0b875da1899--e4b5e70c311340f5a238a4f0e93c63d6 65a84c1c30d747acbf26fe63b38999e5 X 53913886f3454bcfb121d0b875da1899--65a84c1c30d747acbf26fe63b38999e5 65a84c1c30d747acbf26fe63b38999e5--61eb772a03764fc2b0b8c17699cd283e 79e34ca650484fbb887cb691362ed00e 65a84c1c30d747acbf26fe63b38999e5--79e34ca650484fbb887cb691362ed00e 6da8e85066034fc3900c1b8e75e49871 79e34ca650484fbb887cb691362ed00e--6da8e85066034fc3900c1b8e75e49871 9c032983910f46f088e8463d7e4d279c 6da8e85066034fc3900c1b8e75e49871--9c032983910f46f088e8463d7e4d279c 9429683281884722accff4bb1cde5e5f X 9c032983910f46f088e8463d7e4d279c--9429683281884722accff4bb1cde5e5f 9429683281884722accff4bb1cde5e5f--b169d06a76ae418ea2f537a92042fddf d7208486b1d943d8ba06231cef79e861 X 9429683281884722accff4bb1cde5e5f--d7208486b1d943d8ba06231cef79e861 d7208486b1d943d8ba06231cef79e861--6aadd60147dd445f88b8db5c0e4421ec b0aac5b5b90d464fb3e9a115ba2e5b95 d7208486b1d943d8ba06231cef79e861--b0aac5b5b90d464fb3e9a115ba2e5b95 b19631f1adaf4e228c743b80cca9e036 b0aac5b5b90d464fb3e9a115ba2e5b95--b19631f1adaf4e228c743b80cca9e036 557e53583bd74fb588372e7ab604edad b19631f1adaf4e228c743b80cca9e036--557e53583bd74fb588372e7ab604edad 746afbb17d40484aa60596551d3d69b9 557e53583bd74fb588372e7ab604edad--746afbb17d40484aa60596551d3d69b9 530bd985a7a4448da6a30d36699fb172 746afbb17d40484aa60596551d3d69b9--530bd985a7a4448da6a30d36699fb172 8659fdb9ece647cca658ad651a72cc33 X 530bd985a7a4448da6a30d36699fb172--8659fdb9ece647cca658ad651a72cc33 8659fdb9ece647cca658ad651a72cc33--5e1f3ab995ff4ce8a0c0c9ac349fd364 5c08585c035f4a9c9af94ef9f54eb4ad X 8659fdb9ece647cca658ad651a72cc33--5c08585c035f4a9c9af94ef9f54eb4ad 5c08585c035f4a9c9af94ef9f54eb4ad--6bc290286c024da2b8082757d31c85fc 49ba1af1c02b4f6db4da5b0a0c616981 5c08585c035f4a9c9af94ef9f54eb4ad--49ba1af1c02b4f6db4da5b0a0c616981 b00e488e19794098abd5dc422dd02217 49ba1af1c02b4f6db4da5b0a0c616981--b00e488e19794098abd5dc422dd02217 0e43bcd7b84947189252da480d5c8316 b00e488e19794098abd5dc422dd02217--0e43bcd7b84947189252da480d5c8316 dc024e09a01147a89d044f3dc8fe42d4 0e43bcd7b84947189252da480d5c8316--dc024e09a01147a89d044f3dc8fe42d4 eecb0eeca63d413fa7d3365c38b5dc04 dc024e09a01147a89d044f3dc8fe42d4--eecb0eeca63d413fa7d3365c38b5dc04 d7f4153d81254327abc4a2985daeeba1 eecb0eeca63d413fa7d3365c38b5dc04--d7f4153d81254327abc4a2985daeeba1 f9f432814cd14bcf9a9158a1bd062c6c d7f4153d81254327abc4a2985daeeba1--f9f432814cd14bcf9a9158a1bd062c6c e4adb832a7d940dc87895f46fe6a16fc X f9f432814cd14bcf9a9158a1bd062c6c--e4adb832a7d940dc87895f46fe6a16fc e4adb832a7d940dc87895f46fe6a16fc--51cdd5165dfb4a30a23d2bdfad391c49 d76c446fca154523bcc2b336c4ab0afe X e4adb832a7d940dc87895f46fe6a16fc--d76c446fca154523bcc2b336c4ab0afe d76c446fca154523bcc2b336c4ab0afe--23da6a34777d481b8bfb50624258db07 759a59ed2d3d4e8288bd83713031d1e8 d76c446fca154523bcc2b336c4ab0afe--759a59ed2d3d4e8288bd83713031d1e8 81381168df6c40699663b171f94a1d27 759a59ed2d3d4e8288bd83713031d1e8--81381168df6c40699663b171f94a1d27 a390a6afb0eb45b6969afd7134fea256 81381168df6c40699663b171f94a1d27--a390a6afb0eb45b6969afd7134fea256 befc8a0ed978474f9a8d3f896f5a6e3f a390a6afb0eb45b6969afd7134fea256--befc8a0ed978474f9a8d3f896f5a6e3f fb8ff8f91f844bdca65c08a56e019b83 befc8a0ed978474f9a8d3f896f5a6e3f--fb8ff8f91f844bdca65c08a56e019b83 ead723421ddf42bb80d348eae79c74b6 fb8ff8f91f844bdca65c08a56e019b83--ead723421ddf42bb80d348eae79c74b6 c6b0b714d5fd491f95536d8e8c1071ec ead723421ddf42bb80d348eae79c74b6--c6b0b714d5fd491f95536d8e8c1071ec f045c297c58346288fc73ac0a7f1da69 c6b0b714d5fd491f95536d8e8c1071ec--f045c297c58346288fc73ac0a7f1da69 3d023898012348bb9799639d0fe42e21 f045c297c58346288fc73ac0a7f1da69--3d023898012348bb9799639d0fe42e21 128dd78207c344a581603d44511ffdc6 3d023898012348bb9799639d0fe42e21--128dd78207c344a581603d44511ffdc6 c662f4b4152e4a79b52c8082287e38fe 128dd78207c344a581603d44511ffdc6--c662f4b4152e4a79b52c8082287e38fe c3cab04170654efeb0832da9626443e4 X c662f4b4152e4a79b52c8082287e38fe--c3cab04170654efeb0832da9626443e4 c3cab04170654efeb0832da9626443e4--5298c572cddc4f38a745a967150a6345 97e91c0752704b279ec36d99be1704c0 c3cab04170654efeb0832da9626443e4--97e91c0752704b279ec36d99be1704c0 69d5a86e509c40ae9778deb6770d572b 97e91c0752704b279ec36d99be1704c0--69d5a86e509c40ae9778deb6770d572b 666acb1b57664b76a494179e1faa0e4f 69d5a86e509c40ae9778deb6770d572b--666acb1b57664b76a494179e1faa0e4f 3bf4f30819854a2e9f87e18e44f6928e 666acb1b57664b76a494179e1faa0e4f--3bf4f30819854a2e9f87e18e44f6928e 3cc1a3da9a40410e968ff6cbd7f0d073 3bf4f30819854a2e9f87e18e44f6928e--3cc1a3da9a40410e968ff6cbd7f0d073 3c1cf74d096b44aa80f04b7657f57e50 3cc1a3da9a40410e968ff6cbd7f0d073--3c1cf74d096b44aa80f04b7657f57e50 b73e63761b2c482ab8f31f6c223a98ba 3c1cf74d096b44aa80f04b7657f57e50--b73e63761b2c482ab8f31f6c223a98ba 9907b78381374f5da26d2f04e720558c b73e63761b2c482ab8f31f6c223a98ba--9907b78381374f5da26d2f04e720558c cf46f33c778242ef84a02cbf95866185 9907b78381374f5da26d2f04e720558c--cf46f33c778242ef84a02cbf95866185 a9faca53e8624b08a2b8e4662566544c cf46f33c778242ef84a02cbf95866185--a9faca53e8624b08a2b8e4662566544c 77725c9ddab442d2933cc2dcf4fafd78 a9faca53e8624b08a2b8e4662566544c--77725c9ddab442d2933cc2dcf4fafd78 6b64f8bcf95449b8bfdcdd1dabe1bcce 77725c9ddab442d2933cc2dcf4fafd78--6b64f8bcf95449b8bfdcdd1dabe1bcce f00509eb289b4320a01fffd5de86bf1d 6b64f8bcf95449b8bfdcdd1dabe1bcce--f00509eb289b4320a01fffd5de86bf1d 328d55867910448395fad64787a48168 f00509eb289b4320a01fffd5de86bf1d--328d55867910448395fad64787a48168 f8298effcaf14b2abbb486e44f0fc5f3 328d55867910448395fad64787a48168--f8298effcaf14b2abbb486e44f0fc5f3 1992cff3897644f6b9b4545e307066ce f8298effcaf14b2abbb486e44f0fc5f3--1992cff3897644f6b9b4545e307066ce 07e8bbee59164ff1a270cd8d2e5800e5 1992cff3897644f6b9b4545e307066ce--07e8bbee59164ff1a270cd8d2e5800e5 515addcdbe9741d68f7bb5d41744c22e 07e8bbee59164ff1a270cd8d2e5800e5--515addcdbe9741d68f7bb5d41744c22e f930e738cff44df78285af9113bc472c 515addcdbe9741d68f7bb5d41744c22e--f930e738cff44df78285af9113bc472c b43831d81719404e85d342254ccef94b f930e738cff44df78285af9113bc472c--b43831d81719404e85d342254ccef94b c000b0a1f4dc457b98bb1cec381dfc7b b43831d81719404e85d342254ccef94b--c000b0a1f4dc457b98bb1cec381dfc7b 472cf5471c864ab1bcacf45fe7437eba c000b0a1f4dc457b98bb1cec381dfc7b--472cf5471c864ab1bcacf45fe7437eba 532878bf7f9c4d55bd4571146829ef05 472cf5471c864ab1bcacf45fe7437eba--532878bf7f9c4d55bd4571146829ef05 728fcf32a56142dd80bd81ac6a452fa1 532878bf7f9c4d55bd4571146829ef05--728fcf32a56142dd80bd81ac6a452fa1 ebd14bfba6254caa8ec3aebca1da5ad1 728fcf32a56142dd80bd81ac6a452fa1--ebd14bfba6254caa8ec3aebca1da5ad1 d4abc89faa4a43359ff0617d8c8d6681 ebd14bfba6254caa8ec3aebca1da5ad1--d4abc89faa4a43359ff0617d8c8d6681 c6f04e3357ad4b168ac50fce89bd1eae d4abc89faa4a43359ff0617d8c8d6681--c6f04e3357ad4b168ac50fce89bd1eae 233e3c798727456d89f920e6dd62ceb3 c6f04e3357ad4b168ac50fce89bd1eae--233e3c798727456d89f920e6dd62ceb3 ca965ce4593b4a72bb462c1b36fe007a 233e3c798727456d89f920e6dd62ceb3--ca965ce4593b4a72bb462c1b36fe007a 2b648ccafde34d7db1a6ef0998e7da94 ca965ce4593b4a72bb462c1b36fe007a--2b648ccafde34d7db1a6ef0998e7da94 3aa3509c637c48ea8350f1cc115102a4 2b648ccafde34d7db1a6ef0998e7da94--3aa3509c637c48ea8350f1cc115102a4 52424f9cfc134c04871c9ad2d2e25114 3aa3509c637c48ea8350f1cc115102a4--52424f9cfc134c04871c9ad2d2e25114 1b1cb5482b354a4ca202362eab204c29 52424f9cfc134c04871c9ad2d2e25114--1b1cb5482b354a4ca202362eab204c29 fb20bb48bfa941bb810ddbbe1a4a608d 1b1cb5482b354a4ca202362eab204c29--fb20bb48bfa941bb810ddbbe1a4a608d dd95803a9a814d61b3cbe4f73e627d16 fb20bb48bfa941bb810ddbbe1a4a608d--dd95803a9a814d61b3cbe4f73e627d16 dd4d745182be4ae8b3a358623e4d87ec dd95803a9a814d61b3cbe4f73e627d16--dd4d745182be4ae8b3a358623e4d87ec c74a707f42904e7585d083a0e5b3d076 dd4d745182be4ae8b3a358623e4d87ec--c74a707f42904e7585d083a0e5b3d076 f22f0dae7e494273ac50b52b70638afb c74a707f42904e7585d083a0e5b3d076--f22f0dae7e494273ac50b52b70638afb 4bd2bf5b3de8499d825c636126d299c4 f22f0dae7e494273ac50b52b70638afb--4bd2bf5b3de8499d825c636126d299c4 2281e7d46fa341f8b878fb5926d2d520 4bd2bf5b3de8499d825c636126d299c4--2281e7d46fa341f8b878fb5926d2d520 adefae7c7f6645378204bd8ccb15eb80 2281e7d46fa341f8b878fb5926d2d520--adefae7c7f6645378204bd8ccb15eb80 ad0c244de1b54db689ce046d8b34ffa5 adefae7c7f6645378204bd8ccb15eb80--ad0c244de1b54db689ce046d8b34ffa5 ab5add6af6df4768a5f29153f4471262 ad0c244de1b54db689ce046d8b34ffa5--ab5add6af6df4768a5f29153f4471262 03a5993d9c614678b8cab1625ddb3ee1 ab5add6af6df4768a5f29153f4471262--03a5993d9c614678b8cab1625ddb3ee1 d03f8e4e96194fa8b300d42e9035c504 03a5993d9c614678b8cab1625ddb3ee1--d03f8e4e96194fa8b300d42e9035c504 6d21d64eeeea4603b86c227dd54bc740 d03f8e4e96194fa8b300d42e9035c504--6d21d64eeeea4603b86c227dd54bc740 72090a0d028d4509b213e3cec17a7e59 6d21d64eeeea4603b86c227dd54bc740--72090a0d028d4509b213e3cec17a7e59 49fc8b9343a448c18d10c14dc040a100 72090a0d028d4509b213e3cec17a7e59--49fc8b9343a448c18d10c14dc040a100 eefafd03b0874eb69af80eb0389b47ca 49fc8b9343a448c18d10c14dc040a100--eefafd03b0874eb69af80eb0389b47ca 84e35e77e2144d38adc74af7a9af31af eefafd03b0874eb69af80eb0389b47ca--84e35e77e2144d38adc74af7a9af31af a3aa99025775449a875bb0d72963b70e 84e35e77e2144d38adc74af7a9af31af--a3aa99025775449a875bb0d72963b70e fa738b12507649bf946c8481c043d0c9 a3aa99025775449a875bb0d72963b70e--fa738b12507649bf946c8481c043d0c9 592ab9762a6b40daa9d1b6c6f4b882d8 fa738b12507649bf946c8481c043d0c9--592ab9762a6b40daa9d1b6c6f4b882d8 e929486250a14f89b9d50cd8ec076a04 592ab9762a6b40daa9d1b6c6f4b882d8--e929486250a14f89b9d50cd8ec076a04 9e84ac63a830486e9138165f0bdc0daa e929486250a14f89b9d50cd8ec076a04--9e84ac63a830486e9138165f0bdc0daa 74e747489b154f3f8df39a9bfcd98a93 9e84ac63a830486e9138165f0bdc0daa--74e747489b154f3f8df39a9bfcd98a93 d65c25da591d48c3b2beb44e3d7a8c6f 74e747489b154f3f8df39a9bfcd98a93--d65c25da591d48c3b2beb44e3d7a8c6f aa837219f43943b2b98a8120c0a8e236 d65c25da591d48c3b2beb44e3d7a8c6f--aa837219f43943b2b98a8120c0a8e236 c6c6e47eee5449bc9af7792077ed16a0 aa837219f43943b2b98a8120c0a8e236--c6c6e47eee5449bc9af7792077ed16a0 5914b6c5e30643f1bea1af4f0a89afd2 c6c6e47eee5449bc9af7792077ed16a0--5914b6c5e30643f1bea1af4f0a89afd2 078d4889ef80455981d310b4bf26952d 5914b6c5e30643f1bea1af4f0a89afd2--078d4889ef80455981d310b4bf26952d 6af02ca4f60848838bde1450440d7d98 078d4889ef80455981d310b4bf26952d--6af02ca4f60848838bde1450440d7d98 2191d9c5432243dca84f17cb69aeb074 6af02ca4f60848838bde1450440d7d98--2191d9c5432243dca84f17cb69aeb074 d9c44d033c69443488e8a695a2576ada 2191d9c5432243dca84f17cb69aeb074--d9c44d033c69443488e8a695a2576ada 8a5f3f4391104bd187008a9d618dd414 d9c44d033c69443488e8a695a2576ada--8a5f3f4391104bd187008a9d618dd414 ec72f97ae5c14aa599084b04040e3c4a 8a5f3f4391104bd187008a9d618dd414--ec72f97ae5c14aa599084b04040e3c4a e02deaf323224552a934d2e91effb1dd ec72f97ae5c14aa599084b04040e3c4a--e02deaf323224552a934d2e91effb1dd d81b4e54c9914cd7af43d632d1de2bd7 e02deaf323224552a934d2e91effb1dd--d81b4e54c9914cd7af43d632d1de2bd7 5c822d4176f14a28a4e478d86fde4338 d81b4e54c9914cd7af43d632d1de2bd7--5c822d4176f14a28a4e478d86fde4338 5b163d3091984e5c970585c548d22644 5c822d4176f14a28a4e478d86fde4338--5b163d3091984e5c970585c548d22644 5fe6b9eab5544fc4adda0dc9103d3bef RX(b01) 5b163d3091984e5c970585c548d22644--5fe6b9eab5544fc4adda0dc9103d3bef 3ba53c3a8c6449a5961322925e01e09c X 5fe6b9eab5544fc4adda0dc9103d3bef--3ba53c3a8c6449a5961322925e01e09c 3ba53c3a8c6449a5961322925e01e09c--fb2ba6b247c84372b773283cc75d009f edffe11fc29b4bd6a34078fc382cfc50 3ba53c3a8c6449a5961322925e01e09c--edffe11fc29b4bd6a34078fc382cfc50 2513929094b1450081b54cb563ba38db edffe11fc29b4bd6a34078fc382cfc50--2513929094b1450081b54cb563ba38db 572574e971784e38b4d4111b693f0194 2513929094b1450081b54cb563ba38db--572574e971784e38b4d4111b693f0194 7d9b2e83758a442283d7b5735005b555 572574e971784e38b4d4111b693f0194--7d9b2e83758a442283d7b5735005b555 e10e1905a9c741b2be51b87477fbe2c0 7d9b2e83758a442283d7b5735005b555--e10e1905a9c741b2be51b87477fbe2c0 0a7f5d820d0448c9ae66c01e6fbc2f27 e10e1905a9c741b2be51b87477fbe2c0--0a7f5d820d0448c9ae66c01e6fbc2f27 b66c72fb79464763b4f78d6f132d8f38 0a7f5d820d0448c9ae66c01e6fbc2f27--b66c72fb79464763b4f78d6f132d8f38 1790166ae8cc4b5794b179503d638927 b66c72fb79464763b4f78d6f132d8f38--1790166ae8cc4b5794b179503d638927 58d6b6e6fa524738be6c187639da32a1 1790166ae8cc4b5794b179503d638927--58d6b6e6fa524738be6c187639da32a1 a0dce188250c4bad8571fc782a5f154f 58d6b6e6fa524738be6c187639da32a1--a0dce188250c4bad8571fc782a5f154f a8e05995a8864cdf8c55f3ccb88b2d31 a0dce188250c4bad8571fc782a5f154f--a8e05995a8864cdf8c55f3ccb88b2d31 583aa994920f4c8b97812e43fa960057 a8e05995a8864cdf8c55f3ccb88b2d31--583aa994920f4c8b97812e43fa960057 08b1e0c9ed2d4f77a45aea7eaa98fa11 583aa994920f4c8b97812e43fa960057--08b1e0c9ed2d4f77a45aea7eaa98fa11 a7596a4fba8e4df5b081f2c7932d7e39 X 08b1e0c9ed2d4f77a45aea7eaa98fa11--a7596a4fba8e4df5b081f2c7932d7e39 a7596a4fba8e4df5b081f2c7932d7e39--3821e96d1b5a467a8e94bd31e6e9a257 95553aa6e751467f87dbca748d1610de X a7596a4fba8e4df5b081f2c7932d7e39--95553aa6e751467f87dbca748d1610de 95553aa6e751467f87dbca748d1610de--56893468e2e149069343ccd783f0e2cb b50472fb67004e1e8f789921ae8bc106 95553aa6e751467f87dbca748d1610de--b50472fb67004e1e8f789921ae8bc106 e10ba1aabdce400883f5828bb814ca8e b50472fb67004e1e8f789921ae8bc106--e10ba1aabdce400883f5828bb814ca8e 5713d149257743eda723bdd2011d264f e10ba1aabdce400883f5828bb814ca8e--5713d149257743eda723bdd2011d264f b0401375f32b412ba50805c9b8e044e1 X 5713d149257743eda723bdd2011d264f--b0401375f32b412ba50805c9b8e044e1 b0401375f32b412ba50805c9b8e044e1--b5528ddb43a9419b92dc7f7183f9c2f7 386e5be58be64b619cf3985fa4830b42 X b0401375f32b412ba50805c9b8e044e1--386e5be58be64b619cf3985fa4830b42 386e5be58be64b619cf3985fa4830b42--ffae6952b7134f0aba819539f2714d2a 2920c7e912bb4d248c5ab53709df2881 386e5be58be64b619cf3985fa4830b42--2920c7e912bb4d248c5ab53709df2881 275f329923664c5b8dc47978c7e2ea1f 2920c7e912bb4d248c5ab53709df2881--275f329923664c5b8dc47978c7e2ea1f 6b29f00c325e4ec3bd96a4c427e09b14 275f329923664c5b8dc47978c7e2ea1f--6b29f00c325e4ec3bd96a4c427e09b14 dc633dd98cf04523b139b4112e63e955 6b29f00c325e4ec3bd96a4c427e09b14--dc633dd98cf04523b139b4112e63e955 3fc1e07e8d4240619bb73d7c11802680 dc633dd98cf04523b139b4112e63e955--3fc1e07e8d4240619bb73d7c11802680 c23417d6707b4fc3ac7e5a9de940eb00 X 3fc1e07e8d4240619bb73d7c11802680--c23417d6707b4fc3ac7e5a9de940eb00 c23417d6707b4fc3ac7e5a9de940eb00--7ee3f84183d648f1912e5fd846d81932 e452ee6b93aa44348334442ea095f716 X c23417d6707b4fc3ac7e5a9de940eb00--e452ee6b93aa44348334442ea095f716 e452ee6b93aa44348334442ea095f716--60f6e6fb79db40f0908603181c9bc34b 4d0d1832f43a417eab4e5b5d3f7b985c e452ee6b93aa44348334442ea095f716--4d0d1832f43a417eab4e5b5d3f7b985c 2325111d49ad46aba1b8b972007a2024 4d0d1832f43a417eab4e5b5d3f7b985c--2325111d49ad46aba1b8b972007a2024 25cec333165b475c8dbf30562f594e3b 2325111d49ad46aba1b8b972007a2024--25cec333165b475c8dbf30562f594e3b 439ee70c80a042a397f5663c4899a758 25cec333165b475c8dbf30562f594e3b--439ee70c80a042a397f5663c4899a758 ea34057793b94b23aca1d39cd1bb070a 439ee70c80a042a397f5663c4899a758--ea34057793b94b23aca1d39cd1bb070a f8160dc37a27430493583f669ecbbab1 ea34057793b94b23aca1d39cd1bb070a--f8160dc37a27430493583f669ecbbab1 d586d2b1708b4763bd513d30e3b4904a f8160dc37a27430493583f669ecbbab1--d586d2b1708b4763bd513d30e3b4904a 00ed0cb32e3d4e2392167fd015c21730 X d586d2b1708b4763bd513d30e3b4904a--00ed0cb32e3d4e2392167fd015c21730 00ed0cb32e3d4e2392167fd015c21730--de166c76b35f4fdb8cd63236d8f63c80 2db5adbcf8f543ff8dd5400ff4776b90 X 00ed0cb32e3d4e2392167fd015c21730--2db5adbcf8f543ff8dd5400ff4776b90 2db5adbcf8f543ff8dd5400ff4776b90--69140ad05710437faacf69f68a1bf2b2 ce7341d312f74fdb942b7f12382e9807 2db5adbcf8f543ff8dd5400ff4776b90--ce7341d312f74fdb942b7f12382e9807 35c8ff85d3c043d8a018aeea5d1c6718 ce7341d312f74fdb942b7f12382e9807--35c8ff85d3c043d8a018aeea5d1c6718 84c9f89015e547d992afffdafcda3245 35c8ff85d3c043d8a018aeea5d1c6718--84c9f89015e547d992afffdafcda3245 f66bcfd91e3648c48ad21ca691491282 84c9f89015e547d992afffdafcda3245--f66bcfd91e3648c48ad21ca691491282 48303d01e317481281e79ba66ee76b84 f66bcfd91e3648c48ad21ca691491282--48303d01e317481281e79ba66ee76b84 f7f8f563e2174cc4b038d7623bf70c1d 48303d01e317481281e79ba66ee76b84--f7f8f563e2174cc4b038d7623bf70c1d 74e8eec29e3b48fabc8d64c97d37f032 f7f8f563e2174cc4b038d7623bf70c1d--74e8eec29e3b48fabc8d64c97d37f032 da9ba790231348ab8a24616d7f4009d7 74e8eec29e3b48fabc8d64c97d37f032--da9ba790231348ab8a24616d7f4009d7 160d0fbdc96d4b0e8296e13b6e4b58c6 da9ba790231348ab8a24616d7f4009d7--160d0fbdc96d4b0e8296e13b6e4b58c6 7cb5f5ff0602476b954c6e7dae15208c 160d0fbdc96d4b0e8296e13b6e4b58c6--7cb5f5ff0602476b954c6e7dae15208c f388ba4783584f0d8af92c488b4374b1 7cb5f5ff0602476b954c6e7dae15208c--f388ba4783584f0d8af92c488b4374b1 8a78e071c6b143cd8915ed486c149708 X f388ba4783584f0d8af92c488b4374b1--8a78e071c6b143cd8915ed486c149708 8a78e071c6b143cd8915ed486c149708--5c7ad8486ff3482d8dc72dd4d09bdcf1 2243a640e2bb455d8ba0986ecc986a37 8a78e071c6b143cd8915ed486c149708--2243a640e2bb455d8ba0986ecc986a37 7338f632c1a54e0eaf9a8bc66583d684 2243a640e2bb455d8ba0986ecc986a37--7338f632c1a54e0eaf9a8bc66583d684 bfa049b9887b4396b3e70d612fc47b94 7338f632c1a54e0eaf9a8bc66583d684--bfa049b9887b4396b3e70d612fc47b94 b404a3fc1d284c8b87380ec8b201dd9b bfa049b9887b4396b3e70d612fc47b94--b404a3fc1d284c8b87380ec8b201dd9b 30bfa57c1a3b470f89d35f7e37545dc9 b404a3fc1d284c8b87380ec8b201dd9b--30bfa57c1a3b470f89d35f7e37545dc9 6e4bc48a04d542f5862159291da35046 30bfa57c1a3b470f89d35f7e37545dc9--6e4bc48a04d542f5862159291da35046 5cdee7083ab14f4b9a6fc253fdcf253a 6e4bc48a04d542f5862159291da35046--5cdee7083ab14f4b9a6fc253fdcf253a 411b30277485473d9ff411901be744ef 5cdee7083ab14f4b9a6fc253fdcf253a--411b30277485473d9ff411901be744ef a945ae106ce04cba830718de02315162 411b30277485473d9ff411901be744ef--a945ae106ce04cba830718de02315162 9ddfdc1c09d7430d82c13533e73427c8 a945ae106ce04cba830718de02315162--9ddfdc1c09d7430d82c13533e73427c8 6e3e7242e1bf4adaa40ae853003deb1d 9ddfdc1c09d7430d82c13533e73427c8--6e3e7242e1bf4adaa40ae853003deb1d 37546d7ef94544d2a26ad97e593c5353 6e3e7242e1bf4adaa40ae853003deb1d--37546d7ef94544d2a26ad97e593c5353 417a1cd87f1547eb9d2c8da99000f1ac 37546d7ef94544d2a26ad97e593c5353--417a1cd87f1547eb9d2c8da99000f1ac 9868657270be46ba824a949a9ffe9b9e 417a1cd87f1547eb9d2c8da99000f1ac--9868657270be46ba824a949a9ffe9b9e 2612a58d20204980852b9b5249da3753 9868657270be46ba824a949a9ffe9b9e--2612a58d20204980852b9b5249da3753 80b9a6d320884fab97360a184138004f 2612a58d20204980852b9b5249da3753--80b9a6d320884fab97360a184138004f 713f9ef450f54562b9310eb7134ed07e 80b9a6d320884fab97360a184138004f--713f9ef450f54562b9310eb7134ed07e 3c7328c958ee4a49a07a8f3b68aaf3ad 713f9ef450f54562b9310eb7134ed07e--3c7328c958ee4a49a07a8f3b68aaf3ad 7c09f2f002374ce9817cbd8cc8f5b395 3c7328c958ee4a49a07a8f3b68aaf3ad--7c09f2f002374ce9817cbd8cc8f5b395 7d4e30fab2ba49229cb5e174db489e7c 7c09f2f002374ce9817cbd8cc8f5b395--7d4e30fab2ba49229cb5e174db489e7c e0dbf9ac6dae411ca582cc9aca383630 7d4e30fab2ba49229cb5e174db489e7c--e0dbf9ac6dae411ca582cc9aca383630 91f2259e41a545daada001777bb96393 e0dbf9ac6dae411ca582cc9aca383630--91f2259e41a545daada001777bb96393 5d2c646c4e464b649326c5c8306c7175 91f2259e41a545daada001777bb96393--5d2c646c4e464b649326c5c8306c7175 4abbc7ef04884989bf2f23c990161024 5d2c646c4e464b649326c5c8306c7175--4abbc7ef04884989bf2f23c990161024 5117fa8a28b447dfaf736d7355ff8b8f 4abbc7ef04884989bf2f23c990161024--5117fa8a28b447dfaf736d7355ff8b8f c0a40f24993d416bb8073d72862491f1 5117fa8a28b447dfaf736d7355ff8b8f--c0a40f24993d416bb8073d72862491f1 078e57defa744ed2a7fc906e37e56ffb c0a40f24993d416bb8073d72862491f1--078e57defa744ed2a7fc906e37e56ffb 15fb48c9500b4cf9aaa9ac09c4fd5402 078e57defa744ed2a7fc906e37e56ffb--15fb48c9500b4cf9aaa9ac09c4fd5402 f5cf6d9e9c534aaeb043efc7a16830a1 15fb48c9500b4cf9aaa9ac09c4fd5402--f5cf6d9e9c534aaeb043efc7a16830a1 383febeeb9994060a31efb43bfd5b6c8 f5cf6d9e9c534aaeb043efc7a16830a1--383febeeb9994060a31efb43bfd5b6c8 3447608797e74d93a977260ea511b3d5 383febeeb9994060a31efb43bfd5b6c8--3447608797e74d93a977260ea511b3d5 60dc1d4e318843cc9d689716a0bbd6de 3447608797e74d93a977260ea511b3d5--60dc1d4e318843cc9d689716a0bbd6de 3139b42441cc4a9e9220dd5ec55f1415 60dc1d4e318843cc9d689716a0bbd6de--3139b42441cc4a9e9220dd5ec55f1415 2e611b3b6ce849c5a4e2b8de1eeb814f 3139b42441cc4a9e9220dd5ec55f1415--2e611b3b6ce849c5a4e2b8de1eeb814f 22f67800208e4bb3b483ef7bd61f9f40 2e611b3b6ce849c5a4e2b8de1eeb814f--22f67800208e4bb3b483ef7bd61f9f40 96fe5651a49f47bebe696b6fc899bc65 22f67800208e4bb3b483ef7bd61f9f40--96fe5651a49f47bebe696b6fc899bc65 19044763e1954072a0a538b1452f1ee5 96fe5651a49f47bebe696b6fc899bc65--19044763e1954072a0a538b1452f1ee5 89215c347f764207891baf91b3bed688 19044763e1954072a0a538b1452f1ee5--89215c347f764207891baf91b3bed688 ab3e14b7de804f438d0dbe29e7b3dfef 89215c347f764207891baf91b3bed688--ab3e14b7de804f438d0dbe29e7b3dfef 53b6b8d27012402cbc64a3c893a7a958 ab3e14b7de804f438d0dbe29e7b3dfef--53b6b8d27012402cbc64a3c893a7a958 7bd9d241d5e740639938e39069b391ff 53b6b8d27012402cbc64a3c893a7a958--7bd9d241d5e740639938e39069b391ff 78e27fd0edea4950a268d0d9ff7b23b0 7bd9d241d5e740639938e39069b391ff--78e27fd0edea4950a268d0d9ff7b23b0 3a90642178314b46aae86113cc5b4fb6 78e27fd0edea4950a268d0d9ff7b23b0--3a90642178314b46aae86113cc5b4fb6 f596131d24d64707afd3497b3b5edf54 3a90642178314b46aae86113cc5b4fb6--f596131d24d64707afd3497b3b5edf54 9e3b297f2f8740779185633693567382 f596131d24d64707afd3497b3b5edf54--9e3b297f2f8740779185633693567382 cfdcb6dcea054b1387090a86bafc7e8c 9e3b297f2f8740779185633693567382--cfdcb6dcea054b1387090a86bafc7e8c cda567b37a6b4e9b8099d3e6a388560d cfdcb6dcea054b1387090a86bafc7e8c--cda567b37a6b4e9b8099d3e6a388560d 13d2f2de102048989dfbdaf57490b095 cda567b37a6b4e9b8099d3e6a388560d--13d2f2de102048989dfbdaf57490b095 50a1126f3d714011ab60e11a208b67e2 13d2f2de102048989dfbdaf57490b095--50a1126f3d714011ab60e11a208b67e2 fa79a8943ae842c2927241044694b6de 50a1126f3d714011ab60e11a208b67e2--fa79a8943ae842c2927241044694b6de c8bf7285492048c0a798e5a68c65e165 fa79a8943ae842c2927241044694b6de--c8bf7285492048c0a798e5a68c65e165 525d3cfb788f4e2eadc098ba92f12d77 c8bf7285492048c0a798e5a68c65e165--525d3cfb788f4e2eadc098ba92f12d77 362b3c3c00a944989830c27f45562c1d 525d3cfb788f4e2eadc098ba92f12d77--362b3c3c00a944989830c27f45562c1d ef1fd680cb894774bcc4a9460bd6bec9 362b3c3c00a944989830c27f45562c1d--ef1fd680cb894774bcc4a9460bd6bec9 4305533d594648a3b54e7cfccad69f5f ef1fd680cb894774bcc4a9460bd6bec9--4305533d594648a3b54e7cfccad69f5f b019209a85bc4c0aa08da8a6bafca8bf 4305533d594648a3b54e7cfccad69f5f--b019209a85bc4c0aa08da8a6bafca8bf 137febefa8e14e668325291aa1192bc6 b019209a85bc4c0aa08da8a6bafca8bf--137febefa8e14e668325291aa1192bc6 fecd8924ac80437f9e5e1d851d0aca32 137febefa8e14e668325291aa1192bc6--fecd8924ac80437f9e5e1d851d0aca32 de4b9e1e05a84fa9aa35419c4d4a7bc2 fecd8924ac80437f9e5e1d851d0aca32--de4b9e1e05a84fa9aa35419c4d4a7bc2 68dd4afebee34e6ba1a81d80dbb9a54e de4b9e1e05a84fa9aa35419c4d4a7bc2--68dd4afebee34e6ba1a81d80dbb9a54e 2d627135448a4021aafc6d282f7d29cf 68dd4afebee34e6ba1a81d80dbb9a54e--2d627135448a4021aafc6d282f7d29cf 699a1e9c91b44fd9bf371994947691dc 2d627135448a4021aafc6d282f7d29cf--699a1e9c91b44fd9bf371994947691dc d1ef61fa8b2447a0b5973c7f6814a569 699a1e9c91b44fd9bf371994947691dc--d1ef61fa8b2447a0b5973c7f6814a569 fcfed44b367d4bb98ffb582b2d57bce1 d1ef61fa8b2447a0b5973c7f6814a569--fcfed44b367d4bb98ffb582b2d57bce1 ab261b2c8cba4d29aeeb527ae3b02427 fcfed44b367d4bb98ffb582b2d57bce1--ab261b2c8cba4d29aeeb527ae3b02427 5cb7723616c04237b2409ab6e4c31ead ab261b2c8cba4d29aeeb527ae3b02427--5cb7723616c04237b2409ab6e4c31ead 3d479f928b1a43a2ac8ed990ce3201a5 5cb7723616c04237b2409ab6e4c31ead--3d479f928b1a43a2ac8ed990ce3201a5 050bed88e7374747a037d9fbd1a8411d 3d479f928b1a43a2ac8ed990ce3201a5--050bed88e7374747a037d9fbd1a8411d 8c3ce45a3dff45cba8b9de52ae52a140 050bed88e7374747a037d9fbd1a8411d--8c3ce45a3dff45cba8b9de52ae52a140 75089725dc54469fa596e2802883d8c6 8c3ce45a3dff45cba8b9de52ae52a140--75089725dc54469fa596e2802883d8c6 c5201c89cee04dd0a22b642f72141c14 RX(b11) 75089725dc54469fa596e2802883d8c6--c5201c89cee04dd0a22b642f72141c14 c5201c89cee04dd0a22b642f72141c14--9a50ad2a250c4b61a5344eb859a6af93 377f2241221a479cbe751aba3ee5ad54 8b1ae0e64fb045bf832f87f57bb4ac33 9487c44d15ba4e64ad5d3db70198b21e--8b1ae0e64fb045bf832f87f57bb4ac33 896c6c70a9b04ffbb2f212072a429b13 3 7bbcbca89477429bb602ac2a43a2dca9 X 8b1ae0e64fb045bf832f87f57bb4ac33--7bbcbca89477429bb602ac2a43a2dca9 7bbcbca89477429bb602ac2a43a2dca9--4a873f1d5479474e943d41cc01259e81 a81e369dce284de0a8b067cea56f63a6 7bbcbca89477429bb602ac2a43a2dca9--a81e369dce284de0a8b067cea56f63a6 98ad937c6ffb4da18c311f6f2d2e4118 a81e369dce284de0a8b067cea56f63a6--98ad937c6ffb4da18c311f6f2d2e4118 afaa5cbde08246d19f99663bf284743e 98ad937c6ffb4da18c311f6f2d2e4118--afaa5cbde08246d19f99663bf284743e 8878e367bea54585b419dc230b3948a9 afaa5cbde08246d19f99663bf284743e--8878e367bea54585b419dc230b3948a9 b265ce1964d84ff5ad6d5ae8168b2700 8878e367bea54585b419dc230b3948a9--b265ce1964d84ff5ad6d5ae8168b2700 ccef45e95cc342a98bcaac7bc9c06c46 b265ce1964d84ff5ad6d5ae8168b2700--ccef45e95cc342a98bcaac7bc9c06c46 caecf8cb885645cf9c5a34736f8215d8 ccef45e95cc342a98bcaac7bc9c06c46--caecf8cb885645cf9c5a34736f8215d8 0c3f5dd8c8fa4815978aa50721cd8513 caecf8cb885645cf9c5a34736f8215d8--0c3f5dd8c8fa4815978aa50721cd8513 aa9bd62d53af4847b174e3957aae215b 0c3f5dd8c8fa4815978aa50721cd8513--aa9bd62d53af4847b174e3957aae215b 3588ac7919124e17b6e038d7204427c7 aa9bd62d53af4847b174e3957aae215b--3588ac7919124e17b6e038d7204427c7 9661be53886a4019a975333d5398eacc 3588ac7919124e17b6e038d7204427c7--9661be53886a4019a975333d5398eacc 9d05d1830f3445b6a9fa4d0b8a4787ef X 9661be53886a4019a975333d5398eacc--9d05d1830f3445b6a9fa4d0b8a4787ef 9d05d1830f3445b6a9fa4d0b8a4787ef--be79b49ff1da461bae89e3c87e90c422 3bd27c7d7f9048f0bb57fcd3e8349d6b 9d05d1830f3445b6a9fa4d0b8a4787ef--3bd27c7d7f9048f0bb57fcd3e8349d6b 6c3819c4c9ad4167a01e0c705fe984dc 3bd27c7d7f9048f0bb57fcd3e8349d6b--6c3819c4c9ad4167a01e0c705fe984dc e5d4c15bc1424af38dcdcaf402b47e80 X 6c3819c4c9ad4167a01e0c705fe984dc--e5d4c15bc1424af38dcdcaf402b47e80 e5d4c15bc1424af38dcdcaf402b47e80--79e34ca650484fbb887cb691362ed00e bf80edc3797b4f1fb9afad6c605692cc RZ(-1.0*g0) e5d4c15bc1424af38dcdcaf402b47e80--bf80edc3797b4f1fb9afad6c605692cc 554fe809ed614f8e9a1cd0cf512988e1 X bf80edc3797b4f1fb9afad6c605692cc--554fe809ed614f8e9a1cd0cf512988e1 554fe809ed614f8e9a1cd0cf512988e1--9c032983910f46f088e8463d7e4d279c 48055195224648938455eb71f23cae57 554fe809ed614f8e9a1cd0cf512988e1--48055195224648938455eb71f23cae57 442c4c2f5051426295fa19ffa67d1b69 48055195224648938455eb71f23cae57--442c4c2f5051426295fa19ffa67d1b69 acb8a6ab7c494428978cbc10e90d0eb1 X 442c4c2f5051426295fa19ffa67d1b69--acb8a6ab7c494428978cbc10e90d0eb1 acb8a6ab7c494428978cbc10e90d0eb1--b0aac5b5b90d464fb3e9a115ba2e5b95 004357c903474426850c327151abc9b7 acb8a6ab7c494428978cbc10e90d0eb1--004357c903474426850c327151abc9b7 14e7935423234ac1b5966e4ca72f5257 004357c903474426850c327151abc9b7--14e7935423234ac1b5966e4ca72f5257 155865076f064b1e8f1221ef651b9d82 14e7935423234ac1b5966e4ca72f5257--155865076f064b1e8f1221ef651b9d82 b1a4810dffe849d99ff4e9b7438c1b6a X 155865076f064b1e8f1221ef651b9d82--b1a4810dffe849d99ff4e9b7438c1b6a b1a4810dffe849d99ff4e9b7438c1b6a--530bd985a7a4448da6a30d36699fb172 835a5052a6974348b01ad56c9a13a8fe b1a4810dffe849d99ff4e9b7438c1b6a--835a5052a6974348b01ad56c9a13a8fe 3103363edfbf40c1b5f28e6834aeb092 835a5052a6974348b01ad56c9a13a8fe--3103363edfbf40c1b5f28e6834aeb092 0b29a6b74f1c44848609432ca388df63 X 3103363edfbf40c1b5f28e6834aeb092--0b29a6b74f1c44848609432ca388df63 0b29a6b74f1c44848609432ca388df63--49ba1af1c02b4f6db4da5b0a0c616981 b167215f949a4954802ccf76b91c7778 0b29a6b74f1c44848609432ca388df63--b167215f949a4954802ccf76b91c7778 e7d6181559ea4f3a9f80315e88d31e72 b167215f949a4954802ccf76b91c7778--e7d6181559ea4f3a9f80315e88d31e72 dd50e641d7cf4c81a4ffa8e835323e68 e7d6181559ea4f3a9f80315e88d31e72--dd50e641d7cf4c81a4ffa8e835323e68 6c114134b82f4a8abb2f9c5b8186e697 dd50e641d7cf4c81a4ffa8e835323e68--6c114134b82f4a8abb2f9c5b8186e697 507e1b20290d486a9752ed401b9cf08e 6c114134b82f4a8abb2f9c5b8186e697--507e1b20290d486a9752ed401b9cf08e 8ec0e24294db4fa8808837fad19ab4c1 X 507e1b20290d486a9752ed401b9cf08e--8ec0e24294db4fa8808837fad19ab4c1 8ec0e24294db4fa8808837fad19ab4c1--f9f432814cd14bcf9a9158a1bd062c6c 61e210c45405430292743e0d400c2a15 8ec0e24294db4fa8808837fad19ab4c1--61e210c45405430292743e0d400c2a15 5f224352bd3546d88ea36ced87ba1e67 61e210c45405430292743e0d400c2a15--5f224352bd3546d88ea36ced87ba1e67 705cdd2b5e864f1bbd55c5402792acca X 5f224352bd3546d88ea36ced87ba1e67--705cdd2b5e864f1bbd55c5402792acca 705cdd2b5e864f1bbd55c5402792acca--759a59ed2d3d4e8288bd83713031d1e8 98a68856b481403ca66336816176aea1 705cdd2b5e864f1bbd55c5402792acca--98a68856b481403ca66336816176aea1 2b1ba7ba58b145658fc64d71b485464d 98a68856b481403ca66336816176aea1--2b1ba7ba58b145658fc64d71b485464d 581e3f6705004d5cadc0d1a53095bdb0 2b1ba7ba58b145658fc64d71b485464d--581e3f6705004d5cadc0d1a53095bdb0 a0bde7f9d4de487f9d91b828c706625d 581e3f6705004d5cadc0d1a53095bdb0--a0bde7f9d4de487f9d91b828c706625d 1cae6add5b86492ebf316c090a803634 a0bde7f9d4de487f9d91b828c706625d--1cae6add5b86492ebf316c090a803634 74bf889b99fa45f6a0c98cb93d54ad1b 1cae6add5b86492ebf316c090a803634--74bf889b99fa45f6a0c98cb93d54ad1b ce8e91573eaf494ca70dac0320337cc2 74bf889b99fa45f6a0c98cb93d54ad1b--ce8e91573eaf494ca70dac0320337cc2 91390c54acd04118aae94fb2bb8a21f2 ce8e91573eaf494ca70dac0320337cc2--91390c54acd04118aae94fb2bb8a21f2 ce848c0d6c2a469e82cbc144370812d6 91390c54acd04118aae94fb2bb8a21f2--ce848c0d6c2a469e82cbc144370812d6 f71a0dea6fc347ef9918aab7b8eed98e X ce848c0d6c2a469e82cbc144370812d6--f71a0dea6fc347ef9918aab7b8eed98e f71a0dea6fc347ef9918aab7b8eed98e--c662f4b4152e4a79b52c8082287e38fe 79fe0d451bbe4502ab1b474ff52f4ffe f71a0dea6fc347ef9918aab7b8eed98e--79fe0d451bbe4502ab1b474ff52f4ffe 02735638fe764e1fbf17fd1eaa4a6df4 X 79fe0d451bbe4502ab1b474ff52f4ffe--02735638fe764e1fbf17fd1eaa4a6df4 02735638fe764e1fbf17fd1eaa4a6df4--97e91c0752704b279ec36d99be1704c0 7c239b6a299c44efb6bd5dc644470a9e 02735638fe764e1fbf17fd1eaa4a6df4--7c239b6a299c44efb6bd5dc644470a9e d4bfc96188d44065bbbee35e0b6dec7c 7c239b6a299c44efb6bd5dc644470a9e--d4bfc96188d44065bbbee35e0b6dec7c 56e46f1c45b0464cbc13f20aaaf71c28 d4bfc96188d44065bbbee35e0b6dec7c--56e46f1c45b0464cbc13f20aaaf71c28 e12117cd0c164b52b4af57dd7ba189b6 X 56e46f1c45b0464cbc13f20aaaf71c28--e12117cd0c164b52b4af57dd7ba189b6 e12117cd0c164b52b4af57dd7ba189b6--3cc1a3da9a40410e968ff6cbd7f0d073 c503922c8cfa4253b0c5abfce684a3e5 X e12117cd0c164b52b4af57dd7ba189b6--c503922c8cfa4253b0c5abfce684a3e5 c503922c8cfa4253b0c5abfce684a3e5--3c1cf74d096b44aa80f04b7657f57e50 e8c30d94d5ee4c3396d0763bbb0c9c1d c503922c8cfa4253b0c5abfce684a3e5--e8c30d94d5ee4c3396d0763bbb0c9c1d 78f3a774fbea4a40870ab1e55d7ccfb9 e8c30d94d5ee4c3396d0763bbb0c9c1d--78f3a774fbea4a40870ab1e55d7ccfb9 c1bfb3ec402c45298037c2bd22c1453b 78f3a774fbea4a40870ab1e55d7ccfb9--c1bfb3ec402c45298037c2bd22c1453b 6ff887e2d12a490ab9a98e27729e599e c1bfb3ec402c45298037c2bd22c1453b--6ff887e2d12a490ab9a98e27729e599e f4e084b052234506b988ac7fbd885b01 6ff887e2d12a490ab9a98e27729e599e--f4e084b052234506b988ac7fbd885b01 49f3362514584c0193a45b5fa53d6884 f4e084b052234506b988ac7fbd885b01--49f3362514584c0193a45b5fa53d6884 7db9c577f6e741298d536374aca12ee4 49f3362514584c0193a45b5fa53d6884--7db9c577f6e741298d536374aca12ee4 b623f1ba1e364c05924a2931b29464b9 7db9c577f6e741298d536374aca12ee4--b623f1ba1e364c05924a2931b29464b9 bbd7464f6c24443d935f80f120108ddd b623f1ba1e364c05924a2931b29464b9--bbd7464f6c24443d935f80f120108ddd 2370ae20d3bd4bd89cd5f88cf9279f71 X bbd7464f6c24443d935f80f120108ddd--2370ae20d3bd4bd89cd5f88cf9279f71 2370ae20d3bd4bd89cd5f88cf9279f71--1992cff3897644f6b9b4545e307066ce 24c57d63f82f4fd59a8ba7400aa2b29a X 2370ae20d3bd4bd89cd5f88cf9279f71--24c57d63f82f4fd59a8ba7400aa2b29a 24c57d63f82f4fd59a8ba7400aa2b29a--07e8bbee59164ff1a270cd8d2e5800e5 4007bcd5878d41a99083f2c5a00cf13c 24c57d63f82f4fd59a8ba7400aa2b29a--4007bcd5878d41a99083f2c5a00cf13c f823f2a2da104979946807baacc70afa 4007bcd5878d41a99083f2c5a00cf13c--f823f2a2da104979946807baacc70afa 9553631fcada463f807cb171b41a8f5d f823f2a2da104979946807baacc70afa--9553631fcada463f807cb171b41a8f5d bf06bcff40fc4dd98e63508fd0205678 9553631fcada463f807cb171b41a8f5d--bf06bcff40fc4dd98e63508fd0205678 38f47816fa294fbb8a3576253b9575ec bf06bcff40fc4dd98e63508fd0205678--38f47816fa294fbb8a3576253b9575ec 9da19c5b2c07426497e59121c15b459e 38f47816fa294fbb8a3576253b9575ec--9da19c5b2c07426497e59121c15b459e 46e67f0db80b44489ee2617ba755864b 9da19c5b2c07426497e59121c15b459e--46e67f0db80b44489ee2617ba755864b 775cef815fa542cca7849a03f8fee3ba 46e67f0db80b44489ee2617ba755864b--775cef815fa542cca7849a03f8fee3ba 06e692c198384b009ef5d6228fd1b119 775cef815fa542cca7849a03f8fee3ba--06e692c198384b009ef5d6228fd1b119 cc6937c47fc54df5816818670fbb8905 06e692c198384b009ef5d6228fd1b119--cc6937c47fc54df5816818670fbb8905 77ce27f821f442b99c9001fe39fee2f9 cc6937c47fc54df5816818670fbb8905--77ce27f821f442b99c9001fe39fee2f9 52a98a6276f24e5cae280f1cc64aa144 X 77ce27f821f442b99c9001fe39fee2f9--52a98a6276f24e5cae280f1cc64aa144 52a98a6276f24e5cae280f1cc64aa144--ca965ce4593b4a72bb462c1b36fe007a 2fd3e7051d574d888f1cac0472b9790f 52a98a6276f24e5cae280f1cc64aa144--2fd3e7051d574d888f1cac0472b9790f 4013be99495e41e6a690de3311a6150e 2fd3e7051d574d888f1cac0472b9790f--4013be99495e41e6a690de3311a6150e 568dc0f7800f440daff766344545e01b 4013be99495e41e6a690de3311a6150e--568dc0f7800f440daff766344545e01b 9abc67a5ef9a47f0a17454f536145278 568dc0f7800f440daff766344545e01b--9abc67a5ef9a47f0a17454f536145278 175793f0d9984901919f6e88ec74c6dc 9abc67a5ef9a47f0a17454f536145278--175793f0d9984901919f6e88ec74c6dc de2d30695ca24fa6953630c5f3e90814 175793f0d9984901919f6e88ec74c6dc--de2d30695ca24fa6953630c5f3e90814 2c84aa2e791b49468265d36e5a13fc10 de2d30695ca24fa6953630c5f3e90814--2c84aa2e791b49468265d36e5a13fc10 cb7f1afe147345848e19ab849fff128b 2c84aa2e791b49468265d36e5a13fc10--cb7f1afe147345848e19ab849fff128b 86bf426201d84ec2b3c93b0e47d88fc8 cb7f1afe147345848e19ab849fff128b--86bf426201d84ec2b3c93b0e47d88fc8 4a32c64df5634e99ae3be13384e05541 86bf426201d84ec2b3c93b0e47d88fc8--4a32c64df5634e99ae3be13384e05541 8ccd29746a1049c194650a4f9644f6dd 4a32c64df5634e99ae3be13384e05541--8ccd29746a1049c194650a4f9644f6dd 7bb5525a0b3c434f8d83628b4cd9fa4c 8ccd29746a1049c194650a4f9644f6dd--7bb5525a0b3c434f8d83628b4cd9fa4c e5fa69e7bf874cfa873290373c5f8027 7bb5525a0b3c434f8d83628b4cd9fa4c--e5fa69e7bf874cfa873290373c5f8027 dcb8e397ca40403fb9010f6923e6d629 e5fa69e7bf874cfa873290373c5f8027--dcb8e397ca40403fb9010f6923e6d629 36caec0afd994a068f38fb0517e8dd33 dcb8e397ca40403fb9010f6923e6d629--36caec0afd994a068f38fb0517e8dd33 59c8d29ba13f4f91997f0bba5a9af2fe 36caec0afd994a068f38fb0517e8dd33--59c8d29ba13f4f91997f0bba5a9af2fe fbd51a74a85b4efbad7c1080f4952859 59c8d29ba13f4f91997f0bba5a9af2fe--fbd51a74a85b4efbad7c1080f4952859 057397e0883d4f4d8a8e6dea736a6d49 fbd51a74a85b4efbad7c1080f4952859--057397e0883d4f4d8a8e6dea736a6d49 dcff9a80710b4af8853f2f1dd66fd4e0 057397e0883d4f4d8a8e6dea736a6d49--dcff9a80710b4af8853f2f1dd66fd4e0 db58baed1641449f8b728baf7f8934de dcff9a80710b4af8853f2f1dd66fd4e0--db58baed1641449f8b728baf7f8934de d6c4f1256d6646ddbdbaa915a11d86ac db58baed1641449f8b728baf7f8934de--d6c4f1256d6646ddbdbaa915a11d86ac 643ddf40141e49388e8ff578e988de57 d6c4f1256d6646ddbdbaa915a11d86ac--643ddf40141e49388e8ff578e988de57 21c64de70ee04c2fb5ca8c9c6fff72f7 643ddf40141e49388e8ff578e988de57--21c64de70ee04c2fb5ca8c9c6fff72f7 394f766c837f421b85953a44620b1c71 21c64de70ee04c2fb5ca8c9c6fff72f7--394f766c837f421b85953a44620b1c71 33e0b6493a6b45ccb81b6745270f26da 394f766c837f421b85953a44620b1c71--33e0b6493a6b45ccb81b6745270f26da d4dc301d1bd345b5886d02ee70e861d2 33e0b6493a6b45ccb81b6745270f26da--d4dc301d1bd345b5886d02ee70e861d2 a777073f8f534feca5e60d48596f55cf d4dc301d1bd345b5886d02ee70e861d2--a777073f8f534feca5e60d48596f55cf fc6dbabff96d49ed8c838d49c5e8a98e a777073f8f534feca5e60d48596f55cf--fc6dbabff96d49ed8c838d49c5e8a98e fceceed4e71540b0b6f099db4552b8fb fc6dbabff96d49ed8c838d49c5e8a98e--fceceed4e71540b0b6f099db4552b8fb e2206c1ada79496298ed2b712f697990 fceceed4e71540b0b6f099db4552b8fb--e2206c1ada79496298ed2b712f697990 e4fa10fab74149fa853365a11c59e35e e2206c1ada79496298ed2b712f697990--e4fa10fab74149fa853365a11c59e35e 6a798d2463a24a8db5fa7e9460eec545 e4fa10fab74149fa853365a11c59e35e--6a798d2463a24a8db5fa7e9460eec545 b3b4625a14834cb8a7c81de41131b0c8 6a798d2463a24a8db5fa7e9460eec545--b3b4625a14834cb8a7c81de41131b0c8 e4a12d5090064714a0ba73bdf355584e b3b4625a14834cb8a7c81de41131b0c8--e4a12d5090064714a0ba73bdf355584e 6d8527effc714604839c348fb23006e9 e4a12d5090064714a0ba73bdf355584e--6d8527effc714604839c348fb23006e9 801cb8e3dc9549a890b5a2a7a0199594 6d8527effc714604839c348fb23006e9--801cb8e3dc9549a890b5a2a7a0199594 16f275de2e094922b78d29c91a9ea73b 801cb8e3dc9549a890b5a2a7a0199594--16f275de2e094922b78d29c91a9ea73b 1ca2b4db36174c26829710376204def0 16f275de2e094922b78d29c91a9ea73b--1ca2b4db36174c26829710376204def0 c8f90daca6bf46e087ee7005866949ae 1ca2b4db36174c26829710376204def0--c8f90daca6bf46e087ee7005866949ae ae7850d141744e87b3c2b9bd23b6f6d2 c8f90daca6bf46e087ee7005866949ae--ae7850d141744e87b3c2b9bd23b6f6d2 ed7b6c1f6ee64357ac85f71dab2b3844 ae7850d141744e87b3c2b9bd23b6f6d2--ed7b6c1f6ee64357ac85f71dab2b3844 d06ab9617bb549fd947825c2cfc31d93 RX(b02) ed7b6c1f6ee64357ac85f71dab2b3844--d06ab9617bb549fd947825c2cfc31d93 023f92d9b9ec464b816ef2d6d26929f3 d06ab9617bb549fd947825c2cfc31d93--023f92d9b9ec464b816ef2d6d26929f3 68fcb4a774b54ff2b1099ec7f1c6a9a0 X 023f92d9b9ec464b816ef2d6d26929f3--68fcb4a774b54ff2b1099ec7f1c6a9a0 68fcb4a774b54ff2b1099ec7f1c6a9a0--edffe11fc29b4bd6a34078fc382cfc50 ad0fcf2872074d5c92fadd00224d4220 68fcb4a774b54ff2b1099ec7f1c6a9a0--ad0fcf2872074d5c92fadd00224d4220 ad9fae29a4bb4ce6ad57ec135042ec56 ad0fcf2872074d5c92fadd00224d4220--ad9fae29a4bb4ce6ad57ec135042ec56 c672c2fa251f4e3fa018676a00ca0eae ad9fae29a4bb4ce6ad57ec135042ec56--c672c2fa251f4e3fa018676a00ca0eae 9508fc20079744948e34accd5a64ab71 c672c2fa251f4e3fa018676a00ca0eae--9508fc20079744948e34accd5a64ab71 c465948b6b164d4a9a7613e95c67251c 9508fc20079744948e34accd5a64ab71--c465948b6b164d4a9a7613e95c67251c f49fd8ff25734b7d9711381b91de7ccf c465948b6b164d4a9a7613e95c67251c--f49fd8ff25734b7d9711381b91de7ccf cd7e2547e2e8490a917b3872ee820323 f49fd8ff25734b7d9711381b91de7ccf--cd7e2547e2e8490a917b3872ee820323 8afb14160a3a48a2839a582343a59a08 cd7e2547e2e8490a917b3872ee820323--8afb14160a3a48a2839a582343a59a08 0874be0cf39240abbedcd5312542a679 8afb14160a3a48a2839a582343a59a08--0874be0cf39240abbedcd5312542a679 8d7d77b4d3b243c68a7f3481b8cbb974 0874be0cf39240abbedcd5312542a679--8d7d77b4d3b243c68a7f3481b8cbb974 72a0efa838654e46adfa14f821cfb5ca 8d7d77b4d3b243c68a7f3481b8cbb974--72a0efa838654e46adfa14f821cfb5ca d29d766c8e8141c6b04f329a0c7e46fa X 72a0efa838654e46adfa14f821cfb5ca--d29d766c8e8141c6b04f329a0c7e46fa d29d766c8e8141c6b04f329a0c7e46fa--08b1e0c9ed2d4f77a45aea7eaa98fa11 818182eb29154ac688513b4e991ccbda d29d766c8e8141c6b04f329a0c7e46fa--818182eb29154ac688513b4e991ccbda 71b3dbd9b93842299891420423f2a7db 818182eb29154ac688513b4e991ccbda--71b3dbd9b93842299891420423f2a7db 05612767980a42f3a0d7a78a55731235 X 71b3dbd9b93842299891420423f2a7db--05612767980a42f3a0d7a78a55731235 05612767980a42f3a0d7a78a55731235--b50472fb67004e1e8f789921ae8bc106 390f0b421f034d15bb273e414d217254 RZ(-1.0*g1) 05612767980a42f3a0d7a78a55731235--390f0b421f034d15bb273e414d217254 eda8db4f115240809b0fcc735daa0f0e X 390f0b421f034d15bb273e414d217254--eda8db4f115240809b0fcc735daa0f0e eda8db4f115240809b0fcc735daa0f0e--5713d149257743eda723bdd2011d264f efe93725237a4f32822b35d5714a1989 eda8db4f115240809b0fcc735daa0f0e--efe93725237a4f32822b35d5714a1989 b26d3ce05d3241eea9362e1e7f149237 efe93725237a4f32822b35d5714a1989--b26d3ce05d3241eea9362e1e7f149237 7a24ad28ea1d487e8713d04b321f17cc X b26d3ce05d3241eea9362e1e7f149237--7a24ad28ea1d487e8713d04b321f17cc 7a24ad28ea1d487e8713d04b321f17cc--2920c7e912bb4d248c5ab53709df2881 4ea63ca875fa4b5991cc92fc68a32d6c 7a24ad28ea1d487e8713d04b321f17cc--4ea63ca875fa4b5991cc92fc68a32d6c e665f88648e84895b2a9a20889ac3f8a 4ea63ca875fa4b5991cc92fc68a32d6c--e665f88648e84895b2a9a20889ac3f8a e5c9559b82ff4622a5a8883a86d17c2c e665f88648e84895b2a9a20889ac3f8a--e5c9559b82ff4622a5a8883a86d17c2c b7520dd8131843d3a7130474706c5f49 X e5c9559b82ff4622a5a8883a86d17c2c--b7520dd8131843d3a7130474706c5f49 b7520dd8131843d3a7130474706c5f49--3fc1e07e8d4240619bb73d7c11802680 25d484d9260341e5985f7db2875ecc72 b7520dd8131843d3a7130474706c5f49--25d484d9260341e5985f7db2875ecc72 51404faaabc44cc180330a8545cf220a 25d484d9260341e5985f7db2875ecc72--51404faaabc44cc180330a8545cf220a c9ca2159818b492bbcecc29090b2bcbc X 51404faaabc44cc180330a8545cf220a--c9ca2159818b492bbcecc29090b2bcbc c9ca2159818b492bbcecc29090b2bcbc--4d0d1832f43a417eab4e5b5d3f7b985c 112a0f2c82324eafaec0e3433a715ef2 c9ca2159818b492bbcecc29090b2bcbc--112a0f2c82324eafaec0e3433a715ef2 3d6dd3e8559d413d91b9fbf24cd6f06f 112a0f2c82324eafaec0e3433a715ef2--3d6dd3e8559d413d91b9fbf24cd6f06f 78791cf126c9484eaee2da37effc2c0c 3d6dd3e8559d413d91b9fbf24cd6f06f--78791cf126c9484eaee2da37effc2c0c adef02eb2ccc41cfa0d5568463dd5e16 78791cf126c9484eaee2da37effc2c0c--adef02eb2ccc41cfa0d5568463dd5e16 cacf9888cf2a4b759b30d9cb03974760 adef02eb2ccc41cfa0d5568463dd5e16--cacf9888cf2a4b759b30d9cb03974760 1191d4bc24f445f6bfa07632bf7515c4 X cacf9888cf2a4b759b30d9cb03974760--1191d4bc24f445f6bfa07632bf7515c4 1191d4bc24f445f6bfa07632bf7515c4--d586d2b1708b4763bd513d30e3b4904a 83c15a77edde4dc79c318186560c9213 1191d4bc24f445f6bfa07632bf7515c4--83c15a77edde4dc79c318186560c9213 1f9d80b803874c7c87660365f7e265f4 83c15a77edde4dc79c318186560c9213--1f9d80b803874c7c87660365f7e265f4 3893a71a18d04f9f9257be5bb16fc290 X 1f9d80b803874c7c87660365f7e265f4--3893a71a18d04f9f9257be5bb16fc290 3893a71a18d04f9f9257be5bb16fc290--ce7341d312f74fdb942b7f12382e9807 94318a325a8c41139ddcbfc7a80bb77b 3893a71a18d04f9f9257be5bb16fc290--94318a325a8c41139ddcbfc7a80bb77b 8d904334e8144a1a869e28d4f3e1bfcb 94318a325a8c41139ddcbfc7a80bb77b--8d904334e8144a1a869e28d4f3e1bfcb 0de1e8bb7bcf42908bd7f2c7c93499a3 8d904334e8144a1a869e28d4f3e1bfcb--0de1e8bb7bcf42908bd7f2c7c93499a3 47be8ec4547b49c38e07a9222ae12929 0de1e8bb7bcf42908bd7f2c7c93499a3--47be8ec4547b49c38e07a9222ae12929 9094a6c3a2e948bbaa862144134c9ea0 47be8ec4547b49c38e07a9222ae12929--9094a6c3a2e948bbaa862144134c9ea0 ae131fe5a6cf46d8a272430d3ee131cb 9094a6c3a2e948bbaa862144134c9ea0--ae131fe5a6cf46d8a272430d3ee131cb fea75ab3bbb54c67a9bf2842fe1aa058 ae131fe5a6cf46d8a272430d3ee131cb--fea75ab3bbb54c67a9bf2842fe1aa058 1873c600ba844ba7b8ef89a4a27a629f fea75ab3bbb54c67a9bf2842fe1aa058--1873c600ba844ba7b8ef89a4a27a629f 71db99cada344d8d825780fe5b946dc0 1873c600ba844ba7b8ef89a4a27a629f--71db99cada344d8d825780fe5b946dc0 202a001b260e4eb9ae46070bc137c1d3 X 71db99cada344d8d825780fe5b946dc0--202a001b260e4eb9ae46070bc137c1d3 202a001b260e4eb9ae46070bc137c1d3--f388ba4783584f0d8af92c488b4374b1 0d138e97d5854212bf6ee90deb4c34e8 202a001b260e4eb9ae46070bc137c1d3--0d138e97d5854212bf6ee90deb4c34e8 7ea73455e25240f396a6257fabc10921 X 0d138e97d5854212bf6ee90deb4c34e8--7ea73455e25240f396a6257fabc10921 7ea73455e25240f396a6257fabc10921--2243a640e2bb455d8ba0986ecc986a37 fa2e5266bde54151a0f2a113fb27fd4a 7ea73455e25240f396a6257fabc10921--fa2e5266bde54151a0f2a113fb27fd4a a66a36c155dc4dc693bb89dee0a6dd1b fa2e5266bde54151a0f2a113fb27fd4a--a66a36c155dc4dc693bb89dee0a6dd1b 58af32df43754bcb8eecb997c8bad898 a66a36c155dc4dc693bb89dee0a6dd1b--58af32df43754bcb8eecb997c8bad898 02fb08ca91914431b1a90e22f6b3056d X 58af32df43754bcb8eecb997c8bad898--02fb08ca91914431b1a90e22f6b3056d 02fb08ca91914431b1a90e22f6b3056d--30bfa57c1a3b470f89d35f7e37545dc9 ae52a43e6e394f0bb4cfcf663220d44b X 02fb08ca91914431b1a90e22f6b3056d--ae52a43e6e394f0bb4cfcf663220d44b ae52a43e6e394f0bb4cfcf663220d44b--6e4bc48a04d542f5862159291da35046 28e5e228182d49dc8fbae834db8cb111 ae52a43e6e394f0bb4cfcf663220d44b--28e5e228182d49dc8fbae834db8cb111 9296500fa96a47769c07836b7462f31d 28e5e228182d49dc8fbae834db8cb111--9296500fa96a47769c07836b7462f31d 6561b671174d406a9ae08295d0b75932 9296500fa96a47769c07836b7462f31d--6561b671174d406a9ae08295d0b75932 34c0ac4c5edc494ca1ca867a3b640693 6561b671174d406a9ae08295d0b75932--34c0ac4c5edc494ca1ca867a3b640693 249922d1b5864cc68ce65200e2d48336 34c0ac4c5edc494ca1ca867a3b640693--249922d1b5864cc68ce65200e2d48336 f132ee14817449e7ba535bba334ef571 249922d1b5864cc68ce65200e2d48336--f132ee14817449e7ba535bba334ef571 5218dab8113f450aa91adb7d7cf26366 f132ee14817449e7ba535bba334ef571--5218dab8113f450aa91adb7d7cf26366 d947441544364798bbdf8f65339bf223 5218dab8113f450aa91adb7d7cf26366--d947441544364798bbdf8f65339bf223 41b27722d2e548b2840b0bd91bb78ae0 d947441544364798bbdf8f65339bf223--41b27722d2e548b2840b0bd91bb78ae0 3da55a1bbf7d46b49e874796b2cf4062 X 41b27722d2e548b2840b0bd91bb78ae0--3da55a1bbf7d46b49e874796b2cf4062 3da55a1bbf7d46b49e874796b2cf4062--80b9a6d320884fab97360a184138004f 926ec8ba1a2f48a69f1c66909c93bb50 X 3da55a1bbf7d46b49e874796b2cf4062--926ec8ba1a2f48a69f1c66909c93bb50 926ec8ba1a2f48a69f1c66909c93bb50--713f9ef450f54562b9310eb7134ed07e 50337811c4d14fb5be1a329444d40c38 926ec8ba1a2f48a69f1c66909c93bb50--50337811c4d14fb5be1a329444d40c38 b6c263800e9f44158fe4cf1bc421a839 50337811c4d14fb5be1a329444d40c38--b6c263800e9f44158fe4cf1bc421a839 c9270dc66e7b46b18243b1ab29edf070 b6c263800e9f44158fe4cf1bc421a839--c9270dc66e7b46b18243b1ab29edf070 ac914b5b2d6a4d49af52451797bdae3e c9270dc66e7b46b18243b1ab29edf070--ac914b5b2d6a4d49af52451797bdae3e 3d3cb177445e493e9f2670191e2d7c60 ac914b5b2d6a4d49af52451797bdae3e--3d3cb177445e493e9f2670191e2d7c60 cde8d8aef7c743078603159000c758b2 3d3cb177445e493e9f2670191e2d7c60--cde8d8aef7c743078603159000c758b2 5c4f8b5e35724972a99418156876c2ed cde8d8aef7c743078603159000c758b2--5c4f8b5e35724972a99418156876c2ed 258e33f9a0f5475eb321ddc32c223654 5c4f8b5e35724972a99418156876c2ed--258e33f9a0f5475eb321ddc32c223654 6665e6d8fa0e486494071109ae4762be 258e33f9a0f5475eb321ddc32c223654--6665e6d8fa0e486494071109ae4762be ffcf2114c1004ee9960f9c0623244ab6 6665e6d8fa0e486494071109ae4762be--ffcf2114c1004ee9960f9c0623244ab6 66397370cbb94dc6bd2911e8636c68ef ffcf2114c1004ee9960f9c0623244ab6--66397370cbb94dc6bd2911e8636c68ef 202cbde7017d4d16bc48b1ce2399c0eb X 66397370cbb94dc6bd2911e8636c68ef--202cbde7017d4d16bc48b1ce2399c0eb 202cbde7017d4d16bc48b1ce2399c0eb--f5cf6d9e9c534aaeb043efc7a16830a1 ae5a5c12bcf343a6b3c065e0936dbf55 202cbde7017d4d16bc48b1ce2399c0eb--ae5a5c12bcf343a6b3c065e0936dbf55 7b34e4997c5b4a5cbc15d5c44c080d98 ae5a5c12bcf343a6b3c065e0936dbf55--7b34e4997c5b4a5cbc15d5c44c080d98 d54ec970002c4de0b1a1a381d315fd13 7b34e4997c5b4a5cbc15d5c44c080d98--d54ec970002c4de0b1a1a381d315fd13 db37442feec6494892191079e9aafd83 d54ec970002c4de0b1a1a381d315fd13--db37442feec6494892191079e9aafd83 e2192412a6564874b9e96aea4424c086 db37442feec6494892191079e9aafd83--e2192412a6564874b9e96aea4424c086 1682d4fe14a947d381d120bf0dd90a84 e2192412a6564874b9e96aea4424c086--1682d4fe14a947d381d120bf0dd90a84 59e2d45a5d5c457c8e99620e3381e997 1682d4fe14a947d381d120bf0dd90a84--59e2d45a5d5c457c8e99620e3381e997 037a2f8650304918b8908bc106ec32ea 59e2d45a5d5c457c8e99620e3381e997--037a2f8650304918b8908bc106ec32ea 0d2659ddaf894990b8510797cbcf1734 037a2f8650304918b8908bc106ec32ea--0d2659ddaf894990b8510797cbcf1734 1c6e14e5dda24950ad710623c395545a 0d2659ddaf894990b8510797cbcf1734--1c6e14e5dda24950ad710623c395545a 89f8d6dcb9c641c88ccc5847db82e901 1c6e14e5dda24950ad710623c395545a--89f8d6dcb9c641c88ccc5847db82e901 d14f6fef898047ba97e9b5255bf0b819 89f8d6dcb9c641c88ccc5847db82e901--d14f6fef898047ba97e9b5255bf0b819 315c007d1b4c42b0b2b036ce6413222f d14f6fef898047ba97e9b5255bf0b819--315c007d1b4c42b0b2b036ce6413222f 311bba69045b499e8b177614df75ff57 315c007d1b4c42b0b2b036ce6413222f--311bba69045b499e8b177614df75ff57 19aca399cf3f4f56b13f66e8160ae64c 311bba69045b499e8b177614df75ff57--19aca399cf3f4f56b13f66e8160ae64c a19b8747e755499fbbe76046d4d4a0a8 19aca399cf3f4f56b13f66e8160ae64c--a19b8747e755499fbbe76046d4d4a0a8 0926d3d4453540238c2b37e54fa5611f a19b8747e755499fbbe76046d4d4a0a8--0926d3d4453540238c2b37e54fa5611f b47d70879fa548c9a489a43c76f24002 0926d3d4453540238c2b37e54fa5611f--b47d70879fa548c9a489a43c76f24002 7eadb783a41645beace1f44061cc6a88 b47d70879fa548c9a489a43c76f24002--7eadb783a41645beace1f44061cc6a88 3e1a07bd1427478f83814ae9f508771e 7eadb783a41645beace1f44061cc6a88--3e1a07bd1427478f83814ae9f508771e 32a274afb2a04a0fb7eb4dfe6aa8affb 3e1a07bd1427478f83814ae9f508771e--32a274afb2a04a0fb7eb4dfe6aa8affb ef4c12ea607541389a00f5c26e450cb0 32a274afb2a04a0fb7eb4dfe6aa8affb--ef4c12ea607541389a00f5c26e450cb0 cd547994c61a45b18c08d074f41ad359 ef4c12ea607541389a00f5c26e450cb0--cd547994c61a45b18c08d074f41ad359 b66f890e96c34cb999626ef3e4c45c98 cd547994c61a45b18c08d074f41ad359--b66f890e96c34cb999626ef3e4c45c98 fd6ae40d5ce747499efc9699734935be b66f890e96c34cb999626ef3e4c45c98--fd6ae40d5ce747499efc9699734935be e97ff299df384329af1ef73cabff770e fd6ae40d5ce747499efc9699734935be--e97ff299df384329af1ef73cabff770e 39f9540fe4e04984a1beaed075ba9193 e97ff299df384329af1ef73cabff770e--39f9540fe4e04984a1beaed075ba9193 8caa8eb27c5d412bb368f91b9a0bce82 39f9540fe4e04984a1beaed075ba9193--8caa8eb27c5d412bb368f91b9a0bce82 3e4e0f91737a40d7997d71ee710a577d 8caa8eb27c5d412bb368f91b9a0bce82--3e4e0f91737a40d7997d71ee710a577d 521f3e0b466142d998a8e40bfa4cab9a 3e4e0f91737a40d7997d71ee710a577d--521f3e0b466142d998a8e40bfa4cab9a 27c210c6231a42809634db5a17180695 521f3e0b466142d998a8e40bfa4cab9a--27c210c6231a42809634db5a17180695 05d8e63fa8914ae0bb1b885787e5d90c 27c210c6231a42809634db5a17180695--05d8e63fa8914ae0bb1b885787e5d90c fc2fc36597f04e59a408b211cadd3b5e 05d8e63fa8914ae0bb1b885787e5d90c--fc2fc36597f04e59a408b211cadd3b5e b6339d0f0aba486997aba74aaf8e77a9 fc2fc36597f04e59a408b211cadd3b5e--b6339d0f0aba486997aba74aaf8e77a9 63d0ed6b0b04418a858aabe28155ddad b6339d0f0aba486997aba74aaf8e77a9--63d0ed6b0b04418a858aabe28155ddad d9dab3bd82094e9fb30188352ca8e403 63d0ed6b0b04418a858aabe28155ddad--d9dab3bd82094e9fb30188352ca8e403 735ac57392e9406a8abd72c21b5fc4c6 d9dab3bd82094e9fb30188352ca8e403--735ac57392e9406a8abd72c21b5fc4c6 9e98a4d3bc3144feb2722ed05e8e0838 735ac57392e9406a8abd72c21b5fc4c6--9e98a4d3bc3144feb2722ed05e8e0838 f15462e178864f538d43de13def03686 9e98a4d3bc3144feb2722ed05e8e0838--f15462e178864f538d43de13def03686 3f4acbe15e8440a0b495def4a2c4b7a9 f15462e178864f538d43de13def03686--3f4acbe15e8440a0b495def4a2c4b7a9 2b1761a9865f449f9bf8b9025c989a2c 3f4acbe15e8440a0b495def4a2c4b7a9--2b1761a9865f449f9bf8b9025c989a2c 2a6b9da43f9742c0a186dca2625f7f68 RX(b12) 2b1761a9865f449f9bf8b9025c989a2c--2a6b9da43f9742c0a186dca2625f7f68 2a6b9da43f9742c0a186dca2625f7f68--377f2241221a479cbe751aba3ee5ad54 cadc477ecc5a4a24baceccf4efd88efd 5ec455e2fecd4cae9d1ed815010d6e13 896c6c70a9b04ffbb2f212072a429b13--5ec455e2fecd4cae9d1ed815010d6e13 dc16a021328f47498db93b3873195602 4 811e5372ac604ce19a33cd08639dbd58 5ec455e2fecd4cae9d1ed815010d6e13--811e5372ac604ce19a33cd08639dbd58 63126ab02be4476cb7015d4f0fe82ff0 X 811e5372ac604ce19a33cd08639dbd58--63126ab02be4476cb7015d4f0fe82ff0 63126ab02be4476cb7015d4f0fe82ff0--a81e369dce284de0a8b067cea56f63a6 15a7f6c9f5ef4e68a56b53c1f357b4de 63126ab02be4476cb7015d4f0fe82ff0--15a7f6c9f5ef4e68a56b53c1f357b4de ab9cce19a4e641d4ad879b1537d5e23b 15a7f6c9f5ef4e68a56b53c1f357b4de--ab9cce19a4e641d4ad879b1537d5e23b 3f7b51a43b384ccdad1adf9b8459929c ab9cce19a4e641d4ad879b1537d5e23b--3f7b51a43b384ccdad1adf9b8459929c 118a348988254e0d8a7488e169f7ec5a 3f7b51a43b384ccdad1adf9b8459929c--118a348988254e0d8a7488e169f7ec5a 99ba948b5d604123abf0d98da32ed419 118a348988254e0d8a7488e169f7ec5a--99ba948b5d604123abf0d98da32ed419 f86bbaa310fc48809238298b6b77fcde 99ba948b5d604123abf0d98da32ed419--f86bbaa310fc48809238298b6b77fcde d8024f1f94114065b9673d7f05e904f5 f86bbaa310fc48809238298b6b77fcde--d8024f1f94114065b9673d7f05e904f5 565757ff1e7346e98889dbfb189372ad d8024f1f94114065b9673d7f05e904f5--565757ff1e7346e98889dbfb189372ad aae51796082947c894f7112a74a0584b 565757ff1e7346e98889dbfb189372ad--aae51796082947c894f7112a74a0584b d2493431978d4df8a9c03b6f9670b92b X aae51796082947c894f7112a74a0584b--d2493431978d4df8a9c03b6f9670b92b d2493431978d4df8a9c03b6f9670b92b--9661be53886a4019a975333d5398eacc dca10c9e64574d8db8e008983b221bb3 d2493431978d4df8a9c03b6f9670b92b--dca10c9e64574d8db8e008983b221bb3 1072d3d911aa453983078be2840d1768 dca10c9e64574d8db8e008983b221bb3--1072d3d911aa453983078be2840d1768 62b6c955e22f42519d0126788efa22a9 1072d3d911aa453983078be2840d1768--62b6c955e22f42519d0126788efa22a9 cca76fdb9b4744ed8a6ad6ebc2e36cb6 62b6c955e22f42519d0126788efa22a9--cca76fdb9b4744ed8a6ad6ebc2e36cb6 c9feedbf4b0143ba828cb43065bee31d cca76fdb9b4744ed8a6ad6ebc2e36cb6--c9feedbf4b0143ba828cb43065bee31d f437a7b1bd1042f890a42f455f96c97c c9feedbf4b0143ba828cb43065bee31d--f437a7b1bd1042f890a42f455f96c97c 66c0feb46b2d480e8ca3b6c9d601d019 f437a7b1bd1042f890a42f455f96c97c--66c0feb46b2d480e8ca3b6c9d601d019 a44ee61b5b1c4d1ebbdb0b2bfbadb571 66c0feb46b2d480e8ca3b6c9d601d019--a44ee61b5b1c4d1ebbdb0b2bfbadb571 97839dad46ad40e0b735f4067bf77706 a44ee61b5b1c4d1ebbdb0b2bfbadb571--97839dad46ad40e0b735f4067bf77706 47781a1adb5d4e72abd7bef9e9843047 X 97839dad46ad40e0b735f4067bf77706--47781a1adb5d4e72abd7bef9e9843047 47781a1adb5d4e72abd7bef9e9843047--004357c903474426850c327151abc9b7 115ba7ff90264c309b5355caacee311e RZ(-1.0*g0) 47781a1adb5d4e72abd7bef9e9843047--115ba7ff90264c309b5355caacee311e d074287a8a364d5a80f2255705ab16d6 X 115ba7ff90264c309b5355caacee311e--d074287a8a364d5a80f2255705ab16d6 d074287a8a364d5a80f2255705ab16d6--155865076f064b1e8f1221ef651b9d82 ed4dd0f367dc4d9b8e3b538519ab4c20 d074287a8a364d5a80f2255705ab16d6--ed4dd0f367dc4d9b8e3b538519ab4c20 6e15ec8767c64318be31f93a4661113e ed4dd0f367dc4d9b8e3b538519ab4c20--6e15ec8767c64318be31f93a4661113e 20d7de9920844e9a837bbaa3f02fa116 6e15ec8767c64318be31f93a4661113e--20d7de9920844e9a837bbaa3f02fa116 70535ddce6ab4eafb3a20cdf151404a5 20d7de9920844e9a837bbaa3f02fa116--70535ddce6ab4eafb3a20cdf151404a5 35e7fd3671c64b2a865b393aaa602011 X 70535ddce6ab4eafb3a20cdf151404a5--35e7fd3671c64b2a865b393aaa602011 35e7fd3671c64b2a865b393aaa602011--b167215f949a4954802ccf76b91c7778 6da45ae1e2c84e3c9636d5972c8cfa88 35e7fd3671c64b2a865b393aaa602011--6da45ae1e2c84e3c9636d5972c8cfa88 b0bb45291f4e4ace9934a3f2ddd8457e 6da45ae1e2c84e3c9636d5972c8cfa88--b0bb45291f4e4ace9934a3f2ddd8457e a583ed13ef224e4abfaa9003fe21487c b0bb45291f4e4ace9934a3f2ddd8457e--a583ed13ef224e4abfaa9003fe21487c cd4b9e5ea9e04c02a79d61e7e157bb8b X a583ed13ef224e4abfaa9003fe21487c--cd4b9e5ea9e04c02a79d61e7e157bb8b cd4b9e5ea9e04c02a79d61e7e157bb8b--507e1b20290d486a9752ed401b9cf08e 2e4085818d5648548ea6dd5e1069a5fe cd4b9e5ea9e04c02a79d61e7e157bb8b--2e4085818d5648548ea6dd5e1069a5fe 2d6ad40894034cc2bf05872ca16d5a90 2e4085818d5648548ea6dd5e1069a5fe--2d6ad40894034cc2bf05872ca16d5a90 528351246572402cbc556f3f02b10474 2d6ad40894034cc2bf05872ca16d5a90--528351246572402cbc556f3f02b10474 5c46cc4030aa46838eb28b9d83f31297 528351246572402cbc556f3f02b10474--5c46cc4030aa46838eb28b9d83f31297 0fa3fb5a95874cfaa978a3336b45ebfc X 5c46cc4030aa46838eb28b9d83f31297--0fa3fb5a95874cfaa978a3336b45ebfc 0fa3fb5a95874cfaa978a3336b45ebfc--98a68856b481403ca66336816176aea1 d4f3d0513f1340a3ab62999e373f7068 0fa3fb5a95874cfaa978a3336b45ebfc--d4f3d0513f1340a3ab62999e373f7068 4297cdc318c94e4595611372c8fe8fef d4f3d0513f1340a3ab62999e373f7068--4297cdc318c94e4595611372c8fe8fef 29348ccc058b42308977029ab4fcb6d7 4297cdc318c94e4595611372c8fe8fef--29348ccc058b42308977029ab4fcb6d7 ea8fe65fcd934fd4b0607c77d8dc8e74 29348ccc058b42308977029ab4fcb6d7--ea8fe65fcd934fd4b0607c77d8dc8e74 3050b8709af8432ba5d6ba3024e914b7 ea8fe65fcd934fd4b0607c77d8dc8e74--3050b8709af8432ba5d6ba3024e914b7 2e4b71067a3e4ce0aaccdb2b54825076 3050b8709af8432ba5d6ba3024e914b7--2e4b71067a3e4ce0aaccdb2b54825076 786336daa0404c76a3f2679e3155382c 2e4b71067a3e4ce0aaccdb2b54825076--786336daa0404c76a3f2679e3155382c 1778baaaf6b648c2bb21c7ebea0878cb X 786336daa0404c76a3f2679e3155382c--1778baaaf6b648c2bb21c7ebea0878cb 1778baaaf6b648c2bb21c7ebea0878cb--ce848c0d6c2a469e82cbc144370812d6 e804830eb18d4a629a5fa6d2af36a0d6 1778baaaf6b648c2bb21c7ebea0878cb--e804830eb18d4a629a5fa6d2af36a0d6 af0aa52e5ad14be5857e5542d723952f e804830eb18d4a629a5fa6d2af36a0d6--af0aa52e5ad14be5857e5542d723952f f229fa6418614920aef54306e0f3e7ea af0aa52e5ad14be5857e5542d723952f--f229fa6418614920aef54306e0f3e7ea 6d68ed89aeca41c49a07f16d4cd5b4b0 X f229fa6418614920aef54306e0f3e7ea--6d68ed89aeca41c49a07f16d4cd5b4b0 6d68ed89aeca41c49a07f16d4cd5b4b0--7c239b6a299c44efb6bd5dc644470a9e 4084391a6f624d1c9e50c35c85190e83 RZ(-1.0*g0) 6d68ed89aeca41c49a07f16d4cd5b4b0--4084391a6f624d1c9e50c35c85190e83 46a5a862dcfc4f64b58e5cf6ee6dbdb9 X 4084391a6f624d1c9e50c35c85190e83--46a5a862dcfc4f64b58e5cf6ee6dbdb9 46a5a862dcfc4f64b58e5cf6ee6dbdb9--56e46f1c45b0464cbc13f20aaaf71c28 1c25e38002474ecfba679ebb509334df 46a5a862dcfc4f64b58e5cf6ee6dbdb9--1c25e38002474ecfba679ebb509334df d6082ce8ef3a41f9a74e83ec5164e94e 1c25e38002474ecfba679ebb509334df--d6082ce8ef3a41f9a74e83ec5164e94e a33076038ce44064b06c254ce033eb8f X d6082ce8ef3a41f9a74e83ec5164e94e--a33076038ce44064b06c254ce033eb8f a33076038ce44064b06c254ce033eb8f--e8c30d94d5ee4c3396d0763bbb0c9c1d d3ec3853fac0424f9dbe130d505a0840 a33076038ce44064b06c254ce033eb8f--d3ec3853fac0424f9dbe130d505a0840 41f33cfddf024772b0e85bf0415e0b23 d3ec3853fac0424f9dbe130d505a0840--41f33cfddf024772b0e85bf0415e0b23 72849258b3e842d289b5213a8344f783 41f33cfddf024772b0e85bf0415e0b23--72849258b3e842d289b5213a8344f783 7a55104d972b4a4b85e81ef1c28846c1 72849258b3e842d289b5213a8344f783--7a55104d972b4a4b85e81ef1c28846c1 beb2fd15604346bd9f3b7145253c815b 7a55104d972b4a4b85e81ef1c28846c1--beb2fd15604346bd9f3b7145253c815b 960db66b6f5d497396023f00dcdefef0 beb2fd15604346bd9f3b7145253c815b--960db66b6f5d497396023f00dcdefef0 fda5fcbf2e6f4998b84815853db68bef 960db66b6f5d497396023f00dcdefef0--fda5fcbf2e6f4998b84815853db68bef c4a8505849424bc299bc17bcf96abbe3 X fda5fcbf2e6f4998b84815853db68bef--c4a8505849424bc299bc17bcf96abbe3 c4a8505849424bc299bc17bcf96abbe3--bbd7464f6c24443d935f80f120108ddd 3156e8dcf3764be0bf12f7e26bf3546a c4a8505849424bc299bc17bcf96abbe3--3156e8dcf3764be0bf12f7e26bf3546a 15fa7863929e44cfbf57392240b1f9b1 3156e8dcf3764be0bf12f7e26bf3546a--15fa7863929e44cfbf57392240b1f9b1 8c1ddf6ff9e14aa0a78853635e1c1d4e X 15fa7863929e44cfbf57392240b1f9b1--8c1ddf6ff9e14aa0a78853635e1c1d4e 8c1ddf6ff9e14aa0a78853635e1c1d4e--4007bcd5878d41a99083f2c5a00cf13c f62f1bb629f94849b4de8a3cbd4640e0 8c1ddf6ff9e14aa0a78853635e1c1d4e--f62f1bb629f94849b4de8a3cbd4640e0 8cc48803c53e4806854b8dff2d56cb1a f62f1bb629f94849b4de8a3cbd4640e0--8cc48803c53e4806854b8dff2d56cb1a 4964550ce9f642f48ab9d7afb87f3e87 8cc48803c53e4806854b8dff2d56cb1a--4964550ce9f642f48ab9d7afb87f3e87 639804b54c5e47dbadde65222fdd388a 4964550ce9f642f48ab9d7afb87f3e87--639804b54c5e47dbadde65222fdd388a f1c1908e11cc4081917e89d2d807e027 639804b54c5e47dbadde65222fdd388a--f1c1908e11cc4081917e89d2d807e027 0691064906644b2b9837a8b92bfe2e37 f1c1908e11cc4081917e89d2d807e027--0691064906644b2b9837a8b92bfe2e37 53c495ccdd3b4b2dadfa193d68973e52 0691064906644b2b9837a8b92bfe2e37--53c495ccdd3b4b2dadfa193d68973e52 69ad6f958b0041e083b0073639246a42 53c495ccdd3b4b2dadfa193d68973e52--69ad6f958b0041e083b0073639246a42 c739ab1c8beb4cfb95c1921cd0d6e00b 69ad6f958b0041e083b0073639246a42--c739ab1c8beb4cfb95c1921cd0d6e00b bfdae77490364ecfb67ea35f6048b24c X c739ab1c8beb4cfb95c1921cd0d6e00b--bfdae77490364ecfb67ea35f6048b24c bfdae77490364ecfb67ea35f6048b24c--77ce27f821f442b99c9001fe39fee2f9 1e2df018a1a745e6b0ecd9bc05f80660 bfdae77490364ecfb67ea35f6048b24c--1e2df018a1a745e6b0ecd9bc05f80660 00e876fc640f4e7cbdbfacab438298ef X 1e2df018a1a745e6b0ecd9bc05f80660--00e876fc640f4e7cbdbfacab438298ef 00e876fc640f4e7cbdbfacab438298ef--2fd3e7051d574d888f1cac0472b9790f 0b9e768e270c481aaa15f34b64f07a09 00e876fc640f4e7cbdbfacab438298ef--0b9e768e270c481aaa15f34b64f07a09 9f5599b86cd34d3cb3d5d11e15649a8c 0b9e768e270c481aaa15f34b64f07a09--9f5599b86cd34d3cb3d5d11e15649a8c e7c3e25c44904dbe8f8b38d973cd2410 9f5599b86cd34d3cb3d5d11e15649a8c--e7c3e25c44904dbe8f8b38d973cd2410 237305441d79485d9f1a4bdc48ffb7e7 X e7c3e25c44904dbe8f8b38d973cd2410--237305441d79485d9f1a4bdc48ffb7e7 237305441d79485d9f1a4bdc48ffb7e7--175793f0d9984901919f6e88ec74c6dc a655f6220cab4a7e98498c1c79dcd0b9 X 237305441d79485d9f1a4bdc48ffb7e7--a655f6220cab4a7e98498c1c79dcd0b9 a655f6220cab4a7e98498c1c79dcd0b9--de2d30695ca24fa6953630c5f3e90814 7ecb00303055433684a8397d26006173 a655f6220cab4a7e98498c1c79dcd0b9--7ecb00303055433684a8397d26006173 290ca9eadac849abb56885c8159fd7d5 7ecb00303055433684a8397d26006173--290ca9eadac849abb56885c8159fd7d5 7d059fbd0eee4ff38c60100d9befa403 290ca9eadac849abb56885c8159fd7d5--7d059fbd0eee4ff38c60100d9befa403 636a4552e18a4e768e0c2f4da06a711c 7d059fbd0eee4ff38c60100d9befa403--636a4552e18a4e768e0c2f4da06a711c 9524c611126f4cad80bb281acb3a1e96 636a4552e18a4e768e0c2f4da06a711c--9524c611126f4cad80bb281acb3a1e96 78efd362bea54042af3a0cc5cc82eeb9 X 9524c611126f4cad80bb281acb3a1e96--78efd362bea54042af3a0cc5cc82eeb9 78efd362bea54042af3a0cc5cc82eeb9--7bb5525a0b3c434f8d83628b4cd9fa4c a8628192d3c74c78a09f214e6a24af9d X 78efd362bea54042af3a0cc5cc82eeb9--a8628192d3c74c78a09f214e6a24af9d a8628192d3c74c78a09f214e6a24af9d--e5fa69e7bf874cfa873290373c5f8027 c380859468df4fa8b4d1e4794a83e1b4 a8628192d3c74c78a09f214e6a24af9d--c380859468df4fa8b4d1e4794a83e1b4 ff117b8996da436182337d67cda7baa6 c380859468df4fa8b4d1e4794a83e1b4--ff117b8996da436182337d67cda7baa6 c876301d46ca4782b331d1e664201398 ff117b8996da436182337d67cda7baa6--c876301d46ca4782b331d1e664201398 307b5e794648495f850a33909dbd44fb c876301d46ca4782b331d1e664201398--307b5e794648495f850a33909dbd44fb ad97a3f5beae45739fe1e6dbab9135d1 307b5e794648495f850a33909dbd44fb--ad97a3f5beae45739fe1e6dbab9135d1 c1e14e3d01624448adf80d09c8257231 ad97a3f5beae45739fe1e6dbab9135d1--c1e14e3d01624448adf80d09c8257231 7ec91e585a0f4f0491571eb0419e8ae6 c1e14e3d01624448adf80d09c8257231--7ec91e585a0f4f0491571eb0419e8ae6 046b23a8522b4d519862f0d6d496e676 7ec91e585a0f4f0491571eb0419e8ae6--046b23a8522b4d519862f0d6d496e676 4752149c46c54ea18c5340d20a4f0ca0 046b23a8522b4d519862f0d6d496e676--4752149c46c54ea18c5340d20a4f0ca0 b974d7c60e6a47249c02a30835c4d71f X 4752149c46c54ea18c5340d20a4f0ca0--b974d7c60e6a47249c02a30835c4d71f b974d7c60e6a47249c02a30835c4d71f--21c64de70ee04c2fb5ca8c9c6fff72f7 4545ac44b323436d92bc8ec543806614 b974d7c60e6a47249c02a30835c4d71f--4545ac44b323436d92bc8ec543806614 1f96b23df6d04fc0b4df34bfe36b2987 4545ac44b323436d92bc8ec543806614--1f96b23df6d04fc0b4df34bfe36b2987 b5f73791c0f74b3da782de1c8049e734 1f96b23df6d04fc0b4df34bfe36b2987--b5f73791c0f74b3da782de1c8049e734 c637cccdacad4d26aa010d6eaa00dd80 b5f73791c0f74b3da782de1c8049e734--c637cccdacad4d26aa010d6eaa00dd80 62a1bab66f234709a5c3197f98b1d7d0 c637cccdacad4d26aa010d6eaa00dd80--62a1bab66f234709a5c3197f98b1d7d0 78f9d5cdcffc4cd6b0cb2becc2ffdd3a 62a1bab66f234709a5c3197f98b1d7d0--78f9d5cdcffc4cd6b0cb2becc2ffdd3a f7f9d420f4f84b55b00b66221cf6142a 78f9d5cdcffc4cd6b0cb2becc2ffdd3a--f7f9d420f4f84b55b00b66221cf6142a 051fc5dd79d84fc18e5aa737b0bc0cd0 f7f9d420f4f84b55b00b66221cf6142a--051fc5dd79d84fc18e5aa737b0bc0cd0 5730ac2eae984a0992995e5d217a7001 051fc5dd79d84fc18e5aa737b0bc0cd0--5730ac2eae984a0992995e5d217a7001 6a887b56496a4204993c042f1149fb4c 5730ac2eae984a0992995e5d217a7001--6a887b56496a4204993c042f1149fb4c 5fd665e9fa334d87915abce1225b873f 6a887b56496a4204993c042f1149fb4c--5fd665e9fa334d87915abce1225b873f d51ed439b0fe40469a9cf9116c5fe4e5 5fd665e9fa334d87915abce1225b873f--d51ed439b0fe40469a9cf9116c5fe4e5 8f09d2b4a9aa4bf8a1a8aa9b3c5a6d45 d51ed439b0fe40469a9cf9116c5fe4e5--8f09d2b4a9aa4bf8a1a8aa9b3c5a6d45 2dc2d413cf28434c85ca26e4f12b3da3 8f09d2b4a9aa4bf8a1a8aa9b3c5a6d45--2dc2d413cf28434c85ca26e4f12b3da3 094c0df7712b497599bada782d8a4edc 2dc2d413cf28434c85ca26e4f12b3da3--094c0df7712b497599bada782d8a4edc be970e650059451880cca2882abb8be3 094c0df7712b497599bada782d8a4edc--be970e650059451880cca2882abb8be3 f8dba1ecb4bf46aaaba55cd5e5ce59bc be970e650059451880cca2882abb8be3--f8dba1ecb4bf46aaaba55cd5e5ce59bc 46c2b0d49be341f28828a1cae66ba2fb f8dba1ecb4bf46aaaba55cd5e5ce59bc--46c2b0d49be341f28828a1cae66ba2fb 4c19a3b04e9447acb5461c4d979089b7 RX(b03) 46c2b0d49be341f28828a1cae66ba2fb--4c19a3b04e9447acb5461c4d979089b7 cda740b8f6d9417c95979cadd1bad08d 4c19a3b04e9447acb5461c4d979089b7--cda740b8f6d9417c95979cadd1bad08d 40ab11e696ad4524af98c9ca624c212c cda740b8f6d9417c95979cadd1bad08d--40ab11e696ad4524af98c9ca624c212c c8e2d284946946558fcbc8239274f614 X 40ab11e696ad4524af98c9ca624c212c--c8e2d284946946558fcbc8239274f614 c8e2d284946946558fcbc8239274f614--ad0fcf2872074d5c92fadd00224d4220 09db479b433f45febd3e293ec20b9bc8 c8e2d284946946558fcbc8239274f614--09db479b433f45febd3e293ec20b9bc8 466c4e76ce0042f5befd642b7fe53748 09db479b433f45febd3e293ec20b9bc8--466c4e76ce0042f5befd642b7fe53748 b2e10ea1530f4179b654a7042de4c55a 466c4e76ce0042f5befd642b7fe53748--b2e10ea1530f4179b654a7042de4c55a 1058ae7941ce4627ad8ef522bf11a54d b2e10ea1530f4179b654a7042de4c55a--1058ae7941ce4627ad8ef522bf11a54d a0ab033e23f943f9886f4b5e76849aa2 1058ae7941ce4627ad8ef522bf11a54d--a0ab033e23f943f9886f4b5e76849aa2 97052a8503be4277b3b1f778efc389ea a0ab033e23f943f9886f4b5e76849aa2--97052a8503be4277b3b1f778efc389ea 79fa955110bd4261b0d1bbc7a7a711b8 97052a8503be4277b3b1f778efc389ea--79fa955110bd4261b0d1bbc7a7a711b8 d05398fbbc154862aff74cd364717a02 79fa955110bd4261b0d1bbc7a7a711b8--d05398fbbc154862aff74cd364717a02 74a64e6d2a684e6a9b54fcfca8d2517c d05398fbbc154862aff74cd364717a02--74a64e6d2a684e6a9b54fcfca8d2517c 3f1552a177764a5ba171e123a80004c1 X 74a64e6d2a684e6a9b54fcfca8d2517c--3f1552a177764a5ba171e123a80004c1 3f1552a177764a5ba171e123a80004c1--72a0efa838654e46adfa14f821cfb5ca c05ab45f60344dea8393b9b12febe45e 3f1552a177764a5ba171e123a80004c1--c05ab45f60344dea8393b9b12febe45e abda47021c134549958c0668955d0834 c05ab45f60344dea8393b9b12febe45e--abda47021c134549958c0668955d0834 0acc17c4945645b0aad6cf0d2e12e087 abda47021c134549958c0668955d0834--0acc17c4945645b0aad6cf0d2e12e087 2e8ad6bff1774e3a852e87b623bc0713 0acc17c4945645b0aad6cf0d2e12e087--2e8ad6bff1774e3a852e87b623bc0713 9174429e12a643bfa8982a97655cea56 2e8ad6bff1774e3a852e87b623bc0713--9174429e12a643bfa8982a97655cea56 360da764273e4745a8b0307aa668d200 9174429e12a643bfa8982a97655cea56--360da764273e4745a8b0307aa668d200 402ec9475fce4d9099cbc7b5c989d1f4 360da764273e4745a8b0307aa668d200--402ec9475fce4d9099cbc7b5c989d1f4 77c68a41402c4b8bb748809e2a5be236 402ec9475fce4d9099cbc7b5c989d1f4--77c68a41402c4b8bb748809e2a5be236 7500de9674d24d9aa91e09f680f50783 77c68a41402c4b8bb748809e2a5be236--7500de9674d24d9aa91e09f680f50783 2d226009b87b478bbce722f336612f0d X 7500de9674d24d9aa91e09f680f50783--2d226009b87b478bbce722f336612f0d 2d226009b87b478bbce722f336612f0d--4ea63ca875fa4b5991cc92fc68a32d6c de6fe943b91248aba6ea8504dd4bed40 RZ(-1.0*g1) 2d226009b87b478bbce722f336612f0d--de6fe943b91248aba6ea8504dd4bed40 c3f384cfd3594d8b8f0af311e4e7a565 X de6fe943b91248aba6ea8504dd4bed40--c3f384cfd3594d8b8f0af311e4e7a565 c3f384cfd3594d8b8f0af311e4e7a565--e5c9559b82ff4622a5a8883a86d17c2c 936ddfb2637d46aeb29dc0c1dab949f7 c3f384cfd3594d8b8f0af311e4e7a565--936ddfb2637d46aeb29dc0c1dab949f7 c8293e0329a547d4b1aaba2446c8aa72 936ddfb2637d46aeb29dc0c1dab949f7--c8293e0329a547d4b1aaba2446c8aa72 867c6c0e4645443bb65ccf99cb2f0c6c c8293e0329a547d4b1aaba2446c8aa72--867c6c0e4645443bb65ccf99cb2f0c6c e8e9bd691f394b458b312617bf0fc6cf 867c6c0e4645443bb65ccf99cb2f0c6c--e8e9bd691f394b458b312617bf0fc6cf 4bb99e2a19254e6eb7b4d3302189142c X e8e9bd691f394b458b312617bf0fc6cf--4bb99e2a19254e6eb7b4d3302189142c 4bb99e2a19254e6eb7b4d3302189142c--112a0f2c82324eafaec0e3433a715ef2 7a8f9618033e478d9a9810f7215d8faf 4bb99e2a19254e6eb7b4d3302189142c--7a8f9618033e478d9a9810f7215d8faf c7dc163eb6214443be5b4ec53705a386 7a8f9618033e478d9a9810f7215d8faf--c7dc163eb6214443be5b4ec53705a386 525820d8524a4b378991244fab3c8863 c7dc163eb6214443be5b4ec53705a386--525820d8524a4b378991244fab3c8863 5d07a946b14b46d28a36fced55cf72cf X 525820d8524a4b378991244fab3c8863--5d07a946b14b46d28a36fced55cf72cf 5d07a946b14b46d28a36fced55cf72cf--cacf9888cf2a4b759b30d9cb03974760 5fb7fbae1057444eafc38c6dae188128 5d07a946b14b46d28a36fced55cf72cf--5fb7fbae1057444eafc38c6dae188128 2a113df19dcc4a39bbb61272877da262 5fb7fbae1057444eafc38c6dae188128--2a113df19dcc4a39bbb61272877da262 e6dfae197bad407587d8b23363674e27 2a113df19dcc4a39bbb61272877da262--e6dfae197bad407587d8b23363674e27 c06be2a96de345eb8c2a56e2099c1b23 e6dfae197bad407587d8b23363674e27--c06be2a96de345eb8c2a56e2099c1b23 ef67ce5359d14c238d27656ca0da7bdf X c06be2a96de345eb8c2a56e2099c1b23--ef67ce5359d14c238d27656ca0da7bdf ef67ce5359d14c238d27656ca0da7bdf--94318a325a8c41139ddcbfc7a80bb77b 58f6f219d83747d4b07f96d3acde44f2 ef67ce5359d14c238d27656ca0da7bdf--58f6f219d83747d4b07f96d3acde44f2 9aebe034cbc4493ca82609f472bd542f 58f6f219d83747d4b07f96d3acde44f2--9aebe034cbc4493ca82609f472bd542f b9f5f45e875540ae94b2620302db5497 9aebe034cbc4493ca82609f472bd542f--b9f5f45e875540ae94b2620302db5497 670aa9d7b0c249ec936a75330c39edc0 b9f5f45e875540ae94b2620302db5497--670aa9d7b0c249ec936a75330c39edc0 e1c7bb73d0dd4fb29540a7d283e91873 670aa9d7b0c249ec936a75330c39edc0--e1c7bb73d0dd4fb29540a7d283e91873 0211602dd9894179bdd64e356fa0037b e1c7bb73d0dd4fb29540a7d283e91873--0211602dd9894179bdd64e356fa0037b 5146fc0ced3e40c8bfa92f920349520e 0211602dd9894179bdd64e356fa0037b--5146fc0ced3e40c8bfa92f920349520e bd4beb8b2cdf4193829d2c9bc2fabe1d X 5146fc0ced3e40c8bfa92f920349520e--bd4beb8b2cdf4193829d2c9bc2fabe1d bd4beb8b2cdf4193829d2c9bc2fabe1d--71db99cada344d8d825780fe5b946dc0 66b4c166b4db41a79daaae7ed1aa2b48 bd4beb8b2cdf4193829d2c9bc2fabe1d--66b4c166b4db41a79daaae7ed1aa2b48 f6143df38e3f4450b27c17fd81b7f96c 66b4c166b4db41a79daaae7ed1aa2b48--f6143df38e3f4450b27c17fd81b7f96c 624b35c1a47b479386dfc10bcc6581b3 f6143df38e3f4450b27c17fd81b7f96c--624b35c1a47b479386dfc10bcc6581b3 c5bbec4d4fd24f4ea84e6508e946d236 X 624b35c1a47b479386dfc10bcc6581b3--c5bbec4d4fd24f4ea84e6508e946d236 c5bbec4d4fd24f4ea84e6508e946d236--fa2e5266bde54151a0f2a113fb27fd4a 4f90ced72ab245b9b88e6965985e910c RZ(-1.0*g1) c5bbec4d4fd24f4ea84e6508e946d236--4f90ced72ab245b9b88e6965985e910c 9900def28d004ac896c6f0fb43e445bf X 4f90ced72ab245b9b88e6965985e910c--9900def28d004ac896c6f0fb43e445bf 9900def28d004ac896c6f0fb43e445bf--58af32df43754bcb8eecb997c8bad898 0a10541a6efc40a59b8e2d236f015fcd 9900def28d004ac896c6f0fb43e445bf--0a10541a6efc40a59b8e2d236f015fcd e88704b43f05418eb93d39d7a67a52e6 0a10541a6efc40a59b8e2d236f015fcd--e88704b43f05418eb93d39d7a67a52e6 317204abca154e1bbb26a93965fedf37 X e88704b43f05418eb93d39d7a67a52e6--317204abca154e1bbb26a93965fedf37 317204abca154e1bbb26a93965fedf37--28e5e228182d49dc8fbae834db8cb111 c9696f6b477d4d938ef5e5e524a1c313 317204abca154e1bbb26a93965fedf37--c9696f6b477d4d938ef5e5e524a1c313 973efe7891fc4eeebb3c3ab1d1e5eead c9696f6b477d4d938ef5e5e524a1c313--973efe7891fc4eeebb3c3ab1d1e5eead 57ab5a03345c4f478ac537a3abf86395 973efe7891fc4eeebb3c3ab1d1e5eead--57ab5a03345c4f478ac537a3abf86395 950f0721d1ee473eb8751e221183892b 57ab5a03345c4f478ac537a3abf86395--950f0721d1ee473eb8751e221183892b e91c05a0a7934298ad8f11294779e0c3 950f0721d1ee473eb8751e221183892b--e91c05a0a7934298ad8f11294779e0c3 c1e5d458c577468385f5b0d9925f1406 e91c05a0a7934298ad8f11294779e0c3--c1e5d458c577468385f5b0d9925f1406 fbccdae11673461eb421bc9ece25416b c1e5d458c577468385f5b0d9925f1406--fbccdae11673461eb421bc9ece25416b d3ea5dfb28b941709052b429c9591ff3 X fbccdae11673461eb421bc9ece25416b--d3ea5dfb28b941709052b429c9591ff3 d3ea5dfb28b941709052b429c9591ff3--41b27722d2e548b2840b0bd91bb78ae0 9c1f27f5116c498dbb32ccb96a6ad3a8 d3ea5dfb28b941709052b429c9591ff3--9c1f27f5116c498dbb32ccb96a6ad3a8 96e21a7e429a4feb8fa0144fe6121aa7 9c1f27f5116c498dbb32ccb96a6ad3a8--96e21a7e429a4feb8fa0144fe6121aa7 ca57bc0e62334b9d9b90349e767ea74a X 96e21a7e429a4feb8fa0144fe6121aa7--ca57bc0e62334b9d9b90349e767ea74a ca57bc0e62334b9d9b90349e767ea74a--50337811c4d14fb5be1a329444d40c38 7580f8a4f9994d02bdfa220e6d258894 ca57bc0e62334b9d9b90349e767ea74a--7580f8a4f9994d02bdfa220e6d258894 11a0b8409d1f47dfb69aeb542c4a808b 7580f8a4f9994d02bdfa220e6d258894--11a0b8409d1f47dfb69aeb542c4a808b b9ebbd872b644347b48ce691e4980bb6 11a0b8409d1f47dfb69aeb542c4a808b--b9ebbd872b644347b48ce691e4980bb6 74cf0e04cc97441aaeaae8ce422cc549 b9ebbd872b644347b48ce691e4980bb6--74cf0e04cc97441aaeaae8ce422cc549 f2956353e4c647d6ab18a3dcaa8c4a14 74cf0e04cc97441aaeaae8ce422cc549--f2956353e4c647d6ab18a3dcaa8c4a14 06bbd3df4e8147d0b51ad008396ebe35 f2956353e4c647d6ab18a3dcaa8c4a14--06bbd3df4e8147d0b51ad008396ebe35 f851a07ef32d4fe2b99a5c6fcb2be30c 06bbd3df4e8147d0b51ad008396ebe35--f851a07ef32d4fe2b99a5c6fcb2be30c 37b42f74b4cb4d73b1dc9fa934fd75ce f851a07ef32d4fe2b99a5c6fcb2be30c--37b42f74b4cb4d73b1dc9fa934fd75ce 67ca1d7c94a54905abf4671d6b5278e8 37b42f74b4cb4d73b1dc9fa934fd75ce--67ca1d7c94a54905abf4671d6b5278e8 01f5537389c34becb5e5c872773a08e9 X 67ca1d7c94a54905abf4671d6b5278e8--01f5537389c34becb5e5c872773a08e9 01f5537389c34becb5e5c872773a08e9--66397370cbb94dc6bd2911e8636c68ef 1517542f39174534b8f2516201fbb693 01f5537389c34becb5e5c872773a08e9--1517542f39174534b8f2516201fbb693 55ad0fb90acd4d1aad1f032260050a86 X 1517542f39174534b8f2516201fbb693--55ad0fb90acd4d1aad1f032260050a86 55ad0fb90acd4d1aad1f032260050a86--ae5a5c12bcf343a6b3c065e0936dbf55 74d392f8f57d4ae6a2a78c822a729273 55ad0fb90acd4d1aad1f032260050a86--74d392f8f57d4ae6a2a78c822a729273 b999596eea2f43d78a2aeec245b43cdd 74d392f8f57d4ae6a2a78c822a729273--b999596eea2f43d78a2aeec245b43cdd 1a38cf7fbf2c436abbfde4932ca67aed b999596eea2f43d78a2aeec245b43cdd--1a38cf7fbf2c436abbfde4932ca67aed 67558aee7281444f938451127e2dab36 X 1a38cf7fbf2c436abbfde4932ca67aed--67558aee7281444f938451127e2dab36 67558aee7281444f938451127e2dab36--e2192412a6564874b9e96aea4424c086 348042674b73483a97a38e9243298a23 X 67558aee7281444f938451127e2dab36--348042674b73483a97a38e9243298a23 348042674b73483a97a38e9243298a23--1682d4fe14a947d381d120bf0dd90a84 f380658e087b41aea859cf47713e5cde 348042674b73483a97a38e9243298a23--f380658e087b41aea859cf47713e5cde d37628ab2e3f4c70818a5ca6e9784ca2 f380658e087b41aea859cf47713e5cde--d37628ab2e3f4c70818a5ca6e9784ca2 fb1ebd6d8f3847baadf942cddb1ca352 d37628ab2e3f4c70818a5ca6e9784ca2--fb1ebd6d8f3847baadf942cddb1ca352 89ddc7cf51ce4b64ae7153c29dc2f394 fb1ebd6d8f3847baadf942cddb1ca352--89ddc7cf51ce4b64ae7153c29dc2f394 eafd4f85ff0a4a2eb302ee8a27ef9b1f 89ddc7cf51ce4b64ae7153c29dc2f394--eafd4f85ff0a4a2eb302ee8a27ef9b1f 0a99fbadc78b4b9791d56bf0850044b0 X eafd4f85ff0a4a2eb302ee8a27ef9b1f--0a99fbadc78b4b9791d56bf0850044b0 0a99fbadc78b4b9791d56bf0850044b0--d14f6fef898047ba97e9b5255bf0b819 511e7c7a3d37477589cb4f59494b39d1 X 0a99fbadc78b4b9791d56bf0850044b0--511e7c7a3d37477589cb4f59494b39d1 511e7c7a3d37477589cb4f59494b39d1--315c007d1b4c42b0b2b036ce6413222f 14ef9abe0c0549719810f6c75c4920f3 511e7c7a3d37477589cb4f59494b39d1--14ef9abe0c0549719810f6c75c4920f3 f4bf6ddf47914facafad2df35433663b 14ef9abe0c0549719810f6c75c4920f3--f4bf6ddf47914facafad2df35433663b 4cee8cfc89414433880aa81981cb030b f4bf6ddf47914facafad2df35433663b--4cee8cfc89414433880aa81981cb030b d0478e8dd1794bd8a163138be7b14674 4cee8cfc89414433880aa81981cb030b--d0478e8dd1794bd8a163138be7b14674 2f17e3ea5a2d464fbe69eda1444252b3 d0478e8dd1794bd8a163138be7b14674--2f17e3ea5a2d464fbe69eda1444252b3 ee304dbafc244156a71a13e6979b8be8 2f17e3ea5a2d464fbe69eda1444252b3--ee304dbafc244156a71a13e6979b8be8 116a6837f93246a6bf59c80fb4062ba1 ee304dbafc244156a71a13e6979b8be8--116a6837f93246a6bf59c80fb4062ba1 10e7da139a634a3ea6ebb3db6d8e20b7 116a6837f93246a6bf59c80fb4062ba1--10e7da139a634a3ea6ebb3db6d8e20b7 51b78ee002a54908b9facc57b5595069 10e7da139a634a3ea6ebb3db6d8e20b7--51b78ee002a54908b9facc57b5595069 c8e06d1f7c584f6dbef0fdf332e53bee X 51b78ee002a54908b9facc57b5595069--c8e06d1f7c584f6dbef0fdf332e53bee c8e06d1f7c584f6dbef0fdf332e53bee--cd547994c61a45b18c08d074f41ad359 d872abc7e3c84028920dbf162e683cfe c8e06d1f7c584f6dbef0fdf332e53bee--d872abc7e3c84028920dbf162e683cfe 7d6cc77d73b84cf0a77193fa0fbd1c21 d872abc7e3c84028920dbf162e683cfe--7d6cc77d73b84cf0a77193fa0fbd1c21 cd8a06bc4853462eaec1989d09424106 7d6cc77d73b84cf0a77193fa0fbd1c21--cd8a06bc4853462eaec1989d09424106 be881331752c48e1aced5ba1147e45fb cd8a06bc4853462eaec1989d09424106--be881331752c48e1aced5ba1147e45fb 498d0c91467a4e88b035da9893d30233 be881331752c48e1aced5ba1147e45fb--498d0c91467a4e88b035da9893d30233 63021cd7ea4d4a6d96d43e23058845da 498d0c91467a4e88b035da9893d30233--63021cd7ea4d4a6d96d43e23058845da 7d83db8d5f724991a3ac6d45f4bec624 63021cd7ea4d4a6d96d43e23058845da--7d83db8d5f724991a3ac6d45f4bec624 65b791dcccd147efabf63a6a09dab882 7d83db8d5f724991a3ac6d45f4bec624--65b791dcccd147efabf63a6a09dab882 3ad7fe07b539465c9d2f40d6d8529226 65b791dcccd147efabf63a6a09dab882--3ad7fe07b539465c9d2f40d6d8529226 4c8b16bee4174749b1e767fe1c575694 3ad7fe07b539465c9d2f40d6d8529226--4c8b16bee4174749b1e767fe1c575694 00c4ea0587d74baa85b79518e84cf881 4c8b16bee4174749b1e767fe1c575694--00c4ea0587d74baa85b79518e84cf881 e1ac4fb51df94fa2b4f010b4eb40d118 00c4ea0587d74baa85b79518e84cf881--e1ac4fb51df94fa2b4f010b4eb40d118 98681c1d7de84a51ae692563efc479c4 e1ac4fb51df94fa2b4f010b4eb40d118--98681c1d7de84a51ae692563efc479c4 06e7d53333334315a93f145db653854c 98681c1d7de84a51ae692563efc479c4--06e7d53333334315a93f145db653854c a3652d8594554fe48158f486f1e6b9eb 06e7d53333334315a93f145db653854c--a3652d8594554fe48158f486f1e6b9eb 7b9f8b4bdec64c10aeb585de4dc20cc8 a3652d8594554fe48158f486f1e6b9eb--7b9f8b4bdec64c10aeb585de4dc20cc8 eea959fc34044906bd664dd81e4b7d66 7b9f8b4bdec64c10aeb585de4dc20cc8--eea959fc34044906bd664dd81e4b7d66 99a3ec5e8f3143979978139f6a29d081 eea959fc34044906bd664dd81e4b7d66--99a3ec5e8f3143979978139f6a29d081 024f1f059e144acdbd832f50df61e834 RX(b13) 99a3ec5e8f3143979978139f6a29d081--024f1f059e144acdbd832f50df61e834 024f1f059e144acdbd832f50df61e834--cadc477ecc5a4a24baceccf4efd88efd 7901c6a9a78d4d22ab5f8e2e5f753f0b 292975bc9e744820acb516f4751bce80 dc16a021328f47498db93b3873195602--292975bc9e744820acb516f4751bce80 501aef08c32b47e9bad13effc14d8a32 5 415b82573fc7447d9fac9f1c60487ba7 292975bc9e744820acb516f4751bce80--415b82573fc7447d9fac9f1c60487ba7 cade02e6935144d69a62ad4b1f7a53e6 415b82573fc7447d9fac9f1c60487ba7--cade02e6935144d69a62ad4b1f7a53e6 e3923c0a68da4ed6bb9d08333ad4ded5 X cade02e6935144d69a62ad4b1f7a53e6--e3923c0a68da4ed6bb9d08333ad4ded5 e3923c0a68da4ed6bb9d08333ad4ded5--15a7f6c9f5ef4e68a56b53c1f357b4de 032621a23c7941ba9a446329d1e49e93 e3923c0a68da4ed6bb9d08333ad4ded5--032621a23c7941ba9a446329d1e49e93 7750f75dc0654499aa71341043dfb646 032621a23c7941ba9a446329d1e49e93--7750f75dc0654499aa71341043dfb646 01ab22631e5f490297a7532ebd5b9a33 7750f75dc0654499aa71341043dfb646--01ab22631e5f490297a7532ebd5b9a33 8c26b675386c4d98aaf6eaa5cd75af22 01ab22631e5f490297a7532ebd5b9a33--8c26b675386c4d98aaf6eaa5cd75af22 316ea2ade635495198871c4caa933b2a 8c26b675386c4d98aaf6eaa5cd75af22--316ea2ade635495198871c4caa933b2a 74302a4aa5fa46909e1ea593954d3d4a 316ea2ade635495198871c4caa933b2a--74302a4aa5fa46909e1ea593954d3d4a db303bf7afb74355954c4a5ddac350de 74302a4aa5fa46909e1ea593954d3d4a--db303bf7afb74355954c4a5ddac350de a24d833cf63a437d88828ec938d66034 X db303bf7afb74355954c4a5ddac350de--a24d833cf63a437d88828ec938d66034 a24d833cf63a437d88828ec938d66034--aae51796082947c894f7112a74a0584b 139e5a1ba05b410881b7b7b1d8e42395 a24d833cf63a437d88828ec938d66034--139e5a1ba05b410881b7b7b1d8e42395 5c563ca02f064ffe842bedaf77c86921 139e5a1ba05b410881b7b7b1d8e42395--5c563ca02f064ffe842bedaf77c86921 8f8be0c792cd4f6f81472414ec57048a 5c563ca02f064ffe842bedaf77c86921--8f8be0c792cd4f6f81472414ec57048a ea623c130cd941869cb43b84c3f75baa 8f8be0c792cd4f6f81472414ec57048a--ea623c130cd941869cb43b84c3f75baa 99bd71fafbf742f7a4013091a8c87f2b ea623c130cd941869cb43b84c3f75baa--99bd71fafbf742f7a4013091a8c87f2b 176b24ed3f6a4456aa6bf2d8e8a481c5 99bd71fafbf742f7a4013091a8c87f2b--176b24ed3f6a4456aa6bf2d8e8a481c5 964dae4f5bfa4e1ea9727f107400e21c 176b24ed3f6a4456aa6bf2d8e8a481c5--964dae4f5bfa4e1ea9727f107400e21c 9b82aec985ba472e8747ec456be0e6d8 964dae4f5bfa4e1ea9727f107400e21c--9b82aec985ba472e8747ec456be0e6d8 dbd655ebb17f44928267727bf95e16ca 9b82aec985ba472e8747ec456be0e6d8--dbd655ebb17f44928267727bf95e16ca 16bf72119de04da9b59982993f7990b3 dbd655ebb17f44928267727bf95e16ca--16bf72119de04da9b59982993f7990b3 e2265ad3b20f4aad82a421b55cdf1896 16bf72119de04da9b59982993f7990b3--e2265ad3b20f4aad82a421b55cdf1896 0c90229a23c64968b42d11d8528d325b e2265ad3b20f4aad82a421b55cdf1896--0c90229a23c64968b42d11d8528d325b 4ee0f069877640be9c5f164c03f0c32a 0c90229a23c64968b42d11d8528d325b--4ee0f069877640be9c5f164c03f0c32a acdae7d4e4bd4bccb892fc63ce07cdc0 4ee0f069877640be9c5f164c03f0c32a--acdae7d4e4bd4bccb892fc63ce07cdc0 e43ba6ea508a45cc82845e08bd5fa3a1 acdae7d4e4bd4bccb892fc63ce07cdc0--e43ba6ea508a45cc82845e08bd5fa3a1 612980d1edfe476cba6a962a1c0b6f1b e43ba6ea508a45cc82845e08bd5fa3a1--612980d1edfe476cba6a962a1c0b6f1b c7e8bf03d1fe46b7b59ae2ff39ad5786 612980d1edfe476cba6a962a1c0b6f1b--c7e8bf03d1fe46b7b59ae2ff39ad5786 cf1bf226763b423b8b8ad0fc1ab0cbd4 c7e8bf03d1fe46b7b59ae2ff39ad5786--cf1bf226763b423b8b8ad0fc1ab0cbd4 09265dcbe1ee414fbd00f2dbb2b27303 X cf1bf226763b423b8b8ad0fc1ab0cbd4--09265dcbe1ee414fbd00f2dbb2b27303 09265dcbe1ee414fbd00f2dbb2b27303--6da45ae1e2c84e3c9636d5972c8cfa88 090ccc87b7024046b795b6661a52ef9a RZ(-1.0*g0) 09265dcbe1ee414fbd00f2dbb2b27303--090ccc87b7024046b795b6661a52ef9a 4cf24c2154e345b6b821c96cb3946b60 X 090ccc87b7024046b795b6661a52ef9a--4cf24c2154e345b6b821c96cb3946b60 4cf24c2154e345b6b821c96cb3946b60--a583ed13ef224e4abfaa9003fe21487c 6667ade346a54d09bae0cc607ba50a54 4cf24c2154e345b6b821c96cb3946b60--6667ade346a54d09bae0cc607ba50a54 55ea16b2723547008ffe7679035a0368 6667ade346a54d09bae0cc607ba50a54--55ea16b2723547008ffe7679035a0368 5a4c975c5d7249f5937ede97d77019f5 55ea16b2723547008ffe7679035a0368--5a4c975c5d7249f5937ede97d77019f5 779892a2ae99416fb29d57a9a78a2fa1 5a4c975c5d7249f5937ede97d77019f5--779892a2ae99416fb29d57a9a78a2fa1 cc04f581bc764454809bdadee50a00d3 779892a2ae99416fb29d57a9a78a2fa1--cc04f581bc764454809bdadee50a00d3 6da1f3d10fc6483cb4be0469117266fb cc04f581bc764454809bdadee50a00d3--6da1f3d10fc6483cb4be0469117266fb 4851f70293204f24b0322a02e638ed5b X 6da1f3d10fc6483cb4be0469117266fb--4851f70293204f24b0322a02e638ed5b 4851f70293204f24b0322a02e638ed5b--d4f3d0513f1340a3ab62999e373f7068 02d516b007414375996469a6f26c7de9 4851f70293204f24b0322a02e638ed5b--02d516b007414375996469a6f26c7de9 40e4a212647f4786a24313f51e25aa8f 02d516b007414375996469a6f26c7de9--40e4a212647f4786a24313f51e25aa8f 1f54a6bb2f5c4ff3b0fd6f03b9023b3d 40e4a212647f4786a24313f51e25aa8f--1f54a6bb2f5c4ff3b0fd6f03b9023b3d 8251661ab9f7457f8bd48d1794c00d4c 1f54a6bb2f5c4ff3b0fd6f03b9023b3d--8251661ab9f7457f8bd48d1794c00d4c c54d85b80ba64f3f8672486dfcdab8e4 8251661ab9f7457f8bd48d1794c00d4c--c54d85b80ba64f3f8672486dfcdab8e4 bc0ebcf9408c4120a2e92f03a732c081 X c54d85b80ba64f3f8672486dfcdab8e4--bc0ebcf9408c4120a2e92f03a732c081 bc0ebcf9408c4120a2e92f03a732c081--786336daa0404c76a3f2679e3155382c d8b092355ca6452ca8e60e6e910e26a7 bc0ebcf9408c4120a2e92f03a732c081--d8b092355ca6452ca8e60e6e910e26a7 ff21cae7a65744278b3f9407af5897a5 d8b092355ca6452ca8e60e6e910e26a7--ff21cae7a65744278b3f9407af5897a5 149ce08c560f470199079bb336214a54 ff21cae7a65744278b3f9407af5897a5--149ce08c560f470199079bb336214a54 49c83174193243c18975f14e5e70e9a0 149ce08c560f470199079bb336214a54--49c83174193243c18975f14e5e70e9a0 3bec1f870a294ad3a2801fdae4bf6419 49c83174193243c18975f14e5e70e9a0--3bec1f870a294ad3a2801fdae4bf6419 4cde9462a8764335972608737138996b 3bec1f870a294ad3a2801fdae4bf6419--4cde9462a8764335972608737138996b 53f662d4895348ed85c02510526de176 4cde9462a8764335972608737138996b--53f662d4895348ed85c02510526de176 614aacfb7bab474e94ea20fa8dd6e0ec 53f662d4895348ed85c02510526de176--614aacfb7bab474e94ea20fa8dd6e0ec 3250090b8e9b4a03a4b94e5c94a5b28a 614aacfb7bab474e94ea20fa8dd6e0ec--3250090b8e9b4a03a4b94e5c94a5b28a 8a9f5d521dff434db97cfbcac8a34ff2 3250090b8e9b4a03a4b94e5c94a5b28a--8a9f5d521dff434db97cfbcac8a34ff2 1eaf40c06a774654adc8dea9215f13a3 X 8a9f5d521dff434db97cfbcac8a34ff2--1eaf40c06a774654adc8dea9215f13a3 1eaf40c06a774654adc8dea9215f13a3--d3ec3853fac0424f9dbe130d505a0840 7812cbe1166f4756975386bba31c0020 1eaf40c06a774654adc8dea9215f13a3--7812cbe1166f4756975386bba31c0020 5b6f4a2b1c364cb1ac15ba727a8402d0 7812cbe1166f4756975386bba31c0020--5b6f4a2b1c364cb1ac15ba727a8402d0 7a79920aa55e4143922487be648842dc 5b6f4a2b1c364cb1ac15ba727a8402d0--7a79920aa55e4143922487be648842dc 542cbc6262e74d88aeae00962de25fe2 7a79920aa55e4143922487be648842dc--542cbc6262e74d88aeae00962de25fe2 88275a11c9504b9897d3d0059231b007 542cbc6262e74d88aeae00962de25fe2--88275a11c9504b9897d3d0059231b007 7b5e936ccce54bafa723b3d7d88992e4 X 88275a11c9504b9897d3d0059231b007--7b5e936ccce54bafa723b3d7d88992e4 7b5e936ccce54bafa723b3d7d88992e4--fda5fcbf2e6f4998b84815853db68bef fa0fe1c7d6734c08a18f41ebfcc6b234 7b5e936ccce54bafa723b3d7d88992e4--fa0fe1c7d6734c08a18f41ebfcc6b234 db24c34dcda641b9bf1a350be93bce10 fa0fe1c7d6734c08a18f41ebfcc6b234--db24c34dcda641b9bf1a350be93bce10 11bb05ebea3a499dae519f1c40a157f3 db24c34dcda641b9bf1a350be93bce10--11bb05ebea3a499dae519f1c40a157f3 573eeccef25841be92a3396d0811a148 11bb05ebea3a499dae519f1c40a157f3--573eeccef25841be92a3396d0811a148 d7f827cb5a7d4d99b4b8b0b14b3ecf5d X 573eeccef25841be92a3396d0811a148--d7f827cb5a7d4d99b4b8b0b14b3ecf5d d7f827cb5a7d4d99b4b8b0b14b3ecf5d--f62f1bb629f94849b4de8a3cbd4640e0 57054fe90d13482aad10861767aecde6 d7f827cb5a7d4d99b4b8b0b14b3ecf5d--57054fe90d13482aad10861767aecde6 400d755226d6470a99aed21c090a6015 57054fe90d13482aad10861767aecde6--400d755226d6470a99aed21c090a6015 678fe5e6f0774610a055ec6f513899bd 400d755226d6470a99aed21c090a6015--678fe5e6f0774610a055ec6f513899bd 3bac7eac3e004788a448cc9c4c73fa0f 678fe5e6f0774610a055ec6f513899bd--3bac7eac3e004788a448cc9c4c73fa0f 45d9efe5d02c4697a4d67f5f3cf8e9f7 3bac7eac3e004788a448cc9c4c73fa0f--45d9efe5d02c4697a4d67f5f3cf8e9f7 dd6fabc1429649c8bad2c7450d2069fe 45d9efe5d02c4697a4d67f5f3cf8e9f7--dd6fabc1429649c8bad2c7450d2069fe 29f55e53fed8425e91b8b6d4f0d1f796 dd6fabc1429649c8bad2c7450d2069fe--29f55e53fed8425e91b8b6d4f0d1f796 bb9a1fa8cf794a3ca54a0c9609d367e8 X 29f55e53fed8425e91b8b6d4f0d1f796--bb9a1fa8cf794a3ca54a0c9609d367e8 bb9a1fa8cf794a3ca54a0c9609d367e8--c739ab1c8beb4cfb95c1921cd0d6e00b 9b5169e026804dd7876a13e0a242dbf8 bb9a1fa8cf794a3ca54a0c9609d367e8--9b5169e026804dd7876a13e0a242dbf8 5c44cd0dd51945fab7ddb65e06787705 9b5169e026804dd7876a13e0a242dbf8--5c44cd0dd51945fab7ddb65e06787705 310bc098ee274cedbefca518774e1c55 5c44cd0dd51945fab7ddb65e06787705--310bc098ee274cedbefca518774e1c55 c32d84479c984baeb455c16136308d62 X 310bc098ee274cedbefca518774e1c55--c32d84479c984baeb455c16136308d62 c32d84479c984baeb455c16136308d62--0b9e768e270c481aaa15f34b64f07a09 def8af592c8049e3a28d5fb7bac53a93 RZ(-1.0*g0) c32d84479c984baeb455c16136308d62--def8af592c8049e3a28d5fb7bac53a93 6776e954e4d54b1ba3281dd418b7a505 X def8af592c8049e3a28d5fb7bac53a93--6776e954e4d54b1ba3281dd418b7a505 6776e954e4d54b1ba3281dd418b7a505--e7c3e25c44904dbe8f8b38d973cd2410 03fc48ef42554bcb8c9ffda6c1914ab8 6776e954e4d54b1ba3281dd418b7a505--03fc48ef42554bcb8c9ffda6c1914ab8 21d012d1a12e4b9d9eb758218cd3fa00 03fc48ef42554bcb8c9ffda6c1914ab8--21d012d1a12e4b9d9eb758218cd3fa00 272cc0577e9b4579be54d205eff31c6b X 21d012d1a12e4b9d9eb758218cd3fa00--272cc0577e9b4579be54d205eff31c6b 272cc0577e9b4579be54d205eff31c6b--7ecb00303055433684a8397d26006173 18d65a140e54425a9fb11aa02878604e 272cc0577e9b4579be54d205eff31c6b--18d65a140e54425a9fb11aa02878604e c11acc1fa88b467081039cac5e10ecd0 18d65a140e54425a9fb11aa02878604e--c11acc1fa88b467081039cac5e10ecd0 741adf8b72fc4dc2afcca3152a2c501f c11acc1fa88b467081039cac5e10ecd0--741adf8b72fc4dc2afcca3152a2c501f 01a90446fc934f64acb5d2808f055b9e X 741adf8b72fc4dc2afcca3152a2c501f--01a90446fc934f64acb5d2808f055b9e 01a90446fc934f64acb5d2808f055b9e--9524c611126f4cad80bb281acb3a1e96 ea26853fd8ee472798d129816cb79045 01a90446fc934f64acb5d2808f055b9e--ea26853fd8ee472798d129816cb79045 210b61c5c3644d19a0eb29fea51c078c ea26853fd8ee472798d129816cb79045--210b61c5c3644d19a0eb29fea51c078c 5aa26e2d3fcb43ac831318fd7de04206 X 210b61c5c3644d19a0eb29fea51c078c--5aa26e2d3fcb43ac831318fd7de04206 5aa26e2d3fcb43ac831318fd7de04206--c380859468df4fa8b4d1e4794a83e1b4 3b878242a55b459584beeea903ac90cd 5aa26e2d3fcb43ac831318fd7de04206--3b878242a55b459584beeea903ac90cd 015141b3834343f7aba2844189610112 3b878242a55b459584beeea903ac90cd--015141b3834343f7aba2844189610112 30fb630bf59946bf876b9f9c783d08a9 015141b3834343f7aba2844189610112--30fb630bf59946bf876b9f9c783d08a9 e1fe8a88bf654d95a8e9411307b9b504 30fb630bf59946bf876b9f9c783d08a9--e1fe8a88bf654d95a8e9411307b9b504 bf3317ac44d04ec8a899f35d7de42e7f e1fe8a88bf654d95a8e9411307b9b504--bf3317ac44d04ec8a899f35d7de42e7f 3e58687b63b1420e82d49cbb7e72a520 bf3317ac44d04ec8a899f35d7de42e7f--3e58687b63b1420e82d49cbb7e72a520 ee08b0098b67431d8409f19396172496 3e58687b63b1420e82d49cbb7e72a520--ee08b0098b67431d8409f19396172496 89195481a77442efaca9ad64ed38581c X ee08b0098b67431d8409f19396172496--89195481a77442efaca9ad64ed38581c 89195481a77442efaca9ad64ed38581c--4752149c46c54ea18c5340d20a4f0ca0 2ebcb72818dd4125a6b1e33ce63cd79e 89195481a77442efaca9ad64ed38581c--2ebcb72818dd4125a6b1e33ce63cd79e 0d77b9953655483a8a9d35077386b3f8 X 2ebcb72818dd4125a6b1e33ce63cd79e--0d77b9953655483a8a9d35077386b3f8 0d77b9953655483a8a9d35077386b3f8--4545ac44b323436d92bc8ec543806614 2f8213a34ed8491a8849997da77acbc8 RZ(-1.0*g0) 0d77b9953655483a8a9d35077386b3f8--2f8213a34ed8491a8849997da77acbc8 aea1bcf11daf47388f1e5f27f4980a53 X 2f8213a34ed8491a8849997da77acbc8--aea1bcf11daf47388f1e5f27f4980a53 aea1bcf11daf47388f1e5f27f4980a53--b5f73791c0f74b3da782de1c8049e734 1ca1d70d38fd4770b62833f04fa57765 X aea1bcf11daf47388f1e5f27f4980a53--1ca1d70d38fd4770b62833f04fa57765 1ca1d70d38fd4770b62833f04fa57765--c637cccdacad4d26aa010d6eaa00dd80 6edd4065e7104ae7950f0fbf5df4bd02 1ca1d70d38fd4770b62833f04fa57765--6edd4065e7104ae7950f0fbf5df4bd02 5fb506a634f14aaf97e5e9092538fe48 6edd4065e7104ae7950f0fbf5df4bd02--5fb506a634f14aaf97e5e9092538fe48 7136ed08b6e140ecae69cef98e4a7594 5fb506a634f14aaf97e5e9092538fe48--7136ed08b6e140ecae69cef98e4a7594 bf1025710f774b53ae83dbe589e5264d X 7136ed08b6e140ecae69cef98e4a7594--bf1025710f774b53ae83dbe589e5264d bf1025710f774b53ae83dbe589e5264d--051fc5dd79d84fc18e5aa737b0bc0cd0 05cad86195d446f1bf83238aca7e4f9e X bf1025710f774b53ae83dbe589e5264d--05cad86195d446f1bf83238aca7e4f9e 05cad86195d446f1bf83238aca7e4f9e--5730ac2eae984a0992995e5d217a7001 18b918ab6d1f46f1951016c0206b6dd0 05cad86195d446f1bf83238aca7e4f9e--18b918ab6d1f46f1951016c0206b6dd0 699428bf4c1740b6898b24532d9e4e51 18b918ab6d1f46f1951016c0206b6dd0--699428bf4c1740b6898b24532d9e4e51 5a3953786df841efaf39c09afd735a09 699428bf4c1740b6898b24532d9e4e51--5a3953786df841efaf39c09afd735a09 034a3eb2a645471f94c101ba13e605ba 5a3953786df841efaf39c09afd735a09--034a3eb2a645471f94c101ba13e605ba f05de1b8675a4666a8d275bf3fd290f9 034a3eb2a645471f94c101ba13e605ba--f05de1b8675a4666a8d275bf3fd290f9 d86e06f7388346adacbbbf9dbb064422 X f05de1b8675a4666a8d275bf3fd290f9--d86e06f7388346adacbbbf9dbb064422 d86e06f7388346adacbbbf9dbb064422--094c0df7712b497599bada782d8a4edc 7d98b99bd18340a182317e9bbb3fbb0c d86e06f7388346adacbbbf9dbb064422--7d98b99bd18340a182317e9bbb3fbb0c df8a1a66e33544fe830816d32f09e691 7d98b99bd18340a182317e9bbb3fbb0c--df8a1a66e33544fe830816d32f09e691 3077040a5239431d951d0f81d9899926 df8a1a66e33544fe830816d32f09e691--3077040a5239431d951d0f81d9899926 ebf7e6d01d0f4eaab6cac8d052a03220 RX(b04) 3077040a5239431d951d0f81d9899926--ebf7e6d01d0f4eaab6cac8d052a03220 406f743e20b24adabbaeafe6c7d52249 ebf7e6d01d0f4eaab6cac8d052a03220--406f743e20b24adabbaeafe6c7d52249 3755c3d2d73d470c93efd508a41b2457 406f743e20b24adabbaeafe6c7d52249--3755c3d2d73d470c93efd508a41b2457 e2b9dbbe93ab40f9acc784450ea51781 3755c3d2d73d470c93efd508a41b2457--e2b9dbbe93ab40f9acc784450ea51781 f0e0384c8f9d451d93cc1b2fb0ca2b11 X e2b9dbbe93ab40f9acc784450ea51781--f0e0384c8f9d451d93cc1b2fb0ca2b11 f0e0384c8f9d451d93cc1b2fb0ca2b11--09db479b433f45febd3e293ec20b9bc8 abfeec8f0ac040dd8973fa74576ef34e f0e0384c8f9d451d93cc1b2fb0ca2b11--abfeec8f0ac040dd8973fa74576ef34e e72010f9fe564c138964d0d8158ab00b abfeec8f0ac040dd8973fa74576ef34e--e72010f9fe564c138964d0d8158ab00b 535fe83344b545aeaf437fb92e3507a5 e72010f9fe564c138964d0d8158ab00b--535fe83344b545aeaf437fb92e3507a5 cf6088e0e70d4f8bb3bba3b35412e199 535fe83344b545aeaf437fb92e3507a5--cf6088e0e70d4f8bb3bba3b35412e199 dcdaedc8b4ae49339e60d6910960a72f cf6088e0e70d4f8bb3bba3b35412e199--dcdaedc8b4ae49339e60d6910960a72f b474911a169b45d1b7ef98261c5f54f1 dcdaedc8b4ae49339e60d6910960a72f--b474911a169b45d1b7ef98261c5f54f1 772201a1bd994f18b88bc2a2ba13e30a b474911a169b45d1b7ef98261c5f54f1--772201a1bd994f18b88bc2a2ba13e30a 6e9af7e853384809bcf4ad39c956026b X 772201a1bd994f18b88bc2a2ba13e30a--6e9af7e853384809bcf4ad39c956026b 6e9af7e853384809bcf4ad39c956026b--74a64e6d2a684e6a9b54fcfca8d2517c abfe522fa5ff4da8b0c0ec47126d44d0 6e9af7e853384809bcf4ad39c956026b--abfe522fa5ff4da8b0c0ec47126d44d0 ed7ebef003544f12a62f38e6b7c56b25 abfe522fa5ff4da8b0c0ec47126d44d0--ed7ebef003544f12a62f38e6b7c56b25 e0e0e925eecc415abbda922383ad488b ed7ebef003544f12a62f38e6b7c56b25--e0e0e925eecc415abbda922383ad488b 8d0add941f194fa39a5a93aefb7851f9 e0e0e925eecc415abbda922383ad488b--8d0add941f194fa39a5a93aefb7851f9 896e03a8445a470fb2a78c34318eb2e7 8d0add941f194fa39a5a93aefb7851f9--896e03a8445a470fb2a78c34318eb2e7 df7ddc33ad4549b4a0265cd0edbfae24 896e03a8445a470fb2a78c34318eb2e7--df7ddc33ad4549b4a0265cd0edbfae24 41264297fdfb462a8030941ecdb282ce df7ddc33ad4549b4a0265cd0edbfae24--41264297fdfb462a8030941ecdb282ce 1facf981540a4dbbbbfb134e34c25839 41264297fdfb462a8030941ecdb282ce--1facf981540a4dbbbbfb134e34c25839 4908309661114978a11e2f5ba698008f 1facf981540a4dbbbbfb134e34c25839--4908309661114978a11e2f5ba698008f f6e607dab34e433f954c1cc4cf3524d0 4908309661114978a11e2f5ba698008f--f6e607dab34e433f954c1cc4cf3524d0 ca0f43eba97c45bc8aa624bf88a694aa f6e607dab34e433f954c1cc4cf3524d0--ca0f43eba97c45bc8aa624bf88a694aa 1e522ff9459e4dfc9181b8c712d07164 ca0f43eba97c45bc8aa624bf88a694aa--1e522ff9459e4dfc9181b8c712d07164 ea0aefa14c784ddf85a34783040eaa44 1e522ff9459e4dfc9181b8c712d07164--ea0aefa14c784ddf85a34783040eaa44 d175b5127cf94adcb1e1cfc674ec8993 ea0aefa14c784ddf85a34783040eaa44--d175b5127cf94adcb1e1cfc674ec8993 3ad4b15a944b4539982d521166b532e9 d175b5127cf94adcb1e1cfc674ec8993--3ad4b15a944b4539982d521166b532e9 5d7d6bc6a31740249f4e536f518c3310 3ad4b15a944b4539982d521166b532e9--5d7d6bc6a31740249f4e536f518c3310 c69627cb2f044943a7334422652b73ce 5d7d6bc6a31740249f4e536f518c3310--c69627cb2f044943a7334422652b73ce a019da8114c3405298cd0f6c325d43c8 c69627cb2f044943a7334422652b73ce--a019da8114c3405298cd0f6c325d43c8 5665f95e54364f98aea1778758e037fe X a019da8114c3405298cd0f6c325d43c8--5665f95e54364f98aea1778758e037fe 5665f95e54364f98aea1778758e037fe--7a8f9618033e478d9a9810f7215d8faf cdb2cd0a170842a79947c44ed0ac404b RZ(-1.0*g1) 5665f95e54364f98aea1778758e037fe--cdb2cd0a170842a79947c44ed0ac404b 2c073416bf8b4a378c73fafdd811ab87 X cdb2cd0a170842a79947c44ed0ac404b--2c073416bf8b4a378c73fafdd811ab87 2c073416bf8b4a378c73fafdd811ab87--525820d8524a4b378991244fab3c8863 69e8324e657f4597a3b27151da8fcf05 2c073416bf8b4a378c73fafdd811ab87--69e8324e657f4597a3b27151da8fcf05 a501dbbc0c7d479582ba5363d0e19236 69e8324e657f4597a3b27151da8fcf05--a501dbbc0c7d479582ba5363d0e19236 3c9fcf1aa9c245beb1351cb89763da40 a501dbbc0c7d479582ba5363d0e19236--3c9fcf1aa9c245beb1351cb89763da40 88bc83bdea854a4d8165794d8277b9ec 3c9fcf1aa9c245beb1351cb89763da40--88bc83bdea854a4d8165794d8277b9ec ff7d99666899457488d529c8b1aed29f 88bc83bdea854a4d8165794d8277b9ec--ff7d99666899457488d529c8b1aed29f e33d6530763b4eaa96c93ff8057b148a ff7d99666899457488d529c8b1aed29f--e33d6530763b4eaa96c93ff8057b148a 1e6fa26b710c451ebe4bc4a4868edac7 X e33d6530763b4eaa96c93ff8057b148a--1e6fa26b710c451ebe4bc4a4868edac7 1e6fa26b710c451ebe4bc4a4868edac7--58f6f219d83747d4b07f96d3acde44f2 bd8a62659cb74fb8ab98570df314d57f 1e6fa26b710c451ebe4bc4a4868edac7--bd8a62659cb74fb8ab98570df314d57f 857a58a33e1244718cbe7daea49033a9 bd8a62659cb74fb8ab98570df314d57f--857a58a33e1244718cbe7daea49033a9 ee98f21314e247bbbea157b1ec40f273 857a58a33e1244718cbe7daea49033a9--ee98f21314e247bbbea157b1ec40f273 3e62530bb5e54828bd81fe372b4cf85b ee98f21314e247bbbea157b1ec40f273--3e62530bb5e54828bd81fe372b4cf85b 0df350f549664e93ab9e56cea3a6bfcf 3e62530bb5e54828bd81fe372b4cf85b--0df350f549664e93ab9e56cea3a6bfcf 146a05adf4104c5cb076e59ce61aa3e3 X 0df350f549664e93ab9e56cea3a6bfcf--146a05adf4104c5cb076e59ce61aa3e3 146a05adf4104c5cb076e59ce61aa3e3--5146fc0ced3e40c8bfa92f920349520e 08f7fe6e4e514fd5abc24c854731a70f 146a05adf4104c5cb076e59ce61aa3e3--08f7fe6e4e514fd5abc24c854731a70f 4a5d899e91df4c3ab7ee9bf197a18d01 08f7fe6e4e514fd5abc24c854731a70f--4a5d899e91df4c3ab7ee9bf197a18d01 3b1a61839587416cb1e2dd4a6bcf587b 4a5d899e91df4c3ab7ee9bf197a18d01--3b1a61839587416cb1e2dd4a6bcf587b 714ea85ca8c148e0ac92271ddacc25f2 3b1a61839587416cb1e2dd4a6bcf587b--714ea85ca8c148e0ac92271ddacc25f2 b29fcf82696747a980dd6e2e68021fac 714ea85ca8c148e0ac92271ddacc25f2--b29fcf82696747a980dd6e2e68021fac 7408e0fa710949c8b1d7e13a7082842e b29fcf82696747a980dd6e2e68021fac--7408e0fa710949c8b1d7e13a7082842e e37fa07791004699a563e82ef9561ac1 7408e0fa710949c8b1d7e13a7082842e--e37fa07791004699a563e82ef9561ac1 bae56e0a0dff403ca60ad6326faf94c8 e37fa07791004699a563e82ef9561ac1--bae56e0a0dff403ca60ad6326faf94c8 b37d5d6114b14c6c80acd52fe5148175 bae56e0a0dff403ca60ad6326faf94c8--b37d5d6114b14c6c80acd52fe5148175 86b2dde1c59e46738c596402972c2592 b37d5d6114b14c6c80acd52fe5148175--86b2dde1c59e46738c596402972c2592 59e85e28663f4f849ebb15979cf1e71e X 86b2dde1c59e46738c596402972c2592--59e85e28663f4f849ebb15979cf1e71e 59e85e28663f4f849ebb15979cf1e71e--c9696f6b477d4d938ef5e5e524a1c313 7a1f9a1f33f842968293695128e64d95 59e85e28663f4f849ebb15979cf1e71e--7a1f9a1f33f842968293695128e64d95 976064ebfa784318ac693eccb33d408a 7a1f9a1f33f842968293695128e64d95--976064ebfa784318ac693eccb33d408a 31690185c534472b99bf2a7e9cb5339f 976064ebfa784318ac693eccb33d408a--31690185c534472b99bf2a7e9cb5339f e7a896a6498045f693fb5e7714e94d05 31690185c534472b99bf2a7e9cb5339f--e7a896a6498045f693fb5e7714e94d05 c49a81d149264c3fa662291317c4bab2 e7a896a6498045f693fb5e7714e94d05--c49a81d149264c3fa662291317c4bab2 73404afbf2c3491884e409d43bbdb077 X c49a81d149264c3fa662291317c4bab2--73404afbf2c3491884e409d43bbdb077 73404afbf2c3491884e409d43bbdb077--fbccdae11673461eb421bc9ece25416b 6c699e595c6f4f24a0ec09173c2fe80a 73404afbf2c3491884e409d43bbdb077--6c699e595c6f4f24a0ec09173c2fe80a 184992aac5284118915fbc0e215f6193 6c699e595c6f4f24a0ec09173c2fe80a--184992aac5284118915fbc0e215f6193 acafbf48dc764918b557df3e051c1f89 184992aac5284118915fbc0e215f6193--acafbf48dc764918b557df3e051c1f89 d28aea9228db4e2f9205e17c24ad8821 acafbf48dc764918b557df3e051c1f89--d28aea9228db4e2f9205e17c24ad8821 07e61be4ccdc4231a786f0db18835b7e X d28aea9228db4e2f9205e17c24ad8821--07e61be4ccdc4231a786f0db18835b7e 07e61be4ccdc4231a786f0db18835b7e--7580f8a4f9994d02bdfa220e6d258894 ad4e8063789b4b1da60f97559a0ec2fa 07e61be4ccdc4231a786f0db18835b7e--ad4e8063789b4b1da60f97559a0ec2fa f698d08e50ab4f54b5602b67d3e55452 ad4e8063789b4b1da60f97559a0ec2fa--f698d08e50ab4f54b5602b67d3e55452 fcec5d05b9714d9abce1d8cf344eeea3 f698d08e50ab4f54b5602b67d3e55452--fcec5d05b9714d9abce1d8cf344eeea3 ba73b579cc264351904f6179c3a83551 fcec5d05b9714d9abce1d8cf344eeea3--ba73b579cc264351904f6179c3a83551 49f2b26baec445b1be37b7b227dc8b01 ba73b579cc264351904f6179c3a83551--49f2b26baec445b1be37b7b227dc8b01 afdc03b8f65149adb3cedf41bed51f8f 49f2b26baec445b1be37b7b227dc8b01--afdc03b8f65149adb3cedf41bed51f8f 3a0d154813144346a5bb79530591695d afdc03b8f65149adb3cedf41bed51f8f--3a0d154813144346a5bb79530591695d 430989fc16004694a8b43ce742cc222e X 3a0d154813144346a5bb79530591695d--430989fc16004694a8b43ce742cc222e 430989fc16004694a8b43ce742cc222e--67ca1d7c94a54905abf4671d6b5278e8 c183961cd72843d2ae0a66f73335a35a 430989fc16004694a8b43ce742cc222e--c183961cd72843d2ae0a66f73335a35a db669097171a400584099915b785366e c183961cd72843d2ae0a66f73335a35a--db669097171a400584099915b785366e 1b6fbf5f30274f94b3a7b43d482f2408 db669097171a400584099915b785366e--1b6fbf5f30274f94b3a7b43d482f2408 723fc490f51943c2aba60985c6037c62 X 1b6fbf5f30274f94b3a7b43d482f2408--723fc490f51943c2aba60985c6037c62 723fc490f51943c2aba60985c6037c62--74d392f8f57d4ae6a2a78c822a729273 f33b2a610569479aa94496141be481f8 RZ(-1.0*g1) 723fc490f51943c2aba60985c6037c62--f33b2a610569479aa94496141be481f8 80ff08d22ce141438383de15371901bf X f33b2a610569479aa94496141be481f8--80ff08d22ce141438383de15371901bf 80ff08d22ce141438383de15371901bf--1a38cf7fbf2c436abbfde4932ca67aed 869ac3ae57444529ae6473b4573809b3 80ff08d22ce141438383de15371901bf--869ac3ae57444529ae6473b4573809b3 a7c1eb483bd74583915a21050c8e38cb 869ac3ae57444529ae6473b4573809b3--a7c1eb483bd74583915a21050c8e38cb 7fbcce1c9dcf4d56861e3bf6d0d4e458 X a7c1eb483bd74583915a21050c8e38cb--7fbcce1c9dcf4d56861e3bf6d0d4e458 7fbcce1c9dcf4d56861e3bf6d0d4e458--f380658e087b41aea859cf47713e5cde a8354b73f129458d8f9e85308807b47d 7fbcce1c9dcf4d56861e3bf6d0d4e458--a8354b73f129458d8f9e85308807b47d 4c3e0bcad90a487c971f225bae6e3e3a a8354b73f129458d8f9e85308807b47d--4c3e0bcad90a487c971f225bae6e3e3a 640298b915064cdcb21224fd87f3851b 4c3e0bcad90a487c971f225bae6e3e3a--640298b915064cdcb21224fd87f3851b 7126d813eacd4d93ab2956f2142cee1f X 640298b915064cdcb21224fd87f3851b--7126d813eacd4d93ab2956f2142cee1f 7126d813eacd4d93ab2956f2142cee1f--eafd4f85ff0a4a2eb302ee8a27ef9b1f f28f970528dc48098cea09eb3e510d7e 7126d813eacd4d93ab2956f2142cee1f--f28f970528dc48098cea09eb3e510d7e ed78655a0d0444629d4417f5a899ed94 f28f970528dc48098cea09eb3e510d7e--ed78655a0d0444629d4417f5a899ed94 753abf99cec04bf48ece7ab11dd683b4 X ed78655a0d0444629d4417f5a899ed94--753abf99cec04bf48ece7ab11dd683b4 753abf99cec04bf48ece7ab11dd683b4--14ef9abe0c0549719810f6c75c4920f3 5357b8be282940caab5f5d8c627ce8e5 753abf99cec04bf48ece7ab11dd683b4--5357b8be282940caab5f5d8c627ce8e5 7fe73afbcb724f7c93c9c6cd30855b84 5357b8be282940caab5f5d8c627ce8e5--7fe73afbcb724f7c93c9c6cd30855b84 0b1d9c1381c1435da55d10ad458a64dd 7fe73afbcb724f7c93c9c6cd30855b84--0b1d9c1381c1435da55d10ad458a64dd 53f748f0e56a48aebe8b398d6d0d4fa3 0b1d9c1381c1435da55d10ad458a64dd--53f748f0e56a48aebe8b398d6d0d4fa3 3027b45052434494aaa343396159078b 53f748f0e56a48aebe8b398d6d0d4fa3--3027b45052434494aaa343396159078b c155f317974749deaf264ed081c4b1f1 3027b45052434494aaa343396159078b--c155f317974749deaf264ed081c4b1f1 dc0b0c922e564648a2d547e54e28f581 c155f317974749deaf264ed081c4b1f1--dc0b0c922e564648a2d547e54e28f581 fb63c6dd9b50483581798142294e2a63 X dc0b0c922e564648a2d547e54e28f581--fb63c6dd9b50483581798142294e2a63 fb63c6dd9b50483581798142294e2a63--51b78ee002a54908b9facc57b5595069 01bd6b4268524f67a01d7869b066bb8a fb63c6dd9b50483581798142294e2a63--01bd6b4268524f67a01d7869b066bb8a 6468cbaf7b3f44119d9f10fa2c29aa90 X 01bd6b4268524f67a01d7869b066bb8a--6468cbaf7b3f44119d9f10fa2c29aa90 6468cbaf7b3f44119d9f10fa2c29aa90--d872abc7e3c84028920dbf162e683cfe 1f179447551a410f9916a060d3f4a6cf RZ(-1.0*g1) 6468cbaf7b3f44119d9f10fa2c29aa90--1f179447551a410f9916a060d3f4a6cf 904d6ac192ad47d193612d59819a0e76 X 1f179447551a410f9916a060d3f4a6cf--904d6ac192ad47d193612d59819a0e76 904d6ac192ad47d193612d59819a0e76--cd8a06bc4853462eaec1989d09424106 c1a5dc9fb648474f9b821cc3788a6a48 X 904d6ac192ad47d193612d59819a0e76--c1a5dc9fb648474f9b821cc3788a6a48 c1a5dc9fb648474f9b821cc3788a6a48--be881331752c48e1aced5ba1147e45fb ceee188f63d24aaca789885f405c9fd7 c1a5dc9fb648474f9b821cc3788a6a48--ceee188f63d24aaca789885f405c9fd7 8039efe660074b969888fc8695ebfbf1 ceee188f63d24aaca789885f405c9fd7--8039efe660074b969888fc8695ebfbf1 a0fd1a5999034d62ae4cdce33dc993c9 8039efe660074b969888fc8695ebfbf1--a0fd1a5999034d62ae4cdce33dc993c9 fb33ddb2b94449dabc643b3184f31197 X a0fd1a5999034d62ae4cdce33dc993c9--fb33ddb2b94449dabc643b3184f31197 fb33ddb2b94449dabc643b3184f31197--65b791dcccd147efabf63a6a09dab882 22ef9d6a0e604ba5887f6d678a735fd2 X fb33ddb2b94449dabc643b3184f31197--22ef9d6a0e604ba5887f6d678a735fd2 22ef9d6a0e604ba5887f6d678a735fd2--3ad7fe07b539465c9d2f40d6d8529226 5df4fb8ecadc463fb961b278db48ba23 22ef9d6a0e604ba5887f6d678a735fd2--5df4fb8ecadc463fb961b278db48ba23 f751823088ff49d49bd9ffbab852bb99 5df4fb8ecadc463fb961b278db48ba23--f751823088ff49d49bd9ffbab852bb99 2cf8f9eafaa945ba824cc057a49c1f7a f751823088ff49d49bd9ffbab852bb99--2cf8f9eafaa945ba824cc057a49c1f7a 3264ff05f80446bd8e768cee131608a4 2cf8f9eafaa945ba824cc057a49c1f7a--3264ff05f80446bd8e768cee131608a4 d6dec538c8354647bea5b5efa5b4a07a 3264ff05f80446bd8e768cee131608a4--d6dec538c8354647bea5b5efa5b4a07a 04ed6672ffe0425c86e98053f7cbdfc7 X d6dec538c8354647bea5b5efa5b4a07a--04ed6672ffe0425c86e98053f7cbdfc7 04ed6672ffe0425c86e98053f7cbdfc7--a3652d8594554fe48158f486f1e6b9eb 66ae1b0aa8db4178bb535c900632b329 04ed6672ffe0425c86e98053f7cbdfc7--66ae1b0aa8db4178bb535c900632b329 75e6c833b7b144f6a8188e1142372bbe 66ae1b0aa8db4178bb535c900632b329--75e6c833b7b144f6a8188e1142372bbe 12698bb8c7aa4cc0a83bbde643dbc070 75e6c833b7b144f6a8188e1142372bbe--12698bb8c7aa4cc0a83bbde643dbc070 a2aead67ba9045a1a4fc8bcf0bd76a23 RX(b14) 12698bb8c7aa4cc0a83bbde643dbc070--a2aead67ba9045a1a4fc8bcf0bd76a23 a2aead67ba9045a1a4fc8bcf0bd76a23--7901c6a9a78d4d22ab5f8e2e5f753f0b b10402e95b2d41929b611b31f6b18b65 3fc65c567a5c441bad691a651b8c9987 501aef08c32b47e9bad13effc14d8a32--3fc65c567a5c441bad691a651b8c9987 a0903d9c3837470b8e0346bbd0313332 6 57920e5125ea41de9c39ffa27da539fe 3fc65c567a5c441bad691a651b8c9987--57920e5125ea41de9c39ffa27da539fe 21422580c661449d8d059b18829d4e72 57920e5125ea41de9c39ffa27da539fe--21422580c661449d8d059b18829d4e72 981392d6dee54370ab16acc8bbf080e0 21422580c661449d8d059b18829d4e72--981392d6dee54370ab16acc8bbf080e0 0f9a381e29504e7ebf885ac76ebaa3b7 X 981392d6dee54370ab16acc8bbf080e0--0f9a381e29504e7ebf885ac76ebaa3b7 0f9a381e29504e7ebf885ac76ebaa3b7--032621a23c7941ba9a446329d1e49e93 25b36791436c4c61b75ba5b13ad11ee2 0f9a381e29504e7ebf885ac76ebaa3b7--25b36791436c4c61b75ba5b13ad11ee2 5c04677d23f7476b885b3e6982629e0f 25b36791436c4c61b75ba5b13ad11ee2--5c04677d23f7476b885b3e6982629e0f fa1217d610804add8695437126b8ae1d 5c04677d23f7476b885b3e6982629e0f--fa1217d610804add8695437126b8ae1d 909eb8f3ef4e4cc49c475866c585578f fa1217d610804add8695437126b8ae1d--909eb8f3ef4e4cc49c475866c585578f 590113d79b1b4ea7a48966e98fcd08db 909eb8f3ef4e4cc49c475866c585578f--590113d79b1b4ea7a48966e98fcd08db f7959dec8ab440c483b4535d8cc9e48a X 590113d79b1b4ea7a48966e98fcd08db--f7959dec8ab440c483b4535d8cc9e48a f7959dec8ab440c483b4535d8cc9e48a--db303bf7afb74355954c4a5ddac350de b1e2a52b300f4201aba9af07b6e7ccde f7959dec8ab440c483b4535d8cc9e48a--b1e2a52b300f4201aba9af07b6e7ccde 521ea72dbe9b4a98babb41513e0be28b b1e2a52b300f4201aba9af07b6e7ccde--521ea72dbe9b4a98babb41513e0be28b 5a65e426566c45c7a32dc3a73a9c9942 521ea72dbe9b4a98babb41513e0be28b--5a65e426566c45c7a32dc3a73a9c9942 60315156aebd459990abec00b3904481 5a65e426566c45c7a32dc3a73a9c9942--60315156aebd459990abec00b3904481 221a017cf80c49b9914d4c089ba23e2d 60315156aebd459990abec00b3904481--221a017cf80c49b9914d4c089ba23e2d 34da7d4276054f5387efbd42b870528b 221a017cf80c49b9914d4c089ba23e2d--34da7d4276054f5387efbd42b870528b bc4cf6552cbb44c392fffde988a88616 34da7d4276054f5387efbd42b870528b--bc4cf6552cbb44c392fffde988a88616 fe9253e322b743e2ac41ed5f0835b17e bc4cf6552cbb44c392fffde988a88616--fe9253e322b743e2ac41ed5f0835b17e a856ba1ac60549a190a6b96f4550e1ee fe9253e322b743e2ac41ed5f0835b17e--a856ba1ac60549a190a6b96f4550e1ee ff2acd7e1d064c44ba6f5c5f3e919011 a856ba1ac60549a190a6b96f4550e1ee--ff2acd7e1d064c44ba6f5c5f3e919011 a3f8f95c347240c6bf7f69c78baa986f ff2acd7e1d064c44ba6f5c5f3e919011--a3f8f95c347240c6bf7f69c78baa986f 449ef7651c6e465686b05781eff1f5de a3f8f95c347240c6bf7f69c78baa986f--449ef7651c6e465686b05781eff1f5de 847991e551fb4023ac934e86579ff461 449ef7651c6e465686b05781eff1f5de--847991e551fb4023ac934e86579ff461 82d89cbb56454ae19e0ffec3f34d193e 847991e551fb4023ac934e86579ff461--82d89cbb56454ae19e0ffec3f34d193e e213851414ef4231a342bf6196ea1ef0 82d89cbb56454ae19e0ffec3f34d193e--e213851414ef4231a342bf6196ea1ef0 d47f382214534853b84676da1f012ab9 e213851414ef4231a342bf6196ea1ef0--d47f382214534853b84676da1f012ab9 c6adb3923d894f1e8fa657ddac2fe585 d47f382214534853b84676da1f012ab9--c6adb3923d894f1e8fa657ddac2fe585 1d816fe8f4bc4965bd4de343576e4379 c6adb3923d894f1e8fa657ddac2fe585--1d816fe8f4bc4965bd4de343576e4379 838d01e8dc844ae48bbf002b1e444ae5 1d816fe8f4bc4965bd4de343576e4379--838d01e8dc844ae48bbf002b1e444ae5 84edc20d1c254cd58b201b9e572c1d64 838d01e8dc844ae48bbf002b1e444ae5--84edc20d1c254cd58b201b9e572c1d64 c714de98403f4a86995cdbc945af8a24 84edc20d1c254cd58b201b9e572c1d64--c714de98403f4a86995cdbc945af8a24 4c95ff737f724ba6a4fda93d891cb84f c714de98403f4a86995cdbc945af8a24--4c95ff737f724ba6a4fda93d891cb84f 7a4b91ef0aeb433b93ead01bac03471d 4c95ff737f724ba6a4fda93d891cb84f--7a4b91ef0aeb433b93ead01bac03471d 4ab4c7de5792470e9291bb578dda8aa9 7a4b91ef0aeb433b93ead01bac03471d--4ab4c7de5792470e9291bb578dda8aa9 ee160b3cd88040d2a6419ed47ba28fae 4ab4c7de5792470e9291bb578dda8aa9--ee160b3cd88040d2a6419ed47ba28fae 62112cc6ed5045e9b7624ca30da2b051 ee160b3cd88040d2a6419ed47ba28fae--62112cc6ed5045e9b7624ca30da2b051 80c55da16b6249b19a4a439c606d8631 62112cc6ed5045e9b7624ca30da2b051--80c55da16b6249b19a4a439c606d8631 0e6eaf19d85e4dab920db5b9f650c890 80c55da16b6249b19a4a439c606d8631--0e6eaf19d85e4dab920db5b9f650c890 5cd331371b18408c93c7bfa797a1ee0f 0e6eaf19d85e4dab920db5b9f650c890--5cd331371b18408c93c7bfa797a1ee0f d9265f267710446aa571045d5228cca6 X 5cd331371b18408c93c7bfa797a1ee0f--d9265f267710446aa571045d5228cca6 d9265f267710446aa571045d5228cca6--02d516b007414375996469a6f26c7de9 0d4af8787a7649a3bf144e1f8d6d7947 d9265f267710446aa571045d5228cca6--0d4af8787a7649a3bf144e1f8d6d7947 a229a4d5bec64f43a4510f533786287d 0d4af8787a7649a3bf144e1f8d6d7947--a229a4d5bec64f43a4510f533786287d f49285ebf0294502acf3fcb24d08247a a229a4d5bec64f43a4510f533786287d--f49285ebf0294502acf3fcb24d08247a 8187181d316748eea90ac8809d51a38f X f49285ebf0294502acf3fcb24d08247a--8187181d316748eea90ac8809d51a38f 8187181d316748eea90ac8809d51a38f--c54d85b80ba64f3f8672486dfcdab8e4 a19e16045f11493b895e16eca5b5aafe 8187181d316748eea90ac8809d51a38f--a19e16045f11493b895e16eca5b5aafe 0f422839dd1246428c5eb8aefd8666e4 a19e16045f11493b895e16eca5b5aafe--0f422839dd1246428c5eb8aefd8666e4 a29288f46e07417dad3c2906d6dcf640 0f422839dd1246428c5eb8aefd8666e4--a29288f46e07417dad3c2906d6dcf640 54ef5022e96c4ff49c5969bed8d049a8 a29288f46e07417dad3c2906d6dcf640--54ef5022e96c4ff49c5969bed8d049a8 65b035b951464935b0712957f3fecfbc 54ef5022e96c4ff49c5969bed8d049a8--65b035b951464935b0712957f3fecfbc 1aa7938198e04a2d928c6ca3cf018701 65b035b951464935b0712957f3fecfbc--1aa7938198e04a2d928c6ca3cf018701 89c979cfac8d4da893e41d1a0b17ca49 1aa7938198e04a2d928c6ca3cf018701--89c979cfac8d4da893e41d1a0b17ca49 a0bbd1dada65463fb675d6bf1587bd20 89c979cfac8d4da893e41d1a0b17ca49--a0bbd1dada65463fb675d6bf1587bd20 92ba1e6f1bc642b78ae3840ae1cceb9f a0bbd1dada65463fb675d6bf1587bd20--92ba1e6f1bc642b78ae3840ae1cceb9f e494b051af2c4a2989b50fb859a7de63 92ba1e6f1bc642b78ae3840ae1cceb9f--e494b051af2c4a2989b50fb859a7de63 4f08ebf9398f4dd3a8d5eb8717e7e1dc e494b051af2c4a2989b50fb859a7de63--4f08ebf9398f4dd3a8d5eb8717e7e1dc c1580a50688a4d21b61dd0a7046c47bb 4f08ebf9398f4dd3a8d5eb8717e7e1dc--c1580a50688a4d21b61dd0a7046c47bb 25388bdc8211487baca11497bf282657 X c1580a50688a4d21b61dd0a7046c47bb--25388bdc8211487baca11497bf282657 25388bdc8211487baca11497bf282657--7812cbe1166f4756975386bba31c0020 48ac7a7f5f3f45c0b454c409fe64e283 25388bdc8211487baca11497bf282657--48ac7a7f5f3f45c0b454c409fe64e283 bbba84c8f1364cc1b6a6b29dc8e09fed 48ac7a7f5f3f45c0b454c409fe64e283--bbba84c8f1364cc1b6a6b29dc8e09fed a2aca9c4323c400f92df728d5d52a82a bbba84c8f1364cc1b6a6b29dc8e09fed--a2aca9c4323c400f92df728d5d52a82a 0c425230aa4641f3a29ab6cf12d28c41 X a2aca9c4323c400f92df728d5d52a82a--0c425230aa4641f3a29ab6cf12d28c41 0c425230aa4641f3a29ab6cf12d28c41--88275a11c9504b9897d3d0059231b007 012ffae631504a5ba6a425fe13068c38 0c425230aa4641f3a29ab6cf12d28c41--012ffae631504a5ba6a425fe13068c38 db4819088ce64727a7c2745c3d292462 012ffae631504a5ba6a425fe13068c38--db4819088ce64727a7c2745c3d292462 6787d7ad1330405a969a547a73146907 db4819088ce64727a7c2745c3d292462--6787d7ad1330405a969a547a73146907 953880d701004f478817829077c1afd8 6787d7ad1330405a969a547a73146907--953880d701004f478817829077c1afd8 741fbe1aef9e4d38b3a72936f11839b4 953880d701004f478817829077c1afd8--741fbe1aef9e4d38b3a72936f11839b4 dac57c9e7f6e41aa943948ecf4f405cc 741fbe1aef9e4d38b3a72936f11839b4--dac57c9e7f6e41aa943948ecf4f405cc 8d84240cfdca4d99a4ba6a23b1f84d8c X dac57c9e7f6e41aa943948ecf4f405cc--8d84240cfdca4d99a4ba6a23b1f84d8c 8d84240cfdca4d99a4ba6a23b1f84d8c--57054fe90d13482aad10861767aecde6 d4e01800fb364a12a2dd7a5cb383873f 8d84240cfdca4d99a4ba6a23b1f84d8c--d4e01800fb364a12a2dd7a5cb383873f 111fa31199c6466bb20cc03ff6a0a510 d4e01800fb364a12a2dd7a5cb383873f--111fa31199c6466bb20cc03ff6a0a510 3720bbb00c6e4b2fa59f6c85523ce4e2 111fa31199c6466bb20cc03ff6a0a510--3720bbb00c6e4b2fa59f6c85523ce4e2 b5aa9d72fa1543a5a040e24f86aa67e0 3720bbb00c6e4b2fa59f6c85523ce4e2--b5aa9d72fa1543a5a040e24f86aa67e0 b49dc073e8de441a8225d2c10f825d73 b5aa9d72fa1543a5a040e24f86aa67e0--b49dc073e8de441a8225d2c10f825d73 e605b2819b814019a92d96d4b5055f15 X b49dc073e8de441a8225d2c10f825d73--e605b2819b814019a92d96d4b5055f15 e605b2819b814019a92d96d4b5055f15--29f55e53fed8425e91b8b6d4f0d1f796 e4dc2571a4e14118bd18fa3091c363fb e605b2819b814019a92d96d4b5055f15--e4dc2571a4e14118bd18fa3091c363fb ea624f9ed14f47c89bc00d9d16fe8da5 e4dc2571a4e14118bd18fa3091c363fb--ea624f9ed14f47c89bc00d9d16fe8da5 997dc1b8d8a14d71a3ab0eead4abecdb ea624f9ed14f47c89bc00d9d16fe8da5--997dc1b8d8a14d71a3ab0eead4abecdb eaa924bf9cda4739b229baaf4fb7d2ff 997dc1b8d8a14d71a3ab0eead4abecdb--eaa924bf9cda4739b229baaf4fb7d2ff 602d2cf41b9e46af860c5290d96c4968 eaa924bf9cda4739b229baaf4fb7d2ff--602d2cf41b9e46af860c5290d96c4968 e39a7906b1904bcabe5979a06ab649e9 602d2cf41b9e46af860c5290d96c4968--e39a7906b1904bcabe5979a06ab649e9 fd15a216da1546f78647c071686ce7cb e39a7906b1904bcabe5979a06ab649e9--fd15a216da1546f78647c071686ce7cb 7edb6a8f9ddc449d8f9e3845611820f4 fd15a216da1546f78647c071686ce7cb--7edb6a8f9ddc449d8f9e3845611820f4 e4b3748055734c3bb039ff5f6e12fa65 7edb6a8f9ddc449d8f9e3845611820f4--e4b3748055734c3bb039ff5f6e12fa65 9f668d661eb84105a3cdca4adb4e633a e4b3748055734c3bb039ff5f6e12fa65--9f668d661eb84105a3cdca4adb4e633a 211c31615251429aac14f9efd6aeea7b X 9f668d661eb84105a3cdca4adb4e633a--211c31615251429aac14f9efd6aeea7b 211c31615251429aac14f9efd6aeea7b--18d65a140e54425a9fb11aa02878604e f68aae61ee5342988209d95e5331bbdd RZ(-1.0*g0) 211c31615251429aac14f9efd6aeea7b--f68aae61ee5342988209d95e5331bbdd 3d0eb273e1b742789e23779d8f381107 X f68aae61ee5342988209d95e5331bbdd--3d0eb273e1b742789e23779d8f381107 3d0eb273e1b742789e23779d8f381107--741adf8b72fc4dc2afcca3152a2c501f 3e8ef929d0974d45a84607b8e6f94356 3d0eb273e1b742789e23779d8f381107--3e8ef929d0974d45a84607b8e6f94356 d09692ee9ed6485186cbd3a8efacded8 3e8ef929d0974d45a84607b8e6f94356--d09692ee9ed6485186cbd3a8efacded8 a25c96c481ad476e9123b76f26f9789e d09692ee9ed6485186cbd3a8efacded8--a25c96c481ad476e9123b76f26f9789e 14f30efe541d4eed81134ded85a63d35 a25c96c481ad476e9123b76f26f9789e--14f30efe541d4eed81134ded85a63d35 c93d45aca8c8485c8dddf0bcb1841c02 X 14f30efe541d4eed81134ded85a63d35--c93d45aca8c8485c8dddf0bcb1841c02 c93d45aca8c8485c8dddf0bcb1841c02--3b878242a55b459584beeea903ac90cd 3aaa19bb46014eb6bd9b12c31ffb55ac c93d45aca8c8485c8dddf0bcb1841c02--3aaa19bb46014eb6bd9b12c31ffb55ac c82182f42261446087d6930a13423970 3aaa19bb46014eb6bd9b12c31ffb55ac--c82182f42261446087d6930a13423970 dde1dbe563f94dc0afc4415d71bbfe5c c82182f42261446087d6930a13423970--dde1dbe563f94dc0afc4415d71bbfe5c 1f5c8a9c54824122bfbb2de919c2a2bd dde1dbe563f94dc0afc4415d71bbfe5c--1f5c8a9c54824122bfbb2de919c2a2bd 718be104f2f342f6bac970b44648d621 1f5c8a9c54824122bfbb2de919c2a2bd--718be104f2f342f6bac970b44648d621 698c88cddd8945b0bdf1f7ff299f9573 X 718be104f2f342f6bac970b44648d621--698c88cddd8945b0bdf1f7ff299f9573 698c88cddd8945b0bdf1f7ff299f9573--ee08b0098b67431d8409f19396172496 88537127706141189bf3f8cb514279d1 698c88cddd8945b0bdf1f7ff299f9573--88537127706141189bf3f8cb514279d1 c5c5635325694f3b87d39af15ad35543 88537127706141189bf3f8cb514279d1--c5c5635325694f3b87d39af15ad35543 1ac7946d03f94cf8b667595d15352901 c5c5635325694f3b87d39af15ad35543--1ac7946d03f94cf8b667595d15352901 26793f02105740c1bf49cdb8912f3fb4 1ac7946d03f94cf8b667595d15352901--26793f02105740c1bf49cdb8912f3fb4 8ea7fb459ab0441ca2869d99c116fe33 26793f02105740c1bf49cdb8912f3fb4--8ea7fb459ab0441ca2869d99c116fe33 f533c0b0dbdf40fbbf124eb6814f4688 8ea7fb459ab0441ca2869d99c116fe33--f533c0b0dbdf40fbbf124eb6814f4688 e20c963ec52241bcac8de187f7b105d5 X f533c0b0dbdf40fbbf124eb6814f4688--e20c963ec52241bcac8de187f7b105d5 e20c963ec52241bcac8de187f7b105d5--6edd4065e7104ae7950f0fbf5df4bd02 7281ea37965b4716ab0d6e810ad20b0f RZ(-1.0*g0) e20c963ec52241bcac8de187f7b105d5--7281ea37965b4716ab0d6e810ad20b0f ecf2c80b039e41bc8ed626f8cd95fc41 X 7281ea37965b4716ab0d6e810ad20b0f--ecf2c80b039e41bc8ed626f8cd95fc41 ecf2c80b039e41bc8ed626f8cd95fc41--7136ed08b6e140ecae69cef98e4a7594 696defae8064493f9ca4803eca887cfb ecf2c80b039e41bc8ed626f8cd95fc41--696defae8064493f9ca4803eca887cfb 3ce9f094706d44c69a1c75924e426af3 696defae8064493f9ca4803eca887cfb--3ce9f094706d44c69a1c75924e426af3 66ba46154e6d41d2b71bd8c7858b72e6 X 3ce9f094706d44c69a1c75924e426af3--66ba46154e6d41d2b71bd8c7858b72e6 66ba46154e6d41d2b71bd8c7858b72e6--18b918ab6d1f46f1951016c0206b6dd0 4aae0e86c8e34dd9a948e2e24487d1ea 66ba46154e6d41d2b71bd8c7858b72e6--4aae0e86c8e34dd9a948e2e24487d1ea 0c03d0fe55684f8c894e71d154eef7c8 4aae0e86c8e34dd9a948e2e24487d1ea--0c03d0fe55684f8c894e71d154eef7c8 32a9ce849c4441dabd9c5081ec762fc1 0c03d0fe55684f8c894e71d154eef7c8--32a9ce849c4441dabd9c5081ec762fc1 439e923116774fce8c51ad74d013e463 X 32a9ce849c4441dabd9c5081ec762fc1--439e923116774fce8c51ad74d013e463 439e923116774fce8c51ad74d013e463--f05de1b8675a4666a8d275bf3fd290f9 b0f435147d604fae95ac0e6ff34d4dc0 439e923116774fce8c51ad74d013e463--b0f435147d604fae95ac0e6ff34d4dc0 781765a8bab84feb91e241c59a8dd39d b0f435147d604fae95ac0e6ff34d4dc0--781765a8bab84feb91e241c59a8dd39d aa5ae70193004f7f942ab2785ef4921c 781765a8bab84feb91e241c59a8dd39d--aa5ae70193004f7f942ab2785ef4921c 79bad4da784444f5ba63ff708155a611 aa5ae70193004f7f942ab2785ef4921c--79bad4da784444f5ba63ff708155a611 eb7c4b029bdf40078ac3149893241a04 RX(b05) 79bad4da784444f5ba63ff708155a611--eb7c4b029bdf40078ac3149893241a04 59f4fea950dc4c758071b1e15a2180fc eb7c4b029bdf40078ac3149893241a04--59f4fea950dc4c758071b1e15a2180fc 13e0e892e55d4fdd990347533c541521 59f4fea950dc4c758071b1e15a2180fc--13e0e892e55d4fdd990347533c541521 1e312262e26c47fa8b434a3215e3601f 13e0e892e55d4fdd990347533c541521--1e312262e26c47fa8b434a3215e3601f dfbf42ef77bb4fadb5748a3ea90eabca 1e312262e26c47fa8b434a3215e3601f--dfbf42ef77bb4fadb5748a3ea90eabca cfe7254c414848dd83c762143a1c1b40 X dfbf42ef77bb4fadb5748a3ea90eabca--cfe7254c414848dd83c762143a1c1b40 cfe7254c414848dd83c762143a1c1b40--abfeec8f0ac040dd8973fa74576ef34e e5b3790559e2425fb0ffff53f31314d1 cfe7254c414848dd83c762143a1c1b40--e5b3790559e2425fb0ffff53f31314d1 7dd8d05c268344c689bbca6a3f5dfa90 e5b3790559e2425fb0ffff53f31314d1--7dd8d05c268344c689bbca6a3f5dfa90 c1ca80ead0704d04bd5d63d12bc2b961 7dd8d05c268344c689bbca6a3f5dfa90--c1ca80ead0704d04bd5d63d12bc2b961 145bf3b69ff5486a93e59777ee5285a4 c1ca80ead0704d04bd5d63d12bc2b961--145bf3b69ff5486a93e59777ee5285a4 f163668d68444783ae3287b6a42018d5 145bf3b69ff5486a93e59777ee5285a4--f163668d68444783ae3287b6a42018d5 b65602679f5141c985fe17118fa1b126 X f163668d68444783ae3287b6a42018d5--b65602679f5141c985fe17118fa1b126 b65602679f5141c985fe17118fa1b126--772201a1bd994f18b88bc2a2ba13e30a e1012d8ffb7645ffac12f048feff9159 b65602679f5141c985fe17118fa1b126--e1012d8ffb7645ffac12f048feff9159 a3d6b10bf9b04fffa776f9f0b8917d85 e1012d8ffb7645ffac12f048feff9159--a3d6b10bf9b04fffa776f9f0b8917d85 507f8d1e8ae747948f83d922888fc9a3 a3d6b10bf9b04fffa776f9f0b8917d85--507f8d1e8ae747948f83d922888fc9a3 0100e0fc2b3b46a99674198e92f7d616 507f8d1e8ae747948f83d922888fc9a3--0100e0fc2b3b46a99674198e92f7d616 48e115bcd5cc42beb2e11d6bfe95171b 0100e0fc2b3b46a99674198e92f7d616--48e115bcd5cc42beb2e11d6bfe95171b 99130a05217c4257831347acaa72d96a 48e115bcd5cc42beb2e11d6bfe95171b--99130a05217c4257831347acaa72d96a 4fb98aa784ad4d43b050432b92eacf7d 99130a05217c4257831347acaa72d96a--4fb98aa784ad4d43b050432b92eacf7d cbba2edaff9448909171707c985539cc 4fb98aa784ad4d43b050432b92eacf7d--cbba2edaff9448909171707c985539cc 8da824445b5f43cb8fcd2ecfd982784f cbba2edaff9448909171707c985539cc--8da824445b5f43cb8fcd2ecfd982784f 4d87f3123c1443fe8d810c72e94b01ca 8da824445b5f43cb8fcd2ecfd982784f--4d87f3123c1443fe8d810c72e94b01ca 463cd73c66a248389a14aa33ba34d1a3 4d87f3123c1443fe8d810c72e94b01ca--463cd73c66a248389a14aa33ba34d1a3 993adbcb138e4c7f9acc6b9d53483d87 463cd73c66a248389a14aa33ba34d1a3--993adbcb138e4c7f9acc6b9d53483d87 495ec027d5dc4aaaa1a420f07691720f 993adbcb138e4c7f9acc6b9d53483d87--495ec027d5dc4aaaa1a420f07691720f 43d38e6d0cfc4c299389b40edd451216 495ec027d5dc4aaaa1a420f07691720f--43d38e6d0cfc4c299389b40edd451216 1637cc6402de47c1af5b914042e29c7d 43d38e6d0cfc4c299389b40edd451216--1637cc6402de47c1af5b914042e29c7d 7acc04e4205a4ebf84caa9a2c489161b 1637cc6402de47c1af5b914042e29c7d--7acc04e4205a4ebf84caa9a2c489161b 7058e75cae014d228c34de858d0c1dc1 7acc04e4205a4ebf84caa9a2c489161b--7058e75cae014d228c34de858d0c1dc1 abf3643815aa4c408660b78aa025478c 7058e75cae014d228c34de858d0c1dc1--abf3643815aa4c408660b78aa025478c 29b9c1b4d57149dfb61fe6d357a176f1 abf3643815aa4c408660b78aa025478c--29b9c1b4d57149dfb61fe6d357a176f1 f302538977724ff8b486b22eb1f7ae80 29b9c1b4d57149dfb61fe6d357a176f1--f302538977724ff8b486b22eb1f7ae80 9ef569c1a68b4b1ea40ce27112f3ebac f302538977724ff8b486b22eb1f7ae80--9ef569c1a68b4b1ea40ce27112f3ebac e7c27f99f8934b579e7e083d8cda27a8 9ef569c1a68b4b1ea40ce27112f3ebac--e7c27f99f8934b579e7e083d8cda27a8 ad04a889cd3d465f914181362dcc02ca e7c27f99f8934b579e7e083d8cda27a8--ad04a889cd3d465f914181362dcc02ca e4234175e4b840c9bb758efccc48ec35 ad04a889cd3d465f914181362dcc02ca--e4234175e4b840c9bb758efccc48ec35 4b8527b35316489e904fa199a9418016 e4234175e4b840c9bb758efccc48ec35--4b8527b35316489e904fa199a9418016 c9355d504152462f873e7c717d86ce28 4b8527b35316489e904fa199a9418016--c9355d504152462f873e7c717d86ce28 2397d17bb10945e7ad8b4c7bafdcf48f c9355d504152462f873e7c717d86ce28--2397d17bb10945e7ad8b4c7bafdcf48f 74d8ce818ddd46b5bd7290a15e437c79 2397d17bb10945e7ad8b4c7bafdcf48f--74d8ce818ddd46b5bd7290a15e437c79 2cc2495029594ef6bdf1190dd49eba0b 74d8ce818ddd46b5bd7290a15e437c79--2cc2495029594ef6bdf1190dd49eba0b ac8348b788b04293b3bfd4dfd0a803c5 X 2cc2495029594ef6bdf1190dd49eba0b--ac8348b788b04293b3bfd4dfd0a803c5 ac8348b788b04293b3bfd4dfd0a803c5--bd8a62659cb74fb8ab98570df314d57f cc008b2e04ad4ae499189efa35433c28 ac8348b788b04293b3bfd4dfd0a803c5--cc008b2e04ad4ae499189efa35433c28 1295a75049214c358ea9a8c104c6371f cc008b2e04ad4ae499189efa35433c28--1295a75049214c358ea9a8c104c6371f 35736bdb80bb4ecd846d84c117086610 1295a75049214c358ea9a8c104c6371f--35736bdb80bb4ecd846d84c117086610 61371a8c4e5c4ceb82d559066143a56d X 35736bdb80bb4ecd846d84c117086610--61371a8c4e5c4ceb82d559066143a56d 61371a8c4e5c4ceb82d559066143a56d--0df350f549664e93ab9e56cea3a6bfcf e2d4493f6f5041e89c09953855d394b9 61371a8c4e5c4ceb82d559066143a56d--e2d4493f6f5041e89c09953855d394b9 8e10fe4d06204b26b2a1636e73b1ea9d e2d4493f6f5041e89c09953855d394b9--8e10fe4d06204b26b2a1636e73b1ea9d 92f17571a6d24b15aefd33dd28522eef 8e10fe4d06204b26b2a1636e73b1ea9d--92f17571a6d24b15aefd33dd28522eef 8d4e188d745a49e18d3e1384838d2fd8 92f17571a6d24b15aefd33dd28522eef--8d4e188d745a49e18d3e1384838d2fd8 d26ee0c6722e4a3ea3201324cc1e3a07 8d4e188d745a49e18d3e1384838d2fd8--d26ee0c6722e4a3ea3201324cc1e3a07 75fc93767f2644d59644875a97616e3d d26ee0c6722e4a3ea3201324cc1e3a07--75fc93767f2644d59644875a97616e3d d140cc07af6b41aebf1575b1ec90d3ce 75fc93767f2644d59644875a97616e3d--d140cc07af6b41aebf1575b1ec90d3ce 3a6469f39186458aa8b24f25e50ea0a0 d140cc07af6b41aebf1575b1ec90d3ce--3a6469f39186458aa8b24f25e50ea0a0 3f7275966c3c4642bab70c0c123ab84c 3a6469f39186458aa8b24f25e50ea0a0--3f7275966c3c4642bab70c0c123ab84c 5354651fe13946b88b57c8f95a997054 3f7275966c3c4642bab70c0c123ab84c--5354651fe13946b88b57c8f95a997054 a2f33ffc41d34d6786116dcd676403a4 5354651fe13946b88b57c8f95a997054--a2f33ffc41d34d6786116dcd676403a4 f8b06997dcad4026be65bd33b6e4bae8 a2f33ffc41d34d6786116dcd676403a4--f8b06997dcad4026be65bd33b6e4bae8 747601430ff443d99b6fd0cd0827cb85 X f8b06997dcad4026be65bd33b6e4bae8--747601430ff443d99b6fd0cd0827cb85 747601430ff443d99b6fd0cd0827cb85--7a1f9a1f33f842968293695128e64d95 efab3e389b784d06961521933edea792 747601430ff443d99b6fd0cd0827cb85--efab3e389b784d06961521933edea792 622e209991a24e1e84f656d82ed29959 efab3e389b784d06961521933edea792--622e209991a24e1e84f656d82ed29959 94482af749c144a7908571f3a86fc62f 622e209991a24e1e84f656d82ed29959--94482af749c144a7908571f3a86fc62f 3eff85ea8b1e44c3ad215d6b2bf2e5e1 X 94482af749c144a7908571f3a86fc62f--3eff85ea8b1e44c3ad215d6b2bf2e5e1 3eff85ea8b1e44c3ad215d6b2bf2e5e1--c49a81d149264c3fa662291317c4bab2 32fe782d0ecb4cf49f3f8fe71e837e6c 3eff85ea8b1e44c3ad215d6b2bf2e5e1--32fe782d0ecb4cf49f3f8fe71e837e6c bd5e258199604db4b317897158f221e3 32fe782d0ecb4cf49f3f8fe71e837e6c--bd5e258199604db4b317897158f221e3 12dba1f0ff5d46ad8ed7226edaa0093a bd5e258199604db4b317897158f221e3--12dba1f0ff5d46ad8ed7226edaa0093a 7d5ef0439195453fa0bd631a4e000042 12dba1f0ff5d46ad8ed7226edaa0093a--7d5ef0439195453fa0bd631a4e000042 cfcd334fe3f641ab826807a39fc5ea46 7d5ef0439195453fa0bd631a4e000042--cfcd334fe3f641ab826807a39fc5ea46 96dfa18580ec47b78f5baeb34455b85a cfcd334fe3f641ab826807a39fc5ea46--96dfa18580ec47b78f5baeb34455b85a d2e19436946744e699dbe91097943fc7 X 96dfa18580ec47b78f5baeb34455b85a--d2e19436946744e699dbe91097943fc7 d2e19436946744e699dbe91097943fc7--ad4e8063789b4b1da60f97559a0ec2fa 73334f0d60ef403ca61f13e2802c91b8 d2e19436946744e699dbe91097943fc7--73334f0d60ef403ca61f13e2802c91b8 e747a9b10fe14b0285f541700db6c0df 73334f0d60ef403ca61f13e2802c91b8--e747a9b10fe14b0285f541700db6c0df 61d06240081a46ea811eb44e55051b01 e747a9b10fe14b0285f541700db6c0df--61d06240081a46ea811eb44e55051b01 d1c9d9e46e114a72b44347baf3373667 61d06240081a46ea811eb44e55051b01--d1c9d9e46e114a72b44347baf3373667 ea1e3b7b618244f79d5563978f92c591 d1c9d9e46e114a72b44347baf3373667--ea1e3b7b618244f79d5563978f92c591 9f158df6711e42d6bfac0a8079352bd1 X ea1e3b7b618244f79d5563978f92c591--9f158df6711e42d6bfac0a8079352bd1 9f158df6711e42d6bfac0a8079352bd1--3a0d154813144346a5bb79530591695d 1efbb90183b24b1487ab0e8f707de9fa 9f158df6711e42d6bfac0a8079352bd1--1efbb90183b24b1487ab0e8f707de9fa d382e8fcb58243bcb87ed7763742bdb0 1efbb90183b24b1487ab0e8f707de9fa--d382e8fcb58243bcb87ed7763742bdb0 4909f712a2a8452495d97fccaeb5e6b7 d382e8fcb58243bcb87ed7763742bdb0--4909f712a2a8452495d97fccaeb5e6b7 f465f55bd6854f3fa2ecde09500cdfcd 4909f712a2a8452495d97fccaeb5e6b7--f465f55bd6854f3fa2ecde09500cdfcd fffa03d1559c4187b5c4e53397258494 f465f55bd6854f3fa2ecde09500cdfcd--fffa03d1559c4187b5c4e53397258494 0bec809004c24cc28a9a5af51c576e8d fffa03d1559c4187b5c4e53397258494--0bec809004c24cc28a9a5af51c576e8d 7779c254a0394ddf82581ba44cef3555 0bec809004c24cc28a9a5af51c576e8d--7779c254a0394ddf82581ba44cef3555 040358a88b244bd5bc4c29cfac8abd28 7779c254a0394ddf82581ba44cef3555--040358a88b244bd5bc4c29cfac8abd28 f0e4a02820054f5fbd2cb2fb8c5f0f7e 040358a88b244bd5bc4c29cfac8abd28--f0e4a02820054f5fbd2cb2fb8c5f0f7e e5c827a15cc447f18551b1124d9a658a f0e4a02820054f5fbd2cb2fb8c5f0f7e--e5c827a15cc447f18551b1124d9a658a 09abd358ff4e47f8950050bae41a9936 X e5c827a15cc447f18551b1124d9a658a--09abd358ff4e47f8950050bae41a9936 09abd358ff4e47f8950050bae41a9936--a8354b73f129458d8f9e85308807b47d b1c5f715fc124806ac0081e0bdd5f093 RZ(-1.0*g1) 09abd358ff4e47f8950050bae41a9936--b1c5f715fc124806ac0081e0bdd5f093 a5685cf715ac48578d45126f75fa275f X b1c5f715fc124806ac0081e0bdd5f093--a5685cf715ac48578d45126f75fa275f a5685cf715ac48578d45126f75fa275f--640298b915064cdcb21224fd87f3851b f5eb20e599b7493194305dc98420e669 a5685cf715ac48578d45126f75fa275f--f5eb20e599b7493194305dc98420e669 b5c21e97b0a249b39e8afca06d29e560 f5eb20e599b7493194305dc98420e669--b5c21e97b0a249b39e8afca06d29e560 c10df6e050a94e758c1f06ce62f75eb6 b5c21e97b0a249b39e8afca06d29e560--c10df6e050a94e758c1f06ce62f75eb6 fe314fc39d8e4badbdddc0ba5465a9bc c10df6e050a94e758c1f06ce62f75eb6--fe314fc39d8e4badbdddc0ba5465a9bc f574b77d4c66439b968b140d2d05557d X fe314fc39d8e4badbdddc0ba5465a9bc--f574b77d4c66439b968b140d2d05557d f574b77d4c66439b968b140d2d05557d--5357b8be282940caab5f5d8c627ce8e5 bcf13644d9ce4c5c88cb3926ba806e18 f574b77d4c66439b968b140d2d05557d--bcf13644d9ce4c5c88cb3926ba806e18 1f29fd9ca3e54a8a915b770af7f32943 bcf13644d9ce4c5c88cb3926ba806e18--1f29fd9ca3e54a8a915b770af7f32943 6779a74438c94914b0275fb3d0feca75 1f29fd9ca3e54a8a915b770af7f32943--6779a74438c94914b0275fb3d0feca75 e76b221b381d4138ba33bacb23c350a8 6779a74438c94914b0275fb3d0feca75--e76b221b381d4138ba33bacb23c350a8 0dd5202455fc452086cb2b417b223a0c e76b221b381d4138ba33bacb23c350a8--0dd5202455fc452086cb2b417b223a0c 6e27c5ef0fd543359864c8232abe4ef3 X 0dd5202455fc452086cb2b417b223a0c--6e27c5ef0fd543359864c8232abe4ef3 6e27c5ef0fd543359864c8232abe4ef3--dc0b0c922e564648a2d547e54e28f581 2d27f8525d2d4a7185820c12ca271bc3 6e27c5ef0fd543359864c8232abe4ef3--2d27f8525d2d4a7185820c12ca271bc3 2f048072241e45009baa423c8030975e 2d27f8525d2d4a7185820c12ca271bc3--2f048072241e45009baa423c8030975e 9beb6f06acc54b02910057bf438a32b5 2f048072241e45009baa423c8030975e--9beb6f06acc54b02910057bf438a32b5 2a9cc849265c4359b3d6c8f9c8bd3a55 9beb6f06acc54b02910057bf438a32b5--2a9cc849265c4359b3d6c8f9c8bd3a55 fbf34b4d9db641fe91c4f3fadecefdc9 2a9cc849265c4359b3d6c8f9c8bd3a55--fbf34b4d9db641fe91c4f3fadecefdc9 cdcb603759b448fd8d81c84359c14996 fbf34b4d9db641fe91c4f3fadecefdc9--cdcb603759b448fd8d81c84359c14996 d528ac3fb4d54d84b8ebe44036b7a43c X cdcb603759b448fd8d81c84359c14996--d528ac3fb4d54d84b8ebe44036b7a43c d528ac3fb4d54d84b8ebe44036b7a43c--ceee188f63d24aaca789885f405c9fd7 67b592720a6340bd84622a787643672f RZ(-1.0*g1) d528ac3fb4d54d84b8ebe44036b7a43c--67b592720a6340bd84622a787643672f 06e80090a06747ceb10875facdfaca73 X 67b592720a6340bd84622a787643672f--06e80090a06747ceb10875facdfaca73 06e80090a06747ceb10875facdfaca73--a0fd1a5999034d62ae4cdce33dc993c9 3ae1a72070c84234a18871b04a1a1d74 06e80090a06747ceb10875facdfaca73--3ae1a72070c84234a18871b04a1a1d74 11d85393caa74dcd9fa6518ea6c33398 3ae1a72070c84234a18871b04a1a1d74--11d85393caa74dcd9fa6518ea6c33398 a4a4662210b8478a8a991eb64b60a4c7 X 11d85393caa74dcd9fa6518ea6c33398--a4a4662210b8478a8a991eb64b60a4c7 a4a4662210b8478a8a991eb64b60a4c7--5df4fb8ecadc463fb961b278db48ba23 6529b01123464b1792d940c495bfc23a a4a4662210b8478a8a991eb64b60a4c7--6529b01123464b1792d940c495bfc23a 8404cae383014c0ea86b3a3332072cc0 6529b01123464b1792d940c495bfc23a--8404cae383014c0ea86b3a3332072cc0 b04d7546f3924c79bdf1745e7218f1a3 8404cae383014c0ea86b3a3332072cc0--b04d7546f3924c79bdf1745e7218f1a3 5a7bccd4f9b4442892b3f9627f67bf5d X b04d7546f3924c79bdf1745e7218f1a3--5a7bccd4f9b4442892b3f9627f67bf5d 5a7bccd4f9b4442892b3f9627f67bf5d--d6dec538c8354647bea5b5efa5b4a07a 751bcdf704a545a5bf47a1c235885dc1 5a7bccd4f9b4442892b3f9627f67bf5d--751bcdf704a545a5bf47a1c235885dc1 b84315a682094327906353a4c8c567ea 751bcdf704a545a5bf47a1c235885dc1--b84315a682094327906353a4c8c567ea b4bfee4c04284d4cb57a463838a27509 b84315a682094327906353a4c8c567ea--b4bfee4c04284d4cb57a463838a27509 f84eb73765f34cdda734fa2dcff1cdbb b4bfee4c04284d4cb57a463838a27509--f84eb73765f34cdda734fa2dcff1cdbb eb8a405129e94b4498d7450c54ec9375 RX(b15) f84eb73765f34cdda734fa2dcff1cdbb--eb8a405129e94b4498d7450c54ec9375 eb8a405129e94b4498d7450c54ec9375--b10402e95b2d41929b611b31f6b18b65 efd0a370875f4c3bac18608252809920 6e65587ac0b94ff08bee4630fc9901c7 a0903d9c3837470b8e0346bbd0313332--6e65587ac0b94ff08bee4630fc9901c7 ff2cefca99284a8b9ac05f7deb8a6eb4 7 1ded67d16d024d08bf4a01a520a6d7a4 6e65587ac0b94ff08bee4630fc9901c7--1ded67d16d024d08bf4a01a520a6d7a4 9a9df834cd354db3b4cbef8431e1a7f8 1ded67d16d024d08bf4a01a520a6d7a4--9a9df834cd354db3b4cbef8431e1a7f8 e4f2239dbbae4deeacafe8abf03ad386 9a9df834cd354db3b4cbef8431e1a7f8--e4f2239dbbae4deeacafe8abf03ad386 8ada0702b86447e2ad1d2635a42c68fe e4f2239dbbae4deeacafe8abf03ad386--8ada0702b86447e2ad1d2635a42c68fe 90738644b8bd4c64abe82821990434c4 X 8ada0702b86447e2ad1d2635a42c68fe--90738644b8bd4c64abe82821990434c4 90738644b8bd4c64abe82821990434c4--25b36791436c4c61b75ba5b13ad11ee2 efbaaef137044da49776c51de83c8014 90738644b8bd4c64abe82821990434c4--efbaaef137044da49776c51de83c8014 c926e668da15492d8f85e5ba724f1c4a efbaaef137044da49776c51de83c8014--c926e668da15492d8f85e5ba724f1c4a 2ab6878898b94218b6b22090ab865bdc c926e668da15492d8f85e5ba724f1c4a--2ab6878898b94218b6b22090ab865bdc 67b5a13ab85449cf806305ffedf2772e X 2ab6878898b94218b6b22090ab865bdc--67b5a13ab85449cf806305ffedf2772e 67b5a13ab85449cf806305ffedf2772e--590113d79b1b4ea7a48966e98fcd08db 2c6d647e952e4dfc922ec034c6791985 67b5a13ab85449cf806305ffedf2772e--2c6d647e952e4dfc922ec034c6791985 8b180c53b6b04e82a31085a38e9052b6 2c6d647e952e4dfc922ec034c6791985--8b180c53b6b04e82a31085a38e9052b6 bfe6b3a4a9f3408f94c456193ed58bc0 8b180c53b6b04e82a31085a38e9052b6--bfe6b3a4a9f3408f94c456193ed58bc0 41787441226e4d26ab2cd61c34362fe8 bfe6b3a4a9f3408f94c456193ed58bc0--41787441226e4d26ab2cd61c34362fe8 aebd5028f31c4362a80691fdb2b9f8bf 41787441226e4d26ab2cd61c34362fe8--aebd5028f31c4362a80691fdb2b9f8bf 7bfd99087e714bdd91ab19c09cde9b85 aebd5028f31c4362a80691fdb2b9f8bf--7bfd99087e714bdd91ab19c09cde9b85 e93f24a71c104095bcbb7d06b83dee06 7bfd99087e714bdd91ab19c09cde9b85--e93f24a71c104095bcbb7d06b83dee06 7e78e54128f1444ea8d606c6444f0ac4 e93f24a71c104095bcbb7d06b83dee06--7e78e54128f1444ea8d606c6444f0ac4 14ba3208967a4b31b439ed4ca69d8cb3 7e78e54128f1444ea8d606c6444f0ac4--14ba3208967a4b31b439ed4ca69d8cb3 f069e21866174430993f1aefd105462b 14ba3208967a4b31b439ed4ca69d8cb3--f069e21866174430993f1aefd105462b 909120cfdeb046d1be7cf5efcee6a4bf f069e21866174430993f1aefd105462b--909120cfdeb046d1be7cf5efcee6a4bf b1b14669514640c692171822c04e2993 909120cfdeb046d1be7cf5efcee6a4bf--b1b14669514640c692171822c04e2993 58e8539e590f4d6991bdd8738d7d9b27 b1b14669514640c692171822c04e2993--58e8539e590f4d6991bdd8738d7d9b27 238c656419d34012bde34889738d10c2 58e8539e590f4d6991bdd8738d7d9b27--238c656419d34012bde34889738d10c2 1b58d8c89f544bfd908f7314d8cb749a 238c656419d34012bde34889738d10c2--1b58d8c89f544bfd908f7314d8cb749a 26a3ae74507a46b897bcf0b667e08963 1b58d8c89f544bfd908f7314d8cb749a--26a3ae74507a46b897bcf0b667e08963 c8188ec1ed474d6f981149bd58fe0143 26a3ae74507a46b897bcf0b667e08963--c8188ec1ed474d6f981149bd58fe0143 a4794ddd46984307b539ed6e242c53d7 c8188ec1ed474d6f981149bd58fe0143--a4794ddd46984307b539ed6e242c53d7 e928800a341b40649f6390718c17526a a4794ddd46984307b539ed6e242c53d7--e928800a341b40649f6390718c17526a bd49736b8d77476e9dff6f320779e692 e928800a341b40649f6390718c17526a--bd49736b8d77476e9dff6f320779e692 005002a42b9344f999c0d09985dfc876 bd49736b8d77476e9dff6f320779e692--005002a42b9344f999c0d09985dfc876 e473ba89e6394b7e81821eaf912a745f 005002a42b9344f999c0d09985dfc876--e473ba89e6394b7e81821eaf912a745f 8b57d93df63748218986cef270fb1066 e473ba89e6394b7e81821eaf912a745f--8b57d93df63748218986cef270fb1066 aa9ccca821a546ab96c96c34536ec176 8b57d93df63748218986cef270fb1066--aa9ccca821a546ab96c96c34536ec176 12a534708dcc4435bd8734d2a83eaeb0 aa9ccca821a546ab96c96c34536ec176--12a534708dcc4435bd8734d2a83eaeb0 2256c47048ad45f4bfdf4f7b3d8a69e2 12a534708dcc4435bd8734d2a83eaeb0--2256c47048ad45f4bfdf4f7b3d8a69e2 4b6699b93a764459a0e14383304321f3 2256c47048ad45f4bfdf4f7b3d8a69e2--4b6699b93a764459a0e14383304321f3 a7f8dac619c8454bab9b9a62d5464086 4b6699b93a764459a0e14383304321f3--a7f8dac619c8454bab9b9a62d5464086 97e16e2ed5b34b5aa288931e8dbc24c6 a7f8dac619c8454bab9b9a62d5464086--97e16e2ed5b34b5aa288931e8dbc24c6 2012134a3cf44b3b90e4977109a4043e 97e16e2ed5b34b5aa288931e8dbc24c6--2012134a3cf44b3b90e4977109a4043e 89f6d9f3d4564bcbbe9e5748fc5d7d6f 2012134a3cf44b3b90e4977109a4043e--89f6d9f3d4564bcbbe9e5748fc5d7d6f 2169352ba1a147fb8ffeb31d6c8fc7c9 X 89f6d9f3d4564bcbbe9e5748fc5d7d6f--2169352ba1a147fb8ffeb31d6c8fc7c9 2169352ba1a147fb8ffeb31d6c8fc7c9--0d4af8787a7649a3bf144e1f8d6d7947 12d8fb49b23c4900b7e1bd5a597099d8 RZ(-1.0*g0) 2169352ba1a147fb8ffeb31d6c8fc7c9--12d8fb49b23c4900b7e1bd5a597099d8 97ebed37d40e4018981b8e4abd6a0b5f X 12d8fb49b23c4900b7e1bd5a597099d8--97ebed37d40e4018981b8e4abd6a0b5f 97ebed37d40e4018981b8e4abd6a0b5f--f49285ebf0294502acf3fcb24d08247a ebdde0493f134472bd530559276a09fd 97ebed37d40e4018981b8e4abd6a0b5f--ebdde0493f134472bd530559276a09fd 4c7210dbb1284a9c918cfc46f6fbade1 ebdde0493f134472bd530559276a09fd--4c7210dbb1284a9c918cfc46f6fbade1 45852c472efc4c1396d9ae3e3758e0de 4c7210dbb1284a9c918cfc46f6fbade1--45852c472efc4c1396d9ae3e3758e0de 35a9291fa2fc491192edbbbee0b6f3a7 45852c472efc4c1396d9ae3e3758e0de--35a9291fa2fc491192edbbbee0b6f3a7 4ca70f9d4cf343e2944925025505b579 35a9291fa2fc491192edbbbee0b6f3a7--4ca70f9d4cf343e2944925025505b579 55b4a7501abc4388837ab12ee5316a14 4ca70f9d4cf343e2944925025505b579--55b4a7501abc4388837ab12ee5316a14 9b4d75c7201148fbba041541d41527f8 55b4a7501abc4388837ab12ee5316a14--9b4d75c7201148fbba041541d41527f8 3fc732588eb147e29301964311490f27 9b4d75c7201148fbba041541d41527f8--3fc732588eb147e29301964311490f27 78c3367b41904a97becb141595350682 3fc732588eb147e29301964311490f27--78c3367b41904a97becb141595350682 da9ca435210e4af9a2e58f66c82e566f 78c3367b41904a97becb141595350682--da9ca435210e4af9a2e58f66c82e566f aaad5da9e570400798c1808128ca06f2 da9ca435210e4af9a2e58f66c82e566f--aaad5da9e570400798c1808128ca06f2 cb875cad6994401bb1afcd70b83327fe aaad5da9e570400798c1808128ca06f2--cb875cad6994401bb1afcd70b83327fe 6c598dcdf5824398bc5e3a6ef48e22b8 cb875cad6994401bb1afcd70b83327fe--6c598dcdf5824398bc5e3a6ef48e22b8 cae1bd950fd045e5bd87283981ffcf47 6c598dcdf5824398bc5e3a6ef48e22b8--cae1bd950fd045e5bd87283981ffcf47 4dbfe8eac0a241aa9359301ffea0bea2 X cae1bd950fd045e5bd87283981ffcf47--4dbfe8eac0a241aa9359301ffea0bea2 4dbfe8eac0a241aa9359301ffea0bea2--48ac7a7f5f3f45c0b454c409fe64e283 d3d313b05cee44f693b88d1b22ab07ec RZ(-1.0*g0) 4dbfe8eac0a241aa9359301ffea0bea2--d3d313b05cee44f693b88d1b22ab07ec b67cc9b8d02747769ab5b4958a9da16a X d3d313b05cee44f693b88d1b22ab07ec--b67cc9b8d02747769ab5b4958a9da16a b67cc9b8d02747769ab5b4958a9da16a--a2aca9c4323c400f92df728d5d52a82a 06d7ee469a80472f81e6d8dde1893800 b67cc9b8d02747769ab5b4958a9da16a--06d7ee469a80472f81e6d8dde1893800 1b0068edc23d46d999ba0d6132626073 06d7ee469a80472f81e6d8dde1893800--1b0068edc23d46d999ba0d6132626073 7345fab1084c4ed9ae33bfa0ed67cd87 1b0068edc23d46d999ba0d6132626073--7345fab1084c4ed9ae33bfa0ed67cd87 c8b1e13197504ca894e03ad7b1897abf 7345fab1084c4ed9ae33bfa0ed67cd87--c8b1e13197504ca894e03ad7b1897abf 2036016b1bda49a7ab4dd4b8d8162c24 c8b1e13197504ca894e03ad7b1897abf--2036016b1bda49a7ab4dd4b8d8162c24 2541ae85397a426d89e23c5e9a46bddc 2036016b1bda49a7ab4dd4b8d8162c24--2541ae85397a426d89e23c5e9a46bddc 6a54c4871cfb45429089a7acb93125b7 2541ae85397a426d89e23c5e9a46bddc--6a54c4871cfb45429089a7acb93125b7 d2a7154728f941a9bee2737e7fcfea62 6a54c4871cfb45429089a7acb93125b7--d2a7154728f941a9bee2737e7fcfea62 dd91fab95620477b878b3897267210b4 X d2a7154728f941a9bee2737e7fcfea62--dd91fab95620477b878b3897267210b4 dd91fab95620477b878b3897267210b4--d4e01800fb364a12a2dd7a5cb383873f 13b22ca99a58485a8409315e86833b7e dd91fab95620477b878b3897267210b4--13b22ca99a58485a8409315e86833b7e 4365166653f3420fbb3ec263d42fdbf6 13b22ca99a58485a8409315e86833b7e--4365166653f3420fbb3ec263d42fdbf6 8e0fb43ffbc2410b8d05fec20482211d 4365166653f3420fbb3ec263d42fdbf6--8e0fb43ffbc2410b8d05fec20482211d 6eab3d88d20e446c8d4e1aebc6dd4cbf X 8e0fb43ffbc2410b8d05fec20482211d--6eab3d88d20e446c8d4e1aebc6dd4cbf 6eab3d88d20e446c8d4e1aebc6dd4cbf--b49dc073e8de441a8225d2c10f825d73 cca389e031644c99bb09768b2c3e2b52 6eab3d88d20e446c8d4e1aebc6dd4cbf--cca389e031644c99bb09768b2c3e2b52 b5e76335858940eabd5b5a483a376c84 cca389e031644c99bb09768b2c3e2b52--b5e76335858940eabd5b5a483a376c84 3da6589386924afdb32e230d074bb3d4 b5e76335858940eabd5b5a483a376c84--3da6589386924afdb32e230d074bb3d4 a6274ecb3eef4c86ba1f4c81363f40d4 3da6589386924afdb32e230d074bb3d4--a6274ecb3eef4c86ba1f4c81363f40d4 1b5186ee57e949beb557aa740580681a a6274ecb3eef4c86ba1f4c81363f40d4--1b5186ee57e949beb557aa740580681a 1457c6ec13cd475c9f3aa0ce946b682b 1b5186ee57e949beb557aa740580681a--1457c6ec13cd475c9f3aa0ce946b682b b4041ede178a46198333987346ee4606 1457c6ec13cd475c9f3aa0ce946b682b--b4041ede178a46198333987346ee4606 55979eaafa1a4c318a8cbc0e41ec1591 b4041ede178a46198333987346ee4606--55979eaafa1a4c318a8cbc0e41ec1591 fe28f3e409db4ba5a7539ab515b28da2 55979eaafa1a4c318a8cbc0e41ec1591--fe28f3e409db4ba5a7539ab515b28da2 79fcb0e6820c4ad59585f32e14ca4de7 fe28f3e409db4ba5a7539ab515b28da2--79fcb0e6820c4ad59585f32e14ca4de7 ec3f97e8a19646e2bef41def8e7175ee 79fcb0e6820c4ad59585f32e14ca4de7--ec3f97e8a19646e2bef41def8e7175ee 1ef0ac7c0fe546c99cc8147e84b78cbf ec3f97e8a19646e2bef41def8e7175ee--1ef0ac7c0fe546c99cc8147e84b78cbf b2ca869f535341beaeae1ba449703342 1ef0ac7c0fe546c99cc8147e84b78cbf--b2ca869f535341beaeae1ba449703342 a3b4102ff89741af9d83b724e76f8797 b2ca869f535341beaeae1ba449703342--a3b4102ff89741af9d83b724e76f8797 7c18a78ac0604e379142cec0e9577fff a3b4102ff89741af9d83b724e76f8797--7c18a78ac0604e379142cec0e9577fff b3152f79c0404dc5b055d82567b05275 7c18a78ac0604e379142cec0e9577fff--b3152f79c0404dc5b055d82567b05275 429182a5e7c24c388d51984f4764bcb0 b3152f79c0404dc5b055d82567b05275--429182a5e7c24c388d51984f4764bcb0 f4d8fd8f01f84433a1dc5e6b1640686d 429182a5e7c24c388d51984f4764bcb0--f4d8fd8f01f84433a1dc5e6b1640686d f01d8d31fde54be49ec049eb0bef6830 f4d8fd8f01f84433a1dc5e6b1640686d--f01d8d31fde54be49ec049eb0bef6830 005d9601f3a047db9b0cecd5068c06f1 X f01d8d31fde54be49ec049eb0bef6830--005d9601f3a047db9b0cecd5068c06f1 005d9601f3a047db9b0cecd5068c06f1--3aaa19bb46014eb6bd9b12c31ffb55ac 24e7a2a0fff54e788164f5c940e6964b 005d9601f3a047db9b0cecd5068c06f1--24e7a2a0fff54e788164f5c940e6964b 1ab7afd929714c5489f1e0b0980f149d 24e7a2a0fff54e788164f5c940e6964b--1ab7afd929714c5489f1e0b0980f149d 582ac6cebb52467b980ff948bc5a263d 1ab7afd929714c5489f1e0b0980f149d--582ac6cebb52467b980ff948bc5a263d bf4f9ef5e11f43799b2b2e008f92735a X 582ac6cebb52467b980ff948bc5a263d--bf4f9ef5e11f43799b2b2e008f92735a bf4f9ef5e11f43799b2b2e008f92735a--718be104f2f342f6bac970b44648d621 9c605e2596ea47d5be6ef21501288ef1 bf4f9ef5e11f43799b2b2e008f92735a--9c605e2596ea47d5be6ef21501288ef1 d83d1877cb00405495b9392dd8007e06 9c605e2596ea47d5be6ef21501288ef1--d83d1877cb00405495b9392dd8007e06 1d1bd0f8ce3e4be59d5023246a61220b d83d1877cb00405495b9392dd8007e06--1d1bd0f8ce3e4be59d5023246a61220b ae55ac7c33db4aa08fb3b9b8c48345ba 1d1bd0f8ce3e4be59d5023246a61220b--ae55ac7c33db4aa08fb3b9b8c48345ba ed14abe4b43f4616909c81dafe94363d ae55ac7c33db4aa08fb3b9b8c48345ba--ed14abe4b43f4616909c81dafe94363d 864d65720b5b46c1881a007e7f241047 ed14abe4b43f4616909c81dafe94363d--864d65720b5b46c1881a007e7f241047 da1b3075fe3846d2a3239e6cb9f09bd6 864d65720b5b46c1881a007e7f241047--da1b3075fe3846d2a3239e6cb9f09bd6 c3b2bbf0892948cb860883bd1e2d0db9 da1b3075fe3846d2a3239e6cb9f09bd6--c3b2bbf0892948cb860883bd1e2d0db9 c45fce3e1d3a4bb5a872462403bc5a01 c3b2bbf0892948cb860883bd1e2d0db9--c45fce3e1d3a4bb5a872462403bc5a01 a91e2a357482413c894ec25e27faff41 c45fce3e1d3a4bb5a872462403bc5a01--a91e2a357482413c894ec25e27faff41 5d10e14a457941779f2d1edc25004a8f a91e2a357482413c894ec25e27faff41--5d10e14a457941779f2d1edc25004a8f 4bcbc79a7899449094126531f432d837 5d10e14a457941779f2d1edc25004a8f--4bcbc79a7899449094126531f432d837 3d08d9b7a6394a2b947ac2f30621cab9 4bcbc79a7899449094126531f432d837--3d08d9b7a6394a2b947ac2f30621cab9 353d7ae507534a4bb1209025034596db X 3d08d9b7a6394a2b947ac2f30621cab9--353d7ae507534a4bb1209025034596db 353d7ae507534a4bb1209025034596db--4aae0e86c8e34dd9a948e2e24487d1ea 32c26450267f41c39e49b6b264c5fb52 RZ(-1.0*g0) 353d7ae507534a4bb1209025034596db--32c26450267f41c39e49b6b264c5fb52 1fa5be0cbd4f472fae97f56f9e814919 X 32c26450267f41c39e49b6b264c5fb52--1fa5be0cbd4f472fae97f56f9e814919 1fa5be0cbd4f472fae97f56f9e814919--32a9ce849c4441dabd9c5081ec762fc1 7d3390be392449cdb8c8447e312f4b0f 1fa5be0cbd4f472fae97f56f9e814919--7d3390be392449cdb8c8447e312f4b0f 125f10ec15b74cb3aeed4aa310aa108e 7d3390be392449cdb8c8447e312f4b0f--125f10ec15b74cb3aeed4aa310aa108e ce27187e656542cda730e0e475bb81a8 X 125f10ec15b74cb3aeed4aa310aa108e--ce27187e656542cda730e0e475bb81a8 ce27187e656542cda730e0e475bb81a8--781765a8bab84feb91e241c59a8dd39d d9105ca114784d709f5d314d99a51f07 RZ(-1.0*g0) ce27187e656542cda730e0e475bb81a8--d9105ca114784d709f5d314d99a51f07 b743a4cc9cb7462dbcb045b79eeaac73 X d9105ca114784d709f5d314d99a51f07--b743a4cc9cb7462dbcb045b79eeaac73 b743a4cc9cb7462dbcb045b79eeaac73--79bad4da784444f5ba63ff708155a611 523127fd325f4c0cb0e24c61f5056353 RX(b06) b743a4cc9cb7462dbcb045b79eeaac73--523127fd325f4c0cb0e24c61f5056353 3b42c5698cce4ca98c9bc1f90939c5d1 523127fd325f4c0cb0e24c61f5056353--3b42c5698cce4ca98c9bc1f90939c5d1 3cac5fbae7ba48d187a3be8910765aef 3b42c5698cce4ca98c9bc1f90939c5d1--3cac5fbae7ba48d187a3be8910765aef 15e4dbfbc28e45e3b0ae8a77b84cb963 3cac5fbae7ba48d187a3be8910765aef--15e4dbfbc28e45e3b0ae8a77b84cb963 63fec5e7cd6447aab3ff233cb12d6680 15e4dbfbc28e45e3b0ae8a77b84cb963--63fec5e7cd6447aab3ff233cb12d6680 7e0a3ebc886043f297ce8e6350ef59c3 63fec5e7cd6447aab3ff233cb12d6680--7e0a3ebc886043f297ce8e6350ef59c3 299af45d1d9848f49253c3405190fc2a X 7e0a3ebc886043f297ce8e6350ef59c3--299af45d1d9848f49253c3405190fc2a 299af45d1d9848f49253c3405190fc2a--e5b3790559e2425fb0ffff53f31314d1 cbe01429d8f9439e95b70b1f71cdabf2 299af45d1d9848f49253c3405190fc2a--cbe01429d8f9439e95b70b1f71cdabf2 2c962146f78148e4a7b3d86fead05522 cbe01429d8f9439e95b70b1f71cdabf2--2c962146f78148e4a7b3d86fead05522 80152c4a89e242b2b5f8ef36b60933a7 2c962146f78148e4a7b3d86fead05522--80152c4a89e242b2b5f8ef36b60933a7 199c3610be294a16a8d5cab38e8f3087 X 80152c4a89e242b2b5f8ef36b60933a7--199c3610be294a16a8d5cab38e8f3087 199c3610be294a16a8d5cab38e8f3087--f163668d68444783ae3287b6a42018d5 dc04727f4b9047e5b5385ff0f5c751f9 199c3610be294a16a8d5cab38e8f3087--dc04727f4b9047e5b5385ff0f5c751f9 2946eb16ec094f4d8fb76fcb003b616b dc04727f4b9047e5b5385ff0f5c751f9--2946eb16ec094f4d8fb76fcb003b616b dc6f6587016c4d06a2fe65ae7c1e557a 2946eb16ec094f4d8fb76fcb003b616b--dc6f6587016c4d06a2fe65ae7c1e557a 6653f4d2ee4848c68e9281c385472bac dc6f6587016c4d06a2fe65ae7c1e557a--6653f4d2ee4848c68e9281c385472bac 356e874d78f449378ef1ca8f873ce41a 6653f4d2ee4848c68e9281c385472bac--356e874d78f449378ef1ca8f873ce41a ace368a7c9564c6cb6c75fca3a051104 356e874d78f449378ef1ca8f873ce41a--ace368a7c9564c6cb6c75fca3a051104 6d6554bd60cc4453bf5c3285520fd6df ace368a7c9564c6cb6c75fca3a051104--6d6554bd60cc4453bf5c3285520fd6df 4703179c644c4f98a5fd1808f3b18095 6d6554bd60cc4453bf5c3285520fd6df--4703179c644c4f98a5fd1808f3b18095 801a07c216474e2aa1194fc1ade30b13 4703179c644c4f98a5fd1808f3b18095--801a07c216474e2aa1194fc1ade30b13 646b1727f52248dc8418ee74c9662ce5 801a07c216474e2aa1194fc1ade30b13--646b1727f52248dc8418ee74c9662ce5 ef333f44772d40269714567c57cfca3c 646b1727f52248dc8418ee74c9662ce5--ef333f44772d40269714567c57cfca3c 4481c74381144ef395df3e98f1fc93e6 ef333f44772d40269714567c57cfca3c--4481c74381144ef395df3e98f1fc93e6 c86a7452e3854559bbe0a4183fbba83c 4481c74381144ef395df3e98f1fc93e6--c86a7452e3854559bbe0a4183fbba83c bc671ae615424b43becd54e4ca4d96b6 c86a7452e3854559bbe0a4183fbba83c--bc671ae615424b43becd54e4ca4d96b6 78b979559faf46588f3104789f82b316 bc671ae615424b43becd54e4ca4d96b6--78b979559faf46588f3104789f82b316 7d0cbad7d1f6405fb865be6d3945fcc9 78b979559faf46588f3104789f82b316--7d0cbad7d1f6405fb865be6d3945fcc9 1aa08cde90d5473aa5838493d1e658ed 7d0cbad7d1f6405fb865be6d3945fcc9--1aa08cde90d5473aa5838493d1e658ed dab212da383f4562999b5be9b24c1b8e 1aa08cde90d5473aa5838493d1e658ed--dab212da383f4562999b5be9b24c1b8e a6f8b6b747384314a6fbca45917dcaf4 dab212da383f4562999b5be9b24c1b8e--a6f8b6b747384314a6fbca45917dcaf4 c7a9acc62ff84e0f9739fdb66a25ba65 a6f8b6b747384314a6fbca45917dcaf4--c7a9acc62ff84e0f9739fdb66a25ba65 2afdf2ac41354f848d47581bdfc7ad82 c7a9acc62ff84e0f9739fdb66a25ba65--2afdf2ac41354f848d47581bdfc7ad82 d5a185637c17447790c2942220783ee1 2afdf2ac41354f848d47581bdfc7ad82--d5a185637c17447790c2942220783ee1 ce303418e7fa4c539cecdf431e99c919 d5a185637c17447790c2942220783ee1--ce303418e7fa4c539cecdf431e99c919 0ab8b5aad11b4dde9b0789a6437f7dae ce303418e7fa4c539cecdf431e99c919--0ab8b5aad11b4dde9b0789a6437f7dae d29b5da5d27c4fec9d4a93b29af925d3 0ab8b5aad11b4dde9b0789a6437f7dae--d29b5da5d27c4fec9d4a93b29af925d3 3e7912e00e244ee89bad9be4ff1c5af8 d29b5da5d27c4fec9d4a93b29af925d3--3e7912e00e244ee89bad9be4ff1c5af8 57d9f83bc01e46369943081df8abe41a 3e7912e00e244ee89bad9be4ff1c5af8--57d9f83bc01e46369943081df8abe41a 459e990ffc2c40bf9af917f03062f72d 57d9f83bc01e46369943081df8abe41a--459e990ffc2c40bf9af917f03062f72d b22d3875450f44779bc062cb79c664ce 459e990ffc2c40bf9af917f03062f72d--b22d3875450f44779bc062cb79c664ce a221d429a22f4f879ed2563178015f4a b22d3875450f44779bc062cb79c664ce--a221d429a22f4f879ed2563178015f4a 4cc238522f0f4ba3a12c6cf9320bcaae a221d429a22f4f879ed2563178015f4a--4cc238522f0f4ba3a12c6cf9320bcaae c63f26bb9bbd44ec9415520287df38f7 X 4cc238522f0f4ba3a12c6cf9320bcaae--c63f26bb9bbd44ec9415520287df38f7 c63f26bb9bbd44ec9415520287df38f7--cc008b2e04ad4ae499189efa35433c28 dae1f01d15144de1b47b7ff80bd58413 RZ(-1.0*g1) c63f26bb9bbd44ec9415520287df38f7--dae1f01d15144de1b47b7ff80bd58413 1f5120c815f6417d872d4d288dfcd957 X dae1f01d15144de1b47b7ff80bd58413--1f5120c815f6417d872d4d288dfcd957 1f5120c815f6417d872d4d288dfcd957--35736bdb80bb4ecd846d84c117086610 bec65f49e03f49158a318f089267462c 1f5120c815f6417d872d4d288dfcd957--bec65f49e03f49158a318f089267462c 26ea3ad22cb84dd3aea2de87e08c0f57 bec65f49e03f49158a318f089267462c--26ea3ad22cb84dd3aea2de87e08c0f57 02a479befc3446ff94253920a90447d7 26ea3ad22cb84dd3aea2de87e08c0f57--02a479befc3446ff94253920a90447d7 150b437a59b045279f055d665365c616 02a479befc3446ff94253920a90447d7--150b437a59b045279f055d665365c616 bf3b4a138afa423fb56b9f3927b2157d 150b437a59b045279f055d665365c616--bf3b4a138afa423fb56b9f3927b2157d 06de886c9e794e69b75a1e69e82826ac bf3b4a138afa423fb56b9f3927b2157d--06de886c9e794e69b75a1e69e82826ac 7e61df591fa34ee18c9a1d598eadcb24 06de886c9e794e69b75a1e69e82826ac--7e61df591fa34ee18c9a1d598eadcb24 f754a31610be43d4b1d7a307c444ada0 7e61df591fa34ee18c9a1d598eadcb24--f754a31610be43d4b1d7a307c444ada0 cf1c9577bcd84313abdf65a17efafe00 f754a31610be43d4b1d7a307c444ada0--cf1c9577bcd84313abdf65a17efafe00 dcc41250d8354673b45c253fd34a4b08 cf1c9577bcd84313abdf65a17efafe00--dcc41250d8354673b45c253fd34a4b08 31d08aece9364df7a64e4c082918cf3e dcc41250d8354673b45c253fd34a4b08--31d08aece9364df7a64e4c082918cf3e f73805f2bffb4a56b52afe145a3ee670 31d08aece9364df7a64e4c082918cf3e--f73805f2bffb4a56b52afe145a3ee670 abb5f102be5d4d2da7c53422946108d0 f73805f2bffb4a56b52afe145a3ee670--abb5f102be5d4d2da7c53422946108d0 2b8035730ccd48a5b055a198218799b9 abb5f102be5d4d2da7c53422946108d0--2b8035730ccd48a5b055a198218799b9 ae713c57e303453ea105e64048ba55d4 X 2b8035730ccd48a5b055a198218799b9--ae713c57e303453ea105e64048ba55d4 ae713c57e303453ea105e64048ba55d4--efab3e389b784d06961521933edea792 5e35f934435e4243840d6641822bc38f RZ(-1.0*g1) ae713c57e303453ea105e64048ba55d4--5e35f934435e4243840d6641822bc38f 7697f53f62ef44c09bbdb616014736d0 X 5e35f934435e4243840d6641822bc38f--7697f53f62ef44c09bbdb616014736d0 7697f53f62ef44c09bbdb616014736d0--94482af749c144a7908571f3a86fc62f 7763555980e94e4da0357ead3cbb2757 7697f53f62ef44c09bbdb616014736d0--7763555980e94e4da0357ead3cbb2757 bf7031e7fef94597a00db97e7ee9f48f 7763555980e94e4da0357ead3cbb2757--bf7031e7fef94597a00db97e7ee9f48f 16ba5dc9c840479bb64c3a1fd072da51 bf7031e7fef94597a00db97e7ee9f48f--16ba5dc9c840479bb64c3a1fd072da51 a79d6b9cc2364e1a921af935db6d77b8 16ba5dc9c840479bb64c3a1fd072da51--a79d6b9cc2364e1a921af935db6d77b8 92ac35ab209540aa8896b8815b8a4766 a79d6b9cc2364e1a921af935db6d77b8--92ac35ab209540aa8896b8815b8a4766 730fafc3e1db4f00ba0ca5699c634281 92ac35ab209540aa8896b8815b8a4766--730fafc3e1db4f00ba0ca5699c634281 2899897723e64a99b9187661b7920b6a 730fafc3e1db4f00ba0ca5699c634281--2899897723e64a99b9187661b7920b6a b10b7b947c344f12acb6e64e577f1911 2899897723e64a99b9187661b7920b6a--b10b7b947c344f12acb6e64e577f1911 2fb4e9106e4f4de6a9b8248e8ee47e55 X b10b7b947c344f12acb6e64e577f1911--2fb4e9106e4f4de6a9b8248e8ee47e55 2fb4e9106e4f4de6a9b8248e8ee47e55--73334f0d60ef403ca61f13e2802c91b8 7dd51416339149cd9273250e9a141dec 2fb4e9106e4f4de6a9b8248e8ee47e55--7dd51416339149cd9273250e9a141dec 2bb714d5fe224da399466a6c4a9b94f4 7dd51416339149cd9273250e9a141dec--2bb714d5fe224da399466a6c4a9b94f4 a772fe5854bb4bd795ac4ded861dccc0 2bb714d5fe224da399466a6c4a9b94f4--a772fe5854bb4bd795ac4ded861dccc0 43c6b265b96d44f8835adfa20884e58d X a772fe5854bb4bd795ac4ded861dccc0--43c6b265b96d44f8835adfa20884e58d 43c6b265b96d44f8835adfa20884e58d--ea1e3b7b618244f79d5563978f92c591 358de745ba05442dbe392abc978f5afd 43c6b265b96d44f8835adfa20884e58d--358de745ba05442dbe392abc978f5afd 3d06f99012434ed0ba8de6aad3d6af7a 358de745ba05442dbe392abc978f5afd--3d06f99012434ed0ba8de6aad3d6af7a b66d86fe03504241aba586d54ab59d09 3d06f99012434ed0ba8de6aad3d6af7a--b66d86fe03504241aba586d54ab59d09 98aa0f9f906a4d1e9c988ec207eb522d b66d86fe03504241aba586d54ab59d09--98aa0f9f906a4d1e9c988ec207eb522d a03d1de3d45e4106855fb55139784afb 98aa0f9f906a4d1e9c988ec207eb522d--a03d1de3d45e4106855fb55139784afb 6ed4c28010704cafb5fdae23f5dcfcc0 a03d1de3d45e4106855fb55139784afb--6ed4c28010704cafb5fdae23f5dcfcc0 9b2a5bf7113342649611c4bd99c0732d 6ed4c28010704cafb5fdae23f5dcfcc0--9b2a5bf7113342649611c4bd99c0732d af56729e7a65473e8ac56a53f0757da8 9b2a5bf7113342649611c4bd99c0732d--af56729e7a65473e8ac56a53f0757da8 6daa6aeaa6be4c97bed56239ed4d2da6 af56729e7a65473e8ac56a53f0757da8--6daa6aeaa6be4c97bed56239ed4d2da6 7325974aca404e77a916e64870f9bbb6 6daa6aeaa6be4c97bed56239ed4d2da6--7325974aca404e77a916e64870f9bbb6 748c50ead76b4a20aa7ef379672b447a 7325974aca404e77a916e64870f9bbb6--748c50ead76b4a20aa7ef379672b447a 077d2b1f815d424596ee0147cc59a2ce 748c50ead76b4a20aa7ef379672b447a--077d2b1f815d424596ee0147cc59a2ce ef7faa83653645d699f2105bc5084b19 077d2b1f815d424596ee0147cc59a2ce--ef7faa83653645d699f2105bc5084b19 6e13b7077c0542a681bdd0a85ef1ffb6 ef7faa83653645d699f2105bc5084b19--6e13b7077c0542a681bdd0a85ef1ffb6 879d535c4bd74e1cbe0bc0f79816f063 6e13b7077c0542a681bdd0a85ef1ffb6--879d535c4bd74e1cbe0bc0f79816f063 ed63efca2db14f2ca6ee086f5e1246e9 879d535c4bd74e1cbe0bc0f79816f063--ed63efca2db14f2ca6ee086f5e1246e9 aebdb794135545f4ae4095f3e6d87aa1 ed63efca2db14f2ca6ee086f5e1246e9--aebdb794135545f4ae4095f3e6d87aa1 3c73fc3be5234ef0b6b8c2f5b272c137 aebdb794135545f4ae4095f3e6d87aa1--3c73fc3be5234ef0b6b8c2f5b272c137 668ab9c28be84efe9ef913c0208aacfd 3c73fc3be5234ef0b6b8c2f5b272c137--668ab9c28be84efe9ef913c0208aacfd 2dd51c1a4b534e7f9ea50cc98775f7f3 X 668ab9c28be84efe9ef913c0208aacfd--2dd51c1a4b534e7f9ea50cc98775f7f3 2dd51c1a4b534e7f9ea50cc98775f7f3--bcf13644d9ce4c5c88cb3926ba806e18 b8fd9948a4d6480aabc832808e944cc6 2dd51c1a4b534e7f9ea50cc98775f7f3--b8fd9948a4d6480aabc832808e944cc6 b7cb0498bbc24fe29d2a72026f92fd93 b8fd9948a4d6480aabc832808e944cc6--b7cb0498bbc24fe29d2a72026f92fd93 e2caa204f049454f89efadd44f2612a7 b7cb0498bbc24fe29d2a72026f92fd93--e2caa204f049454f89efadd44f2612a7 e900acd40f594a5e9ae7d84e05f95370 X e2caa204f049454f89efadd44f2612a7--e900acd40f594a5e9ae7d84e05f95370 e900acd40f594a5e9ae7d84e05f95370--0dd5202455fc452086cb2b417b223a0c 0c97150d9b0a486fad5f1569276b641d e900acd40f594a5e9ae7d84e05f95370--0c97150d9b0a486fad5f1569276b641d 975212260fc74f8a8daae312408f1f33 0c97150d9b0a486fad5f1569276b641d--975212260fc74f8a8daae312408f1f33 97d54ef53e054876aeac7e7e5988bb7d 975212260fc74f8a8daae312408f1f33--97d54ef53e054876aeac7e7e5988bb7d a7ed2403243343a1b002765dc7678354 97d54ef53e054876aeac7e7e5988bb7d--a7ed2403243343a1b002765dc7678354 327f8621b97d4459acc52fba7fcda6e4 a7ed2403243343a1b002765dc7678354--327f8621b97d4459acc52fba7fcda6e4 95145dd635584892b2ccbcf0c31ec093 327f8621b97d4459acc52fba7fcda6e4--95145dd635584892b2ccbcf0c31ec093 cc9e2c8b91c54165a7a695d3736861fb 95145dd635584892b2ccbcf0c31ec093--cc9e2c8b91c54165a7a695d3736861fb e5db7d20082b48a4ac25437547ff5ad2 cc9e2c8b91c54165a7a695d3736861fb--e5db7d20082b48a4ac25437547ff5ad2 c1499ee7000949ac9df8b7d99ba29904 e5db7d20082b48a4ac25437547ff5ad2--c1499ee7000949ac9df8b7d99ba29904 cebd2c83f0204e8eb83764c00e269e0f c1499ee7000949ac9df8b7d99ba29904--cebd2c83f0204e8eb83764c00e269e0f eee6243a17c243e4867059204eed1c78 cebd2c83f0204e8eb83764c00e269e0f--eee6243a17c243e4867059204eed1c78 5d0ab672c6ba4b22a278718af6e88187 eee6243a17c243e4867059204eed1c78--5d0ab672c6ba4b22a278718af6e88187 379d410ad7a74ab7bfa40ac560098ac4 5d0ab672c6ba4b22a278718af6e88187--379d410ad7a74ab7bfa40ac560098ac4 31ccc6446c4b4e09b9bba5fb3ea94be8 X 379d410ad7a74ab7bfa40ac560098ac4--31ccc6446c4b4e09b9bba5fb3ea94be8 31ccc6446c4b4e09b9bba5fb3ea94be8--6529b01123464b1792d940c495bfc23a 52be81c1b92f4bdc9e005bb66d2e6a25 RZ(-1.0*g1) 31ccc6446c4b4e09b9bba5fb3ea94be8--52be81c1b92f4bdc9e005bb66d2e6a25 7e61af1bd0204f1c8d88cafcd9075f5d X 52be81c1b92f4bdc9e005bb66d2e6a25--7e61af1bd0204f1c8d88cafcd9075f5d 7e61af1bd0204f1c8d88cafcd9075f5d--b04d7546f3924c79bdf1745e7218f1a3 125513c7e4e649bcb32798e75d363e38 7e61af1bd0204f1c8d88cafcd9075f5d--125513c7e4e649bcb32798e75d363e38 a3196c7b61d44408af8b084bbaa88a28 125513c7e4e649bcb32798e75d363e38--a3196c7b61d44408af8b084bbaa88a28 9323907184dd425ebf747319a7474801 X a3196c7b61d44408af8b084bbaa88a28--9323907184dd425ebf747319a7474801 9323907184dd425ebf747319a7474801--b84315a682094327906353a4c8c567ea 28a8d1fa40184e61ae931e6e1119c4e2 RZ(-1.0*g1) 9323907184dd425ebf747319a7474801--28a8d1fa40184e61ae931e6e1119c4e2 1a0f452b9bd34bf88eeeafed194ef41a X 28a8d1fa40184e61ae931e6e1119c4e2--1a0f452b9bd34bf88eeeafed194ef41a 1a0f452b9bd34bf88eeeafed194ef41a--f84eb73765f34cdda734fa2dcff1cdbb 1c15e58125de4b659e835f94d3bf6930 RX(b16) 1a0f452b9bd34bf88eeeafed194ef41a--1c15e58125de4b659e835f94d3bf6930 1c15e58125de4b659e835f94d3bf6930--efd0a370875f4c3bac18608252809920 155081c6326c44b488199ddc8602c0ff f68a8a9968904f21a3772a0c8c6d6676 ff2cefca99284a8b9ac05f7deb8a6eb4--f68a8a9968904f21a3772a0c8c6d6676 ee929d46d4444920b53484f1f4fd94b7 f68a8a9968904f21a3772a0c8c6d6676--ee929d46d4444920b53484f1f4fd94b7 5bda69a5cbe946d5882d60a5d2601931 ee929d46d4444920b53484f1f4fd94b7--5bda69a5cbe946d5882d60a5d2601931 1dfe8931719246a194d95d8b8dea4f04 5bda69a5cbe946d5882d60a5d2601931--1dfe8931719246a194d95d8b8dea4f04 08b703f3bae3447083e317a9e5096f1b 1dfe8931719246a194d95d8b8dea4f04--08b703f3bae3447083e317a9e5096f1b f43435dab7bc4671863674726617c738 08b703f3bae3447083e317a9e5096f1b--f43435dab7bc4671863674726617c738 97e484e5f77a46e9aaf214017fc3d4c8 X f43435dab7bc4671863674726617c738--97e484e5f77a46e9aaf214017fc3d4c8 97e484e5f77a46e9aaf214017fc3d4c8--efbaaef137044da49776c51de83c8014 b4ad6208472846f892803830a41cfd77 RZ(1.0*g0) 97e484e5f77a46e9aaf214017fc3d4c8--b4ad6208472846f892803830a41cfd77 3800b4540f30472e8e65487e4536a7d6 X b4ad6208472846f892803830a41cfd77--3800b4540f30472e8e65487e4536a7d6 3800b4540f30472e8e65487e4536a7d6--2ab6878898b94218b6b22090ab865bdc 25b656fafeed4db29d61fba6db98ba5a 3800b4540f30472e8e65487e4536a7d6--25b656fafeed4db29d61fba6db98ba5a 6fe77fd3cf6c41b2bbc0f7842ec73440 25b656fafeed4db29d61fba6db98ba5a--6fe77fd3cf6c41b2bbc0f7842ec73440 1a4137b3850f4d209a64047b021b7d3d 6fe77fd3cf6c41b2bbc0f7842ec73440--1a4137b3850f4d209a64047b021b7d3d 52c26af41286433caad74026d40f330d 1a4137b3850f4d209a64047b021b7d3d--52c26af41286433caad74026d40f330d 9d8c937534d5419e9ab7e38236795d03 52c26af41286433caad74026d40f330d--9d8c937534d5419e9ab7e38236795d03 2595782eaf5a436fac97b5ee35ba6670 9d8c937534d5419e9ab7e38236795d03--2595782eaf5a436fac97b5ee35ba6670 bf5d84939b3946d5b75cb40bd8f23584 2595782eaf5a436fac97b5ee35ba6670--bf5d84939b3946d5b75cb40bd8f23584 8c2ae505fc49423989050ed2b37f78b9 bf5d84939b3946d5b75cb40bd8f23584--8c2ae505fc49423989050ed2b37f78b9 e09a7dfef3154d85a3e6b5c7e9a1377a 8c2ae505fc49423989050ed2b37f78b9--e09a7dfef3154d85a3e6b5c7e9a1377a c4d19d6471844901ac3513d78586bd7b e09a7dfef3154d85a3e6b5c7e9a1377a--c4d19d6471844901ac3513d78586bd7b 7ba0b486aa3c48179b56415fbf859a2d c4d19d6471844901ac3513d78586bd7b--7ba0b486aa3c48179b56415fbf859a2d 1f54c4a368b74433ab822ace3ab127af 7ba0b486aa3c48179b56415fbf859a2d--1f54c4a368b74433ab822ace3ab127af 371e41e2c6d34ed4bf35ef95b014328a 1f54c4a368b74433ab822ace3ab127af--371e41e2c6d34ed4bf35ef95b014328a 5b517d65f75f4f1ca8583fbc1b13b72b 371e41e2c6d34ed4bf35ef95b014328a--5b517d65f75f4f1ca8583fbc1b13b72b e7ae37ddfd9145f9af7b88fe7ada1b86 5b517d65f75f4f1ca8583fbc1b13b72b--e7ae37ddfd9145f9af7b88fe7ada1b86 e131cd96d0414d1089cbb6d24eb9e88c e7ae37ddfd9145f9af7b88fe7ada1b86--e131cd96d0414d1089cbb6d24eb9e88c d6996357fb9343b9994ab35bf171f6ac e131cd96d0414d1089cbb6d24eb9e88c--d6996357fb9343b9994ab35bf171f6ac cce49e48c3274417aa5d84c58f0fc082 d6996357fb9343b9994ab35bf171f6ac--cce49e48c3274417aa5d84c58f0fc082 131925bcd5ed4f2faab7f1375f84aa63 cce49e48c3274417aa5d84c58f0fc082--131925bcd5ed4f2faab7f1375f84aa63 8e0de359fceb4db2a04389fe792ac6df 131925bcd5ed4f2faab7f1375f84aa63--8e0de359fceb4db2a04389fe792ac6df eb6949b25dbc450da4be237a1d079a9a 8e0de359fceb4db2a04389fe792ac6df--eb6949b25dbc450da4be237a1d079a9a 0a01515f26b143fcb269d70cf6aecbbf eb6949b25dbc450da4be237a1d079a9a--0a01515f26b143fcb269d70cf6aecbbf 19117ca36c9b45428a8bd4e79c981542 0a01515f26b143fcb269d70cf6aecbbf--19117ca36c9b45428a8bd4e79c981542 fb4a71ffb4744fbda322b27caf78d8a3 19117ca36c9b45428a8bd4e79c981542--fb4a71ffb4744fbda322b27caf78d8a3 333069e2988c44b492844818ad5b2ea5 fb4a71ffb4744fbda322b27caf78d8a3--333069e2988c44b492844818ad5b2ea5 650cc5445146473bb37ee5b8c93f7616 333069e2988c44b492844818ad5b2ea5--650cc5445146473bb37ee5b8c93f7616 f77d14ea3bdd4f75ae3f16331b72698d 650cc5445146473bb37ee5b8c93f7616--f77d14ea3bdd4f75ae3f16331b72698d d4c0f26d27bc4d9d88a9c9b2b2dd76d9 f77d14ea3bdd4f75ae3f16331b72698d--d4c0f26d27bc4d9d88a9c9b2b2dd76d9 2760c717b41d48f49e0a8443462ecf8b d4c0f26d27bc4d9d88a9c9b2b2dd76d9--2760c717b41d48f49e0a8443462ecf8b 778aa4e0dcc24d8a814bf0a09afb6149 2760c717b41d48f49e0a8443462ecf8b--778aa4e0dcc24d8a814bf0a09afb6149 a0ea238caaa149fca413160495d60f3c 778aa4e0dcc24d8a814bf0a09afb6149--a0ea238caaa149fca413160495d60f3c eabd331d5a2b497d9b8195184f75d05f a0ea238caaa149fca413160495d60f3c--eabd331d5a2b497d9b8195184f75d05f 9cc907c123e54ac083a3b48015eacf6c eabd331d5a2b497d9b8195184f75d05f--9cc907c123e54ac083a3b48015eacf6c 546c7860eb2048f89fa814ad9f1919b1 9cc907c123e54ac083a3b48015eacf6c--546c7860eb2048f89fa814ad9f1919b1 e861ac7feb8e4c05886d9bd7995f10bf 546c7860eb2048f89fa814ad9f1919b1--e861ac7feb8e4c05886d9bd7995f10bf 89837454b3ce4687b670e2b5a7b4967d e861ac7feb8e4c05886d9bd7995f10bf--89837454b3ce4687b670e2b5a7b4967d 4d183b13d55b425196a427f21eb93552 89837454b3ce4687b670e2b5a7b4967d--4d183b13d55b425196a427f21eb93552 aa909374fe844981ad1fcd9b965c6c60 4d183b13d55b425196a427f21eb93552--aa909374fe844981ad1fcd9b965c6c60 042cda3af0b54044912ebb1d30a92e77 aa909374fe844981ad1fcd9b965c6c60--042cda3af0b54044912ebb1d30a92e77 c883743c4a944585b37c4b2bccc89cf7 042cda3af0b54044912ebb1d30a92e77--c883743c4a944585b37c4b2bccc89cf7 a13fbae9dddd4f1695f6f09c2506a537 c883743c4a944585b37c4b2bccc89cf7--a13fbae9dddd4f1695f6f09c2506a537 dbf3a4d59c664fd3b2e2a8ee97b60f97 a13fbae9dddd4f1695f6f09c2506a537--dbf3a4d59c664fd3b2e2a8ee97b60f97 b1124dbd4a504834ae7c0f46a42d85e7 dbf3a4d59c664fd3b2e2a8ee97b60f97--b1124dbd4a504834ae7c0f46a42d85e7 0a9a3b14e49e47dd90258e6838e6c460 b1124dbd4a504834ae7c0f46a42d85e7--0a9a3b14e49e47dd90258e6838e6c460 ca9fa768fb014b3d98809255666281b6 0a9a3b14e49e47dd90258e6838e6c460--ca9fa768fb014b3d98809255666281b6 1f0a4e4b970e4733a0ba9dada67d5fdd ca9fa768fb014b3d98809255666281b6--1f0a4e4b970e4733a0ba9dada67d5fdd 08e5f48f260e45eeaf778b724793467d 1f0a4e4b970e4733a0ba9dada67d5fdd--08e5f48f260e45eeaf778b724793467d c30c49df1eb84713a6a906640a648c5f 08e5f48f260e45eeaf778b724793467d--c30c49df1eb84713a6a906640a648c5f f97fa66b715f45e3b8c5d70aba336246 c30c49df1eb84713a6a906640a648c5f--f97fa66b715f45e3b8c5d70aba336246 81d009b32ca84f5c834060f218eb4a65 f97fa66b715f45e3b8c5d70aba336246--81d009b32ca84f5c834060f218eb4a65 5f250b19817b40cdbaa3325d64cdcdda 81d009b32ca84f5c834060f218eb4a65--5f250b19817b40cdbaa3325d64cdcdda a406f3a650d048c19cdfb0e707194d5c 5f250b19817b40cdbaa3325d64cdcdda--a406f3a650d048c19cdfb0e707194d5c 11e92bc8d00242079289caf48a5a304a a406f3a650d048c19cdfb0e707194d5c--11e92bc8d00242079289caf48a5a304a 92f550f8f7d9417e88a6294f63cc29c2 11e92bc8d00242079289caf48a5a304a--92f550f8f7d9417e88a6294f63cc29c2 8c75008bc89440449e7ff5621253575a 92f550f8f7d9417e88a6294f63cc29c2--8c75008bc89440449e7ff5621253575a 7c873e7e1b6b4b6aa786008ad638151c 8c75008bc89440449e7ff5621253575a--7c873e7e1b6b4b6aa786008ad638151c 850a42fcf33242fd9d06472b27c1e815 7c873e7e1b6b4b6aa786008ad638151c--850a42fcf33242fd9d06472b27c1e815 49e95fa566c545778d0316b8326e8f03 850a42fcf33242fd9d06472b27c1e815--49e95fa566c545778d0316b8326e8f03 271b17515386471d99b5719927d2f2f9 49e95fa566c545778d0316b8326e8f03--271b17515386471d99b5719927d2f2f9 459fbad7779447eca480096e4d3e1f28 271b17515386471d99b5719927d2f2f9--459fbad7779447eca480096e4d3e1f28 54d4824755624c5fa8fae8f8e1bf7ae2 459fbad7779447eca480096e4d3e1f28--54d4824755624c5fa8fae8f8e1bf7ae2 2ddda0d61b2647ae9ea4101d322b8826 X 54d4824755624c5fa8fae8f8e1bf7ae2--2ddda0d61b2647ae9ea4101d322b8826 2ddda0d61b2647ae9ea4101d322b8826--13b22ca99a58485a8409315e86833b7e e4e8590122ab4852af95b455bea4d8d4 RZ(-1.0*g0) 2ddda0d61b2647ae9ea4101d322b8826--e4e8590122ab4852af95b455bea4d8d4 ccb5b10307a24f6faea0c395d40daf59 X e4e8590122ab4852af95b455bea4d8d4--ccb5b10307a24f6faea0c395d40daf59 ccb5b10307a24f6faea0c395d40daf59--8e0fb43ffbc2410b8d05fec20482211d 41dd99ad8092497c866452b30ee257e3 ccb5b10307a24f6faea0c395d40daf59--41dd99ad8092497c866452b30ee257e3 30fbfc3c07b94e1eb7ec7293d01f77db 41dd99ad8092497c866452b30ee257e3--30fbfc3c07b94e1eb7ec7293d01f77db cc8b49707bef43f783eee1d429b0c680 30fbfc3c07b94e1eb7ec7293d01f77db--cc8b49707bef43f783eee1d429b0c680 b6228001a43f4c9cb5ef59bc11c0510d cc8b49707bef43f783eee1d429b0c680--b6228001a43f4c9cb5ef59bc11c0510d 3b844eac85b3412abe9976612f06b620 b6228001a43f4c9cb5ef59bc11c0510d--3b844eac85b3412abe9976612f06b620 70feb5bf006445b0a6881d2030c8fd48 3b844eac85b3412abe9976612f06b620--70feb5bf006445b0a6881d2030c8fd48 fcc3ad6c788045b09c8c36552cdaba81 70feb5bf006445b0a6881d2030c8fd48--fcc3ad6c788045b09c8c36552cdaba81 04c6d482f67144199265c177583aa776 fcc3ad6c788045b09c8c36552cdaba81--04c6d482f67144199265c177583aa776 855daef66bc44de6a65d86f342d3cac4 04c6d482f67144199265c177583aa776--855daef66bc44de6a65d86f342d3cac4 9309566224924d8aaf6048b211178374 855daef66bc44de6a65d86f342d3cac4--9309566224924d8aaf6048b211178374 78909e70e96c484194ebb61a541a6430 9309566224924d8aaf6048b211178374--78909e70e96c484194ebb61a541a6430 ea0664e0bc734717b931a98d1c516807 78909e70e96c484194ebb61a541a6430--ea0664e0bc734717b931a98d1c516807 3c77bcced20a41238403cb3059696735 ea0664e0bc734717b931a98d1c516807--3c77bcced20a41238403cb3059696735 d2d584b6e7ef4d6d80b7fea366e35959 3c77bcced20a41238403cb3059696735--d2d584b6e7ef4d6d80b7fea366e35959 07e41002bd6c4ae28800618b18859b2a d2d584b6e7ef4d6d80b7fea366e35959--07e41002bd6c4ae28800618b18859b2a 3b5dcbec997e4ad6aeee4851c6282fd1 07e41002bd6c4ae28800618b18859b2a--3b5dcbec997e4ad6aeee4851c6282fd1 a343540d8766462b805a6c97c84660bf 3b5dcbec997e4ad6aeee4851c6282fd1--a343540d8766462b805a6c97c84660bf b5b75b30b3e343c4acf98f2204960b63 a343540d8766462b805a6c97c84660bf--b5b75b30b3e343c4acf98f2204960b63 bac74ff9ed7a4dfbba1d6708a4f85547 b5b75b30b3e343c4acf98f2204960b63--bac74ff9ed7a4dfbba1d6708a4f85547 fb70c319660248bfa0779e46d9417b2a bac74ff9ed7a4dfbba1d6708a4f85547--fb70c319660248bfa0779e46d9417b2a e7161c32ef124e8c8885127eb46b295c fb70c319660248bfa0779e46d9417b2a--e7161c32ef124e8c8885127eb46b295c 8b8d0e259e6f4291bb3841f3646df85e X e7161c32ef124e8c8885127eb46b295c--8b8d0e259e6f4291bb3841f3646df85e 8b8d0e259e6f4291bb3841f3646df85e--24e7a2a0fff54e788164f5c940e6964b 9c66c2dd2adb4c56ad35bf2bfc281a81 RZ(-1.0*g0) 8b8d0e259e6f4291bb3841f3646df85e--9c66c2dd2adb4c56ad35bf2bfc281a81 89a2f5c36c16420d910fa5dbb9fa0b36 X 9c66c2dd2adb4c56ad35bf2bfc281a81--89a2f5c36c16420d910fa5dbb9fa0b36 89a2f5c36c16420d910fa5dbb9fa0b36--582ac6cebb52467b980ff948bc5a263d 3bbc19fa28d94399b3507bf8b1a7db4e 89a2f5c36c16420d910fa5dbb9fa0b36--3bbc19fa28d94399b3507bf8b1a7db4e 3ba8766309d0496db314a8a235f62287 3bbc19fa28d94399b3507bf8b1a7db4e--3ba8766309d0496db314a8a235f62287 5cf72be747e345569f67bf2229f9853f 3ba8766309d0496db314a8a235f62287--5cf72be747e345569f67bf2229f9853f 243ef60e8a364a09bd6e3faab7aca040 5cf72be747e345569f67bf2229f9853f--243ef60e8a364a09bd6e3faab7aca040 cbcc93ab223b40d988feaf128732f120 243ef60e8a364a09bd6e3faab7aca040--cbcc93ab223b40d988feaf128732f120 3866314b587a4186a502b4b472230a25 cbcc93ab223b40d988feaf128732f120--3866314b587a4186a502b4b472230a25 822b1934d01e4969bdd26ef7ace5c107 3866314b587a4186a502b4b472230a25--822b1934d01e4969bdd26ef7ace5c107 a8ae001620a54dfb9ec612dd62e5d072 822b1934d01e4969bdd26ef7ace5c107--a8ae001620a54dfb9ec612dd62e5d072 582b3da5664a4478a6c5adbdf8946fb7 a8ae001620a54dfb9ec612dd62e5d072--582b3da5664a4478a6c5adbdf8946fb7 123fc5cd4ca74eac8e385e909fdbfb75 582b3da5664a4478a6c5adbdf8946fb7--123fc5cd4ca74eac8e385e909fdbfb75 d8029d2f5ba545c4952f3860fa472915 123fc5cd4ca74eac8e385e909fdbfb75--d8029d2f5ba545c4952f3860fa472915 1c4a9754fcae4287881b0993ea6d4df1 d8029d2f5ba545c4952f3860fa472915--1c4a9754fcae4287881b0993ea6d4df1 c22c17015b3c437fbc1ebe78aa2fa174 1c4a9754fcae4287881b0993ea6d4df1--c22c17015b3c437fbc1ebe78aa2fa174 9d689b962c0745f99bfa51d5884a31b3 c22c17015b3c437fbc1ebe78aa2fa174--9d689b962c0745f99bfa51d5884a31b3 ddd98b4153d04e40825f0879c613ce13 9d689b962c0745f99bfa51d5884a31b3--ddd98b4153d04e40825f0879c613ce13 dc0914a758664a9c94cad2ba9bc52f9f ddd98b4153d04e40825f0879c613ce13--dc0914a758664a9c94cad2ba9bc52f9f 8ee5b7214b344f1fb9a05ba40ba98625 dc0914a758664a9c94cad2ba9bc52f9f--8ee5b7214b344f1fb9a05ba40ba98625 8d1e860958a249c7bf91224a2bbfb4b9 8ee5b7214b344f1fb9a05ba40ba98625--8d1e860958a249c7bf91224a2bbfb4b9 653f904864754f8da010689dabbc22e4 8d1e860958a249c7bf91224a2bbfb4b9--653f904864754f8da010689dabbc22e4 caff3b2acc2f4169bf1eaacbe613cd3a 653f904864754f8da010689dabbc22e4--caff3b2acc2f4169bf1eaacbe613cd3a 8fc612fef06b47a4864dec4d7ded2add caff3b2acc2f4169bf1eaacbe613cd3a--8fc612fef06b47a4864dec4d7ded2add 6031846403d74882a475b18026d55caf 8fc612fef06b47a4864dec4d7ded2add--6031846403d74882a475b18026d55caf 8d1841777fc14737873ddd2039d1d946 RX(b07) 6031846403d74882a475b18026d55caf--8d1841777fc14737873ddd2039d1d946 c63dcc5b39bc4a00966520dfcc4cbdaa 8d1841777fc14737873ddd2039d1d946--c63dcc5b39bc4a00966520dfcc4cbdaa d5cac17313a04ad1977586216ee24237 c63dcc5b39bc4a00966520dfcc4cbdaa--d5cac17313a04ad1977586216ee24237 ffa54fe71feb4bbc9e61592a7c7bdcf0 d5cac17313a04ad1977586216ee24237--ffa54fe71feb4bbc9e61592a7c7bdcf0 b6ff4fdefab340f3bfdc39b658cb5c5e ffa54fe71feb4bbc9e61592a7c7bdcf0--b6ff4fdefab340f3bfdc39b658cb5c5e 6908d44ed9cd41338b00e67bf7fbdd05 b6ff4fdefab340f3bfdc39b658cb5c5e--6908d44ed9cd41338b00e67bf7fbdd05 22063e2dfe2343ebacc7c436fafbe2bd 6908d44ed9cd41338b00e67bf7fbdd05--22063e2dfe2343ebacc7c436fafbe2bd 6f9f702246c14bf691b2907146966124 X 22063e2dfe2343ebacc7c436fafbe2bd--6f9f702246c14bf691b2907146966124 6f9f702246c14bf691b2907146966124--cbe01429d8f9439e95b70b1f71cdabf2 8de850da0ac0481da6bc8a1cb636899c RZ(1.0*g1) 6f9f702246c14bf691b2907146966124--8de850da0ac0481da6bc8a1cb636899c 384345e386484957bbd894ad70817223 X 8de850da0ac0481da6bc8a1cb636899c--384345e386484957bbd894ad70817223 384345e386484957bbd894ad70817223--80152c4a89e242b2b5f8ef36b60933a7 c01a9f357c9f41128adbaef1e0fbd233 384345e386484957bbd894ad70817223--c01a9f357c9f41128adbaef1e0fbd233 55465128f7294907b2de10354fe7a475 c01a9f357c9f41128adbaef1e0fbd233--55465128f7294907b2de10354fe7a475 9faf832cce7d42eaab1ee10a6236dfac 55465128f7294907b2de10354fe7a475--9faf832cce7d42eaab1ee10a6236dfac 6203ac3e858c41ffa6549ca0b3b85dfb 9faf832cce7d42eaab1ee10a6236dfac--6203ac3e858c41ffa6549ca0b3b85dfb c15d45933b594564bc23e51541ca3d78 6203ac3e858c41ffa6549ca0b3b85dfb--c15d45933b594564bc23e51541ca3d78 68b0d36c8cbe4ff4a335380e25bc77a8 c15d45933b594564bc23e51541ca3d78--68b0d36c8cbe4ff4a335380e25bc77a8 e98d4d595bb044c58a29c84fece50b66 68b0d36c8cbe4ff4a335380e25bc77a8--e98d4d595bb044c58a29c84fece50b66 43ac69bb8d8e4b628f169675d7a60633 e98d4d595bb044c58a29c84fece50b66--43ac69bb8d8e4b628f169675d7a60633 84aaaa5fa3a047e582db5ab84100b0e5 43ac69bb8d8e4b628f169675d7a60633--84aaaa5fa3a047e582db5ab84100b0e5 67a1dad722294e828034c8f5f6ff5c95 84aaaa5fa3a047e582db5ab84100b0e5--67a1dad722294e828034c8f5f6ff5c95 a007ec691a1c41529118e66f884d0510 67a1dad722294e828034c8f5f6ff5c95--a007ec691a1c41529118e66f884d0510 cc0e3859393942698edf3848b509de86 a007ec691a1c41529118e66f884d0510--cc0e3859393942698edf3848b509de86 abd6a90f61c64d5d827f0de29c090c25 cc0e3859393942698edf3848b509de86--abd6a90f61c64d5d827f0de29c090c25 177d0efe4eb54aed9d6576c69d712df6 abd6a90f61c64d5d827f0de29c090c25--177d0efe4eb54aed9d6576c69d712df6 2cce1e95181b434e9cd02ba643ab42b5 177d0efe4eb54aed9d6576c69d712df6--2cce1e95181b434e9cd02ba643ab42b5 60985c956fe14e1cb23e703dddb862e9 2cce1e95181b434e9cd02ba643ab42b5--60985c956fe14e1cb23e703dddb862e9 f086cda7bc714ac5a7952d848b7bde48 60985c956fe14e1cb23e703dddb862e9--f086cda7bc714ac5a7952d848b7bde48 045d11447bcc474da3cc24301e771196 f086cda7bc714ac5a7952d848b7bde48--045d11447bcc474da3cc24301e771196 2977cbfc51b04922b8abb5e56c74a943 045d11447bcc474da3cc24301e771196--2977cbfc51b04922b8abb5e56c74a943 204ccb292f234efb955e18fa6fb92824 2977cbfc51b04922b8abb5e56c74a943--204ccb292f234efb955e18fa6fb92824 22cd59cc9cc44726b945a91d5938a63e 204ccb292f234efb955e18fa6fb92824--22cd59cc9cc44726b945a91d5938a63e 9f5c4ed6c99f422b9f50300bcb436ebc 22cd59cc9cc44726b945a91d5938a63e--9f5c4ed6c99f422b9f50300bcb436ebc 9bafcf29c0e34497add37f0b5d9ba0fd 9f5c4ed6c99f422b9f50300bcb436ebc--9bafcf29c0e34497add37f0b5d9ba0fd 8b5fff70c20c48a6836b7d7361339672 9bafcf29c0e34497add37f0b5d9ba0fd--8b5fff70c20c48a6836b7d7361339672 d95da67636ed4c7cb877f8df3abb1403 8b5fff70c20c48a6836b7d7361339672--d95da67636ed4c7cb877f8df3abb1403 ccbfae3a7cf34c5295f1b88ea6802f64 d95da67636ed4c7cb877f8df3abb1403--ccbfae3a7cf34c5295f1b88ea6802f64 cd4186a990bd42df83ee94ac1e75f988 ccbfae3a7cf34c5295f1b88ea6802f64--cd4186a990bd42df83ee94ac1e75f988 6a330f78893745709ed8a3bc2402a1ec cd4186a990bd42df83ee94ac1e75f988--6a330f78893745709ed8a3bc2402a1ec ef17f676dc2a4e87b70d9da0e772c64b 6a330f78893745709ed8a3bc2402a1ec--ef17f676dc2a4e87b70d9da0e772c64b 6275478783ce43c083c5991a8c628355 ef17f676dc2a4e87b70d9da0e772c64b--6275478783ce43c083c5991a8c628355 c37485776e7b49f4916991d21f3f1d6a 6275478783ce43c083c5991a8c628355--c37485776e7b49f4916991d21f3f1d6a 078c54ee8c844d3aaa53ccd04284a008 c37485776e7b49f4916991d21f3f1d6a--078c54ee8c844d3aaa53ccd04284a008 529c64137ced4da39997bd7bc470c012 078c54ee8c844d3aaa53ccd04284a008--529c64137ced4da39997bd7bc470c012 e7f1f07d650f42a98b1670b68a8087d6 529c64137ced4da39997bd7bc470c012--e7f1f07d650f42a98b1670b68a8087d6 04f7cca431b141b995d078ef2ef7cb40 e7f1f07d650f42a98b1670b68a8087d6--04f7cca431b141b995d078ef2ef7cb40 4ef0f0efea9046f8afbb0fc8d822c694 04f7cca431b141b995d078ef2ef7cb40--4ef0f0efea9046f8afbb0fc8d822c694 36d6825cc582406baf9a1fcda7ac910c 4ef0f0efea9046f8afbb0fc8d822c694--36d6825cc582406baf9a1fcda7ac910c a7097dbf97c841d397417c20a64c8dbe 36d6825cc582406baf9a1fcda7ac910c--a7097dbf97c841d397417c20a64c8dbe 96cfd7a73afd40ad85548e1daffffe0e a7097dbf97c841d397417c20a64c8dbe--96cfd7a73afd40ad85548e1daffffe0e 007449b14ba54c01b83f8317e346f7c0 96cfd7a73afd40ad85548e1daffffe0e--007449b14ba54c01b83f8317e346f7c0 8451e1b995934bcaa7e934bfd0fa05f5 007449b14ba54c01b83f8317e346f7c0--8451e1b995934bcaa7e934bfd0fa05f5 a948880c5db242aab98059f924cfe4fc 8451e1b995934bcaa7e934bfd0fa05f5--a948880c5db242aab98059f924cfe4fc eed82d6f175d437f8f8cc7e1524f6389 a948880c5db242aab98059f924cfe4fc--eed82d6f175d437f8f8cc7e1524f6389 88c38172ce9343f5ba7d95e9bddf9806 eed82d6f175d437f8f8cc7e1524f6389--88c38172ce9343f5ba7d95e9bddf9806 4fc346e4966340619229557adf781de1 88c38172ce9343f5ba7d95e9bddf9806--4fc346e4966340619229557adf781de1 0ce8a7d07c644541ba426896abc71e8a 4fc346e4966340619229557adf781de1--0ce8a7d07c644541ba426896abc71e8a 7e935bcde02f4bafaa40a18a240d6fdb 0ce8a7d07c644541ba426896abc71e8a--7e935bcde02f4bafaa40a18a240d6fdb dfb202028db440e28e3d93152338684d 7e935bcde02f4bafaa40a18a240d6fdb--dfb202028db440e28e3d93152338684d 97834b17425a4fe88793602303f6a762 dfb202028db440e28e3d93152338684d--97834b17425a4fe88793602303f6a762 5ac02c7f24e142c988dc80a1cf531bb6 97834b17425a4fe88793602303f6a762--5ac02c7f24e142c988dc80a1cf531bb6 6572df426c2246f0ab478bd39c80ead1 5ac02c7f24e142c988dc80a1cf531bb6--6572df426c2246f0ab478bd39c80ead1 3f14359a52b248b78af176b2a4c47110 6572df426c2246f0ab478bd39c80ead1--3f14359a52b248b78af176b2a4c47110 1b33367af1e245b68c3ebcee92a1f5b5 3f14359a52b248b78af176b2a4c47110--1b33367af1e245b68c3ebcee92a1f5b5 a95fab51fedb4ce391ce95d4ca8ea660 1b33367af1e245b68c3ebcee92a1f5b5--a95fab51fedb4ce391ce95d4ca8ea660 0a40768c257b4810a111d450c604da9a a95fab51fedb4ce391ce95d4ca8ea660--0a40768c257b4810a111d450c604da9a c71f020d120648ceadb925c67dd3d5d3 0a40768c257b4810a111d450c604da9a--c71f020d120648ceadb925c67dd3d5d3 cf87df6f8bf94a9f911a113b30293303 c71f020d120648ceadb925c67dd3d5d3--cf87df6f8bf94a9f911a113b30293303 daaf3709ea99469c80dd952f797cfffb cf87df6f8bf94a9f911a113b30293303--daaf3709ea99469c80dd952f797cfffb 6920565b0d0d4105a173d877bc284ce5 daaf3709ea99469c80dd952f797cfffb--6920565b0d0d4105a173d877bc284ce5 ade7f2465c05435e90df0c957f74c5ab 6920565b0d0d4105a173d877bc284ce5--ade7f2465c05435e90df0c957f74c5ab 04dc89793759480ca19e97bd03e38c8a ade7f2465c05435e90df0c957f74c5ab--04dc89793759480ca19e97bd03e38c8a b10993b811ed4fd09094b5af6f9bc14b X 04dc89793759480ca19e97bd03e38c8a--b10993b811ed4fd09094b5af6f9bc14b b10993b811ed4fd09094b5af6f9bc14b--7dd51416339149cd9273250e9a141dec dd9032c9c4bc48b2a5631074839d8f5c RZ(-1.0*g1) b10993b811ed4fd09094b5af6f9bc14b--dd9032c9c4bc48b2a5631074839d8f5c cc17f51ec7d84027bff4c8721026c7e2 X dd9032c9c4bc48b2a5631074839d8f5c--cc17f51ec7d84027bff4c8721026c7e2 cc17f51ec7d84027bff4c8721026c7e2--a772fe5854bb4bd795ac4ded861dccc0 c5edf3f3e3764c96a2791eb7be870e57 cc17f51ec7d84027bff4c8721026c7e2--c5edf3f3e3764c96a2791eb7be870e57 01d5c2a31b59448591edfcb6c9112104 c5edf3f3e3764c96a2791eb7be870e57--01d5c2a31b59448591edfcb6c9112104 2aef529d38ab4c329f22e6935b4adb1e 01d5c2a31b59448591edfcb6c9112104--2aef529d38ab4c329f22e6935b4adb1e ea4f31a573da4a2ba4bdd19068a5f11f 2aef529d38ab4c329f22e6935b4adb1e--ea4f31a573da4a2ba4bdd19068a5f11f 20b8dc86fb2a4827960ed20e13c9e140 ea4f31a573da4a2ba4bdd19068a5f11f--20b8dc86fb2a4827960ed20e13c9e140 18c86e13f43e4371ab2e21e1cfe5631e 20b8dc86fb2a4827960ed20e13c9e140--18c86e13f43e4371ab2e21e1cfe5631e cc0fa23e5cfb404898f75fa480d5e4be 18c86e13f43e4371ab2e21e1cfe5631e--cc0fa23e5cfb404898f75fa480d5e4be a19d40cd0ef64a18b525d65727382ea4 cc0fa23e5cfb404898f75fa480d5e4be--a19d40cd0ef64a18b525d65727382ea4 c43773cf1b7f498eb1b3c552a1b0e3be a19d40cd0ef64a18b525d65727382ea4--c43773cf1b7f498eb1b3c552a1b0e3be 537930d3f02d488a8b820c38fd122b67 c43773cf1b7f498eb1b3c552a1b0e3be--537930d3f02d488a8b820c38fd122b67 b401c418e27a4ba18eb7f631f12984db 537930d3f02d488a8b820c38fd122b67--b401c418e27a4ba18eb7f631f12984db 6c0092b180b940a9985cb777f0770a5e b401c418e27a4ba18eb7f631f12984db--6c0092b180b940a9985cb777f0770a5e b81ca0231d224d6d9e251bab145339fd 6c0092b180b940a9985cb777f0770a5e--b81ca0231d224d6d9e251bab145339fd d906b66ca6184bfd9f64151bfcca88a3 b81ca0231d224d6d9e251bab145339fd--d906b66ca6184bfd9f64151bfcca88a3 47ce176adcb7465fabf4d96d57ed9c43 d906b66ca6184bfd9f64151bfcca88a3--47ce176adcb7465fabf4d96d57ed9c43 571c17bd7fbe412182562ebbaf8fdd0d 47ce176adcb7465fabf4d96d57ed9c43--571c17bd7fbe412182562ebbaf8fdd0d 8614f890b69f4f9eb9cc703d04da8ac9 571c17bd7fbe412182562ebbaf8fdd0d--8614f890b69f4f9eb9cc703d04da8ac9 293ee828ebe44a3fa035c02c21909820 8614f890b69f4f9eb9cc703d04da8ac9--293ee828ebe44a3fa035c02c21909820 7abee88ca87c4233976640d317d8964f 293ee828ebe44a3fa035c02c21909820--7abee88ca87c4233976640d317d8964f 527cf1c10a8946c29fc891fd34f09605 7abee88ca87c4233976640d317d8964f--527cf1c10a8946c29fc891fd34f09605 6edce1f913c943bc8f2c715ffa5b91eb 527cf1c10a8946c29fc891fd34f09605--6edce1f913c943bc8f2c715ffa5b91eb 0293402ba19c4d49881b9ebdc98bd975 X 6edce1f913c943bc8f2c715ffa5b91eb--0293402ba19c4d49881b9ebdc98bd975 0293402ba19c4d49881b9ebdc98bd975--b8fd9948a4d6480aabc832808e944cc6 ba899a4523a4480ab4ddff0e5aeaab0c RZ(-1.0*g1) 0293402ba19c4d49881b9ebdc98bd975--ba899a4523a4480ab4ddff0e5aeaab0c 8adb0789aa474299a6b38e51d316db92 X ba899a4523a4480ab4ddff0e5aeaab0c--8adb0789aa474299a6b38e51d316db92 8adb0789aa474299a6b38e51d316db92--e2caa204f049454f89efadd44f2612a7 b745c9d62d3347a88bb438d6d83713d8 8adb0789aa474299a6b38e51d316db92--b745c9d62d3347a88bb438d6d83713d8 5ea624575c5543f198968894efd56c6f b745c9d62d3347a88bb438d6d83713d8--5ea624575c5543f198968894efd56c6f 334381f29aa445218cf3bbbbac3d96d2 5ea624575c5543f198968894efd56c6f--334381f29aa445218cf3bbbbac3d96d2 5402430ec8084290a3b746119f1a3fd2 334381f29aa445218cf3bbbbac3d96d2--5402430ec8084290a3b746119f1a3fd2 3e1f6992ecbd4f9a93c509f5a12dece3 5402430ec8084290a3b746119f1a3fd2--3e1f6992ecbd4f9a93c509f5a12dece3 aacf6c543e414ff0a2e8e482353b0fe6 3e1f6992ecbd4f9a93c509f5a12dece3--aacf6c543e414ff0a2e8e482353b0fe6 7aaf0d05342642dfaedeb0f1dde7ca74 aacf6c543e414ff0a2e8e482353b0fe6--7aaf0d05342642dfaedeb0f1dde7ca74 7639412e867d4e8c81a02164a42c1e71 7aaf0d05342642dfaedeb0f1dde7ca74--7639412e867d4e8c81a02164a42c1e71 eef6994a1bf341dd91a6d54012ccb454 7639412e867d4e8c81a02164a42c1e71--eef6994a1bf341dd91a6d54012ccb454 f4aa022a6a2244e5bc67efb130757f4b eef6994a1bf341dd91a6d54012ccb454--f4aa022a6a2244e5bc67efb130757f4b 1c6d446306174e9ba3a70907cb003173 f4aa022a6a2244e5bc67efb130757f4b--1c6d446306174e9ba3a70907cb003173 81ab053e24c54f42a9fd74ad518c2ee4 1c6d446306174e9ba3a70907cb003173--81ab053e24c54f42a9fd74ad518c2ee4 5ada92d3c0584969865f41db83936ea7 81ab053e24c54f42a9fd74ad518c2ee4--5ada92d3c0584969865f41db83936ea7 d969df98c57f497391ff5a814161b59c 5ada92d3c0584969865f41db83936ea7--d969df98c57f497391ff5a814161b59c 443b378862ce4cf1b831b7a4c4258143 d969df98c57f497391ff5a814161b59c--443b378862ce4cf1b831b7a4c4258143 1c3c58636ced438899137066d6c516dd 443b378862ce4cf1b831b7a4c4258143--1c3c58636ced438899137066d6c516dd 95a68d8d022e49dd94f82f815d072ad7 1c3c58636ced438899137066d6c516dd--95a68d8d022e49dd94f82f815d072ad7 fa87e6ccc6724fb6b11c7bd8dfc6ca8c 95a68d8d022e49dd94f82f815d072ad7--fa87e6ccc6724fb6b11c7bd8dfc6ca8c 731e410702014f85b42e45e7e543ad9e fa87e6ccc6724fb6b11c7bd8dfc6ca8c--731e410702014f85b42e45e7e543ad9e 1b1bb62055b246a7b4505c406f379e9b 731e410702014f85b42e45e7e543ad9e--1b1bb62055b246a7b4505c406f379e9b 9927533307ba43d68eb2bb804cf0b2c2 1b1bb62055b246a7b4505c406f379e9b--9927533307ba43d68eb2bb804cf0b2c2 dc4a5e2d5c864186abc9c1d85e55434f 9927533307ba43d68eb2bb804cf0b2c2--dc4a5e2d5c864186abc9c1d85e55434f aaa40f71542847e0bf861f6919de744c RX(b17) dc4a5e2d5c864186abc9c1d85e55434f--aaa40f71542847e0bf861f6919de744c aaa40f71542847e0bf861f6919de744c--155081c6326c44b488199ddc8602c0ff"},{"location":"qml/qaoa/#train-the-qaoa-circuit-to-solve-maxcut","title":"Train the QAOA circuit to solve MaxCut","text":"<p>Given the QAOA circuit above, one can construct the associated Qadence <code>QuantumModel</code> and train it using standard gradient based optimization.</p> <p>The loss function to be minimized reads:</p> \\[\\mathcal{L} = \\sum_{i,j}^{N_{\\mathcal{E}}} \\frac{1}{2} \\left(1 - \\langle \\psi | \\sigma_i^z \\sigma_j^z | \\psi \\rangle \\right)\\] <p>where \\(\\psi(\\beta, \\gamma)\\) is the wavefunction obtained by propagating the QAQA quantum circuit and the sum runs over the edges of the graph \\(N_{\\mathcal{E}}\\).</p> <pre><code>import torch\nfrom qadence import QuantumModel\n\ntorch.manual_seed(seed)\n\n\ndef loss_function(_model: QuantumModel):\n\n    expval_ops = _model.expectation().squeeze()\n\n    # this corresponds to the MaxCut cost by definition\n    # with negative sign in front to perform maximization\n    expval = 0.0\n    for val in expval_ops:\n        expval += 0.5 * (1 - val)\n\n    return -1.0 * expval\n\n# initialize the parameters to random values\nmodel = QuantumModel(circuit, observable=zz_ops)\nmodel.reset_vparams(torch.rand(model.num_vparams))\ninitial_loss = loss_function(model)\nprint(f\"Initial loss: {initial_loss}\")\n\n# train the model\nn_epochs = 100\nlr = 1.0\n\noptimizer = torch.optim.Adagrad(model.parameters(), lr=lr)\n\nfor i in range(n_epochs):\n    optimizer.zero_grad()\n    loss = loss_function(model)\n    loss.backward()\n    optimizer.step()\n    if (i+1) % (n_epochs // 10) == 0:\n        print(f\"MaxCut cost at iteration {i+1}: {-loss.item()}\")\n</code></pre> <pre><code>Initial loss: -3.9769044107664167\nMaxCut cost at iteration 10: 9.61645817469737\nMaxCut cost at iteration 20: 10.824030182225492\nMaxCut cost at iteration 30: 10.967494362110305\nMaxCut cost at iteration 40: 10.999997568784083\nMaxCut cost at iteration 50: 10.999999299683344\nMaxCut cost at iteration 60: 10.99999935120806\nMaxCut cost at iteration 70: 10.999999396246412\nMaxCut cost at iteration 80: 10.999999437197955\nMaxCut cost at iteration 90: 10.999999474754983\nMaxCut cost at iteration 100: 10.999999509414243\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p>"},{"location":"qml/qaoa/#results","title":"Results","text":"<p>Given the trained quantum model, one needs to sample the resulting quantum state to recover the bitstring with the highest probability which corresponds to the maximum cut of the graph.</p> <pre><code>samples = model.sample(n_shots=100)[0]\nmost_frequent = max(samples, key=samples.get)\n\nprint(f\"Most frequently sampled bitstring corresponding to the maximum cut: {most_frequent}\")\n\n# let's now draw the cut obtained with the QAOA procedure\ncolors = []\nlabels = {}\nfor node, b in zip(graph.nodes(), most_frequent):\n    colors.append(\"green\") if int(b) == 0 else colors.append(\"red\")\n    labels[node] = \"A\" if int(b) == 0 else \"B\"\n\nnx.draw_networkx(graph, node_color=colors, with_labels=True, labels=labels)\n</code></pre>   Most frequently sampled bitstring corresponding to the maximum cut: 00110011  2024-02-15T16:12:08.763744 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qaoa/#references","title":"References","text":"<ol> <li> <p>Farhi et al. - A Quantum Approximate Optimization Algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"qml/qcl/","title":"Quantum circuit learning","text":"<p>This tutorial shows how to apply <code>qadence</code> for solving a basic quantum machine learning application: fitting a simple function with the quantum circuit learning<sup>1</sup> (QCL) algorithm.</p> <p>QCL is a supervised quantum machine learning algorithm that uses a parametrized quantum neural network to learn the behavior of an arbitrary mathematical function using a set of function values as training data. This tutorial shows how to fit the \\(\\sin(x)\\) function in the \\([-1, 1]\\) domain.</p> <p>In the following, train and test data are defined.</p> <pre><code>import torch\nfrom torch.utils.data import random_split\n\n# make sure all tensors are kept on the same device\n# only available from PyTorch 2.0\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\ntorch.set_default_device(device)\n\ndef qcl_training_data(\n    domain: tuple = (0, 2*torch.pi), n_points: int = 200\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n\n    start, end = domain\n\n    x_rand, _ = torch.sort(torch.DoubleTensor(n_points).uniform_(start, end))\n    y_rand = torch.sin(x_rand)\n\n    return x_rand, y_rand\n\nx, y = qcl_training_data()\n\n# random train/test split of the dataset\ntrain_subset, test_subset = random_split(x, [0.75, 0.25])\ntrain_ind = sorted(train_subset.indices)\ntest_ind = sorted(test_subset.indices)\n\nx_train, y_train = x[train_ind], y[train_ind]\nx_test, y_test = x[test_ind], y[test_ind]\n</code></pre>"},{"location":"qml/qcl/#train-the-qcl-model","title":"Train the QCL model","text":"<p>Qadence provides the <code>QNN</code> convenience constructor to build a quantum neural network. The <code>QNN</code> class needs a circuit and a list of observables; the number of feature parameters in the input circuit determines the number of input features (i.e. the dimensionality of the classical data given as input) whereas the number of observables determines the number of outputs of the quantum neural network.</p> <p>Total qubit magnetization is used as observable:</p> \\[ \\hat{O} = \\sum_i^N \\hat{\\sigma}_i^z \\] <p>In the following the observable, quantum circuit and corresponding QNN model are constructed.</p> <pre><code>import qadence as qd\n\nn_qubits = 4\n\n# create a simple feature map to encode the input data\nfeature_param = qd.FeatureParameter(\"phi\")\nfeature_map = qd.kron(qd.RX(i, feature_param) for i in range(n_qubits))\nfeature_map = qd.tag(feature_map, \"feature_map\")\n\n# create a digital-analog variational ansatz using Qadence convenience constructors\nansatz = qd.hea(n_qubits, depth=n_qubits)\nansatz = qd.tag(ansatz, \"ansatz\")\n\n# total qubit magnetization observable\nobservable = qd.hamiltonian_factory(n_qubits, detuning=qd.Z)\n\ncircuit = qd.QuantumCircuit(n_qubits, feature_map, ansatz)\nmodel = qd.QNN(circuit, [observable])\nexpval = model(values=torch.rand(10))\n</code></pre> <pre><code>tensor([[0.2025],\n        [0.1315],\n        [0.2424],\n        [0.1552],\n        [0.1592],\n        [0.2063],\n        [0.1899],\n        [0.2208],\n        [0.2472],\n        [0.1580]], grad_fn=&lt;CatBackward0&gt;)\n</code></pre> <p>The QCL algorithm uses the output of the quantum neural network as a tunable universal function approximator. Standard PyTorch code is used for training the QNN using a mean-square error loss, Adam optimizer. Training is performend on the GPU if available:</p> <pre><code>n_epochs = 100\nlr = 0.25\n\ninput_values = {\"phi\": x_train}\nmse_loss = torch.nn.MSELoss()  # standard PyTorch loss function\noptimizer = torch.optim.Adam(model.parameters(), lr=lr)  # standard PyTorch Adam optimizer\n\nprint(f\"Initial loss: {mse_loss(model(values=x_train), y_train)}\")\ny_pred_initial = model(values=x_test)\n\nfor i in range(n_epochs):\n\n    optimizer.zero_grad()\n\n    # given a `n_batch` number of input points and a `n_observables`\n    # number of input observables to measure, the QNN returns\n    # an output of the following shape: [n_batch x n_observables]\n    # given that there is only one observable, a squeeze is applied to get\n    # a 1-dimensional tensor\n    loss = mse_loss(model(values=x_train).squeeze(), y_train)\n    loss.backward()\n    optimizer.step()\n\n    if (i+1) % 20 == 0:\n        print(f\"Epoch {i+1} - Loss: {loss.item()}\")\n\nassert loss.item() &lt; 1e-3\n</code></pre> <pre><code>Initial loss: 0.6533070454755132\nEpoch 20 - Loss: 0.00675673293288311\nEpoch 40 - Loss: 0.0013178262682414614\nEpoch 60 - Loss: 0.00024411275385790839\nEpoch 80 - Loss: 1.8109270091471018e-05\nEpoch 100 - Loss: 3.344354751243779e-06\n</code></pre> <p>Qadence offers some convenience functions to implement this training loop with advanced logging and metrics track features. You can refer to this tutorial for more details.</p> <p>The quantum model is now trained on the training data points. To determine the quality of the results, one can check to see how well it fits the function on the test set.</p> <pre><code>import matplotlib.pyplot as plt\n\ny_pred = model({\"phi\": x_test})\n\n# convert all the results to numpy arrays for plotting\nx_train_np = x_train.cpu().detach().numpy().flatten()\ny_train_np = y_train.cpu().detach().numpy().flatten()\nx_test_np = x_test.cpu().detach().numpy().flatten()\ny_test_np = y_test.cpu().detach().numpy().flatten()\ny_pred_initial_np = y_pred_initial.cpu().detach().numpy().flatten()\ny_pred_np = y_pred.cpu().detach().numpy().flatten()\n\nfig, _ = plt.subplots()\nplt.scatter(x_test_np, y_test_np, label=\"Test points\", marker=\"o\", color=\"orange\")\nplt.plot(x_test_np, y_pred_initial_np, label=\"Initial prediction\", color=\"green\", alpha=0.5)\nplt.plot(x_test_np, y_pred_np, label=\"Final prediction\")\nplt.legend()\n</code></pre> 2024-02-15T16:12:13.096118 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"qml/qcl/#references","title":"References","text":"<ol> <li> <p>Mitarai et al., Quantum Circuit Learning \u21a9</p> </li> </ol>"},{"location":"qml/qml_constructors/","title":"Quantum machine learning constructors","text":"<p>Besides the arbitrary Hamiltonian constructors, Qadence also provides a complete set of program constructors useful for digital-analog quantum machine learning programs.</p>"},{"location":"qml/qml_constructors/#feature-maps","title":"Feature maps","text":"<p>The <code>feature_map</code> function can easily create several types of data-encoding blocks. The two main types of feature maps use a Fourier basis or a Chebyshev basis.</p> <pre><code>from qadence import feature_map, BasisSet, chain\nfrom qadence.draw import display\n\nn_qubits = 3\n\nfourier_fm = feature_map(n_qubits, fm_type=BasisSet.FOURIER)\n\nchebyshev_fm = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV)\n\nblock = chain(fourier_fm, chebyshev_fm)\n</code></pre> %3 cluster_6a134cb710ee487ba279524251bf7602 Constant Chebyshev FM cluster_a028901617f74e8590f999f0f8e96f8a Constant Fourier FM 1c8e455ae9a54a6b84a0e5d550f18787 0 2633034f0e1541009ac491fe1717b0e8 RX(phi) 1c8e455ae9a54a6b84a0e5d550f18787--2633034f0e1541009ac491fe1717b0e8 63574fade2ec42b884159487536f7ab5 1 33c16cb95b3e4d5680622d2c40ee3581 RX(acos(phi)) 2633034f0e1541009ac491fe1717b0e8--33c16cb95b3e4d5680622d2c40ee3581 cecbed3b57074c3e8b0ae5fb2b0da814 33c16cb95b3e4d5680622d2c40ee3581--cecbed3b57074c3e8b0ae5fb2b0da814 7905c0d74bcf47f2b3230aebced1e82b 8060565625b842f19536c760b3259380 RX(phi) 63574fade2ec42b884159487536f7ab5--8060565625b842f19536c760b3259380 0f996d40d4c643f0bffa9efd824fa5a4 2 c0c87fdcd5a2473391c9777f659e0f34 RX(acos(phi)) 8060565625b842f19536c760b3259380--c0c87fdcd5a2473391c9777f659e0f34 c0c87fdcd5a2473391c9777f659e0f34--7905c0d74bcf47f2b3230aebced1e82b b520af244d904dc7bd6cce6325b6e3b4 8751ff96a69945c7b78f3e9039ba6adb RX(phi) 0f996d40d4c643f0bffa9efd824fa5a4--8751ff96a69945c7b78f3e9039ba6adb c62aa0de01574518a98c3849bf68c0a1 RX(acos(phi)) 8751ff96a69945c7b78f3e9039ba6adb--c62aa0de01574518a98c3849bf68c0a1 c62aa0de01574518a98c3849bf68c0a1--b520af244d904dc7bd6cce6325b6e3b4 <p>A custom encoding function can also be passed with <code>sympy</code></p> <pre><code>from sympy import asin, Function\n\nn_qubits = 3\n\n# Using a pre-defined sympy Function\ncustom_fm_0 = feature_map(n_qubits, fm_type=asin)\n\n# Creating a custom function\ndef custom_fn(x):\n    return asin(x) + x**2\n\ncustom_fm_1 = feature_map(n_qubits, fm_type=custom_fn)\n\nblock = chain(custom_fm_0, custom_fm_1)\n</code></pre> %3 cluster_63c008f4f4dc4b6baa350697dccb08da Constant &lt;function custom_fn at 0x7ff68cf2d2d0&gt; FM cluster_a44cd658e4ab49889e244df04ea87bf3 Constant asin FM 0f35e0dad2bd49ba91d0df52662d12f6 0 611686d5611c4c8daff6d61725dde9a8 RX(asin(phi)) 0f35e0dad2bd49ba91d0df52662d12f6--611686d5611c4c8daff6d61725dde9a8 beaeb5efc9a14a93bcb67b63cc75efd6 1 340a954443ee49ee9a2eddd95da7926e RX(phi**2 + asin(phi)) 611686d5611c4c8daff6d61725dde9a8--340a954443ee49ee9a2eddd95da7926e 9ab97f5afaa649aa8d9174d65a98e6d7 340a954443ee49ee9a2eddd95da7926e--9ab97f5afaa649aa8d9174d65a98e6d7 52faab2c4a5144fc9ebc2c21dc46e814 5214b82139f8453f9a3dcf71946804ab RX(asin(phi)) beaeb5efc9a14a93bcb67b63cc75efd6--5214b82139f8453f9a3dcf71946804ab 5378f7ecebd542b09bc41497f20e98d9 2 095db3a02007470f8ca4f43f0ed6bebe RX(phi**2 + asin(phi)) 5214b82139f8453f9a3dcf71946804ab--095db3a02007470f8ca4f43f0ed6bebe 095db3a02007470f8ca4f43f0ed6bebe--52faab2c4a5144fc9ebc2c21dc46e814 744d918e7c844326be53e1ed8fc6dcb9 b9914b4e632b466eb747f6dc80127999 RX(asin(phi)) 5378f7ecebd542b09bc41497f20e98d9--b9914b4e632b466eb747f6dc80127999 1ea93b9a91c14f0bb3d5a9cf68b0a876 RX(phi**2 + asin(phi)) b9914b4e632b466eb747f6dc80127999--1ea93b9a91c14f0bb3d5a9cf68b0a876 1ea93b9a91c14f0bb3d5a9cf68b0a876--744d918e7c844326be53e1ed8fc6dcb9 <p>Furthermore, the <code>reupload_scaling</code> argument can be used to change the scaling applied to each qubit in the support of the feature map. The default scalings can be chosen from the <code>ReuploadScaling</code> enumeration.</p> <pre><code>from qadence import ReuploadScaling\nfrom qadence.draw import display\n\nn_qubits = 5\n\n# Default constant value\nfm_constant = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.CONSTANT)\n\n# Linearly increasing scaling\nfm_tower = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.TOWER)\n\n# Exponentially increasing scaling\nfm_exp = feature_map(n_qubits, fm_type=BasisSet.FOURIER, reupload_scaling=ReuploadScaling.EXP)\n\nblock = chain(fm_constant, fm_tower, fm_exp)\n</code></pre> %3 cluster_3f02496ed5b44761adf27e923ee694bf Exponential Fourier FM cluster_f50b035e8a4b43f19f910a8fb9626f8d Constant Fourier FM cluster_085c0bb164f84b568dc5dc66b5ca2be5 Tower Fourier FM dc8ff6cf5c284ada952cefaa54ab5a23 0 6a0bfce5a99e4f83beab12aab8a40b44 RX(phi) dc8ff6cf5c284ada952cefaa54ab5a23--6a0bfce5a99e4f83beab12aab8a40b44 96a6f769c1d84699b03bcab799d7303f 1 c138042f956f49f899bd7ec3623f95a0 RX(1.0*phi) 6a0bfce5a99e4f83beab12aab8a40b44--c138042f956f49f899bd7ec3623f95a0 d332c96ba9144ab191b4309fb0cc34bf RX(1.0*phi) c138042f956f49f899bd7ec3623f95a0--d332c96ba9144ab191b4309fb0cc34bf 401eccac92034794ae17f5fc2c4b81e9 d332c96ba9144ab191b4309fb0cc34bf--401eccac92034794ae17f5fc2c4b81e9 929f40ec38f84b4986948370b20c7c13 3af2a028b6954f40b34cb833e32c9fe4 RX(phi) 96a6f769c1d84699b03bcab799d7303f--3af2a028b6954f40b34cb833e32c9fe4 dcb371c6f74b4278b53ae6440679d710 2 f940cab0d12840b5919a900e87057e0b RX(2.0*phi) 3af2a028b6954f40b34cb833e32c9fe4--f940cab0d12840b5919a900e87057e0b 1f976737a5984533bd1153ab22d267cb RX(2.0*phi) f940cab0d12840b5919a900e87057e0b--1f976737a5984533bd1153ab22d267cb 1f976737a5984533bd1153ab22d267cb--929f40ec38f84b4986948370b20c7c13 c220b70b918f43d48a30ad1c6e374ddf a3ff01ad0ce44891a98de3807a485bc8 RX(phi) dcb371c6f74b4278b53ae6440679d710--a3ff01ad0ce44891a98de3807a485bc8 acb46e2396c7402aac1e8e81860b93f2 3 348b0fabbed54ecb98abd26b2396bc9e RX(3.0*phi) a3ff01ad0ce44891a98de3807a485bc8--348b0fabbed54ecb98abd26b2396bc9e 34d08175743247da829eb9e24983bc80 RX(4.0*phi) 348b0fabbed54ecb98abd26b2396bc9e--34d08175743247da829eb9e24983bc80 34d08175743247da829eb9e24983bc80--c220b70b918f43d48a30ad1c6e374ddf 3616e8a1d812447d93d7e7236d1515d7 4083ef74555444d4b4b8bf2eae12e0ac RX(phi) acb46e2396c7402aac1e8e81860b93f2--4083ef74555444d4b4b8bf2eae12e0ac 53d5f91e2c034a4bb8b0d860d84f168a 4 fb94164474a440ab953a197dbf4b87f8 RX(4.0*phi) 4083ef74555444d4b4b8bf2eae12e0ac--fb94164474a440ab953a197dbf4b87f8 d8d84672530843c9bd37dae4f541e589 RX(8.0*phi) fb94164474a440ab953a197dbf4b87f8--d8d84672530843c9bd37dae4f541e589 d8d84672530843c9bd37dae4f541e589--3616e8a1d812447d93d7e7236d1515d7 8aafb686ff5b46e98a0944d5f351ebf0 1bfd5fb3f11a4f7d83a62c33b3ce088b RX(phi) 53d5f91e2c034a4bb8b0d860d84f168a--1bfd5fb3f11a4f7d83a62c33b3ce088b 7867c05a8e624ba6b6f2389f50144fe3 RX(5.0*phi) 1bfd5fb3f11a4f7d83a62c33b3ce088b--7867c05a8e624ba6b6f2389f50144fe3 6bfea22467524a47945942cd7dfc3a4b RX(16.0*phi) 7867c05a8e624ba6b6f2389f50144fe3--6bfea22467524a47945942cd7dfc3a4b 6bfea22467524a47945942cd7dfc3a4b--8aafb686ff5b46e98a0944d5f351ebf0 <p>A custom scaling can also be defined with a function with an <code>int</code> input and <code>int</code> or <code>float</code> output.</p> <pre><code>n_qubits = 5\n\ndef custom_scaling(i: int) -&gt; int | float:\n    \"\"\"Sqrt(i+1)\"\"\"\n    return (i+1) ** (0.5)\n\n# Custom scaling function\nfm_custom = feature_map(n_qubits, fm_type=BasisSet.CHEBYSHEV, reupload_scaling=custom_scaling)\n</code></pre> %3 b3b7347dbaaa4260824649d607d276c7 0 3cb3d5858dc9425ebed67d80df7e3529 RX(1.0*acos(phi)) b3b7347dbaaa4260824649d607d276c7--3cb3d5858dc9425ebed67d80df7e3529 653fcb6a588742dbb98499d0eb9ebe77 1 170a2189168d4402b8f032877e4417f9 3cb3d5858dc9425ebed67d80df7e3529--170a2189168d4402b8f032877e4417f9 abcf17598e45422495b5e768a9c3d8e2 7926aafff72f44c8840c1c825a9ea512 RX(1.414*acos(phi)) 653fcb6a588742dbb98499d0eb9ebe77--7926aafff72f44c8840c1c825a9ea512 4be3b283734243b48b36593e9004c44c 2 7926aafff72f44c8840c1c825a9ea512--abcf17598e45422495b5e768a9c3d8e2 0c53550031ce48979f736475d01fd68e decf6f923b834957b890bb680b06700c RX(1.732*acos(phi)) 4be3b283734243b48b36593e9004c44c--decf6f923b834957b890bb680b06700c c561b344d09a4b84b1f2ab1bdaaa2454 3 decf6f923b834957b890bb680b06700c--0c53550031ce48979f736475d01fd68e 00d4963d82d747e98f18882ed15fbeaf d9402ee605944cc5ab36160febda8695 RX(2.0*acos(phi)) c561b344d09a4b84b1f2ab1bdaaa2454--d9402ee605944cc5ab36160febda8695 40072a6b66984c3fa6c7978913f0bfa6 4 d9402ee605944cc5ab36160febda8695--00d4963d82d747e98f18882ed15fbeaf 349f488d88fd4f81a4c0534a420dbf76 d198d999cb904519ad78ba4338254661 RX(2.236*acos(phi)) 40072a6b66984c3fa6c7978913f0bfa6--d198d999cb904519ad78ba4338254661 d198d999cb904519ad78ba4338254661--349f488d88fd4f81a4c0534a420dbf76 <p>To add a trainable parameter that multiplies the feature parameter inside the encoding function, simply pass a <code>param_prefix</code> string:</p> <pre><code>n_qubits = 5\n\nfm_trainable = feature_map(\n    n_qubits,\n    fm_type=BasisSet.FOURIER,\n    reupload_scaling=ReuploadScaling.EXP,\n    param_prefix = \"w\",\n)\n</code></pre> %3 16d11b3f9ba44710b30a3b92d9499b1d 0 5716117c0a5d4ad8838224a532f32343 RX(1.0*phi*w\u2080) 16d11b3f9ba44710b30a3b92d9499b1d--5716117c0a5d4ad8838224a532f32343 c08f966c5ef1475f9d8eb8f4de827ed8 1 e37bf366758a4e4783edc61c4e29aed1 5716117c0a5d4ad8838224a532f32343--e37bf366758a4e4783edc61c4e29aed1 4c4301d4549840f284aaad97e719acb0 567406ef686f49538d5c95e0b0e212cb RX(2.0*phi*w\u2081) c08f966c5ef1475f9d8eb8f4de827ed8--567406ef686f49538d5c95e0b0e212cb dfdfadd8ce29436aa7b809cb830899be 2 567406ef686f49538d5c95e0b0e212cb--4c4301d4549840f284aaad97e719acb0 0ef6b7c093b84d7e88b5328f4de6d0de cd65f944bbad441ead363f5284a4b411 RX(4.0*phi*w\u2082) dfdfadd8ce29436aa7b809cb830899be--cd65f944bbad441ead363f5284a4b411 875c075e43b6495faa6f809485b263ab 3 cd65f944bbad441ead363f5284a4b411--0ef6b7c093b84d7e88b5328f4de6d0de cdc48b359bd149788cc8beb14bd54f46 6a69e2e26ebd4fa284296a9cef7f575f RX(8.0*phi*w\u2083) 875c075e43b6495faa6f809485b263ab--6a69e2e26ebd4fa284296a9cef7f575f 26940fe1764a44c3b7e95e03f352a7d5 4 6a69e2e26ebd4fa284296a9cef7f575f--cdc48b359bd149788cc8beb14bd54f46 987ad2c242424e94b57e03eeafd87d4e 4c51f45ca3a548a996d98325e2ab93b0 RX(16.0*phi*w\u2084) 26940fe1764a44c3b7e95e03f352a7d5--4c51f45ca3a548a996d98325e2ab93b0 4c51f45ca3a548a996d98325e2ab93b0--987ad2c242424e94b57e03eeafd87d4e <p>Note that for the Fourier feature map, the encoding function is simply \\(f(x)=x\\). For other cases, like the Chebyshev <code>acos()</code> encoding, the trainable parameter may cause the feature value to be outside the domain of the encoding function. This will eventually be fixed by adding range constraints to trainable parameters in Qadence.</p> <p>A full description of the remaining arguments can be found in the <code>feature_map</code> API reference. We provide an example below.</p> <pre><code>from qadence import RY\n\nn_qubits = 5\n\n# Custom scaling function\nfm_full = feature_map(\n    n_qubits = n_qubits,\n    support = tuple(reversed(range(n_qubits))), # Reverse the qubit support to run the scaling from bottom to top\n    param = \"x\", # Change the name of the parameter\n    op = RY, # Change the rotation gate between RX, RY, RZ or PHASE\n    fm_type = BasisSet.CHEBYSHEV,\n    reupload_scaling = ReuploadScaling.EXP,\n    feature_range = (-1.0, 2.0), # Range from which the input data comes from\n    target_range = (1.0, 3.0), # Range the encoder assumes as the natural range\n    multiplier = 5.0, # Extra multiplier, which can also be a Parameter\n    param_prefix = \"w\", # Add trainable parameters\n)\n</code></pre> %3 1b579d8758934d5daffa78cbc8ce0269 0 5e5e9b3e7a064353aa83c1e5568e95d8 RY(80.0*acos(w\u2084*(0.667*x + 1.667))) 1b579d8758934d5daffa78cbc8ce0269--5e5e9b3e7a064353aa83c1e5568e95d8 f3ddf797190c4496b51695e0f0cd42bf 1 c48c2f7d3aeb410d9b601d01280c9e89 5e5e9b3e7a064353aa83c1e5568e95d8--c48c2f7d3aeb410d9b601d01280c9e89 fc4af4822ed641f381346a2a40203f9a 77191e0811d742ce88a80157c0bde67d RY(40.0*acos(w\u2083*(0.667*x + 1.667))) f3ddf797190c4496b51695e0f0cd42bf--77191e0811d742ce88a80157c0bde67d 288c6c1b243e466ea6a827dcd2a992fa 2 77191e0811d742ce88a80157c0bde67d--fc4af4822ed641f381346a2a40203f9a 7d6ea084dba849b78a15c16c5ef8775d e2d22ecfdbf04ba9ab55db80835918e0 RY(20.0*acos(w\u2082*(0.667*x + 1.667))) 288c6c1b243e466ea6a827dcd2a992fa--e2d22ecfdbf04ba9ab55db80835918e0 4f4f4e86effe47b29877768373c902ee 3 e2d22ecfdbf04ba9ab55db80835918e0--7d6ea084dba849b78a15c16c5ef8775d 73c8b28fc1894733a5692f9d8b1b3c2b 91659c6ae84c40bb8e34e00dd2d330df RY(10.0*acos(w\u2081*(0.667*x + 1.667))) 4f4f4e86effe47b29877768373c902ee--91659c6ae84c40bb8e34e00dd2d330df 9026542a81e6433480c485e16d03b138 4 91659c6ae84c40bb8e34e00dd2d330df--73c8b28fc1894733a5692f9d8b1b3c2b e6fb1950386b4767b975c082da417848 797c6c1e575546329a345d489065432f RY(5.0*acos(w\u2080*(0.667*x + 1.667))) 9026542a81e6433480c485e16d03b138--797c6c1e575546329a345d489065432f 797c6c1e575546329a345d489065432f--e6fb1950386b4767b975c082da417848"},{"location":"qml/qml_constructors/#hardware-efficient-ansatz","title":"Hardware-efficient ansatz","text":"<p>Ansatze blocks for quantum machine-learning are typically built following the Hardware-Efficient Ansatz formalism (HEA). Both fully digital and digital-analog HEAs can easily be built with the <code>hea</code> function. By default, the digital version is returned:</p> <pre><code>from qadence import hea\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = hea(n_qubits, depth)\n</code></pre> %3 ddaf5be77bc04009861dfb1bdfe620ef 0 1d9c9c4f1246443999d9120e4371bfb0 RX(theta\u2080) ddaf5be77bc04009861dfb1bdfe620ef--1d9c9c4f1246443999d9120e4371bfb0 8f22b5028f0646d1965b600e3cb95443 1 d366ed4f939b43adbd8b9442f29f87e6 RY(theta\u2083) 1d9c9c4f1246443999d9120e4371bfb0--d366ed4f939b43adbd8b9442f29f87e6 e095c5cbb8d84030b33c31d3d40a85a0 RX(theta\u2086) d366ed4f939b43adbd8b9442f29f87e6--e095c5cbb8d84030b33c31d3d40a85a0 c73498d6bee54c409ae2449b4667c0db e095c5cbb8d84030b33c31d3d40a85a0--c73498d6bee54c409ae2449b4667c0db eea8e1029f664740a3547b88842f47a3 c73498d6bee54c409ae2449b4667c0db--eea8e1029f664740a3547b88842f47a3 b69249e327fa46b7b006e0dd19a0af56 RX(theta\u2089) eea8e1029f664740a3547b88842f47a3--b69249e327fa46b7b006e0dd19a0af56 cc3bb53eff4846c4a0f9c4e32d8563f0 RY(theta\u2081\u2082) b69249e327fa46b7b006e0dd19a0af56--cc3bb53eff4846c4a0f9c4e32d8563f0 2853735665f94225b96df01ae43ed8d1 RX(theta\u2081\u2085) cc3bb53eff4846c4a0f9c4e32d8563f0--2853735665f94225b96df01ae43ed8d1 0619d0ce20b14b5ca8a93b170ac5e8f3 2853735665f94225b96df01ae43ed8d1--0619d0ce20b14b5ca8a93b170ac5e8f3 9a262f8dff444ae3b15f919ba63df6ef 0619d0ce20b14b5ca8a93b170ac5e8f3--9a262f8dff444ae3b15f919ba63df6ef 9612ff0a1e6748e2859125ae5f4ff000 9a262f8dff444ae3b15f919ba63df6ef--9612ff0a1e6748e2859125ae5f4ff000 ce945c84eeb345f393c5e403a3ccd4f5 994b44fb94d345b6b34c33503c149c36 RX(theta\u2081) 8f22b5028f0646d1965b600e3cb95443--994b44fb94d345b6b34c33503c149c36 c04a2e5f58c74591b14bdf9c5dafc969 2 73086a27854e4dcb88d03c0ba174cea7 RY(theta\u2084) 994b44fb94d345b6b34c33503c149c36--73086a27854e4dcb88d03c0ba174cea7 ee2d1be7062c4d0399bc4184ea90b538 RX(theta\u2087) 73086a27854e4dcb88d03c0ba174cea7--ee2d1be7062c4d0399bc4184ea90b538 6f8efaf908924c88bb12e3499aba8f7f X ee2d1be7062c4d0399bc4184ea90b538--6f8efaf908924c88bb12e3499aba8f7f 6f8efaf908924c88bb12e3499aba8f7f--c73498d6bee54c409ae2449b4667c0db 66577e425d1047cfb7a4de8984aacb98 6f8efaf908924c88bb12e3499aba8f7f--66577e425d1047cfb7a4de8984aacb98 1dda3297ae47457d8f2f7a87cec28cdf RX(theta\u2081\u2080) 66577e425d1047cfb7a4de8984aacb98--1dda3297ae47457d8f2f7a87cec28cdf b3499f154d47411eab1f699694a8005c RY(theta\u2081\u2083) 1dda3297ae47457d8f2f7a87cec28cdf--b3499f154d47411eab1f699694a8005c ca21d9a4acdf4128a866df4bd0f84de3 RX(theta\u2081\u2086) b3499f154d47411eab1f699694a8005c--ca21d9a4acdf4128a866df4bd0f84de3 8d5dc3ac65d6492eb91043ac254e0a77 X ca21d9a4acdf4128a866df4bd0f84de3--8d5dc3ac65d6492eb91043ac254e0a77 8d5dc3ac65d6492eb91043ac254e0a77--0619d0ce20b14b5ca8a93b170ac5e8f3 a8641e36135a4e5eafe37e62cb1457a7 8d5dc3ac65d6492eb91043ac254e0a77--a8641e36135a4e5eafe37e62cb1457a7 a8641e36135a4e5eafe37e62cb1457a7--ce945c84eeb345f393c5e403a3ccd4f5 e57b885bb42b469d9e8977f479f219c6 8e00ed9e5ddf43b7af4f834591579631 RX(theta\u2082) c04a2e5f58c74591b14bdf9c5dafc969--8e00ed9e5ddf43b7af4f834591579631 8d8441fe8c2043d7aa667b22197bf80b RY(theta\u2085) 8e00ed9e5ddf43b7af4f834591579631--8d8441fe8c2043d7aa667b22197bf80b 5e80923e99c042f68bf92171b91226b1 RX(theta\u2088) 8d8441fe8c2043d7aa667b22197bf80b--5e80923e99c042f68bf92171b91226b1 67b322ea51bb42e1bf2ad7ac99a709bb 5e80923e99c042f68bf92171b91226b1--67b322ea51bb42e1bf2ad7ac99a709bb 4a2e917203e5461794798d4703d39064 X 67b322ea51bb42e1bf2ad7ac99a709bb--4a2e917203e5461794798d4703d39064 4a2e917203e5461794798d4703d39064--66577e425d1047cfb7a4de8984aacb98 00761ee12aeb47409aa84ea76c998154 RX(theta\u2081\u2081) 4a2e917203e5461794798d4703d39064--00761ee12aeb47409aa84ea76c998154 ba2084260ad1413eb5509da87fe6208a RY(theta\u2081\u2084) 00761ee12aeb47409aa84ea76c998154--ba2084260ad1413eb5509da87fe6208a cc331158ed5347719073079ccc2d6a54 RX(theta\u2081\u2087) ba2084260ad1413eb5509da87fe6208a--cc331158ed5347719073079ccc2d6a54 48aef4ce96074985a292254a2e2b03c4 cc331158ed5347719073079ccc2d6a54--48aef4ce96074985a292254a2e2b03c4 9e9d015001574e70801225e15867f10d X 48aef4ce96074985a292254a2e2b03c4--9e9d015001574e70801225e15867f10d 9e9d015001574e70801225e15867f10d--a8641e36135a4e5eafe37e62cb1457a7 9e9d015001574e70801225e15867f10d--e57b885bb42b469d9e8977f479f219c6 <p>As seen above, the rotation layers are automatically parameterized, and the prefix <code>\"theta\"</code> can be changed with the <code>param_prefix</code> argument.</p> <p>Furthermore, both the single-qubit rotations and the two-qubit entangler can be customized with the <code>operations</code> and <code>entangler</code> argument. The operations can be passed as a list of single-qubit rotations, while the entangler should be either <code>CNOT</code>, <code>CZ</code>, <code>CRX</code>, <code>CRY</code>, <code>CRZ</code> or <code>CPHASE</code>.</p> <pre><code>from qadence import RX, RY, CPHASE\n\nansatz = hea(\n    n_qubits=n_qubits,\n    depth=depth,\n    param_prefix=\"phi\",\n    operations=[RX, RY, RX],\n    entangler=CPHASE\n)\n</code></pre> %3 eedfc9ab343447758ce860777071343b 0 59cc92870e5a45adb9d72e1e7a4a66bf RX(phi\u2080) eedfc9ab343447758ce860777071343b--59cc92870e5a45adb9d72e1e7a4a66bf 39789ffb69ae4dd1bb59a0ee04a62fd1 1 241e45a5dd9d42c3b16f182645aa4f1c RY(phi\u2083) 59cc92870e5a45adb9d72e1e7a4a66bf--241e45a5dd9d42c3b16f182645aa4f1c 149ea507197448c588aa8d51795c6a2b RX(phi\u2086) 241e45a5dd9d42c3b16f182645aa4f1c--149ea507197448c588aa8d51795c6a2b 9b846e9a38cc408ba5a71af27e09d3a8 149ea507197448c588aa8d51795c6a2b--9b846e9a38cc408ba5a71af27e09d3a8 cb0f1f67ec0e44688e8e005c5b39f811 9b846e9a38cc408ba5a71af27e09d3a8--cb0f1f67ec0e44688e8e005c5b39f811 dd443f5c90224e09a9c529cdf9a5ea8d RX(phi\u2089) cb0f1f67ec0e44688e8e005c5b39f811--dd443f5c90224e09a9c529cdf9a5ea8d 96fdc2c11c704f49b116daefa126732f RY(phi\u2081\u2082) dd443f5c90224e09a9c529cdf9a5ea8d--96fdc2c11c704f49b116daefa126732f d2dc347c350f4eb3986a7b02321d68e3 RX(phi\u2081\u2085) 96fdc2c11c704f49b116daefa126732f--d2dc347c350f4eb3986a7b02321d68e3 ccbf0c83b1344c6783516751e6a425a6 d2dc347c350f4eb3986a7b02321d68e3--ccbf0c83b1344c6783516751e6a425a6 242a87227f47468a959d6ebcbb8ff3cb ccbf0c83b1344c6783516751e6a425a6--242a87227f47468a959d6ebcbb8ff3cb 81f6e22a2af747168f7ea37b346da75a 242a87227f47468a959d6ebcbb8ff3cb--81f6e22a2af747168f7ea37b346da75a 184cab9637e74c9a98d64df7bfaecff1 5c054cb634334db88f4039ceeac00eba RX(phi\u2081) 39789ffb69ae4dd1bb59a0ee04a62fd1--5c054cb634334db88f4039ceeac00eba 485f27d0c77843a0b9bbf09e9199a0c8 2 3a8960730a7a45cf9ef3e01ff8b82ccf RY(phi\u2084) 5c054cb634334db88f4039ceeac00eba--3a8960730a7a45cf9ef3e01ff8b82ccf 9786f8cc9ad04ef5bf3ee1c9ed9ee619 RX(phi\u2087) 3a8960730a7a45cf9ef3e01ff8b82ccf--9786f8cc9ad04ef5bf3ee1c9ed9ee619 fcb7351b0cf645788434c247c15e4fad PHASE(phi_ent\u2080) 9786f8cc9ad04ef5bf3ee1c9ed9ee619--fcb7351b0cf645788434c247c15e4fad fcb7351b0cf645788434c247c15e4fad--9b846e9a38cc408ba5a71af27e09d3a8 c850d25019b541e598c67bd1014434b2 fcb7351b0cf645788434c247c15e4fad--c850d25019b541e598c67bd1014434b2 05b5e0086b934f27ae92b7cb139f1cf6 RX(phi\u2081\u2080) c850d25019b541e598c67bd1014434b2--05b5e0086b934f27ae92b7cb139f1cf6 0f4e6d8ee67742e9a52b4f9cdddfcfee RY(phi\u2081\u2083) 05b5e0086b934f27ae92b7cb139f1cf6--0f4e6d8ee67742e9a52b4f9cdddfcfee 5c781f060d114263b7e125bc8dc27db1 RX(phi\u2081\u2086) 0f4e6d8ee67742e9a52b4f9cdddfcfee--5c781f060d114263b7e125bc8dc27db1 65c4ed44fdbe4170b9f5ef5ab6edfb6c PHASE(phi_ent\u2082) 5c781f060d114263b7e125bc8dc27db1--65c4ed44fdbe4170b9f5ef5ab6edfb6c 65c4ed44fdbe4170b9f5ef5ab6edfb6c--ccbf0c83b1344c6783516751e6a425a6 2b3ee9cbf8ff4d4f95bcbb0aee2246d1 65c4ed44fdbe4170b9f5ef5ab6edfb6c--2b3ee9cbf8ff4d4f95bcbb0aee2246d1 2b3ee9cbf8ff4d4f95bcbb0aee2246d1--184cab9637e74c9a98d64df7bfaecff1 62325038dd134641a421886719490db3 7d5351980ae6411eb0d696fb14bfe91f RX(phi\u2082) 485f27d0c77843a0b9bbf09e9199a0c8--7d5351980ae6411eb0d696fb14bfe91f 9c558fd621874df9b71c59f9a79787f3 RY(phi\u2085) 7d5351980ae6411eb0d696fb14bfe91f--9c558fd621874df9b71c59f9a79787f3 ea0c5cd726f74ba4a975182712c9f292 RX(phi\u2088) 9c558fd621874df9b71c59f9a79787f3--ea0c5cd726f74ba4a975182712c9f292 d4e6caf864784c098ce71b346895c8df ea0c5cd726f74ba4a975182712c9f292--d4e6caf864784c098ce71b346895c8df 4ac9f19264474a5d9ac43b9859adf32a PHASE(phi_ent\u2081) d4e6caf864784c098ce71b346895c8df--4ac9f19264474a5d9ac43b9859adf32a 4ac9f19264474a5d9ac43b9859adf32a--c850d25019b541e598c67bd1014434b2 d354970a5ba944db91feabcd98cc83c4 RX(phi\u2081\u2081) 4ac9f19264474a5d9ac43b9859adf32a--d354970a5ba944db91feabcd98cc83c4 28864a36be924ffeb8a20687cefd3240 RY(phi\u2081\u2084) d354970a5ba944db91feabcd98cc83c4--28864a36be924ffeb8a20687cefd3240 e23a8305ead74fd4b8844d96f1dc4aeb RX(phi\u2081\u2087) 28864a36be924ffeb8a20687cefd3240--e23a8305ead74fd4b8844d96f1dc4aeb 879c13fddc7c4a309f460bc304c2716e e23a8305ead74fd4b8844d96f1dc4aeb--879c13fddc7c4a309f460bc304c2716e 64f3b239e0ab4d1dbe64d217b31897ce PHASE(phi_ent\u2083) 879c13fddc7c4a309f460bc304c2716e--64f3b239e0ab4d1dbe64d217b31897ce 64f3b239e0ab4d1dbe64d217b31897ce--2b3ee9cbf8ff4d4f95bcbb0aee2246d1 64f3b239e0ab4d1dbe64d217b31897ce--62325038dd134641a421886719490db3 <p>Having a truly hardware-efficient ansatz means that the entangling operation can be chosen according to each device's native interactions. Besides digital operations, in Qadence it is also possible to build digital-analog HEAs with the entanglement produced by the natural evolution of a set of interacting qubits, as natively implemented in neutral atom devices. As with other digital-analog functions, this can be controlled with the <code>strategy</code> argument which can be chosen from the <code>Strategy</code> enum type. Currently, only <code>Strategy.DIGITAL</code> and <code>Strategy.SDAQC</code> are available. By default, calling <code>strategy = Strategy.SDAQC</code> will use a global entangling Hamiltonian with Ising-like \\(NN\\) interactions and constant interaction strength,</p> <pre><code>from qadence import Strategy\n\nansatz = hea(\n    n_qubits,\n    depth=depth,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_0638ecaebe86441db0fbdd9975971f38 cluster_41bee70a26454bb2a2c9e8f911bda772 cdee2bfcedb24b83a9b3a097c8e26352 0 08bc5c6ae2444e02bc22143885e10328 RX(theta\u2080) cdee2bfcedb24b83a9b3a097c8e26352--08bc5c6ae2444e02bc22143885e10328 54b450088c274a5e88b94ee656c1786b 1 203321cc7cd646ccb384ca5c3e2e0184 RY(theta\u2083) 08bc5c6ae2444e02bc22143885e10328--203321cc7cd646ccb384ca5c3e2e0184 f476d407b935444683b6c194b956d6c5 RX(theta\u2086) 203321cc7cd646ccb384ca5c3e2e0184--f476d407b935444683b6c194b956d6c5 f04023dbe5154a489ac0b6195c97c9e4 HamEvo f476d407b935444683b6c194b956d6c5--f04023dbe5154a489ac0b6195c97c9e4 2bd6b08713ee4f029426beaaeae41255 RX(theta\u2089) f04023dbe5154a489ac0b6195c97c9e4--2bd6b08713ee4f029426beaaeae41255 7634f27410c44911af8bfd92531848ab RY(theta\u2081\u2082) 2bd6b08713ee4f029426beaaeae41255--7634f27410c44911af8bfd92531848ab 005743362fc84cc8b8fc80aca6e6411b RX(theta\u2081\u2085) 7634f27410c44911af8bfd92531848ab--005743362fc84cc8b8fc80aca6e6411b 1db2a4ac885b42e982314bb881bf5424 HamEvo 005743362fc84cc8b8fc80aca6e6411b--1db2a4ac885b42e982314bb881bf5424 9540c74c229a4719af239c548549058b 1db2a4ac885b42e982314bb881bf5424--9540c74c229a4719af239c548549058b 2d6d529fef074f769d29469822babc73 20d1617789364ae98c33d01e0f2fa874 RX(theta\u2081) 54b450088c274a5e88b94ee656c1786b--20d1617789364ae98c33d01e0f2fa874 2268632be5ae4d629c431295ed833ac5 2 6ba1734d261d4a3484bf016cec5f11c1 RY(theta\u2084) 20d1617789364ae98c33d01e0f2fa874--6ba1734d261d4a3484bf016cec5f11c1 c9e9e61ea0874015a05ae0ed718afc6b RX(theta\u2087) 6ba1734d261d4a3484bf016cec5f11c1--c9e9e61ea0874015a05ae0ed718afc6b 01327b3ea9674607ba5cb11ed3f01a49 t = theta_t\u2080 c9e9e61ea0874015a05ae0ed718afc6b--01327b3ea9674607ba5cb11ed3f01a49 ba73de472fe644b6882d8667f908f728 RX(theta\u2081\u2080) 01327b3ea9674607ba5cb11ed3f01a49--ba73de472fe644b6882d8667f908f728 a62e07c93a7b4dce83b8083326b416f2 RY(theta\u2081\u2083) ba73de472fe644b6882d8667f908f728--a62e07c93a7b4dce83b8083326b416f2 0b7da8cfece44691ad6761ba004ec5c7 RX(theta\u2081\u2086) a62e07c93a7b4dce83b8083326b416f2--0b7da8cfece44691ad6761ba004ec5c7 64032b14267c4e11882e0cba306b1735 t = theta_t\u2081 0b7da8cfece44691ad6761ba004ec5c7--64032b14267c4e11882e0cba306b1735 64032b14267c4e11882e0cba306b1735--2d6d529fef074f769d29469822babc73 eb7310d069e742cfbd592561b008f681 6f46874f28f640449841667eb7ef9f00 RX(theta\u2082) 2268632be5ae4d629c431295ed833ac5--6f46874f28f640449841667eb7ef9f00 ab4ac54d785841b6bfe906db8042a88a RY(theta\u2085) 6f46874f28f640449841667eb7ef9f00--ab4ac54d785841b6bfe906db8042a88a 16f42a7cda994dcea93e110b92ac480c RX(theta\u2088) ab4ac54d785841b6bfe906db8042a88a--16f42a7cda994dcea93e110b92ac480c daa0a9d946f846a3bf238a50e01c693e 16f42a7cda994dcea93e110b92ac480c--daa0a9d946f846a3bf238a50e01c693e 279e73da630449f089da2ea4356bcebf RX(theta\u2081\u2081) daa0a9d946f846a3bf238a50e01c693e--279e73da630449f089da2ea4356bcebf 3b0eaa2de4d04c62a7af26261e11adbf RY(theta\u2081\u2084) 279e73da630449f089da2ea4356bcebf--3b0eaa2de4d04c62a7af26261e11adbf ec3205bbfc9148c49268dc5540cd59e8 RX(theta\u2081\u2087) 3b0eaa2de4d04c62a7af26261e11adbf--ec3205bbfc9148c49268dc5540cd59e8 a77ebb3f5cb34c2b87312f4008c63659 ec3205bbfc9148c49268dc5540cd59e8--a77ebb3f5cb34c2b87312f4008c63659 a77ebb3f5cb34c2b87312f4008c63659--eb7310d069e742cfbd592561b008f681 <p>Note that, by default, only the time-parameter is automatically parameterized when building a digital-analog HEA. However, as described in the Hamiltonians tutorial, arbitrary interaction Hamiltonians can be easily built with the <code>hamiltonian_factory</code> function, with both customized or fully parameterized interactions, and these can be directly passed as the <code>entangler</code> for a customizable digital-analog HEA.</p> <pre><code>from qadence import hamiltonian_factory, Interaction, N, Register, hea\n\n# Build a parameterized neutral-atom Hamiltonian following a honeycomb_lattice:\nregister = Register.honeycomb_lattice(1, 1)\n\nentangler = hamiltonian_factory(\n    register,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"e\",\n    detuning_strength=\"n\"\n)\n\n# Build a fully parameterized Digital-Analog HEA:\nn_qubits = register.n_qubits\ndepth = 2\n\nansatz = hea(\n    n_qubits=register.n_qubits,\n    depth=depth,\n    operations=[RX, RY, RX],\n    entangler=entangler,\n    strategy=Strategy.SDAQC\n)\n</code></pre> %3 cluster_e1fe65a595fe44b9af5b0f38bd455a9e cluster_dce8bf0022344083b6b7bb4de2da795a 7a04da0d3560421cb5d3eacbfb2fc868 0 f6cd661fc257472790711bdc5b336be5 RX(theta\u2080) 7a04da0d3560421cb5d3eacbfb2fc868--f6cd661fc257472790711bdc5b336be5 0a638cd024de4de78fb38dc189b09665 1 47b8bce5fe4c4d1d8269e75e49041ccd RY(theta\u2086) f6cd661fc257472790711bdc5b336be5--47b8bce5fe4c4d1d8269e75e49041ccd 031c8aaa578d4657a8c9ab3b3ed245cf RX(theta\u2081\u2082) 47b8bce5fe4c4d1d8269e75e49041ccd--031c8aaa578d4657a8c9ab3b3ed245cf 96a82ead5c71444d944037b623210da9 031c8aaa578d4657a8c9ab3b3ed245cf--96a82ead5c71444d944037b623210da9 f71cc887d9c642d192b674765bfccdd9 RX(theta\u2081\u2088) 96a82ead5c71444d944037b623210da9--f71cc887d9c642d192b674765bfccdd9 11c97d7d92aa47a8b3d348179e8c7938 RY(theta\u2082\u2084) f71cc887d9c642d192b674765bfccdd9--11c97d7d92aa47a8b3d348179e8c7938 30e1ce47e8854377926c5c527de2fa67 RX(theta\u2083\u2080) 11c97d7d92aa47a8b3d348179e8c7938--30e1ce47e8854377926c5c527de2fa67 7f050069726047d482bc9aa8f66df64b 30e1ce47e8854377926c5c527de2fa67--7f050069726047d482bc9aa8f66df64b efe932eff9c24272a6804311908fb87d 7f050069726047d482bc9aa8f66df64b--efe932eff9c24272a6804311908fb87d b5fd698bc8b6460a943ef64d4e0e993f ffb4b420d99242579074cf5aaf4a5326 RX(theta\u2081) 0a638cd024de4de78fb38dc189b09665--ffb4b420d99242579074cf5aaf4a5326 ec4f7cb126cf4f848cffb74b0d8ac8bf 2 ae48824272c148abbdfbab778702dd3c RY(theta\u2087) ffb4b420d99242579074cf5aaf4a5326--ae48824272c148abbdfbab778702dd3c 52d7a4e7fd3e4fab97ede12831d1746c RX(theta\u2081\u2083) ae48824272c148abbdfbab778702dd3c--52d7a4e7fd3e4fab97ede12831d1746c c6dc7712be324c9c8c9b809ec8ebf014 52d7a4e7fd3e4fab97ede12831d1746c--c6dc7712be324c9c8c9b809ec8ebf014 abc5e0036fab44a9a67ef1a2d1e0d550 RX(theta\u2081\u2089) c6dc7712be324c9c8c9b809ec8ebf014--abc5e0036fab44a9a67ef1a2d1e0d550 d3e944e8cdd648d3bcffd04358f5e01f RY(theta\u2082\u2085) abc5e0036fab44a9a67ef1a2d1e0d550--d3e944e8cdd648d3bcffd04358f5e01f 26523355b59a434a8a152fadbe5739a3 RX(theta\u2083\u2081) d3e944e8cdd648d3bcffd04358f5e01f--26523355b59a434a8a152fadbe5739a3 17db26f61bca4404bf8c7b2680806664 26523355b59a434a8a152fadbe5739a3--17db26f61bca4404bf8c7b2680806664 17db26f61bca4404bf8c7b2680806664--b5fd698bc8b6460a943ef64d4e0e993f 96b2f6a31e2d4b008f87a62da10cee67 de39c3f8055247749ef606f49aadc0d5 RX(theta\u2082) ec4f7cb126cf4f848cffb74b0d8ac8bf--de39c3f8055247749ef606f49aadc0d5 f14b7d17ce4748bda6668667d23ac49a 3 d44ab211fdae4ac7b59c0847e8565009 RY(theta\u2088) de39c3f8055247749ef606f49aadc0d5--d44ab211fdae4ac7b59c0847e8565009 8f289a985f0f4ceeb2c06b2b505fca6b RX(theta\u2081\u2084) d44ab211fdae4ac7b59c0847e8565009--8f289a985f0f4ceeb2c06b2b505fca6b fd8f4bf17f28478a8cd304e7996b3ba0 HamEvo 8f289a985f0f4ceeb2c06b2b505fca6b--fd8f4bf17f28478a8cd304e7996b3ba0 f4cc8d1d760348cd8cf695eab188f104 RX(theta\u2082\u2080) fd8f4bf17f28478a8cd304e7996b3ba0--f4cc8d1d760348cd8cf695eab188f104 416258dc5fb64ba3ab6db5b2a862a0bb RY(theta\u2082\u2086) f4cc8d1d760348cd8cf695eab188f104--416258dc5fb64ba3ab6db5b2a862a0bb 7ce6b51b54c142249dbe5262a37479aa RX(theta\u2083\u2082) 416258dc5fb64ba3ab6db5b2a862a0bb--7ce6b51b54c142249dbe5262a37479aa 33b432e8845d475ca9779a6d0770b61d HamEvo 7ce6b51b54c142249dbe5262a37479aa--33b432e8845d475ca9779a6d0770b61d 33b432e8845d475ca9779a6d0770b61d--96b2f6a31e2d4b008f87a62da10cee67 ca03e30b37334136b393c34a587d012a 5aa8ccc46ee042ee98936aef3c541e8f RX(theta\u2083) f14b7d17ce4748bda6668667d23ac49a--5aa8ccc46ee042ee98936aef3c541e8f 65aa35c4258f4450b8491b516048c290 4 f102eb372cce40b49f19f1d18b9a4be7 RY(theta\u2089) 5aa8ccc46ee042ee98936aef3c541e8f--f102eb372cce40b49f19f1d18b9a4be7 c7490aca8cbb4fc8a62dcc85f3afc643 RX(theta\u2081\u2085) f102eb372cce40b49f19f1d18b9a4be7--c7490aca8cbb4fc8a62dcc85f3afc643 34ebd62b1a274a1691a4fdbae83523e6 t = theta_t\u2080 c7490aca8cbb4fc8a62dcc85f3afc643--34ebd62b1a274a1691a4fdbae83523e6 1354974f97c54e6a93c7ea84c7d4b4ea RX(theta\u2082\u2081) 34ebd62b1a274a1691a4fdbae83523e6--1354974f97c54e6a93c7ea84c7d4b4ea 926ff6978f694eec87073cd8f86d03c9 RY(theta\u2082\u2087) 1354974f97c54e6a93c7ea84c7d4b4ea--926ff6978f694eec87073cd8f86d03c9 625ee4d2e85c4d64b53e2c5c2d706631 RX(theta\u2083\u2083) 926ff6978f694eec87073cd8f86d03c9--625ee4d2e85c4d64b53e2c5c2d706631 cc5a3c8254a94d52a6bd06c3d7f969e4 t = theta_t\u2081 625ee4d2e85c4d64b53e2c5c2d706631--cc5a3c8254a94d52a6bd06c3d7f969e4 cc5a3c8254a94d52a6bd06c3d7f969e4--ca03e30b37334136b393c34a587d012a b0133ac3ed02461d8090e363cc3bff4a 4c0c5b2bbe224609a1ec6a2626875401 RX(theta\u2084) 65aa35c4258f4450b8491b516048c290--4c0c5b2bbe224609a1ec6a2626875401 5f09cf5f185b4187b85573f710d583c0 5 1434088d6a6c4ee09d55578ccb7b3537 RY(theta\u2081\u2080) 4c0c5b2bbe224609a1ec6a2626875401--1434088d6a6c4ee09d55578ccb7b3537 6f6b3a4368584f16971c46c0eb1ad016 RX(theta\u2081\u2086) 1434088d6a6c4ee09d55578ccb7b3537--6f6b3a4368584f16971c46c0eb1ad016 cf551b29e6494c5bb3ea2b59c3b50b31 6f6b3a4368584f16971c46c0eb1ad016--cf551b29e6494c5bb3ea2b59c3b50b31 8e9c6bf6a53e4be5a424330571e0987c RX(theta\u2082\u2082) cf551b29e6494c5bb3ea2b59c3b50b31--8e9c6bf6a53e4be5a424330571e0987c 89213a1758454ceb86cd1f88f7574d7e RY(theta\u2082\u2088) 8e9c6bf6a53e4be5a424330571e0987c--89213a1758454ceb86cd1f88f7574d7e 3919200136d449d389b564772b47703e RX(theta\u2083\u2084) 89213a1758454ceb86cd1f88f7574d7e--3919200136d449d389b564772b47703e 05d1ab69545347468d3cfd206bcd43b4 3919200136d449d389b564772b47703e--05d1ab69545347468d3cfd206bcd43b4 05d1ab69545347468d3cfd206bcd43b4--b0133ac3ed02461d8090e363cc3bff4a 7880d47414ce4f5aa32166e9c1fd12ab 9739ab33dc5b4ea59cf9286c4bd033bb RX(theta\u2085) 5f09cf5f185b4187b85573f710d583c0--9739ab33dc5b4ea59cf9286c4bd033bb d4f04eaea3364d75969fc7b2fe9a17ba RY(theta\u2081\u2081) 9739ab33dc5b4ea59cf9286c4bd033bb--d4f04eaea3364d75969fc7b2fe9a17ba 888b23af1d534143a04cf3b445961d23 RX(theta\u2081\u2087) d4f04eaea3364d75969fc7b2fe9a17ba--888b23af1d534143a04cf3b445961d23 fc0cd4833dc244af895c74c416de0d67 888b23af1d534143a04cf3b445961d23--fc0cd4833dc244af895c74c416de0d67 791e311a5bec4fd2b97d01b07c81bebc RX(theta\u2082\u2083) fc0cd4833dc244af895c74c416de0d67--791e311a5bec4fd2b97d01b07c81bebc efed9b3ed746400e9bee2999b0f2d23e RY(theta\u2082\u2089) 791e311a5bec4fd2b97d01b07c81bebc--efed9b3ed746400e9bee2999b0f2d23e b8282c3a21e44fc7b9fb907ab7deb753 RX(theta\u2083\u2085) efed9b3ed746400e9bee2999b0f2d23e--b8282c3a21e44fc7b9fb907ab7deb753 c98ee6e2e023489ca9e4bb11cbd78ebc b8282c3a21e44fc7b9fb907ab7deb753--c98ee6e2e023489ca9e4bb11cbd78ebc c98ee6e2e023489ca9e4bb11cbd78ebc--7880d47414ce4f5aa32166e9c1fd12ab"},{"location":"qml/qml_constructors/#identity-initialized-ansatz","title":"Identity-initialized ansatz","text":"<p>It is widely known that parametrized quantum circuits are characterized by barren plateaus, where the gradient becomes exponentially small in the number of qubits. Here we include one of many techniques that have been proposed in recent years to mitigate this effect and facilitate <code>QNN</code>s training: Grant et al. showed that initializing the weights of a <code>QNN</code> so that each block of the circuit evaluates to identity reduces the effect of barren plateaus in the initial stage of training. In a similar fashion to <code>hea</code>, such circuit can be created via calling the associated function, <code>identity_initialized_ansatz</code>:</p> <pre><code>from qadence.constructors import identity_initialized_ansatz\nfrom qadence.draw import display\n\nn_qubits = 3\ndepth = 2\n\nansatz = identity_initialized_ansatz(n_qubits, depth)\n</code></pre> %3 cluster_852e89757a7747a48576182244d91aaf BPMA-1 cluster_d026cb234b7d406cb6ecff015689dcf2 BPMA-0 1a6b675202ca4f1ebfc5bc4ff331068f 0 b970171d51ee4a018f9d93de5a4f6630 RX(iia_\u03b1\u2080\u2080) 1a6b675202ca4f1ebfc5bc4ff331068f--b970171d51ee4a018f9d93de5a4f6630 0ad05a2f813a48e7b578209cb6b0b77d 1 7bedb481787444a2a85ca90ff12ee744 RY(iia_\u03b1\u2080\u2083) b970171d51ee4a018f9d93de5a4f6630--7bedb481787444a2a85ca90ff12ee744 9771882292b848da86f7d39b76f04b06 7bedb481787444a2a85ca90ff12ee744--9771882292b848da86f7d39b76f04b06 a00a118bb7fc4ec388e3bd6c5e7191ef 9771882292b848da86f7d39b76f04b06--a00a118bb7fc4ec388e3bd6c5e7191ef c2f5f8efbc2f49b9bf4265586a44c831 RX(iia_\u03b3\u2080\u2080) a00a118bb7fc4ec388e3bd6c5e7191ef--c2f5f8efbc2f49b9bf4265586a44c831 08c2015cf0fa4c1f89229818e4d8ef72 c2f5f8efbc2f49b9bf4265586a44c831--08c2015cf0fa4c1f89229818e4d8ef72 111da714880141edb452bd5b97a11397 08c2015cf0fa4c1f89229818e4d8ef72--111da714880141edb452bd5b97a11397 313020e9ed394f8b81bf720909b88791 RY(iia_\u03b2\u2080\u2083) 111da714880141edb452bd5b97a11397--313020e9ed394f8b81bf720909b88791 e722e2838dea4a2c9b59cc725e0a4496 RX(iia_\u03b2\u2080\u2080) 313020e9ed394f8b81bf720909b88791--e722e2838dea4a2c9b59cc725e0a4496 be2ba75f7d1e4cd789bbaa32406c4774 RX(iia_\u03b1\u2081\u2080) e722e2838dea4a2c9b59cc725e0a4496--be2ba75f7d1e4cd789bbaa32406c4774 31068f077e7f4c3b9e642797ede39491 RY(iia_\u03b1\u2081\u2083) be2ba75f7d1e4cd789bbaa32406c4774--31068f077e7f4c3b9e642797ede39491 29717a447ab7489cb9ab913d8cc94bdd 31068f077e7f4c3b9e642797ede39491--29717a447ab7489cb9ab913d8cc94bdd 04cb8a6349db4b3e9c11ce0cdc19080a 29717a447ab7489cb9ab913d8cc94bdd--04cb8a6349db4b3e9c11ce0cdc19080a d44b5d1412a54b91952ca15cd55716cf RX(iia_\u03b3\u2081\u2080) 04cb8a6349db4b3e9c11ce0cdc19080a--d44b5d1412a54b91952ca15cd55716cf 8527e751777f499da06d331ee4c92b1f d44b5d1412a54b91952ca15cd55716cf--8527e751777f499da06d331ee4c92b1f 363d657b913c4807a278c20a53ecd011 8527e751777f499da06d331ee4c92b1f--363d657b913c4807a278c20a53ecd011 e8ff7b474b9c4cabb5e7b972e9c1050b RY(iia_\u03b2\u2081\u2083) 363d657b913c4807a278c20a53ecd011--e8ff7b474b9c4cabb5e7b972e9c1050b 47e075d1e1c24e209ff34ac73bf40053 RX(iia_\u03b2\u2081\u2080) e8ff7b474b9c4cabb5e7b972e9c1050b--47e075d1e1c24e209ff34ac73bf40053 6e8fad243aac454eaae5baf37b1045bb 47e075d1e1c24e209ff34ac73bf40053--6e8fad243aac454eaae5baf37b1045bb 00f04de2701347db950f4464e2360586 0aa1a70dc24d452d947000318eaa9295 RX(iia_\u03b1\u2080\u2081) 0ad05a2f813a48e7b578209cb6b0b77d--0aa1a70dc24d452d947000318eaa9295 40dee5de10ef4ea283e93ebb6e726dec 2 0336bdc3f8b64cd5ae16fa5c36bd858c RY(iia_\u03b1\u2080\u2084) 0aa1a70dc24d452d947000318eaa9295--0336bdc3f8b64cd5ae16fa5c36bd858c 7775682991d0406486d8c9e71c0aae1c X 0336bdc3f8b64cd5ae16fa5c36bd858c--7775682991d0406486d8c9e71c0aae1c 7775682991d0406486d8c9e71c0aae1c--9771882292b848da86f7d39b76f04b06 9d0fc939b83345d1a77c04cf81009f8f 7775682991d0406486d8c9e71c0aae1c--9d0fc939b83345d1a77c04cf81009f8f 593565c74eb949889d9906904cd7b07e RX(iia_\u03b3\u2080\u2081) 9d0fc939b83345d1a77c04cf81009f8f--593565c74eb949889d9906904cd7b07e 04e182282d224723b2d61f23d4744922 593565c74eb949889d9906904cd7b07e--04e182282d224723b2d61f23d4744922 af191b442ff043e0828838590de324f4 X 04e182282d224723b2d61f23d4744922--af191b442ff043e0828838590de324f4 af191b442ff043e0828838590de324f4--111da714880141edb452bd5b97a11397 24bb85edaca949f183ddda3f3d6329cd RY(iia_\u03b2\u2080\u2084) af191b442ff043e0828838590de324f4--24bb85edaca949f183ddda3f3d6329cd d641320e23fb406b8fe3c2a7b3a91ab5 RX(iia_\u03b2\u2080\u2081) 24bb85edaca949f183ddda3f3d6329cd--d641320e23fb406b8fe3c2a7b3a91ab5 d1233b5455a14072947e14aa7335d9e5 RX(iia_\u03b1\u2081\u2081) d641320e23fb406b8fe3c2a7b3a91ab5--d1233b5455a14072947e14aa7335d9e5 3967a723b4014bc6b4645425a48a8ce8 RY(iia_\u03b1\u2081\u2084) d1233b5455a14072947e14aa7335d9e5--3967a723b4014bc6b4645425a48a8ce8 5b1eeff9600644a59d4501381cf39d1f X 3967a723b4014bc6b4645425a48a8ce8--5b1eeff9600644a59d4501381cf39d1f 5b1eeff9600644a59d4501381cf39d1f--29717a447ab7489cb9ab913d8cc94bdd 5a49b8f29d9a4acbaded51eddb10a0eb 5b1eeff9600644a59d4501381cf39d1f--5a49b8f29d9a4acbaded51eddb10a0eb 814bd51208a4474d93d9cd774ed09ef2 RX(iia_\u03b3\u2081\u2081) 5a49b8f29d9a4acbaded51eddb10a0eb--814bd51208a4474d93d9cd774ed09ef2 bfc4acd88de640469e4ab8359221317d 814bd51208a4474d93d9cd774ed09ef2--bfc4acd88de640469e4ab8359221317d 6cfb86b506234c0eae2dc3bbd7a65db5 X bfc4acd88de640469e4ab8359221317d--6cfb86b506234c0eae2dc3bbd7a65db5 6cfb86b506234c0eae2dc3bbd7a65db5--363d657b913c4807a278c20a53ecd011 6b70def4d2dc46eab940daf74dfdfcf6 RY(iia_\u03b2\u2081\u2084) 6cfb86b506234c0eae2dc3bbd7a65db5--6b70def4d2dc46eab940daf74dfdfcf6 5e6422d18f1747d39f8f4620ec65397b RX(iia_\u03b2\u2081\u2081) 6b70def4d2dc46eab940daf74dfdfcf6--5e6422d18f1747d39f8f4620ec65397b 5e6422d18f1747d39f8f4620ec65397b--00f04de2701347db950f4464e2360586 f2b533863dcf4b348e4dc4ba94f3c6cb a0d9aa350e03477d8fff53ffe82ee538 RX(iia_\u03b1\u2080\u2082) 40dee5de10ef4ea283e93ebb6e726dec--a0d9aa350e03477d8fff53ffe82ee538 3f8a28ee9f8042109c2cbf1ed848fd29 RY(iia_\u03b1\u2080\u2085) a0d9aa350e03477d8fff53ffe82ee538--3f8a28ee9f8042109c2cbf1ed848fd29 ab089d25e08c44d8876ac2b9ec63d389 3f8a28ee9f8042109c2cbf1ed848fd29--ab089d25e08c44d8876ac2b9ec63d389 8924202c38104acdbb6936faa6c285f3 X ab089d25e08c44d8876ac2b9ec63d389--8924202c38104acdbb6936faa6c285f3 8924202c38104acdbb6936faa6c285f3--9d0fc939b83345d1a77c04cf81009f8f 0ffa34dd1e2448dba9a9d2b801f94746 RX(iia_\u03b3\u2080\u2082) 8924202c38104acdbb6936faa6c285f3--0ffa34dd1e2448dba9a9d2b801f94746 1c0b32c814814784912d4a98e4bb5d7c X 0ffa34dd1e2448dba9a9d2b801f94746--1c0b32c814814784912d4a98e4bb5d7c 1c0b32c814814784912d4a98e4bb5d7c--04e182282d224723b2d61f23d4744922 207b22e1b8104d148714e3d44b34168c 1c0b32c814814784912d4a98e4bb5d7c--207b22e1b8104d148714e3d44b34168c dc9983787b4c40059efa6b410ef54f4f RY(iia_\u03b2\u2080\u2085) 207b22e1b8104d148714e3d44b34168c--dc9983787b4c40059efa6b410ef54f4f 8d1fe33a35114d1d9df89f1c0ee948c8 RX(iia_\u03b2\u2080\u2082) dc9983787b4c40059efa6b410ef54f4f--8d1fe33a35114d1d9df89f1c0ee948c8 4a2100ee23364a049efb71f76fbf491d RX(iia_\u03b1\u2081\u2082) 8d1fe33a35114d1d9df89f1c0ee948c8--4a2100ee23364a049efb71f76fbf491d 1b4c5c902b5f47dfb5b0f3bf91be3b58 RY(iia_\u03b1\u2081\u2085) 4a2100ee23364a049efb71f76fbf491d--1b4c5c902b5f47dfb5b0f3bf91be3b58 d98a2bb8bc0041d0ba01cdf231c73ffc 1b4c5c902b5f47dfb5b0f3bf91be3b58--d98a2bb8bc0041d0ba01cdf231c73ffc 763d25db0437404ea582811b2a6e19b4 X d98a2bb8bc0041d0ba01cdf231c73ffc--763d25db0437404ea582811b2a6e19b4 763d25db0437404ea582811b2a6e19b4--5a49b8f29d9a4acbaded51eddb10a0eb 1a15d3845aaf4f4f84b7fbd23f00b55e RX(iia_\u03b3\u2081\u2082) 763d25db0437404ea582811b2a6e19b4--1a15d3845aaf4f4f84b7fbd23f00b55e b2b3f8288fc64b35bb25a3b5b4a45e35 X 1a15d3845aaf4f4f84b7fbd23f00b55e--b2b3f8288fc64b35bb25a3b5b4a45e35 b2b3f8288fc64b35bb25a3b5b4a45e35--bfc4acd88de640469e4ab8359221317d f56541de02f04c43a0efe278dbcda85f b2b3f8288fc64b35bb25a3b5b4a45e35--f56541de02f04c43a0efe278dbcda85f 087e4db6b7f247929101dec5e0a09a3e RY(iia_\u03b2\u2081\u2085) f56541de02f04c43a0efe278dbcda85f--087e4db6b7f247929101dec5e0a09a3e cf0a01c38ca747409e11cf79b6d6d215 RX(iia_\u03b2\u2081\u2082) 087e4db6b7f247929101dec5e0a09a3e--cf0a01c38ca747409e11cf79b6d6d215 cf0a01c38ca747409e11cf79b6d6d215--f2b533863dcf4b348e4dc4ba94f3c6cb"},{"location":"realistic_sims/","title":"Realistic simulations","text":"<p>This section describes how to perform realistic simulations in Qadence.</p>"},{"location":"realistic_sims/measurements/","title":"Measurement protocols","text":"<p>Sample-based measurement protocols are fundamental tools for the prediction and estimation of a quantum state as the result of NISQ programs executions. Their resource efficient implementation is a current and active research field. Qadence offers two main measurement protocols: quantum state tomography and classical shadows.</p>"},{"location":"realistic_sims/measurements/#quantum-state-tomography","title":"Quantum state tomography","text":"<p>The fundamental task of quantum state tomography is to learn an approximate classical description of an output quantum state described by a density matrix \\(\\rho\\), from repeated measurements of copies on a chosen basis. To do so, \\(\\rho\\) is expanded in a basis of observables (the tomography step) and for a given observable \\(\\hat{\\mathcal{O}}\\), the expectation value is calculated with \\(\\langle \\hat{\\mathcal{O}} \\rangle=\\textrm{Tr}(\\hat{\\mathcal{O}}\\rho)\\). A number of measurement repetitions in a suitable basis is then required to estimate \\(\\langle \\hat{\\mathcal{O}} \\rangle\\).</p> <p>The main drawback is the scaling in measurements for the retrieval of the classical expression for a \\(n\\)-qubit quantum state as \\(2^n \\times 2^n\\), together with a large amount of classical post-processing.</p> <p>For an observable expressed as a Pauli string \\(\\hat{\\mathcal{P}}\\), the expectation value for a state \\(|\\psi \\rangle\\) can be derived as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\langle \\psi | \\hat{\\mathcal{P}} |\\psi \\rangle=\\langle \\psi | \\hat{\\mathcal{R}}^\\dagger \\hat{\\mathcal{D}} \\hat{\\mathcal{R}} |\\psi \\rangle \\] <p>The operator \\(\\hat{\\mathcal{R}}\\) diagonalizes \\(\\hat{\\mathcal{P}}\\) and rotates the state into an eigenstate in the computational basis. Therefore, \\(\\hat{\\mathcal{R}}|\\psi \\rangle=\\sum\\limits_{z}a_z|z\\rangle\\) and the expectation value can finally be expressed as:</p> \\[ \\langle \\hat{\\mathcal{P}} \\rangle=\\sum_{z,z'}\\langle z |\\bar{a}_z\\hat{\\mathcal{D}}a_{z'}|z'\\rangle = \\sum_{z}|a_z|^2(-1)^{\\phi_z(\\hat{\\mathcal{P}})} \\] <p>In Qadence, running a tomographical experiment is made simple by defining a <code>Measurements</code> object that captures all options for execution:</p> <pre><code>from torch import tensor\nfrom qadence import hamiltonian_factory, BackendName, DiffMode\nfrom qadence import Parameter, chain, kron, RX, RY, Z, QuantumCircuit, QuantumModel\nfrom qadence.measurements import Measurements\n\n# Define parameters for a circuit.\ntheta1 = Parameter(\"theta1\", trainable=False)\ntheta2 = Parameter(\"theta2\", trainable=False)\ntheta3 = Parameter(\"theta3\", trainable=False)\ntheta4 = Parameter(\"theta4\", trainable=False)\n\nblocks = chain(\n    kron(RX(0, theta1), RY(1, theta2)),\n    kron(RX(0, theta3), RY(1, theta4)),\n)\n\nvalues = {\n    \"theta1\": tensor([0.5]),\n    \"theta2\": tensor([1.5]),\n    \"theta3\": tensor([2.0]),\n    \"theta4\": tensor([2.5]),\n}\n\n# Create a circuit and an observable.\ncircuit = QuantumCircuit(2, blocks)\nobservable = hamiltonian_factory(2, detuning=Z)\n\n# Create a model.\nmodel = QuantumModel(\n    circuit=circuit,\n    observable=observable,\n    backend=BackendName.PYQTORCH,\n    diff_mode=DiffMode.GPSR,\n)\n\n# Define a measurement protocol by passing the shot budget as an option.\ntomo_options = {\"n_shots\": 100000}\ntomo_measurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=tomo_options)\n\n# Get the exact expectation value.\nexact_values = model.expectation(\n    values=values,\n)\n\n# Run the tomography experiment.\nestimated_values_tomo = model.expectation(\n    values=values,\n    measurement=tomo_measurement,\n)\n</code></pre> <pre><code>Exact expectation value = tensor([[-1.4548]])\nEstimated expectation value tomo = tensor([[-1.4503]])\n</code></pre>"},{"location":"realistic_sims/measurements/#classical-shadows","title":"Classical shadows","text":"<p>Recently, a much less resource demanding protocol based on classical shadows has been proposed<sup>1</sup>. It combines ideas from shadow tomography<sup>2</sup> and randomized measurement protocols capable of learning a classical shadow of an unknown quantum state \\(\\rho\\). It relies on deliberately discarding the full classical characterization of the quantum state, and instead focuses on accurately predicting a restricted set of properties that provide efficient protocols for the study of the system.</p> <p>A random measurement consists of applying random unitary rotations before a fixed measurement on each copy of a state. Appropriately averaging over these measurements produces an efficient estimator for the expectation value of an observable. This protocol therefore creates a robust classical representation of the quantum state or classical shadow. The captured measurement information is then reuseable for multiple purposes, i.e. any observable expected value and available for noise mitigation postprocessing.</p> <p>A classical shadow is therefore an unbiased estimator of a quantum state \\(\\rho\\). Such an estimator is obtained with the following procedure<sup>1</sup>: first, apply a random unitary gate \\(U\\) to rotate the state: \\(\\rho \\rightarrow U \\rho U^\\dagger\\) and then perform a basis measurement to obtain a \\(n\\)-bit measurement \\(|\\hat{b}\\rangle \\in \\{0, 1\\}^n\\). Both unitary gates \\(U\\) and the measurement outcomes \\(|\\hat{b}\\rangle\\) are stored on a classical computer for postprocessing v \\(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U\\), a classical snapshot of the state \\(\\rho\\). The whole procedure can be seen as a quantum channel \\(\\mathcal{M}\\) that maps the initial unknown quantum state \\(\\rho\\) to the average result of the measurement protocol:</p> \\[ \\mathbb{E}[U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U] = \\mathcal{M}(\\rho) \\Rightarrow \\rho = \\mathbb{E}[\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)] \\] <p>It is worth noting that the single classical snapshot \\(\\hat{\\rho}=\\mathcal{M}^{-1}(U^\\dagger |\\hat{b}\\rangle\\langle \\hat{b}|U)\\) equals \\(\\rho\\) in expectation: \\(\\mathbb{E}[\\hat{\\rho}]=\\rho\\) despite \\(\\mathcal{M}^{-1}\\) not being a completely positive map. Repeating this procedure \\(N\\) times results in an array of \\(N\\) independent, classical snapshots of \\(\\rho\\) called the classical shadow:</p> \\[ S(\\rho, N) = \\{ \\hat{\\rho}_1=\\mathcal{M}^{-1}(U_1^\\dagger |\\hat{b}_1\\rangle\\langle \\hat{b}_1|U_1),\\cdots,\\hat{\\rho}_N=\\mathcal{M}^{-1}(U_N^\\dagger |\\hat{b}_N\\rangle\\langle \\hat{b}_N|U_N)\\} \\] <p>Along the same lines as the example before, estimating the expectation value using classical shadows in Qadence only requires to pass the right set of parameters to the <code>Measurements</code> object:</p> <pre><code># Classical shadows are defined up to some accuracy and confidence.\nshadow_options = {\"accuracy\": 0.1, \"confidence\": 0.1}  # Shadow size N=54400.\nshadow_measurement = Measurements(protocol=Measurements.SHADOW, options=shadow_options)\n\n# Run the experiment with classical shadows.\nestimated_values_shadow = model.expectation(\n    values=values,\n    measurement=shadow_measurement,\n)\n</code></pre> <pre><code>Estimated expectation value shadow = tensor([[-1.5018]])\n</code></pre>"},{"location":"realistic_sims/measurements/#references","title":"References","text":"<ol> <li> <p>Hsin-Yuan Huang, Richard Kueng and John Preskill, Predicting Many Properties of a Quantum System from Very Few Measurements (2020) \u21a9\u21a9</p> </li> <li> <p>S. Aaronson. Shadow tomography of quantum states. In Proceedings of the 50th Annual A ACM SIGACT Symposium on Theory of Computing, STOC 2018, pages 325\u2013338, New York, NY, USA, 2018. ACM\u00a0\u21a9</p> </li> </ol>"},{"location":"realistic_sims/mitigation/","title":"Error mitigation","text":"<p>Beyond running noisy simulations, Qadence offers a number of noise mitigation techniques to achieve better accuracy of simulation outputs. Currently, mitigation addresses readout errors and depolarizing and dephasing noise for analog blocks.</p>"},{"location":"realistic_sims/mitigation/#readout-error-mitigation","title":"Readout error mitigation","text":"<p>The complete implementation of the mitigation technique is to measure \\(T\\) and classically apply \\(T^{\u22121}\\) to measured probability distributions. However there are several limitations of this approach:</p> <ul> <li>The complete implementation requires \\(2^n\\) characterization experiments (probability measurements), which is not scalable. The classical processing of the calibration data is also inefficient.</li> <li>The matrix \\(T\\) may become singular for large \\(n\\), preventing direct inversion.</li> <li>The inverse \\(T^{\u22121}\\) might not be a stochastic matrix, meaning that it can produce negative corrected probabilities.</li> <li>The correction is not rigorously justified, so we cannot be sure that we are only removing SPAM errors and not otherwise corrupting an estimated probability distribution.</li> </ul> <p>Qadence relies on the assumption of uncorrelated readout errors:</p> \\[ T=T_1\\otimes T_2\\otimes \\dots \\otimes T_n \\] <p>for which the inversion is straightforward:</p> \\[ T^{-1}=T_1^{-1}\\otimes T_2^{-1}\\otimes \\dots \\otimes T_n^{-1} \\] <p>However, even for a reduced \\(n\\) the third limitation holds. This can be avoided by reformulating into a minimization problem<sup>1</sup>:</p> \\[ \\lVert Tp_{\\textrm{corr}}-p_{\\textrm{raw}}\\rVert_{2}^{2} \\] <p>subjected to physicality constraints \\(0 \\leq p_{corr}(x) \\leq 1\\) and \\(\\lVert p_{corr} \\rVert = 1\\). At this point, two methods are implemented to solve this problem. The first one relies on solving using standard optimization tools, the second on Maximum-Likelihood Estimation<sup>2</sup>. In Qadence, this can be user defined using the mitigation protocol:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\nfrom qadence.mitigations import Mitigations\nfrom qadence.types import ReadOutOptimization\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use:\nnoise = Noise(protocol=Noise.READOUT)\n# Define the mitigation method solving the minimization problem:\noptions={\"optimization_type\": ReadOutOptimization.CONSTRAINED}  # ReadOutOptimization.MLE for the alternative method.\nmitigation = Mitigations(protocol=Mitigations.READOUT, options=options)\n\n# Run noiseless, noisy and mitigated simulations.\nn_shots = 100\nnoiseless_samples = model.sample(n_shots=n_shots)\nnoisy_samples = model.sample(noise=noise, n_shots=n_shots)\nmitigated_samples = model.sample(\n    noise=noise, mitigation=mitigation, n_shots=n_shots\n)\n\nprint(f\"noiseless {noiseless_samples}\")\nprint(f\"noisy {noisy_samples}\")\nprint(f\"mitigated {mitigated_samples}\")\n</code></pre> <pre><code>noiseless [Counter({'10': 54, '00': 46})]\nnoisy [Counter({'10': 52, '00': 39, '01': 6, '11': 3})]\nmitigated [Counter({'10': 44, '00': 43, '11': 7, '01': 6})]\n</code></pre>"},{"location":"realistic_sims/mitigation/#wip-zero-noise-extrapolation-for-analog-blocks","title":"[WIP] Zero-noise extrapolation for analog blocks","text":"<p>Zero-noise extrapolation (ZNE) is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred by extrapolating the measured results to the zero-noise limit. In digital computing, this is typically implemented by \"folding\" the circuit and its dagger to artificially increase the noise through sequences of identities<sup>3</sup>. In the analog ZNE variation, analog blocks are time stretched to again artificially increase noise<sup>3</sup>.</p>"},{"location":"realistic_sims/mitigation/#references","title":"References","text":"<ol> <li> <p>Michael R. Geller and Mingyu Sun, Efficient correction of multiqubit measurement errors, (2020) \u21a9</p> </li> <li> <p>Smolin et al., Maximum Likelihood, Minimum Effort, (2011) \u21a9</p> </li> <li> <p>Mitiq: What's the theory behind ZNE? \u21a9\u21a9</p> </li> </ol>"},{"location":"realistic_sims/noise/","title":"Simulated errors","text":"<p>Running programs on NISQ devices often leads to partially useful results due to the presence of noise. In order to perform realistic simulations, a number of noise models are supported in Qadence and corresponding error mitigation techniques whenever possible.</p>"},{"location":"realistic_sims/noise/#readout-errors","title":"Readout errors","text":"<p>State Preparation and Measurement (SPAM) in the hardware is a major source of noise in the execution of quantum programs. They are typically described using confusion matrices of the form:</p> \\[ T(x|x')=\\delta_{xx'} \\] <p>Qadence offers to simulate readout errors with the <code>Noise</code> protocol to corrupt the output samples of a simulation, through execution via a <code>QuantumModel</code>:</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, kron, H, Z\nfrom qadence import hamiltonian_factory\nfrom qadence.noise import Noise\n\n# Simple circuit and observable construction.\nblock = kron(H(0), Z(1))\ncircuit = QuantumCircuit(2, block)\nobservable = hamiltonian_factory(circuit.n_qubits, detuning=Z)\n\n# Construct a quantum model.\nmodel = QuantumModel(circuit=circuit, observable=observable)\n\n# Define a noise model to use.\nnoise = Noise(protocol=Noise.READOUT)\n\n# Run noiseless and noisy simulations.\nnoiseless_samples = model.sample(n_shots=100)\nnoisy_samples = model.sample(noise=noise, n_shots=100)\n</code></pre> <pre><code>noiseless = [Counter({'10': 55, '00': 45})]\nnoisy = [Counter({'00': 49, '10': 46, '11': 4, '01': 1})]\n</code></pre> <p>It is possible to pass options to the noise model. In the previous example, a noise matrix is implicitly computed from a uniform distribution. The <code>option</code> dictionary argument accepts the following options:</p> <ul> <li><code>seed</code>: defaulted to <code>None</code>, for reproducibility purposes</li> <li><code>error_probability</code>: defaulted to 0.1, a bit flip probability</li> <li><code>noise_distribution</code>: defaulted to <code>WhiteNoise.UNIFORM</code>, for non-uniform noise distributions</li> <li><code>noise_matrix</code>: defaulted to <code>None</code>, if the noise matrix is known from third-party experiments, i.e. hardware calibration.</li> </ul> <p>Noisy simulations go hand-in-hand with measurement protocols discussed in the previous section, to assess the impact of noise on expectation values. In this case, both measurement and noise protocols have to be defined appropriately. Please note that a noise protocol without a measurement protocol will be ignored for expectation values computations.</p> <pre><code>from qadence.measurements import Measurements\n\n# Define a noise model with options.\noptions = {\"error_probability\": 0.01}\nnoise = Noise(protocol=Noise.READOUT, options=options)\n\n# Define a tomographical measurement protocol with options.\noptions = {\"n_shots\": 10000}\nmeasurement = Measurements(protocol=Measurements.TOMOGRAPHY, options=options)\n\n# Run noiseless and noisy simulations.\nnoiseless_exp = model.expectation(measurement=measurement)\nnoisy_exp = model.expectation(measurement=measurement, noise=noise)\n</code></pre> <pre><code>noiseless = tensor([[0.7950]], grad_fn=&lt;TransposeBackward0&gt;)\nnoisy = tensor([[0.9718]], grad_fn=&lt;TransposeBackward0&gt;)\n</code></pre>"},{"location":"tutorials/backends/","title":"Backends","text":"<p>Backends allow execution of Qadence abstract quantum circuits. They could be chosen from a variety of simulators, emulators and hardware and can enable circuit differentiability. The primary way to interact and configure a backend is via the high-level API <code>QuantumModel</code>.</p> <p>Not all backends are equivalent</p> <p>Not all backends support the same set of operations, especially while executing analog blocks. Qadence will throw descriptive errors in such cases.</p>"},{"location":"tutorials/backends/#execution-backends","title":"Execution backends","text":"<p>PyQTorch: An efficient, large-scale simulator designed for quantum machine learning, seamlessly integrated with the popular PyTorch deep learning framework for automatic differentiability. It also offers analog computing for time-independent pulses. See <code>PyQTorchBackend</code>.</p> <p>Pulser: A Python library for pulse-level/analog control of neutral atom devices. Execution via QuTiP. See <code>PulserBackend</code>.</p> <p>Braket: A Python SDK for interacting with quantum devices on Amazon Braket. Currently, only the devices with the digital interface of Amazon Braket are supported and execution is performed using the local simulator. Execution on remote simulators and quantum processing units will be available soon. See <code>BraketBackend</code></p> <p>More: Proprietary Qadence extensions provide more high-performance backends based on tensor networks or differentiation engines. For more enquiries, please contact: <code>info@pasqal.com</code>.</p>"},{"location":"tutorials/backends/#differentiation-backend","title":"Differentiation backend","text":"<p>The <code>DifferentiableBackend</code> class enables different differentiation modes for the given backend. This can be chosen from two types:</p> <ul> <li>Automatic differentiation (AD): available for PyTorch based backends (PyQTorch).</li> <li>Parameter Shift Rules (PSR): available for all backends. See this section for more information on differentiability and PSR.</li> </ul> <p>In practice, only a <code>diff_mode</code> should be provided in the <code>QuantumModel</code>. Please note that <code>diff_mode</code> defaults to <code>None</code>:</p> <pre><code>import sympy\nimport torch\nfrom qadence import Parameter, RX, RZ, Z, CNOT, QuantumCircuit, QuantumModel, chain, BackendName, DiffMode\n\nx = Parameter(\"x\", trainable=False)\ny = Parameter(\"y\", trainable=False)\nfm = chain(\n    RX(0, 3 * x),\n    RX(0, x),\n    RZ(1, sympy.exp(y)),\n    RX(0, 3.14),\n    RZ(1, \"theta\")\n)\n\nansatz = CNOT(0, 1)\nblock = chain(fm, ansatz)\n\ncircuit = QuantumCircuit(2, block)\n\nobservable = Z(0)\n\n# DiffMode.GPSR is available for any backend.\n# DiffMode.AD is only available for natively differentiable backends.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH, diff_mode=DiffMode.GPSR)\n\n# Get some values for the feature parameters.\nvalues = {\"x\": (x := torch.tensor([0.5], requires_grad=True)), \"y\": torch.tensor([0.1])}\n\n# Compute expectation.\nexp = model.expectation(values)\n\n# Differentiate the expectation wrt x.\ndexp_dx = torch.autograd.grad(exp, x, torch.ones_like(exp))\n</code></pre> <pre><code>dexp_dx = (tensor([3.6398]),)\n</code></pre>"},{"location":"tutorials/backends/#low-level-backend_factory-interface","title":"Low-level <code>backend_factory</code> interface","text":"<p>Every backend in Qadence inherits from the abstract <code>Backend</code> class: <code>Backend</code> and implement the following methods:</p> <ul> <li><code>run</code>: propagate the initial state according to the quantum circuit and return the final wavefunction object.</li> <li><code>sample</code>: sample from a circuit.</li> <li><code>expectation</code>: computes the expectation of a circuit given an observable.</li> <li><code>convert</code>: convert the abstract <code>QuantumCircuit</code> object to its backend-native representation including a backend specific parameter embedding function.</li> </ul> <p>Backends are purely functional objects which take as input the values for the circuit parameters and return the desired output from a call to a method. In order to use a backend directly, embedded parameters must be supplied as they are returned by the backend specific embedding function.</p> <p>Here is a simple demonstration of the use of the Braket backend to execute a circuit in non-differentiable mode:</p> <pre><code>from qadence import QuantumCircuit, FeatureParameter, RX, RZ, CNOT, hea, chain\n\n# Construct a feature map.\nx = FeatureParameter(\"x\")\nz = FeatureParameter(\"y\")\nfm = chain(RX(0, 3 * x), RZ(1, z), CNOT(0, 1))\n\n# Construct a circuit with an hardware-efficient ansatz.\ncircuit = QuantumCircuit(3, fm, hea(3,1))\n</code></pre> <p>The abstract <code>QuantumCircuit</code> can now be converted to its native representation via the Braket backend.</p> <pre><code>from qadence import backend_factory\n\n# Use only Braket in non-differentiable mode:\nbackend = backend_factory(\"braket\")\n\n# The `Converted` object\n# (contains a `ConvertedCircuit` with the original and native representation)\nconv = backend.convert(circuit)\n</code></pre> <pre><code>conv.circuit.original = ChainBlock(0,1,2)\n\u251c\u2500\u2500 ChainBlock(0,1)\n\u2502   \u251c\u2500\u2500 RX(0) [params: ['3*x']]\n\u2502   \u251c\u2500\u2500 RZ(1) [params: ['y']]\n\u2502   \u2514\u2500\u2500 CNOT(0, 1)\n\u2514\u2500\u2500 ChainBlock(0,1,2) [tag: HEA]\n    \u251c\u2500\u2500 ChainBlock(0,1,2)\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RX(0) [params: ['theta_0']]\n    \u2502   \u2502   \u251c\u2500\u2500 RX(1) [params: ['theta_1']]\n    \u2502   \u2502   \u2514\u2500\u2500 RX(2) [params: ['theta_2']]\n    \u2502   \u251c\u2500\u2500 KronBlock(0,1,2)\n    \u2502   \u2502   \u251c\u2500\u2500 RY(0) [params: ['theta_3']]\n    \u2502   \u2502   \u251c\u2500\u2500 RY(1) [params: ['theta_4']]\n    \u2502   \u2502   \u2514\u2500\u2500 RY(2) [params: ['theta_5']]\n    \u2502   \u2514\u2500\u2500 KronBlock(0,1,2)\n    \u2502       \u251c\u2500\u2500 RX(0) [params: ['theta_6']]\n    \u2502       \u251c\u2500\u2500 RX(1) [params: ['theta_7']]\n    \u2502       \u2514\u2500\u2500 RX(2) [params: ['theta_8']]\n    \u2514\u2500\u2500 ChainBlock(0,1,2)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u2514\u2500\u2500 CNOT(0, 1)\n        \u2514\u2500\u2500 KronBlock(1,2)\n            \u2514\u2500\u2500 CNOT(1, 2)\nconv.circuit.native = Circuit('instructions': [Instruction('operator': Rx('angle': 4ff484a4-7ccf-461e-9de7-613c20609805, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rz('angle': b14f28ee-596d-4232-be95-e2981a5290a7, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 2a2b6c38-d728-4a14-a381-a80d64ea94aa, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 0e9f201e-ffbd-4008-9a05-50b80d08a14c, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 8f17358b-f7b8-4bc6-a7a1-76ade7738053, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': f23cb179-53e6-48af-adfa-75ffa0a3a4c1, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': ef1beba1-930d-4173-8939-a005a8716b0b, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Ry('angle': 9b6f62c3-933d-4a27-83c6-7f434d14c51a, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 37470e6d-5618-4d84-a75b-5984cb4399ed, 'qubit_count': 1), 'target': QubitSet([Qubit(0)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 1d948c43-abfb-440d-943b-92f896c2d62b, 'qubit_count': 1), 'target': QubitSet([Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': Rx('angle': 62f9feed-01e9-4f3e-82f0-6d877f960ef7, 'qubit_count': 1), 'target': QubitSet([Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(0), Qubit(1)]), 'control': QubitSet([]), 'control_state': (), 'power': 1), Instruction('operator': CNot('qubit_count': 2), 'target': QubitSet([Qubit(1), Qubit(2)]), 'control': QubitSet([]), 'control_state': (), 'power': 1)])\n</code></pre> <p>Additionally, <code>Converted</code> contains all fixed and variational parameters, as well as an embedding function which accepts feature parameters to construct a dictionary of circuit native parameters. These are needed as each backend uses a different representation of the circuit parameters:</p> <pre><code>import torch\n\n# Contains fixed parameters and variational (from the HEA)\nconv.params\n\ninputs = {\"x\": torch.tensor([1., 1.]), \"y\":torch.tensor([2., 2.])}\n\n# get all circuit parameters (including feature params)\nembedded = conv.embedding_fn(conv.params, inputs)\n</code></pre> <pre><code>conv.params = {\n  theta_6: tensor([0.6515], requires_grad=True)\n  theta_2: tensor([0.0253], requires_grad=True)\n  theta_0: tensor([0.4202], requires_grad=True)\n  theta_8: tensor([0.4130], requires_grad=True)\n  theta_3: tensor([0.1998], requires_grad=True)\n  theta_7: tensor([0.0871], requires_grad=True)\n  theta_1: tensor([0.1037], requires_grad=True)\n  theta_5: tensor([0.6525], requires_grad=True)\n  theta_4: tensor([0.0048], requires_grad=True)\n}\nembedded = {\n  4ff484a4-7ccf-461e-9de7-613c20609805: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  b14f28ee-596d-4232-be95-e2981a5290a7: tensor([2., 2.])\n  2a2b6c38-d728-4a14-a381-a80d64ea94aa: tensor([0.4202], grad_fn=&lt;ViewBackward0&gt;)\n  0e9f201e-ffbd-4008-9a05-50b80d08a14c: tensor([0.1037], grad_fn=&lt;ViewBackward0&gt;)\n  8f17358b-f7b8-4bc6-a7a1-76ade7738053: tensor([0.0253], grad_fn=&lt;ViewBackward0&gt;)\n  f23cb179-53e6-48af-adfa-75ffa0a3a4c1: tensor([0.1998], grad_fn=&lt;ViewBackward0&gt;)\n  ef1beba1-930d-4173-8939-a005a8716b0b: tensor([0.0048], grad_fn=&lt;ViewBackward0&gt;)\n  9b6f62c3-933d-4a27-83c6-7f434d14c51a: tensor([0.6525], grad_fn=&lt;ViewBackward0&gt;)\n  37470e6d-5618-4d84-a75b-5984cb4399ed: tensor([0.6515], grad_fn=&lt;ViewBackward0&gt;)\n  1d948c43-abfb-440d-943b-92f896c2d62b: tensor([0.0871], grad_fn=&lt;ViewBackward0&gt;)\n  62f9feed-01e9-4f3e-82f0-6d877f960ef7: tensor([0.4130], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>Note that above the parameters keys have changed as they now address the keys on the Braket device. A more readable embedding is provided by the PyQTorch backend:</p> <pre><code>from qadence import BackendName, DiffMode\npyq_backend = backend_factory(backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\n# the `Converted` object\n# (contains a `ConvertedCircuit` wiht the original and native representation)\npyq_conv = pyq_backend.convert(circuit)\nembedded = pyq_conv.embedding_fn(pyq_conv.params, inputs)\n</code></pre> <pre><code>embedded = {\n  theta_6: tensor([0.6515], grad_fn=&lt;ViewBackward0&gt;)\n  y: tensor([2., 2.])\n  3*x: tensor([3., 3.], grad_fn=&lt;ViewBackward0&gt;)\n  theta_2: tensor([0.0253], grad_fn=&lt;ViewBackward0&gt;)\n  theta_0: tensor([0.4202], grad_fn=&lt;ViewBackward0&gt;)\n  theta_8: tensor([0.4130], grad_fn=&lt;ViewBackward0&gt;)\n  theta_3: tensor([0.1998], grad_fn=&lt;ViewBackward0&gt;)\n  theta_7: tensor([0.0871], grad_fn=&lt;ViewBackward0&gt;)\n  theta_1: tensor([0.1037], grad_fn=&lt;ViewBackward0&gt;)\n  theta_5: tensor([0.6525], grad_fn=&lt;ViewBackward0&gt;)\n  theta_4: tensor([0.0048], grad_fn=&lt;ViewBackward0&gt;)\n}\n</code></pre> <p>With the embedded parameters, <code>QuantumModel</code> methods are accessible:</p> <pre><code>embedded = conv.embedding_fn(conv.params, inputs)\nsamples = backend.run(conv.circuit, embedded)\nprint(f\"{samples = }\")\n</code></pre> <pre><code>samples = tensor([[ 0.0700-3.6374e-02j,  0.0175-2.6802e-02j,  0.0365+1.8930e-01j,\n         -0.1506+4.5069e-01j, -0.6863-3.8708e-01j, -0.3197-1.3397e-04j,\n         -0.0128+2.8051e-02j, -0.0615+4.4707e-02j],\n        [ 0.0700-3.6374e-02j,  0.0175-2.6802e-02j,  0.0365+1.8930e-01j,\n         -0.1506+4.5069e-01j, -0.6863-3.8708e-01j, -0.3197-1.3397e-04j,\n         -0.0128+2.8051e-02j, -0.0615+4.4707e-02j]])\n</code></pre>"},{"location":"tutorials/backends/#lower-level-the-backend-representation","title":"Lower-level: the <code>Backend</code> representation","text":"<p>If there is a requirement to work with a specific backend, it is possible to access directly the native circuit. For example, Braket noise features can be imported which are not exposed directly by Qadence.</p> <pre><code>from braket.circuits import Noise\n\n# Get the native Braket circuit with the given parameters\ninputs = {\"x\": torch.rand(1), \"y\":torch.rand(1)}\nembedded = conv.embedding_fn(conv.params, inputs)\nnative = backend.assign_parameters(conv.circuit, embedded)\n\n# Define a noise channel\nnoise = Noise.Depolarizing(probability=0.1)\n\n# Add noise to every gate in the circuit\nnative.apply_gate_noise(noise)\n</code></pre> <p>In order to run this noisy circuit, the density matrix simulator is needed in Braket:</p> <p><pre><code>from braket.devices import LocalSimulator\n\ndevice = LocalSimulator(\"braket_dm\")\nresult = device.run(native, shots=1000).result().measurement_counts\nprint(result)\n</code></pre> <pre><code>Counter({'000': 247, '111': 165, '011': 147, '100': 139, '001': 105, '110': 72, '010': 66, '101': 59})\n</code></pre> <pre><code>print(conv.circuit.native.diagram())\n</code></pre> <pre><code>T  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nq0 : -Rx(4ff484a4-7ccf-461e-9de7-613c20609805)-C----------------------------------------Rx(2a2b6c38-d728-4a14-a381-a80d64ea94aa)-Ry(f23cb179-53e6-48af-adfa-75ffa0a3a4c1)-Rx(37470e6d-5618-4d84-a75b-5984cb4399ed)-C---\n                                               |                                                                                                                                                                   |   \nq1 : -Rz(b14f28ee-596d-4232-be95-e2981a5290a7)-X----------------------------------------Rx(0e9f201e-ffbd-4008-9a05-50b80d08a14c)-Ry(ef1beba1-930d-4173-8939-a005a8716b0b)-Rx(1d948c43-abfb-440d-943b-92f896c2d62b)-X-C-\n                                                                                                                                                                                                                     | \nq2 : -Rx(8f17358b-f7b8-4bc6-a7a1-76ade7738053)-Ry(9b6f62c3-933d-4a27-83c6-7f434d14c51a)-Rx(62f9feed-01e9-4f3e-82f0-6d877f960ef7)-------------------------------------------------------------------------------------X-\n\nT  : |                   0                    |                   1                    |                   2                    |                   3                    |                   4                    |5|6|\n\nUnassigned parameters: [0e9f201e-ffbd-4008-9a05-50b80d08a14c, 1d948c43-abfb-440d-943b-92f896c2d62b, 2a2b6c38-d728-4a14-a381-a80d64ea94aa, 37470e6d-5618-4d84-a75b-5984cb4399ed, 4ff484a4-7ccf-461e-9de7-613c20609805, 62f9feed-01e9-4f3e-82f0-6d877f960ef7, 8f17358b-f7b8-4bc6-a7a1-76ade7738053, 9b6f62c3-933d-4a27-83c6-7f434d14c51a, b14f28ee-596d-4232-be95-e2981a5290a7, ef1beba1-930d-4173-8939-a005a8716b0b, f23cb179-53e6-48af-adfa-75ffa0a3a4c1].\n</code></pre> <pre><code>print(native.diagram())\n</code></pre> <pre><code>T  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n\nq0 : -Rx(0.94)-DEPO(0.1)-C--------DEPO(0.1)-Rx(0.42)-DEPO(0.1)-Ry(0.20)-DEPO(0.1)-Rx(0.65)-DEPO(0.1)-C-DEPO(0.1)-------------\n                         |                                                                           |                       \nq1 : -Rz(0.08)-DEPO(0.1)-X--------DEPO(0.1)-Rx(0.10)-DEPO(0.1)-Ry(0.00)-DEPO(0.1)-Rx(0.09)-DEPO(0.1)-X-DEPO(0.1)-C-DEPO(0.1)-\n                                                                                                                 |           \nq2 : -Rx(0.03)-DEPO(0.1)-Ry(0.65)-DEPO(0.1)-Rx(0.41)-DEPO(0.1)---------------------------------------------------X-DEPO(0.1)-\n\nT  : |        0         |        1         |        2         |        3         |        4         |     5     |     6     |\n</code></pre> </p>"},{"location":"tutorials/getting_started/","title":"Getting started","text":"<p>Quantum programs in Qadence are constructed via a block-system, with an emphasis on composability of primitive blocks to obtain larger, composite blocks. This functional approach is different from other frameworks which follow a more object-oriented way to construct circuits and express programs.</p> How to visualize blocks <p>There are two ways to display blocks in a Python interpreter: either as a tree in ASCII format using <code>print</code>:</p> <p><pre><code>from qadence import X, Y, kron\n\nkron_block = kron(X(0), Y(1))\nprint(kron_block)\n</code></pre> <pre><code>KronBlock(0,1)\n\u251c\u2500\u2500 X(0)\n\u2514\u2500\u2500 Y(1)\n</code></pre> </p> <p>Or using the visualization package:</p> <p><pre><code>from qadence import X, Y, kron\nfrom qadence.draw import display\n\nkron_block = kron(X(0), Y(1))\n# display(kron_block)  # un-comment this line\n</code></pre> %3 a8dbf12fb833466eb6e0a6deedcafc2e 0 449962ec1a5e43cfa415d208d02ee506 X a8dbf12fb833466eb6e0a6deedcafc2e--449962ec1a5e43cfa415d208d02ee506 02afda36a6424262bf9b7f61bd501da5 1 13dd76bd16a046ad9b83f1bf5ec76c1f 449962ec1a5e43cfa415d208d02ee506--13dd76bd16a046ad9b83f1bf5ec76c1f cc9511806e544bb8a06c1f488e65a8fe a2a030487e1449fa879e9598b27186ce Y 02afda36a6424262bf9b7f61bd501da5--a2a030487e1449fa879e9598b27186ce a2a030487e1449fa879e9598b27186ce--cc9511806e544bb8a06c1f488e65a8fe </p>"},{"location":"tutorials/getting_started/#primitive-blocks","title":"Primitive blocks","text":"<p>A <code>PrimitiveBlock</code> represents a digital or an analog time-evolution quantum operation applied to a qubit support. Programs can always be decomposed down into a sequence of <code>PrimitiveBlock</code> elements.</p> <p>Two canonical examples of digital primitive blocks are the parametrized <code>RX</code> and the <code>CNOT</code> gates:</p> <pre><code>from qadence import RX\n\n# A rotation gate on qubit 0 with a fixed numerical parameter.\nrx_gate = RX(0, 0.5)\n</code></pre> %3 1f729016a12e49d0a1f8b7e5b4fcb443 0 821feaa4b1004a4b8c03270873cd4453 RX(0.5) 1f729016a12e49d0a1f8b7e5b4fcb443--821feaa4b1004a4b8c03270873cd4453 819383e6eb2d41439c986569eae90ad1 821feaa4b1004a4b8c03270873cd4453--819383e6eb2d41439c986569eae90ad1 <pre><code>from qadence import CNOT\n\n# A CNOT gate with control on qubit 0 and target on qubit 1.\ncnot_gate = CNOT(0, 1)\n</code></pre> %3 71eddd39ade748a5a216e5ec67324f85 0 40fca2664a754b32b7901bd396640ce5 71eddd39ade748a5a216e5ec67324f85--40fca2664a754b32b7901bd396640ce5 9410954774c3461597fb8972a121e4b0 1 34411ab375964ab19f873c783596f178 40fca2664a754b32b7901bd396640ce5--34411ab375964ab19f873c783596f178 5e2e8bd0114044cc92b2f78b4ddd693d 5bb42f38cfb64b829816b14a1e1d2760 X 9410954774c3461597fb8972a121e4b0--5bb42f38cfb64b829816b14a1e1d2760 5bb42f38cfb64b829816b14a1e1d2760--40fca2664a754b32b7901bd396640ce5 5bb42f38cfb64b829816b14a1e1d2760--5e2e8bd0114044cc92b2f78b4ddd693d <p>A list of all instances of primitive blocks (also referred to as operations) can be found here.</p>"},{"location":"tutorials/getting_started/#composite-blocks","title":"Composite Blocks","text":"<p>Programs can be expressed by composing blocks to result in a larger <code>CompositeBlock</code> using three fundamental operations: chain, kron, and add.</p> <ul> <li>chain applies a set of blocks in sequence on the same or overlapping qubit supports and results in a <code>ChainBlock</code> type. It is akin to applying a matrix product of the sub-blocks with the <code>*</code> operator.</li> </ul> <p><pre><code>from qadence import X, chain\n\n# Chaining on the same qubit using a call to the function.\nchain_x = chain(X(0), X(0))\n</code></pre> %3 86f275b4122044a39c2f7081c5879c42 0 44d5c8dff0154929ae2deb9fb32d30fb X 86f275b4122044a39c2f7081c5879c42--44d5c8dff0154929ae2deb9fb32d30fb 0593c383e5a245d986ae5f84c05bf4ea X 44d5c8dff0154929ae2deb9fb32d30fb--0593c383e5a245d986ae5f84c05bf4ea 7eff0286f97449abb6d6698eadc09243 0593c383e5a245d986ae5f84c05bf4ea--7eff0286f97449abb6d6698eadc09243 <pre><code># Chaining on different qubits using the operator overload.\n# Identical to the kron operation.\nchain_xx = X(0) * X(1)\n</code></pre> %3 bdac6dd46fb14efbb9ebc3dd9121adaa 0 a5be5cdfb5df4d0cb064b26e2d3ec4d3 X bdac6dd46fb14efbb9ebc3dd9121adaa--a5be5cdfb5df4d0cb064b26e2d3ec4d3 88451d995c174916a5531f4d3fe68b3f 1 3b3af9cdf44e4c0c92f4a9b682fcfd9b a5be5cdfb5df4d0cb064b26e2d3ec4d3--3b3af9cdf44e4c0c92f4a9b682fcfd9b 11adad48135b480ca8939cc65c7997b0 3b3af9cdf44e4c0c92f4a9b682fcfd9b--11adad48135b480ca8939cc65c7997b0 00e4b3a2f6ee4ecb8158122f8413fa71 21aa5a361cc04cf08f8f774776a4197c 88451d995c174916a5531f4d3fe68b3f--21aa5a361cc04cf08f8f774776a4197c 6f2376e52b6d4112bdef73f19c46400c X 21aa5a361cc04cf08f8f774776a4197c--6f2376e52b6d4112bdef73f19c46400c 6f2376e52b6d4112bdef73f19c46400c--00e4b3a2f6ee4ecb8158122f8413fa71 </p> <ul> <li>kron applies a set of blocks in parallel (simultaneously) on disjoint qubit support and results in a <code>KronBlock</code> type. This is akin to applying a tensor product of the sub-blocks with the <code>@</code> operator.</li> </ul> <pre><code>from qadence import X, kron\n\nkron_xx = kron(X(0), X(1))  # Equivalent to X(0) @ X(1)\n</code></pre> %3 1d42a0df3ea947fa95019c7ed46a2234 0 e9e658a3832644f7afb33dccc944331d X 1d42a0df3ea947fa95019c7ed46a2234--e9e658a3832644f7afb33dccc944331d 88a392812f1c4f24b2ca339465c6acc8 1 8a4bbfb4ca684bf090c429d21c37e070 e9e658a3832644f7afb33dccc944331d--8a4bbfb4ca684bf090c429d21c37e070 c00e2da450db44628b5c64ed518fbdd4 49f8544fd80d467e959e6c3ab2c71265 X 88a392812f1c4f24b2ca339465c6acc8--49f8544fd80d467e959e6c3ab2c71265 49f8544fd80d467e959e6c3ab2c71265--c00e2da450db44628b5c64ed518fbdd4 <p>For the digital case, it should be noted that <code>kron</code> and <code>chain</code> are semantically equivalent up to the diagrammatic representation as <code>chain</code> implicitly fills blank wires with identities. However, Qadence also supports analog blocks, for which composing sequentially or in parallel becomes non-equivalent. More about analog blocks can be found in the digital-analog section.</p> <ul> <li>add sums the corresponding matrix of each sub-block and results in a <code>AddBlock</code> type which can be used to construct Pauli operators. Please note that <code>AddBlock</code> can give rise to non-unitary computations that might not be supported by all backends.</li> </ul> Get the matrix of a block <p>It is always possible to retrieve the matrix representation of a block by calling the <code>block.tensor()</code> method. Please note that the returned tensor contains a batch dimension for the purposes of block parametrization.</p> <p><pre><code>\n</code></pre> <pre><code>X(0) * X(0) tensor = tensor([[[1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j]]])\nX(0) @ X(1) tensor = tensor([[[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre> </p> <pre><code>from qadence import X, Z\n\nxz = X(0) + Z(0)\nprint(xz.tensor())\n</code></pre> <pre><code>tensor([[[ 1.+0.j,  1.+0.j],\n         [ 1.+0.j, -1.+0.j]]])\n</code></pre> <p>Finally, it is possible to tag blocks with human-readable names:</p> <pre><code>from qadence import X, Y, CNOT, kron, chain, tag\n\nxy = kron(X(0), Y(1))\ntag(xy, \"subblock\")\n\ncomposite_block = kron(xy, CNOT(3,4))\nfinal_block = chain(composite_block, composite_block)\n</code></pre> %3 cluster_96f2fc774f75464faace0440def9cfae subblock cluster_a1866e57d3354ba6bee8d59b6ba494e7 subblock 0b6ab2b9ae90435086de29783b152dc2 0 621c9236632b49f08645d5c3c5db1a4b X 0b6ab2b9ae90435086de29783b152dc2--621c9236632b49f08645d5c3c5db1a4b 594f54eeaf2c4514a546e1ec376e294f 1 0f7f9dbfcb2e4db4bcf6299e8f799625 X 621c9236632b49f08645d5c3c5db1a4b--0f7f9dbfcb2e4db4bcf6299e8f799625 7771d9b44ba44513b15b4d039364a67f 0f7f9dbfcb2e4db4bcf6299e8f799625--7771d9b44ba44513b15b4d039364a67f c41f8341b5904f9e8dddc74c225f39df 34a7c84e0ffc4085a8ec57eaff04ea0c Y 594f54eeaf2c4514a546e1ec376e294f--34a7c84e0ffc4085a8ec57eaff04ea0c e680ebf4ec3647eeb57342320b4c8308 2 4377861de89c4cfebd2d4ca959a44f5b Y 34a7c84e0ffc4085a8ec57eaff04ea0c--4377861de89c4cfebd2d4ca959a44f5b 4377861de89c4cfebd2d4ca959a44f5b--c41f8341b5904f9e8dddc74c225f39df 111f3827c4304f95ac5297ebf0c92f38 7025191d6e774b10b8f52c8c1761f1a3 e680ebf4ec3647eeb57342320b4c8308--7025191d6e774b10b8f52c8c1761f1a3 d5487813ec6b4d46b3619bb2c6cc4239 3 86f6b2050b2e40e4a1aadcab9a47d094 7025191d6e774b10b8f52c8c1761f1a3--86f6b2050b2e40e4a1aadcab9a47d094 86f6b2050b2e40e4a1aadcab9a47d094--111f3827c4304f95ac5297ebf0c92f38 81823328854947ac8962b8bf955fc341 1a2439bd5bef4594a11328af13dcd86a d5487813ec6b4d46b3619bb2c6cc4239--1a2439bd5bef4594a11328af13dcd86a 3fcfb9d7d0714a00a1c815c087acde35 4 43245b0f6c944c76b82f49832e751b2b 1a2439bd5bef4594a11328af13dcd86a--43245b0f6c944c76b82f49832e751b2b 43245b0f6c944c76b82f49832e751b2b--81823328854947ac8962b8bf955fc341 f31a0760f6b04a1085fed68cfab33a42 afc30fc64dd742cb92b1f3a996a143a1 X 3fcfb9d7d0714a00a1c815c087acde35--afc30fc64dd742cb92b1f3a996a143a1 afc30fc64dd742cb92b1f3a996a143a1--1a2439bd5bef4594a11328af13dcd86a 706505b6ad3c40209225650d1374c215 X afc30fc64dd742cb92b1f3a996a143a1--706505b6ad3c40209225650d1374c215 706505b6ad3c40209225650d1374c215--43245b0f6c944c76b82f49832e751b2b 706505b6ad3c40209225650d1374c215--f31a0760f6b04a1085fed68cfab33a42"},{"location":"tutorials/getting_started/#block-execution","title":"Block execution","text":"<p>To quickly run quantum operations and access wavefunctions, samples or expectation values of observables, one can use the convenience functions <code>run</code>, <code>sample</code> and <code>expectation</code>. The following example shows an execution workflow with the natively available <code>PyQTorch</code> backend:</p> <pre><code>from qadence import chain, add, H, Z, run, sample, expectation\n\nn_qubits = 2\nblock = chain(H(0), H(1))\n\n# Compute the wavefunction.\n# Please check the documentation for other available backends.\nwf = run(block)\n\n# Sample the resulting wavefunction with a given number of shots.\nxs = sample(block, n_shots=1000)\n\n# Compute an expectation based on an observable of Pauli-Z operators.\nobs = add(Z(i) for i in range(n_qubits))\nex = expectation(block, obs)\n</code></pre> <pre><code>wf = tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\nxs = [Counter({'01': 283, '11': 247, '10': 241, '00': 229})]\nex = tensor([[0.]])\n</code></pre> <p>More fine-grained control and better performance is provided via the high-level <code>QuantumModel</code> abstraction.</p>"},{"location":"tutorials/getting_started/#execution-via-quantumcircuit-and-quantummodel","title":"Execution via <code>QuantumCircuit</code> and <code>QuantumModel</code>","text":"<p>Quantum programs in Qadence are constructed in two steps:</p> <ol> <li>Build a <code>QuantumCircuit</code> which ties together a composite block and a register.</li> <li>Define a <code>QuantumModel</code> which differentiates, compiles and executes the circuit.</li> </ol> <p><code>QuantumCircuit</code> is a central class in Qadence and circuits are abstract objects from the actual hardware/simulator that they are expected to be executed on. They require to specify the <code>Register</code> of resources to execute your program on. Previous examples were already using <code>QuantumCircuit</code> with a <code>Register</code> that fits the qubit support for the given block.</p> <pre><code>from qadence import QuantumCircuit, Register, H, chain\n\n# NOTE: Run a block which supports two qubits\n# on a register of three qubits.\nregister = Register(3)\ncircuit = QuantumCircuit(register, chain(H(0), H(1)))\n</code></pre> <pre><code>circuit = ChainBlock(0,1)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 H(1)\n</code></pre> <p>Registers and qubit supports</p> <p>Registers can also be constructed from qubit coordinates to create arbitrary register topologies. See details in the digital-analog section. Qubit supports are subsets of the circuit register tied to blocks.</p> <p><code>QuantumModel</code> is another central class in Qadence. It specifies a Backend for the differentiation, compilation and execution of the abstract circuit.</p> <pre><code>from qadence import BackendName, DiffMode, QuantumCircuit, QuantumModel, Register, H, chain\n\nreg = Register(3)\ncirc = QuantumCircuit(reg, chain(H(0), H(1)))\nmodel = QuantumModel(circ, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\n\nxs = model.sample(n_shots=100)\n</code></pre> <pre><code>xs = [Counter({'000': 29, '010': 29, '110': 27, '100': 15})]\n</code></pre> <p>For more details on <code>QuantumModel</code>, see here.</p>"},{"location":"tutorials/hamiltonians/","title":"Constructing arbitrary Hamiltonians","text":"<p>At the heart of digital-analog quantum computing is the description and execution of analog blocks, which represent a set of interacting qubits under some interaction Hamiltonian. For this purpose, Qadence relies on the <code>hamiltonian_factory</code> function to create arbitrary Hamiltonian blocks to be used as generators of <code>HamEvo</code> or as observables to be measured.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-all-to-all-hamiltonians","title":"Arbitrary all-to-all Hamiltonians","text":"<p>Arbitrary all-to-all interaction Hamiltonians can be easily created by passing the number of qubits in the first argument. The type of <code>interaction</code> can be chosen from the available ones in the <code>Interaction</code> enum type.</p> <pre><code>from qadence import hamiltonian_factory\nfrom qadence import N, X, Y, Z\nfrom qadence import Interaction\n\nn_qubits = 3\n\nhamilt = hamiltonian_factory(n_qubits, interaction=Interaction.ZZ)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Alternatively, a custom interaction function can also be defined. The input should be two integer indices \\(i\\) and \\(j\\) and it should return a composition of pauli terms representing the interaction between qubits \\(i\\) and \\(j\\):</p> <pre><code>def custom_int(i: int, j: int):\n    return X(i) @ X(j) + Y(i) @ Y(j)\n\nn_qubits = 2\n\nhamilt = hamiltonian_factory(n_qubits, interaction=custom_int)\n</code></pre> <pre><code>AddBlock(0,1)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 AddBlock(0,1)\n        \u251c\u2500\u2500 KronBlock(0,1)\n        \u2502   \u251c\u2500\u2500 X(0)\n        \u2502   \u2514\u2500\u2500 X(1)\n        \u2514\u2500\u2500 KronBlock(0,1)\n            \u251c\u2500\u2500 Y(0)\n            \u2514\u2500\u2500 Y(1)\n</code></pre> <p>Single-qubit terms can also be added by passing the respective operator directly to the <code>detuning</code> argument. For example, the total magnetization is commonly used as an observable to be measured:</p> <pre><code>total_mag = hamiltonian_factory(n_qubits, detuning = Z)\n</code></pre> <pre><code>AddBlock(0,1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 Z(1)\n</code></pre> <p>For further customization, arbitrary coefficients can be passed as arrays to the <code>interaction_strength</code> and <code>detuning_strength</code> arguments for the two-qubits and single-qubit terms respectively.</p> <pre><code>n_qubits = 3\n\nhamilt = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=[0.5, 0.2, 0.1],\n    detuning_strength=[0.1, 0.5, -0.3]\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: 0.100] \n\u2502   \u2514\u2500\u2500 Z(0)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: -0.300] \n\u2502   \u2514\u2500\u2500 Z(2)\n\u251c\u2500\u2500 [mul: 0.500] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(1)\n\u251c\u2500\u2500 [mul: 0.200] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 Z(0)\n\u2502       \u2514\u2500\u2500 Z(2)\n\u2514\u2500\u2500 [mul: 0.100] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 Z(1)\n        \u2514\u2500\u2500 Z(2)\n</code></pre> <p>Ordering interaction strengths matters</p> <p>When passing interaction strengths as an array, the ordering must be identical to the one obtained from the <code>edges</code> property of a Qadence <code>Register</code>:</p> <p><pre><code>from qadence import Register\n\nprint(Register(n_qubits).edges)\n</code></pre> <pre><code>[(0, 1), (0, 2), (1, 2)]\n</code></pre> </p> <p>For one more example, let's create a transverse-field Ising model,</p> <pre><code>n_qubits = 4\nn_edges = int(0.5 * n_qubits * (n_qubits - 1))\n\nz_terms = [1.0] * n_qubits\nzz_terms = [2.0] * n_edges\n\nzz_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.ZZ,\n    detuning=Z,\n    interaction_strength=zz_terms,\n    detuning_strength=z_terms\n)\n\nx_terms = [-1.0] * n_qubits\nx_ham = hamiltonian_factory(n_qubits, detuning = X, detuning_strength = x_terms)\n\ntransverse_ising = zz_ham + x_ham\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 AddBlock(0,1,2,3)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(0)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(1)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(0)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(2)\n\u2502   \u251c\u2500\u2500 [mul: 2.00000000000000] \n\u2502   \u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502   \u2502       \u251c\u2500\u2500 Z(1)\n\u2502   \u2502       \u2514\u2500\u2500 Z(3)\n\u2502   \u2514\u2500\u2500 [mul: 2.00000000000000] \n\u2502       \u2514\u2500\u2500 KronBlock(2,3)\n\u2502           \u251c\u2500\u2500 Z(2)\n\u2502           \u2514\u2500\u2500 Z(3)\n\u2514\u2500\u2500 AddBlock(0,1,2,3)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(0)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(1)\n    \u251c\u2500\u2500 [mul: -1.00000000000000] \n    \u2502   \u2514\u2500\u2500 X(2)\n    \u2514\u2500\u2500 [mul: -1.00000000000000] \n        \u2514\u2500\u2500 X(3)\n</code></pre> <p>Random interaction coefficients</p> <p>Random interaction coefficients can be chosen between -1 and 1 by simply passing <code>random_strength = True</code> instead of <code>detuning_strength</code> and <code>interaction_strength</code>.</p>"},{"location":"tutorials/hamiltonians/#arbitrary-hamiltonian-topologies","title":"Arbitrary Hamiltonian topologies","text":"<p>Arbitrary interaction topologies can be created using the Qadence <code>Register</code>. Simply pass the register with the desired topology as the first argument to the <code>hamiltonian_factory</code>:</p> <pre><code>from qadence import Register\n\nreg = Register.square(qubits_side=2)\n\nsquare_hamilt = hamiltonian_factory(reg, interaction=Interaction.NN)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 1.00000000000000] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: 1.00000000000000] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/hamiltonians/#adding-variational-parameters","title":"Adding variational parameters","text":"<p>Finally, fully parameterized Hamiltonians can be created by passing a string to the strength arguments, and used to prefix the name of the variational parameters.</p> <pre><code>n_qubits = 3\n\nnn_ham = hamiltonian_factory(\n    n_qubits,\n    interaction=Interaction.NN,\n    detuning=N,\n    interaction_strength=\"c\",\n    detuning_strength=\"d\"\n)\n</code></pre> <pre><code>AddBlock(0,1,2)\n\u251c\u2500\u2500 [mul: d_0] \n\u2502   \u2514\u2500\u2500 N(0)\n\u251c\u2500\u2500 [mul: d_1] \n\u2502   \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: d_2] \n\u2502   \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: c_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: c_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u2514\u2500\u2500 [mul: c_12] \n    \u2514\u2500\u2500 KronBlock(1,2)\n        \u251c\u2500\u2500 N(1)\n        \u2514\u2500\u2500 N(2)\n</code></pre> <p>Alternatively, fully customizable sympy functions can be passed in an array using the Qadence parameters. Furthermore, the <code>use_all_node_pairs = True</code> option can be passed so that interactions are created for every single node pair in the register, irrespectively of the topology of the edges. This is useful for creating Hamiltonians that depend on qubit distance.</p> <pre><code>from qadence import VariationalParameter, Register\n\n# Square register of 4 qubits with a dimensionless distance of 8.0\nreg = Register.square(2, spacing = 8.0)\n\n# Get the distances between all pairs of qubits\ndistance_dict = reg.distances\n\n# Create interaction strength with variational parameter and 1/r term\nstrength_list = []\nfor node_pair in reg.all_node_pairs:\n    param = VariationalParameter(\"x\" + f\"_{node_pair[0]}{node_pair[1]}\")\n    dist_factor = reg.distances[node_pair]\n    strength_list.append(param / dist_factor)\n\nnn_ham = hamiltonian_factory(\n    reg,\n    interaction=Interaction.NN,\n    interaction_strength=strength_list,\n    use_all_node_pairs=True,\n)\n</code></pre> <pre><code>AddBlock(0,1,2,3)\n\u251c\u2500\u2500 [mul: 0.125*x_01] \n\u2502   \u2514\u2500\u2500 KronBlock(0,1)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(1)\n\u251c\u2500\u2500 [mul: 0.088*x_02] \n\u2502   \u2514\u2500\u2500 KronBlock(0,2)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.125*x_03] \n\u2502   \u2514\u2500\u2500 KronBlock(0,3)\n\u2502       \u251c\u2500\u2500 N(0)\n\u2502       \u2514\u2500\u2500 N(3)\n\u251c\u2500\u2500 [mul: 0.125*x_12] \n\u2502   \u2514\u2500\u2500 KronBlock(1,2)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(2)\n\u251c\u2500\u2500 [mul: 0.088*x_13] \n\u2502   \u2514\u2500\u2500 KronBlock(1,3)\n\u2502       \u251c\u2500\u2500 N(1)\n\u2502       \u2514\u2500\u2500 N(3)\n\u2514\u2500\u2500 [mul: 0.125*x_23] \n    \u2514\u2500\u2500 KronBlock(2,3)\n        \u251c\u2500\u2500 N(2)\n        \u2514\u2500\u2500 N(3)\n</code></pre>"},{"location":"tutorials/overlap/","title":"Wavefunction overlaps","text":"<p>Qadence offers convenience functions for computing the overlap between the wavefunctions generated by two quantum circuits \\(U\\) and \\(W\\) as:</p> \\[ S = |\\langle \\psi_U | \\psi_W \\rangle|^2 \\quad \\textrm{where} \\quad \\psi_U = U|\\psi_0\\rangle \\] <p>Here is an example on how to compute the overlap between two very simple parametric circuits consisting of a single <code>RX</code> rotation on different qubits. The overlap is expected to be non-zero only when the rotation angle is different from \\(\\pi \\; \\textrm{mod}\\; 2\\pi\\) for both rotations:</p> <pre><code>import numpy as np\nfrom torch import tensor\nfrom qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea, PI\n\n\n# Create two quantum circuits\n# with a single qubit rotation on two random qubits\nn_qubits = 4\nqubits = np.random.choice(n_qubits, n_qubits, replace=False)\n\nphi = FeatureParameter(\"phi\")\ncircuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))\n\npsi = FeatureParameter(\"psi\")\ncircuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))\n\n# Values for the feature parameters\nvalues_bra = {\"phi\": tensor([PI / 2, PI])}\nvalues_ket = {\"psi\": tensor([PI / 2, PI])}\n\n# Calculate overlap by assigning values to the given bra and ket circuits\novrlp = Overlap(circuit_bra, circuit_ket)\novrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)\n</code></pre> <pre><code>Overlap with exact method:\n tensor([[2.5000e-01, 1.8747e-33],\n        [1.8747e-33, 1.4058e-65]])\n</code></pre> <p>The <code>Overlap</code> class above inherits from <code>QuantumModel</code> and is executed through its inherited forward method for the given input parameter values. By default, the overlap is computed exactly by performing the dot product of the wavefunction propagated from bra and ket circuits.</p> <p>However, it is possible to choose a different method from the <code>OverlapMethod</code> enumeration to be passed via the <code>overlap_method</code> argument in the <code>Overlap</code> initializer. Currently, one can choose from:</p> <ul> <li><code>EXACT</code>: exact computation using the wavefunction matrix representation. Does not work with real devices since it assumes access to the complete qubit system wavefunction.</li> <li><code>COMPUTE_UNCOMPUTE</code>: exact or sampling-based computation using bra \\(U\\) and ket \\(W^{\\dagger}\\) unitaries.</li> <li><code>SWAP_TEST</code>: exact or sampling-based computation using the SWAP test method.</li> <li><code>HADAMARD_TEST</code>: exact or sampling-based computation using the Hadamard test method.</li> <li><code>JENSEN_SHANNON</code>: compute the overlap using the Jensen-Shannon divergence of the two probability distributions obtained by sampling the propagated circuits. This will yield a different result than the other methods.</li> </ul> <p>All methods (except for the <code>EXACT</code> method) take an optional <code>n_shots</code> argument which can be used to perform shot-based calculations.</p> <p>Warning</p> <p>If you select a finite number of shots, the overlap is not differentiable. Therefore, it cannot be used as output of a quantum model if gradients are required.</p> <pre><code># Calculate overlap with SWAP test\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket)\n\n# Calculate overlap with SWAP test\n# using a finite number of shots\novrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)\novrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)\n</code></pre> <pre><code>Overlap with SWAP test:\n tensor([[ 2.5000e-01, -3.3307e-16],\n        [-3.3307e-16, -4.4409e-16]])\nOverlap with SWAP test with finite number of shots:\n tensor([[0.2618, 0.0050],\n        [0.0076, 0.0072]])\n</code></pre>"},{"location":"tutorials/parameters/","title":"Parametric programs","text":"<p>Qadence base <code>Parameter</code> type is a subtype of <code>sympy.Symbol</code>. There are three kinds of parameter subtypes used:</p> <ul> <li>Fixed Parameter: A constant with a fixed, non-trainable value (e.g. \\(\\dfrac{\\pi}{2}\\)).</li> <li>Variational Parameter: A trainable parameter which can be optimized.</li> <li>Feature Parameter: A non-trainable parameter which can be used to encode classical data into a quantum state.</li> </ul>"},{"location":"tutorials/parameters/#fixed-parameters","title":"Fixed Parameters","text":"<p>To pass a fixed parameter to a gate (or any parametrizable block), one can simply use either Python numeric types or wrapped in a <code>torch.Tensor</code>.</p> <pre><code>from qadence import RX, run, PI\n\n# Let's use a torch type.\nblock = RX(0, PI)\nwf = run(block)\n\n# Let's pass a simple float.\nblock = RX(0, 1.)\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[6.1232e-17+0.j, 0.0000e+00-1.j]])\nwf = tensor([[0.8776+0.0000j, 0.0000-0.4794j]])\n</code></pre>"},{"location":"tutorials/parameters/#variational-parameters","title":"Variational Parameters","text":"<p>To parametrize a block by an angle <code>theta</code>, either a Python <code>string</code> or an instance of  <code>VariationalParameter</code> can be passed instead of a numeric type to the gate constructor:</p> <pre><code>from qadence import RX, run, VariationalParameter\n\nblock = RX(0, \"theta\")\n# This is equivalent to:\nblock = RX(0, VariationalParameter(\"theta\"))\n\nwf = run(block)\n</code></pre> <pre><code>wf = tensor([[0.9882+0.0000j, 0.0000-0.1531j]])\n</code></pre> <p>In the first case in the above example, <code>theta</code> is automatically inferred as a <code>VariationalParameter</code> (i.e. trainable). It is initialized to a random value for the purposes of execution. In the context of a <code>QuantumModel</code>, there is no need to pass a value for <code>theta</code> to the <code>run</code> method since it is stored within the underlying model parameter dictionary.</p>"},{"location":"tutorials/parameters/#feature-parameters","title":"Feature Parameters","text":"<p><code>FeatureParameter</code> types (i.e. inputs), always need to be provided with a value or a batch of values as a dictionary:</p> <pre><code>from torch import tensor\nfrom qadence import RX, run, FeatureParameter\n\nblock = RX(0, FeatureParameter(\"phi\"))\n\nwf = run(block, values={\"phi\": tensor([1., 2.])})\n</code></pre> <pre><code>wf = tensor([[0.8776+0.0000j, 0.0000-0.4794j],\n        [0.5403+0.0000j, 0.0000-0.8415j]])\n</code></pre> <p>Now, <code>run</code> returns a batch of states, one for every provided angle which coincides with the value of the particular <code>FeatureParameter</code>.</p>"},{"location":"tutorials/parameters/#multiparameter-expressions","title":"Multiparameter Expressions","text":"<p>However, an angle can itself be an expression <code>Parameter</code> types of any kind. As such, any sympy expression <code>expr: sympy.Basic</code> consisting of a combination of free symbols (i.e. <code>sympy</code> types) and Qadence <code>Parameter</code> can be passed to a block, including trigonometric functions.</p> <pre><code>from torch import tensor\nfrom qadence import RX, Parameter, run, FeatureParameter\nfrom sympy import sin\n\ntheta, phi = Parameter(\"theta\"), FeatureParameter(\"phi\")\nblock = RX(0, sin(theta+phi))\n\n# Remember, to run the block, only FeatureParameter values have to be provided:\nvalues = {\"phi\": tensor([1.0, 2.0])}\nwf = run(block, values=values)\n</code></pre> <pre><code>wf = tensor([[0.8785+0.0000j, 0.0000-0.4778j],\n        [0.9538+0.0000j, 0.0000-0.3006j]])\n</code></pre>"},{"location":"tutorials/parameters/#parameters-redundancy","title":"Parameters Redundancy","text":"<p>Parameters are uniquely defined by their name and redundancy is allowed in composite blocks to assign the same value to different blocks.</p> <pre><code>import torch\nfrom qadence import RX, RY, run, chain, kron\n\nblock = chain(\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n    kron(RX(0, \"phi\"), RY(1, \"theta\")),\n)\n\nwf = run(block)  # Same random initialization for all instances of phi and theta.\n</code></pre> <pre><code>wf = tensor([[0.5500+0.0000j, 0.5257+0.0000j, 0.0000-0.4691j, 0.0000-0.4484j]])\n</code></pre>"},{"location":"tutorials/parameters/#parametrized-circuits","title":"Parametrized Circuits","text":"<p>Now, let's have a look at the construction of a variational ansatz which composes <code>FeatureParameter</code> and <code>VariationalParameter</code> types:</p> <pre><code>import sympy\nfrom qadence import RX, RY, RZ, CNOT, Z, run, chain, kron, FeatureParameter, VariationalParameter\n\nphi = FeatureParameter(\"phi\")\ntheta = VariationalParameter(\"theta\")\n\nblock = chain(\n    kron(\n        RX(0, phi/theta),\n        RY(1, theta*2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi),\n        RY(1, theta),\n        RZ(2, phi),\n    ),\n    kron(\n        RX(0, phi + theta),\n        RY(1, theta**2),\n        RZ(2, sympy.cos(phi)),\n    ),\n    chain(CNOT(0,1), CNOT(1,2))\n)\nblock.tag = \"Rotations\"\n\nobs = 2*kron(*map(Z, range(3)))\nblock = chain(block, obs)\n</code></pre> %3 cluster_7766e30eb7c94044bc0c2eb2033d7dd4 [* 2] cluster_c1cab03caa174af99d3e0e0c4ca04371 Rotations 1b55bfce698145c680551c79dc317565 0 02ac6e2deb7a4aa89397c66dd5ff94e9 RX(phi/theta) 1b55bfce698145c680551c79dc317565--02ac6e2deb7a4aa89397c66dd5ff94e9 0dc61918f4e747088d31a2114e632135 1 0ec2cc881f4d4b2da5e550e4fa0d1adb RX(phi) 02ac6e2deb7a4aa89397c66dd5ff94e9--0ec2cc881f4d4b2da5e550e4fa0d1adb fdb42da5a14b43ba80b17b87c3a07535 RX(phi) 0ec2cc881f4d4b2da5e550e4fa0d1adb--fdb42da5a14b43ba80b17b87c3a07535 979e5eba5b2b4f179a5ea8f491e82650 RX(phi + theta) fdb42da5a14b43ba80b17b87c3a07535--979e5eba5b2b4f179a5ea8f491e82650 0f2808d8b36945929defa92a7ee7d2cc 979e5eba5b2b4f179a5ea8f491e82650--0f2808d8b36945929defa92a7ee7d2cc a57811606da24cf9a670a14838eab846 0f2808d8b36945929defa92a7ee7d2cc--a57811606da24cf9a670a14838eab846 52eb9e880193414fa9a6d6475b1d3b44 Z a57811606da24cf9a670a14838eab846--52eb9e880193414fa9a6d6475b1d3b44 4b94ecb9858c4bb6ac163ba37ba3b758 52eb9e880193414fa9a6d6475b1d3b44--4b94ecb9858c4bb6ac163ba37ba3b758 479dce178b2f41b29b7416ab8004ab08 1187460ae73b48c4a793565478a6e789 RY(2*theta) 0dc61918f4e747088d31a2114e632135--1187460ae73b48c4a793565478a6e789 ec30d31ae9ab489f887c4d485a5f455d 2 893fad5854374d6aa4464b83ae991904 RY(theta) 1187460ae73b48c4a793565478a6e789--893fad5854374d6aa4464b83ae991904 e2dd7ed112d24015b17c146104f98611 RY(theta) 893fad5854374d6aa4464b83ae991904--e2dd7ed112d24015b17c146104f98611 7a883668ce52401cb6d2270625e86569 RY(theta**2) e2dd7ed112d24015b17c146104f98611--7a883668ce52401cb6d2270625e86569 5e74b2134b0244d599673668408e5577 X 7a883668ce52401cb6d2270625e86569--5e74b2134b0244d599673668408e5577 5e74b2134b0244d599673668408e5577--0f2808d8b36945929defa92a7ee7d2cc 55ae1c4cafa646789a340c31bf9dacac 5e74b2134b0244d599673668408e5577--55ae1c4cafa646789a340c31bf9dacac f4c1ee4864994e1b96a8cce4e81a5716 Z 55ae1c4cafa646789a340c31bf9dacac--f4c1ee4864994e1b96a8cce4e81a5716 f4c1ee4864994e1b96a8cce4e81a5716--479dce178b2f41b29b7416ab8004ab08 17086273f83e4ec28aef398a4ea830e1 f6305faf71a441418161774607a7b1b0 RZ(cos(phi)) ec30d31ae9ab489f887c4d485a5f455d--f6305faf71a441418161774607a7b1b0 a42985d0f0cb4d1d8fbd9aabb39040e7 RZ(phi) f6305faf71a441418161774607a7b1b0--a42985d0f0cb4d1d8fbd9aabb39040e7 a92707afc0374ac4b816de36c22a36f9 RZ(phi) a42985d0f0cb4d1d8fbd9aabb39040e7--a92707afc0374ac4b816de36c22a36f9 ffa28904589f4579aa5fe3f08584766c RZ(cos(phi)) a92707afc0374ac4b816de36c22a36f9--ffa28904589f4579aa5fe3f08584766c 00a34d323e9c4c6fa6d5a0ec824cf606 ffa28904589f4579aa5fe3f08584766c--00a34d323e9c4c6fa6d5a0ec824cf606 5d3826b0488541af94425bf7378b1df9 X 00a34d323e9c4c6fa6d5a0ec824cf606--5d3826b0488541af94425bf7378b1df9 5d3826b0488541af94425bf7378b1df9--55ae1c4cafa646789a340c31bf9dacac 4c3987b3211642e0a396f79a5c048962 Z 5d3826b0488541af94425bf7378b1df9--4c3987b3211642e0a396f79a5c048962 4c3987b3211642e0a396f79a5c048962--17086273f83e4ec28aef398a4ea830e1 <p>Please note the different colors for the parametrization with different types. The default palette assigns light blue for <code>VariationalParameter</code>, light green for <code>FeatureParameter</code> and shaded red for observables.</p>"},{"location":"tutorials/parameters/#parametrized-quantummodels","title":"Parametrized QuantumModels","text":"<p>As a quick reminder: <code>FeatureParameter</code> are used for data input and data encoding into a quantum state. <code>VariationalParameter</code> are trainable parameters in a variational ansatz. When used within a <code>QuantumModel</code>, an abstract quantum circuit is made differentiable with respect to both variational and feature parameters which are uniquely identified by their name.</p> <pre><code>from qadence import FeatureParameter, Parameter, VariationalParameter\n\n# Feature parameters are non-trainable parameters.\n# Their primary use is input data encoding.\nfp = FeatureParameter(\"x\")\nassert fp == Parameter(\"x\", trainable=False)\n\n# Variational parameters are trainable parameters.\n# Their primary use is for optimization.\nvp = VariationalParameter(\"y\")\nassert vp == Parameter(\"y\", trainable=True)\n</code></pre> <p>Let's construct a parametric quantum circuit.</p> <pre><code>from qadence import QuantumCircuit, RX, RY, chain, kron\n\ntheta = VariationalParameter(\"theta\")\nphi = FeatureParameter(\"phi\")\n\nblock = chain(\n    kron(RX(0, theta), RY(1, theta)),\n    kron(RX(0, phi), RY(1, phi)),\n)\n\ncircuit = QuantumCircuit(2, block)\nunique_params = circuit.unique_parameters\n</code></pre> <pre><code>unique_params = [theta, phi]\n</code></pre> <p>In the circuit above, four parameters are defined but only two unique names. Therefore, there will be only one variational parameter to be optimized.</p> <p>The <code>QuantumModel</code> class also provides convenience methods to manipulate parameters.</p> <pre><code>from qadence import QuantumModel, BackendName, DiffMode\n\nmodel = QuantumModel(circuit, backend=BackendName.PYQTORCH, diff_mode=DiffMode.AD)\nnum_vparams = model.num_vparams # get the number of variational parameters\nvparams_values = model.vparams\n</code></pre> <pre><code>num_vparams = 1\nvparams_values = OrderedDict([('theta', tensor([0.2054]))])\n</code></pre> <p>Only provide feature parameter values to the quantum model</p> <p>In order to <code>run</code> the variational circuit only feature parameter values have to be provided. Variational parameters are stored in the model itself. If multiple feature parameters are present, values must be provided in batches of same length.</p> <p><pre><code>import torch\n\nvalues = {\"phi\": torch.rand(3)} # theta does not appear here\nwf = model.run(values)\n</code></pre> <pre><code>wf = tensor([[0.9677+0.0000j, 0.1768+0.0000j, 0.0000-0.1768j, 0.0000-0.0323j],\n        [0.9856+0.0000j, 0.1193+0.0000j, 0.0000-0.1193j, 0.0000-0.0144j],\n        [0.8356+0.0000j, 0.3706+0.0000j, 0.0000-0.3706j, 0.0000-0.1644j]],\n       grad_fn=&lt;TBackward0&gt;)\n</code></pre> </p>"},{"location":"tutorials/parameters/#standard-constructors","title":"Standard constructors","text":"<p>The unique parameter identification is relevant when using built-in Qadence block constructors in the <code>qadence.constructors</code> module such as feature maps and hardware efficient ansatze (HEA).</p> <p><pre><code>from qadence import QuantumCircuit, hea\n\nn_qubits = 4\ndepth = 2\n\nhea1 = hea(n_qubits=n_qubits, depth=depth)\ncircuit = QuantumCircuit(n_qubits, hea1)\nnum_unique_parameters = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with a single HEA: 24\n</code></pre> %3 7b809944850d494c9669aa021b3beeff 0 fc2b9db356e442a8a53b1568d6d3c6c4 RX(theta\u2080) 7b809944850d494c9669aa021b3beeff--fc2b9db356e442a8a53b1568d6d3c6c4 18c2037306624c1cad60dca225c7c66c 1 e7daa625b1054a8eb7852f4f704deb52 RY(theta\u2084) fc2b9db356e442a8a53b1568d6d3c6c4--e7daa625b1054a8eb7852f4f704deb52 91a3ef37c7464628868d6f06a15e27a9 RX(theta\u2088) e7daa625b1054a8eb7852f4f704deb52--91a3ef37c7464628868d6f06a15e27a9 97dd8f303e8d4481827282613bc9c5e8 91a3ef37c7464628868d6f06a15e27a9--97dd8f303e8d4481827282613bc9c5e8 a4da65b94b3049d78687b00c888605f2 97dd8f303e8d4481827282613bc9c5e8--a4da65b94b3049d78687b00c888605f2 cca4fccc8cd54a8d8d08dfd241fbbe58 RX(theta\u2081\u2082) a4da65b94b3049d78687b00c888605f2--cca4fccc8cd54a8d8d08dfd241fbbe58 5565b2e182074ea985fcbcbde150dd25 RY(theta\u2081\u2086) cca4fccc8cd54a8d8d08dfd241fbbe58--5565b2e182074ea985fcbcbde150dd25 c3acf86ca41c46a693b6a25393e67db9 RX(theta\u2082\u2080) 5565b2e182074ea985fcbcbde150dd25--c3acf86ca41c46a693b6a25393e67db9 ee1bab3997224b2995cf2b310dc721ab c3acf86ca41c46a693b6a25393e67db9--ee1bab3997224b2995cf2b310dc721ab cc632271682b4c73b35a2c4d5a6404b5 ee1bab3997224b2995cf2b310dc721ab--cc632271682b4c73b35a2c4d5a6404b5 9c5c9ed77cae46b88d6411429dd2e1ff cc632271682b4c73b35a2c4d5a6404b5--9c5c9ed77cae46b88d6411429dd2e1ff 3ff979de819a480cbc351c45a5b8d9cc 4002cf4c369c48059ac94f4c620e3f58 RX(theta\u2081) 18c2037306624c1cad60dca225c7c66c--4002cf4c369c48059ac94f4c620e3f58 7cc47b1b5a67466b854f1160980c6d24 2 bc87048335554d9e84314d18e387677c RY(theta\u2085) 4002cf4c369c48059ac94f4c620e3f58--bc87048335554d9e84314d18e387677c 2c710212cb144990bf790f99cabe0704 RX(theta\u2089) bc87048335554d9e84314d18e387677c--2c710212cb144990bf790f99cabe0704 29d08d15ef8e43eeb243745c7c486afd X 2c710212cb144990bf790f99cabe0704--29d08d15ef8e43eeb243745c7c486afd 29d08d15ef8e43eeb243745c7c486afd--97dd8f303e8d4481827282613bc9c5e8 fb4a7175b4f64d99b7e3bd77aa43ec9d 29d08d15ef8e43eeb243745c7c486afd--fb4a7175b4f64d99b7e3bd77aa43ec9d 9927d0917ff34d90ba0a23e1d9441570 RX(theta\u2081\u2083) fb4a7175b4f64d99b7e3bd77aa43ec9d--9927d0917ff34d90ba0a23e1d9441570 fc2f116591ef42cf8e9733d88dfd52b0 RY(theta\u2081\u2087) 9927d0917ff34d90ba0a23e1d9441570--fc2f116591ef42cf8e9733d88dfd52b0 613fd059c08744cc9c010833e4a5cfd0 RX(theta\u2082\u2081) fc2f116591ef42cf8e9733d88dfd52b0--613fd059c08744cc9c010833e4a5cfd0 f48f0e173f43480eb00f8a589ec9306f X 613fd059c08744cc9c010833e4a5cfd0--f48f0e173f43480eb00f8a589ec9306f f48f0e173f43480eb00f8a589ec9306f--ee1bab3997224b2995cf2b310dc721ab 3fda0e3b94004cb092fcddd9fe10d676 f48f0e173f43480eb00f8a589ec9306f--3fda0e3b94004cb092fcddd9fe10d676 3fda0e3b94004cb092fcddd9fe10d676--3ff979de819a480cbc351c45a5b8d9cc 68a55a2d7ab1416097b83fe24dfb4602 690e3af4eca348eb9cd2077fe33e19ba RX(theta\u2082) 7cc47b1b5a67466b854f1160980c6d24--690e3af4eca348eb9cd2077fe33e19ba c872aaead3564b87a228373129572600 3 066994e236de496bafac9d996b705cfa RY(theta\u2086) 690e3af4eca348eb9cd2077fe33e19ba--066994e236de496bafac9d996b705cfa 9a6c67bd91db4005ab632a3fd52c0b21 RX(theta\u2081\u2080) 066994e236de496bafac9d996b705cfa--9a6c67bd91db4005ab632a3fd52c0b21 92d3caafb59f4004801fe08d7fe9f535 9a6c67bd91db4005ab632a3fd52c0b21--92d3caafb59f4004801fe08d7fe9f535 415270b2beb54898b4a210a069620649 X 92d3caafb59f4004801fe08d7fe9f535--415270b2beb54898b4a210a069620649 415270b2beb54898b4a210a069620649--fb4a7175b4f64d99b7e3bd77aa43ec9d 246eb9593d1f4e188440267e81d2c34a RX(theta\u2081\u2084) 415270b2beb54898b4a210a069620649--246eb9593d1f4e188440267e81d2c34a b325a657fc134bc6a19cae4ffcdf2a86 RY(theta\u2081\u2088) 246eb9593d1f4e188440267e81d2c34a--b325a657fc134bc6a19cae4ffcdf2a86 803de011d0054d9480890d096031ac64 RX(theta\u2082\u2082) b325a657fc134bc6a19cae4ffcdf2a86--803de011d0054d9480890d096031ac64 d8ec017a6d904e79b4a9c00a9a3fa938 803de011d0054d9480890d096031ac64--d8ec017a6d904e79b4a9c00a9a3fa938 1fc4565a2084435a8da5fd226108f3b8 X d8ec017a6d904e79b4a9c00a9a3fa938--1fc4565a2084435a8da5fd226108f3b8 1fc4565a2084435a8da5fd226108f3b8--3fda0e3b94004cb092fcddd9fe10d676 1fc4565a2084435a8da5fd226108f3b8--68a55a2d7ab1416097b83fe24dfb4602 0f8b9cbb2e804118b17b8df2ba16f9b1 94b69f9000b74e7fbfd2e65719077846 RX(theta\u2083) c872aaead3564b87a228373129572600--94b69f9000b74e7fbfd2e65719077846 5ad4d6c7e27a4f89a1264a6fc4b1fed5 RY(theta\u2087) 94b69f9000b74e7fbfd2e65719077846--5ad4d6c7e27a4f89a1264a6fc4b1fed5 22558d3ba7bd4308afde5aeb9a227273 RX(theta\u2081\u2081) 5ad4d6c7e27a4f89a1264a6fc4b1fed5--22558d3ba7bd4308afde5aeb9a227273 fcad59013cf44e529fddb41ec7da58f4 X 22558d3ba7bd4308afde5aeb9a227273--fcad59013cf44e529fddb41ec7da58f4 fcad59013cf44e529fddb41ec7da58f4--92d3caafb59f4004801fe08d7fe9f535 580b61c9a3bc448985dad8fda6b5d64c fcad59013cf44e529fddb41ec7da58f4--580b61c9a3bc448985dad8fda6b5d64c 266afb3c354a42a68e0e4cb268997642 RX(theta\u2081\u2085) 580b61c9a3bc448985dad8fda6b5d64c--266afb3c354a42a68e0e4cb268997642 b2f148c08e2049b086d2203d43f91a79 RY(theta\u2081\u2089) 266afb3c354a42a68e0e4cb268997642--b2f148c08e2049b086d2203d43f91a79 0fbc467213a4489c9bcc1cda2a5ab74e RX(theta\u2082\u2083) b2f148c08e2049b086d2203d43f91a79--0fbc467213a4489c9bcc1cda2a5ab74e 84605c3537f24d89af175ee1624987ff X 0fbc467213a4489c9bcc1cda2a5ab74e--84605c3537f24d89af175ee1624987ff 84605c3537f24d89af175ee1624987ff--d8ec017a6d904e79b4a9c00a9a3fa938 3582ffb648064e7dbd5af9ac435e2297 84605c3537f24d89af175ee1624987ff--3582ffb648064e7dbd5af9ac435e2297 3582ffb648064e7dbd5af9ac435e2297--0f8b9cbb2e804118b17b8df2ba16f9b1 </p> <p>A new circuit can be created by adding another identical HEA. As expected, the number of unique parameters is the same.</p> <p><pre><code>hea2 = hea(n_qubits=n_qubits, depth=depth)\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nnum_unique_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 24\n</code></pre> %3 cluster_dc0ad7728df643bba06cd5c4855ea819 HEA cluster_be1a2b0603a142c6b4f1175912baf663 HEA 498907a923764baeb83776ac1891b290 0 bc1125bfe42d49f99157482d77cce4f5 RX(theta\u2080) 498907a923764baeb83776ac1891b290--bc1125bfe42d49f99157482d77cce4f5 4cddfa71f0ff41bfb68e950192d9f38e 1 6e3018d0ca6146cb8909f9b1f445d2b0 RY(theta\u2084) bc1125bfe42d49f99157482d77cce4f5--6e3018d0ca6146cb8909f9b1f445d2b0 97ad8af2f110429e89f63ad8ff753d3a RX(theta\u2088) 6e3018d0ca6146cb8909f9b1f445d2b0--97ad8af2f110429e89f63ad8ff753d3a 8b9d11c4a52741d3835ebeae49282e16 97ad8af2f110429e89f63ad8ff753d3a--8b9d11c4a52741d3835ebeae49282e16 520ddfa9c7064e1a8b4949abd3dbc368 8b9d11c4a52741d3835ebeae49282e16--520ddfa9c7064e1a8b4949abd3dbc368 95a3e9f2568347d99d53fc8a03ee3b00 RX(theta\u2081\u2082) 520ddfa9c7064e1a8b4949abd3dbc368--95a3e9f2568347d99d53fc8a03ee3b00 93b504b947044a3db4435dd819eb260f RY(theta\u2081\u2086) 95a3e9f2568347d99d53fc8a03ee3b00--93b504b947044a3db4435dd819eb260f aa5abf4ad6304e42b89eff92219b20a5 RX(theta\u2082\u2080) 93b504b947044a3db4435dd819eb260f--aa5abf4ad6304e42b89eff92219b20a5 cb7342ac84ba46af8c13ae49fe2f80cb aa5abf4ad6304e42b89eff92219b20a5--cb7342ac84ba46af8c13ae49fe2f80cb e09ee059d03145deb88046e8c18c7566 cb7342ac84ba46af8c13ae49fe2f80cb--e09ee059d03145deb88046e8c18c7566 bc46189310fd46dc9d99d93d50f434c2 RX(theta\u2080) e09ee059d03145deb88046e8c18c7566--bc46189310fd46dc9d99d93d50f434c2 89b3937dbbc3465a8f869fb6f511a78c RY(theta\u2084) bc46189310fd46dc9d99d93d50f434c2--89b3937dbbc3465a8f869fb6f511a78c a77911c23c534c28a477bda7c921d7b9 RX(theta\u2088) 89b3937dbbc3465a8f869fb6f511a78c--a77911c23c534c28a477bda7c921d7b9 bc96a613564f4489a38a114f4d4dadbc a77911c23c534c28a477bda7c921d7b9--bc96a613564f4489a38a114f4d4dadbc 258cffc2c0c24caa91476518bba16fa9 bc96a613564f4489a38a114f4d4dadbc--258cffc2c0c24caa91476518bba16fa9 686c1e967ef2484a986fbee3ba378d2d RX(theta\u2081\u2082) 258cffc2c0c24caa91476518bba16fa9--686c1e967ef2484a986fbee3ba378d2d 0a0015ae7b8747a3806c467c4636a55e RY(theta\u2081\u2086) 686c1e967ef2484a986fbee3ba378d2d--0a0015ae7b8747a3806c467c4636a55e 99d98b58f8bc4c35b2f8337a7ee4a069 RX(theta\u2082\u2080) 0a0015ae7b8747a3806c467c4636a55e--99d98b58f8bc4c35b2f8337a7ee4a069 3042a280debe47d69c3d3df9ac358932 99d98b58f8bc4c35b2f8337a7ee4a069--3042a280debe47d69c3d3df9ac358932 aea136db2f034d209ab3e0c39870bced 3042a280debe47d69c3d3df9ac358932--aea136db2f034d209ab3e0c39870bced 2e8b285e42f34e9fa48e3cc965d3fbfa aea136db2f034d209ab3e0c39870bced--2e8b285e42f34e9fa48e3cc965d3fbfa 9d5d00c333b948318ea44c8dc11c5dac bb7511a31e314f1f91c2980ce134b0df RX(theta\u2081) 4cddfa71f0ff41bfb68e950192d9f38e--bb7511a31e314f1f91c2980ce134b0df f8d15fb6728047f3813736de8d0fe406 2 9f5caf95af324f6bbae0abeb1ad1979c RY(theta\u2085) bb7511a31e314f1f91c2980ce134b0df--9f5caf95af324f6bbae0abeb1ad1979c 84b7078c7db34a4abb15a3d0108f4641 RX(theta\u2089) 9f5caf95af324f6bbae0abeb1ad1979c--84b7078c7db34a4abb15a3d0108f4641 16af3194a8134c9080f2d5eb9d525c87 X 84b7078c7db34a4abb15a3d0108f4641--16af3194a8134c9080f2d5eb9d525c87 16af3194a8134c9080f2d5eb9d525c87--8b9d11c4a52741d3835ebeae49282e16 1dbdbeb9d36248a8b77c55b22e1017bf 16af3194a8134c9080f2d5eb9d525c87--1dbdbeb9d36248a8b77c55b22e1017bf 2aa47204c68a4149aa3c53e45b9931d7 RX(theta\u2081\u2083) 1dbdbeb9d36248a8b77c55b22e1017bf--2aa47204c68a4149aa3c53e45b9931d7 066350eafaa14503a5ff33776788c9a8 RY(theta\u2081\u2087) 2aa47204c68a4149aa3c53e45b9931d7--066350eafaa14503a5ff33776788c9a8 f9db5fd9a5d94a969213a1ea30f74913 RX(theta\u2082\u2081) 066350eafaa14503a5ff33776788c9a8--f9db5fd9a5d94a969213a1ea30f74913 1d551c8f3b0e4bacb4ebbf4c609410ac X f9db5fd9a5d94a969213a1ea30f74913--1d551c8f3b0e4bacb4ebbf4c609410ac 1d551c8f3b0e4bacb4ebbf4c609410ac--cb7342ac84ba46af8c13ae49fe2f80cb aeb5c801283342ba9e78fe87b67816a4 1d551c8f3b0e4bacb4ebbf4c609410ac--aeb5c801283342ba9e78fe87b67816a4 f4cd526bf3564684a5d845d6e5861182 RX(theta\u2081) aeb5c801283342ba9e78fe87b67816a4--f4cd526bf3564684a5d845d6e5861182 8d376a679c6348ee8dad1caa2e8320cd RY(theta\u2085) f4cd526bf3564684a5d845d6e5861182--8d376a679c6348ee8dad1caa2e8320cd a25ab5d2027248b1a714fd2f01a47a2b RX(theta\u2089) 8d376a679c6348ee8dad1caa2e8320cd--a25ab5d2027248b1a714fd2f01a47a2b 608305643abb41d29948dc37746eae46 X a25ab5d2027248b1a714fd2f01a47a2b--608305643abb41d29948dc37746eae46 608305643abb41d29948dc37746eae46--bc96a613564f4489a38a114f4d4dadbc 0a8ea2a57ba745a2ae4f7d9649daf3f9 608305643abb41d29948dc37746eae46--0a8ea2a57ba745a2ae4f7d9649daf3f9 174c704ce41b415f95eec482a00030ae RX(theta\u2081\u2083) 0a8ea2a57ba745a2ae4f7d9649daf3f9--174c704ce41b415f95eec482a00030ae 0d52e6d90ec349ab9399d0e7602a62a6 RY(theta\u2081\u2087) 174c704ce41b415f95eec482a00030ae--0d52e6d90ec349ab9399d0e7602a62a6 e549419850b3495b86c2a224aff5830f RX(theta\u2082\u2081) 0d52e6d90ec349ab9399d0e7602a62a6--e549419850b3495b86c2a224aff5830f 54590370841e4ae9894e8b8be4181166 X e549419850b3495b86c2a224aff5830f--54590370841e4ae9894e8b8be4181166 54590370841e4ae9894e8b8be4181166--3042a280debe47d69c3d3df9ac358932 1b5248b33737475588a7b707ba6ec292 54590370841e4ae9894e8b8be4181166--1b5248b33737475588a7b707ba6ec292 1b5248b33737475588a7b707ba6ec292--9d5d00c333b948318ea44c8dc11c5dac 6f734492e97c477f838a3b8f0afb4036 74695b6a8673437eb64d23bd720c0cb8 RX(theta\u2082) f8d15fb6728047f3813736de8d0fe406--74695b6a8673437eb64d23bd720c0cb8 015db55b7e004fe4837967a3b229b0dd 3 534792b6912f46c18dfddf912a37edf2 RY(theta\u2086) 74695b6a8673437eb64d23bd720c0cb8--534792b6912f46c18dfddf912a37edf2 5f5a76472ccb440192348552bf3ccb68 RX(theta\u2081\u2080) 534792b6912f46c18dfddf912a37edf2--5f5a76472ccb440192348552bf3ccb68 05402d0ecb0e47899e8a5ea80038ca99 5f5a76472ccb440192348552bf3ccb68--05402d0ecb0e47899e8a5ea80038ca99 c91ae091f20b4d3b8afc01a006732a1f X 05402d0ecb0e47899e8a5ea80038ca99--c91ae091f20b4d3b8afc01a006732a1f c91ae091f20b4d3b8afc01a006732a1f--1dbdbeb9d36248a8b77c55b22e1017bf 6a1a02896a404e79a544b2f2e95fc1b4 RX(theta\u2081\u2084) c91ae091f20b4d3b8afc01a006732a1f--6a1a02896a404e79a544b2f2e95fc1b4 0adda69356344c178d7aa0d0855024a7 RY(theta\u2081\u2088) 6a1a02896a404e79a544b2f2e95fc1b4--0adda69356344c178d7aa0d0855024a7 de137f552d654af6b4bc657b6929a149 RX(theta\u2082\u2082) 0adda69356344c178d7aa0d0855024a7--de137f552d654af6b4bc657b6929a149 fc844d6192464166b5c419adf539d137 de137f552d654af6b4bc657b6929a149--fc844d6192464166b5c419adf539d137 e0ad8e5943ec4ceab041af2da9270003 X fc844d6192464166b5c419adf539d137--e0ad8e5943ec4ceab041af2da9270003 e0ad8e5943ec4ceab041af2da9270003--aeb5c801283342ba9e78fe87b67816a4 af8a88caa7e344e9b2c0c316acb25638 RX(theta\u2082) e0ad8e5943ec4ceab041af2da9270003--af8a88caa7e344e9b2c0c316acb25638 f0d573aa6551448f99681bb0e8820254 RY(theta\u2086) af8a88caa7e344e9b2c0c316acb25638--f0d573aa6551448f99681bb0e8820254 d7d8c103665c4d1ba7dbe2ac538a32cf RX(theta\u2081\u2080) f0d573aa6551448f99681bb0e8820254--d7d8c103665c4d1ba7dbe2ac538a32cf 1b55589f46e74958819f61c5f1fe7e38 d7d8c103665c4d1ba7dbe2ac538a32cf--1b55589f46e74958819f61c5f1fe7e38 0d2c5e3ab66f42ec8879e56b510ef8da X 1b55589f46e74958819f61c5f1fe7e38--0d2c5e3ab66f42ec8879e56b510ef8da 0d2c5e3ab66f42ec8879e56b510ef8da--0a8ea2a57ba745a2ae4f7d9649daf3f9 28d00c936a654d35bbd35129292a7e5a RX(theta\u2081\u2084) 0d2c5e3ab66f42ec8879e56b510ef8da--28d00c936a654d35bbd35129292a7e5a 46e2ee7b2843463b9291c01c8c4f5f7d RY(theta\u2081\u2088) 28d00c936a654d35bbd35129292a7e5a--46e2ee7b2843463b9291c01c8c4f5f7d 385ce545676d4367bc0f2d2a4eba1df3 RX(theta\u2082\u2082) 46e2ee7b2843463b9291c01c8c4f5f7d--385ce545676d4367bc0f2d2a4eba1df3 859f0f31183c467ebaec61e508504e65 385ce545676d4367bc0f2d2a4eba1df3--859f0f31183c467ebaec61e508504e65 cc5bc77fae054c158c4752ad0a9788b0 X 859f0f31183c467ebaec61e508504e65--cc5bc77fae054c158c4752ad0a9788b0 cc5bc77fae054c158c4752ad0a9788b0--1b5248b33737475588a7b707ba6ec292 cc5bc77fae054c158c4752ad0a9788b0--6f734492e97c477f838a3b8f0afb4036 f850c68270054ff781851d62de672ca6 e323d899284f4495a642fa1fe42164bd RX(theta\u2083) 015db55b7e004fe4837967a3b229b0dd--e323d899284f4495a642fa1fe42164bd b55aef16bfa6436c8bf808732476ab73 RY(theta\u2087) e323d899284f4495a642fa1fe42164bd--b55aef16bfa6436c8bf808732476ab73 82d11dc4be954825904d2ff31923150b RX(theta\u2081\u2081) b55aef16bfa6436c8bf808732476ab73--82d11dc4be954825904d2ff31923150b 7013df92350245b799be8cb749b84a2f X 82d11dc4be954825904d2ff31923150b--7013df92350245b799be8cb749b84a2f 7013df92350245b799be8cb749b84a2f--05402d0ecb0e47899e8a5ea80038ca99 388a9076433d4b67ae5f4f3c63c4cf86 7013df92350245b799be8cb749b84a2f--388a9076433d4b67ae5f4f3c63c4cf86 4e72fd8f1fb34c159248ff090fb25de3 RX(theta\u2081\u2085) 388a9076433d4b67ae5f4f3c63c4cf86--4e72fd8f1fb34c159248ff090fb25de3 2ab9438e291b45eea109f9e86fc256a8 RY(theta\u2081\u2089) 4e72fd8f1fb34c159248ff090fb25de3--2ab9438e291b45eea109f9e86fc256a8 5b44a713e015408e9455c31bb60c2d14 RX(theta\u2082\u2083) 2ab9438e291b45eea109f9e86fc256a8--5b44a713e015408e9455c31bb60c2d14 96010140bf8349b99c2cce91fa7dc361 X 5b44a713e015408e9455c31bb60c2d14--96010140bf8349b99c2cce91fa7dc361 96010140bf8349b99c2cce91fa7dc361--fc844d6192464166b5c419adf539d137 931354c35e82400ca4ba60873aae5d34 96010140bf8349b99c2cce91fa7dc361--931354c35e82400ca4ba60873aae5d34 7d4527e4ee9d4cc0bfbb67a5b0646a72 RX(theta\u2083) 931354c35e82400ca4ba60873aae5d34--7d4527e4ee9d4cc0bfbb67a5b0646a72 f47bdfc2379248a4b4d501aed29f84a8 RY(theta\u2087) 7d4527e4ee9d4cc0bfbb67a5b0646a72--f47bdfc2379248a4b4d501aed29f84a8 b0ccac41c28849908bcb99891ab4f76c RX(theta\u2081\u2081) f47bdfc2379248a4b4d501aed29f84a8--b0ccac41c28849908bcb99891ab4f76c 35771bea370b4da4aa4e6cd399611187 X b0ccac41c28849908bcb99891ab4f76c--35771bea370b4da4aa4e6cd399611187 35771bea370b4da4aa4e6cd399611187--1b55589f46e74958819f61c5f1fe7e38 6d56dfa946bf4359aea859e2a6ca7d83 35771bea370b4da4aa4e6cd399611187--6d56dfa946bf4359aea859e2a6ca7d83 77692966a7fd4edda232d6ada94afe01 RX(theta\u2081\u2085) 6d56dfa946bf4359aea859e2a6ca7d83--77692966a7fd4edda232d6ada94afe01 79f589b7c8c045e2a4ec62857eb6c7d7 RY(theta\u2081\u2089) 77692966a7fd4edda232d6ada94afe01--79f589b7c8c045e2a4ec62857eb6c7d7 e1b6b982f355467bb5a4230b6f353ebe RX(theta\u2082\u2083) 79f589b7c8c045e2a4ec62857eb6c7d7--e1b6b982f355467bb5a4230b6f353ebe 08f3e735690b4315ade0fe1842b29a0f X e1b6b982f355467bb5a4230b6f353ebe--08f3e735690b4315ade0fe1842b29a0f 08f3e735690b4315ade0fe1842b29a0f--859f0f31183c467ebaec61e508504e65 4b0af3272b8345e89255eab80ba0e711 08f3e735690b4315ade0fe1842b29a0f--4b0af3272b8345e89255eab80ba0e711 4b0af3272b8345e89255eab80ba0e711--f850c68270054ff781851d62de672ca6 </p> <p>Avoid non-unique names by prefixing</p> <p>A parameter prefix for each HEA can be passed as follows:</p> <p><pre><code>hea1 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p1\")\nhea2 = hea(n_qubits=n_qubits, depth=depth, param_prefix=\"p2\")\n\ncircuit = QuantumCircuit(n_qubits, hea1, hea2)\nn_params_two_heas = circuit.num_unique_parameters\n</code></pre> <pre><code>Unique parameters with two stacked HEAs: 48\n</code></pre> %3 cluster_abda15422666475796f4c83070cc81cb HEA cluster_b0906d263336440b884381bc109900b8 HEA 78c00d7322fa4953a243a01f996d061c 0 209287695634457197b21aad4b7a74ce RX(p1\u2080) 78c00d7322fa4953a243a01f996d061c--209287695634457197b21aad4b7a74ce b8168f84e0a34fe9ad0f286c6e01592d 1 70c273e6cfdc4e918f0c1b383ba0e28e RY(p1\u2084) 209287695634457197b21aad4b7a74ce--70c273e6cfdc4e918f0c1b383ba0e28e 7169fd11c2a74c60973c27a12a548725 RX(p1\u2088) 70c273e6cfdc4e918f0c1b383ba0e28e--7169fd11c2a74c60973c27a12a548725 c647f603462f4a00afcc9dd25cfc440f 7169fd11c2a74c60973c27a12a548725--c647f603462f4a00afcc9dd25cfc440f 1a2fb03f9c074d7b92492f406e27897b c647f603462f4a00afcc9dd25cfc440f--1a2fb03f9c074d7b92492f406e27897b acc5692cbfcc436284bd08a512658a7b RX(p1\u2081\u2082) 1a2fb03f9c074d7b92492f406e27897b--acc5692cbfcc436284bd08a512658a7b 12ed446d15324fa5ab8b8efec33185f0 RY(p1\u2081\u2086) acc5692cbfcc436284bd08a512658a7b--12ed446d15324fa5ab8b8efec33185f0 8f4077d55b6c4a57b0409f1e2e8f7268 RX(p1\u2082\u2080) 12ed446d15324fa5ab8b8efec33185f0--8f4077d55b6c4a57b0409f1e2e8f7268 8a8845fd19db49a19c354935718c4636 8f4077d55b6c4a57b0409f1e2e8f7268--8a8845fd19db49a19c354935718c4636 dd259464dbfc444abae9fcf85ed3f7d8 8a8845fd19db49a19c354935718c4636--dd259464dbfc444abae9fcf85ed3f7d8 aea0b1a2dfc5408ab988d067fc57f007 RX(p2\u2080) dd259464dbfc444abae9fcf85ed3f7d8--aea0b1a2dfc5408ab988d067fc57f007 2690d2d2ab7b43988a7e3b95443edcd6 RY(p2\u2084) aea0b1a2dfc5408ab988d067fc57f007--2690d2d2ab7b43988a7e3b95443edcd6 58a0afee205949cea26b365295e2687b RX(p2\u2088) 2690d2d2ab7b43988a7e3b95443edcd6--58a0afee205949cea26b365295e2687b 8990dd3d93824c6c9dee14d8d74a765c 58a0afee205949cea26b365295e2687b--8990dd3d93824c6c9dee14d8d74a765c 23650ee47eb34806a9f6324deeb80421 8990dd3d93824c6c9dee14d8d74a765c--23650ee47eb34806a9f6324deeb80421 acabcbf9282f4639898c2ff504d9fe41 RX(p2\u2081\u2082) 23650ee47eb34806a9f6324deeb80421--acabcbf9282f4639898c2ff504d9fe41 ce659d798e784f4c8bb2c19ce8bf8880 RY(p2\u2081\u2086) acabcbf9282f4639898c2ff504d9fe41--ce659d798e784f4c8bb2c19ce8bf8880 1de79d7cf12e45b1bf897647c489da48 RX(p2\u2082\u2080) ce659d798e784f4c8bb2c19ce8bf8880--1de79d7cf12e45b1bf897647c489da48 4b6ec971dca54585b5732784b7bbec36 1de79d7cf12e45b1bf897647c489da48--4b6ec971dca54585b5732784b7bbec36 1198465f2e064349bb55b323de9d9adb 4b6ec971dca54585b5732784b7bbec36--1198465f2e064349bb55b323de9d9adb 0f79529eb22d48f98d342143bff10276 1198465f2e064349bb55b323de9d9adb--0f79529eb22d48f98d342143bff10276 8745d6949db948379ef0c5b2d0c168d2 fbb28c3c1cde4b20bcd7da904bb446b2 RX(p1\u2081) b8168f84e0a34fe9ad0f286c6e01592d--fbb28c3c1cde4b20bcd7da904bb446b2 d656394d88914745a66bb84501ff4fcb 2 0dbba14373a147b09ec598900a637931 RY(p1\u2085) fbb28c3c1cde4b20bcd7da904bb446b2--0dbba14373a147b09ec598900a637931 d846eb43654449939970209a1d87447d RX(p1\u2089) 0dbba14373a147b09ec598900a637931--d846eb43654449939970209a1d87447d ffaa8a08d9b743b8a52f65ca5fa173ee X d846eb43654449939970209a1d87447d--ffaa8a08d9b743b8a52f65ca5fa173ee ffaa8a08d9b743b8a52f65ca5fa173ee--c647f603462f4a00afcc9dd25cfc440f e26fa38028bc4aedb0b217bf00da4313 ffaa8a08d9b743b8a52f65ca5fa173ee--e26fa38028bc4aedb0b217bf00da4313 b6c912ddb39741d8bec22933979b5d09 RX(p1\u2081\u2083) e26fa38028bc4aedb0b217bf00da4313--b6c912ddb39741d8bec22933979b5d09 c7931ca6faae4f06b4c46fdba6bf293c RY(p1\u2081\u2087) b6c912ddb39741d8bec22933979b5d09--c7931ca6faae4f06b4c46fdba6bf293c 435b186eca3e434294632911b55832f9 RX(p1\u2082\u2081) c7931ca6faae4f06b4c46fdba6bf293c--435b186eca3e434294632911b55832f9 933cf568e64f4542b3e146a7db172926 X 435b186eca3e434294632911b55832f9--933cf568e64f4542b3e146a7db172926 933cf568e64f4542b3e146a7db172926--8a8845fd19db49a19c354935718c4636 6284eb7fec7b4e4da3039f39e4da81fd 933cf568e64f4542b3e146a7db172926--6284eb7fec7b4e4da3039f39e4da81fd 296057333c114f209ac5109cd4470ce0 RX(p2\u2081) 6284eb7fec7b4e4da3039f39e4da81fd--296057333c114f209ac5109cd4470ce0 12d94f4fc79f4e4e894138ef969857fc RY(p2\u2085) 296057333c114f209ac5109cd4470ce0--12d94f4fc79f4e4e894138ef969857fc 9af53df0b7d34283832d285ec881ce8f RX(p2\u2089) 12d94f4fc79f4e4e894138ef969857fc--9af53df0b7d34283832d285ec881ce8f 35edc9b8ee5b4fa38a1c5c36f1384c18 X 9af53df0b7d34283832d285ec881ce8f--35edc9b8ee5b4fa38a1c5c36f1384c18 35edc9b8ee5b4fa38a1c5c36f1384c18--8990dd3d93824c6c9dee14d8d74a765c 269c12abe49249a78cb1a19c590b7c27 35edc9b8ee5b4fa38a1c5c36f1384c18--269c12abe49249a78cb1a19c590b7c27 4b5640815b0743ae813364fdf5fa050e RX(p2\u2081\u2083) 269c12abe49249a78cb1a19c590b7c27--4b5640815b0743ae813364fdf5fa050e afb3fe2d2792480cb8ca174ff7f576b0 RY(p2\u2081\u2087) 4b5640815b0743ae813364fdf5fa050e--afb3fe2d2792480cb8ca174ff7f576b0 55c7055abb854f45a989623dc2151fcd RX(p2\u2082\u2081) afb3fe2d2792480cb8ca174ff7f576b0--55c7055abb854f45a989623dc2151fcd 9c77397599034231a18e2a15eedff696 X 55c7055abb854f45a989623dc2151fcd--9c77397599034231a18e2a15eedff696 9c77397599034231a18e2a15eedff696--4b6ec971dca54585b5732784b7bbec36 6dbf7bcd7a8f48d4901ee13f9c94f0f5 9c77397599034231a18e2a15eedff696--6dbf7bcd7a8f48d4901ee13f9c94f0f5 6dbf7bcd7a8f48d4901ee13f9c94f0f5--8745d6949db948379ef0c5b2d0c168d2 929c64c0c75c411b97bf43be7fe6338a da0c92c0051e47919005c952e5c62bad RX(p1\u2082) d656394d88914745a66bb84501ff4fcb--da0c92c0051e47919005c952e5c62bad 4aaad3da46564675ba58b6564bd49af6 3 200bce13b58347149dd2cda3a0c6ee57 RY(p1\u2086) da0c92c0051e47919005c952e5c62bad--200bce13b58347149dd2cda3a0c6ee57 d7d263cdfca24332b5c24e40918b78ab RX(p1\u2081\u2080) 200bce13b58347149dd2cda3a0c6ee57--d7d263cdfca24332b5c24e40918b78ab 3369ecd88d5b407b9eb26fb1e029ac61 d7d263cdfca24332b5c24e40918b78ab--3369ecd88d5b407b9eb26fb1e029ac61 5ec0c7a9e5104312a8f1f49ca1741b50 X 3369ecd88d5b407b9eb26fb1e029ac61--5ec0c7a9e5104312a8f1f49ca1741b50 5ec0c7a9e5104312a8f1f49ca1741b50--e26fa38028bc4aedb0b217bf00da4313 4a8797461863492f99129048b1185ee0 RX(p1\u2081\u2084) 5ec0c7a9e5104312a8f1f49ca1741b50--4a8797461863492f99129048b1185ee0 2b8bb4c4e43e4537ba014eb3adb6a895 RY(p1\u2081\u2088) 4a8797461863492f99129048b1185ee0--2b8bb4c4e43e4537ba014eb3adb6a895 358b0037c5874b569cb12f465748c459 RX(p1\u2082\u2082) 2b8bb4c4e43e4537ba014eb3adb6a895--358b0037c5874b569cb12f465748c459 c5641b2a1b384433a39a0e3b2abb83bd 358b0037c5874b569cb12f465748c459--c5641b2a1b384433a39a0e3b2abb83bd e1b984f66aba48039c9f1316c4d1e5fa X c5641b2a1b384433a39a0e3b2abb83bd--e1b984f66aba48039c9f1316c4d1e5fa e1b984f66aba48039c9f1316c4d1e5fa--6284eb7fec7b4e4da3039f39e4da81fd 17b9bf6905fc4133b73881f62b94f850 RX(p2\u2082) e1b984f66aba48039c9f1316c4d1e5fa--17b9bf6905fc4133b73881f62b94f850 0fd1e9466f13484e8d63c439f3758bef RY(p2\u2086) 17b9bf6905fc4133b73881f62b94f850--0fd1e9466f13484e8d63c439f3758bef d813c230926643bea25620b4e1fdbf52 RX(p2\u2081\u2080) 0fd1e9466f13484e8d63c439f3758bef--d813c230926643bea25620b4e1fdbf52 8ee933186f8448a8a287ac09f31c3249 d813c230926643bea25620b4e1fdbf52--8ee933186f8448a8a287ac09f31c3249 429aedf201f342a8ace8bd9521bf1fd9 X 8ee933186f8448a8a287ac09f31c3249--429aedf201f342a8ace8bd9521bf1fd9 429aedf201f342a8ace8bd9521bf1fd9--269c12abe49249a78cb1a19c590b7c27 eac09af2ccc048729b56389117c983e4 RX(p2\u2081\u2084) 429aedf201f342a8ace8bd9521bf1fd9--eac09af2ccc048729b56389117c983e4 a48245d0eb6f45f3abd39a3660632fae RY(p2\u2081\u2088) eac09af2ccc048729b56389117c983e4--a48245d0eb6f45f3abd39a3660632fae 9e6ef99b88c840e5aaf80767c4667e5e RX(p2\u2082\u2082) a48245d0eb6f45f3abd39a3660632fae--9e6ef99b88c840e5aaf80767c4667e5e 15f11b367df14f23b05084dbe7cc0bf0 9e6ef99b88c840e5aaf80767c4667e5e--15f11b367df14f23b05084dbe7cc0bf0 66bfc0b4609b4f49b6ac655f0239d7c8 X 15f11b367df14f23b05084dbe7cc0bf0--66bfc0b4609b4f49b6ac655f0239d7c8 66bfc0b4609b4f49b6ac655f0239d7c8--6dbf7bcd7a8f48d4901ee13f9c94f0f5 66bfc0b4609b4f49b6ac655f0239d7c8--929c64c0c75c411b97bf43be7fe6338a 3c5abb47e7c24d6baf599bf3dfc0274f 3b2ef712e500496693b4697885e62cfd RX(p1\u2083) 4aaad3da46564675ba58b6564bd49af6--3b2ef712e500496693b4697885e62cfd d7f36e123ffe4db597ca6493c841eaff RY(p1\u2087) 3b2ef712e500496693b4697885e62cfd--d7f36e123ffe4db597ca6493c841eaff 172ea8e5df484b5aa34e9ea90c26ffae RX(p1\u2081\u2081) d7f36e123ffe4db597ca6493c841eaff--172ea8e5df484b5aa34e9ea90c26ffae bec8c7c6d5b64d1ab5c2964c47d1743f X 172ea8e5df484b5aa34e9ea90c26ffae--bec8c7c6d5b64d1ab5c2964c47d1743f bec8c7c6d5b64d1ab5c2964c47d1743f--3369ecd88d5b407b9eb26fb1e029ac61 d1692c83a726477a90c1266d2f1d1b4d bec8c7c6d5b64d1ab5c2964c47d1743f--d1692c83a726477a90c1266d2f1d1b4d 06eebb27353b41bd925ca59767bf04d3 RX(p1\u2081\u2085) d1692c83a726477a90c1266d2f1d1b4d--06eebb27353b41bd925ca59767bf04d3 b13c8a5440454945a353f5834e37ebda RY(p1\u2081\u2089) 06eebb27353b41bd925ca59767bf04d3--b13c8a5440454945a353f5834e37ebda 06359521606d40b9b4f6eb2306bfce4c RX(p1\u2082\u2083) b13c8a5440454945a353f5834e37ebda--06359521606d40b9b4f6eb2306bfce4c 5b2e4aeba0ed494aaa2fb990a3f6105e X 06359521606d40b9b4f6eb2306bfce4c--5b2e4aeba0ed494aaa2fb990a3f6105e 5b2e4aeba0ed494aaa2fb990a3f6105e--c5641b2a1b384433a39a0e3b2abb83bd 4ab4ee83a2ae42cb90a1eb0c824267e8 5b2e4aeba0ed494aaa2fb990a3f6105e--4ab4ee83a2ae42cb90a1eb0c824267e8 da0bb4e6d8444e8d81f927c31ea5f049 RX(p2\u2083) 4ab4ee83a2ae42cb90a1eb0c824267e8--da0bb4e6d8444e8d81f927c31ea5f049 e0150c8892514b3f8eb616446b334005 RY(p2\u2087) da0bb4e6d8444e8d81f927c31ea5f049--e0150c8892514b3f8eb616446b334005 9674bf2cbd9f4b2ea0c6140741118570 RX(p2\u2081\u2081) e0150c8892514b3f8eb616446b334005--9674bf2cbd9f4b2ea0c6140741118570 d44b4fcd33c54998af4e668576058798 X 9674bf2cbd9f4b2ea0c6140741118570--d44b4fcd33c54998af4e668576058798 d44b4fcd33c54998af4e668576058798--8ee933186f8448a8a287ac09f31c3249 53fb841e78df44629a1fc23f524ae28e d44b4fcd33c54998af4e668576058798--53fb841e78df44629a1fc23f524ae28e acd086529c0742ce876bcc9060a9cdf3 RX(p2\u2081\u2085) 53fb841e78df44629a1fc23f524ae28e--acd086529c0742ce876bcc9060a9cdf3 0fd8363726d248719cb4d2a7ab37059b RY(p2\u2081\u2089) acd086529c0742ce876bcc9060a9cdf3--0fd8363726d248719cb4d2a7ab37059b 46e3542c59e94a688aeeb0077320bdfe RX(p2\u2082\u2083) 0fd8363726d248719cb4d2a7ab37059b--46e3542c59e94a688aeeb0077320bdfe 46eb6dea43704766bee041759e73ab44 X 46e3542c59e94a688aeeb0077320bdfe--46eb6dea43704766bee041759e73ab44 46eb6dea43704766bee041759e73ab44--15f11b367df14f23b05084dbe7cc0bf0 a98187918a0747de8e5efc76b781d10b 46eb6dea43704766bee041759e73ab44--a98187918a0747de8e5efc76b781d10b a98187918a0747de8e5efc76b781d10b--3c5abb47e7c24d6baf599bf3dfc0274f </p> <p>The <code>hea</code> function will be further explored in the QML Constructors tutorial.</p>"},{"location":"tutorials/parameters/#parametric-observables","title":"Parametric observables","text":"<p>In Qadence, one can define quantum observables with classical optimizable parameters to improve the convergence of QML calculations. This is particularly useful for differentiable quantum circuits.</p> <pre><code>from qadence import VariationalParameter, Z, add, tag\n\ns = VariationalParameter(\"s\")\nobservable = add(s * Z(i) for i in range(n_qubits))\n</code></pre> <p>Now, a quantum model can be created with the parametric observable. The observable variational parameters are included among the model ones.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit\n\ncircuit = QuantumCircuit(n_qubits, hea(n_qubits, depth))\nmodel = QuantumModel(circuit, observable=observable)\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.4060])), ('theta_0', tensor([0.7295])), ('theta_1', tensor([0.4842])), ('theta_10', tensor([0.2934])), ('theta_11', tensor([0.9087])), ('theta_12', tensor([0.5591])), ('theta_13', tensor([0.2918])), ('theta_14', tensor([0.6196])), ('theta_15', tensor([0.0873])), ('theta_16', tensor([0.7099])), ('theta_17', tensor([0.5362])), ('theta_18', tensor([0.3060])), ('theta_19', tensor([0.0122])), ('theta_2', tensor([0.4173])), ('theta_20', tensor([0.5521])), ('theta_21', tensor([0.0399])), ('theta_22', tensor([0.4448])), ('theta_23', tensor([0.8476])), ('theta_3', tensor([0.6639])), ('theta_4', tensor([0.6974])), ('theta_5', tensor([0.1438])), ('theta_6', tensor([0.6251])), ('theta_7', tensor([0.3880])), ('theta_8', tensor([0.2627])), ('theta_9', tensor([0.4693]))])\n</code></pre> <p>One optimization step (forward and backward pass) can be performed using built-in <code>torch</code> functionalities. Variational parameters can be checked to have been updated accordingly:</p> <pre><code>import torch\n\nmse_loss = torch.nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters())\n\n# Compute forward &amp; backward pass\noptimizer.zero_grad()\nloss = mse_loss(model.expectation({}), torch.zeros(1))\nloss.backward()\n\n# Update the parameters and check the parameters.\noptimizer.step()\n</code></pre> <pre><code>Variational parameters = OrderedDict([('s', tensor([0.4050])), ('theta_0', tensor([0.7285])), ('theta_1', tensor([0.4832])), ('theta_10', tensor([0.2944])), ('theta_11', tensor([0.9097])), ('theta_12', tensor([0.5601])), ('theta_13', tensor([0.2908])), ('theta_14', tensor([0.6186])), ('theta_15', tensor([0.0883])), ('theta_16', tensor([0.7109])), ('theta_17', tensor([0.5372])), ('theta_18', tensor([0.3070])), ('theta_19', tensor([0.0112])), ('theta_2', tensor([0.4183])), ('theta_20', tensor([0.5531])), ('theta_21', tensor([0.0389])), ('theta_22', tensor([0.4438])), ('theta_23', tensor([0.8486])), ('theta_3', tensor([0.6649])), ('theta_4', tensor([0.6984])), ('theta_5', tensor([0.1448])), ('theta_6', tensor([0.6261])), ('theta_7', tensor([0.3870])), ('theta_8', tensor([0.2617])), ('theta_9', tensor([0.4683]))])\n</code></pre>"},{"location":"tutorials/parameters/#non-unitary-circuits","title":"Non-unitary circuits","text":"<p>Qadence allows composing with non-unitary blocks. Here is an example of a non-unitary block as a sum of Pauli operators with complex coefficients.</p> <p>Currently, only the <code>PyQTorch</code> backend fully supports execution of non-unitary circuits.</p> <pre><code>from qadence import QuantumModel, QuantumCircuit, Z, X\nc1 = 2.0\nc2 = 2.0 + 2.0j\n\nblock = c1 * Z(0) + c2 * X(1) + c1 * c2 * (Z(2) + X(3))\ncircuit = QuantumCircuit(4, block)\n\nmodel = QuantumModel(circuit)  # BackendName.PYQTORCH and DiffMode.AD by default.\n</code></pre> <pre><code>wf = tensor([[6.+4.j, 4.+4.j, 0.+0.j, 0.+0.j, 2.+2.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/quantummodels/","title":"Quantum models","text":"<p>A quantum program can be expressed and executed using the <code>QuantumModel</code> type. It serves three primary purposes:</p> <p>Parameter handling: by conveniently handling and embedding the two parameter types that Qadence supports: feature and variational (see more details in the next section).</p> <p>Differentiability: by enabling a differentiable backend that supports two differentiable modes: automated differentiation (AD) and parameter shift rule (PSR). The former is used to differentiate non-gate parameters and enabled for PyTorch-based simulators only. The latter is used to differentiate gate parameters and is enabled for all backends.</p> <p>Execution: by defining which backend the program is expected to be executed on. Qadence supports circuit compilation to the native backend representation.</p> <p>Backends</p> <p>Quantum models can execute on a number of different purpose backends: simulators, emulators or real hardware. By default, Qadence executes on the PyQTorch backend which implements a state vector simulator. Other choices include the Pulser backend (pulse sequences on programmable neutral atom arrays).  For more information see the backend section.</p> <p>The base <code>QuantumModel</code> exposes the following methods:</p> <ul> <li><code>QuantumModel.run()</code>: To extract the wavefunction after circuit execution. Not supported by all backends.</li> <li><code>QuantumModel.sample()</code>: Sample a bitstring from the resulting quantum state after circuit execution. Supported by all backends.</li> <li><code>QuantumModel.expectation()</code>: Compute the expectation value of an observable.</li> </ul> <p>Every <code>QuantumModel</code> is an instance of a <code>torch.nn.Module</code> that enables differentiability for its <code>expectation</code> method.</p> <p>Upon construction of the model, a compiled version of the abstract <code>QuantumCircuit</code> is created:</p> <pre><code>from qadence import QuantumCircuit, QuantumModel, RX, Z, chain, BackendName, Parameter\n\n# Construct a parametrized abstract circuit.\n# At this point we cannot run anything yet.\n\nx = Parameter(\"x\")\n\nn_qubits = 2\nblock = chain(RX(0, x), RX(1, x))\ncircuit = QuantumCircuit(n_qubits, block)\nobservable = Z(0)\n\n# Construct a QuantumModel which will compile\n# the abstract circuit to targetted backend.\n# By default, diff_mode=DiffMode.AD.\nmodel = QuantumModel(circuit, observable, backend=BackendName.PYQTORCH)\n\n# The converted circuit is a private attribute and should not\n# manually be tampered with, but we can at least verify its there\n# by printing it.\n</code></pre> <pre><code>model._circuit.native = \n\nQuantumCircuit(\n  (operations): ModuleList(\n    (0): QuantumCircuit(\n      (operations): ModuleList(\n        (0): RX(qubit_support=(0,))\n        (1): RX(qubit_support=(1,))\n      )\n    )\n  )\n)\n</code></pre> <p>Now, the wavefunction, sample, or expectation value are computable by passing a batch of values :</p> <pre><code>import torch\n\n# Set a batch of random parameter values.\nvalues = {\"x\": torch.rand(3)}\n\nwf = model.run(values)\nxs = model.sample(values, n_shots=100)\nex = model.expectation(values)\n</code></pre> <pre><code>wf = tensor([[ 0.9842+0.0000j,  0.0000-0.1246j,  0.0000-0.1246j, -0.0158+0.0000j],\n        [ 0.7807+0.0000j,  0.0000-0.4137j,  0.0000-0.4137j, -0.2193+0.0000j],\n        [ 0.8637+0.0000j,  0.0000-0.3431j,  0.0000-0.3431j, -0.1363+0.0000j]])\nxs = [Counter({'00': 99, '01': 1}), Counter({'00': 63, '10': 19, '01': 15, '11': 3}), Counter({'00': 73, '01': 16, '10': 9, '11': 2})]\nex = tensor([[0.9684],\n        [0.5615],\n        [0.7273]], requires_grad=True)\n</code></pre> <p>You can also measure multiple observables by passing a list of blocks.</p> <pre><code># By default, backend=BackendName.PYQTORCH.\nmodel = QuantumModel(circuit, [Z(0), Z(1)])\nex = model.expectation(values)\n</code></pre> <pre><code>ex = tensor([[0.9684, 0.9684],\n        [0.5615, 0.5615],\n        [0.7273, 0.7273]], requires_grad=True)\n</code></pre>"},{"location":"tutorials/quantummodels/#quantum-neural-network-qnn","title":"Quantum Neural Network (QNN)","text":"<p>The <code>QNN</code> is a subclass of the <code>QuantumModel</code> geared towards quantum machine learning and parameter optimisation. See the quantum machine learning section section or the <code>QNN</code> API reference for more detailed information, and the parametric program tutorial for parameterization.</p>"},{"location":"tutorials/register/","title":"Quantum registers","text":"<p>In Qadence, quantum programs can be executed by specifying the layout of a register of resources as a lattice. Built-in <code>Register</code> types can be used or constructed for arbitrary topologies. Common register topologies are available and illustrated in the plot below.</p> 2024-02-15T16:12:51.127470 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/"},{"location":"tutorials/register/#building-and-drawing-registers","title":"Building and drawing registers","text":"<p>Built-in topologies are directly accessible in the <code>Register</code> methods:</p> <pre><code>from qadence import Register\n\nreg = Register.all_to_all(n_qubits = 2)\nreg_line = Register.line(n_qubits = 2)\nreg_circle = Register.circle(n_qubits = 2)\nreg_squre = Register.square(qubits_side = 2)\nreg_rect = Register.rectangular_lattice(qubits_row = 2, qubits_col = 2)\nreg_triang = Register.triangular_lattice(n_cells_row = 2, n_cells_col = 2)\nreg_honey = Register.honeycomb_lattice(n_cells_row = 2, n_cells_col = 2)\n</code></pre> <p>Qubit coordinates are saved as node properties in the underlying NetworkX graph, but can be accessed directly with the <code>coords</code> property.</p> <p><pre><code>reg = Register.square(2)\nprint(reg.coords)\n</code></pre> <pre><code>{0: (0.5, -0.5), 1: (0.5, 0.5), 2: (-0.5, 0.5), 3: (-0.5, -0.5)}\n</code></pre>  By default, the coords are scaled such that the minimum distance between any two qubits is 1, unless the register is created directly from specific coordinates as shown below. The <code>spacing</code> argument can be used to set the minimum spacing. The <code>rescale_coords</code> method can be used to create a new register by rescaling the coordinates of an already created register.</p> <pre><code>scaled_reg_1 = Register.square(2, spacing = 2.0)\nscaled_reg_2 = reg.rescale_coords(scaling = 2.0)\nprint(scaled_reg_1.coords)\nprint(scaled_reg_2.coords)\n</code></pre> <pre><code>{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n{0: (1.0, -1.0), 1: (1.0, 1.0), 2: (-1.0, 1.0), 3: (-1.0, -1.0)}\n</code></pre> <p>The distance between qubits can also be directly accessed with the <code>distances</code> and <code>edge_distances</code> properties.</p> <pre><code>print(reg.distances)\nprint(reg.edge_distances)\n</code></pre> <pre><code>Distance between all qubit pairs:\n{(0, 1): 1.0, (0, 2): 1.4142135623730951, (0, 3): 1.0, (1, 2): 1.0, (1, 3): 1.4142135623730951, (2, 3): 1.0}\nDistance between qubits connect by an edge in the graph\n{(0, 1): 1.0, (0, 3): 1.0, (1, 2): 1.0, (2, 3): 1.0}\n</code></pre> <p>By calling the <code>Register</code> directly, either the number of nodes or a specific graph can be given as input. If passing a custom graph directly, the node positions will not be defined automatically, and should be previously saved in the <code>\"pos\"</code> node property. If not, <code>reg.coords</code> will return empty tuples and all distances will be 0.</p> <pre><code>import networkx as nx\n\n# Same as Register.all_to_all(n_qubits = 2):\nreg = Register(2)\n\n# Register from a custom graph:\ngraph = nx.complete_graph(3)\n\n# Set node positions, in this case a simple line:\nfor i, node in enumerate(graph.nodes):\n    graph.nodes[node][\"pos\"] = (1.0 * i, 0.0)\n\nreg = Register(graph)\n\nprint(reg.distances)\n</code></pre> <pre><code>{(0, 1): 1.0, (0, 2): 2.0, (1, 2): 1.0}\n</code></pre> <p>Alternatively, arbitrarily shaped registers can also be constructed by providing the node coordinates. In this case, there will be no edges automatically created in the connectivity graph.</p> <pre><code>import numpy as np\nfrom qadence import Register, PI\n\nreg = Register.from_coordinates(\n    [(x, np.sin(x)) for x in np.linspace(0, 2*PI, 10)]\n)\n\nreg.draw(show=False)\n</code></pre> 2024-02-15T16:12:51.468110 image/svg+xml Matplotlib v3.7.4, https://matplotlib.org/ <p>Units for qubit coordinates</p> <p>In general, Qadence makes no assumption about the units for qubit coordinates and distances. However, if used in the context of a Hamiltonian coefficient, care should be taken by the user to guarantee the quantity \\(H.t\\) is dimensionless for exponentiation in the PyQTorch backend, where it is assumed that \\(\\hbar = 1\\). For registers passed to the Pulser backend, coordinates are in \\(\\mu \\textrm{m}\\).</p>"},{"location":"tutorials/register/#connectivity-graphs","title":"Connectivity graphs","text":"<p>Register topology is often assumed in digital simulations to be an all-to-all qubit connectivity. When running on real devices that enable the digital-analog computing paradigm, qubit interactions must be specified either by specifying distances between qubits, or by defining edges in the register connectivity graph.</p> <p>It is possible to access the abstract graph nodes and edges to work with if needed as in the perfect state transfer example.</p> <pre><code>from qadence import Register\n\nreg = Register.rectangular_lattice(2,3)\n</code></pre> <pre><code>reg.nodes = NodeView((0, 1, 2, 3, 4, 5))\nreg.edges = EdgeView([(0, 2), (0, 1), (1, 3), (2, 4), (2, 3), (3, 5), (4, 5)])\n</code></pre> <p>There is also an <code>all_node_pairs</code> property for convencience:</p> <pre><code>print(reg.all_node_pairs)\n</code></pre> <pre><code>[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code></pre> <p>More details about the usage of <code>Register</code> types in the digital-analog paradigm can be found in the digital-analog basics section.</p>"},{"location":"tutorials/serializ_and_prep/","title":"Serialization","text":"<p>Qadence offers convenience functions for serializing and deserializing any quantum program. This is useful for storing quantum programs and sending them for execution over the network via an API.</p> <p>Note</p> <p>Qadence currently uses a custom JSON serialization as interchange format. Support for QASM format for digital quantum programs is currently under consideration.</p> <ul> <li><code>serialize/deserialize</code>: serialize and deserialize a Qadence object into a dictionary</li> <li><code>save/load</code>: save and load a Qadence object to a file with one of the supported   formats. Currently, these are <code>.json</code> and the PyTorch-compatible <code>.pt</code> format.</li> </ul> <p>Let's start with serialization into a dictionary.</p> <pre><code>import torch\nfrom qadence import QuantumCircuit, QuantumModel, DiffMode\nfrom qadence import chain, hamiltonian_factory, feature_map, hea, Z\nfrom qadence.serialization import serialize, deserialize\n\nn_qubits = 4\n\nmy_block = chain(feature_map(n_qubits, param=\"x\"), hea(n_qubits, depth=2))\nobs = hamiltonian_factory(n_qubits, detuning=Z)\n\n# Use the block defined above to create a quantum circuit\n# serialize/deserialize it\nqc = QuantumCircuit(n_qubits, my_block)\nqc_dict = serialize(qc)\nqc_deserialized = deserialize(qc_dict)\nassert qc == qc_deserialized\n\n# Let's wrap it in a QuantumModel\n# and serialize it\nqm = QuantumModel(qc, obs, diff_mode=DiffMode.AD)\nqm_dict = serialize(qm)\nqm_deserialized = deserialize(qm_dict)\n\n# Check if the loaded QuantumModel returns the same expectation\nvalues = {\"x\": torch.rand(10)}\nassert torch.allclose(qm.expectation(values=values), qm_deserialized.expectation(values=values))\n</code></pre> <p>Finally, we can save the quantum circuit and the model with the two supported formats.</p> <pre><code>from qadence.serialization import serialize, deserialize, save, load, SerializationFormat\nqc_fname = \"circuit\"\nsave(qc, folder=\".\", file_name=qc_fname, format=SerializationFormat.PT)\nloaded_qc = load(f\"{qc_fname}.pt\")\nassert qc == loaded_qc\n\nqm_fname = \"model\"\nsave(qm, folder=\".\", file_name=qm_fname, format=SerializationFormat.JSON)\nmodel = load(f\"{qm_fname}.json\")\nassert isinstance(model, QuantumModel)\n</code></pre>"},{"location":"tutorials/state_conventions/","title":"State Conventions","text":"<p>Here is an overview of the state conventions used in Qadence together with practical examples.</p>"},{"location":"tutorials/state_conventions/#qubit-register-order","title":"Qubit register order","text":"<p>Qubit registers in quantum computing are often indexed in increasing or decreasing order from left to right. In Qadence, the convention is qubit indexation in increasing order. For example, a register of four qubits in bra-ket notation reads:</p> \\[|q_0, q_1, q_2, q_3\\rangle\\] <p>Furthermore, when displaying a quantum circuit, qubits are ordered from top to bottom.</p>"},{"location":"tutorials/state_conventions/#basis-state-order","title":"Basis state order","text":"<p>Basis state ordering refers to how basis states are ordered when considering the conversion from bra-ket notation to the standard linear algebra basis. In Qadence, basis states are ordered in the following manner:</p> \\[ \\begin{align} |00\\rangle = [1, 0, 0, 0]^T\\\\ |01\\rangle = [0, 1, 0, 0]^T\\\\ |10\\rangle = [0, 0, 1, 0]^T\\\\ |11\\rangle = [0, 0, 0, 1]^T \\end{align} \\]"},{"location":"tutorials/state_conventions/#endianness","title":"Endianness","text":"<p>Endianness refers to the storage convention for binary information (in bytes) in a classical memory register. In quantum computing, information is either stored in bits or in qubits. The most commonly used conventions are:</p> <ul> <li>A big-endian system stores the most significant bit of a binary word at the smallest memory address.</li> <li>A little-endian system stores the least significant bit of a binary word at the smallest memory address.</li> </ul> <p>Given the register convention in Qadence, the integer \\(2\\) written in binary big-endian as \\(10\\) can be encoded in a qubit register in both big-endian as \\(|10\\rangle\\) or little-endian as \\(|01\\rangle\\).</p> <p>The convention for Qadence is big-endian.</p>"},{"location":"tutorials/state_conventions/#quantum-states","title":"Quantum states","text":"<p>In practical scenarios, conventions regarding register order, basis state order and endianness are very much intertwined, and identical results can be obtained by fixing or varying any of them. In Qadence, we assume that qubit ordering and basis state ordering is fixed, and allow an <code>endianness</code> argument that can be passed to control the expected result. Here are a few examples:</p> <p>A simple and direct way to exemplify the endianness convention is using convenience functions for state preparation.</p> <p>Bitstring convention as inputs</p> <p>When a bitstring is passed as input to a function for state preparation, it has to be understood in big-endian convention.</p> <pre><code>from qadence import Endianness, product_state\n\n# The state |10&gt;, the 3rd basis state.\nstate_big = product_state(\"10\", endianness=Endianness.BIG) # or just \"Big\"\n\n# The state |01&gt;, the 2nd basis state.\nstate_little = product_state(\"10\", endianness=Endianness.LITTLE) # or just \"Little\"\n</code></pre> <pre><code>State in big endian = tensor([[0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\nState in little endian = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Here, a bitword expressed as a Python string to encode the integer 2 in big-endian is used to create the respective basis state in both conventions. However, note that the same results can be obtained by fixing the endianness convention as big-endian (thus creating the state \\(|10\\rangle\\) in both cases), and changing the basis state ordering. A similar argument holds for fixing both endianness and basis state ordering and simply changing the qubit index order.</p> <p>Another example where endianness directly comes into play is when measuring a register. A big- or little-endian measurement will choose the first or the last qubit, respectively, as the most significant bit. Let's see this in an example:</p> <pre><code>from qadence import I, H, sample\n\n# Create superposition state: |00&gt; + |01&gt; (normalized)\nblock = I(0) @ H(1)  # Identity on qubit 0, Hadamard on qubit 1\n\n# Generate bitword samples following both conventions\n# Samples \"00\" and \"01\"\nresult_big = sample(block, endianness=Endianness.BIG)\n# Samples \"00\" and \"10\"\nresult_little = sample(block, endianness=Endianness.LITTLE)\n</code></pre> <pre><code>Sample in big endian = [Counter({'00': 55, '01': 45})]\nSample in little endian = [Counter({'00': 56, '10': 44})]\n</code></pre> <p>In Qadence, endianness can be flipped for many relevant objects:</p> <pre><code>from qadence import invert_endianness\n\n# Equivalent to sampling in little-endian.\nflip_big_sample = invert_endianness(result_big)\n\n# Equivalent to a state created in little-endian.\nflip_big_state = invert_endianness(state_big)\n</code></pre> <pre><code>Flipped sample = [Counter({'00': 55, '10': 45})]\nFlipped state = tensor([[0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre>"},{"location":"tutorials/state_conventions/#quantum-operations","title":"Quantum operations","text":"<p>When looking at the matricial form of quantum operations, the usage of the term endianness becomes slightly abusive. To exemplify, we may consider the <code>CNOT</code> operation with <code>control = 0</code> and <code>target = 1</code>. This operation is often described with two different matrices:</p> \\[ \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ \\end{bmatrix} \\qquad \\text{or} \\qquad \\text{CNOT(0, 1)} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ \\end{bmatrix} \\] <p>The difference can be easily explained either by considering a different ordering of the qubit indices, or a different ordering of the basis states. In Qadence, both can be retrieved through the <code>endianness</code> argument:</p> <pre><code>from qadence import block_to_tensor, CNOT\n\nmatrix_big = block_to_tensor(CNOT(0, 1), endianness=Endianness.BIG)\nmatrix_little = block_to_tensor(CNOT(0, 1), endianness=Endianness.LITTLE)\n</code></pre> <pre><code>CNOT matrix in big endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]]])\n\nCNOT matrix in little endian =\n\ntensor([[[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n         [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n         [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n         [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j]]])\n</code></pre>"},{"location":"tutorials/state_conventions/#backends","title":"Backends","text":"<p>An important part of having clear state conventions is that we need to make sure our results are consistent accross different computational backends, which may have their own conventions. In Qadence, this is taken care of automatically: by calling operations for different backends, the result is expected to be equivalent up to qubit ordering.</p> <pre><code>from qadence import BackendName, RX, run, sample, PI\n\n# RX(PI/4) on qubit 1\nn_qubits = 2\nop = RX(1, PI/4)\n</code></pre> <pre><code>Same sampling order in big endian:\n\nOn PyQTorch = [Counter({'00': 79, '01': 21})]\nOn Braket = [Counter({'00': 84, '01': 16})]\nOn Pulser = [Counter({'00': 82, '01': 18})]\n\nSame wavefunction order:\n\nOn PyQTorch = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Braket = tensor([[0.9239+0.0000j, 0.0000-0.3827j, 0.0000+0.0000j, 0.0000+0.0000j]])\nOn Pulser = tensor([[0.9241+0.0000j, 0.0000-0.3821j, 0.0000+0.0000j, 0.0000+0.0000j]])\n</code></pre>"},{"location":"tutorials/state_init/","title":"State initialization","text":"<p>Qadence offers convenience routines for preparing initial quantum states. These routines are divided into two approaches:</p> <ul> <li>As a dense matrix.</li> <li>From a suitable quantum circuit. This is available for every backend and it should be added in front of the desired quantum circuit to simulate.</li> </ul> <p>Let's illustrate the usage of the state preparation routine.</p> <pre><code>from qadence import random_state, product_state, is_normalized, StateGeneratorType\n\n# Random initial state.\n# the default `type` is StateGeneratorType.HaarMeasureFast\nstate = random_state(n_qubits=2, type=StateGeneratorType.RANDOM_ROTATIONS)\n\n# Check the normalization.\nassert is_normalized(state)\n\n# Product state from a given bitstring.\n# NB: Qadence follows the big endian convention.\nstate = product_state(\"01\")\n</code></pre> <pre><code>Random initial state generated with rotations:\n\nstate = [ 0.95253032+0.j         -0.10844744+0.j          0.        +0.28264746j\n  0.        -0.03217997j]\n\nProduct state corresponding to bitstring '01':\n\nstate = [0.+0.j 1.+0.j 0.+0.j 0.+0.j]\n</code></pre> <p>Now we see how to generate the product state corresponding to the one above with a suitable quantum circuit.</p> <p><pre><code>from qadence import product_block, tag, hea, QuantumCircuit\nfrom qadence.draw import display\n\nstate_prep_block = product_block(\"01\")\n# display(state_prep_block)\n\n# Let's now prepare a circuit.\nn_qubits = 4\n\nstate_prep_block = product_block(\"0001\")\ntag(state_prep_block, \"Prep block\")\n\ncircuit_block = tag(hea(n_qubits, depth = 2), \"Circuit block\")\n\nqc_with_state_prep = QuantumCircuit(n_qubits, state_prep_block, circuit_block)\n</code></pre> %3 cluster_adec49aeab104c7a841905e8af0158a1 Circuit block cluster_af23ca15e328457daf5bde77461716c7 Prep block 457ccabd80d241e98ea4645f77e4bdb9 0 fca63722c1974f68a99547d6ab15a01b 457ccabd80d241e98ea4645f77e4bdb9--fca63722c1974f68a99547d6ab15a01b de612bba5e974d4190caebcaa3c3488e 1 76b7f839d89c41ada2285dd0a8b6a47c RX(theta\u2080) fca63722c1974f68a99547d6ab15a01b--76b7f839d89c41ada2285dd0a8b6a47c 2da92035c29c49c494a86682a361b400 RY(theta\u2084) 76b7f839d89c41ada2285dd0a8b6a47c--2da92035c29c49c494a86682a361b400 edd0d72726474d08b1b5a6ad7a0bcd71 RX(theta\u2088) 2da92035c29c49c494a86682a361b400--edd0d72726474d08b1b5a6ad7a0bcd71 d7192745e9c54ae799727974dff9af84 edd0d72726474d08b1b5a6ad7a0bcd71--d7192745e9c54ae799727974dff9af84 b026004a381b4c02b79261ed50cbb22a d7192745e9c54ae799727974dff9af84--b026004a381b4c02b79261ed50cbb22a 305e080dbaa645e782c57b58d132b5f2 RX(theta\u2081\u2082) b026004a381b4c02b79261ed50cbb22a--305e080dbaa645e782c57b58d132b5f2 06ad38f252824f0993e0e4ee90a99b2f RY(theta\u2081\u2086) 305e080dbaa645e782c57b58d132b5f2--06ad38f252824f0993e0e4ee90a99b2f 0ce99803a92f4021887d91d41a635362 RX(theta\u2082\u2080) 06ad38f252824f0993e0e4ee90a99b2f--0ce99803a92f4021887d91d41a635362 272ca61d55ea494ba7bc96b85683fef8 0ce99803a92f4021887d91d41a635362--272ca61d55ea494ba7bc96b85683fef8 3083b5be70cc423da990bfc5211d0c08 272ca61d55ea494ba7bc96b85683fef8--3083b5be70cc423da990bfc5211d0c08 a50e7c62817046a2a3e9911b4dd72bbc 3083b5be70cc423da990bfc5211d0c08--a50e7c62817046a2a3e9911b4dd72bbc de1db80f467a47ce8b376b3165586bd9 5f80e8f4587a4865b664bc9ba29d674f de612bba5e974d4190caebcaa3c3488e--5f80e8f4587a4865b664bc9ba29d674f 6ca4018f163247f2930f928f58ff746d 2 648015422d074713b0cbaee95b81c220 RX(theta\u2081) 5f80e8f4587a4865b664bc9ba29d674f--648015422d074713b0cbaee95b81c220 9eb706f8457c4527b3992e8f7f548157 RY(theta\u2085) 648015422d074713b0cbaee95b81c220--9eb706f8457c4527b3992e8f7f548157 3965ab8459724fa88591877fe17ea016 RX(theta\u2089) 9eb706f8457c4527b3992e8f7f548157--3965ab8459724fa88591877fe17ea016 66c04216d397472398a0a5d5a7aef126 X 3965ab8459724fa88591877fe17ea016--66c04216d397472398a0a5d5a7aef126 66c04216d397472398a0a5d5a7aef126--d7192745e9c54ae799727974dff9af84 77a10a95016248239a7962dc1f819f4c 66c04216d397472398a0a5d5a7aef126--77a10a95016248239a7962dc1f819f4c a181fd14594643d8af97336e9a0310a2 RX(theta\u2081\u2083) 77a10a95016248239a7962dc1f819f4c--a181fd14594643d8af97336e9a0310a2 f83766efe776420fa1983b68fd0de1c1 RY(theta\u2081\u2087) a181fd14594643d8af97336e9a0310a2--f83766efe776420fa1983b68fd0de1c1 ffaa337a336142639f65b5d6c7cae445 RX(theta\u2082\u2081) f83766efe776420fa1983b68fd0de1c1--ffaa337a336142639f65b5d6c7cae445 6afd140fc2964f41806a8a9983dd8c85 X ffaa337a336142639f65b5d6c7cae445--6afd140fc2964f41806a8a9983dd8c85 6afd140fc2964f41806a8a9983dd8c85--272ca61d55ea494ba7bc96b85683fef8 bac0c20fd8ce4f7284186850711cba15 6afd140fc2964f41806a8a9983dd8c85--bac0c20fd8ce4f7284186850711cba15 bac0c20fd8ce4f7284186850711cba15--de1db80f467a47ce8b376b3165586bd9 c42d89d016f64592afef2476a4ee6c58 9cfeb83d926f445fa72d962c8e919169 6ca4018f163247f2930f928f58ff746d--9cfeb83d926f445fa72d962c8e919169 3d90d36aa9a14fb68046eaafccb1bb39 3 5637e08cb32d49d18047f35f03acae31 RX(theta\u2082) 9cfeb83d926f445fa72d962c8e919169--5637e08cb32d49d18047f35f03acae31 2b883fed0fdc46e98e1535d962f6a9c9 RY(theta\u2086) 5637e08cb32d49d18047f35f03acae31--2b883fed0fdc46e98e1535d962f6a9c9 27c8795073fa4c48963a321eda629fdc RX(theta\u2081\u2080) 2b883fed0fdc46e98e1535d962f6a9c9--27c8795073fa4c48963a321eda629fdc 17f9773736134546aec6f8fcccc4f26a 27c8795073fa4c48963a321eda629fdc--17f9773736134546aec6f8fcccc4f26a 8c7aa7127cdf42e393240b3f27755cf8 X 17f9773736134546aec6f8fcccc4f26a--8c7aa7127cdf42e393240b3f27755cf8 8c7aa7127cdf42e393240b3f27755cf8--77a10a95016248239a7962dc1f819f4c 9b3a306b8c9048b7aa7a64a39cb7bce0 RX(theta\u2081\u2084) 8c7aa7127cdf42e393240b3f27755cf8--9b3a306b8c9048b7aa7a64a39cb7bce0 7ebb7c3664b940b2bf204d63e29e57b7 RY(theta\u2081\u2088) 9b3a306b8c9048b7aa7a64a39cb7bce0--7ebb7c3664b940b2bf204d63e29e57b7 5894384466bb45308024a7ee17870c89 RX(theta\u2082\u2082) 7ebb7c3664b940b2bf204d63e29e57b7--5894384466bb45308024a7ee17870c89 c9d7a944221247b99ebbae833ada235a 5894384466bb45308024a7ee17870c89--c9d7a944221247b99ebbae833ada235a 1da1d1ebd3e74bbdbdb1ac1a47294634 X c9d7a944221247b99ebbae833ada235a--1da1d1ebd3e74bbdbdb1ac1a47294634 1da1d1ebd3e74bbdbdb1ac1a47294634--bac0c20fd8ce4f7284186850711cba15 1da1d1ebd3e74bbdbdb1ac1a47294634--c42d89d016f64592afef2476a4ee6c58 20212aad7b5a404f9f2b309246771318 44321e77f0b340debe1aabf677e61b16 X 3d90d36aa9a14fb68046eaafccb1bb39--44321e77f0b340debe1aabf677e61b16 9be0fcbf1eaa4ad29055128438bb52b0 RX(theta\u2083) 44321e77f0b340debe1aabf677e61b16--9be0fcbf1eaa4ad29055128438bb52b0 aa4da93917f143d5a7cc6a57d20ce2ce RY(theta\u2087) 9be0fcbf1eaa4ad29055128438bb52b0--aa4da93917f143d5a7cc6a57d20ce2ce 0ff87f2dcba64c0793df07f9b8be4c14 RX(theta\u2081\u2081) aa4da93917f143d5a7cc6a57d20ce2ce--0ff87f2dcba64c0793df07f9b8be4c14 7b886d1a1a2a4df8aabb99ce32fb07e9 X 0ff87f2dcba64c0793df07f9b8be4c14--7b886d1a1a2a4df8aabb99ce32fb07e9 7b886d1a1a2a4df8aabb99ce32fb07e9--17f9773736134546aec6f8fcccc4f26a f11e0e2102354accaa480f3b25eed5dd 7b886d1a1a2a4df8aabb99ce32fb07e9--f11e0e2102354accaa480f3b25eed5dd 773b8341c310478492dc0693b54ba89e RX(theta\u2081\u2085) f11e0e2102354accaa480f3b25eed5dd--773b8341c310478492dc0693b54ba89e 84b5f743c490441798f24d527a23e1ae RY(theta\u2081\u2089) 773b8341c310478492dc0693b54ba89e--84b5f743c490441798f24d527a23e1ae f928a936b76a458a871ff3dbcbaac049 RX(theta\u2082\u2083) 84b5f743c490441798f24d527a23e1ae--f928a936b76a458a871ff3dbcbaac049 16e3dbc12540451487c4ce4dba7a8bf3 X f928a936b76a458a871ff3dbcbaac049--16e3dbc12540451487c4ce4dba7a8bf3 16e3dbc12540451487c4ce4dba7a8bf3--c9d7a944221247b99ebbae833ada235a 7cc7560517ab414e871875c1bacb3227 16e3dbc12540451487c4ce4dba7a8bf3--7cc7560517ab414e871875c1bacb3227 7cc7560517ab414e871875c1bacb3227--20212aad7b5a404f9f2b309246771318  Several standard quantum states can be conveniently initialized in Qadence, both in statevector form as well as in block form as shown in following.</p>"},{"location":"tutorials/state_init/#state-vector-initialization","title":"State vector initialization","text":"<p>Qadence offers a number of constructor functions for state vector preparation.</p> <pre><code>from qadence import uniform_state, zero_state, one_state\n\nn_qubits = 3\nbatch_size = 2\n\nuniform_state = uniform_state(n_qubits, batch_size)\nzero_state = zero_state(n_qubits, batch_size)\none_state = one_state(n_qubits, batch_size)\n</code></pre> <pre><code>Uniform state = \n\ntensor([[0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j],\n        [0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j, 0.3536+0.j,\n         0.3536+0.j]])\nZero state = \n\ntensor([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\nOne state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre> <p>As already seen, product states can be easily created, even in batches:</p> <pre><code>from qadence import product_state, rand_product_state\n\n# From a bitsring \"100\"\nprod_state = product_state(\"100\", batch_size)\n\n# Or a random product state\nrand_state = rand_product_state(n_qubits, batch_size)\n</code></pre> <pre><code>Product state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n        [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n\nRandom state = \n\ntensor([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n        [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n</code></pre> <p>Creating a GHZ state:</p> <pre><code>from qadence import ghz_state\n\nghz = ghz_state(n_qubits, batch_size)\n</code></pre> <pre><code>GHZ state = \n\ntensor([[0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j],\n        [0.7071+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j, 0.0000+0.j,\n         0.7071+0.j]])\n</code></pre> <p>Creating a random state uniformly sampled from a Haar measure:</p> <pre><code>from qadence import random_state\n\nrand_haar_state = random_state(n_qubits, batch_size)\n</code></pre> <pre><code>Random state from Haar = \n\ntensor([[-0.1413-0.0314j,  0.4271+0.0558j,  0.1211-0.0650j, -0.2887-0.3458j,\n          0.1520-0.5908j, -0.2196-0.1824j,  0.0992-0.2272j,  0.2243+0.0795j],\n        [ 0.3506+0.1673j,  0.0850-0.2147j, -0.0631+0.6737j,  0.0306+0.2123j,\n          0.3492+0.2833j,  0.0531-0.1610j,  0.1590-0.0134j,  0.1670+0.0875j]])\n</code></pre> <p>Custom initial states can then be passed to either <code>run</code>, <code>sample</code> and <code>expectation</code> through the <code>state</code> argument</p> <pre><code>from qadence import random_state, product_state, CNOT, run\n\ninit_state = product_state(\"10\")\nfinal_state = run(CNOT(0, 1), state=init_state)\n</code></pre> <pre><code>Final state = tensor([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j]])\n</code></pre>"},{"location":"tutorials/state_init/#block-initialization","title":"Block initialization","text":"<p>Not all backends support custom statevector initialization, however previous utility functions have their counterparts to initialize the respective blocks:</p> <pre><code>from qadence import uniform_block, one_block\n\nn_qubits = 3\n\nuniform_block = uniform_block(n_qubits)\n\none_block = one_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u251c\u2500\u2500 H(1)\n\u2514\u2500\u2500 H(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>Similarly, for product states:</p> <pre><code>from qadence import product_block, rand_product_block\n\nproduct_block = product_block(\"100\")\n\nrand_product_block = rand_product_block(n_qubits)\n</code></pre> <pre><code>KronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 I(1)\n\u2514\u2500\u2500 I(2)\nKronBlock(0,1,2)\n\u251c\u2500\u2500 X(0)\n\u251c\u2500\u2500 X(1)\n\u2514\u2500\u2500 X(2)\n</code></pre> <p>And GHZ states:</p> <pre><code>from qadence import ghz_block\n\nghz_block = ghz_block(n_qubits)\n</code></pre> <pre><code>ChainBlock(0,1,2)\n\u251c\u2500\u2500 H(0)\n\u2514\u2500\u2500 ChainBlock(0,1,2)\n    \u251c\u2500\u2500 CNOT(0, 1)\n    \u2514\u2500\u2500 CNOT(1, 2)\n</code></pre> <p>Initial state blocks can simply be chained at the start of a given circuit.</p>"},{"location":"tutorials/state_init/#utility-functions","title":"Utility functions","text":"<p>Some state vector utility functions are also available. We can easily create the probability mass function of a given statevector using <code>torch.distributions.Categorical</code></p> <pre><code>from qadence import random_state, pmf\n\nn_qubits = 3\n\nstate = random_state(n_qubits)\ndistribution = pmf(state)\n</code></pre> <pre><code>Categorical(probs: torch.Size([1, 8]))\n</code></pre> <p>We can also check if a state is normalized:</p> <pre><code>from qadence import random_state, is_normalized\n\nstate = random_state(n_qubits)\nprint(is_normalized(state))\n</code></pre> <pre><code>True\n</code></pre> <p>Or normalize a state:</p> <pre><code>import torch\nfrom qadence import normalize, is_normalized\n\nstate = torch.tensor([[1, 1, 1, 1]], dtype = torch.cdouble)\nprint(normalize(state))\n</code></pre> <pre><code>tensor([[0.5000+0.j, 0.5000+0.j, 0.5000+0.j, 0.5000+0.j]])\n</code></pre>"}]}